[{"type": "Lean.CoreM (Array Lean.Name)",
  "offspring":
  ["Mathlib.Tactic.Lint.getDeclsInCurrModule",
   "ForIn.forIn",
   "ForInStep",
   "Array.getOp",
   "instInhabitedBool",
   "Array.push",
   "Array.map"],
  "name": "Mathlib.Tactic.Lint.getDeclsInMathlib"},
 {"type": "∀ (lo hi : ℤ), 0 ≤ Int.natAbs (hi - lo)",
  "offspring": ["Nat.zero_le"],
  "name":
  "Random.instBoundedRandomIntToPreorderToPartialOrderInstLinearOrderInt.proof_1"},
 {"type":
  "∀ {α : Type u_1} (self₁ : UnionFind α) (rx : Fin (UnionFind.size self₁)) (self₂ : UnionFind α),\n  UnionFind.size self₂ = UnionFind.size self₁ → ↑rx < UnionFind.size self₂",
  "offspring": ["Fin.isLt"],
  "name": "UnionFind.union.proof_2"},
 {"type": "∀ (m n : ℕ), Int.ofNat m * Int.negOfNat n = Int.negOfNat (m * n)",
  "offspring": [],
  "name": "Int.ofNat_mul_negOfNat"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : Fin (Array.size a)) (j : ℕ) (v : α),\n  Array.get? (Array.set a i v) j = if ↑i = j then some v else Array.get? a j",
  "offspring":
  ["if_pos", "Array.get?_set_eq", "if_neg", "Array.get?_set_ne", "ne_eq"],
  "name": "Array.get?_set"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {as : List α}, b ∈ List.remove a as → b ∈ as",
  "offspring": ["List.remove", "List.mem_remove_iff"],
  "name": "List.mem_of_mem_remove"},
 {"type": "{α : Type u} → ℕ → Array α → Array α",
  "offspring": ["Array.pop"],
  "name": "Array.shrink.loop"},
 {"type": "∀ {a b : ℕ}, ¬a ≤ b → b < a",
  "offspring": ["Or.resolve_right", "Nat.lt_or_ge"],
  "name": "Nat.lt_of_not_le"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (l : List α), (¬∃ x, x ∈ l ∧ ¬p x) → ∀ (x : α), x ∈ l → p x",
  "offspring": [],
  "name": "decidableBAll.proof_2"},
 {"type":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → Sort u_1 → MonadWithReader ρ m → MonadWithReader ρ m → Sort u_1",
  "offspring": [],
  "name": "MonadWithReader.noConfusionType"},
 {"type": "System.FilePath → String → System.FilePath",
  "offspring": ["System.FilePath.fileStem", "System.FilePath.withFileName"],
  "name": "System.FilePath.withExtension"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop}, (∃ x, p x) → b ↔ ∀ (x : α), p x → b",
  "offspring": [],
  "name": "exists_imp_distrib"},
 {"type": "USize → USize → Prop", "offspring": [], "name": "USize.le"},
 {"type": "∀ (x : ℕ) {z : ℕ}, 0 < z → (x + z) / z = Nat.succ (x / z)",
  "offspring": ["Nat.div_eq_sub_div", "Nat.le_add_left", "Nat.add_sub_cancel"],
  "name": "Nat.add_div_right"},
 {"type": "∀ (a : USize), -a + a = 0",
  "offspring":
  ["USize.eq_of_val_eq",
   "USize.neg_def",
   "USize.add_def",
   "USize.mk",
   "add_left_neg",
   "USize.zero_def"],
  "name": "USize.instRingUSize.proof_6"},
 {"type":
  "∀ (m n : ℕ) (P : ℕ → ℕ → ℤ → Prop),\n  (∀ (i n : ℕ), P (n + i) n (Int.ofNat i)) → (∀ (i m : ℕ), P m (m + i + 1) -[1+ i]) → P m n (Int.subNatNat m n)",
  "offspring": [],
  "name": "Int.subNatNat_elim"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (n_1 : ℕ) (a : Fin n),\n  AddGroupWithOne.gsmul -[1+ n_1] a = -AddGroupWithOne.gsmul (Int.ofNat (Nat.succ n_1)) a",
  "offspring": ["AddGroupWithOne.gsmul_neg'"],
  "name": "instCommRingFin.proof_4"},
 {"type": "∀ (a b : ℕ), a + b - a = b",
  "offspring":
  ["Nat.zero_eq",
   "Nat.zero_add",
   "Nat.sub_zero",
   "Nat.succ_add",
   "Nat.succ_sub_succ"],
  "name": "Nat.add_sub_self_left"},
 {"type":
  "∀ {α : Type u_1} (lt : α → α → Bool) (a : Array α) (i : Fin (Array.size a)),\n  Array.size (BinaryHeap.heapifyDown lt a i).val = Array.size a",
  "offspring": ["Subtype.property", "BinaryHeap.heapifyDown"],
  "name": "BinaryHeap.size_heapifyDown"},
 {"type": "∀ (n : ℕ), Nat.succ n ≠ n",
  "offspring": ["Nat.succ_ne_zero"],
  "name": "Nat.succ_ne_self"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Util.LibraryNote.commandLibrary_note___"},
 {"type": "{R : Type u} → [self : Ring R] → Semiring R",
  "offspring": [],
  "name": "Ring.toSemiring"},
 {"type": "{α : Type u_1} → [inst : OrOp α] → HOr α α α",
  "offspring": ["HOr.mk", "OrOp.or"],
  "name": "instHOr"},
 {"type": "∀ (a : UInt16), -a + a = 0",
  "offspring":
  ["UInt16.eq_of_val_eq",
   "UInt16.neg_def",
   "UInt16.add_def",
   "UInt16.mk",
   "add_left_neg",
   "UInt16.zero_def"],
  "name": "UInt16.instRingUInt16.proof_6"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a < b → max a b = b",
  "offspring": ["max_eq_right", "le_of_lt"],
  "name": "max_eq_right_of_lt"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [h : Nonempty β], Function.surjective Prod.fst",
  "offspring": ["Nonempty.elim"],
  "name": "Prod.fst_surjective"},
 {"type": "∀ {a b c : Prop}, (a → b) → c ∧ a → c ∧ b",
  "offspring": ["And.imp"],
  "name": "And.imp_right"},
 {"type": "{α : Type u} → Sort u_1 → Append α → Append α → Sort u_1",
  "offspring": [],
  "name": "Append.noConfusionType"},
 {"type": "CommRing USize",
  "offspring":
  ["CommRing.mk", "USize.instRingUSize", "USize.instCommRingUSize.proof_1"],
  "name": "USize.instCommRingUSize"},
 {"type": "Type (u + 1)",
  "offspring": ["Subtype", "Nonempty"],
  "name": "NonemptyType"},
 {"type": "{α : Type u} → [inst : BEq α] → α → List α → ℕ",
  "offspring": ["List.findIdx"],
  "name": "List.indexOf"},
 {"type":
  "{f : Type u → Type v} → [inst : Alternative f] → {α : Type u} → f α → f (Option α)",
  "offspring": ["HOrElse.hOrElse", "Functor.map"],
  "name": "optional"},
 {"type": "{n : ℕ} → (a b : Fin n) → Decidable (a ≤ b)",
  "offspring": ["Nat.decLe"],
  "name": "Fin.decLe"},
 {"type": "Type u → Type u", "offspring": [], "name": "NonAssocSemiring"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {o : Option α} {f : α → Option β},\n  Option.bind o f = none ↔ ∀ (b : β) (a : α), a ∈ o → ¬b ∈ f a",
  "offspring":
  ["Option.eq_none_iff_forall_not_mem",
   "Option.mem_def",
   "Option.bind_eq_some",
   "not_exists",
   "not_and",
   "Iff.rfl"],
  "name": "Option.bind_eq_none"},
 {"type": "Lean.ParametricAttribute (Array Lean.Name)",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.nolintAttr"},
 {"type": "∀ (n m k : ℕ), n * (m + k) = n * m + n * k",
  "offspring": ["Nat.left_distrib"],
  "name": "Nat.mul_add"},
 {"type": "∀ {a b c : ℤ}, -b + a ≤ c → a ≤ b + c",
  "offspring": ["Int.le_add_of_sub_left_le", "Int.add_comm"],
  "name": "Int.le_add_of_neg_add_le_left"},
 {"type": "∀ {m n : ℕ}, Nat.coprime m n ↔ Nat.gcd m n = 1",
  "offspring": ["Iff.rfl"],
  "name": "Nat.coprime_iff_gcd_eq_one"},
 {"type":
  "∀ {α : Sort u_1} [inst : SizeOf α] (f : Unit → α), sizeOf f = sizeOf (f ())",
  "offspring": [],
  "name": "sizeOf_thunk"},
 {"type": "∀ (a : UInt8), 1 * a = a",
  "offspring":
  ["UInt8.one_def", "UInt8.mul_def", "UInt8.mk", "one_mul", "UInt8.mk_val_eq"],
  "name": "UInt8.instSemiringUInt8.proof_13"},
 {"type": "Repr ℕ", "offspring": ["Nat.repr"], "name": "instReprNat"},
 {"type": "System.FilePath → List String",
  "offspring":
  ["System.FilePath.toString",
   "System.FilePath.normalize",
   "System.FilePath.pathSeparator"],
  "name": "System.FilePath.components"},
 {"type": "Sort u → Tactic.Ring.State → Tactic.Ring.State → Sort u",
  "offspring": [],
  "name": "Tactic.Ring.State.noConfusionType"},
 {"type": "{m : Type u → Type v} → [inst : Monad m] → MonadLift m (OptionT m)",
  "offspring": ["MonadLift.mk", "OptionT.lift"],
  "name": "OptionT.instMonadLiftOptionT"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} (a : α), ¬p a → (∃ a_1, a_1 ∈ some a ∧ p a_1) → False",
  "offspring": [],
  "name": "Option.decidable_exists_mem.proof_3"},
 {"type":
  "{ω : Type} → (σ : Type) → (m : Type → Type) → [inst : Monad m] → MonadFunctor m (StateRefT' ω σ m)",
  "offspring": [],
  "name": "StateRefT'.instMonadFunctorStateRefT'"},
 {"type": "∀ {x y : ℕ}, Nat.le x y = (x ≤ y)",
  "offspring": [],
  "name": "Nat.le_eq"},
 {"type": "∀ (a b : UInt8), a - b = { val := a.val - b.val }",
  "offspring": [],
  "name": "UInt8.sub_def"},
 {"type":
  "{M : Type u} → [toMonoid : Monoid M] → (∀ (a b : M), a * b = b * a) → CommMonoid M",
  "offspring": [],
  "name": "CommMonoid.mk"},
 {"type": "LawfulMonad Id",
  "offspring": ["LawfulMonad.mk"],
  "name": "Id.instLawfulMonadIdInstMonadId.proof_1"},
 {"type": "ℤ → ℤ → ℤ", "offspring": [], "name": "Int.sub"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), Nat.xor a b % n < n",
  "offspring": [],
  "name": "Fin.xor.proof_1"},
 {"type": "∀ {α : Type u}, List.length [] = 0",
  "offspring": [],
  "name": "List.length_nil"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (self : α ≃ β), Function.LeftInverse self.invFun self.toFun",
  "offspring": [],
  "name": "Equiv.left_inv"},
 {"type": "∀ {n m : ℕ}, n < m → m ≤ n → False",
  "offspring": ["Nat.le_lt_antisymm"],
  "name": "Nat.lt_le_antisymm"},
 {"type": "∀ {a b c : ℤ}, a + b = a + c → b = c",
  "offspring": [],
  "name": "Int.add_left_cancel"},
 {"type": "∀ {p : Prop} [s : Decidable p], decide p = true → p",
  "offspring": ["ne_true_of_eq_false", "decide_eq_false"],
  "name": "of_decide_eq_true"},
 {"type": "∀ {α : Type u_1} (l : List α), List.map id l = l",
  "offspring": ["id_eq"],
  "name": "List.map_id"},
 {"type": "{α : Sort u} → {β : Sort v} → Sort u_1 → α ⊕' β → α ⊕' β → Sort u_1",
  "offspring": [],
  "name": "PSum.noConfusionType"},
 {"type": "∀ {a b : Prop}, ¬(a ↔ b) ↔ (¬a ↔ b)",
  "offspring": ["Decidable.not_iff"],
  "name": "not_iff"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {as : List α}, a ∈ as → List.card as = List.card (List.remove a as) + 1",
  "offspring": ["List.not_mem_nil", "Subsingleton.elim", "if_pos"],
  "name": "List.card_remove_of_mem"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.injective f → ∀ {x y : α} {z : β}, f y = z → (f x ≠ z ↔ x ≠ y)",
  "offspring": ["Function.injective.ne_iff"],
  "name": "Function.injective.ne_iff'"},
 {"type":
  "∀ (n m : Fin UInt8.size), ¬n = m → { val := n } = { val := m } → False",
  "offspring": [],
  "name": "UInt8.decEq.proof_2"},
 {"type":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], a ∧ b ↔ ¬(¬a ∨ ¬b)",
  "offspring": ["Decidable.not_and_distrib", "Decidable.not_not", "Iff.rfl"],
  "name": "Decidable.and_iff_not_or_not"},
 {"type": "{ε σ α : Type u} → EStateM ε σ α → σ → EStateM.Result ε σ α",
  "offspring": [],
  "name": "EStateM.run"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β},\n  Function.surjective f → ∀ {p : β → β → Prop}, (∀ (y₁ y₂ : β), p y₁ y₂) ↔ ∀ (x₁ x₂ : α), p (f x₁) (f x₂)",
  "offspring": ["Iff.trans", "Function.surjective.forall", "forall_congr'"],
  "name": "Function.surjective.forall₂"},
 {"type":
  "∀ {α : Type u} (n : ℕ) (a : α), List.length (List.replicate n a) = n",
  "offspring":
  ["List.length_nil", "Nat.zero_eq", "List.length_cons", "List.replicate"],
  "name": "List.length_replicate"},
 {"type": "{α : Type u} → {β : Type v} → α × β → α",
  "offspring": [],
  "name": "Prod.fst"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m β",
  "offspring": [],
  "name": "Array.foldlMUnsafe"},
 {"type": "∀ {a a_1 : ℕ}, Sat.Literal.pos a = Sat.Literal.pos a_1 → a = a_1",
  "offspring": [],
  "name": "Sat.Literal.pos.inj"},
 {"type": "Repr Tactic.NormCast.CoeFnInfo",
  "offspring":
  ["repr",
   "instReprNat",
   "Tactic.NormCast.CoeFnInfo.numArgs",
   "Tactic.NormCast.CoeFnInfo.coercee",
   "Tactic.NormCast.CoeFnType",
   "Tactic.NormCast.instReprCoeFnType",
   "Tactic.NormCast.CoeFnInfo.type"],
  "name": "Tactic.NormCast.instReprCoeFnInfo"},
 {"type": "∀ (p : Prop), p ∨ ¬p", "offspring": [], "name": "em"},
 {"type":
  "∀ {p : Prop} {α : Sort u_1} [inst : Nonempty α] (P : α → Prop) (f : p → α) (a : p), P (f a) → P (Function.sometimes f)",
  "offspring": ["Function.sometimes_eq"],
  "name": "Function.sometimes_spec"},
 {"type": "∀ {α : Type u} {x : α}, List.getLast [x] (_ : [x] ≠ []) = x",
  "offspring": [],
  "name": "List.getLast_singleton"},
 {"type": "UInt64 → ℕ → UInt64",
  "offspring": ["UInt64.mk"],
  "name": "UInt64.modn"},
 {"type": "0 < 1", "offspring": ["Int.NonNeg.mk"], "name": "Int.zero_lt_one"},
 {"type":
  "Tactic.Ring.HornerExpr →\n  Lean.Expr × ℕ → Lean.Expr × ℕ → Tactic.Ring.HornerExpr → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring":
  ["Tactic.Ring.HornerExpr.const",
   "Tactic.Ring.HornerExpr.xadd",
   "Tactic.Ring.mkAppCS",
   "Tactic.Ring.HornerExpr.e",
   "Tactic.Ring.HornerExpr.xadd'",
   "Tactic.Ring.HornerExpr.reflConv"],
  "name": "Tactic.Ring.evalHorner"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] (a : α) (l : List α),\n  List.erasep p (a :: l) = if p a then l else a :: List.erasep p l",
  "offspring": [],
  "name": "List.erasep_cons"},
 {"type": "(a b : UInt16) → Decidable (a < b)",
  "offspring": [],
  "name": "UInt16.decLt"},
 {"type":
  "∀ {α : Type u_1} {a : α} (l₁ : List α) {l₂ : List α}, a ∈ l₂ → a ∈ l₁ ++ l₂",
  "offspring": ["List.mem_append"],
  "name": "List.mem_append_right"},
 {"type": "Type u → outParam (Type v) → Type (max u v)",
  "offspring": [],
  "name": "Stream"},
 {"type": "∀ (n : ℕ), sizeOf n = n", "offspring": [], "name": "sizeOf_nat"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → MonadReaderOf ρ (ReaderT ρ m)",
  "offspring": ["MonadReaderOf.mk"],
  "name": "instMonadReaderOfReaderT"},
 {"type":
  "∀ {α : Sort u_3} {β : Sort u_2} {γ : Sort u_1} {f : α → β} {g : γ → α},\n  Function.surjective (f ∘ g) → Function.surjective f",
  "offspring": [],
  "name": "Function.surjective.of_comp"},
 {"type": "ℕ → Sat.Literal", "offspring": [], "name": "Sat.Literal.neg"},
 {"type": "∀ (n : ℕ), n * 1 = n",
  "offspring": ["Nat.zero_add"],
  "name": "Nat.mul_one"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Mathlib.ExtendedBinder.extBinder"],
  "name": "Set.«term{_|_}»"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a = a' ∧ p a) ↔ p a'",
  "offspring": [],
  "name": "exists_eq_left"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α) (b : α) (bs : List α), ¬a = b → a :: as = b :: bs → False",
  "offspring": [],
  "name": "List.hasDecEq.proof_6"},
 {"type": "∀ {α : Type u_1} {l : List α} {a : α}, List.disjoint l [a] ↔ ¬a ∈ l",
  "offspring":
  ["List.disjoint", "List.disjoint_comm", "List.singleton_disjoint", "Iff.rfl"],
  "name": "List.disjoint_singleton"},
 {"type": "∀ {a b : ℤ}, a < 0 → b < 0 → a + b < 0",
  "offspring": ["Int.add_lt_add", "Int.zero_add"],
  "name": "Int.add_neg"},
 {"type": "{α : Type u} → [inst : Inhabited α] → Option α → α",
  "offspring": ["panicWithPosWithDecl"],
  "name": "Option.get!"},
 {"type":
  "∀ {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop},\n  (∀ (a : α), Acc ra a) → (∀ (b : β), Acc rb b) → ∀ (a : α) (b : β), Acc (Prod.Lex ra rb) (a, b)",
  "offspring": ["Prod.lexAccessible.proof_1"],
  "name": "Prod.lexAccessible"},
 {"type": "∀ {α : Sort u_1} {a : α}, a = a",
  "offspring": [],
  "name": "rfl.proof_1"},
 {"type":
  "(σ : Type u) → {m : Type u → Type v} → [inst : MonadStateOf σ m] → (σ → σ) → m PUnit",
  "offspring": ["MonadStateOf.modifyGet"],
  "name": "modifyThe"},
 {"type": "ℕ → ℕ", "offspring": [], "name": "Nat.succ"},
 {"type": "CommRing UInt16",
  "offspring":
  ["CommRing.mk", "UInt16.instRingUInt16", "UInt16.instCommRingUInt16.proof_1"],
  "name": "UInt16.instCommRingUInt16"},
 {"type": "Type u → Type u", "offspring": [], "name": "Sdiff"},
 {"type": "{α : Type u} → α → Option α",
  "offspring": [],
  "name": "Option.some"},
 {"type": "UInt8 → UInt8 → Prop", "offspring": [], "name": "UInt8.lt"},
 {"type":
  "∀ {α : Type u_1} (lt : α → α → Bool) (i : ℕ) (a : Array α),\n  i + 1 ≤ Array.size a →\n    ∀ (a₂ : Array α),\n      Array.size a₂ = Array.size (BinaryHeap.heapifyDown lt a { val := i, isLt := (_ : i < Array.size a) }).val →\n        Array.size a₂ = Array.size a",
  "offspring":
  ["Subtype.property",
   "BinaryHeap.heapifyDown",
   "BinaryHeap.mkHeap.loop.proof_2"],
  "name": "BinaryHeap.mkHeap.loop.proof_4"},
 {"type": "(n m : ℕ) → Decidable (n < m)",
  "offspring": ["Nat.decLe"],
  "name": "Nat.decLt"},
 {"type": "{α : Type u} → {β : Type v} → List α → (α → List β) → List β",
  "offspring": ["List.join", "List.map"],
  "name": "List.bind"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a : α), min a a = a",
  "offspring": ["le_refl", "ite_self"],
  "name": "min_self"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop} {a' : α}, (∃ a, p a ∧ b ∧ a' = a) ↔ p a' ∧ b",
  "offspring": [],
  "name": "exists_eq_right_right'"},
 {"type": "Substring → (Char → Bool) → Substring",
  "offspring": ["Substring.mk"],
  "name": "Substring.takeRightWhile"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk", "Fin.lor", "UInt64.size"],
  "name": "UInt64.lor"},
 {"type": "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), 0 * a = 0",
  "offspring": [],
  "name": "MulZeroOneClass.zero_mul"},
 {"type": "Mathlib.Tactic.Lint.Linter → Bool",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.isFast"},
 {"type": "{α : Type u} → Subarray α → ℕ",
  "offspring": [],
  "name": "Subarray.start"},
 {"type":
  "Sort u → Mathlib.Tactic.Lint.SimpTheoremInfo → Mathlib.Tactic.Lint.SimpTheoremInfo → Sort u",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.noConfusionType"},
 {"type":
  "∀ (x : ℕ) (a : UInt16),\n  { val := Ring.gsmul -[1+ x] a.val } =\n    { val := (-(fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat (Nat.succ x)) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_neg'"],
  "name": "UInt16.instRingUInt16.proof_5"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "List.«term_~_»"},
 {"type":
  "{f : Type u → Type v} → [self : Alternative f] → {α : Type u} → f α → (Unit → f α) → f α",
  "offspring": [],
  "name": "Alternative.orElse"},
 {"type": "true = false → Bool.noConfusionType False true false",
  "offspring": [],
  "name": "instDecidableEqBool.proof_2"},
 {"type":
  "{α : Sort u} → {β : Sort v} → Sort u_1 → Coe α β → Coe α β → Sort u_1",
  "offspring": [],
  "name": "Coe.noConfusionType"},
 {"type": "OrOp UInt8",
  "offspring": ["OrOp.mk", "UInt8.lor"],
  "name": "instOrOpUInt8"},
 {"type":
  "∀ {α : Sort u} [inst : DecidableEq α] {β : Sort u_1} (f : α → β) (a' : α) (b : β) (a : α),\n  Function.update f a' b a = if a = a' then b else f a",
  "offspring": [],
  "name": "Function.update_apply"},
 {"type": "Sort u → Sort u", "offspring": [], "name": "outParam"},
 {"type": "∀ (m : ℕ), Nat.succ m = Nat.succ m",
  "offspring": [],
  "name": "Nat.discriminate.proof_2"},
 {"type":
  "{α : Type} → {m : Type → Type w} → [inst : Monad m] → Array α → (α → m Bool) → m (Option α)",
  "offspring": ["Array.findSomeRevM?"],
  "name": "Array.findRevM?"},
 {"type": "∀ (m n : ℕ), m / n * n ≤ m",
  "offspring":
  ["Nat.div_zero",
   "Nat.mul_zero",
   "Nat.zero_le",
   "Nat.le_div_iff_mul_le",
   "Nat.succ_pos",
   "Nat.le_refl"],
  "name": "Nat.div_mul_le_self"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → [inst : Monad m] → {α : Type u} → m α → ExceptT ε m α",
  "offspring": ["ExceptT.mk", "Functor.map", "Except.ok"],
  "name": "ExceptT.lift"},
 {"type": "ToString UInt32",
  "offspring": ["ToString.mk", "instToStringNat", "UInt32.toNat"],
  "name": "instToStringUInt32"},
 {"type": "{α : Type u} → (α → α → α) → α → Prop",
  "offspring": [],
  "name": "left_identity"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk", "HShiftLeft.hShiftLeft", "UInt64.modn"],
  "name": "UInt64.shiftLeft"},
 {"type": "{G : Type u} → Sort u_1 → Group G → Group G → Sort u_1",
  "offspring": [],
  "name": "Group.noConfusionType"},
 {"type": "ℕ → Nat.Linear.Var → Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["cond", "Nat.blt"],
  "name": "Nat.Linear.Poly.insertSorted"},
 {"type": "{m n k : ℕ} → k ∣ m * n → { d // k = d.fst.val * d.snd.val }",
  "offspring":
  ["Nat.gcd",
   "Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1",
   "Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2",
   "Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4"],
  "name": "Nat.prod_dvd_and_dvd_of_dvd_prod"},
 {"type": "{ε : Type u_1} → {m : Type u_1 → Type u_2} → Monad (ExceptCpsT ε m)",
  "offspring": ["Monad.mk"],
  "name": "ExceptCpsT.instMonadExceptCpsT"},
 {"type": "ℕ → ℕ → ℤ", "offspring": [], "name": "Int.subNatNat"},
 {"type": "∀ (a : ℕ), sizeOf (Sat.Literal.neg a) = 1 + sizeOf a",
  "offspring": ["instSizeOfNat"],
  "name": "Sat.Literal.neg.sizeOf_spec"},
 {"type": "∀ {p : Prop} {d : Decidable p}, toBoolUsing d = true → p",
  "offspring": [],
  "name": "ofBoolUsing_eq_true"},
 {"type": "Bool", "offspring": [], "name": "Bool.false"},
 {"type": "{α : Type u_1} → List (Option α) → Option (List α)",
  "offspring": ["Functor.map", "Option.instFunctorOption"],
  "name": "List.allSome"},
 {"type": "∀ (a b : UInt8), a % b = { val := a.val % b.val }",
  "offspring": [],
  "name": "UInt8.mod_def"},
 {"type": "∀ {a b : Prop}, (a → b) → (a ∨ b ↔ b)",
  "offspring": [],
  "name": "or_iff_right_of_imp"},
 {"type": "∀ (n : ℕ), Int.sign ↑(Nat.succ n) = 1",
  "offspring": [],
  "name": "Int.sign_of_succ"},
 {"type":
  "∀ {α : Type u} (as bs : List α), List.reverse (as ++ bs) = List.reverse bs ++ List.reverse as",
  "offspring":
  ["List.reverse",
   "List.nil_append",
   "List.reverse_nil",
   "List.append_nil",
   "List.cons_append",
   "List.reverse_cons",
   "List.append_assoc"],
  "name": "List.reverse_append"},
 {"type": "Prop → Prop → Prop", "offspring": [], "name": "xor"},
 {"type": "1 = { val := 1 }", "offspring": [], "name": "UInt16.one_def"},
 {"type":
  "{σ : Type u} →\n  {m : Type u → Type v} → {n : Type u → Type w} → [inst : MonadLift m n] → [inst : MonadStateOf σ m] → MonadStateOf σ n",
  "offspring":
  ["MonadStateOf.mk",
   "MonadStateOf.get",
   "MonadStateOf.set",
   "MonadLiftT.monadLift",
   "MonadState.modifyGet"],
  "name": "instMonadStateOf"},
 {"type": "∀ (m : ℕ) {n : ℕ}, 0 < n → n * m / n = m",
  "offspring": ["Nat.mul_div_cancel"],
  "name": "Nat.mul_div_cancel_left"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {γ : Sort u_1} {p q : α → β → γ → Prop},\n  (∀ (a : α) (b : β) (c : γ), p a b c ↔ q a b c) → ((∃ a b c, p a b c) ↔ ∃ a b c, q a b c)",
  "offspring": ["exists_congr", "exists₂_congr"],
  "name": "exists₃_congr"},
 {"type": "∀ (val : floatSpec.float), sizeOf { val := val } = 1 + sizeOf val",
  "offspring": [],
  "name": "Float.mk.sizeOf_spec"},
 {"type":
  "∀ {A : Type u} [inst : AddCommSemigroup A] (a b c : A), a + b + c = a + c + b",
  "offspring": ["add_assoc", "add_comm"],
  "name": "add_right_comm"},
 {"type": "Hashable UInt8",
  "offspring": ["Hashable.mk", "UInt8.toUInt64"],
  "name": "instHashableUInt8"},
 {"type":
  "{G₀ : Type u} →\n  [toDivInvMonoid : DivInvMonoid G₀] →\n    [toZero : Zero G₀] →\n      (∀ (a : G₀), 0 * a = 0) →\n        (∀ (a : G₀), a * 0 = 0) → (∃ x y, x ≠ y) → 0⁻¹ = 0 → (∀ (a : G₀), a ≠ 0 → a * a⁻¹ = 1) → GroupWithZero G₀",
  "offspring": [],
  "name": "GroupWithZero.mk"},
 {"type":
  "∀ {α : Sort u_1} {φ : α → Sort u_2} {a a' : α} (h : a = a') (p : φ a), HEq (Eq.recOn h p) p",
  "offspring": ["eqRec_heq"],
  "name": "eq_rec_heq"},
 {"type": "∀ {a : ℤ}, -a ≤ 0 → 0 ≤ a",
  "offspring": ["Int.le_of_neg_le_neg", "Int.neg_zero"],
  "name": "Int.nonneg_of_neg_nonpos"},
 {"type": "∀ {a b : ℕ}, ¬a ≤ b → b ≤ a",
  "offspring": ["Or.resolve_left", "Nat.le_or_le"],
  "name": "Nat.le_of_not_le"},
 {"type":
  "{α : Type u} → {n : ℕ} → Sort u_1 → OfNat α n → OfNat α n → Sort u_1",
  "offspring": [],
  "name": "OfNat.noConfusionType"},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → List α → List β → List β",
  "offspring": ["List.reverse"],
  "name": "List.mapTRAux"},
 {"type": "Mul UInt64",
  "offspring": ["Mul.mk", "UInt64.mul"],
  "name": "instMulUInt64"},
 {"type":
  "∀ {atoms : Array Lean.Expr} {numAtoms : ℕ} {atoms_1 : Array Lean.Expr} {numAtoms_1 : ℕ},\n  { atoms := atoms, numAtoms := numAtoms } = { atoms := atoms_1, numAtoms := numAtoms_1 } →\n    atoms = atoms_1 ∧ numAtoms = numAtoms_1",
  "offspring": [],
  "name": "Tactic.Ring.State.mk.inj"},
 {"type": "Unit", "offspring": [], "name": "Unit.unit"},
 {"type": "Float → Float", "offspring": [], "name": "Float.exp2"},
 {"type": "∀ {R : Type u} [self : Ring R] (a b : R), a - b = a + -b",
  "offspring": [],
  "name": "Ring.sub_eq_add_neg"},
 {"type":
  "∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] (a b : α), (a == b) = true → a = b",
  "offspring": [],
  "name": "LawfulBEq.eq_of_beq"},
 {"type": "Inhabited Bool", "offspring": [], "name": "instInhabitedBool"},
 {"type":
  "∀ (e : Lean.Expr) (a : Tactic.Ring.HornerExpr) (x n : Lean.Expr × ℕ) (b : Tactic.Ring.HornerExpr) (e_1 : Lean.Expr)\n  (a_1 : Tactic.Ring.HornerExpr) (x_1 n_1 : Lean.Expr × ℕ) (b_1 : Tactic.Ring.HornerExpr),\n  (Tactic.Ring.HornerExpr.xadd e a x n b = Tactic.Ring.HornerExpr.xadd e_1 a_1 x_1 n_1 b_1) =\n    (e = e_1 ∧ a = a_1 ∧ x = x_1 ∧ n = n_1 ∧ b = b_1)",
  "offspring": ["Tactic.Ring.HornerExpr", "Tactic.Ring.HornerExpr.xadd"],
  "name": "Tactic.Ring.HornerExpr.xadd.injEq"},
 {"type": "∀ (a b : ℕ), a < b ∨ a = b ∨ b < a",
  "offspring": ["Nat.lt_by_cases"],
  "name": "Nat.lt_trichotomy"},
 {"type": "∀ {p q : Prop}, ¬p → p → q",
  "offspring": [],
  "name": "instDecidableForAll.proof_3"},
 {"type":
  "Tactic.Ring.HornerExpr → Tactic.Ring.HornerExpr → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring": [],
  "name": "Tactic.Ring.evalAdd"},
 {"type": "∀ {R : Type u_1} [inst : Ring R] (a b : R), -(a * b) = -a * b",
  "offspring":
  ["eq_of_sub_eq_zero'",
   "SubNegMonoid.sub_eq_add_neg",
   "neg_neg",
   "add_mul",
   "neg_add_self",
   "MonoidWithZero.zero_mul"],
  "name": "neg_mul_eq_neg_mul"},
 {"type":
  "∀ {α : Type u_1} {i : ℕ} (as bs : List α) (h : i < List.length as) {h' : i < List.length (as ++ bs)},\n  List.get (as ++ bs) { val := i, isLt := h' } = List.get as { val := i, isLt := h }",
  "offspring": ["List.append"],
  "name": "List.get_append_left"},
 {"type": "sizeOf PUnit.unit = 1",
  "offspring": [],
  "name": "PUnit.unit.sizeOf_spec"},
 {"type": "Coe Tactic.Ring.HornerExpr Lean.Expr",
  "offspring": ["Coe.mk", "Tactic.Ring.HornerExpr.e"],
  "name": "Tactic.Ring.HornerExpr.instCoeHornerExprExpr"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExceptOf ε m] → {α : Type v} → ε → m α",
  "offspring": [],
  "name": "MonadExceptOf.throw"},
 {"type": "{M : Type u} → [inst : One M] → [inst : Mul M] → ℕ → M → M",
  "offspring": [],
  "name": "npow_rec"},
 {"type": "Inhabited (Sort u)", "offspring": [], "name": "instInhabitedSort"},
 {"type":
  "{α : Type u} → {m : Type → Type w} → [inst : Monad m] → (α → m Bool) → Subarray α → m Bool",
  "offspring": ["Array.allM", "Subarray.as", "Subarray.start", "Subarray.stop"],
  "name": "Subarray.allM"},
 {"type":
  "∀ {α : Type u_1} (f : α → α) (n : ℕ) (l : List α), List.length (List.modifyNth f n l) = List.length l",
  "offspring": ["List.modifyNthTail_length", "List.modifyHead"],
  "name": "List.modify_get?_length"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → (l : List α) → Decidable (∀ (x : α), x ∈ l → p x)",
  "offspring": ["decidableBAll.proof_1", "decidableBAll.proof_2"],
  "name": "decidableBAll"},
 {"type": "{G : Type u} → [self : Group G] → DivInvMonoid G",
  "offspring": [],
  "name": "Group.toDivInvMonoid"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.tacticApply_mod_cast_"},
 {"type":
  "{m : Type → Type} → [inst : Monad m] → Array Lean.Syntax → (Lean.Syntax → m Bool) → m (Array Lean.Syntax)",
  "offspring": [],
  "name": "Array.filterSepElemsM"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} (l : List α), p a → ∃ x, x ∈ a :: l ∧ p x",
  "offspring": ["List.mem_cons_self"],
  "name": "List.exists_mem_cons_of"},
 {"type":
  "∀ (b f n : ℕ) (l1 l2 : List Char),\n  List.length l1 = List.length l2 → List.length (Nat.toDigitsCore b f n l1) = List.length (Nat.toDigitsCore b f n l2)",
  "offspring": ["if_true", "instDecidableFalse", "if_false", "trivial"],
  "name": "Nat.to_digits_core_lens_eq_aux"},
 {"type": "-Int.ofNat 0 = 0", "offspring": [], "name": "Int.neg_ofNat_zero"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "timeCmd"},
 {"type": "Type", "offspring": [], "name": "FloatArray"},
 {"type": "∀ {α : Type u} (a : α), { down := a }.down = a",
  "offspring": [],
  "name": "ULift.down_up"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "termS!_"},
 {"type": "∀ (n : ℕ), Int.ofNat (Nat.succ n) = Int.ofNat n + 1",
  "offspring": [],
  "name": "Int.ofNat_succ"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {b : β},\n  (¬∃ a, f a = b) → Function.inv_fun f b = Classical.choice n",
  "offspring": ["Function.inv_fun_on_neg", "mt"],
  "name": "Function.inv_fun_neg"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : Array α), (Array.isEqv a b fun x y => decide (x = y)) = true → a = b",
  "offspring":
  ["dif_pos",
   "dif_neg",
   "eq_false'",
   "of_decide_eq_false",
   "instDecidableFalse",
   "Decidable.decide"],
  "name": "Array.eq_of_isEqv"},
 {"type": "∀ (a : UInt32), { val := a.val } = a",
  "offspring": ["UInt32.size", "UInt32.mk"],
  "name": "UInt32.mk_val_eq"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε α β : Type u_1} {f : α → ExceptT ε m β} [inst : Monad m] (x : ExceptT ε m α),\n  ExceptT.run (x >>= f) = do\n    let x ← ExceptT.run x\n    match x with\n      | Except.ok x => ExceptT.run (f x)\n      | Except.error e => pure (Except.error e)",
  "offspring": [],
  "name": "ExceptT.run_bind"},
 {"type": "∀ {α : Sort u} {r : α → α → Prop} (a b : α), r a b → TC r a b",
  "offspring": [],
  "name": "TC.base"},
 {"type":
  "∀ (m n : ℕ) (c : ℤ), Int.ofNat m + Int.ofNat n + c = Int.ofNat m + (Int.ofNat n + c)",
  "offspring":
  ["Int.ofNat_add_ofNat",
   "Nat.add_assoc",
   "Int.ofNat_add_negSucc_ofNat",
   "Int.subNatNat_add",
   "Int.subNatNat"],
  "name": "Int.add_assoc_aux1"},
 {"type":
  "∀ {α : Type u} {as : Array α} {start stop : ℕ} {h₁ : start ≤ stop} {h₂ : stop ≤ Array.size as} {as_1 : Array α}\n  {start_1 stop_1 : ℕ} {h₁_1 : start_1 ≤ stop_1} {h₂_1 : stop_1 ≤ Array.size as_1},\n  { as := as, start := start, stop := stop, h₁ := h₁, h₂ := h₂ } =\n      { as := as_1, start := start_1, stop := stop_1, h₁ := h₁_1, h₂ := h₂_1 } →\n    as = as_1 ∧ start = start_1 ∧ stop = stop_1",
  "offspring": [],
  "name": "Subarray.mk.inj"},
 {"type": "FloatArray → Bool",
  "offspring": ["instBEqNat", "FloatArray.size"],
  "name": "FloatArray.isEmpty"},
 {"type": "¬False", "offspring": [], "name": "not_false"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) {c : Nat.Linear.PolyCnstr},\n  Nat.Linear.PolyCnstr.isValid c = true → Nat.Linear.PolyCnstr.denote ctx c = True",
  "offspring":
  ["Nat.Linear.PolyCnstr",
   "Nat.Linear.Poly.isZero",
   "cond_true",
   "Bool.and_eq_true",
   "Nat.Linear.Poly.of_isZero",
   "Bool.of_not_eq_true",
   "cond_false"],
  "name": "Nat.Linear.PolyCnstr.eq_true_of_isValid"},
 {"type": "∀ (a b c : ℤ), a * (b + c) = a * b + a * c",
  "offspring":
  ["Int.ofNat_add_ofNat",
   "Int.ofNat_mul_ofNat",
   "Nat.left_distrib",
   "Int.ofNat_add_negSucc_ofNat",
   "Int.ofNat_mul_subNatNat",
   "Int.ofNat_mul_negSucc_ofNat",
   "Int.negOfNat_eq_subNatNat_zero",
   "Int.subNatNat",
   "Int.subNatNat_add",
   "Int.negSucc_ofNat_add_ofNat",
   "Int.add_comm",
   "Int.negSucc_ofNat_add_negSucc_ofNat",
   "Int.negOfNat_add",
   "Int.negOfNat",
   "Nat.succ_add",
   "Int.negSucc_ofNat_ofNat",
   "Nat.right_distrib",
   "Int.negSucc_ofNat_mul_subNatNat",
   "Int.mul_negSucc_ofNat_negSucc_ofNat",
   "Int.ofNat.injEq"],
  "name": "Int.distrib_left"},
 {"type": "{α : Type u} → (α → Bool) → Subarray α → Bool",
  "offspring": ["Id.run", "Subarray.allM", "Id.instMonadId"],
  "name": "Subarray.all"},
 {"type": "Substring → Bool",
  "offspring": ["Substring.all"],
  "name": "Substring.isNat"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.Find.«tactic#find_»"},
 {"type": "∀ (m n : ℕ), Nat.gcd (Nat.gcd m n) m = Nat.gcd m n",
  "offspring": ["Nat.gcd", "Nat.gcd_comm", "Nat.gcd_gcd_self_left_right"],
  "name": "Nat.gcd_gcd_self_left_left"},
 {"type": "{σ : Type u_1} → {m : Type u_1 → Type u_2} → Monad (StateCpsT σ m)",
  "offspring": ["Monad.mk"],
  "name": "StateCpsT.instMonadStateCpsT"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} [inst : Setoid α] {s t u : Subtype p}, s ≈ t → t ≈ u → s ≈ u",
  "offspring": ["Setoid.trans"],
  "name": "Subtype.trans"},
 {"type":
  "{α : Type u} → Sort u_1 → OfScientific α → OfScientific α → Sort u_1",
  "offspring": [],
  "name": "OfScientific.noConfusionType"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {g₁ g₂ : β → α},\n  Function.LeftInverse g₁ f → Function.RightInverse g₂ f → g₁ = g₂",
  "offspring": [],
  "name": "Function.LeftInverse.eq_RightInverse"},
 {"type":
  "{α₁ α₂ α₃ β : Type u} → (α₁ → α₂ → α₃ → β) → ((α₁ → α₂ → α₃ → β) → α₁ → α₂ → α₃ → β) → ℕ → α₁ → α₂ → α₃ → β",
  "offspring": [],
  "name": "bfix3"},
 {"type":
  "∀ {G : Type u} [inst : Mul G] [self : IsMulLeftCancel G] (a b c : G), a * b = a * c → b = c",
  "offspring": [],
  "name": "IsMulLeftCancel.mul_left_cancel"},
 {"type": "∀ {a : Prop}, (∀ (b : Prop), (a → b) → a) → a",
  "offspring": [],
  "name": "peirce'"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {b b' : (a : α) → β a} (a : α),\n  (∀ (x : α), b x = b' x) →\n    (let x := a;\n      b x) =\n      let x := a;\n      b' x",
  "offspring": [],
  "name": "let_body_congr"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.isInfix"},
 {"type": "ℤ → ℕ", "offspring": [], "name": "Int.natAbs"},
 {"type": "{α : Type u_1} → (List α → List α) → ℕ → List α → List α",
  "offspring": [],
  "name": "List.modifyNthTail"},
 {"type": "{α : Type u_1} → List α → Option (List α)",
  "offspring": [],
  "name": "List.tail?"},
 {"type": "∀ {n : ℕ} (a b : Fin n), a * b = b * a",
  "offspring": ["CommSemigroup.mul_comm"],
  "name": "instCommSemiringFin.proof_12"},
 {"type": "ReprAtom String",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomString"},
 {"type": "∀ {P : Prop} (h : P), (_ : P) = h",
  "offspring": [],
  "name": "iff_mpr_iff_true_intro"},
 {"type": "∀ (n m : ℕ), Nat.pred n * m = n * m - m",
  "offspring":
  ["Nat.zero_eq",
   "Nat.pred_zero",
   "Nat.zero_mul",
   "Nat.zero_sub",
   "Nat.pred_succ",
   "Nat.succ_mul",
   "Nat.add_sub_cancel"],
  "name": "Nat.mul_pred_left"},
 {"type": "∀ (a : UInt32), 0 * a = 0",
  "offspring":
  ["UInt32.zero_def", "UInt32.mul_def", "UInt32.mk", "MonoidWithZero.zero_mul"],
  "name": "UInt32.instSemiringUInt32.proof_9"},
 {"type": "{α : Type u} → Sort u_1 → Div α → Div α → Sort u_1",
  "offspring": [],
  "name": "Div.noConfusionType"},
 {"type": "ℕ",
  "offspring": ["HPow.hPow", "System.Platform.numBits"],
  "name": "USize.size"},
 {"type": "∀ {b : Prop} (a : Prop), b → a ∨ b",
  "offspring": [],
  "name": "Or.intro_right"},
 {"type": "∀ (m n : ℕ), Nat.gcd m (Nat.gcd n m) = Nat.gcd n m",
  "offspring": ["Nat.gcd", "Nat.gcd_comm", "Nat.gcd_gcd_self_right_left"],
  "name": "Nat.gcd_gcd_self_right_right"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "Set.«term{_}»"},
 {"type":
  "∀ (id : ℕ) (lits proof : Array ℤ),\n  sizeOf (Mathlib.Tactic.Sat.LRATStep.add id lits proof) = 1 + sizeOf id + sizeOf lits + sizeOf proof",
  "offspring": ["instSizeOfNat"],
  "name": "Mathlib.Tactic.Sat.LRATStep.add.sizeOf_spec"},
 {"type": "∀ {a b c d : ℤ}, a < b → c ≤ d → a + c < b + d",
  "offspring":
  ["lt_of_lt_of_le", "Int.add_lt_add_right", "Int.add_le_add_left"],
  "name": "Int.add_lt_add_of_lt_of_le"},
 {"type": "∀ (k n m : ℕ), k + n - (k + m) = n - m",
  "offspring": ["Nat.add_sub_add_right"],
  "name": "Nat.add_sub_add_left"},
 {"type":
  "{M : Type u} →\n  [toSemigroup : Semigroup M] →\n    [toOne : One M] →\n      (∀ (a : M), 1 * a = a) →\n        (∀ (a : M), a * 1 = a) →\n          (npow : ℕ → M → M) →\n            (∀ (x : M), npow 0 x = 1) → (∀ (n : ℕ) (x : M), npow (Nat.succ n) x = x * npow n x) → Monoid M",
  "offspring": [],
  "name": "Monoid.mk"},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → Sort u_1 → WellFounded r → WellFounded r → Sort u_1",
  "offspring": [],
  "name": "WellFounded.noConfusionType"},
 {"type": "Hashable ℕ",
  "offspring": ["Hashable.mk", "UInt64.ofNat"],
  "name": "instHashableNat"},
 {"type":
  "∀ {m : Type u → Type u_1} {β γ σ : Type u} [inst : Monad m] (f : PUnit → StateCpsT σ m β) (s s' : σ) (k : β → σ → m γ),\n  StateCpsT.runK (set s' >>= f) s k = StateCpsT.runK (f PUnit.unit) s' k",
  "offspring": [],
  "name": "StateCpsT.runK_bind_set"},
 {"type": "ℕ → ℕ → Prop", "offspring": [], "name": "Nat.le"},
 {"type": "0 = { val := 0 }", "offspring": [], "name": "UInt16.zero_def"},
 {"type": "∀ {a b : ℤ}, a ≤ 0 → b ≤ 0 → a + b ≤ 0",
  "offspring": ["Int.add_le_add", "Int.zero_add"],
  "name": "Int.add_nonpos"},
 {"type":
  "{ε : Type u_1} → {α : Type u_2} → [inst : ToString ε] → [inst : ToString α] → ToString (Except ε α)",
  "offspring": ["ToString.mk"],
  "name": "instToStringExcept"},
 {"type": "AndOp UInt16",
  "offspring": ["AndOp.mk", "UInt16.land"],
  "name": "instAndOpUInt16"},
 {"type": "{α : Type u_1} → α → Set α → Set α",
  "offspring": ["setOf"],
  "name": "Set.insert"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (j : ℕ), j < Array.size as → 0 + j = Array.size as → False",
  "offspring": ["Nat.zero_add", "Nat.lt_irrefl"],
  "name": "Array.findIdx?.loop.proof_1"},
 {"type":
  "{α : Type u} →\n  {m : Type u → Type v} →\n    [inst : Monad m] → [inst : Inhabited α] → (α → α → Bool) → (α → m α) → (Unit → m α) → Array α → α → m (Array α)",
  "offspring":
  ["Array.isEmpty",
   "Array.push",
   "Array.get!",
   "Array.insertAt",
   "not",
   "Array.modifyM",
   "Array.back"],
  "name": "Array.binInsertM"},
 {"type":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : Sort u₃} → (β → β → φ) → (α → β) → α → α → φ",
  "offspring": [],
  "name": "Function.on_fun"},
 {"type": "∀ {n : ℕ} (a b c : Fin n), a * b * c = a * (b * c)",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Fin.mul_def",
   "Fin.size_positive",
   "Nat.mul_mod",
   "Nat.mod_eq_of_lt",
   "Fin.isLt",
   "Nat.mul_assoc"],
  "name": "instCommSemigroupFin.proof_1"},
 {"type": "∀ (a b : Bool), ((!a == b) = true) = ¬a = b",
  "offspring": [],
  "name": "Bool.not_beq_to_not_eq"},
 {"type": "{α : Type u} → (α → α → Prop) → LT α",
  "offspring": [],
  "name": "LT.mk"},
 {"type":
  "{α : Type u} → {β : Type v} → (α → α → Prop) → (β → β → Prop) → α × β → α × β → Prop",
  "offspring": [],
  "name": "Prod.RProd"},
 {"type": "Ord UInt32",
  "offspring": ["Ord.mk", "compareOfLessAndEq", "instLTUInt32"],
  "name": "instOrdUInt32"},
 {"type": "∀ {a : ℤ}, a ≤ 0 → 0 ≤ -a",
  "offspring": [],
  "name": "Int.neg_nonneg_of_nonpos"},
 {"type": "{α : Type u_1} → List α → List ℕ → List (List α) × List α",
  "offspring": ["List.splitAt"],
  "name": "List.takeList"},
 {"type": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "offspring": ["Decidable.byCases"],
  "name": "Decidable.byContradiction"},
 {"type": "{α : Type u} → Option α", "offspring": [], "name": "Option.none"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_4} {δ : Type u_2} (f : α → β → γ) (g : γ → δ),\n  Function.uncurry (Function.bicompr g f) = g ∘ Function.uncurry f",
  "offspring": [],
  "name": "Function.uncurry_bicompr"},
 {"type": "Sort u", "offspring": [], "name": "PEmpty"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.«termExt_proof%»"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk", "HDiv.hDiv"],
  "name": "UInt64.div"},
 {"type": "{n : ℕ} → Fin n → ℕ → Fin n",
  "offspring": ["Fin.modn.proof_1"],
  "name": "Fin.modn"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (i : ℕ), UnionFind.rank self i < UnionFind.rankMax self",
  "offspring": ["UnionFind.lt_rankMax'", "Nat.succ_pos"],
  "name": "UnionFind.lt_rankMax"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop}, WellFounded r → WellFounded (TC r)",
  "offspring": ["TC.wf.proof_1"],
  "name": "TC.wf"},
 {"type":
  "∀ {α : Type u} (as : List α) (i : ℕ) (a : α), List.length (List.set as i a) = List.length as",
  "offspring": ["List.length_cons", "List.set"],
  "name": "List.length_set"},
 {"type": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "offspring": [],
  "name": "MulZeroClass.toZero"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a ≤ c → b ≤ c → (∀ {d : α}, a ≤ d → b ≤ d → c ≤ d) → c = max a b",
  "offspring": ["le_antisymm", "le_max_left", "le_max_right", "max_le"],
  "name": "eq_max"},
 {"type":
  "∀ {α : Type u} [inst : LT α] (b : α) (bs : List α), List.lt [] (b :: bs)",
  "offspring": [],
  "name": "List.lt.nil"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) -[1+ x] = (fun n => { val := ↑n }) -[1+ x]",
  "offspring": [],
  "name": "USize.instRingUSize.proof_8"},
 {"type": "{α : Type u} → List α → ℕ → List α",
  "offspring": [],
  "name": "List.removeNth"},
 {"type":
  "{G : Type u} → [toSemigroup : Semigroup G] → (∀ (a b : G), a * b = b * a) → CommSemigroup G",
  "offspring": [],
  "name": "CommSemigroup.mk"},
 {"type": "∀ {p q : Prop}, p = q → ¬q → ¬p",
  "offspring": [],
  "name": "Eq.mpr_not"},
 {"type": "Type", "offspring": [], "name": "Tactic.Ring.HornerExpr"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (i : ℕ), i + 1 ≤ Array.size as → i < Array.size as",
  "offspring": ["Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "Array.foldrM.fold.proof_1"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["HDiv.hDiv", "Fin.div.proof_1"],
  "name": "Fin.div"},
 {"type": "∀ {a : ℤ}, a < 0 → Int.sign a = -1",
  "offspring": ["Int.eq_neg_succ_of_lt_zero"],
  "name": "Int.sign_eq_neg_one_of_neg"},
 {"type": "∀ (n : ℕ), Int.subNatNat n n = 0",
  "offspring":
  ["Int.subNatNat_of_sub_eq_zero", "Nat.sub_self", "Int.ofNat_zero"],
  "name": "Int.sub_nat_self"},
 {"type": "Mathlib.Tactic.Lint.LintVerbosity",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.high"},
 {"type":
  "∀ {α : Type u_1} {o₁ o₂ : Option α}, (∀ (a : α), a ∈ o₁ ↔ a ∈ o₂) → o₁ = o₂",
  "offspring": [],
  "name": "Option.ext"},
 {"type":
  "∀ {ε : Type u} {α : Type v} [inst : SizeOf ε] [inst_1 : SizeOf α] (a : ε), sizeOf (Except.error a) = 1 + sizeOf a",
  "offspring": [],
  "name": "Except.error.sizeOf_spec"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {a : α} {f : α → β}, Option.map f (some a) = some (f a)",
  "offspring": [],
  "name": "Option.map_some'"},
 {"type": "Bool → Bool → Bool", "offspring": [], "name": "strictAnd"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HShiftRight α β γ → HShiftRight α β γ → Sort u_1",
  "offspring": [],
  "name": "HShiftRight.noConfusionType"},
 {"type": "∀ (a : ℤ), a + -a = 0",
  "offspring": ["Int.add_comm", "Int.add_left_neg"],
  "name": "Int.add_right_neg"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "guardHyp"},
 {"type": "{n : ℕ} → CommSemigroup (Fin n)",
  "offspring": ["CommSemigroup.mk", "instCommSemigroupFin.proof_2"],
  "name": "instCommSemigroupFin"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["HDiv.hDiv"], "name": "Nat.shiftRight"},
 {"type": "∀ (a : UInt8), -a + a = 0",
  "offspring":
  ["UInt8.eq_of_val_eq",
   "UInt8.neg_def",
   "UInt8.add_def",
   "UInt8.mk",
   "add_left_neg",
   "UInt8.zero_def"],
  "name": "UInt8.instRingUInt8.proof_6"},
 {"type": "∀ {α : Type u_1} {β : Type u_2}, Function.injective Prod.swap",
  "offspring": ["Function.LeftInverse.injective", "Prod.swap_LeftInverse"],
  "name": "Prod.swap_injective"},
 {"type": "∀ {a b : Prop} [inst : Decidable b], ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "offspring": ["not_and_of_not_or_not"],
  "name": "Decidable.not_and_distrib'"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.injective f → ∀ {a b : α} {c : β}, f b = c → (f a = c ↔ a = b)",
  "offspring": ["Function.injective.eq_iff"],
  "name": "Function.injective.eq_iff'"},
 {"type":
  "(α : Type) → Lean.Expr → Lean.Expr → optParam Lean.DefinitionSafety Lean.DefinitionSafety.safe → Lean.MetaM α",
  "offspring": [],
  "name": "Mathlib.Eval.evalExpr"},
 {"type": "Prop → Type", "offspring": [], "name": "Decidable"},
 {"type": "Div UInt8",
  "offspring": ["Div.mk", "UInt8.div"],
  "name": "instDivUInt8"},
 {"type": "∀ {α : Type u_1}, ∅ = []", "offspring": [], "name": "List.empty_eq"},
 {"type": "Sort u → Nat.Linear.ExprCnstr → Nat.Linear.ExprCnstr → Sort u",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.noConfusionType"},
 {"type": "∀ {a : ℤ}, a ≤ ↑(Int.natAbs a)",
  "offspring":
  ["Or.elim",
   "le_total",
   "Int.instLinearOrderInt",
   "Int.eq_natAbs_of_zero_le",
   "Int.le_refl",
   "le_trans",
   "Int.ofNat_zero_le"],
  "name": "Int.le_natAbs"},
 {"type":
  "{α : Type u} → [inst : LT α] → [h : DecidableRel fun a a_1 => a < a_1] → (l₁ l₂ : List α) → Decidable (l₁ < l₂)",
  "offspring":
  ["List.hasDecidableLt.proof_1",
   "List.lt.nil",
   "List.hasDecidableLt.proof_2",
   "List.lt.head",
   "List.hasDecidableLt.proof_3",
   "List.lt.tail",
   "List.hasDecidableLt.proof_4"],
  "name": "List.hasDecidableLt"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α], left_commutative min",
  "offspring": ["left_comm", "min_comm", "min_assoc"],
  "name": "min_left_comm"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, a1 = a2 ↔ a1.val = a2.val",
  "offspring": ["Subtype.ext_iff"],
  "name": "Subtype.ext_iff_val"},
 {"type": "{α : Type u} → Array α → Std.PersistentArray α",
  "offspring": ["Array.foldl"],
  "name": "Array.toPersistentArray"},
 {"type": "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → Array α",
  "offspring": [],
  "name": "BinaryHeap.arr"},
 {"type": "∀ (a b c : UInt16), a * (b + c) = a * b + a * c",
  "offspring":
  ["UInt16.add_def",
   "UInt16.mul_def",
   "UInt16.mk",
   "UInt16.eq_of_val_eq",
   "Distrib.left_distrib"],
  "name": "UInt16.instSemiringUInt16.proof_7"},
 {"type": "∀ (a b : UInt16), a % b = { val := a.val % b.val }",
  "offspring": [],
  "name": "UInt16.mod_def"},
 {"type":
  "∀ {ids ids_1 : Array ℕ}, Mathlib.Tactic.Sat.LRATStep.del ids = Mathlib.Tactic.Sat.LRATStep.del ids_1 → ids = ids_1",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LRATStep.del.inj"},
 {"type":
  "{ρ : Type u} →\n  {m n : Type u → Type v} → [inst : MonadFunctor m n] → [inst : MonadWithReaderOf ρ m] → MonadWithReaderOf ρ n",
  "offspring":
  ["MonadWithReaderOf.mk", "MonadFunctorT.monadMap", "withTheReader"],
  "name": "instMonadWithReaderOf"},
 {"type": "∀ {a b c : ℕ}, c * a ≤ c * b → 0 < c → a ≤ b",
  "offspring": ["Nat.ge_of_not_lt"],
  "name": "Nat.le_of_mul_le_mul_left"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b → b ≤ a",
  "offspring": ["Or.resolve_left", "le_total"],
  "name": "le_of_not_le"},
 {"type": "∀ {a b : Prop}, ¬(a → b) → ¬¬a",
  "offspring": ["mt", "Not.elim"],
  "name": "not_not_of_not_imp"},
 {"type": "∀ {α : Sort u} [inst : Setoid α] {a b : α}, a ≈ b → b ≈ a",
  "offspring": ["Equivalence.symm", "Setoid.iseqv"],
  "name": "Setoid.symm"},
 {"type": "{α : Type u} → [self : BEq α] → α → α → Bool",
  "offspring": [],
  "name": "BEq.beq"},
 {"type": "∀ {α : Sort u} {a a' : α}, a = a' → HEq a a'",
  "offspring": ["Eq.subst"],
  "name": "heq_of_eq"},
 {"type":
  "{α : Sort u} → {β : Sort v} → (α → α → Prop) → (β → β → Prop) → (_ : α) ×' β → (_ : α) ×' β → Prop",
  "offspring": [],
  "name": "PSigma.RevLex"},
 {"type": "(α : Sort u) → DecidableEq α",
  "offspring": ["inferInstance"],
  "name": "Classical.typeDecidableEq"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {s : Set α} {b : β},\n  (∃ a, a ∈ s ∧ f a = b) → f (Function.inv_fun_on f s b) = b",
  "offspring": ["Function.inv_fun_on_pos"],
  "name": "Function.inv_fun_on_eq"},
 {"type": "∀ {α : Type u_1} {l : List α} {a : α}, List.disjoint [a] l ↔ ¬a ∈ l",
  "offspring": ["List.mem_singleton", "forall_eq"],
  "name": "List.singleton_disjoint"},
 {"type": "{α : Type u_1} → List α → ℕ → List α",
  "offspring": [],
  "name": "List.rotate'"},
 {"type": "{α : Type u} → (α → α) → Complement α",
  "offspring": [],
  "name": "Complement.mk"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {as : List α}, ¬a ∈ as → List.remove a as = as",
  "offspring": [],
  "name": "List.remove_eq_of_not_mem"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, p = q ↔ p.fst = q.fst ∧ p.snd = q.snd",
  "offspring": ["Prod.mk.injEq"],
  "name": "Prod.eq_iff_fst_eq_snd_eq"},
 {"type": "{α : Type u_1} → List α → ℕ",
  "offspring": ["List.lengthTRAux"],
  "name": "List.lengthTR"},
 {"type":
  "∀ {ε σ α : Type u} (a : ε) (a_1 : σ) (a_2 : ε) (a_3 : σ),\n  (EStateM.Result.error a a_1 = EStateM.Result.error a_2 a_3) = (a = a_2 ∧ a_1 = a_3)",
  "offspring": ["EStateM.Result.error"],
  "name": "EStateM.Result.error.injEq"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (β → β → β) → (α → β) → α → β → β",
  "offspring": [],
  "name": "Function.comp_left"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∪_»"},
 {"type": "∀ (n m k : ℕ), (n + m) * k = n * k + m * k",
  "offspring": [],
  "name": "Nat.right_distrib"},
 {"type": "ℕ → Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["cond", "instBEqNat"],
  "name": "Nat.Linear.Poly.mul"},
 {"type": "{α : Type u} → {β : Type v} → (β → α → β) → β → Subarray α → β",
  "offspring": ["Id.run", "Subarray.foldlM", "Id.instMonadId"],
  "name": "Subarray.foldl"},
 {"type": "∀ {a b c : ℤ}, c < a + b → -a < b - c",
  "offspring": [],
  "name": "Int.neg_lt_sub_left_of_lt_add"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (Option α → β → γ) → List α → List β → List γ × List α",
  "offspring": ["List.map₂Left'", "flip"],
  "name": "List.map₂Right'"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b ↔ a < b ∨ a = b",
  "offspring": ["Decidable.le_iff_lt_or_eq"],
  "name": "le_iff_lt_or_eq"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a < c → b < c → max a b < c",
  "offspring": ["Or.elim", "le_or_gt", "max_eq_right", "max_eq_left_of_lt"],
  "name": "max_lt"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddSemigroup"},
 {"type":
  "∀ {m : Type u → Type v} [inst : Monad m] [self : LawfulMonad m] {α β : Type u} (f : α → β) (x : m α),\n  (do\n      let a ← x\n      pure (f a)) =\n    f <$> x",
  "offspring": [],
  "name": "LawfulMonad.bind_pure_comp"},
 {"type": "ℕ", "offspring": [], "name": "UInt8.size"},
 {"type": "{α : Type u_1} → Stream (List α) α",
  "offspring": ["Stream.mk", "Option", "Prod"],
  "name": "instStreamList"},
 {"type": "∀ (α : Sort u), α → True ↔ True",
  "offspring": ["trivial"],
  "name": "implies_true_iff"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {ra : α → α → Prop} {rb : β → β → Prop},\n  (∀ (a : α), Acc ra a) → (∀ (b : β), Acc rb b) → ∀ (a : α) (b : β), Acc (Prod.Lex ra rb) (a, b)",
  "offspring": ["Acc.intro"],
  "name": "Prod.lexAccessible.proof_1"},
 {"type": "∀ (a : ℕ), a % 0 = a", "offspring": [], "name": "Nat.mod_zero"},
 {"type": "Mathlib.Tactic.Lint.NamedLinter → Lean.Name",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.NamedLinter.declName"},
 {"type":
  "{R : Type u} → [toRing : Ring R] → (∀ (a b : R), a * b = b * a) → CommRing R",
  "offspring": [],
  "name": "CommRing.mk"},
 {"type": "∀ {a b c : Prop}, a ∨ b → c ↔ (a → c) ∧ (b → c)",
  "offspring": [],
  "name": "or_imp_distrib"},
 {"type":
  "∀ (a : ℤ), a = Int.ofNat (Int.natAbs a) ∨ a = -Int.ofNat (Int.natAbs a)",
  "offspring": [],
  "name": "Int.natAbs_eq"},
 {"type":
  "Lean.Name → optParam Lean.AttributeKind Lean.AttributeKind.global → optParam ℕ 1000 → Lean.MetaM Unit",
  "offspring":
  ["Tactic.NormCast.pushCastExt",
   "Tactic.NormCast.NormCastExtension.up",
   "Tactic.NormCast.normCastExt",
   "Tactic.NormCast.NormCastExtension.down"],
  "name": "Tactic.NormCast.addMove"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : (a a_1 : α) → TC r a a_1 → Prop} (a b : α), r a b → TC.below (_ : TC r a b)",
  "offspring": [],
  "name": "TC.below.base"},
 {"type": "{α : Sort u} → α", "offspring": [], "name": "lcUnreachable"},
 {"type": "∀ {n : ℕ} (k : ℕ), n ≤ k → ∀ (a : ℕ), a < n → a < k",
  "offspring": ["lt_of_lt_of_le"],
  "name": "UFModel.push.proof_1"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → α → Option α × BinaryHeap α lt",
  "offspring":
  ["BinaryHeap.max",
   "BinaryHeap.replaceMax.proof_1",
   "BinaryHeap.mk",
   "Array.push",
   "BinaryHeap.arr",
   "Subtype.val",
   "BinaryHeap.heapifyDown",
   "BinaryHeap.replaceMax.proof_2",
   "Array.set",
   "BinaryHeap.size_pos_of_max"],
  "name": "BinaryHeap.replaceMax"},
 {"type": "∀ {α : Sort u_1} [inst : Inhabited α], Nonempty α",
  "offspring": ["Inhabited.default"],
  "name": "instNonempty.proof_1"},
 {"type": "Sort u → Sort (max u (v + 1))", "offspring": [], "name": "HasEquiv"},
 {"type":
  "Tactic.Ring.HornerExpr → Tactic.Ring.HornerExpr → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring": [],
  "name": "Tactic.Ring.evalMul"},
 {"type":
  "∀ {α : Type u} (as bs : List α), List.length (as ++ bs) = List.length as + List.length bs",
  "offspring":
  ["List.nil_append",
   "List.length_nil",
   "Nat.zero_add",
   "List.cons_append",
   "List.length_cons",
   "Nat.succ_add"],
  "name": "List.length_append"},
 {"type": "∀ {n : ℕ} (a b : Fin n), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "offspring": ["Nat.lt_iff_le_not_le"],
  "name": "Fin.lt_iff_le_not_le"},
 {"type": "Subsingleton Empty",
  "offspring": ["Subsingleton.intro", "Empty.elim"],
  "name": "instSubsingletonEmpty.proof_1"},
 {"type":
  "{α : Type} → {m : Type → Type} → [inst : Monad m] → m (Option α) → m (Lean.LOption α)",
  "offspring": ["Option.toLOption"],
  "name": "toLOptionM"},
 {"type": "∀ (α : Sort u) (default : α), optParam α default = α",
  "offspring": [],
  "name": "optParam_eq"},
 {"type": "Mul USize",
  "offspring": ["Mul.mk", "USize.mul"],
  "name": "instMulUSize"},
 {"type":
  "{f : Type u → Type v} → [inst : Functor f] → {α β : Type u} → f α → (α → β) → f β",
  "offspring": ["Functor.map"],
  "name": "Functor.mapRev"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt) (x : α),\n  BinaryHeap.size (BinaryHeap.insert self x) = BinaryHeap.size self + 1",
  "offspring":
  ["BinaryHeap.size_heapifyUp",
   "Array.push",
   "BinaryHeap.arr",
   "BinaryHeap.insert.proof_1",
   "Array.size_push"],
  "name": "BinaryHeap.size_insert"},
 {"type":
  "{m : Type u_1 → Type u_2} → [inst : Monad m] → MonadControl m (OptionT m)",
  "offspring": ["MonadControl.mk", "OptionT.run"],
  "name": "instMonadControlOptionT"},
 {"type": "∀ (a b : ℕ), a - b < Nat.succ a",
  "offspring": ["Nat.lt_succ_of_le", "Nat.sub_le"],
  "name": "Nat.sub_lt_succ"},
 {"type": "Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": [],
  "name": "Nat.Linear.Poly.sort"},
 {"type": "∀ (u : Unit), sizeOf u = 1", "offspring": [], "name": "Unit.sizeOf"},
 {"type":
  "∀ (x : ℕ) (x_1 : UInt32), npow_rec (Nat.succ x) x_1 = npow_rec (Nat.succ x) x_1",
  "offspring": [],
  "name": "UInt32.instSemiringUInt32.proof_16"},
 {"type":
  "(p : Prop) →\n  [inst : Decidable p] → (α : p → Type u_1) → [inst : (hp : p) → DecidableEq (α hp)] → DecidableEq ((hp : p) → α hp)",
  "offspring": ["decidable_of_iff", "Function.decidable_eq_pfun.proof_1"],
  "name": "Function.decidable_eq_pfun"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {as : List α}, b ∈ List.remove a as ↔ b ∈ as ∧ b ≠ a",
  "offspring":
  ["List.not_mem_nil",
   "ne_eq",
   "false_and",
   "List.mem_cons",
   "if_pos",
   "Ne",
   "Or.resolve_left",
   "if_neg",
   "Ne.symm"],
  "name": "List.mem_remove_iff"},
 {"type": "∀ {a b c : ℕ}, a ≤ b → b ≤ c → a ≤ c",
  "offspring": ["Nat.le_trans"],
  "name": "Nat.instTransNatLeInstLENat.proof_1"},
 {"type": "∀ (m n : ℕ), Nat.gcd m n ∣ n",
  "offspring": ["Nat.gcd_dvd"],
  "name": "Nat.gcd_dvd_right"},
 {"type":
  "{A : Type u} → [inst : Add A] → (∀ (a b c : A), b + a = c + a → b = c) → IsAddRightCancel A",
  "offspring": [],
  "name": "IsAddRightCancel.mk"},
 {"type": "{α : Type u} → List α → List α",
  "offspring": [],
  "name": "List.tail"},
 {"type": "∀ {p q : Prop}, ¬q → p ∧ q → False",
  "offspring": [],
  "name": "instDecidableAnd.proof_1"},
 {"type": "ShiftRight ℕ",
  "offspring": ["ShiftRight.mk", "Nat.shiftRight"],
  "name": "Nat.instShiftRightNat"},
 {"type": "∀ (a : ℕ), sizeOf (Sat.Literal.pos a) = 1 + sizeOf a",
  "offspring": ["instSizeOfNat"],
  "name": "Sat.Literal.pos.sizeOf_spec"},
 {"type": "∀ {a b : Prop}, a ∨ b ↔ ¬(¬a ∧ ¬b)",
  "offspring": ["Decidable.or_iff_not_and_not"],
  "name": "or_iff_not_and_not"},
 {"type": "∀ (α : Sort u) [self : Setoid α], Equivalence Setoid.r",
  "offspring": [],
  "name": "Setoid.iseqv"},
 {"type": "outParam (Type u) → Type u → Type u",
  "offspring": [],
  "name": "EStateM.Backtrackable"},
 {"type":
  "{α : Type u} → (as : Array α) → (α → Bool) → optParam ℕ 0 → optParam ℕ (Array.size as) → Bool",
  "offspring": ["Id.run", "Array.allM", "Id.instMonadId"],
  "name": "Array.all"},
 {"type": "Type u → Type u → Type u → Type u",
  "offspring": [],
  "name": "DoResultPRBC"},
 {"type": "∀ {n : ℕ} {a b : Fin n}, ↑a = ↑b → a = b",
  "offspring": [],
  "name": "Fin.ext"},
 {"type": "∀ {α : Type u_1}, [] ~ []",
  "offspring": [],
  "name": "List.Perm.nil"},
 {"type": "{α : Type u} → [self : EmptyCollection α] → α",
  "offspring": [],
  "name": "EmptyCollection.emptyCollection"},
 {"type": "{M : Type u} → Sort u_1 → Monoid M → Monoid M → Sort u_1",
  "offspring": [],
  "name": "Monoid.noConfusionType"},
 {"type":
  "{α : Type u} → [inst : DecidableEq α] → (a : α) → (as : List α) → Decidable (a ∈ as)",
  "offspring":
  ["decidable_of_decidable_of_iff",
   "List.instDecidableMemListInstMembershipList.proof_1"],
  "name": "List.instDecidableMemListInstMembershipList"},
 {"type":
  "∀ {α : Type u_1} (n : ℕ) (l : List α), List.length (List.take n l) ≤ n",
  "offspring": ["List.length_take", "min_le_left", "Nat.instLinearOrderNat"],
  "name": "List.length_take_le"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "Int.termℤ"},
 {"type": "{A : Type u} → [self : AddCommMonoid A] → AddMonoid A",
  "offspring": [],
  "name": "AddCommMonoid.toAddMonoid"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "offspring": ["lt_of_le_not_le", "le_trans", "le_not_le_of_lt"],
  "name": "lt_of_le_of_lt"},
 {"type": "∀ (a : UInt8), { val := a.val } = a",
  "offspring": ["UInt8.size", "UInt8.mk"],
  "name": "UInt8.mk_val_eq"},
 {"type": "Type u → Type u", "offspring": [], "name": "BEq"},
 {"type":
  "(optParam (System.FilePath → IO Bool) fun x => pure true) → System.FilePath → StateT (Array System.FilePath) IO Unit",
  "offspring": [],
  "name": "System.FilePath.walkDir.go"},
 {"type":
  "∀ {α : Type u} (a : Array α) (i : Fin (Array.size a)) (v : α), Array.size (Array.set a i v) = Array.size a",
  "offspring": ["List.length_set", "Array.data"],
  "name": "Array.size_set"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_^_»"},
 {"type":
  "∀ {α : Type u} {β : Type v} (fst : α) (snd : β) (fst_1 : α) (snd_1 : β),\n  ((fst, snd) = (fst_1, snd_1)) = (fst = fst_1 ∧ snd = snd_1)",
  "offspring": [],
  "name": "Prod.mk.injEq"},
 {"type": "AndOp UInt32",
  "offspring": ["AndOp.mk", "UInt32.land"],
  "name": "instAndOpUInt32"},
 {"type":
  "{α : Type u} → {β : Type v} → WellFoundedRelation α → WellFoundedRelation β → WellFoundedRelation (α × β)",
  "offspring":
  ["WellFoundedRelation.mk",
   "Prod.Lex",
   "WellFoundedRelation.rel",
   "Prod.lex.proof_1"],
  "name": "Prod.lex"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": [],
  "name": "unexpandUnit"},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α",
  "offspring": ["List.eraseRepsAux"],
  "name": "List.eraseReps"},
 {"type": "(p : Prop) → [h : Decidable p] → Bool",
  "offspring": [],
  "name": "Decidable.decide"},
 {"type": "Sort u → Sort (max 1 u)", "offspring": [], "name": "Hashable"},
 {"type": "∀ {α : Type u_1} {S : Set α} (a : { a // a ∈ S }), a.val ∈ S",
  "offspring": ["Subtype.property"],
  "name": "Subtype.val_prop"},
 {"type":
  "{α₁ α₂ α₃ α₄ β : Type u} →\n  (α₁ → α₂ → α₃ → α₄ → β) → ((α₁ → α₂ → α₃ → α₄ → β) → α₁ → α₂ → α₃ → α₄ → β) → α₁ → α₂ → α₃ → α₄ → β",
  "offspring": ["bfix4", "USize.size"],
  "name": "fixCore4"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.convNormCast"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt) (x m : α),\n  BinaryHeap.max self = some m →\n    0 < Array.size (Array.set self.arr { val := 0, isLt := (_ : 0 < BinaryHeap.size self) } x)",
  "offspring": ["Array.size_set", "BinaryHeap.size_pos_of_max"],
  "name": "BinaryHeap.insertExtractMax.proof_2"},
 {"type": "{α : Type u} → EmptyCollection (List α)",
  "offspring": ["EmptyCollection.mk"],
  "name": "List.instEmptyCollectionList"},
 {"type": "Float → Float → Float", "offspring": [], "name": "Float.atan2"},
 {"type": "ℕ → Char", "offspring": [], "name": "Nat.digitChar"},
 {"type": "∀ {a b c : Prop}, ((a → b) → (b → a) → c) → (a ↔ b) → c",
  "offspring": [],
  "name": "Iff.elim.proof_1"},
 {"type":
  "∀ {α : Type u} [self : PartialOrder α] (a b : α), a ≤ b → b ≤ a → a = b",
  "offspring": [],
  "name": "PartialOrder.le_antisymm"},
 {"type":
  "{G : Type u} → {inst : Mul G} → Sort u_1 → IsMulRightCancel G → IsMulRightCancel G → Sort u_1",
  "offspring": [],
  "name": "IsMulRightCancel.noConfusionType"},
 {"type": "∀ {a b : Prop}, a ∨ b → b ∨ a", "offspring": [], "name": "Or.swap"},
 {"type": "∀ {a b : Prop}, a → ((b ↔ a) ↔ b)",
  "offspring": ["Iff.trans", "Iff.comm", "iff_true_left"],
  "name": "iff_true_right"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadStateOf σ m] → m σ",
  "offspring": [],
  "name": "MonadStateOf.get"},
 {"type": "{M₀ : Type u} → [self : MulZeroClass M₀] → Mul M₀",
  "offspring": [],
  "name": "MulZeroClass.toMul"},
 {"type":
  "∀ {hyps : Array Lean.Expr} {isConditional : Bool} {lhs rhs : Lean.Expr} {hyps_1 : Array Lean.Expr}\n  {isConditional_1 : Bool} {lhs_1 rhs_1 : Lean.Expr},\n  { hyps := hyps, isConditional := isConditional, lhs := lhs, rhs := rhs } =\n      { hyps := hyps_1, isConditional := isConditional_1, lhs := lhs_1, rhs := rhs_1 } →\n    hyps = hyps_1 ∧ isConditional = isConditional_1 ∧ lhs = lhs_1 ∧ rhs = rhs_1",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.mk.inj"},
 {"type": "Substring → String.Pos → String.Pos",
  "offspring": [],
  "name": "Substring.next"},
 {"type": "FloatArray → Array Float",
  "offspring": [],
  "name": "FloatArray.data"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop},\n  WellFounded r → ∀ {C : α → Prop} (a : α), (∀ (x : α), (∀ (y : α), r y x → C y) → C x) → C a",
  "offspring": ["WellFounded.recursion"],
  "name": "WellFounded.induction"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], ¬(a → b) → a",
  "offspring": ["Decidable.by_contradiction", "not_not_of_not_imp"],
  "name": "Decidable.of_not_imp"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort u_2} [inst : ∀ (a : α), Nonempty (β a)], Nonempty ((a : α) → β a)",
  "offspring": ["Classical.arbitrary"],
  "name": "instNonemptyForAll_2.proof_1"},
 {"type": "Array Lean.Name → Lean.CoreM Lean.MessageData",
  "offspring": ["Functor.map", "Array.mapM"],
  "name": "Mathlib.Tactic.Lint.formatLemmas"},
 {"type": "∀ {α : Type u_1} (s t : List α), t ≠ [] → s ++ t ≠ []",
  "offspring":
  ["implies_congr_ctx",
   "ne_eq",
   "List.append_eq_nil",
   "and_false",
   "implies_true"],
  "name": "List.append_ne_nil_of_ne_nil_right"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {β α : Type u_1} [inst : Monad m] (e : β) (f : α → ExceptCpsT β m β),\n  ExceptCpsT.runCatch (throw e >>= f) = pure e",
  "offspring": [],
  "name": "ExceptCpsT.runCatch_bind_throw"},
 {"type": "Type u → (Type u → Type v) → Type v",
  "offspring": [],
  "name": "MonadReaderOf"},
 {"type": "{α : Type u_1} → ℕ → UnionFind α",
  "offspring": ["UnionFind.mk", "Array.mkEmpty", "UnionFind.mkEmpty.proof_1"],
  "name": "UnionFind.mkEmpty"},
 {"type": "∀ (a : USize), sizeOf a = USize.toNat a + 2",
  "offspring":
  ["USize.mk.sizeOf_spec",
   "Fin.sizeOf",
   "USize.size",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var"],
  "name": "USize.sizeOf"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : SizeOf α] [inst_1 : (a : α) → SizeOf (β a)] (fst : α) (snd : β fst),\n  sizeOf { fst := fst, snd := snd } = 1 + sizeOf fst + sizeOf snd",
  "offspring": [],
  "name": "PSigma.mk.sizeOf_spec"},
 {"type":
  "System.FilePath → optParam Bool System.FilePath.isCaseInsensitive → System.FilePath",
  "offspring":
  ["instBEqNat",
   "System.FilePath.pathSeparators",
   "not",
   "System.FilePath.mk",
   "List.contains",
   "System.FilePath.pathSeparator",
   "System.FilePath.toString"],
  "name": "System.FilePath.normalize"},
 {"type":
  "∀ {α : Sort u_1} {r : α → α → Prop} {C : α → Sort u_2} (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α)\n  (acx : Acc r x), WellFounded.fixF F x acx = F x fun y p => WellFounded.fixF F y (_ : Acc (fun y x => r y x) y)",
  "offspring": [],
  "name": "WellFounded.fixFEq.proof_1"},
 {"type":
  "∀ (x x_1 x_2 : UInt8), { val := (x * x_1 * x_2).1 } = { val := (x * (x_1 * x_2)).1 }",
  "offspring": ["UInt8.mk", "Semigroup.mul_assoc"],
  "name": "UInt8.instSemigroupUInt8.proof_1"},
 {"type": "∀ (val : Fin UInt32.size), sizeOf { val := val } = 1 + sizeOf val",
  "offspring": [],
  "name": "UInt32.mk.sizeOf_spec"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["Nat.add"], "name": "Nat.mul"},
 {"type": "∀ {a b : Prop}, (a ↔ b) ↔ (a → b) ∧ (b → a)",
  "offspring": ["iff_iff_implies_and_implies"],
  "name": "iff_def"},
 {"type":
  "∀ {p : ℕ → Prop} (n : ℕ), (∀ (n : ℕ), (∀ (m : ℕ), m < n → p m) → p n) → p n",
  "offspring": ["Nat.strong_rec_on"],
  "name": "Nat.strong_induction_on"},
 {"type":
  "∀ (a : Nat.Linear.Expr) (k : ℕ) (a_1 : Nat.Linear.Expr) (k_1 : ℕ),\n  (Nat.Linear.Expr.mulR a k = Nat.Linear.Expr.mulR a_1 k_1) = (a = a_1 ∧ k = k_1)",
  "offspring": ["Nat.Linear.Expr", "Nat.Linear.Expr.mulR"],
  "name": "Nat.Linear.Expr.mulR.injEq"},
 {"type": "{α : Sort u_1} → (α → α) → Prop",
  "offspring": [],
  "name": "Function.involutive"},
 {"type": "∀ (α : Sort u_1) (x : α), id (id x) = id (id x)",
  "offspring": [],
  "name": "Equiv.refl.proof_1"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → (Unit → β) → γ) → HAndThen α β γ",
  "offspring": [],
  "name": "HAndThen.mk"},
 {"type": "∀ (n n_1 : ℕ), (Nat.succ n = Nat.succ n_1) = (n = n_1)",
  "offspring": [],
  "name": "Nat.succ.injEq"},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Thunk α → Thunk β",
  "offspring": ["Thunk.mk", "Thunk.get"],
  "name": "Thunk.map"},
 {"type": "∀ {n m : ℕ}, m ≤ n → Int.ofNat (n - m) = Int.ofNat n - Int.ofNat m",
  "offspring": [],
  "name": "Int.ofNat_sub"},
 {"type": "Mathlib.Tactic.Lint.Linter",
  "offspring":
  ["Mathlib.Tactic.Lint.Linter.mk",
   "Mathlib.Tactic.Lint.isSimpTheorem",
   "Mathlib.Tactic.Lint.checkAllSimpTheoremInfos",
   "Option"],
  "name": "Mathlib.Tactic.Lint.simpVarHead"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "precMin"},
 {"type": "(A : Type u) → [inst : AddGroup A] → IsAddLeftCancel A",
  "offspring":
  ["IsAddLeftCancel.mk",
   "instIsAddLeftCancelToAddToAddSemigroupToAddMonoidToSubNegMonoid.proof_1"],
  "name": "instIsAddLeftCancelToAddToAddSemigroupToAddMonoidToSubNegMonoid"},
 {"type": "ℕ → UInt8",
  "offspring": ["UInt8.mk", "Fin.ofNat"],
  "name": "UInt8.ofNat"},
 {"type":
  "∀ {α β ε : Type u} {m : Type u → Type v} [inst : Monad m] [inst_1 : LawfulMonad m] (x : ExceptT ε m α)\n  (y : ExceptT ε m β), (SeqLeft.seqLeft x fun x => y) = Seq.seq (Function.const β <$> x) fun x => y",
  "offspring": [],
  "name": "ExceptT.seqLeft_eq"},
 {"type": "∀ (n : ℕ), Nat.gcd n 1 = 1",
  "offspring": ["Nat.gcd_comm", "Nat.gcd_one_left"],
  "name": "Nat.gcd_one_right"},
 {"type":
  "{A : Type u} → Sort u_1 → AddSemigroup A → AddSemigroup A → Sort u_1",
  "offspring": [],
  "name": "AddSemigroup.noConfusionType"},
 {"type": "{α : Type u_1} → [inst : Div α] → HDiv α α α",
  "offspring": ["HDiv.mk", "Div.div"],
  "name": "instHDiv"},
 {"type":
  "{v : Sat.Valuation} →\n  {f : Sat.Fmla} → Sort u → Sat.Valuation.satisfies_fmla v f → Sat.Valuation.satisfies_fmla v f → Sort u",
  "offspring": [],
  "name": "Sat.Valuation.satisfies_fmla.noConfusionType"},
 {"type":
  "{α : Type u_1} → [inst : DecidableEq α] → (l : List α) → Decidable (List.Nodup l)",
  "offspring": ["List.decidablePairwise"],
  "name": "List.nodupDecidable"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExcept ε m] → {α : Type v} → ε → m α",
  "offspring": [],
  "name": "MonadExcept.throw"},
 {"type": "∀ {a b : ℤ}, a - b = 0 → a = b",
  "offspring": [],
  "name": "Int.eq_of_sub_eq_zero"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a > b → b ≥ c → a > c",
  "offspring": ["gt_of_gt_of_ge"],
  "name": "instTransGtToLTGeToLE.proof_1"},
 {"type": "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, List.map f [] = []",
  "offspring": [],
  "name": "List.map_nil"},
 {"type": "Type", "offspring": [], "name": "Mathlib.Tactic.Lint.Linter"},
 {"type": "(ℕ → Bool) → ℕ → Bool",
  "offspring": ["not", "Nat.any"],
  "name": "Nat.all"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {g : β → α},\n  Function.injective f → Function.RightInverse g f → Function.inv_fun f = g",
  "offspring": ["Function.inv_fun_eq"],
  "name": "Function.inv_fun_eq_of_injective_of_RightInverse"},
 {"type": "∀ (n : ℕ), Nat.coprime 1 n ↔ true = true",
  "offspring": ["Nat.gcd_one_left"],
  "name": "Nat.coprime_one_left_iff"},
 {"type": "∀ {α : Type u_1} {l : List α}, l ≠ [] → ∃ b L, l = b :: L",
  "offspring": [],
  "name": "List.exists_cons_of_ne_nil"},
 {"type":
  "{m : Type → Type} →\n  {α : Type} →\n    [inst : Monad m] →\n      [inst : Lean.MonadEnv m] →\n        [inst : Lean.MonadOptions m] →\n          [inst : MonadLiftT BaseIO m] → [inst : MonadExcept Lean.Exception m] → Tactic.Cache α → m α",
  "offspring":
  ["StateRefT'.run",
   "Task.Priority.default",
   "Unit",
   "Option.getD",
   "Task.get"],
  "name": "Tactic.Cache.get"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : ℕ), Fin.ofInt' -[1+ x] = Fin.ofInt' -[1+ x]",
  "offspring": [],
  "name": "instAddGroupWithOneFin.proof_7"},
 {"type":
  "∀ (x x_1 : UInt64), { val := (x - x_1).1 } = { val := (x + -x_1).1 }",
  "offspring": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "UInt64.instRingUInt64.proof_1"},
 {"type":
  "{α : Sort u} → {p : α → Prop} → Sort u_1 → Subtype p → Subtype p → Sort u_1",
  "offspring": [],
  "name": "Subtype.noConfusionType"},
 {"type": "Inhabited Ordering",
  "offspring": ["Ordering.lt"],
  "name": "instInhabitedOrdering"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "commandOfNat_class___"},
 {"type": "(a b : Float) → Decidable (a ≤ b)",
  "offspring": [],
  "name": "Float.decLe"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε α β : Type u_1} [inst : Monad m] (e : ε) (f : α → ExceptCpsT ε m β),\n  ExceptCpsT.run (throw e >>= f) = ExceptCpsT.run (throw e)",
  "offspring": [],
  "name": "ExceptCpsT.run_bind_throw"},
 {"type": "ℕ → UInt64",
  "offspring": ["UInt64.mk", "Fin.ofNat"],
  "name": "UInt64.ofNat"},
 {"type": "ℤ → Sat.Literal",
  "offspring":
  ["Int.instLTInt", "Sat.Literal.neg", "Int.toNat", "Sat.Literal.pos"],
  "name": "Sat.Literal.ofInt"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2}, Nonempty (PProd α β) ↔ Nonempty α ∧ Nonempty β",
  "offspring": ["Nonempty", "PProd", "PProd.mk"],
  "name": "nonempty_pprod"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∩_»"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Mathlib.ExtendedBinder.extBinderParenthesized"],
  "name": "Mathlib.ExtendedBinder.extBinderCollection"},
 {"type": "Prop → Prop", "offspring": [], "name": "Not"},
 {"type": "ToString Char",
  "offspring": ["ToString.mk"],
  "name": "instToStringChar"},
 {"type": "∀ {a b c : ℤ}, b ≤ a → c ≤ 0 → a * c ≤ b * c",
  "offspring": [],
  "name": "Int.mul_le_mul_of_nonpos_right"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "List.«term_<:+_»"},
 {"type":
  "{G : Type u} → [toGroup : Group G] → (∀ (a b : G), a * b = b * a) → CommGroup G",
  "offspring": [],
  "name": "CommGroup.mk"},
 {"type": "(False ↔ True) ↔ False",
  "offspring": ["iff_false_intro", "trivial"],
  "name": "false_iff_true"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {n : ℕ},\n  List.length l₁ ≤ n → List.get? (l₁ ++ l₂) n = List.get? l₂ (n - List.length l₁)",
  "offspring":
  ["List.cons_append",
   "Nat.add_zero",
   "List.length_cons",
   "Nat.add_sub_add_right",
   "Nat.lt_succ_iff"],
  "name": "List.get?_append_right"},
 {"type": "Tactic.NormCast.NormCastExtension → Lean.Meta.SimpExtension",
  "offspring": [],
  "name": "Tactic.NormCast.NormCastExtension.up"},
 {"type": "∀ (p : Prop), (False → p) = True",
  "offspring":
  ["trivial", "of_decide_eq_false", "instDecidableFalse", "Decidable.decide"],
  "name": "false_implies"},
 {"type": "Inhabited Tactic.NormCast.CoeFnType",
  "offspring": ["Tactic.NormCast.CoeFnType.coe"],
  "name": "Tactic.NormCast.instInhabitedCoeFnType"},
 {"type": "Repr Substring",
  "offspring": ["Substring.toString"],
  "name": "instReprSubstring"},
 {"type": "∀ {p : Prop}, p = False → ¬p",
  "offspring": [],
  "name": "not_of_eq_false"},
 {"type":
  "{P : Sort u} → {x y : Ordering} → x = y → Ordering.noConfusionType P x y",
  "offspring": ["noConfusionEnum"],
  "name": "Ordering.noConfusion"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "SeqRight"},
 {"type": "(a b : UInt32) → Decidable (a ≤ b)",
  "offspring": ["UInt32.decLe"],
  "name": "instDecidableLeUInt32InstLEUInt32"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → α → BinaryHeap α lt",
  "offspring":
  ["BinaryHeap.mk",
   "Subtype.val",
   "BinaryHeap.heapifyUp",
   "Array.push",
   "BinaryHeap.arr",
   "BinaryHeap.insert.proof_1",
   "BinaryHeap.size"],
  "name": "BinaryHeap.insert"},
 {"type": "∀ {α : Type u_1}, Option.map id = id",
  "offspring": ["Option.map"],
  "name": "Option.map_id"},
 {"type": "(a b : UInt16) → Decidable (a = b)",
  "offspring": ["UInt16.decEq.proof_1", "UInt16.decEq.proof_2"],
  "name": "UInt16.decEq"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), Nat.lor a b % n < n",
  "offspring": [],
  "name": "Fin.lor.proof_1"},
 {"type": "∀ {M : Type u} [self : Monoid M] (a : M), a * 1 = a",
  "offspring": [],
  "name": "Monoid.mul_one"},
 {"type": "∀ (x : UInt16), npow_rec 0 x = npow_rec 0 x",
  "offspring": [],
  "name": "UInt16.instSemiringUInt16.proof_15"},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "offspring": ["List.sublistsAux"],
  "name": "List.sublists"},
 {"type":
  "∀ (numArgs coercee : ℕ) (type : Tactic.NormCast.CoeFnType),\n  sizeOf { numArgs := numArgs, coercee := coercee, type := type } = 1 + sizeOf numArgs + sizeOf coercee + sizeOf type",
  "offspring": ["instSizeOfNat", "Tactic.NormCast.CoeFnType"],
  "name": "Tactic.NormCast.CoeFnInfo.mk.sizeOf_spec"},
 {"type": "∀ {m n a : ℕ}, Nat.coprime m n → a ∣ m → Nat.coprime (m / a) n",
  "offspring":
  ["Nat.eq_zero_or_pos",
   "Nat.eq_zero_of_zero_dvd",
   "Dvd.dvd",
   "Nat.instDvdNat",
   "Nat.zero_div",
   "Nat.mul_div_cancel_left",
   "Nat.coprime.coprime_mul_left"],
  "name": "Nat.coprime.coprime_div_left"},
 {"type": "{α : Type u_1} → {β : Sort u_2} → (α → β) → β → Option α",
  "offspring": ["Classical.choose"],
  "name": "Function.partial_inv"},
 {"type": "{R : Type u} → Sort u_1 → CommRing R → CommRing R → Sort u_1",
  "offspring": [],
  "name": "CommRing.noConfusionType"},
 {"type": "ToStream Std.Range Std.Range",
  "offspring": ["ToStream.mk"],
  "name": "instToStreamRange"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {g : Fin 0 → β}, UFModel.Agrees #[] f g",
  "offspring": ["UFModel.Agrees.mk'", "sorryAx", "Array.get"],
  "name": "UFModel.Agrees.empty"},
 {"type": "∀ {ε : Type u} {α : Type u_1}, Except.map id = id",
  "offspring": ["Except", "Except.error", "Except.ok", "id_eq"],
  "name": "Except.map_id"},
 {"type": "DecidableEq ℕ",
  "offspring": ["Nat.decEq"],
  "name": "instDecidableEqNat"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β}, Function.injective f → Function.inv_fun f ∘ f = id",
  "offspring": ["Function.LeftInverse_inv_fun"],
  "name": "Function.inv_fun_comp"},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ → ℕ → α → α",
  "offspring": [],
  "name": "Nat.foldAux"},
 {"type": "{α : Type u_1} → α → Thunk α",
  "offspring": ["Thunk.mk"],
  "name": "Thunk.pure"},
 {"type": "∀ {a b c : ℕ}, a + b < c + b → a < c",
  "offspring": ["Nat.lt_of_add_lt_add_left"],
  "name": "Nat.lt_of_add_lt_add_right"},
 {"type": "{R : Type u} → Sort u_1 → Ring R → Ring R → Sort u_1",
  "offspring": [],
  "name": "Ring.noConfusionType"},
 {"type":
  "∀ (a a_1 : ℕ), (Sat.Literal.pos a = Sat.Literal.pos a_1) = (a = a_1)",
  "offspring": ["Sat.Literal", "Sat.Literal.pos"],
  "name": "Sat.Literal.pos.injEq"},
 {"type": "ByteArray → (UInt8 → Bool) → optParam ℕ 0 → Option ℕ",
  "offspring": [],
  "name": "ByteArray.findIdx?"},
 {"type": "{α : Sort u} → plift α → α", "offspring": [], "name": "plift.down"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Functor f] [self : LawfulFunctor f] {α : Type u} (x : f α), id <$> x = x",
  "offspring": [],
  "name": "LawfulFunctor.id_map"},
 {"type":
  "(a : FloatArray) → (i : USize) → USize.toNat i < FloatArray.size a → Float",
  "offspring": ["Array.uget"],
  "name": "FloatArray.uget"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → Float → m β) → β → (as : FloatArray) → optParam ℕ 0 → optParam ℕ (FloatArray.size as) → m β",
  "offspring": ["FloatArray.size", "FloatArray.foldlM.proof_1"],
  "name": "FloatArray.foldlM"},
 {"type":
  "{R : Type u} → [self : NonUnitalNonAssocSemiring R] → AddCommMonoid R",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid"},
 {"type":
  "(ε : Type u) → {m : Type v → Type w} → [inst : MonadExceptOf ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "offspring": ["MonadExceptOf.tryCatch"],
  "name": "tryCatchThe"},
 {"type": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "offspring": [],
  "name": "eq_of_heq"},
 {"type": "Neg ℤ",
  "offspring": ["Neg.mk", "Int.neg"],
  "name": "Int.instNegInt"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "offspring": ["Function.LeftInverse"],
  "name": "Function.has_LeftInverse"},
 {"type": "∀ (x : ℕ), (fun a => a) (x + 1) = (fun a => a) (x + 1)",
  "offspring": [],
  "name": "Nat.instCommSemiringNat.proof_3"},
 {"type": "{R : Type u} → [self : NonUnitalNonAssocSemiring R] → One R",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.toOne"},
 {"type":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], (a ↔ ¬b) ↔ (b ↔ ¬a)",
  "offspring":
  ["iff_def", "and_congr", "imp_not_comm", "Decidable.not_imp_comm"],
  "name": "Decidable.iff_not_comm"},
 {"type": "∀ (n e : ℕ), 0 < e → n < 10 ^ e → String.length (Nat.repr n) ≤ e",
  "offspring": ["Nat.to_digits_core_length"],
  "name": "Nat.repr_length"},
 {"type": "{α : Type u_1} → Array α → ℕ → α → Array α",
  "offspring": ["Array.set"],
  "name": "Array.setD"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) -[1+ x] = (fun n => { val := ↑n }) -[1+ x]",
  "offspring": [],
  "name": "UInt64.instRingUInt64.proof_8"},
 {"type":
  "{g : Type} →\n  (α : Type u) →\n    [inst : Preorder α] →\n      [inst_1 : BoundedRandom α] → (lo hi : α) → lo ≤ hi → [inst_2 : RandomGen g] → RandG g { a // lo ≤ a ∧ a ≤ hi }",
  "offspring": ["BoundedRandom.randomR"],
  "name": "Random.randBound"},
 {"type": "∀ {a b : ℤ}, a - 1 < b → a ≤ b",
  "offspring": ["Int.le_of_lt_add_one", "Int.lt_add_of_sub_right_lt"],
  "name": "Int.le_of_sub_one_lt"},
 {"type": "Lean.Expr → Tactic.Ring.RingM ℕ",
  "offspring":
  ["MonadState.get",
   "ForIn.forIn",
   "Array.getOp",
   "Tactic.Ring.State.atoms",
   "ForInStep.done",
   "MProd.snd",
   "Tactic.Ring.State.numAtoms",
   "MProd.fst",
   "modify",
   "Tactic.Ring.State.mk",
   "Array.push"],
  "name": "Tactic.Ring.addAtom"},
 {"type": "∀ (a b : UInt8), a + b = { val := a.val + b.val }",
  "offspring": [],
  "name": "UInt8.add_def"},
 {"type": "Type u → Type (max 1 u)", "offspring": [], "name": "Random"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {x : α} [inst : Monad m], ExceptCpsT.runCatch (pure x) = pure x",
  "offspring": [],
  "name": "ExceptCpsT.runCatch_pure"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (x : ℕ),\n  x < Array.size as → (invImage (fun a => Array.size as - a) instWellFoundedRelation).1 (x + 1) x",
  "offspring": ["sizeOf_nat", "Nat.lt_eq", "Nat.sub_succ_lt_self"],
  "name": "Array.isPrefixOfAux.proof_3"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HMul α β γ] → α → β → γ",
  "offspring": [],
  "name": "HMul.hMul"},
 {"type":
  "∀ {s1 s2 s1_1 s2_1 : ℕ}, { s1 := s1, s2 := s2 } = { s1 := s1_1, s2 := s2_1 } → s1 = s1_1 ∧ s2 = s2_1",
  "offspring": [],
  "name": "StdGen.mk.inj"},
 {"type": "∀ {i j : ℕ}, Nat.gcd i j = 0 ↔ i = 0 ∧ j = 0",
  "offspring":
  ["Nat.eq_zero_of_gcd_eq_zero_left",
   "Nat.eq_zero_of_gcd_eq_zero_right",
   "Nat.gcd_zero_right"],
  "name": "Nat.gcd_eq_zero_iff"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a b c : Fin n), a * b * c = a * (b * c)",
  "offspring": ["Semigroup.mul_assoc"],
  "name": "instCommSemiringFin.proof_7"},
 {"type": "∀ {n k m : ℕ}, n ≤ k → k < n + m → k - n < m",
  "offspring": [],
  "name": "Nat.sub_lt_left_of_lt_add"},
 {"type":
  "{α : Type u} → {motive : List α → Sort u_1} → List α → Sort (max 1 u_1)",
  "offspring": ["PProd"],
  "name": "List.below"},
 {"type": "∀ {α : Type u_1} (as : List α), ∃ bs, bs ++ as = as",
  "offspring": [],
  "name": "List.forIn'.proof_1"},
 {"type":
  "∀ {n : ℕ} (a b : Fin n), Option.isSome (Fin.checkedAdd a b) = true ↔ ↑a + ↑b < n",
  "offspring":
  ["Subsingleton.elim",
   "decide_eq_true",
   "eq_false_of_decide",
   "false_iff",
   "not_lt",
   "Nat.instLinearOrderNat",
   "instDecidableFalse",
   "decide_eq_false",
   "not_le"],
  "name": "Fin.checked_add_spec"},
 {"type": "{α : Type u} → (α → Bool) → List α → List α",
  "offspring": [],
  "name": "List.dropWhile"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop}\n  {motive : (a : List α) → (a_1 : List β) → List.Forall₂ R a a_1 → Prop}, List.Forall₂.below (_ : List.Forall₂ R [] [])",
  "offspring": [],
  "name": "List.Forall₂.below.nil"},
 {"type": "∀ {a b : Prop}, (a → b) → (a ∧ b ↔ a)",
  "offspring": [],
  "name": "and_iff_left_of_imp"},
 {"type": "System.FilePath → Option String",
  "offspring": ["Option.bind", "System.FilePath.fileName"],
  "name": "System.FilePath.extension"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "offspring": ["Preorder.le_trans"],
  "name": "le_trans"},
 {"type":
  "∀ (n m : Fin UInt32.size), ¬n = m → { val := n } = { val := m } → False",
  "offspring": [],
  "name": "UInt32.decEq.proof_2"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_==_»"},
 {"type": "∀ {b : Bool}, ¬b = false → b = true",
  "offspring": [],
  "name": "Bool.of_not_eq_false"},
 {"type": "{ε : Type u} → {m : Type u → Type v} → MonadFunctor m (ExceptT ε m)",
  "offspring": ["MonadFunctor.mk"],
  "name": "ExceptT.instMonadFunctorExceptT"},
 {"type":
  "{α : Type u} → [inst : Inhabited α] → (α → α → Bool) → Array α → α → Array α",
  "offspring": ["Id.run", "Array.binInsertM", "Id.instMonadId"],
  "name": "Array.binInsert"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (c d : Nat.Linear.ExprCnstr),\n  (Nat.Linear.ExprCnstr.toNormPoly c == Nat.Linear.ExprCnstr.toPoly d) = true →\n    Nat.Linear.ExprCnstr.denote ctx c = Nat.Linear.ExprCnstr.denote ctx d",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq"},
 {"type": "∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a",
  "offspring": [],
  "name": "eq_comm"},
 {"type":
  "∀ {α : Type u} {head : α} {tail : List α} {head_1 : α} {tail_1 : List α},\n  head :: tail = head_1 :: tail_1 → head = head_1 ∧ tail = tail_1",
  "offspring": [],
  "name": "List.cons.inj"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {f : α → β} → Function.surjective f → β → α",
  "offspring": ["Classical.choose"],
  "name": "Function.surj_inv"},
 {"type":
  "∀ {A : Type u} [inst : AddSemigroup A] [inst_1 : IsAddRightCancel A] (a : A) {b c : A}, b + a = c + a ↔ b = c",
  "offspring": ["add_right_cancel"],
  "name": "add_left_inj"},
 {"type":
  "∀ {α : Type u_1} [inst : SizeOf α] (as : Array α) (i : Fin (Array.size as)), sizeOf (Array.get as i) < sizeOf as",
  "offspring": ["Array.mk.sizeOf_spec"],
  "name": "Array.sizeOf_get_lt"},
 {"type": "Lean.Elab.Command.CommandElab",
  "offspring": [],
  "name": "timeCmdElab"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort v}, Nonempty ((a : α) → β a) ↔ ∀ (a : α), Nonempty (β a)",
  "offspring": ["Classical.choice"],
  "name": "Classical.nonempty_pi"},
 {"type": "{n : ℕ} → Fin n → Fin n → Bool × Fin n",
  "offspring": ["Decidable.decide"],
  "name": "Fin.overflowingAdd"},
 {"type": "∀ {α : Sort u} {a b : α}, a ≠ b → a = b → False",
  "offspring": [],
  "name": "Ne.elim"},
 {"type": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "offspring": ["AddGroup.mk", "AddGroupWithOne.add_left_neg"],
  "name": "AddGroupWithOne.toAddGroup"},
 {"type":
  "{m : Type u → Type v} → {β : Type u} → [inst : Monad m] → [inst : ToBool β] → m β → m β → m β",
  "offspring": ["ToBool.toBool"],
  "name": "orM"},
 {"type": "∀ {a b c : Prop}, a ∨ b ∨ c ↔ b ∨ a ∨ c",
  "offspring":
  ["Iff.trans", "Iff.symm", "Or.assoc", "or_congr", "Or.comm", "Iff.refl"],
  "name": "Or.left_comm"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) {c : Nat.Linear.PolyCnstr},\n  Nat.Linear.PolyCnstr.isUnsat c = true → Nat.Linear.PolyCnstr.denote ctx c = False",
  "offspring":
  ["Nat.Linear.PolyCnstr",
   "or",
   "Nat.Linear.Poly.isZero",
   "Nat.Linear.Poly.isNonZero",
   "cond_true",
   "Bool.or_eq_true",
   "Bool.and_eq_true",
   "Nat.Linear.Poly.of_isZero",
   "Bool.of_not_eq_true",
   "cond_false"],
  "name": "Nat.Linear.PolyCnstr.eq_false_of_isUnsat"},
 {"type": "Sort u → Sort (max 1 u)", "offspring": [], "name": "Setoid"},
 {"type":
  "∀ {b c x y u v : Prop} [dec_b : Decidable b] [dec_c : Decidable c],\n  (b ↔ c) → (x ↔ u) → (y ↔ v) → ((if b then x else y) ↔ if c then u else v)",
  "offspring": ["if_ctx_congr_prop"],
  "name": "if_congr_prop"},
 {"type": "Nat.Linear.PolyCnstr → Nat.Linear.Poly",
  "offspring": [],
  "name": "Nat.Linear.PolyCnstr.rhs"},
 {"type": "∀ {a b c : Prop}, a ∨ b ∨ c ↔ b ∨ a ∨ c",
  "offspring": ["or_assoc", "or_comm", "Iff.rfl"],
  "name": "or_left_comm"},
 {"type":
  "∀ {R : Type u} [self : AddMonoidWithOne R] (n : ℕ), AddMonoidWithOne.natCast (n + 1) = AddMonoidWithOne.natCast n + 1",
  "offspring": [],
  "name": "AddMonoidWithOne.natCast_succ"},
 {"type": "∀ {m n : ℕ}, n ≤ m → Nat.succ m - n = Nat.succ (m - n)",
  "offspring":
  ["Exists.elim", "Nat.le.dest", "Nat.add_sub_cancel_left", "Nat.add_succ"],
  "name": "Nat.succ_sub"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "offspring": ["lt_of_le_not_le", "le_trans", "le_not_le_of_lt"],
  "name": "lt_of_lt_of_le"},
 {"type": "String",
  "offspring": ["System.Platform.isWindows"],
  "name": "System.FilePath.exeExtension"},
 {"type":
  "∀ {motive : ℕ → Prop} (x y : ℕ), (y ≤ x → ∀ (k : ℕ), x = y + k → motive k) → (x < y → motive 0) → motive (x - y)",
  "offspring":
  ["Nat.lt_or_ge",
   "Nat.sub_eq_zero_of_le",
   "Nat.le_of_lt",
   "Nat.add_sub_of_le"],
  "name": "Nat.sub.elim"},
 {"type": "∀ {a b : Prop}, a → ¬b ↔ b → ¬a",
  "offspring": ["imp.swap"],
  "name": "imp_not_comm"},
 {"type": "∀ {a b : ℤ}, a = -b → b = -a",
  "offspring": ["Int.neg_neg"],
  "name": "Int.eq_neg_of_eq_neg"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≥ b → b ≥ c → a ≥ c",
  "offspring": ["le_trans"],
  "name": "ge_trans"},
 {"type": "∀ {a b : Prop}, a ∨ b → b ∨ a", "offspring": [], "name": "Or.symm"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → ℕ → (ℕ → m Bool) → m Bool",
  "offspring": [],
  "name": "Nat.anyM"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (a : α), sizeOf (ForInStep.done a) = 1 + sizeOf a",
  "offspring": [],
  "name": "ForInStep.done.sizeOf_spec"},
 {"type": "∀ {p q : Prop}, p → q → (p ↔ q)",
  "offspring": [],
  "name": "instDecidableIff.proof_1"},
 {"type": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "offspring": [],
  "name": "ite"},
 {"type": "∀ {a b c : ℤ}, a ≤ b + c → -c + a ≤ b",
  "offspring": ["Int.neg_add_le_left_of_le_add", "Int.add_comm"],
  "name": "Int.neg_add_le_right_of_le_add"},
 {"type": "Tactic.NormCast.CoeFnType",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.coeSort"},
 {"type": "∀ {a b : ℤ}, a ≤ b → -b ≤ -a",
  "offspring": [],
  "name": "Int.neg_le_neg"},
 {"type": "ℤ → ℤ → Prop", "offspring": ["Int.NonNeg"], "name": "Int.le"},
 {"type":
  "∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop} (q : Quotient s),\n  (∀ (a : α), motive (Quotient.mk s a)) → motive q",
  "offspring": ["Quot.inductionOn"],
  "name": "Quotient.inductionOn"},
 {"type":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : outParam (Type v)} →\n      {d : outParam (Membership α ρ)} →\n        ({β : Type u₁} → [inst : Monad m] → (x : ρ) → β → ((a : α) → a ∈ x → β → m (ForInStep β)) → m β) →\n          ForIn' m ρ α d",
  "offspring": [],
  "name": "ForIn'.mk"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] {a : α} {b : β a} {f g : (a : α) → β a},\n  Function.update f a b = g ↔ b = g a ∧ ∀ (x : α), x ≠ a → f x = g x",
  "offspring":
  ["Iff.trans", "Function.funext_iff", "Function.forall_update_iff"],
  "name": "Function.update_eq_iff"},
 {"type":
  "∀ {α : Type u_1} {f : α → α → α},\n  (∀ (a b : α), f a b = a ∨ f a b = b) →\n    ∀ (o₁ o₂ : Option α), Option.lift_or_get f o₁ o₂ = o₁ ∨ Option.lift_or_get f o₁ o₂ = o₂",
  "offspring": [],
  "name": "Option.lift_or_get_choice"},
 {"type": "Nat.Linear.PolyCnstr → Nat.Linear.PolyCnstr → Nat.Linear.PolyCnstr",
  "offspring":
  ["Nat.Linear.Poly",
   "Nat.Linear.PolyCnstr.mk",
   "Nat.Linear.PolyCnstr.eq",
   "Nat.Linear.Poly.cancel",
   "Nat.Linear.Poly.combine",
   "Nat.Linear.PolyCnstr.lhs",
   "Nat.Linear.PolyCnstr.rhs"],
  "name": "Nat.Linear.PolyCnstr.combine"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "offspring": ["le_trans"],
  "name": "instTransLeToLE.proof_1"},
 {"type": "{α : Type u_1} → Set α → Set α → Set α",
  "offspring": ["setOf"],
  "name": "Set.union"},
 {"type": "{α : Type u} → Array α → ℕ → (α → α) → Array α",
  "offspring": ["Array.modify"],
  "name": "Array.modifyOp"},
 {"type":
  "∀ {f : Sat.Fmla} {c : Sat.Clause}, Sat.Fmla.subsumes f (Sat.Fmla.one c) → Sat.Fmla.proof f c",
  "offspring":
  ["Sat.Valuation.satisfies_fmla.prop",
   "Sat.Fmla.subsumes.prop",
   "List.Mem.head",
   "Sat.Clause"],
  "name": "Sat.Fmla.proof_of_subsumes"},
 {"type": "∀ {p : Prop}, p → p ≠ False",
  "offspring": [],
  "name": "ne_false_of_self"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → α → List α → List ℕ",
  "offspring": ["List.findIdxs"],
  "name": "List.indexesOf"},
 {"type": "∀ (n : ℕ), Nat.pred (Nat.succ n) = n",
  "offspring": [],
  "name": "Nat.pred_succ"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (x : α × β), Prod.swap (Prod.swap x) = x",
  "offspring": ["Prod.swap"],
  "name": "Prod.swap_swap"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_=_»"},
 {"type":
  "∀ {α : Type}, Nonempty (IO.Ref (Lean.MetaM α ⊕ Task (Except Lean.Exception α)))",
  "offspring": [],
  "name": "Tactic.instNonemptyCache.proof_1"},
 {"type": "Type s → Type (max s r)", "offspring": [], "name": "ULift"},
 {"type": "Type", "offspring": [], "name": "Substring"},
 {"type":
  "∀ (f f₁ f₂ : Sat.Fmla), Sat.Fmla.subsumes f (Sat.Fmla.and f₁ f₂) → Sat.Fmla.subsumes f f₁",
  "offspring":
  ["Sat.Fmla.subsumes.mk",
   "Sat.Fmla.subsumes.prop",
   "List.mem_append",
   "Sat.Clause"],
  "name": "Sat.Fmla.subsumes_left"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x",
  "offspring": [],
  "name": "Equivalence.symm"},
 {"type": "Nonempty (Fin UInt64.size)",
  "offspring": ["instNonempty", "UInt64.instInhabitedFinSize"],
  "name": "UInt64.instRingUInt64.proof_2"},
 {"type": "∀ {α : Type u_1}, ∃ n m, UFModel.Models #[] m",
  "offspring": ["UFModel.empty", "UFModel.Models.empty"],
  "name": "UnionFind.empty.proof_1"},
 {"type":
  "∀ {α : Type u} (a : α) (m n : ℕ), List.replicateTR.loop a n (List.replicate m a) = List.replicate (n + m) a",
  "offspring": ["Nat.zero_eq", "Nat.zero_add", "Nat.succ_add"],
  "name": "List.replicateTR_loop_replicate_eq"},
 {"type": "{α : Sort u} → [s : Setoid α] → α → Quotient s",
  "offspring": ["Quotient.mk"],
  "name": "Quotient.mk'"},
 {"type": "WellFounded WellFoundedRelation.rel",
  "offspring": ["WellFoundedRelation.wf"],
  "name": "Nat.gcd.proof_1"},
 {"type":
  "∀ {v : Sat.Valuation} {c : Sat.Clause} {p : Prop}, Sat.Clause.reify v c p → ¬Sat.Valuation.satisfies v c → p",
  "offspring": [],
  "name": "Sat.Clause.reify.prop"},
 {"type": "∀ (a : ℤ), ¬a < a",
  "offspring": ["Int.lt.dest"],
  "name": "Int.lt_irrefl"},
 {"type":
  "∀ {α : Type u_1} {a : α} {x : Option (Option α)}, a ∈ Option.join x → some a ∈ x",
  "offspring": ["Option.mem_def", "Option.join_eq_some"],
  "name": "Option.mem_of_mem_join"},
 {"type": "∀ (a : UInt32), a + 0 = a",
  "offspring":
  ["UInt32.zero_def",
   "UInt32.add_def",
   "UInt32.mk",
   "add_zero",
   "UInt32.mk_val_eq"],
  "name": "UInt32.instSemiringUInt32.proof_1"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f : α → β}, Function.surjective f → Function.has_RightInverse f",
  "offspring": ["Function.surj_inv", "Function.RightInverse_surj_inv"],
  "name": "Function.surjective.has_RightInverse"},
 {"type": "∀ {p q : Prop}, ¬p → p ∧ q → False",
  "offspring": [],
  "name": "instDecidableAnd.proof_2"},
 {"type":
  "Sort u → Mathlib.Tactic.Lint.Linter → Mathlib.Tactic.Lint.Linter → Sort u",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.noConfusionType"},
 {"type": "(a b : UInt64) → Decidable (a < b)",
  "offspring": ["UInt64.decLt"],
  "name": "instDecidableLtUInt64InstLTUInt64"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : Array α), (Array.isEqv a b fun a b => decide (a = b)) = true → a = b",
  "offspring": ["Array.eq_of_isEqv"],
  "name": "Array.instDecidableEqArray.proof_2"},
 {"type": "{α : Sort u_1} → {β : Type u_2} → (ℕ → α → β → α) → α → List β → α",
  "offspring": ["List.foldlIdxAux"],
  "name": "List.foldlIdx"},
 {"type":
  "∀ {α : Type u_1} (f : List α → List α),\n  (∀ (l : List α), List.length (f l) = List.length l) →\n    ∀ (n : ℕ) (l : List α), List.length (List.modifyNthTail f n l) = List.length l",
  "offspring": ["congr_arg"],
  "name": "List.modifyNthTail_length"},
 {"type": "∀ {p : Prop}, ¬p → p = False", "offspring": [], "name": "eq_false"},
 {"type":
  "∀ {A : Type u} [inst : AddCommSemigroup A] (a b c d : A), a + b + (c + d) = a + c + (b + d)",
  "offspring": ["add_left_comm", "add_assoc"],
  "name": "add_add_add_comm"},
 {"type": "Semigroup USize",
  "offspring":
  ["Semigroup.mk", "instMulUSize", "USize.instSemigroupUSize.proof_1"],
  "name": "USize.instSemigroupUSize"},
 {"type": "(α : Sort u_1) → α ≃ α",
  "offspring": ["Equiv.mk", "Equiv.refl.proof_1", "Equiv.refl.proof_2"],
  "name": "Equiv.refl"},
 {"type":
  "∀ {p₁ p₂ q₁ : Prop}, p₁ = p₂ → ∀ {q₂ : p₂ → Prop}, (∀ (h : p₂), q₁ = q₂ h) → (p₁ → q₁) = ∀ (h : p₂), q₂ h",
  "offspring": [],
  "name": "implies_dep_congr_ctx"},
 {"type": "∀ {a b : Prop}, (a → b) → ¬a ∨ b",
  "offspring": ["Decidable.not_or_of_imp"],
  "name": "not_or_of_imp"},
 {"type": "∀ {G₀ : Type u} [self : GroupWithZero G₀], ∃ x y, x ≠ y",
  "offspring": [],
  "name": "GroupWithZero.exists_pair_ne"},
 {"type": "∀ {a a_1 : ℕ}, -[1+ a] = -[1+ a_1] → a = a_1",
  "offspring": [],
  "name": "Int.negSucc.inj"},
 {"type": "∀ {a b : ℤ}, a < b → ∀ (c : ℤ), c + a < c + b",
  "offspring":
  ["Int.lt_iff_le_and_ne",
   "Int.add_le_add_left",
   "Int.le_of_lt",
   "Int.lt_irrefl",
   "Int.add_left_cancel"],
  "name": "Int.add_lt_add_left"},
 {"type": "∀ {α β : Type u_1} {f : α → β}, f <$> none = none",
  "offspring": [],
  "name": "Option.map_none"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε β : Type u_1} {e : ε} [inst : Monad m], ExceptT.run (throw e) = pure (Except.error e)",
  "offspring": [],
  "name": "ExceptT.run_throw"},
 {"type": "∀ {a b c d : Prop}, (c → a) → (b → d) → (a → b) → c → d",
  "offspring": [],
  "name": "imp_imp_imp"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["Fin.mul.proof_1"],
  "name": "Fin.mul"},
 {"type": "Nat.Linear.Poly → Nat.Linear.Expr",
  "offspring": ["Nat.Linear.Var"],
  "name": "Nat.Linear.Poly.toExpr"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "Set.term𝒫_"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x : Fin (UnionFind.size self)),\n  (Array.get self.arr x).parent = ↑x →\n    ∃ n m m',\n      UFModel.Models self.arr m ∧\n        UFModel.Models self.arr m' ∧\n          m'.rank = m.rank ∧\n            (∃ hr, ↑(UFModel.parent m' { val := ↑x, isLt := hr }) = ↑x) ∧ UFModel.rank m ↑x ≤ UFModel.rank m ↑x",
  "offspring":
  ["UnionFind.arr",
   "Fin.isLt",
   "UFModel.parent",
   "UFModel.Models.parent_eq'",
   "le_refl",
   "UFModel.rank",
   "UnionFind.model'"],
  "name": "UnionFind.findAux.proof_2"},
 {"type": "(n : ℕ) → n < 4294967296 → USize",
  "offspring": ["USize.mk", "USize.size", "USize.ofNat32.proof_1"],
  "name": "USize.ofNat32"},
 {"type": "{f : Type u → Type v} → [self : Alternative f] → {α : Type u} → f α",
  "offspring": [],
  "name": "Alternative.failure"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} (w : α), p w → (∀ (y : α), p y → y = w) → ExistsUnique fun x => p x",
  "offspring": [],
  "name": "ExistsUnique.intro"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a : α), Function.injective (Prod.mk a)",
  "offspring": ["Prod.mk.inj"],
  "name": "Prod.mk.inj_left"},
 {"type": "{α : Type u_1} → [inst : CommSemiring α] → α → α → ℕ → α → α",
  "offspring": ["HPow.hPow"],
  "name": "Tactic.Ring.horner"},
 {"type": "Type", "offspring": [], "name": "NonScalar"},
 {"type":
  "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → (α → β) → f α → f β",
  "offspring": [],
  "name": "Functor.map"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : BEq α] → [inst : BEq β] → BEq (α × β)",
  "offspring": ["BEq.mk"],
  "name": "instBEqProd"},
 {"type": "∀ (a : ℤ), a * 0 = 0", "offspring": [], "name": "Int.mul_zero"},
 {"type": "Sort u → Sort (max 1 u)",
  "offspring": [],
  "name": "WellFoundedRelation"},
 {"type": "∀ {m n k : ℕ}, m ≤ k * n → m / k ≤ n",
  "offspring": ["Nat.div_zero", "Nat.zero_le"],
  "name": "Nat.div_le_of_le_mul"},
 {"type":
  "∀ {α : Lean.Expr} {univ : Lean.Level} {cs α_1 : Lean.Expr} {univ_1 : Lean.Level} {cs_1 : Lean.Expr},\n  { α := α, univ := univ, cs := cs } = { α := α_1, univ := univ_1, cs := cs_1 } → α = α_1 ∧ univ = univ_1 ∧ cs = cs_1",
  "offspring": [],
  "name": "Tactic.Ring.Cache.mk.inj"},
 {"type": "{p : Prop} → Sort u → Decidable p → Decidable p → Sort u",
  "offspring": [],
  "name": "Decidable.noConfusionType"},
 {"type": "{α : Type u} → List α → List α → List α",
  "offspring": [],
  "name": "List.append"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β},\n  Function.bijective f → ∀ (g : γ → α), Function.surjective (f ∘ g) ↔ Function.surjective g",
  "offspring":
  ["Function.bijective.injective",
   "Function.surjective.comp",
   "Function.bijective.surjective"],
  "name": "Function.surjective.of_comp_iff'"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadReader ρ m] → m ρ",
  "offspring": [],
  "name": "MonadReader.read"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExcept ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "offspring": [],
  "name": "MonadExcept.tryCatch"},
 {"type": "{motive : Nat.Linear.Expr → Prop} → Nat.Linear.Expr → Prop",
  "offspring": [],
  "name": "Nat.Linear.Expr.ibelow"},
 {"type": "ℕ → ℕ → ℕ",
  "offspring": ["WellFounded.fix", "Nat.sub_lt", "Nat.lt_of_lt_of_le"],
  "name": "Nat.mod"},
 {"type": "Sort u → Sort (max 1 u)",
  "offspring": ["Decidable"],
  "name": "DecidableEq"},
 {"type": "Mathlib.Tactic.Lint.LintVerbosity",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.low"},
 {"type": "∀ {m k : ℕ}, Nat.gcd k m = Nat.zero → Nat.zero = Nat.gcd k m",
  "offspring": [],
  "name": "Nat.prod_dvd_and_dvd_of_dvd_prod.proof_1"},
 {"type": "∀ (n : ℕ), n + n ≠ 1",
  "offspring": [],
  "name": "Nat.add_self_ne_one"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_1} {p q : α → β → γ → Prop},\n  (∀ (a : α) (b : β) (c : γ), p a b c ↔ q a b c) →\n    ((∀ (a : α) (b : β) (c : γ), p a b c) ↔ ∀ (a : α) (b : β) (c : γ), q a b c)",
  "offspring": ["forall_congr'", "forall₂_congr"],
  "name": "forall₃_congr"},
 {"type":
  "∀ {α σ β : Type u} {m : Type u → Type v} (a : α) (s : σ) (k : α → σ → m β), StateCpsT.runK (pure a) s k = k a s",
  "offspring": [],
  "name": "StateCpsT.runK_pure"},
 {"type": "ℕ → ℕ → List Char",
  "offspring": ["Nat.toDigitsCore"],
  "name": "Nat.toDigits"},
 {"type": "∀ {a b c : ℤ}, a - b < c → a < b + c",
  "offspring": [],
  "name": "Int.lt_add_of_sub_left_lt"},
 {"type": "Type", "offspring": [], "name": "UInt64"},
 {"type": "∀ {n m : ℕ}, n + m = 0 → m = 0",
  "offspring": ["Nat.eq_zero_of_add_eq_zero_right"],
  "name": "Nat.eq_zero_of_add_eq_zero_left"},
 {"type": "Sub USize",
  "offspring": ["Sub.mk", "USize.sub"],
  "name": "instSubUSize"},
 {"type":
  "{α : Type u_1} →\n  (self : UnionFind α) →\n    (i : ℕ) →\n      { k // ∀ (j : ℕ), j < i → ∀ (h : j < Array.size self.arr), (Array.get self.arr { val := j, isLt := h }).rank ≤ k }",
  "offspring":
  ["Subtype.mk",
   "UnionFind.rankMaxAux.proof_1",
   "max",
   "UnionFind.rankMaxAux.proof_2"],
  "name": "UnionFind.rankMaxAux"},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_3} → {β : Type u_1} → [inst : Monad m] → (α → m β) → Option α → m (Option β)",
  "offspring": [],
  "name": "Option.mapM"},
 {"type":
  "∀ {α : Type u} [inst : LT α] {motive : (a a_1 : List α) → List.lt a a_1 → Prop} {a : α} {as : List α} {b : α}\n  {bs : List α},\n  ¬a < b →\n    ¬b < a →\n      ∀ {a_3 : List.lt as bs}, List.lt.below a_3 → motive as bs a_3 → List.lt.below (_ : List.lt (a :: as) (b :: bs))",
  "offspring": [],
  "name": "List.lt.below.tail"},
 {"type": "{α : Type u} → Array α → ℕ → ℕ → Array α",
  "offspring": ["Array.swap", "panicWithPosWithDecl"],
  "name": "Array.swap!"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → Sort u_1 → MonadExceptOf ε m → MonadExceptOf ε m → Sort u_1",
  "offspring": [],
  "name": "MonadExceptOf.noConfusionType"},
 {"type": "{α : Sort u} → [self : Setoid α] → α → α → Prop",
  "offspring": [],
  "name": "Setoid.r"},
 {"type": "DecidableEq Char",
  "offspring": ["decEq"],
  "name": "instDecidableEqChar"},
 {"type": "List UInt8 → ByteArray",
  "offspring": [],
  "name": "List.toByteArray"},
 {"type": "∀ {α β : Sort u_1} (h₁ h₂ : α = β) (a : α), cast h₁ a = cast h₂ a",
  "offspring": [],
  "name": "cast_proof_irrel"},
 {"type": "System.FilePath → BaseIO Bool",
  "offspring": ["System.FilePath.metadata"],
  "name": "System.FilePath.isDir"},
 {"type": "AddCommSemigroup USize",
  "offspring":
  ["AddCommSemigroup.mk",
   "USize.instAddSemigroupUSize",
   "USize.instAddCommSemigroupUSize.proof_1"],
  "name": "USize.instAddCommSemigroupUSize"},
 {"type": "{α : Sort u} → (α → α → Prop) → Prop",
  "offspring": [],
  "name": "WellFounded"},
 {"type": "Substring → String.Pos",
  "offspring": [],
  "name": "Substring.stopPos"},
 {"type": "∀ {a : ℤ}, a ≤ 0 → ∃ n, a = -↑n",
  "offspring":
  ["Int.eq_neg_of_eq_neg",
   "Int.eq_ofNat_of_zero_le",
   "Int.neg_nonneg_of_nonpos"],
  "name": "Int.exists_eq_neg_ofNat"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (x : α), x = Tactic.Ring.horner 1 x 1 0",
  "offspring": ["pow_one", "one_mul", "add_zero"],
  "name": "Tactic.Ring.horner_atom"},
 {"type": "∀ {α : Type u_1}, (fun p => (p.fst, p.snd)) = id",
  "offspring": [],
  "name": "Prod.id_prod"},
 {"type": "{α : Type u_1} → Set α → Set α → Set α",
  "offspring": ["setOf"],
  "name": "Set.diff"},
 {"type":
  "∀ {R : Type u_1} {m n : ℕ} [inst : AddMonoidWithOne R], ↑(m + n) = ↑m + ↑n",
  "offspring":
  ["Nat.zero_eq",
   "Nat.add_zero",
   "Nat.cast_zero",
   "add_zero",
   "Nat.add_succ",
   "Nat.cast_succ",
   "add_assoc"],
  "name": "Nat.cast_add"},
 {"type":
  "{R : Type u} →\n  [toAddMonoidWithOne : AddMonoidWithOne R] →\n    [toNeg : Neg R] →\n      [toSub : Sub R] →\n        (∀ (a b : R), a - b = a + -b) →\n          (gsmul : ℤ → R → R) →\n            (∀ (a : R), gsmul 0 a = 0) →\n              (∀ (n : ℕ) (a : R), gsmul (Int.ofNat (Nat.succ n)) a = a + gsmul (Int.ofNat n) a) →\n                (∀ (n : ℕ) (a : R), gsmul -[1+ n] a = -gsmul (Int.ofNat (Nat.succ n)) a) →\n                  (∀ (a : R), -a + a = 0) →\n                    (intCast : ℤ → R) →\n                      (∀ (n : ℕ), intCast (Int.ofNat n) = AddMonoidWithOne.natCast n) →\n                        (∀ (n : ℕ), intCast -[1+ n] = -AddMonoidWithOne.natCast (n + 1)) → AddGroupWithOne R",
  "offspring": [],
  "name": "AddGroupWithOne.mk"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β},\n  Function.surjective f → ∀ {p : β → β → β → Prop}, (∃ y₁ y₂ y₃, p y₁ y₂ y₃) ↔ ∃ x₁ x₂ x₃, p (f x₁) (f x₂) (f x₃)",
  "offspring":
  ["Iff.trans",
   "Function.surjective.exists",
   "exists_congr",
   "Function.surjective.exists₂"],
  "name": "Function.surjective.exists₃"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p], List.erasep p [] = []",
  "offspring": [],
  "name": "List.erasep_nil"},
 {"type": "∀ {a b : ℕ}, 0 < a → 0 < b → Nat.pred a = Nat.pred b → a = b",
  "offspring": ["Nat.lt_irrefl"],
  "name": "Nat.pred_inj"},
 {"type": "∀ {a b c d : Prop}, (a → c) → (b → d) → a ∧ b → c ∧ d",
  "offspring": [],
  "name": "And.imp"},
 {"type": "∀ (a b : ℤ), -(a * b) = -a * b",
  "offspring":
  ["Int.neg_eq_of_add_eq_zero",
   "Int.distrib_right",
   "Int.add_right_neg",
   "Int.zero_mul"],
  "name": "Int.neg_mul_eq_neg_mul"},
 {"type": "{n : ℕ} → OfNat ℤ n",
  "offspring": ["OfNat.mk"],
  "name": "instOfNatInt"},
 {"type": "∀ (b : Bool), (false || b) = b",
  "offspring": [],
  "name": "Bool.false_or"},
 {"type": "∀ (n : ℕ), 0 < ↑(Nat.succ n)",
  "offspring": ["Int.ofNat_lt", "Nat.succ_pos"],
  "name": "Int.ofNat_succ_pos"},
 {"type": "ByteArray → UInt8 → ByteArray",
  "offspring": ["ByteArray.mk", "Array.push"],
  "name": "ByteArray.push"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → (α → β → Prop) → (β → γ → Prop) → outParam (α → γ → Prop) → Type",
  "offspring": [],
  "name": "Trans"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {k : ℕ}, List.length l ≤ k → List.drop k l = []",
  "offspring": [],
  "name": "List.drop_eq_nil_of_le"},
 {"type": "∀ {m k : ℕ} (n : ℕ), Nat.coprime m k → Nat.coprime (m ^ n) k",
  "offspring": ["Nat.coprime_one_left"],
  "name": "Nat.coprime.pow_left"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → MonoidWithZero (Fin n)",
  "offspring":
  ["MonoidWithZero.mk",
   "instMonoidWithZeroFin.proof_4",
   "instMonoidWithZeroFin.proof_5",
   "CommSemigroup"],
  "name": "instMonoidWithZeroFin"},
 {"type":
  "∀ (arr : ByteArray) (off len : ℕ),\n  sizeOf { arr := arr, off := off, len := len } = 1 + sizeOf arr + sizeOf off + sizeOf len",
  "offspring": ["ByteArray", "instSizeOfNat"],
  "name": "ByteSlice.mk.sizeOf_spec"},
 {"type":
  "∀ {p : Prop} {α : Sort u_1} [inst : Nonempty α] (f : p → α) (a : p), Function.sometimes f = f a",
  "offspring": ["dif_pos"],
  "name": "Function.sometimes_eq"},
 {"type": "{α : Type u_1} → Set α → Set α → Prop",
  "offspring": [],
  "name": "Set.subset"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk", "Fin.xor", "UInt8.size"],
  "name": "UInt8.xor"},
 {"type": "∀ (m n : ℕ), Nat.gcd (m * n) n = n",
  "offspring":
  ["Nat.dvd_antisymm",
   "Nat.gcd_dvd_right",
   "Nat.dvd_gcd",
   "Nat.dvd_mul_left",
   "Nat.dvd_refl"],
  "name": "Nat.gcd_mul_left_left"},
 {"type": "Inhabited Tactic.Ring.HornerExpr",
  "offspring": ["Tactic.Ring.HornerExpr.const"],
  "name": "Tactic.Ring.instInhabitedHornerExpr"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (fuel : ℕ) (p₁ p₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.combineAux fuel p₁ p₂) =\n    Nat.Linear.Poly.denote ctx p₁ + Nat.Linear.Poly.denote ctx p₂",
  "offspring":
  ["Nat.Linear.Poly.denote_append",
   "Nat.zero_add",
   "Nat.add_left_comm",
   "Nat.add_assoc",
   "cond_true",
   "Bool.of_not_eq_true",
   "cond_false",
   "Nat.right_distrib"],
  "name": "Nat.Linear.Poly.denote_combineAux"},
 {"type": "Mul ℤ",
  "offspring": ["Mul.mk", "Int.mul"],
  "name": "Int.instMulInt"},
 {"type":
  "∀ {α : Type}, Nonempty (Tactic.Cache α × (Lean.Name → Lean.ConstantInfo → α → Lean.MetaM α))",
  "offspring": ["Prod"],
  "name": "Tactic.instNonemptyDeclCache.proof_1"},
 {"type":
  "∀ {α : Sort u_1} (P : Prop) [inst : Decidable P] (x : ¬P → α) (y : ¬¬P → α),\n  dite (¬P) x y = dite P (fun h => y (_ : ¬¬P)) x",
  "offspring":
  ["dite_congr",
   "instDecidableFalse",
   "eq_false_of_decide",
   "Eq.mpr_prop",
   "Eq.mpr_not",
   "dite_false",
   "not_not_intro",
   "dite_true",
   "not_false",
   "True.intro"],
  "name": "dite_not"},
 {"type": "Add UInt64",
  "offspring": ["Add.mk", "UInt64.add"],
  "name": "instAddUInt64"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} {δ : Type u_4} {f : α → γ} {g : β → δ},\n  Function.surjective f → Function.surjective g → Function.surjective (Prod.map f g)",
  "offspring": ["Prod.ext'"],
  "name": "Function.surjective.prod_map"},
 {"type":
  "{α : Type u} → [n : Nonempty α] → {β : Sort v} → (α → β) → Set α → β → α",
  "offspring": ["Classical.choose", "Classical.choice"],
  "name": "Function.inv_fun_on"},
 {"type":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], ¬a → b ↔ ¬b → a",
  "offspring": ["Not.decidable_imp_symm"],
  "name": "Decidable.not_imp_comm"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk", "Fin.land", "UInt8.size"],
  "name": "UInt8.land"},
 {"type": "∀ {p q : Prop}, p = q → q → p",
  "offspring": [],
  "name": "Eq.mpr_prop"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → List (ℕ × α)",
  "offspring": ["List.foldrIdx"],
  "name": "List.indexesValues"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt) (i : Fin (BinaryHeap.size self)) (x : α),\n  ↑i < Array.size (Array.set self.arr i x)",
  "offspring": ["Array.set", "Array.size_set", "Fin.isLt"],
  "name": "BinaryHeap.decreaseKey.proof_1"},
 {"type": "{α : Type u} → (α → Bool) → List α → List α → List α × List α",
  "offspring": ["List.reverse"],
  "name": "List.spanAux"},
 {"type": "∀ {a b c : ℤ}, a + b ≤ c + b → a ≤ c",
  "offspring": ["Int.le_of_add_le_add_left", "Int.add_comm"],
  "name": "Int.le_of_add_le_add_right"},
 {"type": "{α : Type u} → (α → α → α) → Append α",
  "offspring": [],
  "name": "Append.mk"},
 {"type": "Nat.Linear.Context → Nat.Linear.Var → ℕ",
  "offspring": ["cond", "Nat.Linear.Var", "instBEqNat", "Nat.Linear.fixedVar"],
  "name": "Nat.Linear.Var.denote"},
 {"type":
  "{R : Type u} → [self : NonUnitalNonAssocSemiring R] → AddMonoidWithOne R",
  "offspring":
  ["AddMonoidWithOne.mk",
   "NonUnitalNonAssocSemiring.natCast",
   "NonUnitalNonAssocSemiring.natCast_zero",
   "NonUnitalNonAssocSemiring.natCast_succ"],
  "name": "NonUnitalNonAssocSemiring.toAddMonoidWithOne"},
 {"type":
  "∀ {c : Prop} [h : Decidable c] {α : Sort u_1} (t : α), (if c then t else t) = t",
  "offspring": [],
  "name": "ite_id"},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : ToString α] → [inst : ToString β] → ToString (α × β)",
  "offspring": ["ToString.mk"],
  "name": "instToStringProd"},
 {"type": "Mathlib.Tactic.Lint.SimpTheoremInfo → Array Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.hyps"},
 {"type":
  "{R : Type u} →\n  [toAddCommMonoid : AddCommMonoid R] →\n    [toMul : Mul R] →\n      (∀ (a b c : R), a * (b + c) = a * b + a * c) →\n        (∀ (a b c : R), (a + b) * c = a * c + b * c) →\n          (∀ (a : R), 0 * a = 0) →\n            (∀ (a : R), a * 0 = 0) →\n              [toOne : One R] →\n                (natCast : ℕ → R) →\n                  natCast 0 = 0 → (∀ (n : ℕ), natCast (n + 1) = natCast n + 1) → NonUnitalNonAssocSemiring R",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.mk"},
 {"type":
  "{α : Sort u} → {β : Sort v} → Sort u_1 → CoeHead α β → CoeHead α β → Sort u_1",
  "offspring": [],
  "name": "CoeHead.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} {a : α}, List.get? l n = some a → a ∈ l",
  "offspring": ["List.get_mem", "List.get?_eq_some"],
  "name": "List.get?_mem"},
 {"type": "{α : Type u} → [self : ToBool α] → α → Bool",
  "offspring": [],
  "name": "ToBool.toBool"},
 {"type": "{α : Type u} → [inst : Repr α] → Repr (Array α)",
  "offspring": ["instBEqNat", "Array.toList", "repr"],
  "name": "Array.instReprArray"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β} {g : β → α}, Function.RightInverse g f → Function.surjective f",
  "offspring": [],
  "name": "Function.RightInverse.surjective"},
 {"type": "∀ {α : Type u_1} (x : α), Option.getD none x = x",
  "offspring": [],
  "name": "Option.getD_none"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {toFun : α → β} {invFun : β → α} {left_inv : Function.LeftInverse invFun toFun}\n  {right_inv : Function.RightInverse invFun toFun} {toFun_1 : α → β} {invFun_1 : β → α}\n  {left_inv_1 : Function.LeftInverse invFun_1 toFun_1} {right_inv_1 : Function.RightInverse invFun_1 toFun_1},\n  { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv } =\n      { toFun := toFun_1, invFun := invFun_1, left_inv := left_inv_1, right_inv := right_inv_1 } →\n    toFun = toFun_1 ∧ invFun = invFun_1",
  "offspring": [],
  "name": "Equiv.mk.inj"},
 {"type": "{β : Type u} → {α : Type v} → [inst : ToBool β] → α → α → β → α",
  "offspring": ["ToBool.toBool"],
  "name": "bool"},
 {"type":
  "{α : Type u} → {p : α → Prop} → {a : α} → p a → Inhabited { x // p x }",
  "offspring": ["Subtype.mk"],
  "name": "Subtype.instInhabitedSubtype"},
 {"type":
  "∀ (arr : ByteArray) (off len : ℕ) (arr_1 : ByteArray) (off_1 len_1 : ℕ),\n  ({ arr := arr, off := off, len := len } = { arr := arr_1, off := off_1, len := len_1 }) =\n    (arr = arr_1 ∧ off = off_1 ∧ len = len_1)",
  "offspring": ["ByteArray", "ByteSlice", "ByteSlice.mk"],
  "name": "ByteSlice.mk.injEq"},
 {"type": "Lean.Name → Lean.Name → Lean.CoreM Unit",
  "offspring": ["Mathlib.Prelude.Rename.renameExtension"],
  "name": "Mathlib.Prelude.Rename.addNameAlignment"},
 {"type":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "offspring": [],
  "name": "dite"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {γ : Sort u_3} {f : α → β} {g : β → α} {h : β → γ} {i : γ → β},\n  Function.RightInverse f g → Function.RightInverse h i → Function.RightInverse (h ∘ f) (g ∘ i)",
  "offspring": ["Function.LeftInverse.comp"],
  "name": "Function.RightInverse.comp"},
 {"type": "∀ (n : ℕ), n < Nat.succ n",
  "offspring": ["Nat.lt.base"],
  "name": "Nat.lt_succ_self"},
 {"type": "{α : Sort u} → [s : DecidableEq α] → (a b : α) → Decidable (a = b)",
  "offspring": [],
  "name": "decEq"},
 {"type":
  "∀ {A : Type u} [inst : AddCommSemigroup A] (a b c : A), a + (b + c) = b + (a + c)",
  "offspring": ["add_assoc", "add_comm"],
  "name": "add_left_comm"},
 {"type": "{α : Type u} → {β : Type v} → List (α × β) → List α × List β",
  "offspring": [],
  "name": "List.unzip"},
 {"type": "∀ (a : ℕ), a ∣ a",
  "offspring": ["Nat.mul_one"],
  "name": "Nat.dvd_refl"},
 {"type":
  "{β α σ : Type u} → {m : Type u → Type v} → StateCpsT σ m α → σ → (α → σ → m β) → m β",
  "offspring": [],
  "name": "StateCpsT.runK"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} (e₁ : α ≃ β) (e₂ : β ≃ γ),\n  Function.LeftInverse (e₁.invFun ∘ e₂.invFun) (e₂.toFun ∘ e₁.toFun)",
  "offspring": ["Function.LeftInverse.comp"],
  "name": "Equiv.trans.proof_1"},
 {"type": "∀ {a b : ℤ}, a ≠ 0 → b * a = a → b = 1",
  "offspring": ["Int.eq_of_mul_eq_mul_right", "Int.one_mul"],
  "name": "Int.eq_one_of_mul_eq_self_left"},
 {"type":
  "∀ {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β} {motive : Quotient s₁ → Quotient s₂ → Prop},\n  (∀ (a : α) (b : β), motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)) →\n    ∀ (q₁ : Quotient s₁) (q₂ : Quotient s₂), motive q₁ q₂",
  "offspring": ["Quotient.ind"],
  "name": "Quotient.ind₂"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.tacticSplit_ands"},
 {"type": "(self : FloatSpec) → self.float",
  "offspring": [],
  "name": "FloatSpec.val"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (f : (a : α) → motive (Quot.mk r a)),\n  (∀ (a b : α), r a b → (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) →\n    ∀ (q : Quot r), (Quot.lift (Quot.indep f) (_ : ∀ (a b : α), r a b → Quot.indep f a = Quot.indep f b) q).fst = q",
  "offspring": ["Quot.ind"],
  "name": "Quot.liftIndepPr1"},
 {"type":
  "∀ {α : Type u_1} (l : List α), List.length (List.tail l) = List.length l - 1",
  "offspring": [],
  "name": "List.length_tail"},
 {"type": "Lean.Environment → Lean.Meta.DiscrTree Lean.Name",
  "offspring": ["Mathlib.Tactic.Ext.extExtension"],
  "name": "Mathlib.Tactic.Ext.extLemmas"},
 {"type": "{α : Type u} → (α → Bool) → List α → List α × List α",
  "offspring": ["List.partitionAux"],
  "name": "List.partition"},
 {"type":
  "Bool → List Lean.Name → Bool → Lean.CoreM (List Mathlib.Tactic.Lint.NamedLinter)",
  "offspring":
  ["Mathlib.Tactic.Lint.getLinters",
   "Array.toList",
   "Mathlib.Tactic.Lint.mathlibLinterAttr",
   "List.filter",
   "Mathlib.Tactic.Lint.Linter.isFast",
   "Mathlib.Tactic.Lint.NamedLinter.toLinter"],
  "name": "Mathlib.Tactic.Lint.getChecks"},
 {"type":
  "∀ {α : Type u} (as bs cs : List α),\n  List.reverseAux (List.reverseAux as bs) cs = List.reverseAux bs (List.reverseAux (List.reverseAux as []) cs)",
  "offspring": [],
  "name": "List.reverseAux_reverseAux"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [self : LawfulApplicative f] {α β : Type u} (g : α → β) (x : f α),\n  (Seq.seq (pure g) fun x_1 => x) = g <$> x",
  "offspring": [],
  "name": "LawfulApplicative.pure_seq"},
 {"type":
  "∀ {test : Lean.Name → Lean.MetaM (Option Lean.MessageData)} {noErrorsFound errorsFound : Lean.MessageData}\n  {isFast : Bool} {test_1 : Lean.Name → Lean.MetaM (Option Lean.MessageData)}\n  {noErrorsFound_1 errorsFound_1 : Lean.MessageData} {isFast_1 : Bool},\n  { test := test, noErrorsFound := noErrorsFound, errorsFound := errorsFound, isFast := isFast } =\n      { test := test_1, noErrorsFound := noErrorsFound_1, errorsFound := errorsFound_1, isFast := isFast_1 } →\n    test = test_1 ∧ noErrorsFound = noErrorsFound_1 ∧ errorsFound = errorsFound_1 ∧ isFast = isFast_1",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.mk.inj"},
 {"type": "∀ {n : ℕ}, 0 < n → Nat.succ (Nat.pred n) = n",
  "offspring": [],
  "name": "Nat.succ_pred_eq_of_pos"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {h : ∀ (a : α), p a → p (id a)}, Subtype.map id h = id",
  "offspring": [],
  "name": "Subtype.map_id"},
 {"type": "{α : Type u_1} → {β : Sort u_2} → (ℕ → α → β → β) → β → List α → β",
  "offspring": ["List.foldrIdxAux"],
  "name": "List.foldrIdx"},
 {"type": "Repr Mathlib.Tactic.Lint.LintVerbosity",
  "offspring": ["GE.ge"],
  "name": "Mathlib.Tactic.Lint.instReprLintVerbosity"},
 {"type": "Lean.ParserDescr", "offspring": ["calcStep"], "name": "tacticCalc_"},
 {"type": "∀ (a b c : UInt8), (a + b) * c = a * c + b * c",
  "offspring":
  ["UInt8.add_def",
   "UInt8.mul_def",
   "UInt8.mk",
   "UInt8.eq_of_val_eq",
   "Distrib.right_distrib"],
  "name": "UInt8.instSemiringUInt8.proof_8"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α × β → γ) (x : α) (y : β), Function.curry f x y = f (x, y)",
  "offspring": [],
  "name": "Function.curry_apply"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.isSuffix"},
 {"type": "∀ {α β : Sort u} {a : α} {b : β}, HEq a b → HEq b a",
  "offspring": ["HEq.ndrecOn"],
  "name": "HEq.symm"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l₁ : List α} (l₂ : List α),\n  a ∈ l₁ → List.erase (l₁ ++ l₂) a = List.erase l₁ a ++ l₂",
  "offspring": ["List.erase_eq_erasep", "List.erasep_append_left"],
  "name": "List.erase_append_left"},
 {"type":
  "{m : Type → Type v} → [inst : Monad m] → {α : Type} → (α → m Bool) → List α → m (List α)",
  "offspring": ["List.filterAuxM", "List.reverse"],
  "name": "List.filterM"},
 {"type": "Lean.Name → Option Lean.Name",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.isEqnLemma?"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.RunTac.tacticRun_tac_"},
 {"type": "∀ {a b : ℤ}, a < b → ∀ (c : ℤ), a + c < b + c",
  "offspring": ["Int.add_comm", "Int.add_lt_add_left"],
  "name": "Int.add_lt_add_right"},
 {"type": "Semigroup UInt16",
  "offspring":
  ["Semigroup.mk", "instMulUInt16", "UInt16.instSemigroupUInt16.proof_1"],
  "name": "UInt16.instSemigroupUInt16"},
 {"type": "∀ {a b : ℕ}, a < b → b - a ≠ 0",
  "offspring":
  ["Ne",
   "Nat.lt_irrefl",
   "Nat.sub_zero",
   "ne_eq",
   "eq_false'",
   "Nat.not_lt_zero",
   "Nat.succ_sub_succ",
   "Nat.lt_of_succ_lt_succ"],
  "name": "Nat.sub_ne_zero_of_lt"},
 {"type":
  "{A : Type u} → [toAddMonoid : AddMonoid A] → (∀ (a b : A), a + b = b + a) → AddCommMonoid A",
  "offspring": [],
  "name": "AddCommMonoid.mk"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«stx_,+,?»"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop}\n  {motive : (a : List α) → (a_1 : List β) → List.Forall₂ R a a_1 → Prop} {a : List α} {a_1 : List β}\n  (x : List.Forall₂ R a a_1),\n  (∀ (a : List α) (a_2 : List β) (x : List.Forall₂ R a a_2), List.Forall₂.below x → motive a a_2 x) → motive a a_1 x",
  "offspring": ["List.Forall₂.below.nil", "List.Forall₂.below.cons"],
  "name": "List.Forall₂.brecOn"},
 {"type": "∀ {a : ℤ}, 0 ≤ -a → a ≤ 0",
  "offspring": ["Int.le_of_neg_le_neg", "Int.neg_zero"],
  "name": "Int.nonpos_of_neg_nonneg"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {r : α → α → Prop} {s : (a : α) → β a → β a → Prop} {a₁ : α} (b₁ : β a₁) {a₂ : α}\n  (b₂ : β a₂), r a₁ a₂ → PSigma.Lex r s { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }",
  "offspring": [],
  "name": "PSigma.Lex.left"},
 {"type": "∀ {m n : ℕ}, -[1+ m] = -[1+ n] ↔ m = n",
  "offspring": ["Int.negSucc.inj"],
  "name": "Int.negSucc_ofNat_inj_iff"},
 {"type": "AndOp UInt64",
  "offspring": ["AndOp.mk", "UInt64.land"],
  "name": "instAndOpUInt64"},
 {"type": "∀ {a : ℤ}, Int.NonNeg a ↔ ∃ n, a = ↑n",
  "offspring": ["Int.NonNeg.mk"],
  "name": "Int.nonneg_def"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk", "HShiftLeft.hShiftLeft", "UInt32.modn"],
  "name": "UInt32.shiftLeft"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] {a b : A}, a - b = 0 → a = b",
  "offspring": ["add_right_cancel"],
  "name": "eq_of_sub_eq_zero'"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)],\n  (fun n_1 => Fin.ofNat' n_1 (_ : 0 < n)) 0 = (fun n_1 => Fin.ofNat' n_1 (_ : 0 < n)) 0",
  "offspring": [],
  "name": "instAddMonoidWithOneFin.proof_1"},
 {"type":
  "∀ {α : Type u_1} (x : Option α), (HOrElse.hOrElse none fun x_1 => x) = x",
  "offspring": [],
  "name": "Option.none_orelse"},
 {"type":
  "∀ {α : Sort u} {down down_1 : α}, { down := down } = { down := down_1 } → down = down_1",
  "offspring": [],
  "name": "plift.up.inj"},
 {"type": "{α : Type u} → Sort u_1 → Subarray α → Subarray α → Sort u_1",
  "offspring": [],
  "name": "Subarray.noConfusionType"},
 {"type":
  "{R : Type u} → Sort u_1 → CommSemiring R → CommSemiring R → Sort u_1",
  "offspring": [],
  "name": "CommSemiring.noConfusionType"},
 {"type": "∀ {α : Type u} [inst : Preorder α] (a : α), ¬a > a",
  "offspring": ["lt_irrefl"],
  "name": "gt_irrefl"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "offspring": ["lt_of_lt_of_le"],
  "name": "instTransLtToLTLeToLE.proof_1"},
 {"type": "∀ (a : ℤ), Int.natAbs (-a) = Int.natAbs a",
  "offspring": ["Int.natAbs"],
  "name": "Int.natAbs_neg"},
 {"type": "∀ {α : Type u_1} {p : α → Prop} (x : { x // p x }), ∃ x, p x",
  "offspring": [],
  "name": "Subtype.existsOfSubtype.proof_1"},
 {"type": "{α : Type u} → {motive : List α → Prop} → List α → Prop",
  "offspring": [],
  "name": "List.ibelow"},
 {"type": "∀ {a b : Prop}, (¬a ↔ ¬b) ↔ (a ↔ b)",
  "offspring": ["Decidable.not_iff_not"],
  "name": "not_iff_not"},
 {"type": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), a * 0 = 0",
  "offspring": [],
  "name": "MonoidWithZero.mul_zero"},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeHTCT α β] → α → β",
  "offspring": [],
  "name": "CoeHTCT.coe"},
 {"type":
  "Type u_2 → ∀ {β : Type u_1}, WellFoundedRelation β → WellFounded (PSigma.RevLex emptyRelation WellFoundedRelation.rel)",
  "offspring": ["PSigma.revLex", "WellFoundedRelation.wf"],
  "name": "PSigma.skipLeft.proof_1"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2}, Nonempty (α ⊕ β) ↔ Nonempty α ∨ Nonempty β",
  "offspring": ["Nonempty", "Sum", "Sum.inl", "Sum.inr"],
  "name": "nonempty_sum"},
 {"type":
  "∀ {β : Type u_1} {α : Type u_2} {b : β} {l : List α} {f : α → List β} (a : b ∈ List.bind l f), ∃ a, a ∈ l ∧ b ∈ f a",
  "offspring": ["List.mem_bind"],
  "name": "List.exists_of_mem_bind"},
 {"type":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {s₁ : Setoid α} →\n      {s₂ : Setoid β} →\n        {motive : Quotient s₁ → Quotient s₂ → Sort uC} →\n          [s : ∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))] →\n            (q₁ : Quotient s₁) →\n              (q₂ : Quotient s₂) → ((a : α) → (b : β) → motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)) → motive q₁ q₂",
  "offspring": ["Quot.recOnSubsingleton"],
  "name": "Quotient.recOnSubsingleton₂"},
 {"type": "{α : Type u} → Sort u_1 → Complement α → Complement α → Sort u_1",
  "offspring": [],
  "name": "Complement.noConfusionType"},
 {"type":
  "∀ {v : Sat.Valuation} {c : Sat.Clause} {p : Prop}, (¬Sat.Valuation.satisfies v c → p) → Sat.Clause.reify v c p",
  "offspring": [],
  "name": "Sat.Clause.reify.mk"},
 {"type": "Tactic.NormCast.CoeFnInfo → Tactic.NormCast.CoeFnType",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnInfo.type"},
 {"type":
  "∀ (as : ByteArray) (i : ℕ), i + 1 ≤ ByteArray.size as → i ≤ ByteArray.size as",
  "offspring": ["Nat.le_of_lt", "Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "ByteArray.forIn.loop.proof_2"},
 {"type": "∀ {α : Sort u₁} {β : Sort u₂} (f : α → β), id ∘ f = f",
  "offspring": [],
  "name": "Function.comp.left_id"},
 {"type": "∀ {m n : ℕ}, n ∣ m → m / n * n = m",
  "offspring": ["Nat.mul_div_cancel'"],
  "name": "Nat.div_mul_cancel"},
 {"type": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "offspring": [],
  "name": "MonoidWithZero.toMonoid"},
 {"type": "{α : Type u} → [inst : LT α] → LE (List α)",
  "offspring": ["LE.mk", "List.le"],
  "name": "List.instLEList"},
 {"type": "{g : Type u} → [self : RandomGen g] → g → ℕ × g",
  "offspring": [],
  "name": "RandomGen.next"},
 {"type":
  "∀ {α : Type u_1} (x : α) (as bs : List α), x ∈ List.reverseAux as bs ↔ x ∈ as ∨ x ∈ bs",
  "offspring":
  ["List.reverseAux",
   "List.not_mem_nil",
   "false_or",
   "List.mem_cons",
   "or_assoc",
   "or_comm",
   "Iff.rfl"],
  "name": "List.mem_reverseAux"},
 {"type": "∀ (a b : Prop), a ∨ b ↔ b ∨ a",
  "offspring": ["Or.comm"],
  "name": "or_comm"},
 {"type": "∀ {a b : Prop}, a ∨ ¬b → b → a",
  "offspring": ["Or.elim"],
  "name": "Or.neg_resolve_right"},
 {"type": "∀ (n m : ℕ), n < m ∨ n ≥ m",
  "offspring":
  ["Nat.zero_le", "Nat.le_succ_of_le", "Nat.eq_or_lt_of_le", "Nat.le_refl"],
  "name": "Nat.lt_or_ge"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : ℕ), Array.size a ≤ i → Array.get? a i = none",
  "offspring":
  ["dite_congr",
   "instDecidableFalse",
   "not_lt_of_ge",
   "Eq.mpr_prop",
   "dite_false"],
  "name": "Array.get?_len_le"},
 {"type": "Nonempty (Fin UInt64.size)",
  "offspring": ["instNonempty", "UInt64.instInhabitedFinSize"],
  "name": "UInt64.instSemiringUInt64.proof_3"},
 {"type": "Mathlib.Tactic.Lint.Linter → Lean.MessageData",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.errorsFound"},
 {"type": "Type u → Type u → Type u", "offspring": [], "name": "Reader"},
 {"type":
  "{S₀ : Type u} →\n  [toSemigroup : Semigroup S₀] →\n    [toZero : Zero S₀] → (∀ (a : S₀), 0 * a = 0) → (∀ (a : S₀), a * 0 = 0) → SemigroupWithZero S₀",
  "offspring": [],
  "name": "SemigroupWithZero.mk"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} (e₁ : α ≃ β) (e₂ : β ≃ γ),\n  Function.RightInverse (e₁.invFun ∘ e₂.invFun) (e₂.toFun ∘ e₁.toFun)",
  "offspring": ["Function.RightInverse.comp"],
  "name": "Equiv.trans.proof_2"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (Prod.swap p).fst = p.snd",
  "offspring": [],
  "name": "Prod.fst_swap"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β} {g : β → α},\n  Function.surjective f → Function.RightInverse f g → Function.LeftInverse f g",
  "offspring": [],
  "name": "Function.LeftInverse_of_surjective_of_RightInverse"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Conv.convRun_conv_"},
 {"type": "∀ {m n : ℕ}, ↑m ≤ ↑n ↔ m ≤ n",
  "offspring":
  ["Nat.le.intro",
   "Int.ofNat.inj",
   "Int.ofNat_add",
   "Int.le.dest",
   "Int.instLEInt",
   "Int.le.intro",
   "Nat.le.dest"],
  "name": "Int.ofNat_le"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, (∃ x, p x) → Nonempty α",
  "offspring": [],
  "name": "Exists.nonempty"},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Inhabited β] → Array α → (α → Option β) → β",
  "offspring": ["Array.findSome?", "panicWithPosWithDecl"],
  "name": "Array.findSome!"},
 {"type":
  "Trans (fun a a_1 => a < a_1) (fun a a_1 => a ≤ a_1) fun a a_1 => a < a_1",
  "offspring": ["Trans.mk", "Nat.instTransNatLtInstLTNatLeInstLENat.proof_1"],
  "name": "Nat.instTransNatLtInstLTNatLeInstLENat"},
 {"type": "ByteArray → List UInt8",
  "offspring": [],
  "name": "ByteArray.toList"},
 {"type": "{α : Type u} → [inst : LT α] → LT (List α)",
  "offspring": ["LT.mk", "List.lt"],
  "name": "List.instLTList"},
 {"type":
  "∀ (eq : Bool) (lhs rhs : Nat.Linear.Expr) (eq_1 : Bool) (lhs_1 rhs_1 : Nat.Linear.Expr),\n  ({ eq := eq, lhs := lhs, rhs := rhs } = { eq := eq_1, lhs := lhs_1, rhs := rhs_1 }) =\n    (eq = eq_1 ∧ lhs = lhs_1 ∧ rhs = rhs_1)",
  "offspring":
  ["Nat.Linear.Expr", "Nat.Linear.ExprCnstr", "Nat.Linear.ExprCnstr.mk"],
  "name": "Nat.Linear.ExprCnstr.mk.injEq"},
 {"type":
  "{R : Type u} → [toSemiring : Semiring R] → (∀ (a b : R), a * b = b * a) → CommSemiring R",
  "offspring": [],
  "name": "CommSemiring.mk"},
 {"type": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Semigroup S₀",
  "offspring": [],
  "name": "SemigroupWithZero.toSemigroup"},
 {"type": "∀ (n : ℕ), -[1+ n] < 0",
  "offspring":
  ["lt_of_not_ge", "Int.instLinearOrderInt", "Int.eq_ofNat_of_zero_le"],
  "name": "Int.neg_succ_lt_zero"},
 {"type": "ℤ → ℤ → Prop", "offspring": ["Int.instLEInt"], "name": "Int.lt"},
 {"type": "ℕ → Array ℤ → Array ℤ → Mathlib.Tactic.Sat.LRATStep",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LRATStep.add"},
 {"type":
  "∀ {toLinter : Mathlib.Tactic.Lint.Linter} {declName : Lean.Name} {toLinter_1 : Mathlib.Tactic.Lint.Linter}\n  {declName_1 : Lean.Name},\n  { toLinter := toLinter, declName := declName } = { toLinter := toLinter_1, declName := declName_1 } →\n    toLinter = toLinter_1 ∧ declName = declName_1",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.NamedLinter.mk.inj"},
 {"type": "ToString Substring",
  "offspring": ["ToString.mk", "Substring.toString"],
  "name": "instToStringSubstring"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), b ≤ max a b",
  "offspring":
  ["if_pos",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "le_of_lt",
   "if_neg",
   "le_refl"],
  "name": "le_max_right"},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Monad m] → [inst : Inhabited α] → Inhabited (m α)",
  "offspring": ["Inhabited.default"],
  "name": "instInhabited"},
 {"type": "Sort u → Substring → Substring → Sort u",
  "offspring": [],
  "name": "Substring.noConfusionType"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {r : (x : α) → β x → Prop}, (∀ (x : α), ∃ y, r x y) → ∃ f, ∀ (x : α), r x (f x)",
  "offspring": ["Classical.choose", "Classical.choose_spec"],
  "name": "Classical.axiomOfChoice"},
 {"type":
  "∀ {α : Type u_1} {s₁ s₂ t₁ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → List.length t₁ = List.length t₂ → s₁ = s₂",
  "offspring": ["List.append_inj'"],
  "name": "List.append_inj_left'"},
 {"type":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (x : α), p x ∧ q x) ↔ (∀ (x : α), p x) ∧ ∀ (x : α), q x",
  "offspring": [],
  "name": "forall_and_distrib"},
 {"type": "Neg USize",
  "offspring": ["Neg.mk", "USize.mk"],
  "name": "USize.instNegUSize"},
 {"type": "{α : Type u} → {o : Option α} → Option.isSome o = true → α",
  "offspring": [],
  "name": "Option.get"},
 {"type":
  "∀ {α : Type u_1} (a : α) (n : ℕ), List.length (List.repeat' a n) = n",
  "offspring":
  ["List.length_nil", "Nat.zero_eq", "List.length_cons", "List.repeat'"],
  "name": "List.length_repeat'"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → Option α × BinaryHeap α lt",
  "offspring": ["BinaryHeap.max", "BinaryHeap.popMax"],
  "name": "BinaryHeap.extractMax"},
 {"type":
  "{α : Type u} → {β : Type v} → α → (k : USize → β) → (∀ (u₁ u₂ : USize), k u₁ = k u₂) → β",
  "offspring": ["ptrAddrUnsafe"],
  "name": "withPtrAddrUnsafe"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) (x : α) (xs : List α), (∃ x, x ∈ xs ∧ p x) → ∃ x_1, x_1 ∈ x :: xs ∧ p x_1",
  "offspring": ["List.Mem.tail"],
  "name": "decidableBEx.proof_3"},
 {"type":
  "∀ {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} (a : α) {b₁ b₂ : β},\n  rb b₁ b₂ → Prod.Lex ra rb (a, b₁) (a, b₂)",
  "offspring": [],
  "name": "Prod.Lex.right"},
 {"type": "∀ (a b : Prop) [inst : Decidable a], ((a → b) → a) → a",
  "offspring": ["Not.elim"],
  "name": "Decidable.peirce"},
 {"type": "Monad BaseIO", "offspring": [], "name": "instMonadBaseIO"},
 {"type":
  "∀ {α : Type u_1} {a : α} (l : List α) (h : l ++ [a] ≠ []), List.getLast (l ++ [a]) h = a",
  "offspring": ["List.getLast"],
  "name": "List.getLast_append"},
 {"type":
  "{ε σ α : Type u} → Sort u_1 → EStateM.Result ε σ α → EStateM.Result ε σ α → Sort u_1",
  "offspring": [],
  "name": "EStateM.Result.noConfusionType"},
 {"type":
  "{β : Type u_1} →\n  {γ : Type u_2} →\n    {δ : Type u_3} → {α : Type u_4} → [inst : Function.HasUncurry β γ δ] → Function.HasUncurry (α → β) (α × γ) δ",
  "offspring": ["Function.HasUncurry.mk", "Function.HasUncurry.uncurry"],
  "name": "Function.HasUncurry_induction"},
 {"type":
  "∀ {α : Type u_1} (a : α) {m n : ℕ} (l : List α), m ≠ n → List.get? (List.set l m a) n = List.get? l n",
  "offspring": ["List.set_eq_modifyNth", "List.get?_modifyNth_ne"],
  "name": "List.get?_set_ne"},
 {"type":
  "{α : Type u₁} → {β : Type u₂} → {φ : Type u₃} → (α × β → φ) → α → β → φ",
  "offspring": [],
  "name": "Function.curry"},
 {"type": "ToString ByteArray",
  "offspring":
  ["ToString.mk", "List.toString", "instToStringUInt8", "ByteArray.toList"],
  "name": "instToStringByteArray"},
 {"type":
  "∀ {p : ℕ → Prop} (a : ℕ), p 0 → (∀ (n : ℕ), (∀ (m : ℕ), m ≤ n → p m) → p (Nat.succ n)) → p a",
  "offspring": ["Nat.strong_induction_on", "Nat.lt_succ_of_le"],
  "name": "Nat.case_strong_induction_on"},
 {"type": "∀ (a : UInt8), 0 * a = 0",
  "offspring":
  ["UInt8.zero_def", "UInt8.mul_def", "UInt8.mk", "MonoidWithZero.zero_mul"],
  "name": "UInt8.instSemiringUInt8.proof_9"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {n : ℕ},\n  List.length l₁ ≤ n → n < List.length (l₁ ++ l₂) → n - List.length l₁ < List.length l₂",
  "offspring": ["Nat.sub_lt_left_of_lt_add", "List.length_append"],
  "name": "List.get_append_right_aux"},
 {"type": "∀ (x y z : ℕ), (x + y * z) % y = x % y",
  "offspring":
  ["Nat.mul_zero",
   "Nat.add_zero",
   "Nat.mul_succ",
   "Nat.add_assoc",
   "Nat.add_mod_right"],
  "name": "Nat.add_mul_mod_self_left"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} {a : α}, List.get? l n = some a ↔ ∃ h, List.get l { val := n, isLt := h } = a",
  "offspring": ["List.get?_eq_get"],
  "name": "List.get?_eq_some"},
 {"type": "Type u → Type u", "offspring": [], "name": "LinearOrder"},
 {"type": "{n : ℕ} → Coe (Fin n) ℕ",
  "offspring": ["Coe.mk"],
  "name": "Fin.coeToNat"},
 {"type":
  "{ε : Type u} → {α : Type u_1} → Except ε α → (Unit → Except ε α) → Except ε α",
  "offspring": ["Except.ok"],
  "name": "Except.orElseLazy"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β},\n  Function.injective f → ∀ (g : γ → α), Function.injective (f ∘ g) ↔ Function.injective g",
  "offspring": ["Function.injective.of_comp", "Function.injective.comp"],
  "name": "Function.injective.of_comp_iff"},
 {"type": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "offspring": ["Iff.rfl"],
  "name": "iff_of_eq"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {n : ℕ}, List.length l = Nat.succ n → l ≠ []",
  "offspring": [],
  "name": "List.ne_nil_of_length_eq_succ"},
 {"type": "∀ {a b : ℤ}, a ≤ b → ∃ n, b - a = ↑n",
  "offspring": ["Int.nonneg_def"],
  "name": "Int.le.dest_sub"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk", "Fin.lor", "UInt16.size"],
  "name": "UInt16.lor"},
 {"type":
  "∀ {α β σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf β] [inst_2 : SizeOf σ] (a : α) (a_1 : σ),\n  sizeOf (DoResultPR.pure a a_1) = 1 + sizeOf a + sizeOf a_1",
  "offspring": [],
  "name": "DoResultPR.pure.sizeOf_spec"},
 {"type": "∀ (x : USize), { val := AddMonoid.nsmul 0 x.val } = { val := 0.1 }",
  "offspring": ["AddMonoid.nsmul_zero'"],
  "name": "USize.instSemiringUSize.proof_4"},
 {"type": "Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["Nat.Linear.Poly.combineAux", "Nat.Linear.hugeFuel"],
  "name": "Nat.Linear.Poly.combine"},
 {"type":
  "{α : Sort u} →\n  {β : Sort v} → [inst : DecidableEq β] → (f : α → β) → {P : Sort w} → {x y : α} → x = y → noConfusionTypeEnum f P x y",
  "offspring": ["noConfusionEnum.proof_1"],
  "name": "noConfusionEnum"},
 {"type": "∀ {α : Sort u_1} {p : Prop}, Nonempty α → (α → p) → p",
  "offspring": [],
  "name": "Nonempty.elim.proof_1"},
 {"type": "ℤ → ℕ", "offspring": [], "name": "Int.toNat"},
 {"type": "∀ {α : Type u} (a : α), ¬a ∈ []",
  "offspring": ["sorryAx"],
  "name": "List.not_mem_nil"},
 {"type":
  "∀ (f : Type u → Type v) [inst : Functor f] [inst_1 : LawfulFunctor f] {α β : Type u} (h : α ≃ β) (x : f α),\n  Equiv.toFun (Functor.map_equiv f h) x = h.toFun <$> x",
  "offspring": [],
  "name": "Functor.map_equiv_apply"},
 {"type":
  "∀ (x y : Mathlib.Tactic.Lint.LintVerbosity),\n  Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx x = Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx y → x = y",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} [inst : Setoid α] {s t : Subtype p}, s ≈ t → t ≈ s",
  "offspring": ["Setoid.symm"],
  "name": "Subtype.symm"},
 {"type":
  "{α : Type u_1} → {β : α → Type v} → [inst : Repr α] → [s : (x : α) → Repr (β x)] → Repr (Sigma β)",
  "offspring": ["repr"],
  "name": "instReprSigma"},
 {"type": "∀ {α β : Type u_1} {f : α → β}, Functor.map f = Option.map f",
  "offspring": [],
  "name": "Option.map_eq_map"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), List.erase l a = List.erasep (Eq a) l",
  "offspring":
  ["List.erase_cons_head",
   "Subsingleton.elim",
   "List.erasep_cons_of_pos",
   "List.erase_cons_tail",
   "ne_eq",
   "Ne.symm",
   "List.erasep_cons_of_neg"],
  "name": "List.erase_eq_erasep"},
 {"type": "Substring → ℕ → Substring",
  "offspring": ["Substring.mk", "Substring.nextn"],
  "name": "Substring.take"},
 {"type": "{α : Type u} → (α → α → α) → Sdiff α",
  "offspring": [],
  "name": "Sdiff.mk"},
 {"type":
  "∀ (as : FloatArray) (i : ℕ), i + 1 ≤ FloatArray.size as → FloatArray.size as - 1 - i < FloatArray.size as",
  "offspring":
  ["Nat.lt_of_le_of_lt",
   "Nat.sub_le",
   "Nat.sub_lt",
   "Nat.zero_lt_of_lt",
   "Nat.lt_of_lt_of_le",
   "Nat.lt_succ_self"],
  "name": "FloatArray.forIn.loop.proof_1"},
 {"type": "{α : Type u✝} → [self : Zero α] → α",
  "offspring": [],
  "name": "Zero.zero"},
 {"type": "∀ (n : ℕ), Nat.coprime n 0 ↔ n = 1",
  "offspring": ["Nat.gcd_zero_right"],
  "name": "Nat.coprime_zero_right"},
 {"type": "∀ {a b : ℤ}, -(a + b) = -a + -b",
  "offspring": [],
  "name": "Int.neg_add"},
 {"type": "Sub ℤ",
  "offspring": ["Sub.mk", "Int.sub"],
  "name": "Int.instSubInt"},
 {"type": "∀ (x : ℕ), x % 1 = 0", "offspring": [], "name": "Nat.mod_one"},
 {"type":
  "(Type u₁ → Type u₂) →\n  (ρ : Type u) → (α : outParam (Type v)) → outParam (Membership α ρ) → Type (max (max (max u (u₁ + 1)) u₂) v)",
  "offspring": [],
  "name": "ForIn'"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] {a : α} {b : β a} {f g : (a : α) → β a},\n  g = Function.update f a b ↔ g a = b ∧ ∀ (x : α), x ≠ a → g x = f x",
  "offspring":
  ["Iff.trans", "Function.funext_iff", "Function.forall_update_iff"],
  "name": "Function.eq_update_iff"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)], Fin n → 0 = 0",
  "offspring": ["Fin"],
  "name": "instAddGroupWithOneFin.proof_3"},
 {"type":
  "∀ {α : Type u} {β : Type v} {b₁ b₂ : β} {s : β → β → Prop} (a₁ a₂ : α),\n  s b₁ b₂ → PSigma.SkipLeft α s { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }",
  "offspring": ["PSigma.mkSkipLeft.proof_1"],
  "name": "PSigma.mkSkipLeft"},
 {"type":
  "∀ (k : ℕ) {m n : ℕ}, Nat.coprime m n → Nat.gcd k (m * n) = Nat.gcd k m * Nat.gcd k n",
  "offspring":
  ["Nat.dvd_antisymm",
   "Nat.gcd_mul_dvd_mul_gcd",
   "Nat.coprime.mul_dvd_of_dvd_of_dvd",
   "Nat.coprime.gcd_both",
   "Nat.gcd_dvd_gcd_mul_right_right",
   "Nat.gcd_dvd_gcd_mul_left_right"],
  "name": "Nat.coprime.gcd_mul"},
 {"type": "∀ {a b : ℤ}, 0 ≤ a → 0 ≤ b → 0 ≤ a * b",
  "offspring": ["Nat.cast_mul", "Int.ofNat_nonneg", "Int.eq_ofNat_of_zero_le"],
  "name": "Int.mul_nonneg"},
 {"type": "LawfulBEq Nat.Linear.PolyCnstr",
  "offspring": ["Nat.Linear.instLawfulBEqPolyCnstrInstBEqPolyCnstr.proof_1"],
  "name": "Nat.Linear.instLawfulBEqPolyCnstrInstBEqPolyCnstr"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → Array α → Array β → (α → β → γ) → Array γ",
  "offspring": ["Array.zipWithAux"],
  "name": "Array.zipWith"},
 {"type": "{α : Type u} → (α → Bool) → List α → List α",
  "offspring": [],
  "name": "List.takeWhile"},
 {"type": "ToString Bool",
  "offspring": ["ToString.mk", "cond"],
  "name": "instToStringBool"},
 {"type": "∀ (x : ℕ), (fun a => a) -[1+ x] = (fun a => a) -[1+ x]",
  "offspring": [],
  "name": "Int.instCommRingInt.proof_10"},
 {"type":
  "∀ {α : Type u_1} (l : List α) (i : ℕ) (a : α) (h : i < List.length (List.set l i a)),\n  List.get (List.set l i a) { val := i, isLt := h } = a",
  "offspring":
  ["List.get",
   "List.set",
   "Option.some_inj",
   "List.get?_eq_get",
   "List.get?",
   "List.get?_set_eq",
   "Functor.map",
   "Option",
   "Option.instFunctorOption",
   "List.length_set",
   "Option.map_eq_map",
   "Option.map_some'"],
  "name": "List.get_set_eq"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Inhabited α] → [inst : Inhabited β] → Inhabited (α × β)",
  "offspring": ["Inhabited.default"],
  "name": "instInhabitedProd"},
 {"type": "{α : Type u} → (α → α → α) → Mod α",
  "offspring": [],
  "name": "Mod.mk"},
 {"type": "∀ {k m : ℕ}, Nat.coprime k m → k ∣ m → k = 1",
  "offspring": ["Nat.coprime.gcd_eq_one", "Nat.gcd", "Nat.gcd_eq_left"],
  "name": "Nat.coprime.eq_one_of_dvd"},
 {"type": "List Char → String", "offspring": [], "name": "List.asString"},
 {"type": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), k + n ≤ k + m",
  "offspring": ["Nat.le.dest"],
  "name": "Nat.add_le_add_left"},
 {"type": "{α β : Type u} → α → β → MProd α β",
  "offspring": [],
  "name": "MProd.mk"},
 {"type": "∀ (a b : ℕ), a = b → Int.ofNat a = Int.ofNat b",
  "offspring": [],
  "name": "Int.decEq.proof_1"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), a + 0 = a",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Fin.add_def",
   "Fin.zero_def",
   "Nat.add_zero",
   "Fin.size_positive",
   "Nat.mod_eq_of_lt",
   "Fin.isLt"],
  "name": "instAddCommMonoidFin.proof_1"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), 0 + a = a",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Fin.add_def",
   "Fin.zero_def",
   "Nat.zero_add",
   "Fin.size_positive",
   "Nat.mod_eq_of_lt",
   "Fin.isLt"],
  "name": "instAddCommMonoidFin.proof_2"},
 {"type": "(fun n => { val := ↑n }) 0 = (fun n => { val := ↑n }) 0",
  "offspring": [],
  "name": "UInt16.instSemiringUInt16.proof_11"},
 {"type":
  "{α : Sort u} → {β : Sort v} → (a : α) → [inst : CoeDep α a β] → CoeT α a β",
  "offspring": ["CoeT.mk", "CoeDep.coe"],
  "name": "coeOfDep"},
 {"type": "∀ {α : Sort u} {a : α}, a = a",
  "offspring": ["rfl.proof_1"],
  "name": "rfl"},
 {"type": "∀ {α : Type u_1} {l : List α}, List.length l = 1 ↔ ∃ a, l = [a]",
  "offspring":
  ["List.length_cons",
   "Nat.succ.injEq",
   "Nat.succ_ne_zero",
   "List.length_singleton"],
  "name": "List.length_eq_one"},
 {"type": "{a b : Prop} → Sort u → a ∧ b → a ∧ b → Sort u",
  "offspring": [],
  "name": "And.noConfusionType"},
 {"type": "∀ (p : Prop) [inst : Decidable p], decide p = true ↔ p",
  "offspring": ["decide_eq_true"],
  "name": "decide_eq_true_iff"},
 {"type": "∀ {n : ℕ}, WellFounded fun a b => b < a",
  "offspring": ["Subrelation.wf", "Fin.isLt", "WellFoundedRelation.wf"],
  "name": "Fin.gt_wf"},
 {"type": "∀ (a : ℤ), a ≤ a",
  "offspring": ["Int.le.intro", "Int.add_zero"],
  "name": "Int.le_refl"},
 {"type": "{α : Type u} → Task α → α", "offspring": [], "name": "Task.get"},
 {"type": "Lean.Elab.Command.CommandElab",
  "offspring": ["cond", "Mathlib.Prelude.Rename.addNameAlignment"],
  "name": "Mathlib.Prelude.Rename.elabAlign"},
 {"type": "∀ {α β : Sort u} {a : α} {b : β} (h₁ : α = β), h₁ ▸ a = b → HEq a b",
  "offspring": ["heq_of_eq"],
  "name": "heq_of_eqRec_eq"},
 {"type": "∀ {n m : ℕ}, ¬n ≤ m ↔ m < n",
  "offspring": ["Nat.lt_of_not_le", "Nat.not_le_of_lt"],
  "name": "Nat.not_le"},
 {"type": "ℤ → ℤ", "offspring": [], "name": "Int.sign"},
 {"type": "∀ {a b : Prop}, (a ∨ b ↔ b) ↔ a → b",
  "offspring": ["or_comm", "or_iff_left_iff_imp", "Iff.rfl"],
  "name": "or_iff_right_iff_imp"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : Fin n), (fun x a => Fin.ofNat' x (_ : 0 < n) * a) 0 x = 0",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Nat.zero_mod",
   "Fin.size_positive",
   "Fin.mul_def",
   "MonoidWithZero.zero_mul",
   "Fin.zero_def"],
  "name": "instAddCommMonoidFin.proof_3"},
 {"type":
  "∀ (up down squash up_1 down_1 squash_1 : Lean.Meta.SimpExtension),\n  ({ up := up, down := down, squash := squash } = { up := up_1, down := down_1, squash := squash_1 }) =\n    (up = up_1 ∧ down = down_1 ∧ squash = squash_1)",
  "offspring":
  ["Tactic.NormCast.NormCastExtension", "Tactic.NormCast.NormCastExtension.mk"],
  "name": "Tactic.NormCast.NormCastExtension.mk.injEq"},
 {"type": "ℕ → Char", "offspring": [], "name": "Nat.superDigitChar"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (as : ByteArray) → (UInt8 → β → m (ForInStep β)) → (i : ℕ) → i ≤ ByteArray.size as → β → m β",
  "offspring": [],
  "name": "ByteArray.forIn.loop"},
 {"type": "Repr UInt8",
  "offspring": ["repr", "instReprNat", "UInt8.toNat"],
  "name": "instReprUInt8"},
 {"type": "Nonempty (Fin UInt32.size)",
  "offspring": ["instNonempty", "UInt32.instInhabitedFinSize"],
  "name": "UInt32.instSemiringUInt32.proof_3"},
 {"type": "∀ {a b : ℤ}, a ≤ b → a - 1 < b",
  "offspring": ["Int.sub_right_lt_of_lt_add", "Int.lt_add_one_of_le"],
  "name": "Int.sub_one_lt_of_le"},
 {"type": "Float → Float → Prop",
  "offspring": ["FloatSpec.lt", "floatSpec"],
  "name": "Float.lt"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "PSum"},
 {"type": "{α : Type} → String → IO α → IO α",
  "offspring": [],
  "name": "timeit"},
 {"type": "∀ {α : Type u_1} (a : α), pure a = a",
  "offspring": [],
  "name": "Id.pure_eq"},
 {"type": "∀ {α : Type u_1} (as : Array α), Array.size as ≤ Array.size as",
  "offspring": ["Nat.le_refl"],
  "name": "Array.findSomeRevM?.proof_1"},
 {"type": "{α : Type u} → [inst : BEq α] → α → α → Bool",
  "offspring": ["not"],
  "name": "bne"},
 {"type":
  "{α : Type u} → (p : α → Prop) → [inst : DecidablePred p] → List α → ℕ",
  "offspring": [],
  "name": "List.findIdx"},
 {"type": "∀ {n m : ℕ}, m ≤ n → n - m + m = n",
  "offspring": ["Nat.add_sub_of_le"],
  "name": "Nat.sub_add_cancel"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx (Nat.Linear.ExprCnstr.toNormPoly c) = Nat.Linear.ExprCnstr.denote ctx c",
  "offspring":
  ["Nat.Linear.ExprCnstr",
   "cond_true",
   "Nat.Linear.Poly.denote_eq_cancel_eq",
   "Nat.Linear.Poly.denote_fuse",
   "Nat.Linear.Poly.denote_sort_go",
   "Nat.Linear.Expr.denote_toPoly",
   "Nat.zero_add",
   "Bool.of_not_eq_true",
   "cond_false",
   "Nat.Linear.Poly.denote_le_cancel_eq"],
  "name": "Nat.Linear.ExprCnstr.denote_toNormPoly"},
 {"type": "Type u → Type u → Type u", "offspring": [], "name": "StateM"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b < a",
  "offspring": ["Or.symm", "lt_or_le"],
  "name": "le_or_lt"},
 {"type": "∀ (n : ℕ), Int.NonNeg (Int.ofNat n)",
  "offspring": [],
  "name": "Int.NonNeg.mk"},
 {"type": "∀ (a b : UInt16), a * b = { val := a.val * b.val }",
  "offspring": [],
  "name": "UInt16.mul_def"},
 {"type": "∀ {a b : ℤ}, a < b → a - b < 0",
  "offspring": [],
  "name": "Int.sub_neg_of_lt"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk", "Fin.xor", "UInt32.size"],
  "name": "UInt32.xor"},
 {"type": "AddSemigroup UInt8",
  "offspring":
  ["AddSemigroup.mk", "instAddUInt8", "UInt8.instAddSemigroupUInt8.proof_1"],
  "name": "UInt8.instAddSemigroupUInt8"},
 {"type": "∀ {a b : ℤ}, 0 ≤ a → b ≤ 0 → a * b ≤ 0",
  "offspring": [],
  "name": "Int.mul_nonpos_of_nonneg_of_nonpos"},
 {"type": "{α : Type s} → Sort u → ULift α → ULift α → Sort u",
  "offspring": [],
  "name": "ULift.noConfusionType"},
 {"type": "Float → Float", "offspring": [], "name": "Float.neg"},
 {"type": "(p : Prop) → [inst : Decidable p] → CoeDep Prop p Bool",
  "offspring": ["CoeDep.mk", "Decidable.decide"],
  "name": "decPropToBool"},
 {"type": "∀ {a b c : Prop}, (a ∨ b) ∧ c ↔ a ∧ c ∨ b ∧ c",
  "offspring": ["Iff.trans", "And.comm", "and_or_distrib_left", "or_congr"],
  "name": "or_and_distrib_right"},
 {"type": "(n : ℕ) → WellFoundedRelation (Fin n)",
  "offspring": ["WellFoundedRelation.mk", "Fin.gt_wf"],
  "name": "Fin.upRel"},
 {"type":
  "{A : Type u} → [toAddGroup : AddGroup A] → (∀ (a b : A), a + b = b + a) → AddCommGroup A",
  "offspring": [],
  "name": "AddCommGroup.mk"},
 {"type":
  "∀ {m n k : ℕ}, Nat.coprime m k → Nat.coprime n k → Nat.coprime (m * n) k",
  "offspring": ["Nat.coprime.gcd_mul_left_cancel"],
  "name": "Nat.coprime.mul"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (α → β → m β) → β → (as : Array α) → optParam ℕ (Array.size as) → optParam ℕ 0 → m β",
  "offspring": [],
  "name": "Array.foldrMUnsafe"},
 {"type":
  "∀ {a b c : Prop} [inst : Decidable a], a → b ∨ c ↔ (a → b) ∨ (a → c)",
  "offspring": ["true_implies", "false_implies", "or_self"],
  "name": "Decidable.imp_or_distrib"},
 {"type":
  "{α : Sort u} → {β : Sort v} → [inst : DecidableEq β] → (α → β) → Sort w → α → α → Sort w",
  "offspring": [],
  "name": "noConfusionTypeEnum"},
 {"type": "{α : Sort u} → Sort u_1 → plift α → plift α → Sort u_1",
  "offspring": [],
  "name": "plift.noConfusionType"},
 {"type":
  "∀ {b c : Prop} {α : Sort u_1} {s : Decidable b} [inst : Decidable c] {x : b → α} {u : c → α} {y : ¬b → α} {v : ¬c → α},\n  b = c → (∀ (h : c), x (_ : b) = u h) → (∀ (h : ¬c), y (_ : ¬b) = v h) → dite b x y = dite c u v",
  "offspring": ["dif_pos", "dif_neg"],
  "name": "dite_congr"},
 {"type": "ℤ → ℤ → ℤ", "offspring": ["Int.negOfNat"], "name": "Int.mul"},
 {"type": "{m : Type u_1 → Type u_2} → {α : Type u_3} → ForIn m (List α) α",
  "offspring": ["ForIn.mk", "List.forIn"],
  "name": "List.instForInList"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, ¬a ∈ l → List.length (List.insert a l) = List.length l + 1",
  "offspring": ["List.insert_of_not_mem"],
  "name": "List.length_insert_of_not_mem"},
 {"type": "∀ {a b : ℤ}, -a = -b → a = b",
  "offspring": ["Int.neg_neg"],
  "name": "Int.neg_inj"},
 {"type": "{α : Type u_1} → [inst : Lean.ToFormat α] → Lean.ToFormat (Array α)",
  "offspring": ["Array.toList"],
  "name": "instToFormatArray"},
 {"type": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), n + k ≤ m + k",
  "offspring": ["Nat.add_le_add_left"],
  "name": "Nat.add_le_add_right"},
 {"type": "{α : Type s} → Sort u → ulift α → ulift α → Sort u",
  "offspring": [],
  "name": "ulift.noConfusionType"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["cond"],
  "name": "unexpandSubtype"},
 {"type": "Char",
  "offspring": ["System.Platform.isWindows"],
  "name": "System.SearchPath.separator"},
 {"type": "{α : Type u} → Append (Array α)",
  "offspring": ["Append.mk", "Array.append"],
  "name": "Array.instAppendArray"},
 {"type":
  "{A : Type u} → Sort u_1 → AddCommMonoid A → AddCommMonoid A → Sort u_1",
  "offspring": [],
  "name": "AddCommMonoid.noConfusionType"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b ∧ ¬b ≤ a",
  "offspring": ["lt_iff_le_not_le"],
  "name": "le_not_le_of_lt"},
 {"type": "Nat.pred 0 = 0", "offspring": [], "name": "Nat.pred_zero"},
 {"type": "{α : Type u} → [inst : Inhabited α] → String → α",
  "offspring": ["panicCore"],
  "name": "panic"},
 {"type": "∀ (n : ℕ) (x : ℤ), -[1+ n] * x = -(Int.ofNat (Nat.succ n) * x)",
  "offspring":
  ["Int.negSucc_ofNat_ofNat",
   "Int.ofNat_mul_ofNat",
   "Int.mul_negSucc_ofNat_negSucc_ofNat",
   "Int.ofNat_mul_negSucc_ofNat"],
  "name": "Int.instCommRingInt.proof_8"},
 {"type": "Type u → Type u", "offspring": [], "name": "MulZeroOneClass"},
 {"type": "{n : ℕ} → Div (Fin n)",
  "offspring": ["Div.mk", "Fin.div"],
  "name": "Fin.instDivFin"},
 {"type": "(ℕ → Bool) → ℕ × ℕ → Bool",
  "offspring": ["Nat.anyAux", "not"],
  "name": "Prod.allI"},
 {"type":
  "∀ {arr : ByteArray} {off len : ℕ} {arr_1 : ByteArray} {off_1 len_1 : ℕ},\n  { arr := arr, off := off, len := len } = { arr := arr_1, off := off_1, len := len_1 } →\n    arr = arr_1 ∧ off = off_1 ∧ len = len_1",
  "offspring": [],
  "name": "ByteSlice.mk.inj"},
 {"type": "∀ (x n p : ℕ), n * p ≤ x → (x - n * p) / n = x / n - p",
  "offspring":
  ["Nat.eq_zero_or_pos",
   "Nat.div_zero",
   "Nat.zero_sub",
   "Nat.mul_zero",
   "Nat.sub_zero"],
  "name": "Nat.sub_mul_div"},
 {"type": "sizeOf Ordering.eq = 1",
  "offspring": [],
  "name": "Ordering.eq.sizeOf_spec"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) (Int.ofNat x) = (fun n => { val := ↑n }) (Int.ofNat x)",
  "offspring": [],
  "name": "UInt16.instRingUInt16.proof_7"},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Prop} →\n        {s : β → γ → Prop} → {t : outParam (α → γ → Prop)} → Sort u → Trans r s t → Trans r s t → Sort u",
  "offspring": [],
  "name": "Trans.noConfusionType"},
 {"type": "{σ : Type u} → Sort u_1 → DoResultBC σ → DoResultBC σ → Sort u_1",
  "offspring": [],
  "name": "DoResultBC.noConfusionType"},
 {"type": "Nat.Linear.Context → Nat.Linear.Poly → ℕ",
  "offspring":
  ["Nat.Linear.Var", "Nat.add", "Nat.mul", "Nat.Linear.Var.denote"],
  "name": "Nat.Linear.Poly.denote"},
 {"type": "ℕ → List Char → List Char",
  "offspring": [],
  "name": "Nat.toSuperDigitsAux"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (p : Nat.Linear.Poly),\n  Nat.Linear.Expr.denote ctx (Nat.Linear.Poly.toExpr p) = Nat.Linear.Poly.denote ctx p",
  "offspring":
  ["Nat.Linear.Poly.denote_toExpr_go",
   "Nat.Linear.monomialToExpr",
   "Nat.Linear.denote_monomialToExpr"],
  "name": "Nat.Linear.Poly.denote_toExpr"},
 {"type": "∀ {k m n : ℕ}, k ∣ n → (k ∣ m ↔ k ∣ m + n)",
  "offspring": ["Nat.dvd_add_iff_right"],
  "name": "Nat.dvd_add_iff_left"},
 {"type": "∀ (m n : ℕ), Nat.gcd (Nat.gcd n m) m = Nat.gcd n m",
  "offspring": ["Nat.gcd", "Nat.gcd_comm", "Nat.gcd_gcd_self_right_right"],
  "name": "Nat.gcd_gcd_self_left_right"},
 {"type": "∀ (m n : ℕ), Nat.gcd n (m * n) = n",
  "offspring": ["Nat.gcd", "Nat.gcd_comm", "Nat.gcd_mul_left_left"],
  "name": "Nat.gcd_mul_left_right"},
 {"type":
  "∀ {α : Type u_1} {a b c : List α} {x : α}, x :: c = a ++ b ↔ a = [] ∧ b = x :: c ∨ ∃ a', a = x :: a' ∧ c = a' ++ b",
  "offspring": ["eq_comm", "List.append_eq_cons_iff", "Iff.rfl"],
  "name": "List.cons_eq_append_iff"},
 {"type": "Type u → Type u", "offspring": [], "name": "CommGroup"},
 {"type": "∀ {x y : ℕ}, (Nat.blt x y = true) = (x < y)",
  "offspring": ["Nat.le_of_ble_eq_true", "Nat.ble_eq_true_of_le"],
  "name": "Nat.blt_eq"},
 {"type": "(a : Prop) → Decidable a",
  "offspring": ["Classical.choice", "Classical.propDecidable.proof_1"],
  "name": "Classical.propDecidable"},
 {"type": "Bind Id", "offspring": ["inferInstance"], "name": "Id.hasBind"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«termExists_,_»"},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → FloatArray → β → (Float → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "FloatArray.forIn"},
 {"type": "∀ (a : Prop), ¬¬(a ∨ ¬a)",
  "offspring": [],
  "name": "non_contradictory_em"},
 {"type": "∀ {m n k : ℕ}, n - m = Nat.succ k → Int.subNatNat m n = -[1+ k]",
  "offspring": [],
  "name": "Int.subNatNat_of_sub_eq_succ"},
 {"type": "System.FilePath → Option System.FilePath",
  "offspring":
  ["Functor.map",
   "Option.instFunctorOption",
   "System.FilePath.mk",
   "System.FilePath.toString",
   "List.contains",
   "System.FilePath.pathSeparators"],
  "name": "System.FilePath.parent"},
 {"type":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.gpow (Int.ofNat (Nat.succ n)) a = a * DivInvMonoid.gpow (Int.ofNat n) a",
  "offspring": [],
  "name": "DivInvMonoid.gpow_succ'"},
 {"type": "(m : Type u → Type v) → [inst : Monad m] → Prop",
  "offspring": [],
  "name": "LawfulMonad"},
 {"type": "Float → Float → Prop",
  "offspring": ["FloatSpec.le", "floatSpec", "Float.val"],
  "name": "Float.le"},
 {"type":
  "∀ {α : Sort u_1} (x y : α) [inst : Decidable (x = y)], x = y ∨ x ≠ y",
  "offspring": ["dec_em"],
  "name": "Decidable.eq_or_ne"},
 {"type":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b)",
  "offspring":
  ["iff_iff_implies_and_implies",
   "Decidable.imp_iff_not_or",
   "or_comm",
   "Iff.rfl"],
  "name": "Decidable.iff_iff_not_or_and_or_not"},
 {"type": "Substring → Bool",
  "offspring": ["instBEqNat", "Substring.bsize"],
  "name": "Substring.isEmpty"},
 {"type": "∀ (n m k : ℕ), Nat.succ n - m - Nat.succ k = n - m - k",
  "offspring": ["Nat.sub_sub", "Nat.add_succ", "Nat.succ_sub_succ"],
  "name": "Nat.succ_sub_sub_succ"},
 {"type": "Neg UInt32",
  "offspring": ["Neg.mk", "UInt32.mk"],
  "name": "UInt32.instNegUInt32"},
 {"type": "{α : Type u_1} → ToBool (Option α)",
  "offspring": ["ToBool.mk", "Option.toBool"],
  "name": "instToBoolOption"},
 {"type": "Lean.Name → Lean.MessageData → Lean.CoreM Lean.MessageData",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.printWarning"},
 {"type":
  "∀ {α : Type u_1} (l : List α) (a : Array α), (List.toArrayAux l a).data = a.data ++ l",
  "offspring":
  ["Array.data",
   "List.toArrayAux",
   "List.append_nil",
   "Array.push",
   "Array.mk",
   "List.concat_eq_append",
   "List.append_assoc",
   "List.singleton_append"],
  "name": "List.toArrayAux_data"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk"],
  "name": "USize.mul"},
 {"type":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] {a b : α}, (a == b) = true → a = b",
  "offspring": ["LawfulBEq.eq_of_beq"],
  "name": "eq_of_beq"},
 {"type":
  "∀ (x x_1 x_2 : UInt16), { val := (x + x_1 + x_2).1 } = { val := (x + (x_1 + x_2)).1 }",
  "offspring": ["UInt16.mk", "AddSemigroup.add_assoc"],
  "name": "UInt16.instAddSemigroupUInt16.proof_1"},
 {"type":
  "∀ (x : ℕ) (a : USize),\n  { val := Ring.gsmul (Int.ofNat (Nat.succ x)) a.val } =\n    { val := (a + (fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat x) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_succ'"],
  "name": "USize.instRingUSize.proof_4"},
 {"type": "ℕ → UInt64", "offspring": ["UInt64.ofNat"], "name": "Nat.toUInt64"},
 {"type":
  "∀ {α : Type u_1} [inst : Inhabited α] {L : List α} (h : 0 < List.length L),\n  some (List.get L { val := 0, isLt := h }) = List.head? L",
  "offspring": ["List.get_cons_zero"],
  "name": "List.get_zero"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<&&>_»"},
 {"type": "∀ {α : Type u_1} (l : List α), List.get? l 0 = List.head? l",
  "offspring": [],
  "name": "List.get?_zero"},
 {"type":
  "∀ (f : Type u → Type v) [inst : Functor f] [inst_1 : LawfulFunctor f] {α β γ : Type u} (m : α → β) (g : β → γ)\n  (x : f α), g <$> m <$> x = (g ∘ m) <$> x",
  "offspring": ["LawfulFunctor.comp_map"],
  "name": "Functor.map_map"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} (f : α → β) (g : β → γ), Option.map g ∘ Option.map f = Option.map (g ∘ f)",
  "offspring": ["Function.comp_apply", "Option.map_map", "Option.map"],
  "name": "Option.map_comp_map"},
 {"type": "Mul UInt16",
  "offspring": ["Mul.mk", "UInt16.mul"],
  "name": "instMulUInt16"},
 {"type": "{α : Type u} → α → Squash α",
  "offspring": ["Quot.mk"],
  "name": "Squash.mk"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.Attr.coe"},
 {"type":
  "∀ {v v_1 : ℕ}, Nat.Linear.Expr.num v = Nat.Linear.Expr.num v_1 → v = v_1",
  "offspring": [],
  "name": "Nat.Linear.Expr.num.inj"},
 {"type": "Type u → Type u", "offspring": [], "name": "Thunk"},
 {"type": "∀ {a b c : ℤ}, a ≤ b → 0 ≤ c → c * a ≤ c * b",
  "offspring":
  ["le_antisymm",
   "le_refl",
   "MonoidWithZero.zero_mul",
   "le_not_le_of_lt",
   "Int.mul_lt_mul_of_pos_left",
   "lt_of_le_not_le"],
  "name": "Int.mul_le_mul_of_nonneg_left"},
 {"type": "Xor ℕ",
  "offspring": ["Xor.mk", "Nat.xor"],
  "name": "Nat.instXorNat"},
 {"type": "Inhabited (Fin UInt64.size)",
  "offspring": ["Fin.ofNat'", "UInt64.size_positive"],
  "name": "UInt64.instInhabitedFinSize"},
 {"type": "∀ (k : ℕ) {m n : ℕ}, Nat.coprime m n → Nat.coprime m (Nat.gcd k n)",
  "offspring": ["Nat.coprime.coprime_dvd_right", "Nat.gcd_dvd_right"],
  "name": "Nat.coprime.gcd_right"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → (b ↔ a)",
  "offspring": [],
  "name": "Iff.symm"},
 {"type":
  "{M₀ : Type u} →\n  [toMul : Mul M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroClass M₀",
  "offspring": [],
  "name": "MulZeroClass.mk"},
 {"type": "Type", "offspring": [], "name": "Tactic.NormCast.NormCastExtension"},
 {"type":
  "{α : Sort u} → {β : Sort v} → (β → β → Prop) → (α → β) → α → α → Prop",
  "offspring": [],
  "name": "InvImage"},
 {"type": "∀ {a b c : ℤ}, c ≤ a + b → -b ≤ a - c",
  "offspring": ["Int.le_sub_left_of_add_le", "Int.sub_right_le_of_le_add"],
  "name": "Int.neg_le_sub_right_of_le_add"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk"],
  "name": "UInt64.mul"},
 {"type": "System.FilePath → String",
  "offspring": [],
  "name": "System.FilePath.toString"},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → Array α → Array β",
  "offspring": ["Id.run", "Array.mapM", "Id.instMonadId"],
  "name": "Array.map"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (val val_1 : α), (PSum.inl val = PSum.inl val_1) = (val = val_1)",
  "offspring": ["PSum.inl"],
  "name": "PSum.inl.injEq"},
 {"type": "∀ {α : Type u_1} [inst : DecidableEq α] (a : α), (a == a) = true",
  "offspring": ["Decidable.decide", "Subsingleton.elim", "decide_eq_true_eq"],
  "name": "beq_self_eq_true'"},
 {"type": "Type u → Type u", "offspring": [], "name": "Option"},
 {"type":
  "∀ {α β : Sort u_1} {p : α → Prop} {q : β → Prop} {a : { x // p x }} {b : { y // q y }},\n  α = β → HEq p q → (HEq a b ↔ HEq a.val b.val)",
  "offspring": [],
  "name": "Subtype.heq_iff_coe_heq"},
 {"type":
  "∀ {α : Type u_1} (a : Array α), WellFounded (invImage (fun a_1 => Array.size a - a_1) instWellFoundedRelation).1",
  "offspring": [],
  "name": "Array.isEqvAux.proof_1"},
 {"type": "{α : Type u} → Array α → ℕ → ℕ → Array α → Array α",
  "offspring": ["Array.push", "Array.get"],
  "name": "Array.appendCore.loop"},
 {"type": "{α : Sort u} → (α → ℕ) → WellFoundedRelation α",
  "offspring": ["invImage", "Nat.lt_wfRel"],
  "name": "measure"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {as : List α}, ¬a ∈ as → List.card (List.insert a as) = List.card as + 1",
  "offspring":
  ["Subsingleton.elim", "List.insert_of_not_mem", "List.card_cons_of_not_mem"],
  "name": "List.card_insert_of_not_mem"},
 {"type": "∀ {a b c : ℤ}, a ≤ b + c → -b + a ≤ c",
  "offspring": [],
  "name": "Int.neg_add_le_of_le_add"},
 {"type": "∀ {n m : ℕ}, m ≤ n → m + (n - m) = n",
  "offspring": ["Nat.sub_add_cancel"],
  "name": "Nat.add_sub_cancel'"},
 {"type":
  "∀ {α : Sort u_1} {p : Nonempty α → Prop}, (∃ h, p h) ↔ ∃ a, p (_ : Nonempty α)",
  "offspring": [],
  "name": "Nonempty.exists"},
 {"type":
  "∀ (m n k : ℕ), Int.ofNat m * Int.subNatNat n k = Int.subNatNat (m * n) (m * k)",
  "offspring":
  ["Nat.zero_eq",
   "Int.ofNat_zero",
   "Int.zero_mul",
   "Nat.zero_mul",
   "Int.sub_nat_self"],
  "name": "Int.ofNat_mul_subNatNat"},
 {"type": "∀ {α : Type u_1} {p : α → Prop} (a : α), a ∈ none → p a",
  "offspring": ["Option.mem_def", "eq_false'", "false_implies", "implies_true"],
  "name": "Option.decidable_forall_mem.proof_1"},
 {"type": "∀ {n m k : ℕ}, n + m = k + m → n = k",
  "offspring": ["Nat.add_left_cancel"],
  "name": "Nat.add_right_cancel"},
 {"type": "∀ (a : UInt64), -a = { val := -a.val }",
  "offspring": [],
  "name": "UInt64.neg_def"},
 {"type": "{α : Type u} → {β : Type v} → Array α → (α → Option β) → Option β",
  "offspring": ["Id.run", "Array.findSomeRevM?", "Id.instMonadId"],
  "name": "Array.findSomeRev?"},
 {"type": "{α : Type u_1} → List α → ℕ → α → List α",
  "offspring": [],
  "name": "List.set"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop},\n  (∀ (x : α), r x x) → (∀ {x y : α}, r x y → r y x) → (∀ {x y z : α}, r x y → r y z → r x z) → Equivalence r",
  "offspring": [],
  "name": "Equivalence.mk"},
 {"type": "{α : Type u_1} → α → List α → α",
  "offspring": [],
  "name": "List.ilast'"},
 {"type": "Mul UInt32",
  "offspring": ["Mul.mk", "UInt32.mul"],
  "name": "instMulUInt32"},
 {"type": "∀ {α : Type u_1} {a : α}, Option.isSome (some a) = true",
  "offspring": [],
  "name": "Option.isSome_some"},
 {"type":
  "∀ (x : Tactic.NormCast.CoeFnType), Tactic.NormCast.CoeFnType.ofNat (Tactic.NormCast.CoeFnType.toCtorIdx x) = x",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.ofNat_toCtorIdx"},
 {"type": "{α : Sort u} → α → Inhabited α",
  "offspring": [],
  "name": "Inhabited.mk"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«stx_,+»"},
 {"type": "ReprAtom Float",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomFloat"},
 {"type":
  "{α : Sort u} →\n  {β : Sort v} →\n    (toFun : α → β) → (invFun : β → α) → Function.LeftInverse invFun toFun → Function.RightInverse invFun toFun → α ≃ β",
  "offspring": [],
  "name": "Equiv.mk"},
 {"type":
  "∀ (x : Tactic.NormCast.Label), Tactic.NormCast.Label.ofNat (Tactic.NormCast.Label.toCtorIdx x) = x",
  "offspring": [],
  "name": "Tactic.NormCast.Label.ofNat_toCtorIdx"},
 {"type":
  "{ε : Type u} →\n  {m : Type u → Type v} → [inst : Monad m] → {α : Type u} → ExceptT ε m α → (ε → ExceptT ε m α) → ExceptT ε m α",
  "offspring": ["ExceptT.mk", "Except.ok"],
  "name": "ExceptT.tryCatch"},
 {"type": "∀ {a b c : ℤ}, c ≤ a + b → -a ≤ b - c",
  "offspring": [],
  "name": "Int.neg_le_sub_left_of_le_add"},
 {"type":
  "∀ (x : ℕ), { val := ↑(x + 1) } = { val := ((fun n => { val := ↑n }) x + 1).1 }",
  "offspring": ["Fin.ofNat'_succ", "UInt64.size"],
  "name": "UInt64.instSemiringUInt64.proof_12"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [inst : MonadState σ m] → [inst : Monad m] → (σ → σ) → m σ",
  "offspring": ["MonadState.modifyGet"],
  "name": "getModify"},
 {"type": "{n : ℕ} → (val : ℕ) → val < n → Fin n",
  "offspring": [],
  "name": "Fin.mk"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, (∀ (x : α), ¬p x) → ¬∃ x, p x",
  "offspring": ["exists_imp_distrib"],
  "name": "not_exists_of_forall_not"},
 {"type":
  "∀ {α : Type u_1} (arr : Array (UFNode α)) (model : ∃ n m, UFModel.Models arr m) (arr_1 : Array (UFNode α))\n  (model_1 : ∃ n m, UFModel.Models arr_1 m),\n  ({ arr := arr, model := model } = { arr := arr_1, model := model_1 }) = (arr = arr_1)",
  "offspring": ["UnionFind.mk"],
  "name": "UnionFind.mk.injEq"},
 {"type":
  "∀ {α β σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf β] [inst_2 : SizeOf σ] (a : β) (a_1 : σ),\n  sizeOf (DoResultPR.return a a_1) = 1 + sizeOf a + sizeOf a_1",
  "offspring": [],
  "name": "DoResultPR.return.sizeOf_spec"},
 {"type": "Prop → Prop", "offspring": [], "name": "non_contradictory"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [self : LawfulApplicative f] {α β : Type u} (g : f (α → β)) (x : α),\n  (Seq.seq g fun x_1 => pure x) = (fun h => h x) <$> g",
  "offspring": [],
  "name": "LawfulApplicative.seq_pure"},
 {"type": "{α : Sort u} → (α → α → Prop) → Sort u",
  "offspring": [],
  "name": "Quot"},
 {"type": "{α : Type u_1} → List α → Prop",
  "offspring": ["List.Pairwise", "Ne"],
  "name": "List.Nodup"},
 {"type":
  "∀ {α : Type s} [inst : SizeOf α] (down : α), sizeOf { down := down } = 1 + sizeOf down",
  "offspring": [],
  "name": "ulift.up.sizeOf_spec"},
 {"type": "∀ {a b : ℕ}, 0 < a → a ≤ b → b - a < b",
  "offspring": ["Nat.sub_lt", "Nat.lt_of_lt_of_le"],
  "name": "Nat.sub_lt_self"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], (¬a → b) → ¬b → a",
  "offspring": ["Decidable.not_imp_symm"],
  "name": "Not.decidable_imp_symm"},
 {"type": "∀ {m k n : ℕ}, m ∣ k → Nat.coprime k n → Nat.coprime m n",
  "offspring": ["Nat.eq_one_of_dvd_one"],
  "name": "Nat.coprime.coprime_dvd_left"},
 {"type": "ToString Float",
  "offspring": ["ToString.mk", "Float.toString"],
  "name": "instToStringFloat"},
 {"type": "Type u → Type u", "offspring": [], "name": "SemigroupWithZero"},
 {"type": "∀ {a b c d : Prop}, (a ↔ c) → (b ↔ d) → (a → b ↔ c → d)",
  "offspring": ["imp_congr_ctx"],
  "name": "imp_congr"},
 {"type": "∀ {a b : ℤ}, a = b → a - b = 0",
  "offspring": ["Int.sub_self"],
  "name": "Int.sub_eq_zero_of_eq"},
 {"type": "{R : Type u_1} → [inst : AddMonoidWithOne R] → CoeTail ℕ R",
  "offspring": ["CoeTail.mk"],
  "name": "instCoeTailNat"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (self : α ≃ β), Function.RightInverse self.invFun self.toFun",
  "offspring": [],
  "name": "Equiv.right_inv"},
 {"type": "∀ {k m n : ℕ}, Nat.coprime m (k * n) → Nat.coprime m n",
  "offspring": ["Nat.coprime.coprime_dvd_right", "Nat.dvd_mul_left"],
  "name": "Nat.coprime.coprime_mul_left_right"},
 {"type": "CommRing UInt64",
  "offspring":
  ["CommRing.mk", "UInt64.instRingUInt64", "UInt64.instCommRingUInt64.proof_1"],
  "name": "UInt64.instCommRingUInt64"},
 {"type":
  "{α : Sort u} → Sort u_1 → WellFoundedRelation α → WellFoundedRelation α → Sort u_1",
  "offspring": [],
  "name": "WellFoundedRelation.noConfusionType"},
 {"type": "∀ {a b : ℤ}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "offspring":
  ["Int.instLTInt",
   "Int.lt_iff_le_and_ne",
   "Not.imp",
   "Int.le_antisymm",
   "Ne",
   "Int.le_refl"],
  "name": "Int.lt_iff_le_not_le"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (m : ℕ), a % m % n < n",
  "offspring": [],
  "name": "Fin.modn.proof_1"},
 {"type":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], (¬a ↔ ¬b) ↔ (a ↔ b)",
  "offspring": ["iff_def", "iff_def'", "and_congr", "Decidable.not_imp_not"],
  "name": "Decidable.not_iff_not"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "Pure"},
 {"type": "(c : Prop) → [inst : Decidable c] → Prop",
  "offspring": [],
  "name": "as_false"},
 {"type": "Type", "offspring": ["List", "Sat.Clause"], "name": "Sat.Fmla"},
 {"type": "List String → System.FilePath",
  "offspring": ["System.FilePath.mk", "System.FilePath.pathSeparator"],
  "name": "System.mkFilePath"},
 {"type": "{α : Type u_1} → Inhabited (Option α)",
  "offspring": [],
  "name": "instInhabitedOption"},
 {"type": "Type u → Type u", "offspring": [], "name": "Dvd"},
 {"type": "{g : Type u} → Sort u_1 → RandomGen g → RandomGen g → Sort u_1",
  "offspring": [],
  "name": "RandomGen.noConfusionType"},
 {"type": "∀ {α : Sort u} {p : α → Prop}, (∃ x, p x) → Nonempty α",
  "offspring": [],
  "name": "nonempty_of_exists"},
 {"type":
  "∀ {α : Type u} (val val_1 : α), (some val = some val_1) = (val = val_1)",
  "offspring": [],
  "name": "Option.some.injEq"},
 {"type": "UInt32 → ℕ", "offspring": ["UInt32.size"], "name": "UInt32.toNat"},
 {"type": "∀ {a b c : ℤ}, a - c < b → a < b + c",
  "offspring": [],
  "name": "Int.lt_add_of_sub_right_lt"},
 {"type": "∀ {n : ℕ}, 0 < n → n / n = 1",
  "offspring": ["Nat.zero_div", "Nat.zero_add", "Nat.add_div_right"],
  "name": "Nat.div_self"},
 {"type": "∀ {a b c : ℕ}, a ≤ b → c * a ≤ c * b",
  "offspring":
  ["Nat.le_antisymm",
   "le_refl",
   "Nat.zero_le",
   "Nat.zero_mul",
   "Nat.le_of_lt",
   "Nat.mul_lt_mul_of_pos_left",
   "not_le",
   "Nat.instLinearOrderNat"],
  "name": "Nat.mul_le_mul_of_nonneg_left"},
 {"type":
  "{R : Type u} → Sort u_1 → AddMonoidWithOne R → AddMonoidWithOne R → Sort u_1",
  "offspring": [],
  "name": "AddMonoidWithOne.noConfusionType"},
 {"type": "(ε σ : Type) → MonadExceptOf ε (EST ε σ)",
  "offspring": [],
  "name": "instMonadExceptOfEST"},
 {"type":
  "Array Lean.Name →\n  Array Mathlib.Tactic.Lint.NamedLinter →\n    Lean.CoreM (Array (Mathlib.Tactic.Lint.NamedLinter × Std.HashMap Lean.Name Lean.MessageData))",
  "offspring":
  ["Array.mapM",
   "Array.filterM",
   "Mathlib.Tactic.Lint.shouldBeLinted",
   "Mathlib.Tactic.Lint.NamedLinter.name",
   "Functor.map",
   "Mathlib.Tactic.Lint.Linter.test",
   "Mathlib.Tactic.Lint.NamedLinter.toLinter",
   "Option",
   "Task.Priority.default",
   "ForIn.forIn",
   "ForInStep",
   "Task.get",
   "EmptyCollection.emptyCollection"],
  "name": "Mathlib.Tactic.Lint.lintCore"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {as : List α}, ¬a ∈ as → List.card (a :: as) = List.card as + 1",
  "offspring": ["if_neg"],
  "name": "List.card_cons_of_not_mem"},
 {"type": "∀ {p : Prop} [s : Decidable p], p → decide p = true",
  "offspring": ["Decidable.decide"],
  "name": "decide_eq_true"},
 {"type": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "offspring": [],
  "name": "MulZeroClass.mul_zero"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (a b : Nat.Linear.Expr),\n  Nat.Linear.Expr.toNormPoly a = Nat.Linear.Expr.toNormPoly b →\n    Nat.Linear.Expr.denote ctx a = Nat.Linear.Expr.denote ctx b",
  "offspring": [],
  "name": "Nat.Linear.Expr.eq_of_toNormPoly"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "Functor"},
 {"type":
  "{A : Type u} →\n  [toAddMonoid : AddMonoid A] →\n    [toNeg : Neg A] →\n      [toSub : Sub A] →\n        (∀ (a b : A), a - b = a + -b) →\n          (gsmul : ℤ → A → A) →\n            (∀ (a : A), gsmul 0 a = 0) →\n              (∀ (n : ℕ) (a : A), gsmul (Int.ofNat (Nat.succ n)) a = a + gsmul (Int.ofNat n) a) →\n                (∀ (n : ℕ) (a : A), gsmul -[1+ n] a = -gsmul (Int.ofNat (Nat.succ n)) a) → SubNegMonoid A",
  "offspring": [],
  "name": "SubNegMonoid.mk"},
 {"type": "Sort u → Tactic.Ring.HornerExpr → Tactic.Ring.HornerExpr → Sort u",
  "offspring": [],
  "name": "Tactic.Ring.HornerExpr.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} (i : ℕ) (l : List α), List.length (List.take i l) = min i (List.length l)",
  "offspring":
  ["List.take",
   "min",
   "List.length_nil",
   "Nat.zero_min",
   "Nat.min_zero",
   "List.length_cons",
   "Nat.min_succ_succ"],
  "name": "List.length_take"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → Option α → (α → Option β) → Option β",
  "offspring": [],
  "name": "Option.bind"},
 {"type": "∀ {m n : ℕ}, 0 < n → m ∣ n → m ≤ n",
  "offspring":
  ["Nat.mul_zero",
   "eq_false_of_decide",
   "Nat.mul_one",
   "Nat.mul_le_mul_left",
   "Nat.succ_pos"],
  "name": "Nat.le_of_dvd"},
 {"type": "Unit → Bool", "offspring": [], "name": "System.Platform.getIsOSX"},
 {"type":
  "{α : Type u} →\n  {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Subarray α → β → (α → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "Subarray.forIn"},
 {"type": "{α : Type u} → ℕ → ℕ → Array α → ℕ → Array α",
  "offspring":
  ["WellFounded.fix",
   "Array.swap!",
   "WellFoundedRelation.rel",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Nat.sub_succ_lt_self"],
  "name": "Array.reverse.rev"},
 {"type": "{α : Type u} → (a : Array α) → Fin (Array.size a) → α → α × Array α",
  "offspring": ["Array.set", "Array.get"],
  "name": "Array.swapAt"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a ~ a_1 → Prop} (x : α) {l₁ l₂ : List α} {a : l₁ ~ l₂},\n  List.Perm.below a → motive l₁ l₂ a → List.Perm.below (_ : x :: l₁ ~ x :: l₂)",
  "offspring": [],
  "name": "List.Perm.below.cons"},
 {"type":
  "∀ (x y : Tactic.NormCast.CoeFnType),\n  ¬Tactic.NormCast.CoeFnType.toCtorIdx x = Tactic.NormCast.CoeFnType.toCtorIdx y → x = y → False",
  "offspring":
  ["Tactic.NormCast.CoeFnType", "Tactic.NormCast.CoeFnType.toCtorIdx"],
  "name": "Tactic.NormCast.instDecidableEqCoeFnType.proof_2"},
 {"type":
  "∀ {α : Type u} {β : Type v} {val val_1 : α}, Sum.inl val = Sum.inl val_1 → val = val_1",
  "offspring": [],
  "name": "Sum.inl.inj"},
 {"type":
  "∀ (stop x : ℕ), x < stop → (invImage (fun a => stop - a) instWellFoundedRelation).1 (x + 1) x",
  "offspring": ["sizeOf_nat", "Nat.lt_eq", "Nat.sub_succ_lt_self"],
  "name": "Array.anyM.loop.proof_3"},
 {"type": "∀ (m n k : ℕ), (m % n + k) % n = (m + k) % n",
  "offspring": [],
  "name": "Nat.mod_add_mod"},
 {"type":
  "{α : Type u} → [inst : LE α] → [inst : DecidableRel LE.le] → List α → Option α",
  "offspring": ["List.foldl", "min"],
  "name": "List.minimum?"},
 {"type":
  "∀ {α : Sort u} {b c : Prop} [dec_b : Decidable b] [dec_c : Decidable c] {x y u v : α},\n  (b ↔ c) → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v",
  "offspring": ["not_iff_not_of_iff"],
  "name": "if_ctx_congr"},
 {"type": "ReprAtom USize",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomUSize"},
 {"type":
  "∀ {G : Type u} [inst : Semigroup G] [inst_1 : IsMulRightCancel G] {a b c : G}, b * a = c * a ↔ b = c",
  "offspring": ["mul_right_cancel"],
  "name": "mul_right_cancel_iff"},
 {"type":
  "∀ {α : Type u} {a : α} {as : List α}, List.get (a :: as) { val := 0, isLt := (_ : 0 < List.length (a :: as)) } = a",
  "offspring": [],
  "name": "List.get_cons_zero"},
 {"type": "Semiring UInt16",
  "offspring":
  ["Semiring.mk",
   "UInt16.instSemiringUInt16.proof_13",
   "UInt16.instSemiringUInt16.proof_14",
   "UInt16.instSemiringUInt16.proof_15",
   "UInt16.instSemiringUInt16.proof_16",
   "Semigroup",
   "UInt16.instSemigroupUInt16",
   "AddCommSemigroup",
   "UInt16.instAddCommSemigroupUInt16"],
  "name": "UInt16.instSemiringUInt16"},
 {"type":
  "∀ (x x_1 : UInt32), { val := (x - x_1).1 } = { val := (x + -x_1).1 }",
  "offspring": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "UInt32.instRingUInt32.proof_1"},
 {"type": "(ℕ → Bool) → ℕ → Bool",
  "offspring": ["Nat.anyAux"],
  "name": "Nat.any"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : Option (Option α)} {f : α → β},\n  Option.bind x (Option.map f) = Option.bind (Option.map (Option.map f) x) id",
  "offspring":
  ["Option.none_bind",
   "Option.map_none'",
   "Option.some_bind",
   "Option.map_some'",
   "id_eq"],
  "name": "Option.bind_map_comm"},
 {"type": "∀ {α : Type u} (b : ulift α), { down := b.down } = b",
  "offspring": ["ulift.up", "ulift.down"],
  "name": "ulift.up_down"},
 {"type": "∀ {a b : ℤ}, 0 ≤ a → a ≤ b → a * a ≤ b * b",
  "offspring": ["Int.mul_le_mul", "le_trans"],
  "name": "Int.mul_self_le_mul_self"},
 {"type": "∀ {a b c : ℤ}, -b + a ≤ c → a ≤ b + c",
  "offspring": [],
  "name": "Int.le_add_of_neg_add_le"},
 {"type":
  "{ε : Type u_1} → {m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Inhabited ε] → Inhabited (ExceptCpsT ε m α)",
  "offspring": ["Inhabited.default"],
  "name": "ExceptCpsT.instInhabitedExceptCpsT"},
 {"type": "UInt64 → Fin UInt64.size", "offspring": [], "name": "UInt64.val"},
 {"type": "∀ {α : Type u_1} {a : α}, Option.isNone (some a) = false",
  "offspring": [],
  "name": "Option.isNone_some"},
 {"type":
  "∀ (m : ℕ) {k n : ℕ}, Nat.coprime k n → Nat.gcd (m * k) n = Nat.gcd m n",
  "offspring": ["Nat.coprime.gcd_mul_left_cancel"],
  "name": "Nat.coprime.gcd_mul_right_cancel"},
 {"type": "∀ {a b c : ℤ}, -a < b - c → c < a + b",
  "offspring": ["Int.lt_add_of_neg_add_lt_left", "Int.add_lt_of_lt_sub_right"],
  "name": "Int.lt_add_of_neg_lt_sub_left"},
 {"type":
  "∀ {α : Type u_1} {a : α} {o : Option α}, a ∈ Option.toList o ↔ a ∈ o",
  "offspring":
  ["List.not_mem_nil",
   "Option.mem_def",
   "eq_false'",
   "List.mem_cons",
   "or_false",
   "eq_comm",
   "Option.some.injEq"],
  "name": "Option.mem_toList"},
 {"type": "∀ (a : ℤ), -a + a = 0",
  "offspring":
  ["Int.neg_ofNat_of_succ",
   "Int.negSucc_ofNat_add_ofNat",
   "Int.sub_nat_self",
   "Int.neg_neg_ofNat_succ",
   "Int.ofNat_add_negSucc_ofNat"],
  "name": "Int.add_left_neg"},
 {"type": "{α : Sort u} → {p : α → Prop} → (∃ x, p x) → Inhabited α",
  "offspring":
  ["Classical.inhabited_of_nonempty", "Classical.inhabited_of_exists.proof_1"],
  "name": "Classical.inhabited_of_exists"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} [inst : Setoid α] (s : Subtype p), s ≈ s",
  "offspring": ["Setoid.refl", "Subtype.val"],
  "name": "Subtype.refl"},
 {"type": "Tactic.Ring.HornerExpr → Lean.Expr",
  "offspring": [],
  "name": "Tactic.Ring.HornerExpr.e"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} {a : α} [inst : Monad m], ExceptCpsT.runCatch (throw a) = pure a",
  "offspring": [],
  "name": "ExceptCpsT.runCatch_throw"},
 {"type":
  "∀ {n : ℕ} (self : UFModel n) (i : Fin n),\n  ↑(UFModel.parent self i) ≠ ↑i → UFModel.rank self ↑i < UFModel.rank self ↑(UFModel.parent self i)",
  "offspring": [],
  "name": "UFModel.rank_lt"},
 {"type":
  "∀ {R : Type u_1} {n : ℕ} [inst : AddGroupWithOne R], ↑-[1+ n] = -↑(n + 1)",
  "offspring": ["AddGroupWithOne.intCast_negSucc"],
  "name": "Int.cast_negSucc"},
 {"type": "{α : Type u_1} → [inst : AndThen α] → HAndThen α α α",
  "offspring": ["HAndThen.mk", "AndThen.andThen"],
  "name": "instHAndThen"},
 {"type": "∀ {a b : Prop}, a ∨ b ↔ b ∨ a",
  "offspring": ["Or.symm"],
  "name": "Or.comm"},
 {"type":
  "∀ {β : Sort u_1} {δ : Sort u_2} {α : Sort u_3} {f : β → δ} {g : α → β} {x : α}, Function.comp f g x = f (g x)",
  "offspring": [],
  "name": "Function.comp_apply"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → (List α → List β → List β) → List β",
  "offspring": [],
  "name": "List.sublistsAux"},
 {"type": "List Bool → Bool", "offspring": ["List.all"], "name": "List.and"},
 {"type": "CommSemiring ℕ",
  "offspring": ["CommSemiring.mk"],
  "name": "Nat.instCommSemiringNat"},
 {"type": "(a b : UInt64) → Decidable (a < b)",
  "offspring": [],
  "name": "UInt64.decLt"},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop},\n  Sat.Literal.reify v l a → Sat.Clause.reify v (Sat.Clause.cons l Sat.Clause.nil) a",
  "offspring":
  ["Sat.Clause.reify.mk",
   "Sat.Clause.reify.prop",
   "Sat.Clause.reify_and",
   "Sat.Clause.reify_zero"],
  "name": "Sat.Clause.reify_one"},
 {"type":
  "∀ {α β : Type u} {fst : α} {snd : β} {fst_1 : α} {snd_1 : β},\n  { fst := fst, snd := snd } = { fst := fst_1, snd := snd_1 } → fst = fst_1 ∧ snd = snd_1",
  "offspring": [],
  "name": "MProd.mk.inj"},
 {"type": "Mathlib.Tactic.Lint.NamedLinter → Mathlib.Tactic.Lint.Linter",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.NamedLinter.toLinter"},
 {"type":
  "Lean.Expr →\n  (Mathlib.Tactic.Lint.SimpTheoremInfo → Lean.MetaM (Option Lean.MessageData)) → Lean.MetaM (Option Lean.MessageData)",
  "offspring":
  ["Mathlib.Tactic.Lint.withSimpTheoremInfos",
   "Option.mapM",
   "Array.isEmpty",
   "Array.toList",
   "Array.filterMap"],
  "name": "Mathlib.Tactic.Lint.checkAllSimpTheoremInfos"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "prioHigh"},
 {"type":
  "∀ {A : Type u} [inst : AddSemigroup A] [inst_1 : IsAddLeftCancel A] (a : A) {b c : A}, a + b = a + c ↔ b = c",
  "offspring": ["add_left_cancel"],
  "name": "add_right_inj"},
 {"type": "StdGen → ℕ × StdGen",
  "offspring": ["Int.toNat", "StdGen.mk", "Int.instLTInt", "HDiv.hDiv"],
  "name": "stdNext"},
 {"type":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ) (a : R),\n  AddGroupWithOne.gsmul (Int.ofNat (Nat.succ n)) a = a + AddGroupWithOne.gsmul (Int.ofNat n) a",
  "offspring": [],
  "name": "AddGroupWithOne.gsmul_succ'"},
 {"type": "∀ (a : ℤ), -a = -1 * a",
  "offspring": [],
  "name": "Int.neg_eq_neg_one_mul"},
 {"type": "{α : Type u} → Sort u_1 → OrOp α → OrOp α → Sort u_1",
  "offspring": [],
  "name": "OrOp.noConfusionType"},
 {"type": "Lean.CoreM (Array Lean.Name)",
  "offspring": ["Mathlib.Tactic.Lint.getDeclsInCurrModule", "Array.map"],
  "name": "Mathlib.Tactic.Lint.getAllDecls"},
 {"type": "∀ {α : Type u_1} (l l₁ l₂ : List α), l ⊆ l₂ → l ⊆ l₁ ++ l₂",
  "offspring": ["List.subset.trans", "List.subset_append_right"],
  "name": "List.subset_append_of_subset_right"},
 {"type":
  "∀ {α α' : Sort u} {β : α → Sort v} {β' : α' → Sort v} {f : (a : α) → β a} {f' : (a : α') → β' a},\n  α = α' → (∀ (a : α) (a' : α'), HEq a a' → HEq (f a) (f' a')) → HEq f f'",
  "offspring": [],
  "name": "Function.hfunext"},
 {"type": "DecidableEq UInt16",
  "offspring": ["UInt16.decEq"],
  "name": "instDecidableEqUInt16"},
 {"type": "∀ (b : ℕ), 0 / b = 0",
  "offspring": ["Nat.div_eq", "if_neg", "Nat.not_le_of_gt"],
  "name": "Nat.zero_div"},
 {"type":
  "{f : Type u → Type v} → {inst : Functor f} → Sort u_1 → LawfulFunctor f → LawfulFunctor f → Sort u_1",
  "offspring": [],
  "name": "LawfulFunctor.noConfusionType"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "precLead"},
 {"type": "Prop", "offspring": [], "name": "False"},
 {"type": "Bool → Bool → Bool", "offspring": [], "name": "and"},
 {"type": "ℕ → Sat.Literal", "offspring": [], "name": "Sat.Literal.pos"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.commandLrat_proof__Example__"},
 {"type": "∀ {x y : ℕ}, Nat.mul x y = x * y",
  "offspring": [],
  "name": "Nat.mul_eq"},
 {"type": "∀ (a b : ℕ), ¬a = b → -[1+ a] = -[1+ b] → False",
  "offspring": [],
  "name": "Int.decEq.proof_4"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : (a a_1 : α) → TC r a a_1 → Prop} (a b c : α) {a_1 : TC r a b},\n  TC.below a_1 → motive a b a_1 → ∀ {a_4 : TC r b c}, TC.below a_4 → motive b c a_4 → TC.below (_ : TC r a c)",
  "offspring": [],
  "name": "TC.below.trans"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_3} {φ : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ),\n  (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n    ∀ (q₂ : Quotient s₂) (a b : α),\n      a ≈ b →\n        (fun a₁ => Quotient.lift (f a₁) (_ : ∀ (a b : β), a ≈ b → f a₁ a = f a₁ b) q₂) a =\n          (fun a₁ => Quotient.lift (f a₁) (_ : ∀ (a b : β), a ≈ b → f a₁ a = f a₁ b) q₂) b",
  "offspring": ["Quotient.ind"],
  "name": "Quotient.lift₂.proof_2"},
 {"type": "Mathlib.Tactic.Lint.Linter",
  "offspring":
  ["Mathlib.Tactic.Lint.Linter.mk",
   "Mathlib.Tactic.Lint.isSimpTheorem",
   "Option"],
  "name": "Mathlib.Tactic.Lint.simpComm"},
 {"type": "(α : Sort u) → α → α", "offspring": [], "name": "typedExpr"},
 {"type": "Type → Type",
  "offspring": ["Prod", "Tactic.Cache"],
  "name": "Tactic.DeclCache"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_>>_»"},
 {"type": "∀ {a b : Prop}, a → (a → b ↔ b)",
  "offspring": ["imp_intro"],
  "name": "imp_iff_right"},
 {"type":
  "{α : Sort u} →\n  {C : α → Sort v} → {r : α → α → Prop} → WellFounded r → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → C x",
  "offspring": ["WellFounded.fixF", "WellFounded.apply"],
  "name": "WellFounded.fix"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β → Prop) → List α → List β → Prop",
  "offspring": [],
  "name": "List.Forall₂"},
 {"type": "{α : Type u} → List α → List (ℕ × α)",
  "offspring": ["List.enumFrom"],
  "name": "List.enum"},
 {"type": "sizeOf Mathlib.Tactic.Lint.LintVerbosity.high = 1",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.high.sizeOf_spec"},
 {"type": "∀ (a : ℤ), ∃ n, a = Int.ofNat n ∨ a = -Int.ofNat n",
  "offspring": ["Int.natAbs", "Int.natAbs_eq"],
  "name": "Int.eq_x_or_neg"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → (α → β → γ) → List α → List β → List γ",
  "offspring": [],
  "name": "List.map₂"},
 {"type": "List.iota = List.iotaTR",
  "offspring": [],
  "name": "List.iota_eq_iotaTR"},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → ByteArray → β → (UInt8 → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "ByteArray.forIn"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["Nat.mul"], "name": "Nat.pow"},
 {"type":
  "{σ : Type} → {m n : Type → Type} → [inst : MonadLift m n] → [inst : STWorld σ m] → STWorld σ n",
  "offspring": ["STWorld.mk"],
  "name": "instSTWorld"},
 {"type": "Type u → Type u", "offspring": [], "name": "OrElse"},
 {"type": "{A : Type u} → [self : SubNegMonoid A] → Sub A",
  "offspring": [],
  "name": "SubNegMonoid.toSub"},
 {"type":
  "∀ (hyps : Array Lean.Expr) (isConditional : Bool) (lhs rhs : Lean.Expr) (hyps_1 : Array Lean.Expr)\n  (isConditional_1 : Bool) (lhs_1 rhs_1 : Lean.Expr),\n  ({ hyps := hyps, isConditional := isConditional, lhs := lhs, rhs := rhs } =\n      { hyps := hyps_1, isConditional := isConditional_1, lhs := lhs_1, rhs := rhs_1 }) =\n    (hyps = hyps_1 ∧ isConditional = isConditional_1 ∧ lhs = lhs_1 ∧ rhs = rhs_1)",
  "offspring":
  ["Mathlib.Tactic.Lint.SimpTheoremInfo",
   "Mathlib.Tactic.Lint.SimpTheoremInfo.mk"],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.mk.injEq"},
 {"type": "∀ {m n : ℕ}, m < Nat.succ n ↔ m ≤ n",
  "offspring": ["Nat.le_of_lt_succ", "Nat.lt_succ_of_le"],
  "name": "Nat.lt_succ_iff"},
 {"type": "{α : Type u_1} → [inst : Ord α] → DecidableRel LE.le",
  "offspring": ["Ordering.isLE", "Ord.compare"],
  "name": "instDecidableRelLeLeOfOrd"},
 {"type": "{α : Type u} → List (List α) → List α",
  "offspring": [],
  "name": "List.join"},
 {"type":
  "∀ (α : Sort u_1) {β : α → Sort u_2} [inst : ∀ (a : α), Nonempty (β a)], Nonempty ((a : α) → β a)",
  "offspring": ["Classical.ofNonempty"],
  "name": "instNonemptyForAll_1.proof_1"},
 {"type": "∀ {a : Prop}, ¬(a ∧ ¬a)", "offspring": [], "name": "and_not_self"},
 {"type": "{α β : Type u} → MProd α β → α",
  "offspring": [],
  "name": "MProd.fst"},
 {"type": "∀ {n m : ℕ}, Nat.ble n m = true → n ≤ m",
  "offspring": ["Nat.zero_le", "Nat.succ_le_succ"],
  "name": "Nat.le_of_ble_eq_true"},
 {"type": "∀ (a b : ℤ), a + b - b = a",
  "offspring": ["Int.add_neg_cancel_right"],
  "name": "Int.add_sub_cancel"},
 {"type": "Tactic.Ring.HornerExpr → Bool",
  "offspring": ["Tactic.Ring.HornerExpr.xadd", "Decidable.decide"],
  "name": "Tactic.Ring.HornerExpr.isZero"},
 {"type": "Float → Float", "offspring": [], "name": "Float.acosh"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} (x : β) (f : α → β) (a : α), Option.elim (some a) x f = f a",
  "offspring": [],
  "name": "Option.elim_some"},
 {"type":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p → q)",
  "offspring":
  ["instDecidableForAll.proof_1",
   "instDecidableForAll.proof_2",
   "instDecidableForAll.proof_3"],
  "name": "instDecidableForAll"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a ≤ c → b ≤ c → max a b ≤ c",
  "offspring":
  ["if_pos", "instDecidableLtToLTToPreorderToPartialOrder", "if_neg"],
  "name": "max_le"},
 {"type":
  "{f f' : Sat.Fmla} → Sort u → Sat.Fmla.subsumes f f' → Sat.Fmla.subsumes f f' → Sort u",
  "offspring": [],
  "name": "Sat.Fmla.subsumes.noConfusionType"},
 {"type": "∀ {n : ℕ} {a b : Fin n}, a < b → a % b = a",
  "offspring":
  ["Fin.eq_of_val_eq", "Fin.mod_def", "Nat.mod_eq_of_lt", "Fin.isLt"],
  "name": "Fin.mod_eq_of_lt"},
 {"type": "{α : Type u} → [self : Subset α] → α → α → Prop",
  "offspring": [],
  "name": "Subset.subset"},
 {"type": "Repr UInt64",
  "offspring": ["repr", "instReprNat", "UInt64.toNat"],
  "name": "instReprUInt64"},
 {"type":
  "∀ {α : Sort u_1} (p : α → Prop) (h : Nonempty α), (¬∃ x, p x) → (∃ y, p y) → p (Classical.choice h)",
  "offspring": [],
  "name": "Classical.strongIndefiniteDescription.proof_2"},
 {"type":
  "{ε : outParam (Type u)} →\n  {m : Type v → Type w} → ({α : Type v} → ε → m α) → ({α : Type v} → m α → (ε → m α) → m α) → MonadExcept ε m",
  "offspring": [],
  "name": "MonadExcept.mk"},
 {"type": "ByteSlice → ℕ", "offspring": [], "name": "ByteSlice.len"},
 {"type": "Inhabited Tactic.NormCast.CoeFnInfo",
  "offspring":
  ["Tactic.NormCast.CoeFnInfo.mk",
   "Inhabited.default",
   "instInhabitedNat",
   "Tactic.NormCast.CoeFnType",
   "Tactic.NormCast.instInhabitedCoeFnType"],
  "name": "Tactic.NormCast.instInhabitedCoeFnInfo"},
 {"type": "Tactic.Ring.HornerExpr → Lean.MetaM Lean.Format",
  "offspring": ["instToStringNat", "PProd.snd"],
  "name": "Tactic.Ring.HornerExpr.pp"},
 {"type": "Mathlib.Tactic.Lint.Linter → Lean.MessageData",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.noErrorsFound"},
 {"type":
  "{α : Type u_1} → {p : α → Prop} → [inst : Repr α] → Repr (Subtype p)",
  "offspring": ["Subtype.val"],
  "name": "instReprSubtype"},
 {"type":
  "∀ {M : Type u} [inst : CommSemigroup M] (a b c d : M), a * b * (c * d) = a * c * (b * d)",
  "offspring": ["mul_left_comm", "Semigroup.mul_assoc"],
  "name": "mul_mul_mul_comm"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∈_»"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HDiv α β γ] → α → β → γ",
  "offspring": [],
  "name": "HDiv.hDiv"},
 {"type": "Lean.ToExpr Tactic.NormCast.CoeFnInfo",
  "offspring":
  ["Tactic.NormCast.CoeFnType", "Tactic.NormCast.instToExprCoeFnType"],
  "name": "Tactic.NormCast.instToExprCoeFnInfo"},
 {"type": "{R : Type u_1} → [inst : AddMonoidWithOne R] → CoeHTCT ℕ R",
  "offspring": ["CoeHTCT.mk"],
  "name": "instCoeHTCTNat"},
 {"type":
  "∀ {α : Type u_1} {p : Option α → Prop}, (∀ (x : Option α), x ≠ none → p x) ↔ ∀ (x : α), p (some x)",
  "offspring": ["Option.some_ne_none"],
  "name": "Option.ball_ne_none"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b",
  "offspring": ["lt_irrefl"],
  "name": "ne_of_lt"},
 {"type": "∀ {a b : ℤ}, -b < -a → a < b",
  "offspring": ["Int.neg_lt_neg", "Int.neg_neg"],
  "name": "Int.lt_of_neg_lt_neg"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {g : β → φ} {f : α → β},\n  Function.injective g → Function.injective f → Function.injective (g ∘ f)",
  "offspring": [],
  "name": "Function.injective.comp"},
 {"type":
  "{α : Type u_1} → (α → α → Bool) → (a : Array α) → Fin (Array.size a) → { a' // Array.size a' = Array.size a }",
  "offspring": ["WellFounded.fix", "Subtype.mk"],
  "name": "BinaryHeap.heapifyUp"},
 {"type":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → m ρ → MonadReader ρ m",
  "offspring": [],
  "name": "MonadReader.mk"},
 {"type": "{α : Type u_1} → [inst : Repr α] → Repr (Option α)",
  "offspring": ["reprArg"],
  "name": "instReprOption"},
 {"type":
  "{p : ℕ → Sort u} → (n : ℕ) → ((n : ℕ) → ((m : ℕ) → m < n → p m) → p n) → p n",
  "offspring": ["WellFounded.fix'", "WellFoundedRelation.wf", "Nat.lt_wfRel"],
  "name": "Nat.strong_rec_on"},
 {"type": "Type u_1 → Type u_1", "offspring": [], "name": "UnionFind"},
 {"type":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → ({α : Type u} → (ρ → ρ) → m α → m α) → MonadWithReader ρ m",
  "offspring": [],
  "name": "MonadWithReader.mk"},
 {"type": "∀ {a : Prop}, ¬¬a → a",
  "offspring": ["by_contra"],
  "name": "of_not_not"},
 {"type": "∀ {a : ℤ}, Int.NonNeg a → ∃ n, a = ↑n",
  "offspring": ["Int.nonneg_def"],
  "name": "Int.NonNeg.elim"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → (self : BinaryHeap α lt) → Fin (BinaryHeap.size self) → α → BinaryHeap α lt",
  "offspring":
  ["BinaryHeap.mk",
   "Subtype.val",
   "BinaryHeap.heapifyDown",
   "Array.set",
   "BinaryHeap.arr",
   "BinaryHeap.decreaseKey.proof_1"],
  "name": "BinaryHeap.decreaseKey"},
 {"type": "ByteArray → Array UInt8", "offspring": [], "name": "ByteArray.data"},
 {"type": "Add Float",
  "offspring": ["Add.mk", "Float.add"],
  "name": "instAddFloat"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} (hd : α) (tl : List α),\n  List.Pairwise R tl → (∀ (x : α), x ∈ tl → R hd x) → List.Pairwise R (hd :: tl)",
  "offspring": ["List.Pairwise_cons"],
  "name": "List.decidablePairwise.proof_3"},
 {"type": "Type", "offspring": [], "name": "Bool"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.tacticSimp_rw___"},
 {"type": "∀ {a b c : ℕ}, a < b → b ≤ c → a < c",
  "offspring": ["Nat.lt_of_lt_of_le"],
  "name": "Nat.instTransNatLtInstLTNatLeInstLENat.proof_1"},
 {"type": "(α : Sort u) → α → Sort v → Sort (max 1 v)",
  "offspring": [],
  "name": "CoeDep"},
 {"type": "Substring → String.Pos → String.Pos → Substring",
  "offspring": ["GE.ge", "Substring.mk", "Nat.min"],
  "name": "Substring.extract"},
 {"type": "Array ℤ → Lean.Expr → ℕ → Mathlib.Tactic.Sat.LClause",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LClause.mk"},
 {"type": "∀ {α : Type u_1} {a b : α}, a ∈ [b] → a = b",
  "offspring": ["Or.elim", "List.eq_or_mem_of_mem_cons", "List.not_mem_nil"],
  "name": "List.eq_of_mem_singleton"},
 {"type": "∀ {a b : Prop}, ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "offspring": ["Decidable.not_and_distrib"],
  "name": "not_and_distrib"},
 {"type":
  "∀ {α : Type u_1} [inst : SizeOf α] (parent : ℕ) (value : α) (rank : ℕ),\n  sizeOf { parent := parent, value := value, rank := rank } = 1 + sizeOf parent + sizeOf value + sizeOf rank",
  "offspring": ["instSizeOfNat"],
  "name": "UFNode.mk.sizeOf_spec"},
 {"type": "∀ (a b : ℕ), a ≤ b ∨ b ≤ a",
  "offspring": ["Or.imp_left", "Nat.le_of_lt", "Nat.lt_or_ge"],
  "name": "Nat.le_or_le"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ),\n  Function.injective2 f → ∀ {a₁ a₂ : α} {b₁ b₂ : β}, f a₁ b₁ = f a₂ b₂ → b₁ = b₂",
  "offspring": [],
  "name": "Function.injective2.right"},
 {"type": "∀ (a b : ℕ), a = b → -[1+ a] = -[1+ b]",
  "offspring": [],
  "name": "Int.decEq.proof_3"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term∅»"},
 {"type": "HMod UInt8 ℕ UInt8",
  "offspring": ["HMod.mk", "UInt8.modn"],
  "name": "instHModUInt8Nat"},
 {"type": "Div UInt32",
  "offspring": ["Div.mk", "UInt32.div"],
  "name": "instDivUInt32"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (n_1 : ℕ) (x : Fin n), Monoid.npow (Nat.succ n_1) x = x * Monoid.npow n_1 x",
  "offspring": ["Monoid.npow_succ'"],
  "name": "instCommSemiringFin.proof_11"},
 {"type": "∀ {m n : ℕ}, Int.subNatNat m n = Int.ofNat m - Int.ofNat n",
  "offspring":
  ["Int.subNatNat_elim",
   "Int.ofNat_add",
   "Int.sub_eq_add_neg",
   "Int.add_assoc",
   "Int.add_left_comm",
   "Int.add_right_neg",
   "Int.add_zero",
   "Int.negSucc_ofNat_coe",
   "Int.neg_add",
   "Int.ofNat_sub",
   "Nat.le_refl",
   "Nat.sub_self",
   "Int.ofNat_zero",
   "Int.zero_add"],
  "name": "Int.subNatNat_eq_coe"},
 {"type":
  "∀ {ctx : Nat.Linear.Context} {c₁ c₂ : Nat.Linear.PolyCnstr},\n  Nat.Linear.PolyCnstr.denote ctx c₁ →\n    Nat.Linear.PolyCnstr.denote ctx c₂ → Nat.Linear.PolyCnstr.denote ctx (Nat.Linear.PolyCnstr.combine c₁ c₂)",
  "offspring":
  ["Bool.and_self",
   "cond_true",
   "Nat.Linear.Poly.denote_eq_cancel_eq",
   "Nat.Linear.Poly.denote_combine",
   "Bool.of_not_eq_true",
   "Bool.and_false",
   "cond_false",
   "Nat.Linear.Poly.denote_le_cancel_eq",
   "Nat.add_le_add_left",
   "Bool.and_true",
   "Nat.add_le_add_right",
   "Nat.add_le_add"],
  "name": "Nat.Linear.PolyCnstr.denote_combine"},
 {"type": "Nat.Linear.Poly → Bool",
  "offspring":
  ["Nat.Linear.Var",
   "cond",
   "instBEqNat",
   "Nat.Linear.fixedVar",
   "Decidable.decide",
   "GT.gt"],
  "name": "Nat.Linear.Poly.isNonZero"},
 {"type": "∀ {a b c : ℤ}, a ≤ b → b ≤ c → a ≤ c",
  "offspring": ["Int.le.intro", "Int.add_assoc", "Nat.cast_add", "Int.le.dest"],
  "name": "Int.le_trans"},
 {"type": "UInt32 → UInt16",
  "offspring": ["Nat.toUInt16", "UInt32.toNat"],
  "name": "UInt32.toUInt16"},
 {"type": "0 < UInt16.size", "offspring": [], "name": "UInt16.size_positive"},
 {"type": "Sat.Clause → Sat.Fmla", "offspring": [], "name": "Sat.Fmla.one"},
 {"type": "{α : Type u} → (α → (Unit → α) → α) → OrElse α",
  "offspring": [],
  "name": "OrElse.mk"},
 {"type": "∀ (x x_1 : USize), { val := (x + x_1).1 } = { val := (x_1 + x).1 }",
  "offspring": ["USize.mk", "AddCommSemigroup.add_comm"],
  "name": "USize.instAddCommSemigroupUSize.proof_1"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HPow α β γ → HPow α β γ → Sort u_1",
  "offspring": [],
  "name": "HPow.noConfusionType"},
 {"type":
  "∀ (ids : Array ℕ), sizeOf (Mathlib.Tactic.Sat.LRATStep.del ids) = 1 + sizeOf ids",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LRATStep.del.sizeOf_spec"},
 {"type":
  "∀ {α : Sort u_1} (P : Prop) [inst : Decidable P] (x y : α), (if ¬P then x else y) = if P then y else x",
  "offspring": ["dite_not"],
  "name": "ite_not"},
 {"type": "Repr ℤ", "offspring": ["Int.repr"], "name": "instReprInt"},
 {"type": "∀ {a b : Prop}, a ∧ ¬b → ¬(a → b)",
  "offspring": [],
  "name": "not_imp_of_and_not"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«termΣ'_,_»"},
 {"type":
  "{α : Type u} →\n  {motive : (a : α) → (a_1 : List α) → List.Mem a a_1 → Prop} → {a : α} → {a_1 : List α} → List.Mem a a_1 → Prop",
  "offspring": [],
  "name": "List.Mem.below"},
 {"type": "∀ {α : Type u_1}, Nonempty (ULift α) ↔ Nonempty α",
  "offspring": ["Nonempty", "ULift", "ULift.up"],
  "name": "nonempty_ulift"},
 {"type": "∀ (a : UInt32), sizeOf a = UInt32.toNat a + 2",
  "offspring":
  ["UInt32.mk.sizeOf_spec",
   "Fin.sizeOf",
   "UInt32.size",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var"],
  "name": "UInt32.sizeOf"},
 {"type": "∀ {α : Type u_1} (x : Option α), Option.bind x some = x",
  "offspring": [],
  "name": "Option.bind_some"},
 {"type": "{α : Sort u₁} → {β : α → Sort u₂} → ((x : α) → β x) → (x : α) → β x",
  "offspring": [],
  "name": "Function.app"},
 {"type":
  "∀ (m n k : ℕ), Int.subNatNat m n + -[1+ k] = Int.subNatNat m (n + Nat.succ k)",
  "offspring": [],
  "name": "Int.subNatNat_add_negSucc_ofNat"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (x : α) (y : β), Function.uncurry f (x, y) = f x y",
  "offspring": [],
  "name": "Function.uncurry_apply_pair"},
 {"type":
  "∀ {v : Sat.Valuation} {c : Sat.Clause} {a : Prop}, Sat.Clause.reify v c a → Sat.Fmla.reify v (Sat.Fmla.one c) a",
  "offspring":
  ["Sat.Fmla.reify.mk",
   "Sat.Clause.reify.prop",
   "Sat.Valuation.satisfies_fmla.mk",
   "Sat.Fmla",
   "Sat.Valuation.satisfies"],
  "name": "Sat.Fmla.reify_one"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [inst : Decidable P] (x y : α),\n  f (if P then x else y) = if P then f x else f y",
  "offspring": ["apply_dite"],
  "name": "apply_ite"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_⊆_»"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β},\n  Function.bijective f → ∀ (g : γ → α), Function.bijective (f ∘ g) ↔ Function.bijective g",
  "offspring":
  ["and_congr",
   "Function.injective.of_comp_iff",
   "Function.bijective.injective",
   "Function.surjective.of_comp_iff'"],
  "name": "Function.bijective.of_comp_iff'"},
 {"type": "{α : Sort u} → (s : Setoid α) → α → Quotient s",
  "offspring": ["Quot.mk"],
  "name": "Quotient.mk"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk", "Fin.land", "UInt32.size"],
  "name": "UInt32.land"},
 {"type":
  "Sort u → Mathlib.Tactic.Lint.LintVerbosity → Mathlib.Tactic.Lint.LintVerbosity → Sort u",
  "offspring":
  ["noConfusionTypeEnum",
   "Mathlib.Tactic.Lint.LintVerbosity",
   "Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx"],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.noConfusionType"},
 {"type": "∀ {α : Sort u} {f : α → α}, Function.involutive f → f ∘ f = id",
  "offspring": [],
  "name": "Function.involutive.comp_self"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HMul α β γ → HMul α β γ → Sort u_1",
  "offspring": [],
  "name": "HMul.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : ℕ) (h : i < Array.size a),\n  Array.get? a i = some (Array.get a { val := i, isLt := h })",
  "offspring": ["dite_congr", "Eq.mpr_prop", "dite_true", "True.intro"],
  "name": "Array.get?_eq_get"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), a >>> b % n < n",
  "offspring": [],
  "name": "Fin.shiftRight.proof_1"},
 {"type": "∀ {n m : ℕ}, Nat.le n m → Nat.le n (Nat.succ m)",
  "offspring": [],
  "name": "Nat.le.step"},
 {"type": "Dvd ℕ", "offspring": ["Dvd.mk"], "name": "Nat.instDvdNat"},
 {"type": "∀ {α : Sort u_1} (a b : α), (if True then a else b) = a",
  "offspring": [],
  "name": "ite_true"},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → (r : α → β → Prop) → Trans r Eq r",
  "offspring": ["Trans.mk", "instTransEq_1.proof_1"],
  "name": "instTransEq_1"},
 {"type": "Type u → outParam (Type u) → Type u",
  "offspring": [],
  "name": "ToStream"},
 {"type": "Complement UInt8",
  "offspring": ["Complement.mk", "UInt8.complement"],
  "name": "instComplementUInt8"},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Monad m] → Inhabited (α → m α)",
  "offspring": [],
  "name": "instInhabitedForAll_2"},
 {"type": "(a b : UInt8) → Decidable (a = b)",
  "offspring": ["UInt8.decEq.proof_1", "UInt8.decEq.proof_2"],
  "name": "UInt8.decEq"},
 {"type": "ℕ → ℕ → ℕ",
  "offspring": ["WellFounded.fix", "Nat.gcd.proof_1", "Nat.zero_lt_succ"],
  "name": "Nat.gcd"},
 {"type": "Div Float",
  "offspring": ["Div.mk", "Float.div"],
  "name": "instDivFloat"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) (a : α) (l : List α), (∀ (x : α), x ∈ a :: l → p x) ↔ p a ∧ ∀ (x : α), x ∈ l → p x",
  "offspring": ["List.mem_cons_self", "List.mem_cons_of_mem"],
  "name": "List.ball_cons"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_||_»"},
 {"type": "∀ {α : Sort u} {a : α}, HEq a a",
  "offspring": ["HEq.rfl.proof_1"],
  "name": "HEq.rfl"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, p.fst = q.fst → p.snd = q.snd → p = q",
  "offspring": ["Prod.ext_iff"],
  "name": "Prod.ext'"},
 {"type":
  "∀ (n : ℕ) (a : UInt16),\n  { val := AddMonoid.nsmul (Nat.succ n) a.val } = { val := (a + (fun n a => { val := AddMonoid.nsmul n a.val }) n a).1 }",
  "offspring": ["AddMonoid.nsmul_succ'"],
  "name": "UInt16.instSemiringUInt16.proof_5"},
 {"type": "{m : Type u_1 → Type u_2} → {α : Type u_3} → ForM m (List α) α",
  "offspring": ["ForM.mk", "List.forM"],
  "name": "List.instForMList"},
 {"type": "ℕ → Tactic.NormCast.Label",
  "offspring":
  ["cond",
   "Nat.ble",
   "Nat.beq",
   "Tactic.NormCast.Label.move",
   "Tactic.NormCast.Label.squash",
   "Tactic.NormCast.Label.elim"],
  "name": "Tactic.NormCast.Label.ofNat"},
 {"type":
  "{m : Type u → Type v} → ({α β : Type u} → m α → (α → m β) → m β) → Bind m",
  "offspring": [],
  "name": "Bind.mk"},
 {"type": "outParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "MonadState"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (List α → α → List α → β) → List α → List β",
  "offspring": ["List.mapWithPrefixSuffixAux"],
  "name": "List.mapWithPrefixSuffix"},
 {"type": "∀ {α : Type u_1} (x y : α) (l : List α), y :: x :: l ~ x :: y :: l",
  "offspring": [],
  "name": "List.Perm.swap"},
 {"type": "∀ {α : Type u} {val val_1 : α}, some val = some val_1 → val = val_1",
  "offspring": [],
  "name": "Option.some.inj"},
 {"type":
  "{m : Type u_1 → Type u_2} → {ε α : Type u_1} → [inst : Monad m] → [inst : Inhabited ε] → Inhabited (ExceptT ε m α)",
  "offspring": ["Inhabited.default"],
  "name": "instInhabitedExceptT"},
 {"type": "Prop → Prop → Prop", "offspring": [], "name": "Or"},
 {"type": "∀ (n : ℕ), n * 0 = 0", "offspring": [], "name": "Nat.mul_zero"},
 {"type": "{g : Type} → [inst : RandomGen g] → RandG g ℕ",
  "offspring":
  ["MonadState.get",
   "MonadStateOf.set",
   "ULift.up",
   "RandomGen.next",
   "ULift.down"],
  "name": "Rand.next"},
 {"type": "{α : Sort u} → (α → ℕ) → α → α → Prop",
  "offspring": ["InvImage"],
  "name": "Measure"},
 {"type": "UInt16 → UInt16 → Prop", "offspring": [], "name": "UInt16.lt"},
 {"type": "{α : Type u} → [inst : ToString α] → ToString (List α)",
  "offspring": ["ToString.mk", "List.toString"],
  "name": "instToStringList"},
 {"type": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "offspring": ["Nat.cast_succ", "Nat.cast_zero", "zero_add"],
  "name": "Nat.cast_one"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddCommGroup"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop}, (∃ x, p x) → (∀ (y₁ y₂ : α), p y₁ → p y₂ → y₁ = y₂) → ExistsUnique fun x => p x",
  "offspring": ["Exists.elim", "ExistsUnique.intro"],
  "name": "exists_unique_of_exists_of_unique"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Mathlib.ExtendedBinder.extBinders"],
  "name": "Set.«term{_|_}_1»"},
 {"type": "Sort u → ByteSliceT → ByteSliceT → Sort u",
  "offspring": [],
  "name": "ByteSliceT.noConfusionType"},
 {"type": "Bool",
  "offspring": ["or", "System.Platform.isWindows", "System.Platform.isOSX"],
  "name": "System.FilePath.isCaseInsensitive"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {p : β → Prop} (h : ∀ (a : α), p (f a)),\n  Function.injective f → Function.injective (Subtype.coind f h)",
  "offspring": ["Subtype.val"],
  "name": "Subtype.coind_injective"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a x : α) (n m n' : ℕ) (a' : α),\n  n * m = n' → a ^ m = a' → Tactic.Ring.horner a x n 0 ^ m = Tactic.Ring.horner a' x n' 0",
  "offspring": ["add_zero", "mul_pow", "pow_mul"],
  "name": "Tactic.Ring.horner_pow"},
 {"type":
  "{p : Prop} → (P : p → Prop) → [Dp : Decidable p] → [DP : (h : p) → Decidable (P h)] → Decidable (∃ h, P h)",
  "offspring":
  ["decidable_of_decidable_of_iff",
   "exists_prop_decidable.proof_1",
   "exists_prop_decidable.proof_2"],
  "name": "exists_prop_decidable"},
 {"type": "∀ {k m n : ℕ}, Nat.coprime (m * k) n → Nat.coprime m n",
  "offspring": ["Nat.coprime.coprime_dvd_left", "Nat.dvd_mul_right"],
  "name": "Nat.coprime.coprime_mul_right"},
 {"type":
  "{α : Sort u} → {β : Sort v} → Sort u_1 → CoeHTCT α β → CoeHTCT α β → Sort u_1",
  "offspring": [],
  "name": "CoeHTCT.noConfusionType"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)], 0 < n",
  "offspring": ["Nonempty.elim", "Fin.size_positive"],
  "name": "Fin.size_positive'"},
 {"type":
  "{α β σ : Type u} → Sort u_1 → DoResultPRBC α β σ → DoResultPRBC α β σ → Sort u_1",
  "offspring": [],
  "name": "DoResultPRBC.noConfusionType"},
 {"type":
  "{α : Type u} → {β : Type v} → [ha : WellFoundedRelation α] → [hb : WellFoundedRelation β] → WellFoundedRelation (α × β)",
  "offspring": ["Prod.lex"],
  "name": "Prod.instWellFoundedRelationProd"},
 {"type":
  "∀ {G : Type u} [inst : Semigroup G] [inst_1 : IsMulLeftCancel G] {a b c : G}, a * b = a * c ↔ b = c",
  "offspring": ["mul_left_cancel"],
  "name": "mul_left_cancel_iff"},
 {"type": "∀ (m n : ℕ), Int.negOfNat n * -[1+ m] = Int.ofNat (n * Nat.succ m)",
  "offspring": ["Int.mul_comm", "Int.negSucc_ofNat_mul_negOfNat"],
  "name": "Int.negOfNat_mul_negSucc_ofNat"},
 {"type": "∀ {n : ℕ} (a b : Fin n), a * b = b * a",
  "offspring": ["Fin.eq_of_val_eq", "Fin.mul_def", "Fin.size_positive"],
  "name": "instCommSemigroupFin.proof_2"},
 {"type":
  "{A : Type u} →\n  [toAddSemigroup : AddSemigroup A] →\n    [toZero : Zero A] →\n      (∀ (a : A), a + 0 = a) →\n        (∀ (a : A), 0 + a = a) →\n          (nsmul : ℕ → A → A) →\n            (∀ (x : A), nsmul 0 x = 0) → (∀ (n : ℕ) (x : A), nsmul (Nat.succ n) x = x + nsmul n x) → AddMonoid A",
  "offspring": [],
  "name": "AddMonoid.mk"},
 {"type": "{α : Sort u} → {β : α → Sort v} → (fst : α) → β fst → PSigma β",
  "offspring": [],
  "name": "PSigma.mk"},
 {"type":
  "∀ {α : Sort u} {r q : α → α → Prop} {a : α}, Subrelation q r → Acc r a → Acc q a",
  "offspring": ["Subrelation.accessible.proof_1"],
  "name": "Subrelation.accessible"},
 {"type":
  "Lean.Name → optParam Lean.AttributeKind Lean.AttributeKind.global → optParam ℕ 1000 → Lean.MetaM Unit",
  "offspring":
  ["Tactic.NormCast.Label",
   "Tactic.NormCast.classifyType",
   "Tactic.NormCast.addElim",
   "Tactic.NormCast.addSquash",
   "Tactic.NormCast.addMove"],
  "name": "Tactic.NormCast.addInfer"},
 {"type": "Type u → Type u", "offspring": [], "name": "Subarray"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β},\n  Function.surjective f → ∀ {p : β → β → Prop}, (∃ y₁ y₂, p y₁ y₂) ↔ ∃ x₁ x₂, p (f x₁) (f x₂)",
  "offspring": ["Iff.trans", "Function.surjective.exists", "exists_congr"],
  "name": "Function.surjective.exists₂"},
 {"type":
  "∀ (n : ℕ) (a : UInt8),\n  { val := AddMonoid.nsmul (Nat.succ n) a.val } = { val := (a + (fun n a => { val := AddMonoid.nsmul n a.val }) n a).1 }",
  "offspring": ["AddMonoid.nsmul_succ'"],
  "name": "UInt8.instSemiringUInt8.proof_5"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → α → List α → List α",
  "offspring": [],
  "name": "List.remove"},
 {"type": "Tactic.NormCast.CoeFnType",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.coeFn"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.subset"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["Array.append"],
  "name": "Set.insertUnexpander"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "offspring": ["LinearOrder.le_total"],
  "name": "le_total"},
 {"type": "∀ {a b c : Prop}, a → b → c ↔ b → a → c",
  "offspring": ["Function.swap"],
  "name": "imp.swap"},
 {"type":
  "∀ (x x_1 x_2 : UInt32), { val := (x * x_1 * x_2).1 } = { val := (x * (x_1 * x_2)).1 }",
  "offspring": ["UInt32.mk", "Semigroup.mul_assoc"],
  "name": "UInt32.instSemigroupUInt32.proof_1"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "termMax_prec"},
 {"type":
  "{α : Sort u} → {β : α → Sort v} → ((x : α) → β x) → ((x : α) → β x) → Prop",
  "offspring": [],
  "name": "Function.Equiv"},
 {"type": "USize → USize → Prop", "offspring": [], "name": "USize.lt"},
 {"type": "{α : Type u} → [inst : BEq α] → α → List α → Bool",
  "offspring": [],
  "name": "List.elem"},
 {"type": "(!true) = false", "offspring": [], "name": "Bool.not_true"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {n : ℕ}, List.length l ≤ n → List.get? l n = none",
  "offspring": ["List.get?", "Nat.le_of_succ_le_succ"],
  "name": "List.get?_len_le"},
 {"type": "∀ (a : USize), { val := a.val } = a",
  "offspring": ["USize.size", "USize.mk"],
  "name": "USize.mk_val_eq"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {arr : Array α} {n : ℕ} {m : Fin n → β},\n  UFModel.Agrees arr f m →\n    ∀ {i : Fin (Array.size arr)} {x : α} {m' : Fin n → β},\n      (∀ (j : Fin n), ↑j ≠ ↑i → m' j = m j) →\n        (∀ (h : ↑i < n), f x = m' { val := ↑i, isLt := h }) → UFModel.Agrees (Array.set arr i x) f m'",
  "offspring": ["UFModel.Agrees.mk'", "Array.size_set"],
  "name": "UFModel.Agrees.set"},
 {"type": "∀ {M₀ : Type u} [self : MonoidWithZero M₀] (a : M₀), 0 * a = 0",
  "offspring": [],
  "name": "MonoidWithZero.zero_mul"},
 {"type": "∀ (n m : ℕ), Int.ofNat (n + m) = Int.ofNat n + Int.ofNat m",
  "offspring": [],
  "name": "Int.ofNat_add"},
 {"type": "Coe String System.FilePath",
  "offspring": ["Coe.mk", "System.FilePath.mk"],
  "name": "System.instCoeStringFilePath"},
 {"type": "Substring → String.Pos → String.Pos",
  "offspring": [],
  "name": "Substring.prev"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α β : Type u} → OptionT m α → (α → OptionT m β) → OptionT m β",
  "offspring": ["OptionT.mk"],
  "name": "OptionT.bind"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : Fin n), 0 * x = 0",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Fin.mul_def",
   "Fin.zero_def",
   "Nat.zero_mul",
   "Nat.zero_mod",
   "Fin.size_positive"],
  "name": "instMonoidWithZeroFin.proof_4"},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Set α → Set β",
  "offspring": ["setOf"],
  "name": "Set.image"},
 {"type": "{R : Type u} → [self : Ring R] → ℤ → R",
  "offspring": [],
  "name": "Ring.intCast"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["Array.append"],
  "name": "unexpandProdMk"},
 {"type": "{α : Type u} → {β : Type v} → Sort u_1 → α ⊕ β → α ⊕ β → Sort u_1",
  "offspring": [],
  "name": "Sum.noConfusionType"},
 {"type": "ℕ → Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["Nat.mul"],
  "name": "Nat.Linear.Poly.mul.go"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∀ (x : α), x ∈ a :: l → p x) → ∀ (x : α), x ∈ l → p x",
  "offspring": ["List.forall_mem_cons"],
  "name": "List.forall_mem_of_forall_mem_cons"},
 {"type": "∀ (a b : ℕ), 0 < a → a ≤ b → b - a < b",
  "offspring": ["Nat.sub_lt", "lt_of_lt_of_le"],
  "name": "Nat.sub_lt_of_pos_le"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2}, Nonempty (α × β) ↔ Nonempty α ∧ Nonempty β",
  "offspring": ["Nonempty", "Prod"],
  "name": "nonempty_prod"},
 {"type": "Mathlib.Tactic.Lint.LintVerbosity → ℕ",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx"},
 {"type": "∀ {a b : Prop}, ¬a → ¬b → (a ↔ b)",
  "offspring": ["Not.elim"],
  "name": "iff_of_false"},
 {"type": "{α : Type u} → Array α → Array α → Array α",
  "offspring": ["Array.foldl", "Array.push"],
  "name": "Array.append"},
 {"type": "System.FilePath → IO IO.FS.Metadata",
  "offspring": [],
  "name": "System.FilePath.metadata"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {r : α → α → Prop} {s : β → β → Prop} {b : β},\n  Acc s b → (∀ (a : α), Acc r a) → ∀ (a : α), Acc (PSigma.RevLex r s) { fst := a, snd := b }",
  "offspring": ["PSigma.revLexAccessible.proof_1"],
  "name": "PSigma.revLexAccessible"},
 {"type": "{α : Type u} → List α → ℕ → List α",
  "offspring": [],
  "name": "List.eraseIdx"},
 {"type": "Ord Char",
  "offspring": ["Ord.mk", "compareOfLessAndEq"],
  "name": "instOrdChar"},
 {"type": "∀ (a : UInt16), a + 0 = a",
  "offspring":
  ["UInt16.zero_def",
   "UInt16.add_def",
   "UInt16.mk",
   "add_zero",
   "UInt16.mk_val_eq"],
  "name": "UInt16.instSemiringUInt16.proof_1"},
 {"type":
  "{ε : Type u_1} → {m : Type u_1 → Type u_2} → MonadExceptOf ε (ExceptCpsT ε m)",
  "offspring": ["MonadExceptOf.mk"],
  "name": "ExceptCpsT.instMonadExceptOfExceptCpsT"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [inst : Monad m] (f : α → β → m (ForInStep β)) (b : β),\n  forIn [] b f = pure b",
  "offspring": [],
  "name": "List.forIn_nil"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → UInt8 → m β) → β → (as : ByteArray) → optParam ℕ 0 → optParam ℕ (ByteArray.size as) → m β",
  "offspring": ["ByteArray.size"],
  "name": "ByteArray.foldlMUnsafe"},
 {"type": "∀ {α : Sort u_1}, id = fun x => x",
  "offspring": [],
  "name": "Function.id_def"},
 {"type": "Inhabited Substring",
  "offspring": ["Substring.mk"],
  "name": "instInhabitedSubstring"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → [inst : CoeTail β δ] → [inst : CoeTC α β] → CoeHTCT α δ",
  "offspring": ["CoeHTCT.mk", "CoeTail.coe", "CoeTC.coe"],
  "name": "coeOfTCOfTail"},
 {"type": "{ε σ : Type} → MonadLift (ST σ) (EST ε σ)",
  "offspring": ["MonadLift.mk", "EStateM.Result.ok"],
  "name": "instMonadLiftSTEST"},
 {"type": "Tactic.NormCast.CoeFnType → ℕ",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.toCtorIdx"},
 {"type": "{α : Type u_1} → Array α → ℕ → Array α",
  "offspring": ["Array.eraseIdxAux"],
  "name": "Array.eraseIdx"},
 {"type": "LT USize",
  "offspring": ["LT.mk", "USize.lt"],
  "name": "instLTUSize"},
 {"type": "Type", "offspring": [], "name": "UInt32"},
 {"type": "Sat.Literal → Sat.Literal",
  "offspring": ["Sat.Literal.neg", "Sat.Literal.pos"],
  "name": "Sat.Literal.negate"},
 {"type": "{α : Type u} → Append (List α)",
  "offspring": ["Append.mk", "List.append"],
  "name": "List.instAppendList"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HShiftLeft α β γ",
  "offspring": [],
  "name": "HShiftLeft.mk"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)], AddMonoidWithOne.natCast 0 = 0",
  "offspring": ["AddMonoidWithOne.natCast_zero"],
  "name": "instCommSemiringFin.proof_5"},
 {"type":
  "∀ {α : Type u_1} (as : Array α), WellFounded (invImage (fun a => Array.size as - a) instWellFoundedRelation).1",
  "offspring": [],
  "name": "Array.isPrefixOfAux.proof_1"},
 {"type": "∀ {n m : ℕ}, n ≤ m → Nat.pred n ≤ Nat.pred m",
  "offspring": ["Nat.le.refl", "Nat.le_trans", "Nat.le_succ"],
  "name": "Nat.pred_le_pred"},
 {"type": "∀ {a b : UInt8}, a = b → a.val = b.val",
  "offspring": [],
  "name": "UInt8.val_eq_of_eq"},
 {"type": "∀ {a b : Prop}, a ∧ b ↔ b ∧ a",
  "offspring": ["And.symm"],
  "name": "And.comm"},
 {"type":
  "∀ {α : Sort v} {β : Sort u} {a₁ a₂ : α} {b₁ b₂ : α → β},\n  a₁ = a₂ →\n    (∀ (x : α), b₁ x = b₂ x) →\n      (let x := a₁;\n        b₁ x) =\n        let x := a₂;\n        b₂ x",
  "offspring": [],
  "name": "let_eq"},
 {"type":
  "∀ {α : Type u} {motive : (a : α) → (a_1 : List α) → List.Mem a a_1 → Prop} {a : α} {a_1 : List α} (x : List.Mem a a_1),\n  (∀ (a : α) (a_2 : List α) (x : List.Mem a a_2), List.Mem.below x → motive a a_2 x) → motive a a_1 x",
  "offspring": ["List.Mem.below.head", "List.Mem.below.tail"],
  "name": "List.Mem.brecOn"},
 {"type": "Lean.Expr → ℕ → Tactic.Ring.HornerExpr",
  "offspring": [],
  "name": "Tactic.Ring.HornerExpr.const"},
 {"type":
  "∀ {n : ℕ} (m : UFModel n) (k : ℕ),\n  n ≤ k →\n    ∀ (i : Fin k)\n      (a :\n        ↑((fun i =>\n                if h : ↑i < n then\n                  let x := UFModel.parent m { val := ↑i, isLt := h };\n                  match x with\n                  | { val := a, isLt := h' } => { val := a, isLt := (_ : a < k) }\n                else i)\n              i) ≠\n          ↑i),\n      (fun i => if h : i < n then UFModel.rank m i else 0) ↑i <\n        (fun i => if h : i < n then UFModel.rank m i else 0)\n          ↑((fun i =>\n                if h : ↑i < n then\n                  let x := UFModel.parent m { val := ↑i, isLt := h };\n                  match x with\n                  | { val := a, isLt := h' } => { val := a, isLt := (_ : a < k) }\n                else i)\n              i)",
  "offspring":
  ["ne_eq",
   "dif_pos",
   "dite_congr",
   "Fin.isLt",
   "dite_true",
   "UFModel.rank_lt",
   "dif_neg",
   "sorryAx"],
  "name": "UFModel.push.proof_2"},
 {"type": "∀ {a b : ℤ}, a ≤ 0 → b ≤ 0 → 0 ≤ a * b",
  "offspring": [],
  "name": "Int.mul_nonneg_of_nonpos_of_nonpos"},
 {"type": "Type u → Type u", "offspring": [], "name": "MulOneClass"},
 {"type": "USize.size = 4294967296 ∨ USize.size = 18446744073709551616",
  "offspring": [],
  "name": "usize_size_eq"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), List.erase (a :: l) a = l",
  "offspring": ["List.erase_cons", "List.erase", "ite_true"],
  "name": "List.erase_cons_head"},
 {"type": "{α : Type u} → (α → Prop) → Set α",
  "offspring": [],
  "name": "setOf"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α), a :: as = [] → List.noConfusionType False (a :: as) []",
  "offspring": [],
  "name": "List.hasDecEq.proof_2"},
 {"type": "{α : Type u} → Array α → Option α",
  "offspring": ["Array.get?"],
  "name": "Array.back?"},
 {"type": "∀ {a b : ℕ}, a < b → a % b = a",
  "offspring": [],
  "name": "Nat.mod_eq_of_lt"},
 {"type": "∀ (n : ℕ), n - 1 = Nat.pred n",
  "offspring": [],
  "name": "Nat.sub_one"},
 {"type": "Sort u → Sort (max 1 u)", "offspring": [], "name": "SizeOf"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk", "HDiv.hDiv"],
  "name": "USize.div"},
 {"type":
  "{ε : Type u} → {α : Type v} → Sort u_1 → Except ε α → Except ε α → Sort u_1",
  "offspring": [],
  "name": "Except.noConfusionType"},
 {"type": "Type",
  "offspring": ["Prod"],
  "name": "Mathlib.Util.LibraryNote.LibraryNoteEntry"},
 {"type":
  "Trans (fun a a_1 => a ≤ a_1) (fun a a_1 => a ≤ a_1) fun a a_1 => a ≤ a_1",
  "offspring": ["Trans.mk", "Nat.instTransNatLeInstLENat.proof_1"],
  "name": "Nat.instTransNatLeInstLENat"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {as bs : List α}, as ⊆ bs → List.card as ≤ List.card bs",
  "offspring": ["List.card_nil", "Nat.zero_le"],
  "name": "List.card_subset_le"},
 {"type":
  "∀ {α : Type u_1} {x : Option (Option α)}, ¬Option.join x = none ↔ ∃ z, x = some (some z)",
  "offspring":
  ["Option.bind_eq_none",
   "Option.mem_def",
   "id_eq",
   "not_forall",
   "not_not",
   "exists_prop",
   "exists_eq_right"],
  "name": "Option.join_ne_none'"},
 {"type": "{α : Type} → Lean.Elab.Command.CommandElabM α → Lean.AttrM α",
  "offspring": ["StateRefT'.run", "Inhabited.default", "modify", "Array.find?"],
  "name": "Mathlib.Tactic.Ext.liftCommandElabM"},
 {"type": "UInt32 → ℕ → UInt32",
  "offspring": ["UInt32.mk"],
  "name": "UInt32.modn"},
 {"type":
  "∀ {a : Nat.Linear.Expr} {k : ℕ} {a_1 : Nat.Linear.Expr} {k_1 : ℕ},\n  Nat.Linear.Expr.mulR a k = Nat.Linear.Expr.mulR a_1 k_1 → a = a_1 ∧ k = k_1",
  "offspring": [],
  "name": "Nat.Linear.Expr.mulR.inj"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (i : Fin (Array.size self.arr)),\n  (Array.get self.arr i).parent < UnionFind.size self",
  "offspring":
  ["UFModel.Models.parent_eq'",
   "Fin.isLt",
   "UFModel.parent",
   "UnionFind.model'"],
  "name": "UnionFind.parent_lt"},
 {"type": "∀ (a : UInt8), a * 1 = a",
  "offspring":
  ["UInt8.one_def", "UInt8.mul_def", "UInt8.mk", "mul_one", "UInt8.mk_val_eq"],
  "name": "UInt8.instSemiringUInt8.proof_14"},
 {"type": "Type",
  "offspring": ["List", "System.FilePath"],
  "name": "System.SearchPath"},
 {"type": "AddCommSemigroup UInt32",
  "offspring":
  ["AddCommSemigroup.mk",
   "UInt32.instAddSemigroupUInt32",
   "UInt32.instAddCommSemigroupUInt32.proof_1"],
  "name": "UInt32.instAddCommSemigroupUInt32"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → ({α : Type u} → ({β : Type u} → m β → m β) → n α → n α) → MonadFunctorT m n",
  "offspring": [],
  "name": "MonadFunctorT.mk"},
 {"type": "UInt64 → UInt64 → Prop", "offspring": [], "name": "UInt64.lt"},
 {"type":
  "{stream : Type u} → {value : outParam (Type v)} → (stream → Option (value × stream)) → Stream stream value",
  "offspring": [],
  "name": "Stream.mk"},
 {"type":
  "{α : Type u} →\n  {m : Type → Type w} →\n    [inst : Monad m] → (α → m Bool) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m Bool",
  "offspring": ["Array.anyM", "not"],
  "name": "Array.allM"},
 {"type": "Tactic.Ring.State → ℕ",
  "offspring": [],
  "name": "Tactic.Ring.State.numAtoms"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a b : β), ¬a = b → Sum.inr a = Sum.inr b → False",
  "offspring": [],
  "name": "instDecidableEqSum.proof_4"},
 {"type": "Float → Float", "offspring": [], "name": "Float.acos"},
 {"type": "Lean.Parsec ℤ",
  "offspring": ["Unit", "Mathlib.Tactic.Sat.Parser.parseNat"],
  "name": "Mathlib.Tactic.Sat.Parser.parseInt"},
 {"type":
  "∀ (float : Type) (val : float) (lt le : float → float → Prop) (decLt : DecidableRel lt) (decLe : DecidableRel le)\n  (float_1 : Type) (val_1 : float_1) (lt_1 le_1 : float_1 → float_1 → Prop) (decLt_1 : DecidableRel lt_1)\n  (decLe_1 : DecidableRel le_1),\n  ({ float := float, val := val, lt := lt, le := le, decLt := decLt, decLe := decLe } =\n      { float := float_1, val := val_1, lt := lt_1, le := le_1, decLt := decLt_1, decLe := decLe_1 }) =\n    (float = float_1 ∧ HEq val val_1 ∧ HEq lt lt_1 ∧ HEq le le_1 ∧ HEq decLt decLt_1 ∧ HEq decLe decLe_1)",
  "offspring": ["FloatSpec", "FloatSpec.mk", "DecidableRel"],
  "name": "FloatSpec.mk.injEq"},
 {"type":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] (a : α), (a == a) = true",
  "offspring": ["LawfulBEq.rfl"],
  "name": "beq_self_eq_true"},
 {"type": "ℤ → ℤ → ℤ", "offspring": ["HDiv.hDiv"], "name": "Int.fdiv"},
 {"type": "Type u → Type v → Type (max u v)",
  "offspring": [],
  "name": "Except"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_++_»"},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → {a : α} → Sort u_1 → Acc r a → Acc r a → Sort u_1",
  "offspring": [],
  "name": "Acc.noConfusionType"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_::_»"},
 {"type":
  "∀ {α : Sort u} (down down_1 : α), ({ down := down } = { down := down_1 }) = (down = down_1)",
  "offspring": ["plift.up"],
  "name": "plift.up.injEq"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop}, (ExistsUnique fun x => p x) → ∃ x, p x",
  "offspring": ["Exists.elim"],
  "name": "exists_of_exists_unique"},
 {"type": "Lean.Parsec ℕ",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Parser.parseNat"},
 {"type": "∀ (x : ℕ) {y k : ℕ}, k ≤ y → (x + k ≤ y ↔ x ≤ y - k)",
  "offspring": ["Nat.add_sub_cancel", "Nat.sub_le_sub_right_iff", "Iff.rfl"],
  "name": "Nat.add_le_to_le_sub"},
 {"type": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "offspring": [],
  "name": "PartialOrder.toPreorder"},
 {"type": "List Float → FloatArray → FloatArray",
  "offspring": ["Float", "FloatArray.push"],
  "name": "List.toFloatArray.loop"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α ε β : Type u_1} [inst : Monad m] (x : m α) (f : α → ExceptCpsT ε m β),\n  ExceptCpsT.run (ExceptCpsT.lift x >>= f) = do\n    let a ← x\n    ExceptCpsT.run (f a)",
  "offspring": [],
  "name": "ExceptCpsT.run_bind_lift"},
 {"type":
  "∀ {ε : Type u} {α : Type v} {a a_1 : ε}, Except.error a = Except.error a_1 → a = a_1",
  "offspring": [],
  "name": "Except.error.inj"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HShiftLeft α β γ → HShiftLeft α β γ → Sort u_1",
  "offspring": [],
  "name": "HShiftLeft.noConfusionType"},
 {"type": "∀ {a b : Prop}, a ∧ a ∧ b ↔ a ∧ b",
  "offspring": [],
  "name": "and_self_left"},
 {"type": "ℕ → Nat.Linear.PolyCnstr → Nat.Linear.PolyCnstr",
  "offspring":
  ["Nat.Linear.PolyCnstr.mk",
   "Nat.Linear.PolyCnstr.eq",
   "Nat.Linear.Poly.mul",
   "Nat.Linear.PolyCnstr.lhs",
   "Nat.Linear.PolyCnstr.rhs"],
  "name": "Nat.Linear.PolyCnstr.mul"},
 {"type":
  "{m : Type → Type u} → [inst : Monad m] → {α : Type v} → (α → m Bool) → List α → m Bool",
  "offspring": [],
  "name": "List.allM"},
 {"type":
  "∀ {α : Type u} {b : α} {bs : List α} (as : List α), b ∈ bs → b ∈ as ++ bs",
  "offspring": ["List.nil_append", "List.Mem.tail"],
  "name": "List.mem_append_of_mem_right"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (a : α), List.map f [a] = [f a]",
  "offspring": [],
  "name": "List.map_singleton"},
 {"type":
  "∀ {α : Sort u_1} {s : Setoid α} (a b : α), Subsingleton (Decidable (Quotient.mk s a = Quotient.mk s b))",
  "offspring": ["instSubsingletonDecidable"],
  "name": "instDecidableEqQuotient.proof_1"},
 {"type": "∀ {p : Prop} (d : Decidable p), p → toBoolUsing d = true",
  "offspring": ["decide_eq_true"],
  "name": "toBoolUsing_eq_true"},
 {"type": "{α : Type u} → [inst : LT α] → List α → List α → Prop",
  "offspring": [],
  "name": "List.le"},
 {"type": "DecidableEq UInt32",
  "offspring": ["UInt32.decEq"],
  "name": "instDecidableEqUInt32"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_>=_»"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → α → OptionT m α",
  "offspring": ["OptionT.mk"],
  "name": "OptionT.pure"},
 {"type": "{n : ℕ} → Fin n → Fin n → Option (Fin n)",
  "offspring": ["Fin.underflowingSub"],
  "name": "Fin.checkedSub"},
 {"type": "LE UInt16",
  "offspring": ["LE.mk", "UInt16.le"],
  "name": "instLEUInt16"},
 {"type": "∀ (a : UInt16), a * 0 = 0",
  "offspring":
  ["UInt16.zero_def", "UInt16.mul_def", "UInt16.mk", "MonoidWithZero.mul_zero"],
  "name": "UInt16.instSemiringUInt16.proof_10"},
 {"type": "∀ {α : Sort u_1} (x y : α), x = y ∨ x ≠ y",
  "offspring": ["em"],
  "name": "eq_or_ne"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_/\\_»"},
 {"type": "∀ (k : ℕ) {m n : ℕ}, Nat.coprime m n → Nat.coprime (Nat.gcd k m) n",
  "offspring": ["Nat.coprime.coprime_dvd_left", "Nat.gcd_dvd_right"],
  "name": "Nat.coprime.gcd_left"},
 {"type": "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "offspring":
  ["MulZeroOneClass.mk", "MonoidWithZero.zero_mul", "MonoidWithZero.mul_zero"],
  "name": "MonoidWithZero.toMulZeroOneClass"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β ε : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (f : α → β)\n  (x : ExceptT ε m α), x >>= pure ∘ f = f <$> x",
  "offspring": [],
  "name": "ExceptT.bind_pure_comp"},
 {"type": "{α : Type u} → {n : ℕ} → α → OfNat α n",
  "offspring": [],
  "name": "OfNat.mk"},
 {"type": "∀ {a b c : ℤ}, a - b ≤ c → a ≤ b + c",
  "offspring": [],
  "name": "Int.le_add_of_sub_left_le"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b → a = b ∨ b < a",
  "offspring": ["lt_of_not_ge", "lt_of_le_of_ne"],
  "name": "eq_or_lt_of_not_lt"},
 {"type":
  "∀ (test : Lean.Name → Lean.MetaM (Option Lean.MessageData)) (noErrorsFound errorsFound : Lean.MessageData)\n  (isFast : Bool),\n  sizeOf { test := test, noErrorsFound := noErrorsFound, errorsFound := errorsFound, isFast := isFast } =\n    1 + sizeOf noErrorsFound + sizeOf errorsFound + sizeOf isFast",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.mk.sizeOf_spec"},
 {"type": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "offspring": [],
  "name": "MulOneClass.toMul"},
 {"type":
  "∀ (stop : ℕ), WellFounded (invImage (fun a => stop - a) instWellFoundedRelation).1",
  "offspring": [],
  "name": "Array.anyM.loop.proof_1"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {r : α → α → Prop} → Quot r → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → β",
  "offspring": ["Quot.lift"],
  "name": "Quot.liftOn"},
 {"type": "(fun n => { val := ↑n }) 0 = (fun n => { val := ↑n }) 0",
  "offspring": [],
  "name": "UInt32.instSemiringUInt32.proof_11"},
 {"type":
  "∀ {α : Type u_1} (x y : α) {l₁ l₂ : List α}, l₁ ~ l₂ → y :: x :: l₁ ~ x :: y :: l₂",
  "offspring": [],
  "name": "List.Perm.swap'"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β}, Function.injective f → Function.is_partial_inv f (Function.partial_inv f)",
  "offspring": [],
  "name": "Function.partial_inv_of_injective"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [inst : Monad m] → MonadStateOf σ (StateT σ m)",
  "offspring": ["MonadStateOf.mk"],
  "name": "instMonadStateOfStateT"},
 {"type": "∀ {a b : ℤ}, a < b → a ≠ b",
  "offspring": ["Int.lt_irrefl"],
  "name": "Int.ne_of_lt"},
 {"type": "(a b : UInt64) → Decidable (a ≤ b)",
  "offspring": [],
  "name": "UInt64.decLe"},
 {"type": "ℤ → ℤ → ℤ", "offspring": [], "name": "Int.rem"},
 {"type": "∀ {n m : ℕ}, n ≤ m → n < Nat.succ m",
  "offspring": ["Nat.succ_le_succ"],
  "name": "Nat.lt_succ_of_le"},
 {"type": "(ε : Type u_1) → MonadExceptOf ε (Except ε)",
  "offspring": ["MonadExceptOf.mk", "Except.error", "Except.tryCatch"],
  "name": "instMonadExceptOfExcept"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → (Unit → β) → γ) → HOrElse α β γ",
  "offspring": [],
  "name": "HOrElse.mk"},
 {"type": "∀ {a : ℤ}, a < 0 → 0 < -a",
  "offspring": [],
  "name": "Int.neg_pos_of_neg"},
 {"type": "∀ {a : Prop} (h₁ h₂ : a), h₁ = h₂",
  "offspring": [],
  "name": "proofIrrel"},
 {"type": "∀ {α : Sort u} {a : α}, a ≠ a → False",
  "offspring": ["Ne.irrefl"],
  "name": "false_of_ne"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → BinaryHeap α lt",
  "offspring": ["Subtype.val", "BinaryHeap.popMaxAux"],
  "name": "BinaryHeap.popMax"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.termFrom_lrat__"},
 {"type":
  "∀ {A : Type u} [self : SubNegMonoid A] (a : A), SubNegMonoid.gsmul 0 a = 0",
  "offspring": [],
  "name": "SubNegMonoid.gsmul_zero'"},
 {"type":
  "∀ {α : Sort u} {C : α → Sort v} {r : α → α → Prop} (hwf : WellFounded r) (F : (x : α) → ((y : α) → r y x → C y) → C x)\n  (x : α), WellFounded.fix hwf F x = F x fun y h => WellFounded.fix hwf F y",
  "offspring": ["WellFounded.fixFEq"],
  "name": "WellFounded.fix_eq"},
 {"type": "{α : Type u_1} → List α → ℕ → α → α",
  "offspring": ["Option.getD", "List.get?"],
  "name": "List.getD"},
 {"type":
  "∀ (toLinter : Mathlib.Tactic.Lint.Linter) (declName : Lean.Name),\n  sizeOf { toLinter := toLinter, declName := declName } = 1 + sizeOf toLinter + sizeOf declName",
  "offspring": ["Mathlib.Tactic.Lint.Linter", "instSizeOfName"],
  "name": "Mathlib.Tactic.Lint.NamedLinter.mk.sizeOf_spec"},
 {"type": "{m : Type u → Type v} → [self : Monad m] → Bind m",
  "offspring": [],
  "name": "Monad.toBind"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_/_»"},
 {"type":
  "{α : Type u} →\n  [toPartialOrder : PartialOrder α] →\n    (∀ (a b : α), a ≤ b ∨ b ≤ a) →\n      (DecidableRel fun a a_1 => a ≤ a_1) → DecidableEq α → (DecidableRel fun a a_1 => a < a_1) → LinearOrder α",
  "offspring": [],
  "name": "LinearOrder.mk"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (l₁ : List α) (l₂ : List β),\n  List.length (List.map₂ f l₁ l₂) = min (List.length l₁) (List.length l₂)",
  "offspring":
  ["List.length_nil",
   "min",
   "min_self",
   "Nat.instLinearOrderNat",
   "List.length_cons",
   "Nat.zero_min",
   "Nat.min_zero",
   "List.map₂",
   "Nat.min_succ_succ"],
  "name": "List.length_map₂"},
 {"type":
  "{q p : Prop} → {α : Sort u_1} → [inst : Decidable q] → p ∨ q → (p → α) → (q → α) → α",
  "offspring": ["Or.resolve_right"],
  "name": "Or.by_cases'"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<||>_»"},
 {"type": "∀ {R : Type u} [self : Semiring R] (a : R), 1 * a = a",
  "offspring": [],
  "name": "Semiring.one_mul"},
 {"type": "∀ {α : Sort u_1} (a : α), id a = a",
  "offspring": [],
  "name": "id_eq"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a : α) (b : β) (a' : α) (b' : β), a = a' → b = b' → (a, b) = (a', b')",
  "offspring": [],
  "name": "instDecidableEqProd.proof_1"},
 {"type": "∀ {α : Type u_1} (s t : List α), s ≠ [] → s ++ t ≠ []",
  "offspring":
  ["implies_congr_ctx",
   "ne_eq",
   "List.append_eq_nil",
   "false_and",
   "implies_true"],
  "name": "List.append_ne_nil_of_ne_nil_left"},
 {"type": "{α : Type u} → (α → α) → Neg α", "offspring": [], "name": "Neg.mk"},
 {"type": "{α : Type u_1} → Subset (List α)",
  "offspring": ["Subset.mk", "List.subset"],
  "name": "List.instSubsetList"},
 {"type": "∀ {m n : ℕ}, Int.subNatNat m (m + n + 1) = -[1+ n]",
  "offspring": [],
  "name": "Int.subNatNat_add_right"},
 {"type": "∀ (a b : UInt8), a * b = { val := a.val * b.val }",
  "offspring": [],
  "name": "UInt8.mul_def"},
 {"type":
  "{δ : outParam (Type u)} → {σ : Type u} → Sort u_1 → EStateM.Backtrackable δ σ → EStateM.Backtrackable δ σ → Sort u_1",
  "offspring": [],
  "name": "EStateM.Backtrackable.noConfusionType"},
 {"type": "ℕ → Lean.Level", "offspring": [], "name": "Nat.toLevel"},
 {"type": "∀ (a : UInt16), { val := Ring.gsmul 0 a.val } = { val := 0.1 }",
  "offspring": ["SubNegMonoid.gsmul_zero'"],
  "name": "UInt16.instRingUInt16.proof_3"},
 {"type": "∀ (n : ℕ), n % 2 = 0 ∨ n % 2 = 1",
  "offspring": ["Nat.not_lt_zero", "Nat.lt_of_succ_lt_succ"],
  "name": "Nat.mod_two_eq_zero_or_one"},
 {"type": "Sub UInt8",
  "offspring": ["Sub.mk", "UInt8.sub"],
  "name": "instSubUInt8"},
 {"type":
  "∀ {n : ℕ} {parent : Fin n → Fin n} {rank : ℕ → ℕ}\n  {rank_lt : ∀ (i : Fin n), ↑(parent i) ≠ ↑i → rank ↑i < rank ↑(parent i)} {parent_1 : Fin n → Fin n} {rank_1 : ℕ → ℕ}\n  {rank_lt_1 : ∀ (i : Fin n), ↑(parent_1 i) ≠ ↑i → rank_1 ↑i < rank_1 ↑(parent_1 i)},\n  { parent := parent, rank := rank, rank_lt := rank_lt } =\n      { parent := parent_1, rank := rank_1, rank_lt := rank_lt_1 } →\n    parent = parent_1 ∧ rank = rank_1",
  "offspring": [],
  "name": "UFModel.mk.inj"},
 {"type": "∀ {G : Type u} [inst : Group G] (a : G), a⁻¹⁻¹ = a",
  "offspring": ["inv_eq_of_mul_eq_one", "mul_left_inv"],
  "name": "inv_inv"},
 {"type":
  "{α : Sort u} →\n  {β : α → Sort v} → WellFoundedRelation α → ((a : α) → WellFoundedRelation (β a)) → WellFoundedRelation (PSigma β)",
  "offspring":
  ["WellFoundedRelation.mk",
   "PSigma.Lex",
   "WellFoundedRelation.rel",
   "PSigma.lex.proof_1"],
  "name": "PSigma.lex"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, p = q ↔ p.fst = q.fst ∧ p.snd = q.snd",
  "offspring": ["Prod.mk.eta", "Prod.mk.inj_iff", "Iff.rfl"],
  "name": "Prod.ext_iff"},
 {"type": "Substring → Char → Bool",
  "offspring": ["Substring.any"],
  "name": "Substring.contains"},
 {"type": "∀ (m n : ℕ), Nat.gcd n (n * m) = n",
  "offspring": ["Nat.gcd", "Nat.gcd_comm", "Nat.gcd_mul_right_left"],
  "name": "Nat.gcd_mul_right_right"},
 {"type": "{α : Type u_1} → List α → Option α",
  "offspring": [],
  "name": "List.head?"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "offspring": [],
  "name": "congrArg"},
 {"type": "{α : Sort u_1} → {β : Type u_2} → (α → β → α) → α → List β → α",
  "offspring": [],
  "name": "List.foldl"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {s₁ : Setoid α} {s₂ : Setoid β} {motive : Quotient s₁ → Quotient s₂ → Sort u_1}\n  [s : ∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))] (q₂ : Quotient s₂) (a : α),\n  Subsingleton (motive (Quot.mk Setoid.r a) q₂)",
  "offspring": ["Quot.recOnSubsingleton"],
  "name": "Quotient.recOnSubsingleton₂.proof_1"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticMatch_target_"},
 {"type": "{R : Type u} → [self : Ring R] → Neg R",
  "offspring": [],
  "name": "Ring.toNeg"},
 {"type": "ℕ → Prop", "offspring": [], "name": "Nat.AtLeastTwo"},
 {"type":
  "∀ (float : Type) (val : float) (lt le : float → float → Prop) (decLt : DecidableRel lt) (decLe : DecidableRel le),\n  sizeOf { float := float, val := val, lt := lt, le := le, decLt := decLt, decLe := decLe } =\n    1 + sizeOf float + sizeOf val",
  "offspring": [],
  "name": "FloatSpec.mk.sizeOf_spec"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → DecidableEq (Option α)",
  "offspring": [],
  "name": "instDecidableEqOption"},
 {"type":
  "∀ {ε σ α : Type u} (a : α) (a_1 : σ) (a_2 : α) (a_3 : σ),\n  (EStateM.Result.ok a a_1 = EStateM.Result.ok a_2 a_3) = (a = a_2 ∧ a_1 = a_3)",
  "offspring": ["EStateM.Result.ok"],
  "name": "EStateM.Result.ok.injEq"},
 {"type": "∀ {m n d : ℕ}, 1 < d → d ∣ m → d ∣ n → ¬Nat.coprime m n",
  "offspring": [],
  "name": "Nat.not_coprime_of_dvd_of_dvd"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p : α → β → Prop}, (∀ (x : α × β), p x.fst x.snd) ↔ ∀ (a : α) (b : β), p a b",
  "offspring": ["Prod.forall"],
  "name": "Prod.forall'"},
 {"type": "∀ {α : Type u_1}, List.join [] = []",
  "offspring": [],
  "name": "List.join_nil"},
 {"type":
  "∀ (a b : ℕ), -[1+ a] = Int.ofNat b → Int.noConfusionType False -[1+ a] (Int.ofNat b)",
  "offspring": [],
  "name": "Int.decEq.proof_6"},
 {"type":
  "∀ {m : Type u → Type u_1} {α : Type u} [inst : Monad m] [inst_1 : LawfulMonad m] (x : m α),\n  ExceptCpsT.runCatch (ExceptCpsT.lift x) = x",
  "offspring": ["bind_pure"],
  "name": "ExceptCpsT.runCatch_lift"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε α : Type u_1} [inst : Monad m] {x y : ExceptT ε m α},\n  ExceptT.run x = ExceptT.run y → x = y",
  "offspring": [],
  "name": "ExceptT.ext"},
 {"type": "{α : Type u_1} → [inst : Repr α] → α → Lean.Format",
  "offspring": [],
  "name": "reprArg"},
 {"type": "AddCommSemigroup UInt64",
  "offspring":
  ["AddCommSemigroup.mk",
   "UInt64.instAddSemigroupUInt64",
   "UInt64.instAddCommSemigroupUInt64.proof_1"],
  "name": "UInt64.instAddCommSemigroupUInt64"},
 {"type": "∀ {a : ℤ}, Int.sign a = -1 → a < 0",
  "offspring": ["Int.neg_succ_lt_zero"],
  "name": "Int.neg_of_sign_eq_neg_one"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → (List α → List β) → List (List β) → List (List β)",
  "offspring": [],
  "name": "List.sublists'Aux"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) → ∀ (x : α), ¬p x",
  "offspring": [],
  "name": "forall_not_of_not_exists"},
 {"type": "∀ {k x y : ℕ}, 0 < k → (x / k < y ↔ x < y * k)",
  "offspring":
  ["not_le", "Nat.instLinearOrderNat", "not_congr", "Nat.le_div_iff_mul_le"],
  "name": "Nat.div_lt_iff_lt_mul"},
 {"type": "∀ {α : Type u} {p : α → Prop}, { x // p x } → ∃ x, p x",
  "offspring": ["Subtype.existsOfSubtype.proof_1"],
  "name": "Subtype.existsOfSubtype"},
 {"type": "(α : Sort u) → outParam (α → Sort v) → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "CoeFun"},
 {"type":
  "{A : Type u} → {inst : Add A} → Sort u_1 → IsAddRightCancel A → IsAddRightCancel A → Sort u_1",
  "offspring": [],
  "name": "IsAddRightCancel.noConfusionType"},
 {"type":
  "{motive : Nat.Linear.Expr → Sort u} → Nat.Linear.Expr → Sort (max 1 u)",
  "offspring": ["PProd"],
  "name": "Nat.Linear.Expr.below"},
 {"type": "(a b : Float) → Decidable (a ≤ b)",
  "offspring": ["Float.decLe"],
  "name": "floatDecLe"},
 {"type": "∀ {a b : ℤ}, a < b → -b < -a",
  "offspring": [],
  "name": "Int.neg_lt_neg"},
 {"type": "∀ {α : Type u_1} (a : α), some a = some a",
  "offspring": [],
  "name": "Option.pbind.proof_1"},
 {"type": "∀ (n : ℕ), n < Nat.succ n",
  "offspring": ["Nat.lt.base.proof_1"],
  "name": "Nat.lt.base"},
 {"type": "Lean.ParserDescr",
  "offspring":
  ["Mathlib.ExtendedBinder.extBinder",
   "Mathlib.ExtendedBinder.extBinderCollection"],
  "name": "Mathlib.ExtendedBinder.extBinders"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop}, WellFounded r → ∀ (a : α), Acc r a",
  "offspring": ["WellFounded.apply.proof_1"],
  "name": "WellFounded.apply"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {fst : α} {snd : β} {fst_1 : α} {snd_1 : β},\n  { fst := fst, snd := snd } = { fst := fst_1, snd := snd_1 } → fst = fst_1 ∧ snd = snd_1",
  "offspring": [],
  "name": "PProd.mk.inj"},
 {"type": "{α : Type u_1} → {β : Type u_2} → Function.HasUncurry (α → β) α β",
  "offspring": ["Function.HasUncurry.mk"],
  "name": "Function.HasUncurry_base"},
 {"type": "∀ (v : ℕ), sizeOf (Nat.Linear.Expr.num v) = 1 + sizeOf v",
  "offspring": ["instSizeOfNat"],
  "name": "Nat.Linear.Expr.num.sizeOf_spec"},
 {"type": "Sat.Valuation → Prop → List Prop → ℕ → Prop",
  "offspring": [],
  "name": "Sat.Valuation.implies"},
 {"type": "Ord UInt8",
  "offspring": ["Ord.mk", "compareOfLessAndEq", "instLTUInt8"],
  "name": "instOrdUInt8"},
 {"type": "∀ (a : Prop) {b : Prop}, ¬b → ¬(a ∧ b)",
  "offspring": ["mt"],
  "name": "not_and_of_not_right"},
 {"type": "{α : Type u_1} → [inst : Mod α] → HMod α α α",
  "offspring": ["HMod.mk", "Mod.mod"],
  "name": "instHMod"},
 {"type": "∀ {n : ℕ}, n ≠ 0 → 0 < n",
  "offspring": ["Or.resolve_left", "Nat.eq_zero_or_pos"],
  "name": "Nat.pos_of_ne_zero"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk", "HShiftRight.hShiftRight", "UInt16.modn"],
  "name": "UInt16.shiftRight"},
 {"type": "Sort u → ByteSlice → ByteSlice → Sort u",
  "offspring": [],
  "name": "ByteSlice.noConfusionType"},
 {"type": "∀ (a : ℤ) {b : ℤ}, 0 < b → a < b + a",
  "offspring": [],
  "name": "Int.lt_add_of_pos_left"},
 {"type": "{α : Type u_1} → Thunk α → α", "offspring": [], "name": "Thunk.get"},
 {"type": "{α : Type u_1} → (as : List α) → as ≠ [] → α",
  "offspring": ["List.getLast.proof_1", "List.getLast.proof_2"],
  "name": "List.getLast"},
 {"type": "{α : Type u} → [inst : Inhabited α] → String → α",
  "offspring": [],
  "name": "panicCore"},
 {"type": "∀ {m n : ℕ}, n ∣ m → n * (m / n) = m",
  "offspring": ["Nat.zero_add", "Nat.mod_eq_zero_of_dvd", "Nat.mod_add_div"],
  "name": "Nat.mul_div_cancel'"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.tacticNorm_cast0__"},
 {"type":
  "{σ : Type u_1} → {m : Type u_1 → Type u_2} → MonadStateOf σ (StateCpsT σ m)",
  "offspring": ["MonadStateOf.mk"],
  "name": "StateCpsT.instMonadStateOfStateCpsT"},
 {"type":
  "∀ {σ β : Type u} {m : Type u → Type v} (s : σ) (k : σ → σ → m β), StateCpsT.runK get s k = k s s",
  "offspring": [],
  "name": "StateCpsT.runK_get"},
 {"type": "∀ {a : ℤ}, a < 0 → ∃ n, a = -[1+ n]",
  "offspring": ["not_lt_of_ge", "Int.ofNat_zero_le"],
  "name": "Int.eq_neg_succ_of_lt_zero"},
 {"type": "{α : Type u_1} → [inst : BEq α] → α → List α → List α → List α",
  "offspring": ["List.reverse"],
  "name": "List.eraseRepsAux"},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → {β : Sort v} → (f : α → β) → (∀ (a b : α), r a b → f a = f b) → Quot r → β",
  "offspring": [],
  "name": "Quot.lift"},
 {"type": "{A : Type u} → [self : AddCommGroup A] → AddCommMonoid A",
  "offspring": ["AddCommMonoid.mk", "AddCommGroup.add_comm"],
  "name": "AddCommGroup.toAddCommMonoid"},
 {"type": "∀ {α : Type u_1} (l : List α), List.disjoint [] l",
  "offspring": ["Not.elim", "List.not_mem_nil"],
  "name": "List.disjoint_nil_left"},
 {"type":
  "∀ {R : Type u} [self : Distrib R] (a b c : R), (a + b) * c = a * c + b * c",
  "offspring": [],
  "name": "Distrib.right_distrib"},
 {"type": "Lean.Elab.Tactic.Tactic",
  "offspring": ["Tactic.NormCast.pushCastExt"],
  "name": "Tactic.NormCast.evalPushCast"},
 {"type": "Lean.Name → Lean.MetaM Bool",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.isSimpTheorem"},
 {"type": "{α : Type u_1} → (α → α) → ℕ → List α → List α",
  "offspring": ["List.modifyNthTail", "List.modifyHead"],
  "name": "List.modifyNth"},
 {"type": "∀ (n : ℕ), n + 1 = Nat.succ n",
  "offspring": [],
  "name": "Nat.add_one"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAppend α β γ] → α → β → γ",
  "offspring": [],
  "name": "HAppend.hAppend"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["Array.append"],
  "name": "unexpandListCons"},
 {"type":
  "∀ (x : ℕ) (a : UInt32),\n  { val := Ring.gsmul -[1+ x] a.val } =\n    { val := (-(fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat (Nat.succ x)) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_neg'"],
  "name": "UInt32.instRingUInt32.proof_5"},
 {"type": "FloatArray → ℕ → Float → FloatArray",
  "offspring": ["FloatArray.mk", "Array.set!", "Float"],
  "name": "FloatArray.set!"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "Array.«term__[_:]»"},
 {"type":
  "(m : Type u_1 → Type u_2) →\n  (n : Type u_1 → Type u_3) →\n    (o : Type u_1 → Type u_4) → [inst : MonadLift n o] → [inst : MonadLiftT m n] → MonadLiftT m o",
  "offspring": ["MonadLiftT.mk", "MonadLift.monadLift", "MonadLiftT.monadLift"],
  "name": "instMonadLiftT"},
 {"type": "{α : Type u_1} → Subarray α → Array α",
  "offspring": ["Array.ofSubarray"],
  "name": "Subarray.toArray"},
 {"type": "∀ {a b : ℤ}, a < 0 → b ≤ 0 → a + b < 0",
  "offspring": ["Int.add_lt_add_of_lt_of_le", "Int.zero_add"],
  "name": "Int.add_neg_of_neg_of_nonpos"},
 {"type": "{a : Prop} → (b : Bool) → (b = true ↔ a) → Decidable a",
  "offspring": ["decidable_of_bool.proof_1", "decidable_of_bool.proof_2"],
  "name": "decidable_of_bool"},
 {"type": "ToString FloatArray",
  "offspring":
  ["ToString.mk",
   "List.toString",
   "Float",
   "instToStringFloat",
   "FloatArray.toList"],
  "name": "instToStringFloatArray"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_4} {δ : Type u_3} (f : α → γ) (g : β → δ) (p : α × β),\n  Prod.map f g p = (f p.fst, g p.snd)",
  "offspring": [],
  "name": "prod_map"},
 {"type":
  "{α : Type u} → List α → Std.PersistentArray α → Std.PersistentArray α",
  "offspring": [],
  "name": "List.toPersistentArrayAux"},
 {"type": "Div USize",
  "offspring": ["Div.mk", "USize.div"],
  "name": "instDivUSize"},
 {"type": "{α : Type u} → Sort u_1 → Subset α → Subset α → Sort u_1",
  "offspring": [],
  "name": "Subset.noConfusionType"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : ℕ) (a_1 : Fin n), -(a_1 + nsmul_rec a a_1) = -nsmul_rec (Nat.succ a) a_1",
  "offspring": ["Fin"],
  "name": "instAddGroupWithOneFin.proof_5"},
 {"type": "Sort u → UInt32 → UInt32 → Sort u",
  "offspring": [],
  "name": "UInt32.noConfusionType"},
 {"type": "(σ : Type) → Monad (ST σ)", "offspring": [], "name": "instMonadST"},
 {"type": "∀ {α : Sort u_1} {a : α}, HEq a a",
  "offspring": [],
  "name": "HEq.rfl.proof_1"},
 {"type": "∀ {R : Type u} [self : Ring R] (a : R), -a + a = 0",
  "offspring": [],
  "name": "Ring.add_left_neg"},
 {"type":
  "∀ {ε σ α : Type u} {a : α} {a_1 : σ} {a_2 : α} {a_3 : σ},\n  EStateM.Result.ok a a_1 = EStateM.Result.ok a_2 a_3 → a = a_2 ∧ a_1 = a_3",
  "offspring": [],
  "name": "EStateM.Result.ok.inj"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ), Function.uncurry f = fun p => f p.fst p.snd",
  "offspring": [],
  "name": "Function.uncurry_def"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HShiftRight α β γ] → α → β → γ",
  "offspring": [],
  "name": "HShiftRight.hShiftRight"},
 {"type": "{α : Type u_1} → List α → Array α → Array α",
  "offspring": ["Array.push"],
  "name": "List.toArrayAux"},
 {"type": "Inhabited (Fin UInt8.size)",
  "offspring": ["Fin.ofNat'", "UInt8.size_positive"],
  "name": "UInt8.instInhabitedFinSize"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : ℕ), Array.get? a i = List.get? a.data i",
  "offspring":
  ["dif_pos",
   "List.get?_eq_get",
   "dif_neg",
   "List.get?_len_le",
   "le_of_not_lt",
   "Nat.instLinearOrderNat"],
  "name": "Array.get?_eq_get?"},
 {"type": "{A : Type u} → [self : AddCommSemigroup A] → AddSemigroup A",
  "offspring": [],
  "name": "AddCommSemigroup.toAddSemigroup"},
 {"type": "Repr PUnit", "offspring": [], "name": "instReprPUnit"},
 {"type":
  "{G : Type u} → [toDivInvMonoid : DivInvMonoid G] → (∀ (a : G), a⁻¹ * a = 1) → Group G",
  "offspring": [],
  "name": "Group.mk"},
 {"type": "∀ {a b : USize}, a = b → a.val = b.val",
  "offspring": [],
  "name": "USize.val_eq_of_eq"},
 {"type":
  "{P : ℕ → Sort u} → P 0 → P 1 → ((n : ℕ) → P n → P (Nat.succ n) → P (Nat.succ (Nat.succ n))) → (a : ℕ) → P a",
  "offspring": ["PProd.snd"],
  "name": "Nat.two_step_induction"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk", "HDiv.hDiv"],
  "name": "UInt32.div"},
 {"type": "{f : Type u → Type v} → [self : Applicative f] → Pure f",
  "offspring": [],
  "name": "Applicative.toPure"},
 {"type": "(a b : USize) → Decidable (a < b)",
  "offspring": [],
  "name": "USize.decLt"},
 {"type": "ℕ → List ℕ", "offspring": [], "name": "List.iotaTR"},
 {"type":
  "∀ (n : ℕ) (a : UInt32),\n  { val := AddMonoid.nsmul (Nat.succ n) a.val } = { val := (a + (fun n a => { val := AddMonoid.nsmul n a.val }) n a).1 }",
  "offspring": ["AddMonoid.nsmul_succ'"],
  "name": "UInt32.instSemiringUInt32.proof_5"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddCommSemigroup"},
 {"type": "{α : Type u_1} → List α → ℕ",
  "offspring": [],
  "name": "List.length"},
 {"type": "{α : Type u_1} → List (List α) → List (List α)",
  "offspring": ["List.transposeAux"],
  "name": "List.transpose"},
 {"type": "ByteSlice → ℕ", "offspring": [], "name": "ByteSlice.off"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f : α → β},\n  Function.bijective f ↔ ∃ g, Function.LeftInverse g f ∧ Function.RightInverse g f",
  "offspring":
  ["Function.surj_inv",
   "Function.LeftInverse_surj_inv",
   "Function.RightInverse_surj_inv",
   "Function.LeftInverse.injective",
   "Function.RightInverse.surjective"],
  "name": "Function.bijective_iff_has_inverse"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → β → (α → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "Array.forIn"},
 {"type":
  "∀ {m : Type u → Type v} [inst : Monad m] [toLawfulApplicative : LawfulApplicative m],\n  (∀ {α β : Type u} (f : α → β) (x : m α),\n      (do\n          let a ← x\n          pure (f a)) =\n        f <$> x) →\n    (∀ {α β : Type u} (f : m (α → β)) (x : m α),\n        (do\n            let a ← f\n            a <$> x) =\n          Seq.seq f fun x_1 => x) →\n      (∀ {α β : Type u} (x : α) (f : α → m β), pure x >>= f = f x) →\n        (∀ {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ), x >>= f >>= g = x >>= fun x => f x >>= g) →\n          LawfulMonad m",
  "offspring": [],
  "name": "LawfulMonad.mk"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "«command_ClassAbbrev__:_:=__,»"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {l : List α}, a ≠ b → (a ∈ List.erase l b ↔ a ∈ l)",
  "offspring": ["List.erase_eq_erasep", "List.mem_erasep_of_neg", "Ne.symm"],
  "name": "List.mem_erase_of_ne"},
 {"type": "ℕ → ℕ → ℕ",
  "offspring": ["WellFounded.fix", "Nat.sub_lt", "Nat.lt_of_lt_of_le"],
  "name": "Nat.div"},
 {"type":
  "{α₁ α₂ α₃ α₄ α₅ α₆ β : Type u} →\n  (α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) →\n    ((α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β",
  "offspring": ["bfix6", "USize.size"],
  "name": "fixCore6"},
 {"type": "UInt16 → ℕ", "offspring": ["UInt16.size"], "name": "UInt16.toNat"},
 {"type": "∀ {a b c : Prop}, (a ↔ b) → (a ∧ c ↔ b ∧ c)",
  "offspring": ["and_congr", "Iff.rfl"],
  "name": "and_congr_left'"},
 {"type": "(α : Type u_1) → Option α",
  "offspring": ["Nonempty", "Classical.choice"],
  "name": "Option.choice"},
 {"type": "∀ {a b c : ℤ}, -c + a < b → a < b + c",
  "offspring": ["Int.lt_add_of_sub_right_lt", "Int.add_comm"],
  "name": "Int.lt_add_of_neg_add_lt_right"},
 {"type": "Float → Float", "offspring": [], "name": "Float.log10"},
 {"type": "Nonempty (Fin 1)",
  "offspring": ["instNonempty"],
  "name": "Random.randBool.proof_1"},
 {"type": "∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (p.fst, p.snd) = p",
  "offspring": [],
  "name": "Prod.mk.eta"},
 {"type": "∀ {A : Type u} [inst : AddMonoid A] (a : A), a + 0 = a",
  "offspring": ["AddMonoid.add_zero"],
  "name": "add_zero"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "offspring": ["lt_of_le_of_lt"],
  "name": "instTransLeToLELtToLT.proof_1"},
 {"type": "Sub UInt16",
  "offspring": ["Sub.mk", "UInt16.sub"],
  "name": "instSubUInt16"},
 {"type": "∀ {a b c : ℤ}, a < b → 0 < c → a * c < b * c",
  "offspring": [],
  "name": "Int.mul_lt_mul_of_pos_right"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.«tacticExt?___:_»"},
 {"type": "Nonempty (Fin UInt32.size)",
  "offspring": ["instNonempty", "UInt32.instInhabitedFinSize"],
  "name": "UInt32.instRingUInt32.proof_2"},
 {"type":
  "∀ {n val : ℕ} {isLt : val < n} {val_1 : ℕ} {isLt_1 : val_1 < n},\n  { val := val, isLt := isLt } = { val := val_1, isLt := isLt_1 } → val = val_1",
  "offspring": [],
  "name": "Fin.mk.inj"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.isUnsat (Nat.Linear.ExprCnstr.toNormPoly c) = true → Nat.Linear.ExprCnstr.denote ctx c = False",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.eq_false_of_isUnsat"},
 {"type":
  "{α : Type u} →\n  {inst : LT α} → {motive : (a a_1 : List α) → List.lt a a_1 → Prop} → {a a_1 : List α} → List.lt a a_1 → Prop",
  "offspring": [],
  "name": "List.lt.below"},
 {"type": "ByteSliceT → ByteArray", "offspring": [], "name": "ByteSliceT.arr"},
 {"type": "∀ {c : Prop} (a b : Prop), (a ∨ b) ∨ c ↔ a ∨ b ∨ c",
  "offspring": ["Or.assoc"],
  "name": "or_assoc"},
 {"type":
  "∀ {α : Type u_1} [inst : SizeOf α] (as : List α) (i : Fin (List.length as)), sizeOf (List.get as i) < sizeOf as",
  "offspring":
  ["Fin.elim0",
   "List.cons.sizeOf_spec",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var",
   "Nat.add",
   "Nat.add_zero"],
  "name": "List.sizeOf_get_lt"},
 {"type": "∀ {R : Type u} [self : AddGroupWithOne R] (a : R), -a + a = 0",
  "offspring": [],
  "name": "AddGroupWithOne.add_left_neg"},
 {"type": "{α : Type u} → Array α → α → Array α",
  "offspring": ["Array.mk", "List.concat", "Array.data"],
  "name": "Array.push"},
 {"type": "{g : Type u} → [self : RandomGen g] → g → g × g",
  "offspring": [],
  "name": "RandomGen.split"},
 {"type": "{α : Type u_1} → [inst : Repr α] → α → String",
  "offspring": [],
  "name": "reprStr"},
 {"type": "∀ (a : ℕ), a ∣ 0",
  "offspring": ["Nat.mul_zero"],
  "name": "Nat.dvd_zero"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (n_1 : ℕ), AddGroupWithOne.intCast -[1+ n_1] = -AddMonoidWithOne.natCast (n_1 + 1)",
  "offspring": ["AddGroupWithOne.intCast_negSucc"],
  "name": "instCommRingFin.proof_7"},
 {"type": "xor False = id",
  "offspring": ["false_and", "and_true", "false_or", "id_eq", "implies_true"],
  "name": "xor_false"},
 {"type": "∀ (m n k : ℕ), Nat.gcd m n ∣ Nat.gcd m (k * n)",
  "offspring": ["Nat.gcd_dvd_gcd_of_dvd_right", "Nat.dvd_mul_left"],
  "name": "Nat.gcd_dvd_gcd_mul_left_right"},
 {"type": "∀ {α : Type u_1} (a : α) {l₁ l₂ : List α}, l₁ ⊆ l₂ → l₁ ⊆ a :: l₂",
  "offspring": ["List.Mem.tail"],
  "name": "List.subset_cons_of_subset"},
 {"type": "∀ (a : ℤ), 0 ≤ a → Int.ofNat (Int.natAbs a) = a",
  "offspring": ["Int.neg_succ_lt_zero", "not_lt_of_ge"],
  "name": "Int.ofNat_natAbs_eq_of_nonneg"},
 {"type": "ReprAtom ℤ",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomInt"},
 {"type": "∀ {a b c d : Prop}, (a ↔ c) → (b ↔ d) → (a ∨ b ↔ c ∨ d)",
  "offspring": ["Or.imp"],
  "name": "or_congr"},
 {"type": "∀ {a b : Prop}, (a ↔ b) ↔ (¬a ∨ b) ∧ (a ∨ ¬b)",
  "offspring": ["Decidable.iff_iff_not_or_and_or_not"],
  "name": "iff_iff_not_or_and_or_not"},
 {"type":
  "∀ {α : Sort u} {f : α → α}, Function.involutive f → Function.injective f",
  "offspring":
  ["Function.LeftInverse.injective", "Function.involutive.LeftInverse"],
  "name": "Function.involutive.injective"},
 {"type":
  "Array (Array ℤ) → Lean.Expr → Lean.Expr → Array Mathlib.Tactic.Sat.LRATStep → Lean.MetaM Lean.Expr",
  "offspring":
  ["ForIn.forIn",
   "Mathlib.Tactic.Sat.LRATStep",
   "ForInStep",
   "MProd",
   "Option",
   "Mathlib.Tactic.Sat.Clause",
   "instBEqNat",
   "instHashableNat",
   "Array.foldl",
   "Mathlib.Tactic.Sat.buildProofStep",
   "Array.isEmpty",
   "ForInStep.done",
   "Mathlib.Tactic.Sat.Clause.mk",
   "Mathlib.Tactic.Sat.buildClause",
   "MProd.snd",
   "MProd.fst",
   "Mathlib.Tactic.Sat.buildClauses",
   "Inhabited.default"],
  "name": "Mathlib.Tactic.Sat.buildProof"},
 {"type": "ShiftLeft ℕ",
  "offspring": ["ShiftLeft.mk", "Nat.shiftLeft"],
  "name": "Nat.instShiftLeftNat"},
 {"type": "{α : Type u_1} → ℕ → List α → List α × List α",
  "offspring": [],
  "name": "List.splitAt"},
 {"type": "DecidableEq Tactic.NormCast.CoeFnType",
  "offspring":
  ["Tactic.NormCast.CoeFnType.toCtorIdx",
   "Tactic.NormCast.instDecidableEqCoeFnType.proof_1",
   "Tactic.NormCast.instDecidableEqCoeFnType.proof_2"],
  "name": "Tactic.NormCast.instDecidableEqCoeFnType"},
 {"type": "{α : Type u_1} → [inst : Lean.ToFormat α] → Lean.ToFormat (List α)",
  "offspring": ["List.format"],
  "name": "instToFormatList"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : Option α} {f : α → β} {b : β}, Option.map f x = some b ↔ ∃ a, x = some a ∧ f a = b",
  "offspring":
  ["Option.map_none'",
   "eq_false'",
   "false_and",
   "exists_false",
   "Option.map_some'",
   "Option.some.injEq",
   "exists_eq_left'"],
  "name": "Option.map_eq_some'"},
 {"type": "∀ {G : Type u} [inst : Group G] {a b : G}, a * b = 1 → a⁻¹ = b",
  "offspring": ["left_inv_eq_right_inv", "inv_mul_self"],
  "name": "inv_eq_of_mul_eq_one"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«binderTerm≤_»"},
 {"type": "∀ {m k : ℕ}, Nat.gcd k m = Nat.gcd k m",
  "offspring": ["Nat.gcd"],
  "name": "Nat.prod_dvd_and_dvd_of_dvd_prod.proof_2"},
 {"type": "sizeOf false = 1",
  "offspring": [],
  "name": "Bool.false.sizeOf_spec"},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → List α → List β",
  "offspring": ["List.mapTRAux"],
  "name": "List.mapTR"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {p : β → Prop} (h : ∀ (a : α), p (f a)),\n  Function.surjective f → Function.surjective (Subtype.coind f h)",
  "offspring": ["Subtype.coe_injective", "Subtype.val"],
  "name": "Subtype.coind_surjective"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α) (i : ℕ), Nat.succ i < List.length (a :: as) → Nat.succ i ≤ List.length as",
  "offspring": ["Nat.le_of_succ_le_succ"],
  "name": "List.get.proof_1"},
 {"type":
  "∀ {α σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf σ] (a : σ), sizeOf (DoResultSBC.continue a) = 1 + sizeOf a",
  "offspring": [],
  "name": "DoResultSBC.continue.sizeOf_spec"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] {i : ℕ}, Fin.ofNat' (Nat.succ i) (_ : 0 < n) = Fin.ofNat' i (_ : 0 < n) + 1",
  "offspring":
  ["Fin.ext",
   "Fin.add_def",
   "Fin.one_val",
   "Nat.mod_add_mod",
   "Subsingleton.allEq",
   "instSubsingletonFinOfNatNatInstOfNatNat_1",
   "instSubsingletonFinOfNatNatInstOfNatNat"],
  "name": "Fin.ofNat'_succ"},
 {"type":
  "∀ {α : Type u} {β : α → Type v} [inst : SizeOf α] [inst_1 : (a : α) → SizeOf (β a)] (fst : α) (snd : β fst),\n  sizeOf { fst := fst, snd := snd } = 1 + sizeOf fst + sizeOf snd",
  "offspring": [],
  "name": "Sigma.mk.sizeOf_spec"},
 {"type": "∀ {n : ℕ} (self : Fin n), ↑self < n",
  "offspring": [],
  "name": "Fin.isLt"},
 {"type": "{gen : Type u} → [inst : RandomGen gen] → gen → Bool × gen",
  "offspring": ["Decidable.decide", "randNat"],
  "name": "randBool"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} (r : α → β → Prop) {a : α} {b c : β}, r a b → b = c → r a c",
  "offspring": [],
  "name": "instTransEq_1.proof_1"},
 {"type": "∀ {p : Prop}, p = True → p",
  "offspring": ["trivial"],
  "name": "of_eq_true"},
 {"type": "∀ {n m k : ℕ}, k ≤ m → n - k ≤ m - k → n ≤ m",
  "offspring":
  ["Nat.zero_le",
   "Nat.not_succ_le_zero",
   "Nat.succ_le_succ",
   "Nat.le_of_succ_le_succ",
   "Nat.succ_sub_succ"],
  "name": "Nat.le_of_le_of_sub_le_sub_right"},
 {"type": "{α : Type u} → [self : Mod α] → α → α → α",
  "offspring": [],
  "name": "Mod.mod"},
 {"type":
  "{α : Type} → Lean.Expr → (Mathlib.Tactic.Lint.SimpTheoremInfo → Lean.MetaM α) → Lean.MetaM (Array α)",
  "offspring":
  ["Array.mapM",
   "Mathlib.Tactic.Lint.isConditionalHyps",
   "Array.toList",
   "Mathlib.Tactic.Lint.SimpTheoremInfo.mk"],
  "name": "Mathlib.Tactic.Lint.withSimpTheoremInfos"},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      [h : ∀ (a : α), Subsingleton (motive (Quotient.mk s a))] →\n        (q : Quotient s) → ((a : α) → motive (Quotient.mk s a)) → motive q",
  "offspring": ["Quot.recOnSubsingleton"],
  "name": "Quotient.recOnSubsingleton"},
 {"type": "∀ (n : ℕ), n / 1 = n", "offspring": [], "name": "Nat.div_one"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → [self : MonadLiftT m n] → {α : Type u} → m α → n α",
  "offspring": [],
  "name": "MonadLiftT.monadLift"},
 {"type":
  "∀ (data data_1 : Array UInt8), ({ data := data } = { data := data_1 }) = (data = data_1)",
  "offspring": ["ByteArray", "ByteArray.mk"],
  "name": "ByteArray.mk.injEq"},
 {"type": "Bool → Bool → Bool", "offspring": ["or"], "name": "strictOr"},
 {"type":
  "{G₀ : Type u} → Sort u_1 → GroupWithZero G₀ → GroupWithZero G₀ → Sort u_1",
  "offspring": [],
  "name": "GroupWithZero.noConfusionType"},
 {"type": "∀ {α : Sort u_1} [h : Nonempty α] {p : Prop}, (Inhabited α → p) → p",
  "offspring": ["Nonempty.elim"],
  "name": "Nonempty.elim_to_inhabited"},
 {"type":
  "{α β : Type u_1} → {m : Type u_1 → Type u_2} → [inst : Monad m] → m (Option α) → m β → (α → m β) → m β",
  "offspring": ["Option.elim"],
  "name": "Option.melim"},
 {"type": "∀ (a : UInt32), -a = { val := -a.val }",
  "offspring": [],
  "name": "UInt32.neg_def"},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "offspring":
  ["MonadExcept.tryCatch",
   "Tactic.NormCast.numeralToCoe",
   "Tactic.NormCast.NormCastExtension.up",
   "Tactic.NormCast.normCastExt",
   "Tactic.NormCast.upwardAndElim",
   "Tactic.NormCast.NormCastExtension.squash"],
  "name": "Tactic.NormCast.derive"},
 {"type": "{α : Type u} → List α → α → List α",
  "offspring": [],
  "name": "List.concat"},
 {"type":
  "{α : Type u} → {β : Type v} → Task α → (α → Task β) → optParam Task.Priority Task.Priority.default → Task β",
  "offspring": ["Task.pure", "Task.get"],
  "name": "Task.bind"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {arr : Array α} {m : Fin (Array.size arr) → β},\n  UFModel.Agrees arr f m → ∀ (i : Fin (Array.size arr)), f (Array.get arr i) = m i",
  "offspring": ["UFModel.Agrees.get_eq"],
  "name": "UFModel.Agrees.get_eq'"},
 {"type": "{α : Type u_1} → [inst : BEq α] → BEq (Option α)",
  "offspring": ["BEq.mk"],
  "name": "instBEqOption"},
 {"type": "{α : Type u} → [self : LinearOrder α] → DecidableEq α",
  "offspring": [],
  "name": "LinearOrder.decidable_eq"},
 {"type": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "offspring": [],
  "name": "Subtype.val"},
 {"type": "{ε : Type} → MonadExceptOf ε (EIO ε)",
  "offspring": [],
  "name": "instMonadExceptOfEIO"},
 {"type":
  "Sort u → Tactic.NormCast.NormCastExtension → Tactic.NormCast.NormCastExtension → Sort u",
  "offspring": [],
  "name": "Tactic.NormCast.NormCastExtension.noConfusionType"},
 {"type": "∀ (a : ℤ), Int.sign a = -1 ↔ a < 0",
  "offspring": ["Int.neg_of_sign_eq_neg_one", "Int.sign_eq_neg_one_of_neg"],
  "name": "Int.sign_eq_neg_one_iff_neg"},
 {"type": "(G : Type u) → [inst : Mul G] → Type",
  "offspring": [],
  "name": "IsMulLeftCancel"},
 {"type": "0 = { val := 0 }", "offspring": [], "name": "UInt8.zero_def"},
 {"type": "{α : Sort u} → Sort u_1 → Inhabited α → Inhabited α → Sort u_1",
  "offspring": [],
  "name": "Inhabited.noConfusionType"},
 {"type": "∀ (n : ℕ), n = 0 ∨ n = Nat.succ (Nat.pred n)",
  "offspring": ["eq_false'", "Nat.pred_succ", "or_true"],
  "name": "Nat.eq_zero_or_eq_succ_pred"},
 {"type":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {as : List α}, a ∈ as → List.elem a as = true",
  "offspring": ["beq_self_eq_true'"],
  "name": "List.elem_eq_true_of_mem"},
 {"type": "∀ {α : Type u_1} (a : α) (l : List α), a ∈ a :: l",
  "offspring": ["List.mem_cons", "true_or"],
  "name": "List.mem_cons_self"},
 {"type":
  "{ε : Type u} →\n  {m : Type u → Type v} → [inst : Monad m] → {α β : Type u} → (α → ExceptT ε m β) → Except ε α → m (Except ε β)",
  "offspring": ["Except.error"],
  "name": "ExceptT.bindCont"},
 {"type":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α], LawfulBEq (List α)",
  "offspring":
  ["LawfulBEq.mk",
   "Bool.and_eq_true",
   "List.beq",
   "List.cons.injEq",
   "eq_of_beq",
   "beq_self_eq_true",
   "Bool.true_and"],
  "name": "List.instLawfulBEqListInstBEqList.proof_1"},
 {"type": "ℕ → ℕ → Bool", "offspring": ["Nat.ble"], "name": "Nat.blt"},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → (as bs : Array α) → Array.size as ≤ Array.size bs → ℕ → Bool",
  "offspring":
  ["WellFounded.fix",
   "Array.isPrefixOfAux.proof_1",
   "Array.isPrefixOfAux.proof_3",
   "Array.get",
   "Array.isPrefixOfAux.proof_2"],
  "name": "Array.isPrefixOfAux"},
 {"type": "∀ {n m : ℕ}, n ≤ m → m < n → False",
  "offspring": ["Nat.lt_irrefl", "Nat.lt_of_le_of_lt"],
  "name": "Nat.le_lt_antisymm"},
 {"type":
  "{G : Type u} → [inst : One G] → [inst : Mul G] → [inst : Inv G] → ℤ → G → G",
  "offspring": ["npow_rec", "Inv.inv"],
  "name": "gpow_rec"},
 {"type": "∀ (val : Fin UInt16.size), sizeOf { val := val } = 1 + sizeOf val",
  "offspring": [],
  "name": "UInt16.mk.sizeOf_spec"},
 {"type":
  "∀ {α : Type u₁} {β : Type u₂} {g : β → α} {f : α → β}, Function.RightInverse g f → f ∘ g = id",
  "offspring": [],
  "name": "Function.RightInverse.id"},
 {"type": "ShiftLeft UInt64",
  "offspring": ["ShiftLeft.mk", "UInt64.shiftLeft"],
  "name": "instShiftLeftUInt64"},
 {"type":
  "{α : Type u_1} → (a : Array α) → (n : ℕ) → Array.size a = n → Array α",
  "offspring": ["Array.toListLitAux", "Array.toArrayLit.proof_1"],
  "name": "Array.toArrayLit"},
 {"type": "∀ {n m k : ℕ}, k ≤ n → n + m - k = n - k + m",
  "offspring":
  ["Nat.sub_eq_iff_eq_add",
   "Nat.le_trans",
   "Nat.le_add_right",
   "Nat.add_right_comm",
   "Nat.sub_add_cancel"],
  "name": "Nat.sub_add_comm"},
 {"type": "{α : Type u} → {β : α → Type v} → Sigma β → α",
  "offspring": [],
  "name": "Sigma.fst"},
 {"type": "∀ (a a_1 : UInt32), a + a_1 = a_1 + a",
  "offspring": ["UInt32.add_def", "add_comm", "UInt32.mk"],
  "name": "UInt32.instSemiringUInt32.proof_6"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk", "HDiv.hDiv"],
  "name": "UInt16.div"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.«termExt_type%__»"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_⁻¹»"},
 {"type": "Div UInt16",
  "offspring": ["Div.mk", "UInt16.div"],
  "name": "instDivUInt16"},
 {"type": "{G₀ : Type u} → [self : GroupWithZero G₀] → DivInvMonoid G₀",
  "offspring": [],
  "name": "GroupWithZero.toDivInvMonoid"},
 {"type": "Type u → (Type u → Type v) → Type u → Type (max (u + 1) v)",
  "offspring": [],
  "name": "ExceptCpsT"},
 {"type": "∀ (n m : ℕ), n * m = m * n",
  "offspring": ["Nat.mul_zero", "Nat.zero_mul", "Nat.succ_mul", "Nat.mul_succ"],
  "name": "Nat.mul_comm"},
 {"type": "{α : Type u} → (α → α → Bool) → List α → List (List α)",
  "offspring": ["List.groupByAux"],
  "name": "List.groupBy"},
 {"type": "Complement USize",
  "offspring": ["Complement.mk", "USize.complement"],
  "name": "instComplementUSize"},
 {"type": "{f : Type u → Type v} → [self : Alternative f] → Applicative f",
  "offspring": [],
  "name": "Alternative.toApplicative"},
 {"type": "FloatArray → ℕ", "offspring": ["Float"], "name": "FloatArray.size"},
 {"type": "∀ (b : Bool), sizeOf b = 1",
  "offspring": [],
  "name": "Bool.sizeOf_eq_one"},
 {"type":
  "∀ (up down squash : Lean.Meta.SimpExtension),\n  sizeOf { up := up, down := down, squash := squash } = 1 + sizeOf up + sizeOf down + sizeOf squash",
  "offspring": [],
  "name": "Tactic.NormCast.NormCastExtension.mk.sizeOf_spec"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.Find.«command#find_»"},
 {"type": "∀ {a b : Prop}, a → ((a ↔ b) ↔ b)",
  "offspring": ["iff_of_true"],
  "name": "iff_true_left"},
 {"type": "Nat.Linear.Context → Nat.Linear.Expr → ℕ",
  "offspring": ["Nat.add", "PProd.snd", "Nat.Linear.Var.denote", "Nat.mul"],
  "name": "Nat.Linear.Expr.denote"},
 {"type":
  "{α : Type u_1} → {β : Sort u_2} → [inst : Subsingleton β] → Squash α → (α → β) → β",
  "offspring": ["Quot.lift", "Squash.lift.proof_1"],
  "name": "Squash.lift"},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : Lean.ToFormat α] → [inst : Lean.ToFormat β] → Lean.ToFormat (α × β)",
  "offspring": [],
  "name": "instToFormatProd"},
 {"type": "Type u → Type u", "offspring": [], "name": "Append"},
 {"type":
  "∀ (x : ℕ) (x_1 : UInt64), npow_rec (Nat.succ x) x_1 = npow_rec (Nat.succ x) x_1",
  "offspring": [],
  "name": "UInt64.instSemiringUInt64.proof_16"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b > c → a > c",
  "offspring": ["gt_of_ge_of_gt"],
  "name": "instTransGeToLEGtToLT.proof_1"},
 {"type": "Tactic.NormCast.CoeFnInfo → ℕ",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnInfo.coercee"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_-_»"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} (f : α → Option β), Option.bind none f = none",
  "offspring": [],
  "name": "Option.none_bind"},
 {"type": "DecidableEq UInt64",
  "offspring": ["UInt64.decEq"],
  "name": "instDecidableEqUInt64"},
 {"type": "{α : Type u} → (α → α → α) → Prop",
  "offspring": [],
  "name": "left_cancelative"},
 {"type": "DecidableEq Tactic.NormCast.Label",
  "offspring":
  ["Tactic.NormCast.Label.toCtorIdx",
   "Tactic.NormCast.instDecidableEqLabel.proof_1",
   "Tactic.NormCast.instDecidableEqLabel.proof_2"],
  "name": "Tactic.NormCast.instDecidableEqLabel"},
 {"type": "1 = { val := 1 }", "offspring": [], "name": "UInt32.one_def"},
 {"type": "(p : ℕ → Prop) → [inst : DecidablePred p] → (∃ n, p n) → ℕ",
  "offspring": ["Subtype.val", "Nat.find_x"],
  "name": "Nat.find"},
 {"type": "∀ {m n : ℕ}, m ∣ n → n % m = 0",
  "offspring": ["Exists.elim", "Nat.mul_mod_right"],
  "name": "Nat.mod_eq_zero_of_dvd"},
 {"type":
  "∀ {α : Type u_1} (l : List α) (n : ℕ) (h : n < List.length l), List.get l { val := n, isLt := h } ∈ l",
  "offspring": ["List.mem_cons_self", "List.mem_cons_of_mem", "Nat.add"],
  "name": "List.get_mem"},
 {"type": "∀ (a : USize), { val := Ring.gsmul 0 a.val } = { val := 0.1 }",
  "offspring": ["SubNegMonoid.gsmul_zero'"],
  "name": "USize.instRingUSize.proof_3"},
 {"type": "{R : Type u} → [self : Ring R] → ℤ → R → R",
  "offspring": [],
  "name": "Ring.gsmul"},
 {"type": "∀ (p : Prop), (p ∧ True) = p",
  "offspring": ["trivial"],
  "name": "and_true"},
 {"type": "∀ {a b : ℤ}, a < b → ∃ n, a + ↑(Nat.succ n) = b",
  "offspring":
  ["Exists.imp", "Int.add_left_comm", "Int.add_comm", "Int.le.dest"],
  "name": "Int.lt.dest"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk"],
  "name": "UInt8.add"},
 {"type": "{α : Type u} → [inst : BEq α] → BEq (List α)",
  "offspring": ["BEq.mk", "List.beq"],
  "name": "List.instBEqList"},
 {"type":
  "{α : Type u} → [inst : LT α] → [inst : DecidableRel LT.lt] → List α → Option α",
  "offspring": ["List.foldl", "max"],
  "name": "List.maximum?"},
 {"type":
  "∀ {α : Type u_1} {x : Option (Option (Option α))}, Option.join (Option.join x) = Option.join (Option.map Option.join x)",
  "offspring":
  ["Option.none_bind",
   "Option.map_none'",
   "Option.some_bind",
   "id_eq",
   "Option.map_some'"],
  "name": "Option.join_join"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ f₃ : (x : α) → β x},\n  Function.Equiv f₁ f₂ → Function.Equiv f₂ f₃ → Function.Equiv f₁ f₃",
  "offspring": [],
  "name": "Function.Equiv.trans"},
 {"type": "sizeOf Tactic.NormCast.Label.squash = 1",
  "offspring": [],
  "name": "Tactic.NormCast.Label.squash.sizeOf_spec"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} [inst : SizeOf α] [inst_1 : SizeOf β] (val : β), sizeOf (PSum.inr val) = 1 + sizeOf val",
  "offspring": [],
  "name": "PSum.inr.sizeOf_spec"},
 {"type": "∀ {a b c d : Prop}, a ∨ b → (a → c) → (b → d) → c ∨ d",
  "offspring": ["Or.imp"],
  "name": "or_of_or_of_imp_of_imp"},
 {"type": "Type u → (Type v → Type w) → Type (max (max u (v + 1)) w)",
  "offspring": [],
  "name": "MonadExceptOf"},
 {"type": "{n : ℕ} → Fin n → Fin n → Bool × Fin n",
  "offspring": ["Decidable.decide"],
  "name": "Fin.overflowingMul"},
 {"type":
  "∀ {G : Type u} [inst : AddSemigroup G] (a b c : G), a + b + c = a + (b + c)",
  "offspring": ["AddSemigroup.add_assoc"],
  "name": "add_assoc"},
 {"type":
  "∀ {α : Sort u_3} {β : Sort u_4} {γ : Sort u_1} {δ : Sort u_2} {p q : α → β → γ → δ → Prop},\n  (∀ (a : α) (b : β) (c : γ) (d : δ), p a b c d ↔ q a b c d) → ((∃ a b c d, p a b c d) ↔ ∃ a b c d, q a b c d)",
  "offspring": ["exists_congr", "exists₃_congr"],
  "name": "exists₄_congr"},
 {"type":
  "{α : Sort u2} →\n  {a : α} → {motive : {β : Sort u2} → β → Sort u1} → motive a → {β : Sort u2} → {b : β} → HEq a b → motive b",
  "offspring": [],
  "name": "HEq.ndrec"},
 {"type": "∀ {α : Sort u} {p : Prop}, Nonempty α → (α → p) → p",
  "offspring": ["Nonempty.elim.proof_1"],
  "name": "Nonempty.elim"},
 {"type": "Int.ofNat 0 = 0", "offspring": [], "name": "Int.ofNat_zero"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {r : β → β → Prop} {a : α} (f : α → β), Acc r (f a) → Acc (InvImage r f) a",
  "offspring": ["InvImage.accessible.proof_1"],
  "name": "InvImage.accessible"},
 {"type": "∀ (m n : ℕ), Nat.gcd m n * Nat.lcm m n = m * n",
  "offspring": [],
  "name": "Nat.gcd_mul_lcm"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, b < a → a ≠ b",
  "offspring": ["lt_irrefl"],
  "name": "ne_of_gt"},
 {"type": "∀ {G : Type u} [inst : Group G] (a b : G), a⁻¹ * (a * b) = b",
  "offspring": ["Inv.inv", "Semigroup.mul_assoc", "mul_left_inv", "one_mul"],
  "name": "inv_mul_cancel_left"},
 {"type": "∀ (x x_1 : UInt8), { val := (x + x_1).1 } = { val := (x_1 + x).1 }",
  "offspring": ["UInt8.mk", "AddCommSemigroup.add_comm"],
  "name": "UInt8.instAddCommSemigroupUInt8.proof_1"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "List.«term_<+_»"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a : α} {l : List α}, ¬p a → (a ∈ List.erasep p l ↔ a ∈ l)",
  "offspring":
  ["List.mem_of_mem_erasep", "Or.elim", "List.exists_or_eq_self_of_erasep"],
  "name": "List.mem_erasep_of_neg"},
 {"type": "{α : Type u} → [inst : Preorder α] → Trans GE.ge GE.ge GE.ge",
  "offspring": ["Trans.mk", "instTransGeToLE.proof_1"],
  "name": "instTransGeToLE"},
 {"type": "∀ {a b c d : Prop}, (a → c) → (b → d) → a ∨ b → c ∨ d",
  "offspring": ["Or.elim"],
  "name": "Or.imp"},
 {"type":
  "∀ {σ : Type u_1} {m : Type u_1 → Type u_2}, LawfulMonad (ExceptCpsT σ m)",
  "offspring": ["LawfulMonad.mk"],
  "name": "ExceptCpsT.instLawfulMonadExceptCpsTInstMonadExceptCpsT.proof_1"},
 {"type": "Fin UInt8.size → UInt8", "offspring": [], "name": "UInt8.mk"},
 {"type":
  "∀ {G : Type u} [self : DivInvMonoid G] (a : G), DivInvMonoid.gpow 0 a = 1",
  "offspring": [],
  "name": "DivInvMonoid.gpow_zero'"},
 {"type": "∀ {a b : ℤ}, a - b = a + -b",
  "offspring": [],
  "name": "Int.sub_eq_add_neg"},
 {"type": "∀ {m n : ℕ}, m ∣ n ↔ Nat.gcd m n = m",
  "offspring":
  ["Nat.gcd_rec",
   "Nat.mod_eq_zero_of_dvd",
   "Nat.gcd_zero_left",
   "Nat.gcd_dvd_right"],
  "name": "Nat.gcd_eq_left_iff_dvd"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HOr"},
 {"type": "∀ {a b c : ℕ}, a = c + b → a - b = c",
  "offspring": ["Nat.add_sub_cancel"],
  "name": "Nat.sub_eq_of_eq_add"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAppend α β γ",
  "offspring": [],
  "name": "HAppend.mk"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (a b c d : Nat.Linear.Expr),\n  Nat.Linear.Poly.cancel (Nat.Linear.Expr.toNormPoly a) (Nat.Linear.Expr.toNormPoly b) =\n      (Nat.Linear.Expr.toPoly c, Nat.Linear.Expr.toPoly d) →\n    (Nat.Linear.Expr.denote ctx a ≤ Nat.Linear.Expr.denote ctx b) =\n      (Nat.Linear.Expr.denote ctx c ≤ Nat.Linear.Expr.denote ctx d)",
  "offspring": [],
  "name": "Nat.Linear.Expr.of_cancel_le"},
 {"type": "{ε σ α : Type u} → [inst : Inhabited ε] → Inhabited (EStateM ε σ α)",
  "offspring": ["EStateM.Result.error", "Inhabited.default"],
  "name": "EStateM.instInhabitedEStateM"},
 {"type": "∀ {a b : Prop}, (a ↔ ¬b) ↔ (b ↔ ¬a)",
  "offspring": ["Decidable.iff_not_comm"],
  "name": "iff_not_comm"},
 {"type": "USize → ℕ", "offspring": ["USize.size"], "name": "USize.toNat"},
 {"type": "Type u → Type u", "offspring": [], "name": "LT"},
 {"type": "(self : FloatSpec) → DecidableRel self.lt",
  "offspring": [],
  "name": "FloatSpec.decLt"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {r : α → α → Prop} {s : β → β → Prop},\n  WellFounded r → WellFounded s → WellFounded (PSigma.RevLex r s)",
  "offspring": ["PSigma.revLex.proof_1"],
  "name": "PSigma.revLex"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticRwa__"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) {l : List α} {n : Fin (List.length (List.map f l))},\n  List.get (List.map f l) n = f (List.get l { val := ↑n, isLt := (_ : ↑n < List.length l) })",
  "offspring":
  ["Option.some.inj",
   "List.get",
   "List.map",
   "Fin.isLt",
   "List.length_map",
   "List.get?_eq_get",
   "List.get?",
   "List.get?_map",
   "Option.map"],
  "name": "List.get_map"},
 {"type":
  "∀ {α : Sort u_3} {β : Sort u_1} {φ : Sort u_2} {s₁ : Setoid α} {s₂ : Setoid β} (f : α → β → φ),\n  (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n    ∀ (a₁ : α) (a b : β), a ≈ b → f a₁ a = f a₁ b",
  "offspring": ["Setoid.refl"],
  "name": "Quotient.lift₂.proof_1"},
 {"type": "∀ (a b : ℕ), (¬a < b) = (b ≤ a)",
  "offspring": ["Nat.not_le_of_gt", "Nat.succ_le_succ"],
  "name": "Nat.not_lt_eq"},
 {"type": "{α : Type u} → (α → Bool) → Subarray α → Bool",
  "offspring": ["Id.run", "Subarray.anyM", "Id.instMonadId"],
  "name": "Subarray.any"},
 {"type": "Type u → Type u", "offspring": [], "name": "CommSemigroup"},
 {"type": "∀ (n : ℕ), n ^ 0 = 1", "offspring": [], "name": "Nat.pow_zero"},
 {"type": "∀ {α : Type}, Nonempty (Tactic.DeclCache α)",
  "offspring": ["Tactic.instNonemptyDeclCache.proof_1"],
  "name": "Tactic.instNonemptyDeclCache"},
 {"type": "{α : Type u_1} → (α → Bool) → Option α → Option α",
  "offspring": [],
  "name": "Option.filter"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "CoeHead"},
 {"type": "∀ {a b c : ℤ}, -a ≤ b - c → c ≤ a + b",
  "offspring": ["Int.le_add_of_neg_add_le_left", "Int.add_le_of_le_sub_right"],
  "name": "Int.le_add_of_neg_le_sub_left"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.«termExt_iff_type%__»"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} → [inst : Monad m] → Subarray α → (α → β → m (ForInStep β)) → USize → USize → β → m β",
  "offspring":
  ["instLTUSize",
   "Subarray.forInUnsafe.loop",
   "Array.uget",
   "Subarray.as",
   "lcProof"],
  "name": "Subarray.forInUnsafe.loop"},
 {"type":
  "{ε σ α : Type u} → [inst : Inhabited ε] → [inst : Inhabited σ] → Inhabited (EStateM.Result ε σ α)",
  "offspring": ["EStateM.Result.error", "Inhabited.default"],
  "name": "EStateM.instInhabitedResult"},
 {"type": "Fin UInt32.size → UInt32", "offspring": [], "name": "UInt32.mk"},
 {"type":
  "∀ (lo hi : ℤ), lo ≤ hi → ∀ (z : ℕ), z ≤ Int.natAbs (hi - lo) → lo ≤ ↑z + lo ∧ ↑z + lo ≤ hi",
  "offspring":
  ["Int.le_add_of_nonneg_left",
   "Int.ofNat_zero_le",
   "Int.add_le_of_le_sub_right",
   "Int.le_trans",
   "Int.ofNat_le",
   "le_of_eq",
   "Int.ofNat_natAbs_eq_of_nonneg",
   "Int.sub_nonneg_of_le"],
  "name":
  "Random.instBoundedRandomIntToPreorderToPartialOrderInstLinearOrderInt.proof_2"},
 {"type": "∀ {m : ℕ} (n : ℕ), 0 < m → Nat.gcd m n ≤ m",
  "offspring": ["Nat.le_of_dvd", "Nat.gcd_dvd_left"],
  "name": "Nat.gcd_le_left"},
 {"type":
  "{G : Type u} → [inst : Zero G] → [inst : Add G] → [inst : Neg G] → ℤ → G → G",
  "offspring": ["nsmul_rec"],
  "name": "gsmul_rec"},
 {"type":
  "∀ {G : Type u} [inst : Semigroup G] [inst_1 : IsMulLeftCancel G] (a : G) {b c : G}, a * b = a * c ↔ b = c",
  "offspring": ["mul_left_cancel"],
  "name": "mul_right_inj"},
 {"type": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "offspring": ["Nat.AtLeastTwo.mk", "Nat.succ_le_succ", "Nat.zero_le"],
  "name": "instAtLeastTwoHAddNatInstHAddInstAddNatOfNat.proof_1"},
 {"type": "∀ {k m n : ℕ}, Nat.coprime (k * m) n → Nat.coprime m n",
  "offspring": ["Nat.coprime.coprime_dvd_left", "Nat.dvd_mul_left"],
  "name": "Nat.coprime.coprime_mul_left"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["Nat.lor", "Fin.lor.proof_1"],
  "name": "Fin.lor"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term_×'_»"},
 {"type":
  "∀ {G : Type u} [self : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "offspring": [],
  "name": "Semigroup.mul_assoc"},
 {"type":
  "∀ {float : Type} {val : float} {lt le : float → float → Prop} {decLt : DecidableRel lt} {decLe : DecidableRel le}\n  {float_1 : Type} {val_1 : float_1} {lt_1 le_1 : float_1 → float_1 → Prop} {decLt_1 : DecidableRel lt_1}\n  {decLe_1 : DecidableRel le_1},\n  { float := float, val := val, lt := lt, le := le, decLt := decLt, decLe := decLe } =\n      { float := float_1, val := val_1, lt := lt_1, le := le_1, decLt := decLt_1, decLe := decLe_1 } →\n    float = float_1 ∧ HEq val val_1 ∧ HEq lt lt_1 ∧ HEq le le_1 ∧ HEq decLt decLt_1 ∧ HEq decLe decLe_1",
  "offspring": [],
  "name": "FloatSpec.mk.inj"},
 {"type": "∀ (a b : ℤ), -a + (a + b) = b",
  "offspring": ["Int.add_assoc", "Int.add_left_neg", "Int.zero_add"],
  "name": "Int.neg_add_cancel_left"},
 {"type":
  "∀ {α β : Sort u} {a : α} {b : β} {p : (T : Sort u) → T → Prop}, HEq a b → p α a → p β b",
  "offspring": ["HEq.ndrecOn"],
  "name": "HEq.subst"},
 {"type": "{α : Type u} → α → List α → Prop",
  "offspring": [],
  "name": "List.Mem"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a' = a → p a) ↔ p a'",
  "offspring": ["eq_comm", "forall_eq"],
  "name": "forall_eq'"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "CoeHTCT"},
 {"type":
  "∀ {α : Sort u} [inst : DecidableEq α] {α' : Sort u_1} {β : Sort u_2} (f : α' → β) (g : α → α') (i : α) (v : α'),\n  f ∘ Function.update g i v = Function.update (f ∘ g) i (f v)",
  "offspring": ["Function.apply_update"],
  "name": "Function.comp_update"},
 {"type":
  "(α : Sort u) → {β : α → Sort v} → [inst : (a : α) → Inhabited (β a)] → Inhabited ((a : α) → β a)",
  "offspring": ["Inhabited.default"],
  "name": "instInhabitedForAll_1"},
 {"type":
  "∀ (id : ℕ) (lits proof : Array ℤ) (id_1 : ℕ) (lits_1 proof_1 : Array ℤ),\n  (Mathlib.Tactic.Sat.LRATStep.add id lits proof = Mathlib.Tactic.Sat.LRATStep.add id_1 lits_1 proof_1) =\n    (id = id_1 ∧ lits = lits_1 ∧ proof = proof_1)",
  "offspring":
  ["Mathlib.Tactic.Sat.LRATStep", "Mathlib.Tactic.Sat.LRATStep.add"],
  "name": "Mathlib.Tactic.Sat.LRATStep.add.injEq"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt), BinaryHeap.max self = BinaryHeap.max self",
  "offspring": ["BinaryHeap.max"],
  "name": "BinaryHeap.replaceMax.proof_1"},
 {"type": "System.FilePath → Bool",
  "offspring": ["not", "System.FilePath.isAbsolute"],
  "name": "System.FilePath.isRelative"},
 {"type":
  "{f : Type u → Type v} → Sort u_1 → Applicative f → Applicative f → Sort u_1",
  "offspring": [],
  "name": "Applicative.noConfusionType"},
 {"type":
  "∀ (k : ℕ) (a : Nat.Linear.Expr) (k_1 : ℕ) (a_1 : Nat.Linear.Expr),\n  (Nat.Linear.Expr.mulL k a = Nat.Linear.Expr.mulL k_1 a_1) = (k = k_1 ∧ a = a_1)",
  "offspring": ["Nat.Linear.Expr", "Nat.Linear.Expr.mulL"],
  "name": "Nat.Linear.Expr.mulL.injEq"},
 {"type": "{α : Type u} → Sort u_1 → Array α → Array α → Sort u_1",
  "offspring": [],
  "name": "Array.noConfusionType"},
 {"type": "∀ {M : Type u} [self : Monoid M] (a : M), 1 * a = a",
  "offspring": [],
  "name": "Monoid.one_mul"},
 {"type": "∀ {n m : ℕ}, Nat.beq n m = true → n = m",
  "offspring": [],
  "name": "Nat.eq_of_beq_eq_true"},
 {"type": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), 1 * a = a",
  "offspring": [],
  "name": "NonAssocSemiring.one_mul"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«prec(_)»"},
 {"type": "∀ {α : Type u} [self : LinearOrder α] (a b : α), a ≤ b ∨ b ≤ a",
  "offspring": [],
  "name": "LinearOrder.le_total"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b ∨ a < b → a ≤ b",
  "offspring": ["le_of_eq", "le_of_lt"],
  "name": "le_of_eq_or_lt"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort u_2},\n  WellFoundedRelation α →\n    ((a : α) → WellFoundedRelation (β a)) →\n      WellFounded (PSigma.Lex WellFoundedRelation.rel fun a => WellFoundedRelation.rel)",
  "offspring":
  ["WellFounded.intro",
   "Acc",
   "PSigma.lexAccessible",
   "WellFounded.apply",
   "WellFoundedRelation.wf"],
  "name": "PSigma.lex.proof_1"},
 {"type": "∀ (m n : ℕ), Int.negOfNat m + Int.negOfNat n = Int.negOfNat (m + n)",
  "offspring": ["Nat.zero_eq", "Nat.zero_add", "Nat.add_zero", "Nat.succ_add"],
  "name": "Int.negOfNat_add"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : ℕ), Fin.ofNat' (Nat.succ x) (_ : 0 < n) = Fin.ofNat' x (_ : 0 < n) + 1",
  "offspring": ["Fin.ofNat'_succ"],
  "name": "instAddMonoidWithOneFin.proof_2"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') ↔ p a'",
  "offspring": ["Iff.trans", "exists_congr", "And.comm", "exists_eq_left"],
  "name": "exists_eq_right"},
 {"type":
  "∀ (x : ℕ) (a : UInt8),\n  { val := Ring.gsmul (Int.ofNat (Nat.succ x)) a.val } =\n    { val := (a + (fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat x) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_succ'"],
  "name": "UInt8.instRingUInt8.proof_4"},
 {"type": "∀ {a b c : ℤ}, b < a → c < 0 → a * c < b * c",
  "offspring": [],
  "name": "Int.mul_lt_mul_of_neg_right"},
 {"type":
  "∀ {α : Type u} {motive : (a : α) → (a_1 : List α) → List.Mem a a_1 → Prop} (a : α) {b : α} {as : List α}\n  {a_1 : List.Mem b as}, List.Mem.below a_1 → motive b as a_1 → List.Mem.below (_ : List.Mem b (a :: as))",
  "offspring": [],
  "name": "List.Mem.below.tail"},
 {"type": "∀ (a : UInt64), sizeOf a = UInt64.toNat a + 2",
  "offspring":
  ["UInt64.mk.sizeOf_spec",
   "Fin.sizeOf",
   "UInt64.size",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var"],
  "name": "UInt64.sizeOf"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : α) → (a_1 : List α) → List.Chain R a a_1 → Prop} {a : α},\n  List.Chain.below (_ : List.Chain R a [])",
  "offspring": [],
  "name": "List.Chain.below.nil"},
 {"type": "{α : Type u} → [self : Xor α] → α → α → α",
  "offspring": [],
  "name": "Xor.xor"},
 {"type": "LawfulBEq ℕ",
  "offspring": ["Nat.instLawfulBEqNatInstBEqNat.proof_1"],
  "name": "Nat.instLawfulBEqNatInstBEqNat"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Conv.convTry_"},
 {"type": "∀ (a b n : ℕ), a * b % n = a % n * (b % n) % n",
  "offspring": [],
  "name": "Nat.mul_mod"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (val val_1 : β), (PSum.inr val = PSum.inr val_1) = (val = val_1)",
  "offspring": ["PSum.inr"],
  "name": "PSum.inr.injEq"},
 {"type": "∀ (a b c : ℤ), a * b * c = a * (b * c)",
  "offspring":
  ["Int.ofNat_mul_ofNat",
   "Nat.mul_assoc",
   "Int.ofNat_mul_negSucc_ofNat",
   "Int.negOfNat",
   "Int.ofNat_mul_negOfNat",
   "Int.negOfNat_mul_ofNat",
   "Int.negSucc_ofNat_ofNat",
   "Int.negOfNat_mul_negSucc_ofNat",
   "Int.mul_negSucc_ofNat_negSucc_ofNat",
   "Int.negSucc_ofNat_mul_negOfNat"],
  "name": "Int.mul_assoc"},
 {"type":
  "∀ {c : Prop} {h : Decidable c} (hc : c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = t hc",
  "offspring": [],
  "name": "dif_pos"},
 {"type":
  "{α : Sort u2} →\n  {r : α → α → Prop} →\n    {C : α → Sort u1} →\n      {a : α} → Acc r a → ((x : α) → (∀ (y : α), r y x → Acc r y) → ((y : α) → r y x → C y) → C x) → C a",
  "offspring": [],
  "name": "Acc.ndrecOn"},
 {"type": "∀ (n x : ℕ), x ^ Nat.succ n = x * x ^ n",
  "offspring": ["Nat.pow_succ"],
  "name": "Nat.instCommSemiringNat.proof_4"},
 {"type": "∀ {a b : ℕ}, a % b < a → b ≤ a",
  "offspring": ["Decidable.byContradiction"],
  "name": "Nat.le_of_mod_lt"},
 {"type": "{R : Type u} → [self : CommSemiring R] → CommMonoid R",
  "offspring": ["CommMonoid.mk", "CommSemiring.mul_comm"],
  "name": "CommSemiring.toCommMonoid"},
 {"type": "Pow Float Float",
  "offspring": ["Pow.mk", "Float.pow"],
  "name": "instPowFloat"},
 {"type": "∀ {α β : Sort u} {a : α} {b : β}, HEq a b → α = β",
  "offspring": ["type_eq_of_heq.proof_1"],
  "name": "type_eq_of_heq"},
 {"type": "{α : Sort u} → Sort u_1 → HasEquiv α → HasEquiv α → Sort u_1",
  "offspring": [],
  "name": "HasEquiv.noConfusionType"},
 {"type":
  "{α : Type u} → {inst : BEq α} → Sort u_1 → LawfulBEq α → LawfulBEq α → Sort u_1",
  "offspring": [],
  "name": "LawfulBEq.noConfusionType"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m], LawfulMonad (ExceptT ε m)",
  "offspring": ["ExceptT.instLawfulMonadExceptTInstMonadExceptT.proof_1"],
  "name": "ExceptT.instLawfulMonadExceptTInstMonadExceptT"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, b ≤ a → max a b = a",
  "offspring": ["eq_max", "le_refl"],
  "name": "max_eq_left"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "precMin1"},
 {"type": "∀ (a b : USize), a * b = { val := a.val * b.val }",
  "offspring": [],
  "name": "USize.mul_def"},
 {"type": "{m : Type u_1 → Type u_2} → ForIn m ByteArray UInt8",
  "offspring": ["ForIn.mk", "ByteArray.forIn"],
  "name": "ByteArray.instForInByteArrayUInt8"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → List α",
  "offspring": [],
  "name": "List.erasep"},
 {"type": "{n i : ℕ} → OfNat (Fin (n + 1)) i",
  "offspring": ["OfNat.mk", "Fin.ofNat"],
  "name": "Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat"},
 {"type": "Type", "offspring": [], "name": "Tactic.NormCast.CoeFnInfo"},
 {"type": "{α : Type u} → α → List α", "offspring": [], "name": "List.pure"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "precArg"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (x : α) (o : Option α),\n  Option.getD (Option.map f o) (f x) = f (Option.getD o x)",
  "offspring": [],
  "name": "Option.getD_map"},
 {"type": "∀ (n : ℕ), -[1+ n] = -Int.ofNat n - 1",
  "offspring": ["Int.sub_eq_add_neg", "Int.neg_add"],
  "name": "Int.negSucc_ofNat_coe'"},
 {"type":
  "{M₀ : Type u} →\n  [toMulOneClass : MulOneClass M₀] →\n    [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MulZeroOneClass M₀",
  "offspring": [],
  "name": "MulZeroOneClass.mk"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), a * b % n < n",
  "offspring": [],
  "name": "Fin.mul.proof_1"},
 {"type": "∀ {A : Type u} [self : AddCommGroup A] (a b : A), a + b = b + a",
  "offspring": [],
  "name": "AddCommGroup.add_comm"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "offspring": ["Iff.elim_left.proof_1"],
  "name": "Iff.elim_left"},
 {"type": "Type", "offspring": [], "name": "System.FilePath"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "calcStep"},
 {"type": "ShiftLeft UInt32",
  "offspring": ["ShiftLeft.mk", "UInt32.shiftLeft"],
  "name": "instShiftLeftUInt32"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "Array.«term__[:_]»"},
 {"type": "Lean.Expr → Option (Lean.Expr × ℕ)",
  "offspring": [],
  "name": "Tactic.NormCast.isNumeral?"},
 {"type": "∀ {a b c : ℤ}, a + b < c + b → a < c",
  "offspring": ["Int.lt_of_add_lt_add_left", "Int.add_comm"],
  "name": "Int.lt_of_add_lt_add_right"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_^^^_»"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a ~ a_1 → Prop} {l₁ l₂ l₃ : List α} {a : l₁ ~ l₂},\n  List.Perm.below a →\n    motive l₁ l₂ a → ∀ {a_3 : l₂ ~ l₃}, List.Perm.below a_3 → motive l₂ l₃ a_3 → List.Perm.below (_ : l₁ ~ l₃)",
  "offspring": [],
  "name": "List.Perm.below.trans"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α}, a = b ↔ (a == b) = true",
  "offspring": ["decide_eq_true"],
  "name": "EqIffBeqTrue"},
 {"type": "{α : Type} → Lean.Meta.DiscrTree α → StateT (Array α) Id Unit",
  "offspring": ["ForIn.forIn", "ForInStep", "Mathlib.Tactic.Lint.trieElements"],
  "name": "Mathlib.Tactic.Lint.elements"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Functor m] [inst_1 : LawfulFunctor m] (x : m α),\n  (fun a => a) <$> x = x",
  "offspring": ["LawfulFunctor.id_map"],
  "name": "id_map'"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HAdd"},
 {"type": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "offspring": [],
  "name": "CommSemiring.toSemiring"},
 {"type": "Sort u → Tactic.Ring.Cache → Tactic.Ring.Cache → Sort u",
  "offspring": [],
  "name": "Tactic.Ring.Cache.noConfusionType"},
 {"type": "∀ {a b : ℤ}, 0 < a - b → b < a",
  "offspring": [],
  "name": "Int.lt_of_sub_pos"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : Array α) (i : ℕ),\n  Array.isEqvAux a a (_ : Array.size a = Array.size a) (fun x y => decide (x = y)) i = true",
  "offspring":
  ["WellFounded.fix_eq",
   "dif_pos",
   "Subsingleton.elim",
   "Bool.and_true",
   "decide_eq_true_eq",
   "dif_neg"],
  "name": "Array.isEqvAux_self"},
 {"type":
  "Std.HashMap Lean.Name Lean.MessageData → Lean.CoreM Lean.MessageData",
  "offspring":
  ["Mathlib.Tactic.Lint.sortResults",
   "Functor.map",
   "Array.toList",
   "Array.mapM",
   "Mathlib.Tactic.Lint.printWarning"],
  "name": "Mathlib.Tactic.Lint.printWarnings"},
 {"type": "∀ {n m : ℕ}, n ≤ m → ↑(m - n) = ↑m - ↑n",
  "offspring": ["Int.ofNat_sub"],
  "name": "Int.coe_nat_sub"},
 {"type":
  "{α₁ : Type u₁} → {α₂ : Type u₂} → {β₁ : Type v₁} → {β₂ : Type v₂} → (α₁ → α₂) → (β₁ → β₂) → α₁ × β₁ → α₂ × β₂",
  "offspring": [],
  "name": "Prod.map"},
 {"type":
  "Sort u → Tactic.NormCast.CoeFnInfo → Tactic.NormCast.CoeFnInfo → Sort u",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnInfo.noConfusionType"},
 {"type":
  "∀ {R : Type u} [self : NonUnitalNonAssocSemiring R] (a b c : R), (a + b) * c = a * c + b * c",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.right_distrib"},
 {"type": "∀ (p : Prop) [inst : Decidable p], decide p = false ↔ ¬p",
  "offspring": ["of_decide_eq_false", "decide_eq_false"],
  "name": "decide_eq_false_iff_not"},
 {"type": "∀ {a : ℤ}, Int.ofNat (Int.natAbs a * Int.natAbs a) = a * a",
  "offspring": [],
  "name": "Int.natAbs_mul_self"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Functor f] [self : LawfulFunctor f] {α β γ : Type u} (g : α → β) (h : β → γ) (x : f α),\n  (h ∘ g) <$> x = h <$> g <$> x",
  "offspring": [],
  "name": "LawfulFunctor.comp_map"},
 {"type":
  "{f : Type u → Type v} → ({α β : Type u} → f (α → β) → (Unit → f α) → f β) → Seq f",
  "offspring": [],
  "name": "Seq.mk"},
 {"type": "{A : Type u} → [self : AddSemigroup A] → Add A",
  "offspring": [],
  "name": "AddSemigroup.toAdd"},
 {"type": "∀ (a b : ℤ), -a * b = -(a * b)",
  "offspring": ["Int.neg_mul_eq_neg_mul"],
  "name": "Int.neg_mul_eq_neg_mul_symm"},
 {"type": "{α : Type u_1} → (α → Option α) → List α → List α",
  "offspring": [],
  "name": "List.lookmap"},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "offspring": [],
  "name": "MonadFunctorT"},
 {"type": "{α : Type u} → {β : Type v} → α → α ⊕ β",
  "offspring": [],
  "name": "Sum.inl"},
 {"type":
  "Std.HashMap ℕ Mathlib.Tactic.Sat.Clause → Array ℤ → Array ℤ → Lean.Expr → Lean.Expr → Except String Lean.Expr",
  "offspring":
  ["Id.run",
   "ForIn.forIn",
   "Id.instMonadId",
   "Mathlib.Tactic.Sat.Clause",
   "ForInStep",
   "MProd",
   "Option",
   "Array",
   "Mathlib.Tactic.Sat.LClause",
   "instBEqNat",
   "instHashableNat",
   "not",
   "Mathlib.Tactic.Sat.LClause.mk",
   "Mathlib.Tactic.Sat.Clause.lits",
   "Mathlib.Tactic.Sat.Clause.expr",
   "Array.push",
   "Mathlib.Tactic.Sat.Clause.proof",
   "ForInStep.done",
   "Except.error",
   "Int.natAbs",
   "MProd.snd",
   "MProd.fst",
   "instHashableInt",
   "Int.instLTInt",
   "Option.isSome",
   "instToStringString",
   "Mathlib.Tactic.Sat.LClause.lits",
   "Inhabited.default",
   "Sat.Literal",
   "Sat.instToExprLiteral",
   "Sat.Literal.ofInt",
   "Except.ok",
   "Mathlib.Tactic.Sat.LClause.depth",
   "Int.toNat",
   "Array.foldr",
   "EmptyCollection.emptyCollection"],
  "name": "Mathlib.Tactic.Sat.buildProofStep"},
 {"type": "∀ {α : Type u} (b : ULift α), { down := b.down } = b",
  "offspring": ["ULift.up", "ULift.down"],
  "name": "ULift.up_down"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a : α) (b : β),\n  Sum.inl a = Sum.inr b → Sum.noConfusionType False (Sum.inl a) (Sum.inr b)",
  "offspring": [],
  "name": "instDecidableEqSum.proof_6"},
 {"type":
  "{α : Type u} → {m : Type v → Type w} → [inst : Monad m] → (α → m PUnit) → Subarray α → m PUnit",
  "offspring":
  ["Array.forRevM", "Subarray.as", "Subarray.stop", "Subarray.start"],
  "name": "Subarray.forRevM"},
 {"type": "Tactic.Ring.Cache → Lean.Expr",
  "offspring": [],
  "name": "Tactic.Ring.Cache.α"},
 {"type":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (p ↔ q)",
  "offspring":
  ["instDecidableIff.proof_1",
   "instDecidableIff.proof_2",
   "instDecidableIff.proof_3",
   "instDecidableIff.proof_4"],
  "name": "instDecidableIff"},
 {"type":
  "∀ {R : Type u} [self : NonUnitalNonAssocSemiring R] (a : R), 0 * a = 0",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.zero_mul"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["Nat.pred"], "name": "Nat.sub"},
 {"type": "Type", "offspring": [], "name": "Nat.Linear.Expr"},
 {"type": "List Lean.MessageData → Lean.MessageData",
  "offspring": [],
  "name": "Tactic.LibrarySearch.lines"},
 {"type": "Type u → Type u", "offspring": [], "name": "Array"},
 {"type": "∀ {α : Type u_1} {β : Type u_2}, Function.surjective Prod.swap",
  "offspring": ["Function.RightInverse.surjective", "Prod.swap_LeftInverse"],
  "name": "Prod.swap_surjective"},
 {"type":
  "∀ (arr : ByteArray) (off : ℕ) (arr_1 : ByteArray) (off_1 : ℕ),\n  ({ arr := arr, off := off } = { arr := arr_1, off := off_1 }) = (arr = arr_1 ∧ off = off_1)",
  "offspring": ["ByteArray", "ByteSliceT", "ByteSliceT.mk"],
  "name": "ByteSliceT.mk.injEq"},
 {"type": "Coe String IO.Error",
  "offspring": ["Coe.mk"],
  "name": "instCoeStringError"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term[_]»"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (n : ℕ) (a : α) (l : List α), l <:+ List.leftpad n a l",
  "offspring": [],
  "name": "List.leftpad_suffix"},
 {"type": "∀ {G : Type u} [inst : Group G] (a : G), a * a⁻¹ = 1",
  "offspring": ["mul_right_inv"],
  "name": "mul_inv_self"},
 {"type":
  "∀ {α : Sort u_1} {p : α → α → Bool}, is_dec_refl p → ∀ (x y : α), ¬p x y = true → x = y → False",
  "offspring": [],
  "name": "decidable_eq_of_bool_pred.proof_1"},
 {"type": "Sort u → Type u", "offspring": [], "name": "plift"},
 {"type": "∀ {a b : ℤ}, a < -b → b < -a",
  "offspring": [],
  "name": "Int.lt_neg_of_lt_neg"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_×_»"},
 {"type": "∀ (a b : UInt64), a % b = { val := a.val % b.val }",
  "offspring": [],
  "name": "UInt64.mod_def"},
 {"type": "∀ {n m k : ℕ}, 0 < n → m = n * k → m / n = k",
  "offspring": ["Nat.mul_div_cancel_left"],
  "name": "Nat.div_eq_of_eq_mul_right"},
 {"type":
  "{ε : Type u} → {ε' : Type u_1} → {α : Type u_2} → (ε → ε') → Except ε α → Except ε' α",
  "offspring": ["Except.error", "Except.ok"],
  "name": "Except.mapError"},
 {"type":
  "∀ {α : Sort u_1} [inst : HasEquiv α] {p : α → Prop} {s t : Subtype p}, s ≈ t ↔ s.val ≈ t.val",
  "offspring": ["Iff.rfl"],
  "name": "Subtype.equiv_iff"},
 {"type": "ByteArray → ℕ → UInt8 → ByteArray",
  "offspring": ["ByteArray.mk", "Array.set!"],
  "name": "ByteArray.set!"},
 {"type":
  "∀ {α : Type u_1} {arr : Array (UFNode α)} {m : UFModel (Array.size arr)},\n  UFModel.Models arr m → ∀ (i : Fin (Array.size arr)), (Array.get arr i).parent = ↑(UFModel.parent m i)",
  "offspring": ["UFModel.Models.parent_eq"],
  "name": "UFModel.Models.parent_eq'"},
 {"type": "∀ (n : ℕ), n < 4294967296 → n < USize.size",
  "offspring": ["usize_size_eq", "Nat.lt_trans"],
  "name": "USize.ofNat32.proof_1"},
 {"type": "{α : Type u} → Sort u_1 → Thunk α → Thunk α → Sort u_1",
  "offspring": [],
  "name": "Thunk.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α) (b : α) (bs : List α), a = b → as = bs → a :: as = b :: bs",
  "offspring": [],
  "name": "List.hasDecEq.proof_4"},
 {"type":
  "∀ {v : Sat.Valuation} {a : Prop} {n : ℕ}, (v n ↔ a) → Sat.Literal.reify v (Sat.Literal.pos n) ¬a",
  "offspring": ["Sat.Literal.reify.mk", "mt"],
  "name": "Sat.Literal.reify_pos"},
 {"type":
  "{m : Type u → Type v} → {inst : Monad m} → Sort u_1 → LawfulMonad m → LawfulMonad m → Sort u_1",
  "offspring": [],
  "name": "LawfulMonad.noConfusionType"},
 {"type": "∀ {p q : Prop}, ¬p → ¬q → p ∨ q → False",
  "offspring": [],
  "name": "instDecidableOr.proof_1"},
 {"type": "∀ {α : Type u_1} (a : α) (n : Fin 1), List.get [a] n = a",
  "offspring": [],
  "name": "List.get_singleton"},
 {"type": "∀ {a b c : ℕ}, a + b ≤ c → a ≤ c - b",
  "offspring": ["Nat.le.dest", "Nat.le.intro"],
  "name": "Nat.le_sub_of_add_le"},
 {"type": "∀ (a : UInt64), a + 0 = a",
  "offspring":
  ["UInt64.zero_def",
   "UInt64.add_def",
   "UInt64.mk",
   "add_zero",
   "UInt64.mk_val_eq"],
  "name": "UInt64.instSemiringUInt64.proof_1"},
 {"type": "{α : Type u_1} → ℕ → ℕ → List α → List α",
  "offspring": ["List.drop"],
  "name": "List.slice"},
 {"type": "∀ {p q : Prop}, p → ¬q → (p → q) → False",
  "offspring": [],
  "name": "instDecidableForAll.proof_2"},
 {"type": "(a b : UInt32) → Decidable (a < b)",
  "offspring": [],
  "name": "UInt32.decLt"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop} {a : α} {b : β} {l₁ : List α} {l₂ : List β},\n  R a b → List.Forall₂ R l₁ l₂ → List.Forall₂ R (a :: l₁) (b :: l₂)",
  "offspring": [],
  "name": "List.Forall₂.cons"},
 {"type": "{α : Type u} → List α → List (List α) → List α",
  "offspring": ["List.join", "List.intersperse"],
  "name": "List.intercalate"},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "offspring": [],
  "name": "MonadControlT"},
 {"type":
  "∀ {ε : Type u} {α : Type v} (a a_1 : ε), (Except.error a = Except.error a_1) = (a = a_1)",
  "offspring": ["Except.error"],
  "name": "Except.error.injEq"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : LT α] → [inst : LT β] → LT (α × β)",
  "offspring": ["LT.mk"],
  "name": "instLTProd"},
 {"type": "∀ {a b c d : ℕ}, a ≤ b → c ≤ d → a + c ≤ b + d",
  "offspring": ["Nat.le_trans", "Nat.add_le_add_right", "Nat.add_le_add_left"],
  "name": "Nat.add_le_add"},
 {"type":
  "{α : Type u_1} → (α → α → Bool) → (a : Array α) → { a' // Array.size a' = Array.size a }",
  "offspring": [],
  "name": "BinaryHeap.mkHeap"},
 {"type":
  "Lean.SimplePersistentEnvExtension (Lean.Name × Lean.Name) Mathlib.Prelude.Rename.RenameMap",
  "offspring": [],
  "name": "Mathlib.Prelude.Rename.renameExtension"},
 {"type": "{α : Type u_1} → UnionFind α",
  "offspring": ["UnionFind.mk", "UnionFind.empty.proof_1"],
  "name": "UnionFind.empty"},
 {"type":
  "∀ {α β σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf β] [inst_2 : SizeOf σ] (a : α) (a_1 : σ),\n  sizeOf (DoResultPRBC.pure a a_1) = 1 + sizeOf a + sizeOf a_1",
  "offspring": [],
  "name": "DoResultPRBC.pure.sizeOf_spec"},
 {"type": "{α : Type u} → Sort u_1 → Inter α → Inter α → Sort u_1",
  "offspring": [],
  "name": "Inter.noConfusionType"},
 {"type": "∀ (n m k : ℕ), n * (m * k) = m * (n * k)",
  "offspring": ["Nat.mul_assoc"],
  "name": "Nat.mul_left_comm"},
 {"type": "∀ {n m : ℕ}, n > m → ¬n ≤ m",
  "offspring": ["Nat.lt_or_ge", "Nat.lt_trans", "Nat.lt_irrefl"],
  "name": "Nat.not_le_of_gt"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) ↔ ∃ x, ¬p x",
  "offspring": ["Decidable.not_forall"],
  "name": "not_forall"},
 {"type": "Mathlib.Tactic.Lint.SimpTheoremInfo → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.rhs"},
 {"type": "Float → ℤ → Float", "offspring": [], "name": "Float.scaleB"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {s : Setoid α} → Quotient s → (f : α → β) → (∀ (a b : α), a ≈ b → f a = f b) → β",
  "offspring": ["Quot.liftOn"],
  "name": "Quotient.liftOn"},
 {"type": "{α : Type u} → List α → List α",
  "offspring": ["List.reverseAux"],
  "name": "List.reverse"},
 {"type": "{α β : Type u} → (α → β) → ((α → β) → α → β) → α → β",
  "offspring": ["fixCore1"],
  "name": "fixCore"},
 {"type": "{G : Type u} → Sort u_1 → CommGroup G → CommGroup G → Sort u_1",
  "offspring": [],
  "name": "CommGroup.noConfusionType"},
 {"type": "∀ (n m : ℕ), n + m - m = n",
  "offspring": [],
  "name": "Nat.add_sub_cancel"},
 {"type": "∀ {a b c : Prop}, a ∨ b ∧ c ↔ (a ∨ b) ∧ (a ∨ c)",
  "offspring": ["And.imp", "imp_intro", "Or.imp_right"],
  "name": "or_and_distrib_left"},
 {"type": "Sat.Valuation → Sat.Fmla → Prop → Prop",
  "offspring": [],
  "name": "Sat.Fmla.reify"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticExfalso"},
 {"type":
  "∀ (str : String) (startPos stopPos : String.Pos),\n  sizeOf { str := str, startPos := startPos, stopPos := stopPos } = 1 + sizeOf str + sizeOf startPos + sizeOf stopPos",
  "offspring": ["instSizeOfNat"],
  "name": "Substring.mk.sizeOf_spec"},
 {"type":
  "{α : Sort u} →\n  {β : α → Sort v} →\n    [ha : WellFoundedRelation α] → [hb : (a : α) → WellFoundedRelation (β a)] → WellFoundedRelation (PSigma β)",
  "offspring": ["PSigma.lex"],
  "name": "PSigma.instWellFoundedRelationPSigma"},
 {"type": "∀ {n m : ℕ}, n ≤ m → m ≤ n → n = m",
  "offspring": ["Nat.lt_of_le_of_lt", "Nat.lt_irrefl"],
  "name": "Nat.le_antisymm"},
 {"type":
  "∀ {k m n : ℕ}, Nat.coprime (m * n) k ↔ Nat.coprime m k ∧ Nat.coprime n k",
  "offspring":
  ["Nat.coprime.coprime_mul_right",
   "Nat.coprime.coprime_mul_left",
   "Nat.coprime_iff_gcd_eq_one",
   "Nat.coprime.gcd_mul_left_cancel"],
  "name": "Nat.coprime_mul_iff_left"},
 {"type": "∀ (x x_1 : UInt32), { val := (x + x_1).1 } = { val := (x_1 + x).1 }",
  "offspring": ["UInt32.mk", "AddCommSemigroup.add_comm"],
  "name": "UInt32.instAddCommSemigroupUInt32.proof_1"},
 {"type":
  "∀ (x y : Mathlib.Tactic.Lint.LintVerbosity),\n  ¬Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx x = Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx y → x = y → False",
  "offspring":
  ["Mathlib.Tactic.Lint.LintVerbosity",
   "Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx"],
  "name": "Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2"},
 {"type": "{α : Type u} → Array α → Array α",
  "offspring": ["Array.foldl", "Prod", "Array.push", "Array.empty"],
  "name": "Array.getEvenElems"},
 {"type":
  "∀ {b c x y u v : Prop} [dec_b : Decidable b], (b ↔ c) → (x ↔ u) → (y ↔ v) → ((if b then x else y) ↔ if c then u else v)",
  "offspring": ["if_ctx_simp_congr_prop"],
  "name": "if_simp_congr_prop"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} (x : α), (∀ (y : α), r y x → Acc r y) → Acc r x",
  "offspring": [],
  "name": "Acc.intro"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "Applicative"},
 {"type": "∀ {a b c : ℤ}, a < b + c → -b + a < c",
  "offspring": [],
  "name": "Int.neg_add_lt_of_lt_add"},
 {"type": "False → True = False",
  "offspring": [],
  "name": "true_eq_false_of_false"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_\\_»"},
 {"type": "{f : Type u → Type v} → [self : Applicative f] → Seq f",
  "offspring": [],
  "name": "Applicative.toSeq"},
 {"type": "∀ {α : Type u_1} {a b : α} {l : List α}, a ∈ b :: l → b ∈ l → a ∈ l",
  "offspring": ["Or.elim", "List.eq_or_mem_of_mem_cons"],
  "name": "List.mem_of_mem_cons_of_mem"},
 {"type": "{α : Type u} → [self : Neg α] → α → α",
  "offspring": [],
  "name": "Neg.neg"},
 {"type": "∀ {a b c : Prop}, (a → b) → a ∧ c → b ∧ c",
  "offspring": ["And.imp"],
  "name": "And.imp_left"},
 {"type":
  "{α : Type} →\n  Lean.Name → (Array Lean.Expr → Lean.Expr → Lean.Expr → Array (Lean.Name × Lean.Expr) → Lean.MetaM α) → Lean.MetaM α",
  "offspring": ["Array.map", "ForIn.forIn", "Array.push"],
  "name": "Mathlib.Tactic.Ext.withExtHyps"},
 {"type": "∀ {G₀ : Type u} [self : GroupWithZero G₀], 0⁻¹ = 0",
  "offspring": [],
  "name": "GroupWithZero.inv_zero"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), -a + a = 0",
  "offspring": ["AddGroupWithOne.add_left_neg"],
  "name": "instCommRingFin.proof_5"},
 {"type": "{M : Type u} → [self : CommMonoid M] → Monoid M",
  "offspring": [],
  "name": "CommMonoid.toMonoid"},
 {"type": "Type", "offspring": [], "name": "Float"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAnd α β γ",
  "offspring": [],
  "name": "HAnd.mk"},
 {"type": "Type u → Type u", "offspring": [], "name": "Monoid"},
 {"type": "Sat.Valuation → Sat.Literal → Prop",
  "offspring": [],
  "name": "Sat.Valuation.neg"},
 {"type": "∀ {n : ℤ}, ↑n = n", "offspring": [], "name": "Int.cast_id"},
 {"type": "Lean.Expr → Lean.Elab.TermElabM Unit",
  "offspring":
  ["Tactic.DeclCache.get",
   "Tactic.Find.findDeclsPerHead",
   "ForIn.forIn",
   "andM",
   "instToBoolBool",
   "Array.toList",
   "GT.gt",
   "ForInStep.done",
   "Option.get!"],
  "name": "Tactic.Find.findType"},
 {"type":
  "{α : Type u} → [self : Random α] → {g : Type} → [inst : RandomGen g] → RandG g α",
  "offspring": [],
  "name": "Random.random"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (a' : α), ∃ a, f a = f a'",
  "offspring": [],
  "name": "exists_apply_eq_apply"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] {a b c : α}, a ≥ b → b ≥ c → a ≥ c",
  "offspring": ["ge_trans"],
  "name": "instTransGeToLE.proof_1"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {C : α → Sort v} (F : (x : α) → ((y : α) → r y x → C y) → C x) (x : α)\n  (acx : Acc r x), WellFounded.fixF F x acx = F x fun y p => WellFounded.fixF F y (_ : Acc (fun y x => r y x) y)",
  "offspring": ["WellFounded.fixFEq.proof_1"],
  "name": "WellFounded.fixFEq"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) (l : List α), (∃ x, x ∈ l ∧ ¬p x) → ¬∀ (x : α), x ∈ l → p x",
  "offspring": [],
  "name": "decidableBAll.proof_1"},
 {"type": "{α : Type u_1} → Subset (Set α)",
  "offspring": ["Subset.mk", "Set.subset"],
  "name": "Set.instSubsetSet"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) (Int.ofNat x) = (fun n => { val := ↑n }) (Int.ofNat x)",
  "offspring": [],
  "name": "UInt32.instRingUInt32.proof_7"},
 {"type": "∀ {a : Prop}, a → (a ↔ True)",
  "offspring": ["True.intro"],
  "name": "iff_true_intro"},
 {"type": "{α : Type u} → [self : Ord α] → α → α → Ordering",
  "offspring": [],
  "name": "Ord.compare"},
 {"type": "(α : Sort u) → [inst : SizeOf α] → α → α → Prop",
  "offspring": ["Measure"],
  "name": "SizeOfRef"},
 {"type": "(fun a => Int.ofNat a) 0 = (fun a => Int.ofNat a) 0",
  "offspring": [],
  "name": "Int.instCommRingInt.proof_2"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β},\n  Function.surjective f →\n    ∀ {p : β → β → β → Prop}, (∀ (y₁ y₂ y₃ : β), p y₁ y₂ y₃) ↔ ∀ (x₁ x₂ x₃ : α), p (f x₁) (f x₂) (f x₃)",
  "offspring":
  ["Iff.trans",
   "Function.surjective.forall",
   "forall_congr'",
   "Function.surjective.forall₂"],
  "name": "Function.surjective.forall₃"},
 {"type": "Xor UInt8",
  "offspring": ["Xor.mk", "UInt8.xor"],
  "name": "instXorUInt8"},
 {"type": "{α : Type u_1} → Inter (Set α)",
  "offspring": ["Inter.mk", "Set.inter"],
  "name": "Set.instInterSet"},
 {"type": "{α : Type u} → UInt32 → (Unit → α) → α",
  "offspring": [],
  "name": "dbgSleep"},
 {"type": "{α : Type u} → [n : Nonempty α] → {β : Sort v} → (α → β) → β → α",
  "offspring": ["Function.inv_fun_on", "Set.univ"],
  "name": "Function.inv_fun"},
 {"type": "{α : Type u_1} → Array α → ℕ → α → Array α",
  "offspring": ["Array.setD"],
  "name": "Array.set!"},
 {"type":
  "∀ {val val_1 : floatSpec.float}, { val := val } = { val := val_1 } → val = val_1",
  "offspring": [],
  "name": "Float.mk.inj"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) (Int.ofNat x) = (fun n => { val := ↑n }) (Int.ofNat x)",
  "offspring": [],
  "name": "USize.instRingUSize.proof_7"},
 {"type": "Ordering", "offspring": [], "name": "Ordering.gt"},
 {"type": "{M : Type u} → [inst : Zero M] → [inst : Add M] → ℕ → M → M",
  "offspring": [],
  "name": "nsmul_rec"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HAnd α β γ → HAnd α β γ → Sort u_1",
  "offspring": [],
  "name": "HAnd.noConfusionType"},
 {"type": "Type", "offspring": [], "name": "ByteSliceT"},
 {"type": "{α : Sort u_1} → Nonempty α → α",
  "offspring": ["Classical.choice"],
  "name": "Nonempty.some"},
 {"type": "Sat.Fmla → Sat.Clause → Prop",
  "offspring": ["Sat.Valuation.satisfies"],
  "name": "Sat.Fmla.proof"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a > b → ¬a < b",
  "offspring": ["lt_asymm"],
  "name": "not_lt_of_gt"},
 {"type": "Float → Float", "offspring": [], "name": "Float.cosh"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAndThen α β γ] → α → (Unit → β) → γ",
  "offspring": [],
  "name": "HAndThen.hAndThen"},
 {"type": "∀ {α : Type u_1} (l : List α), l ≠ [] → ∃ x, x ∈ l",
  "offspring": ["List.exists_mem_of_length_pos", "List.length_pos_of_ne_nil"],
  "name": "List.exists_mem_of_ne_nil"},
 {"type":
  "Type u → outParam (Type v) → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "Function.HasUncurry"},
 {"type": "{α : Sort u} → α → α → Prop", "offspring": [], "name": "Eq"},
 {"type": "{α σ : Type u} → σ → DoResultSBC α σ",
  "offspring": [],
  "name": "DoResultSBC.continue"},
 {"type": "∀ (a b c : USize), (a + b) * c = a * c + b * c",
  "offspring":
  ["USize.add_def",
   "USize.mul_def",
   "USize.mk",
   "USize.eq_of_val_eq",
   "Distrib.right_distrib"],
  "name": "USize.instSemiringUSize.proof_8"},
 {"type":
  "∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = t",
  "offspring": [],
  "name": "if_pos"},
 {"type":
  "∀ {α : Type u} (as bs : List α), List.reverseAux (List.reverseAux as bs) [] = List.reverseAux bs as",
  "offspring": [],
  "name": "List.reverseAux_reverseAux_nil"},
 {"type":
  "∀ {α : Type u} (as bs cs : List α), as ++ bs ++ cs = as ++ (bs ++ cs)",
  "offspring": ["List.cons_append"],
  "name": "List.append_assoc"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) -[1+ x] = (fun n => { val := ↑n }) -[1+ x]",
  "offspring": [],
  "name": "UInt16.instRingUInt16.proof_8"},
 {"type": "{α : Type u} → (α → (Unit → α) → α) → AndThen α",
  "offspring": [],
  "name": "AndThen.mk"},
 {"type": "∀ {α : Sort u} (a : α), id a = a",
  "offspring": [],
  "name": "id.def"},
 {"type": "{R : Type u} → [self : Ring R] → Sub R",
  "offspring": [],
  "name": "Ring.toSub"},
 {"type":
  "{f : Type u → Type v} → [self : SeqLeft f] → {α β : Type u} → f α → (Unit → f β) → f α",
  "offspring": [],
  "name": "SeqLeft.seqLeft"},
 {"type": "{α : Sort u} → [i : α] → α",
  "offspring": [],
  "name": "inferInstance"},
 {"type": "(n : ℕ) → n < UInt64.size → UInt64",
  "offspring": ["UInt64.mk", "UInt64.size"],
  "name": "UInt64.ofNatCore"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {r : α → α → Prop} {s : (a : α) → β a → β a → Prop} {a : α},\n  Acc r a → (∀ (a : α), WellFounded (s a)) → ∀ (b : β a), Acc (PSigma.Lex r s) { fst := a, snd := b }",
  "offspring": ["PSigma.lexAccessible.proof_1"],
  "name": "PSigma.lexAccessible"},
 {"type":
  "∀ {α : Type u_1} {p : Option α → Prop}, (∃ x x_1, p x) ↔ ∃ x, p (some x)",
  "offspring":
  ["Option.get",
   "Option.ne_none_iff_isSome",
   "Option.some_get",
   "Option.some_ne_none"],
  "name": "Option.bex_ne_none"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.surjective f → ∀ {p : β → Prop}, (∃ y, p y) ↔ ∃ x, p (f x)",
  "offspring": [],
  "name": "Function.surjective.exists"},
 {"type":
  "Array (Mathlib.Tactic.Lint.NamedLinter × Std.HashMap Lean.Name Lean.MessageData) →\n  Array Lean.Name → Bool → String → Bool → Mathlib.Tactic.Lint.LintVerbosity → ℕ → Lean.CoreM Lean.MessageData",
  "offspring":
  ["Array.filterMapM",
   "Mathlib.Tactic.Lint.NamedLinter",
   "Option",
   "not",
   "Mathlib.Tactic.Lint.groupedByFilename",
   "Mathlib.Tactic.Lint.printWarnings",
   "Mathlib.Tactic.Lint.NamedLinter.name",
   "Mathlib.Tactic.Lint.Linter.errorsFound",
   "Mathlib.Tactic.Lint.NamedLinter.toLinter",
   "Mathlib.Tactic.Lint.LintVerbosity",
   "Mathlib.Tactic.Lint.LintVerbosity.high",
   "Mathlib.Tactic.Lint.Linter.noErrorsFound",
   "Array.filterM",
   "Mathlib.Tactic.Lint.isAutoDecl",
   "Mathlib.Tactic.Lint.LintVerbosity.medium",
   "instBEqNat",
   "Array.foldl",
   "Array.map",
   "Array.toList"],
  "name": "Mathlib.Tactic.Lint.formatLinterResults"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (cs : Nat.Linear.Certificate),\n  Nat.Linear.PolyCnstr.isUnsat (Nat.Linear.Certificate.combine cs) = true → Nat.Linear.Certificate.denote ctx cs",
  "offspring": [],
  "name": "Nat.Linear.Certificate.of_combine_isUnsat"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.tacticAssumption_mod_cast"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term{}»"},
 {"type": "∀ {p q : Prop}, p → ¬q → p ∧ ¬q ∨ q ∧ ¬p",
  "offspring": [],
  "name": "instDecidableXor.proof_2"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l₁ l₂ : List α}, l₁ ++ a :: l₂ ~ a :: (l₁ ++ l₂)",
  "offspring":
  ["List.Perm.refl", "List.Perm.trans", "List.Perm.cons", "List.Perm.swap"],
  "name": "List.perm_middle"},
 {"type": "ℕ → UInt8", "offspring": ["UInt8.ofNat"], "name": "Nat.toUInt8"},
 {"type": "UInt8 → ℕ", "offspring": ["UInt8.size"], "name": "UInt8.toNat"},
 {"type": "Type u → Type u → Type u", "offspring": [], "name": "MProd"},
 {"type":
  "{m : Type u → Type v} → [self : MonadFinally m] → {α β : Type u} → m α → (Option α → m β) → m (α × β)",
  "offspring": [],
  "name": "MonadFinally.tryFinally'"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a : α} {l : List α},\n  ¬p a → List.erasep p (a :: l) = a :: List.erasep p l",
  "offspring": ["List.erasep_cons", "instDecidableFalse", "ite_false"],
  "name": "List.erasep_cons_of_neg"},
 {"type": "∀ (a : Prop), ¬a ∧ a ↔ False",
  "offspring": [],
  "name": "not_and_self_iff"},
 {"type":
  "∀ (m n : ℕ), -[1+ m] * -[1+ n] = Int.ofNat (Nat.succ m * Nat.succ n)",
  "offspring": [],
  "name": "Int.mul_negSucc_ofNat_negSucc_ofNat"},
 {"type": "System.FilePath → Bool",
  "offspring":
  ["or",
   "List.contains",
   "System.FilePath.pathSeparators",
   "System.FilePath.toString",
   "System.Platform.isWindows",
   "Decidable.decide",
   "GE.ge"],
  "name": "System.FilePath.isAbsolute"},
 {"type": "Type u → Type u", "offspring": [], "name": "Neg"},
 {"type": "{α : Sort u} → {β : Sort v} → CoeFun (α ≃ β) fun x => α → β",
  "offspring": ["CoeFun.mk", "Equiv.toFun"],
  "name": "Equiv.instCoeFunEquiv"},
 {"type": "∀ {α : Sort u_1} {β : Sort u_2}, (α → β) → Nonempty α → Nonempty β",
  "offspring": [],
  "name": "Nonempty.map"},
 {"type":
  "{m : Type u → Type u_1} → {ε α : Type u} → [inst : Monad m] → ExceptCpsT ε m α → m (Except ε α)",
  "offspring": ["Except.ok", "Except.error"],
  "name": "ExceptCpsT.run"},
 {"type": "∀ {k n m : ℕ}, k * n ≤ m → m < Nat.succ k * n → m / n = k",
  "offspring": [],
  "name": "Nat.div_eq_of_lt_le"},
 {"type":
  "{α : Type u} → [self : ReprTuple α] → α → List Lean.Format → List Lean.Format",
  "offspring": [],
  "name": "ReprTuple.reprTuple"},
 {"type": "(self : FloatSpec) → DecidableRel self.le",
  "offspring": [],
  "name": "FloatSpec.decLe"},
 {"type": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "offspring":
  ["MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonAssocSemiring.toMulZeroOneClass"},
 {"type": "(α : Sort u) → α ⊕' (α → False)",
  "offspring":
  ["Classical.propDecidable",
   "Nonempty",
   "PSum.inl",
   "Inhabited.default",
   "PSum.inr",
   "Classical.typeDecidable.proof_1"],
  "name": "Classical.typeDecidable"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {δ : Sort u₄} (f : φ → δ) (g : β → φ) (h : α → β), (f ∘ g) ∘ h = f ∘ g ∘ h",
  "offspring": [],
  "name": "Function.comp.assoc"},
 {"type": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "offspring": ["Or.elim"],
  "name": "Or.resolve_left"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {arr : Array α} {n : ℕ} {m : Fin n → β},\n  UFModel.Agrees arr f m →\n    ∀ (k : ℕ),\n      k = n + 1 →\n        ∀ (x : α) (m' : Fin k → β),\n          (∀ (i : Fin k) (h : ↑i < n), m' i = m { val := ↑i, isLt := h }) →\n            (∀ (h : n < k), f x = m' { val := n, isLt := h }) → UFModel.Agrees (Array.push arr x) f m'",
  "offspring": [],
  "name": "UFModel.Agrees.push"},
 {"type": "{α : Type u} → [inst : Preorder α] → Trans GE.ge GT.gt GT.gt",
  "offspring": ["Trans.mk", "instTransGeToLEGtToLT.proof_1"],
  "name": "instTransGeToLEGtToLT"},
 {"type": "{α : Type u} → Sort u_1 → Add α → Add α → Sort u_1",
  "offspring": [],
  "name": "Add.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} (a : α) (n : ℕ), List.repeat' a (n + 1) = a :: List.repeat' a n",
  "offspring": [],
  "name": "List.repeat'_succ"},
 {"type": "∀ {m n : ℕ}, Nat.coprime n m ↔ Nat.coprime m n",
  "offspring": ["Nat.coprime.symm"],
  "name": "Nat.coprime_comm"},
 {"type": "∀ {i : ℕ}, i ≤ 0 ↔ i = 0",
  "offspring": ["Nat.eq_zero_of_le_zero", "le_refl"],
  "name": "Nat.le_zero_iff"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_3} [inst : Monad m] (f : α → m PUnit), forM [] f = pure PUnit.unit",
  "offspring": [],
  "name": "List.forM_nil"},
 {"type":
  "{m : Type u → Type v} → {β : Type u} → [inst : Monad m] → [inst : ToBool β] → m β → m β → m β",
  "offspring": ["ToBool.toBool"],
  "name": "andM"},
 {"type": "∀ {α β : Type u_1} (x : Id α) (f : α → β), f <$> x = f x",
  "offspring": [],
  "name": "Id.map_eq"},
 {"type": "∀ {p : Prop} [inst : Decidable p], (decide p = true) = p",
  "offspring": ["decide_eq_true"],
  "name": "decide_eq_true_eq"},
 {"type":
  "∀ {α : Type u_1} {arr : Array (UFNode α)} {n : ℕ} {m : UFModel n}, UFModel.Models arr m → n = Array.size arr",
  "offspring": ["UFModel.Agrees.size_eq"],
  "name": "UFModel.Models.size_eq"},
 {"type": "∀ (a : UInt8), sizeOf a = UInt8.toNat a + 2",
  "offspring":
  ["UInt8.mk.sizeOf_spec",
   "Fin.sizeOf",
   "UInt8.size",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var"],
  "name": "UInt8.sizeOf"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ a = b ∨ b < a",
  "offspring": ["Or.elim", "le_total", "Decidable.lt_or_eq_of_le"],
  "name": "lt_trichotomy"},
 {"type": "{α : Type u_1} → UFNode α → ℕ",
  "offspring": [],
  "name": "UFNode.parent"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a <+ a_1 → Prop} {a a_1 : List α} (x : a <+ a_1),\n  (∀ (a a_2 : List α) (x : a <+ a_2), List.sublist.below x → motive a a_2 x) → motive a a_1 x",
  "offspring":
  ["List.sublist.below.slnil",
   "List.sublist.below.cons",
   "List.sublist.below.cons2"],
  "name": "List.sublist.brecOn"},
 {"type":
  "∀ (eq : Bool) (lhs rhs : Nat.Linear.Poly) (eq_1 : Bool) (lhs_1 rhs_1 : Nat.Linear.Poly),\n  ({ eq := eq, lhs := lhs, rhs := rhs } = { eq := eq_1, lhs := lhs_1, rhs := rhs_1 }) =\n    (eq = eq_1 ∧ lhs = lhs_1 ∧ rhs = rhs_1)",
  "offspring":
  ["Nat.Linear.Poly", "Nat.Linear.PolyCnstr", "Nat.Linear.PolyCnstr.mk"],
  "name": "Nat.Linear.PolyCnstr.mk.injEq"},
 {"type": "∀ {a b : Prop} [inst : Decidable b], (a ↔ b) ↔ a ∧ b ∨ ¬a ∧ ¬b",
  "offspring": [],
  "name": "Decidable.iff_iff_and_or_not_and_not"},
 {"type": "{α : Type u} → (α → α → α) → (α → α) → α → Prop",
  "offspring": [],
  "name": "RightInverse"},
 {"type":
  "∀ {f : Type u_1 → Type u_2} {α : Type u_1} [inst : Applicative f] [inst_1 : LawfulApplicative f] (x : f α),\n  (Seq.seq (pure id) fun x_1 => x) = x",
  "offspring": ["LawfulApplicative.pure_seq", "LawfulFunctor.id_map"],
  "name": "pure_id_seq"},
 {"type": "∀ {a b : ℕ}, a < b → 0 < b",
  "offspring": [],
  "name": "Nat.zero_lt_of_lt"},
 {"type":
  "{α : Type u_1} → {n : ℕ} → (Fin n → α) → (m : ℕ) → m ≤ n → List α → List α",
  "offspring": ["Nat.le_of_lt"],
  "name": "List.ofFnAux"},
 {"type": "∀ {α β : Sort u_1} {a : α} {b : β}, HEq a b → α = β",
  "offspring": ["HEq.ndrecOn"],
  "name": "type_eq_of_heq.proof_1"},
 {"type": "∀ {n m k : ℕ}, n < m → m = k → n < k",
  "offspring": [],
  "name": "Nat.lt_of_lt_of_eq"},
 {"type": "{α : Type u} → [inst : Preorder α] → Trans LT.lt LE.le LT.lt",
  "offspring": ["Trans.mk", "instTransLtToLTLeToLE.proof_1"],
  "name": "instTransLtToLTLeToLE"},
 {"type": "{α β σ : Type u} → β → σ → DoResultPRBC α β σ",
  "offspring": [],
  "name": "DoResultPRBC.return"},
 {"type":
  "{m : Type u_1 → Type u_2} → {σ : Type u_1} → [inst : Monad m] → MonadLift m (StateCpsT σ m)",
  "offspring": ["MonadLift.mk", "StateCpsT.lift"],
  "name": "StateCpsT.instMonadLiftStateCpsT"},
 {"type": "∀ (m n : ℕ), Int.ofNat m + Int.ofNat n = Int.ofNat (m + n)",
  "offspring": [],
  "name": "Int.ofNat_add_ofNat"},
 {"type": "{n : ℕ} → Fin n → Fin n → Bool",
  "offspring": ["Decidable.decide"],
  "name": "Fin.mulOverflows?"},
 {"type": "∀ {a b c : Prop}, a → b ∨ c ↔ (a → b) ∨ (a → c)",
  "offspring": ["Decidable.imp_or_distrib"],
  "name": "imp_or_distrib"},
 {"type": "List Bool → Bool", "offspring": ["List.all"], "name": "List.band"},
 {"type": "(self : FloatSpec) → self.float → self.float → Prop",
  "offspring": [],
  "name": "FloatSpec.le"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} (f : α → γ) (g : β → δ) (p : α × β),\n  (Prod.map f g p).fst = f p.fst",
  "offspring": ["prod_map"],
  "name": "Prod.map_fst"},
 {"type":
  "∀ {α : Type u_1} {a : α} [inst : SizeOf α] {as : List α}, a ∈ as → sizeOf a < sizeOf as",
  "offspring":
  ["List.cons.sizeOf_spec",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var",
   "Nat.lt_trans"],
  "name": "List.sizeOf_lt_of_mem"},
 {"type":
  "{motive : Tactic.Ring.HornerExpr → Sort u} → Tactic.Ring.HornerExpr → Sort (max 1 u)",
  "offspring": ["PProd"],
  "name": "Tactic.Ring.HornerExpr.below"},
 {"type": "∀ {a b : ℤ}, a < 0 → b < 0 → 0 < a * b",
  "offspring": [],
  "name": "Int.mul_pos_of_neg_of_neg"},
 {"type":
  "∀ {α : Type u_1}, WellFounded (invImage (fun a => Array.size a) instWellFoundedRelation).1",
  "offspring": [],
  "name": "Array.popWhile.proof_1"},
 {"type": "UInt8 → Bool",
  "offspring": ["Decidable.decide", "GE.ge", "instLEUInt8"],
  "name": "UInt8.isUpper"},
 {"type": "LT Float",
  "offspring": ["LT.mk", "Float.lt"],
  "name": "instLTFloat"},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Alternative m] → Option α → m α",
  "offspring": ["Alternative.failure"],
  "name": "liftOption"},
 {"type": "∀ {a b c : ℤ}, a - b < c → a - c < b",
  "offspring": ["Int.sub_left_lt_of_lt_add", "Int.lt_add_of_sub_right_lt"],
  "name": "Int.sub_lt_of_sub_lt"},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] (a : M) (m n : ℕ), a ^ (m + n) = a ^ m * a ^ n",
  "offspring":
  ["Nat.zero_eq",
   "Nat.add_zero",
   "pow_zero",
   "mul_one",
   "Nat.add_succ",
   "pow_succ'",
   "Semigroup.mul_assoc",
   "pow_mul_comm"],
  "name": "pow_add"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α), ∃ m, UFModel.Models self.arr m",
  "offspring": ["UFModel.Models.size_eq", "UnionFind.model"],
  "name": "UnionFind.model'"},
 {"type": "∀ (a b : ℕ), Nat.min a b ≤ a",
  "offspring":
  ["ite_true",
   "le_refl",
   "instDecidableFalse",
   "ite_false",
   "Nat.le_of_not_le"],
  "name": "Nat.min_le_left"},
 {"type":
  "{α : Type u} → {p : α → Prop} → [inst : DecidableEq α] → DecidableEq { x // p x }",
  "offspring":
  ["Subtype.mk",
   "Subtype.instDecidableEqSubtype.proof_1",
   "Subtype.instDecidableEqSubtype.proof_2"],
  "name": "Subtype.instDecidableEqSubtype"},
 {"type": "∀ (a b c : ℤ), a * (b - c) = a * b - a * c",
  "offspring":
  ["Trans.trans",
   "Int.distrib_left",
   "Int.mul_neg_eq_neg_mul_symm",
   "Int.sub_eq_add_neg"],
  "name": "Int.mul_sub"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (val : α), sizeOf (some val) = 1 + sizeOf val",
  "offspring": [],
  "name": "Option.some.sizeOf_spec"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«term∃__,_»"},
 {"type": "∀ (m n : ℕ), ↑m = ↑n ↔ m = n",
  "offspring": ["Int.ofNat_eq_ofNat_iff"],
  "name": "Int.cast_eq_cast_iff_Nat"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "offspring": [],
  "name": "Iff.mpr"},
 {"type": "∀ {a b c : ℤ}, -b + a < c → a < b + c",
  "offspring": ["Int.lt_add_of_sub_left_lt", "Int.add_comm"],
  "name": "Int.lt_add_of_neg_add_lt_left"},
 {"type": "{α : Sort u} → (α → α → Bool) → Prop",
  "offspring": [],
  "name": "is_dec_refl"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2},\n  WellFoundedRelation α → WellFoundedRelation β → WellFounded (Prod.Lex WellFoundedRelation.rel WellFoundedRelation.rel)",
  "offspring":
  ["WellFounded.intro",
   "Acc",
   "Prod.lexAccessible",
   "WellFounded.apply",
   "WellFoundedRelation.wf"],
  "name": "Prod.lex.proof_1"},
 {"type": "optParam (Array ℤ) #[] → Lean.Parsec (Array ℤ)",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Parser.parseInts"},
 {"type": "∀ {a b c d : Prop}, (a ↔ c) → (b ↔ d) → (a ∧ b ↔ c ∧ d)",
  "offspring": ["And.imp"],
  "name": "and_congr"},
 {"type": "Lean.Expr → Lean.Expr → optParam Bool true → Lean.MetaM Bool",
  "offspring": ["bne"],
  "name": "Mathlib.Tactic.Lint.isSimpEq"},
 {"type": "∀ (a : Prop), a ↔ a", "offspring": [], "name": "Iff.refl"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [self : LawfulApplicative f] {α β : Type u} (x : f α) (y : f β),\n  (SeqLeft.seqLeft x fun x => y) = Seq.seq (Function.const β <$> x) fun x => y",
  "offspring": [],
  "name": "LawfulApplicative.seqLeft_eq"},
 {"type": "∀ {n m : ℕ}, n ≤ m → ∀ (i : ℕ), n ^ i ≤ m ^ i",
  "offspring": ["Nat.le_refl", "Nat.mul_le_mul"],
  "name": "Nat.pow_le_pow_of_le_left"},
 {"type": "∀ {m n : ℕ}, m < n → 0 < n - m",
  "offspring":
  ["Nat.lt_of_add_lt_add_right",
   "Nat.zero_add",
   "Nat.sub_add_cancel",
   "Nat.le_of_lt"],
  "name": "Nat.sub_pos_of_lt"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∀ (x : α), x ∈ a :: l → p x) ↔ p a ∧ ∀ (x : α), x ∈ l → p x",
  "offspring": ["List.ball_cons"],
  "name": "List.forall_mem_cons"},
 {"type": "∀ {α : Sort u_1} [h : Subsingleton α] (a b : α), a = b",
  "offspring": ["Subsingleton.allEq"],
  "name": "Subsingleton.elim.proof_1"},
 {"type":
  "∀ {α : Type u_1} (a : α) (n : ℕ) (l : List α), List.set l n a = List.modifyNth (fun x => a) n l",
  "offspring": ["congr_arg"],
  "name": "List.set_eq_modifyNth"},
 {"type": "∀ (a : UInt32), { val := Ring.gsmul 0 a.val } = { val := 0.1 }",
  "offspring": ["SubNegMonoid.gsmul_zero'"],
  "name": "UInt32.instRingUInt32.proof_3"},
 {"type": "{σ : Type u} → EStateM.Backtrackable PUnit σ",
  "offspring":
  ["EStateM.Backtrackable.mk", "EStateM.dummySave", "EStateM.dummyRestore"],
  "name": "EStateM.nonBacktrackable"},
 {"type": "∀ {α : Type}, Nonempty (Tactic.Cache α)",
  "offspring": ["Tactic.instNonemptyCache.proof_1"],
  "name": "Tactic.instNonemptyCache"},
 {"type": "List Bool → Bool", "offspring": ["List.any"], "name": "List.bor"},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] (n : ℕ) (a : M), Monoid.npow n a = a ^ n",
  "offspring": [],
  "name": "npow_eq_pow"},
 {"type": "(n : ℕ) → DecidableEq (Fin n)",
  "offspring": ["decEq", "Fin.eq_of_val_eq", "Fin.ne_of_val_ne"],
  "name": "instDecidableEqFin"},
 {"type": "{α : Type u} → [inst : DecidableEq α] → α → List α → List (List α)",
  "offspring": ["List.splitOnP"],
  "name": "List.splitOn"},
 {"type": "Substring → String.Iterator",
  "offspring": [],
  "name": "Substring.toIterator"},
 {"type": "{α : Type u_1} → [inst : ToString α] → ToString (Id α)",
  "offspring": [],
  "name": "instToStringId"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l₁ : List α} (l₂ : List α), a ∈ l₁ → a ∈ l₁ ++ l₂",
  "offspring": ["List.mem_append"],
  "name": "List.mem_append_left"},
 {"type":
  "∀ {n : ℕ} (val : ℕ) (isLt : val < n) (val_1 : ℕ) (isLt_1 : val_1 < n),\n  ({ val := val, isLt := isLt } = { val := val_1, isLt := isLt_1 }) = (val = val_1)",
  "offspring": [],
  "name": "Fin.mk.injEq"},
 {"type": "Lean.Expr → Lean.MetaM (Option Lean.Expr)",
  "offspring":
  ["Tactic.NormCast.getCoeFnInfo?",
   "Tactic.NormCast.CoeFnInfo",
   "instBEqNat",
   "Tactic.NormCast.CoeFnInfo.numArgs",
   "Tactic.NormCast.CoeFnInfo.coercee"],
  "name": "Tactic.NormCast.isCoeOf?"},
 {"type": "Nat.Linear.PolyCnstr → Nat.Linear.PolyCnstr",
  "offspring":
  ["Nat.Linear.Poly",
   "Nat.Linear.PolyCnstr.mk",
   "Nat.Linear.PolyCnstr.eq",
   "Nat.Linear.Poly.cancel",
   "Nat.Linear.Poly.fuse",
   "Nat.Linear.Poly.sort",
   "Nat.Linear.PolyCnstr.lhs",
   "Nat.Linear.PolyCnstr.rhs"],
  "name": "Nat.Linear.PolyCnstr.norm"},
 {"type":
  "∀ {α : Type u_1} (l : List α) (i : ℕ), i < List.length l → List.length (List.removeNth l i) = List.length l - 1",
  "offspring": ["List.length_cons"],
  "name": "List.length_removeNth"},
 {"type": "Task.Priority", "offspring": [], "name": "Task.Priority.max"},
 {"type":
  "{ε σ α β : Type u} → EStateM ε σ α → (Unit → EStateM ε σ β) → EStateM ε σ β",
  "offspring": ["EStateM.Result.error"],
  "name": "EStateM.seqRight"},
 {"type": "∀ {α β : Sort u} {a a' : α} {b : β}, a = a' → HEq a' b → HEq a b",
  "offspring": ["HEq.trans", "heq_of_eq"],
  "name": "heq_of_eq_of_heq"},
 {"type": "∀ {a b c : ℤ}, -b + a < c → a < b + c",
  "offspring": [],
  "name": "Int.lt_add_of_neg_add_lt"},
 {"type":
  "∀ {α : Sort u_1} {φ : α → Sort v} {a a' : α} {p₁ : φ a} {p₂ : φ a'} (e : a' = a), p₁ = e ▸ p₂ → HEq p₁ p₂",
  "offspring": ["HEq.rfl"],
  "name": "heq_of_eq_rec_right"},
 {"type": "∀ {n m : ℕ}, 0 < n → 0 < m → n - m < n",
  "offspring": ["Nat.lt_irrefl", "Nat.succ_sub_succ_eq_sub"],
  "name": "Nat.sub_lt"},
 {"type":
  "{f : Type u → Type v} → ({α β : Type u} → (α → β) → f α → f β) → ({α β : Type u} → α → f β → f α) → Functor f",
  "offspring": [],
  "name": "Functor.mk"},
 {"type": "xor True = Not",
  "offspring": ["true_and", "eq_false_of_decide", "and_false", "or_false"],
  "name": "xor_true"},
 {"type": "Mathlib.Tactic.Lint.Linter",
  "offspring":
  ["Mathlib.Tactic.Lint.Linter.mk",
   "Mathlib.Tactic.Lint.isSimpTheorem",
   "Mathlib.Tactic.Lint.checkAllSimpTheoremInfos",
   "Option",
   "Mathlib.Tactic.Lint.decorateError",
   "Array.contains",
   "Mathlib.Tactic.Lint.isSimpEq",
   "Option.isNone",
   "Mathlib.Tactic.Lint.formatLemmas",
   "Mathlib.Tactic.Lint.heuristicallyExtractSimpTheorems",
   "Option.getD",
   "not"],
  "name": "Mathlib.Tactic.Lint.simpNF"},
 {"type": "∀ (a : Prop), Nonempty (Decidable a)",
  "offspring": [],
  "name": "Classical.propDecidable.proof_1"},
 {"type": "Type", "offspring": [], "name": "UInt8"},
 {"type": "0 < UInt32.size",
  "offspring": [],
  "name": "instInhabitedUInt32.proof_1"},
 {"type": "∀ {A : Type u} [self : AddMonoid A] (a : A), a + 0 = a",
  "offspring": [],
  "name": "AddMonoid.add_zero"},
 {"type": "∀ {a : ℤ}, Int.sign a = 0 → a = 0",
  "offspring": [],
  "name": "Int.eq_zero_of_sign_eq_zero"},
 {"type": "∀ {n m : ℕ}, ¬Nat.ble n m = true → ¬n ≤ m",
  "offspring": ["Nat.ble_eq_true_of_le"],
  "name": "Nat.not_le_of_not_ble_eq_true"},
 {"type": "Type u → Type u", "offspring": [], "name": "OfScientific"},
 {"type": "∀ {m n : ℕ}, Nat.coprime m n → Nat.gcd m n = 1",
  "offspring": [],
  "name": "Nat.coprime.gcd_eq_one"},
 {"type":
  "∀ (a a_1 : ℕ), (Sat.Literal.neg a = Sat.Literal.neg a_1) = (a = a_1)",
  "offspring": ["Sat.Literal", "Sat.Literal.neg"],
  "name": "Sat.Literal.neg.injEq"},
 {"type": "Inhabited Tactic.NormCast.NormCastExtension",
  "offspring": ["Tactic.NormCast.NormCastExtension.mk", "Inhabited.default"],
  "name": "Tactic.NormCast.instInhabitedNormCastExtension"},
 {"type":
  "{α : Type u_1} →\n  (a : Array α) → ℕ → (r : Array α) → Array.size r = Array.size a → { r // Array.size r = Array.size a - 1 }",
  "offspring":
  ["WellFounded.fix",
   "Array.swap",
   "Array.size_swap",
   "Nat.lt_of_le_of_lt",
   "Nat.pred_le",
   "WellFoundedRelation.rel",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Nat.sub_succ_lt_self",
   "Subtype.mk",
   "Array.pop",
   "Array.size_pop"],
  "name": "Array.eraseIdxSzAux"},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → List α → α",
  "offspring": ["panicWithPosWithDecl"],
  "name": "List.head!"},
 {"type":
  "∀ {α : Type u} {i : ℕ} {a : α} {as : List α} {h : i + 1 < List.length (a :: as)},\n  List.get (a :: as) { val := i + 1, isLt := h } = List.get as { val := i, isLt := (_ : i < List.length as) }",
  "offspring": [],
  "name": "List.get_cons_succ"},
 {"type": "Sort u → Prop", "offspring": [], "name": "Subsingleton"},
 {"type": "Substring → Substring",
  "offspring": ["Substring.dropWhile"],
  "name": "Substring.trimLeft"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), a % b % n < n",
  "offspring": [],
  "name": "Fin.mod.proof_1"},
 {"type": "∀ {n m : ℕ}, Nat.succ n ≤ m → n < m",
  "offspring": [],
  "name": "Nat.lt_of_succ_le"},
 {"type": "Type u → Type u", "offspring": [], "name": "OrOp"},
 {"type": "Lean.Syntax → Lean.Expr → Lean.Elab.Tactic.TacticM Unit",
  "offspring":
  ["Tactic.TryThis.delabToRefinableSyntax", "Tactic.TryThis.addSuggestion"],
  "name": "Tactic.TryThis.addExactSuggestion"},
 {"type": "ByteSlice → ℕ → UInt8",
  "offspring": ["ByteArray.get!", "ByteSlice.arr", "ByteSlice.off"],
  "name": "ByteSlice.getOp"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β ε : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (f : α → β)\n  (x : ExceptT ε m α), ExceptT.run (f <$> x) = Except.map f <$> ExceptT.run x",
  "offspring": ["ExceptT.mk", "map_eq_pure_bind", "bind_congr"],
  "name": "ExceptT.run_map"},
 {"type": "∀ {α : Sort u_1} [s : DecidableEq α] (a : α), decide (a = a) = true",
  "offspring": ["Decidable.decide"],
  "name": "of_decide_eq_self_eq_true"},
 {"type": "{R : Type u} → [self : Ring R] → AddCommGroup R",
  "offspring": ["AddCommGroup.mk", "AddCommMonoid.add_comm"],
  "name": "Ring.toAddCommGroup"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "offspring": [],
  "name": "congr"},
 {"type": "sizeOf true = 1", "offspring": [], "name": "Bool.true.sizeOf_spec"},
 {"type": "∀ (b : Bool), (true || b) = true",
  "offspring": [],
  "name": "Bool.true_or"},
 {"type": "∀ {a b : ℤ}, a * b = 0 → a = 0 ∨ b = 0",
  "offspring": ["lt_trichotomy", "Int.instLinearOrderInt"],
  "name": "Int.eq_zero_or_eq_zero_of_mul_eq_zero"},
 {"type": "∀ {k m n : ℕ}, Nat.coprime m (n * k) → Nat.coprime m n",
  "offspring": ["Nat.coprime.coprime_dvd_right", "Nat.dvd_mul_right"],
  "name": "Nat.coprime.coprime_mul_right_right"},
 {"type": "∀ {n m : ℕ}, Nat.succ n ≤ Nat.succ m → n ≤ m",
  "offspring": ["Nat.pred_le_pred"],
  "name": "Nat.le_of_succ_le_succ"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (data : List α), sizeOf { data := data } = 1 + sizeOf data",
  "offspring": [],
  "name": "Array.mk.sizeOf_spec"},
 {"type": "{f : Type u → Type v} → ({α : Type u} → α → f α) → Pure f",
  "offspring": [],
  "name": "Pure.mk"},
 {"type": "{α : Type u} → [inst : Inhabited α] → List α → α",
  "offspring": ["panicWithPosWithDecl", "PProd.snd"],
  "name": "List.last!"},
 {"type":
  "∀ {a b a_1 b_1 : Nat.Linear.Expr}, Nat.Linear.Expr.add a b = Nat.Linear.Expr.add a_1 b_1 → a = a_1 ∧ b = b_1",
  "offspring": [],
  "name": "Nat.Linear.Expr.add.inj"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l₁ l₂ : List α}, List.disjoint (a :: l₁) l₂ → List.disjoint l₁ l₂",
  "offspring": ["List.disjoint_of_subset_left", "List.subset_cons"],
  "name": "List.disjoint_of_disjoint_cons_left"},
 {"type": "ℤ → ℤ → ℤ", "offspring": ["Int.subNatNat"], "name": "Int.add"},
 {"type": "{ε α : Type} → EIO ε α → Except ε α",
  "offspring": ["unsafeBaseIO"],
  "name": "unsafeEIO"},
 {"type": "Ring UInt8",
  "offspring":
  ["Ring.mk",
   "UInt8.instSemiringUInt8",
   "UInt8.instNegUInt8",
   "instSubUInt8",
   "UInt8.instRingUInt8.proof_1",
   "UInt8.mk",
   "Ring.gsmul",
   "UInt8.instRingUInt8.proof_3",
   "UInt8.instRingUInt8.proof_4",
   "UInt8.instRingUInt8.proof_5",
   "UInt8.instRingUInt8.proof_6",
   "Int.cast",
   "UInt8.instRingUInt8.proof_7",
   "UInt8.instRingUInt8.proof_8"],
  "name": "UInt8.instRingUInt8"},
 {"type": "{ε σ α : Type u} → EStateM ε σ α → σ → Option α",
  "offspring": ["EStateM.run"],
  "name": "EStateM.run'"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": [],
  "name": "unexpandEqNDRec"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : Fin n), 1 * x = x",
  "offspring":
  ["CommSemigroup.mul_comm",
   "Fin.eq_of_val_eq",
   "Fin.mul_def",
   "Fin.one_def",
   "Fin.size_positive",
   "Fin.elim0",
   "Nat.lt_or_eq_of_le",
   "Nat.mod_le",
   "Nat.mul_one",
   "Nat.mod_eq_of_lt",
   "Fin.isLt"],
  "name": "instMonoidWithZeroFin.proof_1"},
 {"type": "∀ (a b c : ℤ), a + b + c = a + (b + c)",
  "offspring":
  ["Int.add_assoc_aux1",
   "Int.add_comm",
   "Int.add_assoc_aux2",
   "Int.negSucc_ofNat_add_negSucc_ofNat",
   "Nat.add_succ",
   "Nat.add_left_comm"],
  "name": "Int.add_assoc"},
 {"type": "Sort u_1 → PNonScalar → PNonScalar → Sort u_1",
  "offspring": [],
  "name": "PNonScalar.noConfusionType"},
 {"type": "Decidable False",
  "offspring": ["not_false"],
  "name": "instDecidableFalse"},
 {"type": "Lean.Expr → Lean.Expr → Lean.Expr → ℕ → Lean.Expr × Lean.Expr",
  "offspring":
  ["Id.run",
   "ForIn.forIn",
   "Id.instMonadId",
   "Inhabited.default",
   "MProd.snd",
   "MProd.fst"],
  "name": "Mathlib.Tactic.Sat.buildReify"},
 {"type": "LT UInt8",
  "offspring": ["LT.mk", "UInt8.lt"],
  "name": "instLTUInt8"},
 {"type": "Lean.Name → Lean.CoreM Mathlib.Tactic.Lint.NamedLinter",
  "offspring": ["Classical.ofNonempty"],
  "name": "Mathlib.Tactic.Lint.getLinter"},
 {"type":
  "∀ (A : Type u_1) [inst : AddGroup A] (a b c : A), b + a = c + a → b = c",
  "offspring": ["add_neg_cancel_right"],
  "name":
  "instIsAddRightCancelToAddToAddSemigroupToAddMonoidToSubNegMonoid.proof_1"},
 {"type": "{α β : Type u} → (α → β) → ((α → β) → α → β) → ℕ → α → β",
  "offspring": [],
  "name": "bfix1"},
 {"type":
  "∀ {α : Type u_1} {a : α} {as : List α} {i : Fin (List.length (as ++ [a]))},\n  ¬↑i < List.length as → List.get (as ++ [a]) i = a",
  "offspring":
  ["List.nil_append",
   "List.length_cons",
   "List.length_nil",
   "Nat.Linear.ExprCnstr.eq_false_of_isUnsat",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var",
   "Nat.zero_eq",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "eq_false_of_decide",
   "List.append",
   "Nat.not_lt_eq",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Nat.not_le_eq"],
  "name": "List.get_last"},
 {"type":
  "{α : Type u_1} →\n  {lt : α → α → Bool} → (self : BinaryHeap α lt) → { a' // BinaryHeap.size a' = BinaryHeap.size self - 1 }",
  "offspring":
  ["BinaryHeap.popMaxAux.proof_1",
   "Subtype.mk",
   "BinaryHeap.popMaxAux.proof_2"],
  "name": "BinaryHeap.popMaxAux"},
 {"type": "{f : Type u → Type v} → [self : Applicative f] → SeqLeft f",
  "offspring": [],
  "name": "Applicative.toSeqLeft"},
 {"type": "∀ (a b : ℤ), a + b + -b = a",
  "offspring": ["Int.add_assoc", "Int.add_right_neg", "Int.add_zero"],
  "name": "Int.add_neg_cancel_right"},
 {"type": "∀ (n : ℕ), Int.natAbs (Int.ofNat n) = n",
  "offspring": [],
  "name": "Int.natAbs_ofNat"},
 {"type": "{α : Type u} → Membership α (List α)",
  "offspring": ["Membership.mk", "List.Mem"],
  "name": "List.instMembershipList"},
 {"type": "(a b : Float) → Decidable (a < b)",
  "offspring": ["Float.decLt"],
  "name": "floatDecLt"},
 {"type": "∀ {R : Type u} [self : Ring R] (a : R), Ring.gsmul 0 a = 0",
  "offspring": [],
  "name": "Ring.gsmul_zero'"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "offspring": ["Function.LeftInverse"],
  "name": "Function.RightInverse"},
 {"type": "∀ (m : ℕ) {n : ℕ}, 0 < n → 0 < Nat.gcd m n",
  "offspring": ["Nat.pos_of_dvd_of_pos", "Nat.gcd_dvd_right"],
  "name": "Nat.gcd_pos_of_pos_right"},
 {"type": "Inhabited USize",
  "offspring": ["USize.ofNatCore", "instInhabitedUSize.proof_1"],
  "name": "instInhabitedUSize"},
 {"type": "{α : Type u_1} → Inhabited (List α)",
  "offspring": [],
  "name": "instInhabitedList"},
 {"type":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → Decidable (xor p q)",
  "offspring":
  ["instDecidableXor.proof_1",
   "instDecidableXor.proof_2",
   "instDecidableXor.proof_3",
   "instDecidableXor.proof_4"],
  "name": "instDecidableXor"},
 {"type": "∀ {n m k : ℕ}, n + k = m → n ≤ m",
  "offspring": ["Nat.le_add_right"],
  "name": "Nat.le.intro"},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → (a : Array α) → α → ℕ → Option (Fin (Array.size a))",
  "offspring":
  ["WellFounded.fix",
   "Array.indexOfAux.proof_1",
   "Array.get",
   "Array.indexOfAux.proof_2"],
  "name": "Array.indexOfAux"},
 {"type": "∀ {n m : ℕ}, Nat.succ n < Nat.succ m → n < m",
  "offspring": ["Nat.le_of_succ_le_succ"],
  "name": "Nat.lt_of_succ_lt_succ"},
 {"type": "{α β : Type u} → MProd α β → β",
  "offspring": [],
  "name": "MProd.snd"},
 {"type": "∀ {α : Type u_1} {a b : α} {l : List α}, ¬a ∈ b :: l → a ≠ b",
  "offspring": ["List.Mem.head"],
  "name": "List.ne_of_not_mem_cons"},
 {"type": "∀ {m k : ℕ} (p : ℕ), Nat.gcd k m = Nat.succ p → 0 < Nat.gcd k m",
  "offspring": [],
  "name": "Nat.prod_dvd_and_dvd_of_dvd_prod.proof_3"},
 {"type":
  "∀ (x : ℕ), { val := ↑(x + 1) } = { val := ((fun n => { val := ↑n }) x + 1).1 }",
  "offspring": ["Fin.ofNat'_succ", "UInt16.size"],
  "name": "UInt16.instSemiringUInt16.proof_12"},
 {"type":
  "∀ {α : Type u_1} (b : α) (as : List α), b :: as = [] → List.noConfusionType False (b :: as) []",
  "offspring": [],
  "name": "List.getLast.proof_2"},
 {"type": "∀ (a : Prop), ¬¬¬a ↔ ¬a",
  "offspring": ["mt", "not_not_intro"],
  "name": "not_non_contradictory_iff_absurd"},
 {"type": "∀ {a b c : Prop}, (a ∧ c ↔ b ∧ c) ↔ c → (a ↔ b)",
  "offspring": ["And.congr_right_iff", "and_comm", "Iff.rfl"],
  "name": "And.congr_left_iff"},
 {"type":
  "∀ (p q : Prop) [d₁ : Decidable p] [d₂ : Decidable q], ¬(p ∧ q) ↔ ¬p ∨ ¬q",
  "offspring": [],
  "name": "Decidable.not_and_iff_or_not"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HOrElse α β γ] → α → (Unit → β) → γ",
  "offspring": [],
  "name": "HOrElse.hOrElse"},
 {"type": "{α : Type u_1} → UnionFind α → ℕ",
  "offspring": ["Subtype.val", "UnionFind.rankMaxAux", "UnionFind.size"],
  "name": "UnionFind.rankMax"},
 {"type": "Float → UInt32", "offspring": [], "name": "Float.toUInt32"},
 {"type": "{motive : ℕ → Prop} → ℕ → Prop",
  "offspring": [],
  "name": "Nat.ibelow"},
 {"type":
  "∀ {R : Type u_1} {n : ℕ} [inst : AddMonoidWithOne R] [inst_1 : Nat.AtLeastTwo n], ↑(OfNat.ofNat n) = OfNat.ofNat n",
  "offspring": [],
  "name": "Nat.cast_ofNat"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) (c : ∀ (a b : α), r a b → f a = f b) (a : α),\n  Quot.lift f c (Quot.mk r a) = f a",
  "offspring": [],
  "name": "Quot.liftBeta"},
 {"type": "0 < UInt32.size", "offspring": [], "name": "UInt32.size_positive"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticTransitivity__"},
 {"type": "{n : ℕ} → Fin n → ℕ", "offspring": [], "name": "Fin.val"},
 {"type": "(self : FloatSpec) → self.float → self.float → Prop",
  "offspring": [],
  "name": "FloatSpec.lt"},
 {"type": "Lean.PrettyPrinter.Delaborator.Delab",
  "offspring":
  ["Tactic.NormCast.coeDelaborator",
   "Tactic.NormCast.CoeFnInfo.mk",
   "Tactic.NormCast.CoeFnType.coe"],
  "name": "Array.ofSubarray.delaborator"},
 {"type":
  "∀ {m : Type u → Type u_1} {β γ α σ : Type u} [inst : Monad m] (a : α) (f : α → StateCpsT σ m β) (s : σ)\n  (k : β → σ → m γ), StateCpsT.runK (pure a >>= f) s k = StateCpsT.runK (f a) s k",
  "offspring": [],
  "name": "StateCpsT.runK_bind_pure"},
 {"type":
  "∀ {α : Type u_1} {f : α → α → α} {a : Option α}, Option.lift_or_get f a none = a",
  "offspring": [],
  "name": "Option.lift_or_get_none_right"},
 {"type":
  "∀ {σ : Type u_1} {m : Type u_1 → Type u_2}, LawfulMonad (StateCpsT σ m)",
  "offspring": ["LawfulMonad.mk"],
  "name": "StateCpsT.instLawfulMonadStateCpsTInstMonadStateCpsT.proof_1"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α ε : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (a : α),\n  ExceptT.lift (pure a) = pure a",
  "offspring": ["LawfulApplicative.map_pure"],
  "name": "ExceptT.lift_pure"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), a * 0 = 0",
  "offspring": ["MonoidWithZero.mul_zero"],
  "name": "instCommSemiringFin.proof_4"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["HShiftRight.hShiftRight", "Fin.shiftRight.proof_1"],
  "name": "Fin.shiftRight"},
 {"type": "Repr Tactic.NormCast.Label",
  "offspring": ["GE.ge"],
  "name": "Tactic.NormCast.instReprLabel"},
 {"type": "∀ {R : Type u_1} [inst : AddGroupWithOne R], ↑1 = 1",
  "offspring": ["Int.cast", "Int.cast_ofNat", "Nat.cast_one"],
  "name": "Int.cast_one"},
 {"type": "{α : Sort u} → [h : Nonempty α] → (α → Prop) → α",
  "offspring": ["Subtype.val", "Classical.strongIndefiniteDescription"],
  "name": "Classical.epsilon"},
 {"type": "{ε : Type u} → {α : Type u_1} → α → Except ε α",
  "offspring": ["Except.ok"],
  "name": "Except.pure"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort u_2} [inst : ∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "offspring": ["Subsingleton.intro", "Subsingleton.elim"],
  "name": "instSubsingletonForAll.proof_1"},
 {"type": "{a b : ℕ} → {C : Sort u} → (a < b → C) → (b ≤ a → C) → C",
  "offspring": ["Nat.lt_ge_by_cases.proof_1"],
  "name": "Nat.lt_ge_by_cases"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (a : α), l₁ ⊆ l₂ → a :: l₁ ⊆ a :: l₂",
  "offspring": ["List.mem_cons", "List.eq_or_mem_of_mem_cons"],
  "name": "List.cons_subset_cons"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → AddCommMonoid (Fin n)",
  "offspring":
  ["AddCommMonoid.mk", "instAddCommMonoidFin.proof_5", "AddCommSemigroup"],
  "name": "instAddCommMonoidFin"},
 {"type": "{M : Type u} → Sort u_1 → MulOneClass M → MulOneClass M → Sort u_1",
  "offspring": [],
  "name": "MulOneClass.noConfusionType"},
 {"type": "Repr USize",
  "offspring": ["repr", "instReprNat", "USize.toNat"],
  "name": "instReprUSize"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.tacticExt1___"},
 {"type": "∀ (n : ℕ), 0 ≤ n",
  "offspring": ["Nat.le.refl", "Nat.le.step"],
  "name": "Nat.zero_le"},
 {"type": "∀ (m n : ℕ), Int.ofNat m + -[1+ n] = Int.subNatNat m (Nat.succ n)",
  "offspring": [],
  "name": "Int.ofNat_add_negSucc_ofNat"},
 {"type": "Add UInt32",
  "offspring": ["Add.mk", "UInt32.add"],
  "name": "instAddUInt32"},
 {"type": "{g : Type} → [inst : RandomGen g] → RandG g Bool",
  "offspring": ["Random.rand", "Fin"],
  "name": "Random.randBool"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} (l : List α), b ≠ a → List.erase (b :: l) a = b :: List.erase l a",
  "offspring": ["List.erase_cons", "if_neg"],
  "name": "List.erase_cons_tail"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (x : ℕ),\n  x < Array.size a → (invImage (fun a_1 => Array.size a - a_1) instWellFoundedRelation).1 (x + 1) x",
  "offspring": ["sizeOf_nat", "Nat.lt_eq", "Nat.sub_succ_lt_self"],
  "name": "Array.indexOfAux.proof_2"},
 {"type": "{α : Type u} → [inst : ToString α] → ToString (Option α)",
  "offspring": ["ToString.mk", "addParenHeuristic"],
  "name": "instToStringOption"},
 {"type": "Xor UInt64",
  "offspring": ["Xor.mk", "UInt64.xor"],
  "name": "instXorUInt64"},
 {"type": "∀ (val : ℕ), sizeOf { val := val } = 1 + sizeOf val",
  "offspring": ["instSizeOfNat"],
  "name": "NonScalar.mk.sizeOf_spec"},
 {"type": "LawfulBEq Bool",
  "offspring": ["instLawfulBEqBoolInstBEqInstDecidableEqBool.proof_1"],
  "name": "instLawfulBEqBoolInstBEqInstDecidableEqBool"},
 {"type": "{α : Sort u} → (p : α → Prop) → (∃ x, p x) → { x // p x }",
  "offspring": ["Classical.choice", "Classical.indefiniteDescription.proof_1"],
  "name": "Classical.indefiniteDescription"},
 {"type":
  "∀ {α : Type u_1} [inst : Add α] (l r tl tr t : α), l = tl → r = tr → tl + tr = t → l + r = t",
  "offspring": [],
  "name": "Tactic.Ring.subst_into_add"},
 {"type":
  "{α : Type u} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (α → m PUnit) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m PUnit",
  "offspring": ["Array.foldlM"],
  "name": "Array.forM"},
 {"type": "{α : Sort u} → {β : Sort v} → [self : Coe α β] → α → β",
  "offspring": [],
  "name": "Coe.coe"},
 {"type": "LE UInt32", "offspring": ["LE.mk"], "name": "instLEUInt32"},
 {"type": "∀ {a b c : Prop}, a ∨ c → (a → b) → b ∨ c",
  "offspring": ["Or.imp_left"],
  "name": "or_of_or_of_imp_left"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} (a : α), p a → ∃ a_1, a_1 ∈ some a ∧ p a_1",
  "offspring": [],
  "name": "Option.decidable_exists_mem.proof_2"},
 {"type": "LinearOrder ℕ",
  "offspring": ["LinearOrder.mk", "Nat.le_total", "inferInstance"],
  "name": "Nat.instLinearOrderNat"},
 {"type": "{α : Type u_1} → ToStream (Array α) (Subarray α)",
  "offspring": ["ToStream.mk", "Array.toSubarray"],
  "name": "instToStreamArraySubarray"},
 {"type": "∀ {n m : ℕ}, n < m → n ≤ m",
  "offspring": ["Nat.le_of_succ_le"],
  "name": "Nat.le_of_lt"},
 {"type": "∀ (n m : Fin UInt64.size), n = m → { val := n } = { val := m }",
  "offspring": [],
  "name": "UInt64.decEq.proof_1"},
 {"type": "∀ {α : Sort u_1} {f : α → α}, Function.involutive f ↔ f^[2] = id",
  "offspring": ["Iff.symm", "Function.funext_iff"],
  "name": "Function.involutive_iff_iter_2_eq_id"},
 {"type": "∀ {n m : ℕ}, n > 0 → m > 0 → n * m > 0",
  "offspring": [],
  "name": "Nat.mul_pos"},
 {"type":
  "∀ (x y : Tactic.NormCast.Label), ¬Tactic.NormCast.Label.toCtorIdx x = Tactic.NormCast.Label.toCtorIdx y → x = y → False",
  "offspring": ["Tactic.NormCast.Label", "Tactic.NormCast.Label.toCtorIdx"],
  "name": "Tactic.NormCast.instDecidableEqLabel.proof_2"},
 {"type": "USize → UInt32",
  "offspring": ["Nat.toUInt32", "USize.toNat"],
  "name": "USize.toUInt32"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), e.toFun ∘ (Equiv.symm e).toFun = id",
  "offspring": ["Equiv.apply_symm_apply"],
  "name": "Equiv.self_comp_symm"},
 {"type": "∀ (x x_1 : UInt16), x * x_1 = x_1 * x",
  "offspring":
  ["UInt16.eq_of_val_eq", "UInt16.mul_def", "CommSemigroup.mul_comm"],
  "name": "UInt16.instCommRingUInt16.proof_1"},
 {"type":
  "∀ {α : Type u_1} (x : α) (xs : List α) (n : ℕ),\n  n = List.length xs →\n    List.get (x :: xs) { val := n, isLt := (_ : n < List.length (x :: xs)) } = List.getLast (x :: xs) (_ : x :: xs ≠ [])",
  "offspring": ["List.getLast_eq_get"],
  "name": "List.get_cons_length"},
 {"type":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun a a_1 => a ≤ a_1",
  "offspring": [],
  "name": "LinearOrder.decidable_le"},
 {"type": "{n : ℕ} → OfNat UInt8 n",
  "offspring": ["OfNat.mk", "UInt8.ofNat"],
  "name": "instOfNatUInt8"},
 {"type": "Lean.Parsec (Array Mathlib.Tactic.Sat.LRATStep)",
  "offspring":
  ["SeqLeft.seqLeft",
   "Unit",
   "Mathlib.Tactic.Sat.Parser.parseNat",
   "Mathlib.Tactic.Sat.Parser.parseNats",
   "Mathlib.Tactic.Sat.LRATStep.del",
   "Mathlib.Tactic.Sat.Parser.parseInts",
   "Mathlib.Tactic.Sat.LRATStep.add"],
  "name": "Mathlib.Tactic.Sat.Parser.parseLRAT"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk"],
  "name": "UInt64.mod"},
 {"type": "{α : Type u} → [inst : ToString α] → List α → String",
  "offspring": ["List.toStringAux"],
  "name": "List.toString"},
 {"type":
  "{ε α : Type u} → {m : Type u → Type v} → [inst : Monad m] → [inst : MonadExcept ε m] → m α → m (Except ε α)",
  "offspring": ["MonadExcept.tryCatch", "Except.ok", "Except.error"],
  "name": "observing"},
 {"type": "∀ (a b : Prop), a ∧ b ↔ b ∧ a",
  "offspring": ["And.comm"],
  "name": "and_comm"},
 {"type": "∀ (n : ℕ), 0 < Nat.succ n",
  "offspring": ["Nat.succ_le_succ", "Nat.zero_le"],
  "name": "Nat.zero_lt_succ"},
 {"type": "∀ {x y k : ℕ}, k ≤ y → (x ≤ y - k ↔ x + k ≤ y)",
  "offspring": ["Nat.add_sub_cancel", "Nat.sub_le_sub_right_iff", "Iff.rfl"],
  "name": "Nat.le_sub_iff_add_le"},
 {"type": "∀ {A : Type u} [self : AddGroup A] (a : A), -a + a = 0",
  "offspring": [],
  "name": "AddGroup.add_left_neg"},
 {"type": "{α : Sort u} → {β : Sort v} → (α → β) → CoeHead α β",
  "offspring": [],
  "name": "CoeHead.mk"},
 {"type":
  "∀ (val val_1 : floatSpec.float), ({ val := val } = { val := val_1 }) = (val = val_1)",
  "offspring": ["Float", "Float.mk"],
  "name": "Float.mk.injEq"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "CoeTail"},
 {"type": "{A : Type u} → Sort u_1 → AddGroup A → AddGroup A → Sort u_1",
  "offspring": [],
  "name": "AddGroup.noConfusionType"},
 {"type": "∀ {a b c : ℤ}, a ≤ b → 0 ≤ c → a * c ≤ b * c",
  "offspring":
  ["le_antisymm",
   "le_refl",
   "MonoidWithZero.mul_zero",
   "le_not_le_of_lt",
   "Int.mul_lt_mul_of_pos_right",
   "lt_of_le_not_le"],
  "name": "Int.mul_le_mul_of_nonneg_right"},
 {"type":
  "∀ {α : Type u} (a : α) {b : α} {as : List α}, List.Mem b as → List.Mem b (a :: as)",
  "offspring": [],
  "name": "List.Mem.tail"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → ({α : Type u} → m α → n α) → MonadLift m n",
  "offspring": [],
  "name": "MonadLift.mk"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_1} {δ : Sort u_2} {p q : α → β → γ → δ → Prop},\n  (∀ (a : α) (b : β) (c : γ) (d : δ), p a b c d ↔ q a b c d) →\n    ((∀ (a : α) (b : β) (c : γ) (d : δ), p a b c d) ↔ ∀ (a : α) (b : β) (c : γ) (d : δ), q a b c d)",
  "offspring": ["forall_congr'", "forall₃_congr"],
  "name": "forall₄_congr"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (m : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.sort m) = Nat.Linear.Poly.denote ctx m",
  "offspring": ["Nat.Linear.Poly.denote_sort_go", "Nat.zero_add"],
  "name": "Nat.Linear.Poly.denote_sort"},
 {"type": "∀ {x y : ℕ}, (Nat.ble x y = true) = (x ≤ y)",
  "offspring": ["Nat.le_of_ble_eq_true", "Nat.ble_eq_true_of_le"],
  "name": "Nat.ble_eq"},
 {"type": "{A : Type u} → [self : SubNegMonoid A] → Neg A",
  "offspring": [],
  "name": "SubNegMonoid.toNeg"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk", "Fin.land", "USize.size"],
  "name": "USize.land"},
 {"type": "∀ {α : Sort u} {p : α → Prop}, (∃ y, p y) → p (Classical.epsilon p)",
  "offspring": ["Classical.epsilon_spec_aux", "nonempty_of_exists"],
  "name": "Classical.epsilon_spec"},
 {"type": "∀ (b : Bool), (b && b) = b",
  "offspring": [],
  "name": "Bool.and_self"},
 {"type": "{R : Type u} → [self : Semiring R] → MonoidWithZero R",
  "offspring":
  ["MonoidWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "Semiring.toMonoidWithZero"},
 {"type": "Tactic.NormCast.NormCastExtension",
  "offspring": [],
  "name": "Tactic.NormCast.normCastExt"},
 {"type":
  "∀ {m : Type u → Type u_1} {β α σ : Type u} [inst : Monad m] (x : m α) (s : σ) (k : α → σ → m β),\n  StateCpsT.runK (StateCpsT.lift x) s k = do\n    let a ← x\n    k a s",
  "offspring": [],
  "name": "StateCpsT.runK_lift"},
 {"type":
  "{α₁ α₂ α₃ α₄ α₅ α₆ β : Type u} →\n  [inst : Inhabited β] →\n    ((α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β",
  "offspring": ["fixCore6", "Inhabited.default"],
  "name": "fix6"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → Sort u_1 → MonadReaderOf ρ m → MonadReaderOf ρ m → Sort u_1",
  "offspring": [],
  "name": "MonadReaderOf.noConfusionType"},
 {"type":
  "∀ {M : Type u_1} [inst : Monoid M] (a : M) (m n : ℕ), a ^ (m * n) = (a ^ m) ^ n",
  "offspring":
  ["Nat.zero_eq",
   "Nat.mul_zero",
   "pow_zero",
   "Nat.mul_succ",
   "pow_add",
   "pow_succ'",
   "pow_mul_comm"],
  "name": "pow_mul"},
 {"type": "{α : Type u_1} → {β : Type u_2} → Option α → β → (α → β) → β",
  "offspring": [],
  "name": "Option.elim"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (m₁ m₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_le ctx (Nat.Linear.Poly.cancel m₁ m₂) = Nat.Linear.Poly.denote_le ctx (m₁, m₂)",
  "offspring":
  ["Nat.Linear.Poly.of_denote_le_cancel", "Nat.Linear.Poly.denote_le_cancel"],
  "name": "Nat.Linear.Poly.denote_le_cancel_eq"},
 {"type": "{α : Sort u} → Nonempty α → α",
  "offspring": [],
  "name": "Classical.choice"},
 {"type": "{α : Type u_1} → [inst : OfNat α 0] → Zero α",
  "offspring": ["Zero.mk"],
  "name": "instZero"},
 {"type": "{ε : Type u} → {α : Type v} → ε → Except ε α",
  "offspring": [],
  "name": "Except.error"},
 {"type": "{n : ℕ} → Sub (Fin n)",
  "offspring": ["Sub.mk", "Fin.sub"],
  "name": "Fin.instSubFin"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2}, (α → β) → (β → α) → (Nonempty α ↔ Nonempty β)",
  "offspring": ["Nonempty.map"],
  "name": "Nonempty.congr"},
 {"type": "(a b : UInt8) → Decidable (a < b)",
  "offspring": ["UInt8.decLt"],
  "name": "instDecidableLtUInt8InstLTUInt8"},
 {"type":
  "{G : Type u} → [inst : Mul G] → (∀ (a b c : G), b * a = c * a → b = c) → IsMulRightCancel G",
  "offspring": [],
  "name": "IsMulRightCancel.mk"},
 {"type": "Type u → (Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "MonadWithReaderOf"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ b ≤ a",
  "offspring": ["lt_of_not_ge"],
  "name": "lt_or_le"},
 {"type": "{ε σ : Type u} → MonadStateOf σ (EStateM ε σ)",
  "offspring":
  ["MonadStateOf.mk", "EStateM.get", "EStateM.set", "EStateM.modifyGet"],
  "name": "EStateM.instMonadStateOfEStateM"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (fst : α) (snd : β) (fst_1 : α) (snd_1 : β),\n  ({ fst := fst, snd := snd } = { fst := fst_1, snd := snd_1 }) = (fst = fst_1 ∧ snd = snd_1)",
  "offspring": ["PProd.mk"],
  "name": "PProd.mk.injEq"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {n : ℕ}, n < List.length l₁ → List.get? (l₁ ++ l₂) n = List.get? l₁ n",
  "offspring": [],
  "name": "List.get?_append"},
 {"type": "∀ (a b : ℕ), Nat.min a b = Nat.min b a",
  "offspring":
  ["ite_true",
   "Nat.le_antisymm",
   "instDecidableFalse",
   "ite_false",
   "not_or_intro",
   "Nat.le_or_le"],
  "name": "Nat.min_comm"},
 {"type":
  "∀ {α : Sort u} {t : True → α} {e : ¬True → α}, dite True t e = t True.intro",
  "offspring": [],
  "name": "dite_true"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {n : ℕ},\n  List.length l₁ ≤ n →\n    ∀ (h₂ : n < List.length (l₁ ++ l₂)),\n      List.get (l₁ ++ l₂) { val := n, isLt := h₂ } =\n        List.get l₂ { val := n - List.length l₁, isLt := (_ : n - List.length l₁ < List.length l₂) }",
  "offspring":
  ["Option.some.inj",
   "List.get?_eq_get",
   "List.get?",
   "List.get?_append_right"],
  "name": "List.get_append_right'"},
 {"type": "(α : Sort u) → α → ℕ", "offspring": [], "name": "default.sizeOf"},
 {"type":
  "{α : Sort u} →\n  {C : α → Sort v} → {r : α → α → Prop} → WellFounded r → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → C x",
  "offspring": ["WellFounded.fix'.impl"],
  "name": "WellFounded.fix'.impl"},
 {"type":
  "∀ {e : Lean.Expr} {coeff : ℕ} {e_1 : Lean.Expr} {coeff_1 : ℕ},\n  Tactic.Ring.HornerExpr.const e coeff = Tactic.Ring.HornerExpr.const e_1 coeff_1 → e = e_1 ∧ coeff = coeff_1",
  "offspring": [],
  "name": "Tactic.Ring.HornerExpr.const.inj"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, c ≤ a → c ≤ b → c ≤ min a b",
  "offspring":
  ["if_pos", "instDecidableLeToLEToPreorderToPartialOrder", "if_neg"],
  "name": "le_min"},
 {"type": "Nat.Linear.PolyCnstr → Nat.Linear.Poly",
  "offspring": [],
  "name": "Nat.Linear.PolyCnstr.lhs"},
 {"type": "Tactic.NormCast.Label",
  "offspring": [],
  "name": "Tactic.NormCast.Label.elim"},
 {"type": "Sort u → FloatSpec → FloatSpec → Sort u",
  "offspring": [],
  "name": "FloatSpec.noConfusionType"},
 {"type": "USize → Fin USize.size", "offspring": [], "name": "USize.val"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∃ x, x ∈ a :: l ∧ p x) → p a ∨ ∃ x, x ∈ l ∧ p x",
  "offspring": [],
  "name": "List.or_exists_of_exists_mem_cons"},
 {"type":
  "{α : outParam (Type u)} → {γ : Type v} → Sort u_1 → Membership α γ → Membership α γ → Sort u_1",
  "offspring": [],
  "name": "Membership.noConfusionType"},
 {"type": "{α : Type u} → Sort u_1 → Sdiff α → Sdiff α → Sort u_1",
  "offspring": [],
  "name": "Sdiff.noConfusionType"},
 {"type": "ℕ → ℕ → StdGen", "offspring": [], "name": "StdGen.mk"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f : α → β}, Function.surjective f ↔ Function.has_RightInverse f",
  "offspring":
  ["Function.surjective.has_RightInverse",
   "Function.has_RightInverse.surjective"],
  "name": "Function.surjective_iff_has_RightInverse"},
 {"type": "∀ (a b : USize), a + b = { val := a.val + b.val }",
  "offspring": [],
  "name": "USize.add_def"},
 {"type": "{α : Type u_1} → Option α → Bool",
  "offspring": [],
  "name": "Option.isSome"},
 {"type": "ℕ → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.Expr.num"},
 {"type": "∀ (x x_1 : UInt16), { val := (x + x_1).1 } = { val := (x_1 + x).1 }",
  "offspring": ["UInt16.mk", "AddCommSemigroup.add_comm"],
  "name": "UInt16.instAddCommSemigroupUInt16.proof_1"},
 {"type": "{α : Type u} → [self : Mul α] → α → α → α",
  "offspring": [],
  "name": "Mul.mul"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {g : β → Option α}, Function.is_partial_inv f g → Function.injective f",
  "offspring": ["Option.some.inj"],
  "name": "Function.injective_of_partial_inv"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop}\n  {motive : (a : List α) → (a_1 : List β) → List.Forall₂ R a a_1 → Prop} {a : α} {b : β} {l₁ : List α} {l₂ : List β},\n  R a b →\n    ∀ {a_2 : List.Forall₂ R l₁ l₂},\n      List.Forall₂.below a_2 → motive l₁ l₂ a_2 → List.Forall₂.below (_ : List.Forall₂ R (a :: l₁) (b :: l₂))",
  "offspring": [],
  "name": "List.Forall₂.below.cons"},
 {"type": "Type u → Type u", "offspring": [], "name": "Div"},
 {"type":
  "∀ {p : Prop} {ps : List Prop} (f : Sat.Fmla),\n  Sat.Fmla.proof f [] → (∀ (v : Sat.Valuation), Sat.Valuation.implies v (Sat.Fmla.reify v f p) ps 0) → p",
  "offspring":
  ["Sat.Fmla.reify.prop",
   "Sat.Valuation.mk_implies",
   "Sat.Valuation.mk",
   "List.reverseAux"],
  "name": "Sat.Fmla.refute"},
 {"type": "∀ {a b : Prop}, a → b → (a ↔ b)",
  "offspring": [],
  "name": "iff_of_true"},
 {"type": "∀ {α : Type u_1} (l l₁ l₂ : List α), l ⊆ l₁ → l ⊆ l₁ ++ l₂",
  "offspring": ["List.subset.trans", "List.subset_append_left"],
  "name": "List.subset_append_of_subset_left"},
 {"type": "{α β σ : Type u} → α → σ → DoResultPRBC α β σ",
  "offspring": [],
  "name": "DoResultPRBC.pure"},
 {"type":
  "∀ {α : Type u₁} {β : Type u₂} {φ : Type u₃} (f : α → β → φ), Function.curry (Function.uncurry f) = f",
  "offspring": [],
  "name": "Function.curry_uncurry"},
 {"type":
  "{α : Type u} → {inst : Preorder α} → Sort u_1 → BoundedRandom α → BoundedRandom α → Sort u_1",
  "offspring": [],
  "name": "BoundedRandom.noConfusionType"},
 {"type": "∀ (a b : UInt64), a - b = { val := a.val - b.val }",
  "offspring": [],
  "name": "UInt64.sub_def"},
 {"type": "∀ {a b c : ℤ}, a + b ≤ c → a ≤ c - b",
  "offspring": [],
  "name": "Int.le_sub_right_of_add_le"},
 {"type": "Tactic.NormCast.CoeFnInfo → ℕ",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnInfo.numArgs"},
 {"type": "{α : Type u_1} → Sdiff (Set α)",
  "offspring": ["Sdiff.mk", "Set.diff"],
  "name": "Set.instSdiffSet"},
 {"type": "∀ {p : Prop}, (¬p → False) → p",
  "offspring": ["Decidable.by_contradiction"],
  "name": "by_contradiction"},
 {"type": "{α : Type u} → {β : Type v} → (β → α → β) → Prop",
  "offspring": [],
  "name": "right_commutative"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«termListΣ»"},
 {"type": "∀ {k n m : ℕ}, k + n < k + m → n < m",
  "offspring":
  ["Nat.lt_of_le_of_ne",
   "Nat.le_of_add_le_add_left",
   "Nat.le_of_lt",
   "Nat.lt_irrefl"],
  "name": "Nat.lt_of_add_lt_add_left"},
 {"type": "{n : ℕ} → HMod (Fin n) ℕ (Fin n)",
  "offspring": ["HMod.mk", "Fin.modn"],
  "name": "Fin.instHModFinNat"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × Option β)",
  "offspring": ["List.map₂Left"],
  "name": "List.zipLeft"},
 {"type": "{R : Type u_1} → [inst : AddMonoidWithOne R] → ℕ → R",
  "offspring": ["AddMonoidWithOne.natCast"],
  "name": "Nat.cast"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → ℕ → (ℕ → m Unit) → ℕ → m Unit",
  "offspring": [],
  "name": "Nat.forM.loop"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → {α : Type u} → m (Except ε α) → ExceptT ε m α",
  "offspring": [],
  "name": "ExceptT.mk"},
 {"type": "LawfulBEq ℕ",
  "offspring": ["LawfulBEq.mk", "Nat.eq_of_beq_eq_true", "Nat.beq_refl"],
  "name": "Nat.instLawfulBEqNatInstBEqNat.proof_1"},
 {"type":
  "∀ {α : Type s} (down down_1 : α), ({ down := down } = { down := down_1 }) = (down = down_1)",
  "offspring": ["ulift.up"],
  "name": "ulift.up.injEq"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [self : LawfulApplicative f] {α β γ : Type u} (x : f α) (g : f (α → β))\n  (h : f (β → γ)),\n  (Seq.seq h fun x_1 => Seq.seq g fun x_2 => x) = Seq.seq (Seq.seq (Function.comp <$> h) fun x => g) fun x_1 => x",
  "offspring": [],
  "name": "LawfulApplicative.seq_assoc"},
 {"type":
  "∀ {α β φ : Sort u} {a : α} {b : β} {c : φ}, HEq a b → HEq b c → HEq a c",
  "offspring": ["HEq.subst"],
  "name": "HEq.trans"},
 {"type": "UInt16 → UInt8",
  "offspring": ["Nat.toUInt8", "UInt16.toNat"],
  "name": "UInt16.toUInt8"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term#[_,]»"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Util.includeStr"},
 {"type": "Type u → Type u", "offspring": [], "name": "Ord"},
 {"type": "{α : Type u} → (α → α → α) → Union α",
  "offspring": [],
  "name": "Union.mk"},
 {"type":
  "∀ {m : Type u → Type u_1} {α β : Type u} [inst : Monad m] [inst_1 : LawfulMonad m] (mf : m (α → β)) (x : m α),\n  (Seq.seq mf fun x_1 => x) = do\n    let f ← mf\n    f <$> x",
  "offspring": ["LawfulMonad.bind_map"],
  "name": "seq_eq_bind"},
 {"type": "∀ (m n : ℕ), m ∣ Nat.lcm m n",
  "offspring": ["Nat.mul_div_assoc", "Nat.gcd_dvd_right"],
  "name": "Nat.dvd_lcm_left"},
 {"type":
  "∀ {α : Type u_1} (a : α) (s t : List α), (a ∈ s ++ t) = (a ∈ s ∨ a ∈ t)",
  "offspring": ["List.mem_append"],
  "name": "List.mem_append_eq"},
 {"type": "∀ {n m : ℕ}, n ≤ m → n ≤ Nat.succ m",
  "offspring": ["Nat.le.step"],
  "name": "Nat.le_step"},
 {"type":
  "∀ (as : ByteArray) (i : ℕ), i + 1 ≤ ByteArray.size as → ByteArray.size as - 1 - i < ByteArray.size as",
  "offspring":
  ["Nat.lt_of_le_of_lt",
   "Nat.sub_le",
   "Nat.sub_lt",
   "Nat.zero_lt_of_lt",
   "Nat.lt_of_lt_of_le",
   "Nat.lt_succ_self"],
  "name": "ByteArray.forIn.loop.proof_1"},
 {"type":
  "{α : Type u} → {n : ℕ} → (a : Array α) → (i : ℕ) → Array.size a = n → i < n → α",
  "offspring": ["Array.get", "Array.getLit.proof_1"],
  "name": "Array.getLit"},
 {"type": "Substring → optParam String \" \" → List Substring",
  "offspring": [],
  "name": "Substring.splitOn"},
 {"type": "∀ {α : Type u_1} {o : Option α}, o ≠ none ↔ ∃ x, o = some x",
  "offspring":
  ["Iff.trans", "Option.ne_none_iff_exists", "exists_congr", "eq_comm"],
  "name": "Option.ne_none_iff_exists'"},
 {"type": "Sort u → ℕ → ℕ → Sort u",
  "offspring": [],
  "name": "Nat.noConfusionType"},
 {"type":
  "Trans (fun a a_1 => a < a_1) (fun a a_1 => a < a_1) fun a a_1 => a < a_1",
  "offspring": ["Trans.mk", "Nat.instTransNatLtInstLTNat.proof_1"],
  "name": "Nat.instTransNatLtInstLTNat"},
 {"type": "ℕ → String",
  "offspring": ["List.asString", "Nat.toSuperDigits"],
  "name": "Nat.toSuperscriptString"},
 {"type":
  "{α : Type u} → {β : Type v} → α → (k : USize → β) → (∀ (u₁ u₂ : USize), k u₁ = k u₂) → β",
  "offspring": [],
  "name": "withPtrAddr"},
 {"type": "∀ (x z : ℕ), (x + z) % z = x % z",
  "offspring": ["Nat.mod_eq_sub_mod", "Nat.le_add_left", "Nat.add_sub_cancel"],
  "name": "Nat.add_mod_right"},
 {"type":
  "{α : Type u} → (P : α → Prop) → [inst : DecidablePred P] → List α → (List α → List α) → List (List α)",
  "offspring": [],
  "name": "List.splitOnPAux"},
 {"type": "Float → Float", "offspring": [], "name": "Float.atanh"},
 {"type": "LawfulBEq Nat.Linear.PolyCnstr",
  "offspring": ["LawfulBEq.mk"],
  "name": "Nat.Linear.instLawfulBEqPolyCnstrInstBEqPolyCnstr.proof_1"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "Equiv"},
 {"type":
  "∀ {α : Sort u} {c : Prop} {d : Decidable c} (a : α), (if c then a else a) = a",
  "offspring": [],
  "name": "ite_self"},
 {"type":
  "∀ {R : Type u} [self : AddMonoidWithOne R], AddMonoidWithOne.natCast 0 = 0",
  "offspring": [],
  "name": "AddMonoidWithOne.natCast_zero"},
 {"type": "∀ {p : Prop} [s : Decidable p], decide p = false → ¬p",
  "offspring": ["ne_false_of_eq_true", "decide_eq_true"],
  "name": "of_decide_eq_false"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a b : Fin n), a * b = b * a",
  "offspring": ["CommSemiring.mul_comm"],
  "name": "instCommRingFin.proof_8"},
 {"type": "Lean.Expr → Lean.Expr → Lean.MetaM (Option Lean.Meta.Simp.Result)",
  "offspring":
  ["Tactic.NormCast.NormCastExtension.down",
   "Tactic.NormCast.normCastExt",
   "Tactic.NormCast.proveEqUsing"],
  "name": "Tactic.NormCast.proveEqUsingDown"},
 {"type": "{α : Type u} → ℕ → α → List α",
  "offspring": [],
  "name": "List.replicateTR"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "Nat.«term_^[_]»"},
 {"type": "∀ {α : Type u_1} {a : α} {b : Option α}, a ∈ b ↔ b = some a",
  "offspring": ["Iff.rfl"],
  "name": "Option.mem_def"},
 {"type": "(ℕ → Bool) → ℕ × ℕ → Bool",
  "offspring": ["Nat.anyAux"],
  "name": "Prod.anyI"},
 {"type": "{α : Type u_1} → [inst : Repr α] → α → Lean.Format",
  "offspring": [],
  "name": "repr"},
 {"type": "{α : Type u_1} → {n : ℕ} → (Fin n → α) → List α",
  "offspring": ["List.ofFnAux", "Nat.le_refl"],
  "name": "List.ofFn"},
 {"type":
  "{n : ℕ} →\n  (m : UFModel n) →\n    (x y : Fin n) → ↑x ≠ ↑y → UFModel.rank m ↑x ≤ UFModel.rank m ↑y → ↑(UFModel.parent m y) = ↑y → UFModel n",
  "offspring":
  ["UFModel.mk",
   "UFModel.parent",
   "UFModel.rank",
   "UFModel.setParentBump.proof_1"],
  "name": "UFModel.setParentBump"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (i : ℕ), i + 1 ≤ Array.size as → i < Array.size as",
  "offspring": ["Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "Array.findSomeRevM?.find.proof_1"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "termIfThenElse"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop} {val : α} {property : p val} {val_1 : α} {property_1 : p val_1},\n  { val := val, property := property } = { val := val_1, property := property_1 } → val = val_1",
  "offspring": [],
  "name": "Subtype.mk.inj"},
 {"type": "∀ (n m : Fin UInt16.size), n = m → { val := n } = { val := m }",
  "offspring": [],
  "name": "UInt16.decEq.proof_1"},
 {"type":
  "∀ {α : Type s} {down down_1 : α}, { down := down } = { down := down_1 } → down = down_1",
  "offspring": [],
  "name": "ulift.up.inj"},
 {"type": "∀ (p : Prop), (p ∨ True) = True",
  "offspring": ["trivial"],
  "name": "or_true"},
 {"type":
  "{A : Type u} → {inst : Add A} → Sort u_1 → IsAddLeftCancel A → IsAddLeftCancel A → Sort u_1",
  "offspring": [],
  "name": "IsAddLeftCancel.noConfusionType"},
 {"type":
  "∀ (p : ℕ → Prop) (m : ℕ), (∀ (n : ℕ), n < m → ¬p n) → p m → p m ∧ ∀ (m_1 : ℕ), m_1 < m → ¬p m_1",
  "offspring": [],
  "name": "Nat.find_x.proof_1"},
 {"type":
  "{p q : Prop} → [inst : Decidable p] → [inst : Decidable q] → {α : Sort u} → p ∨ q → (p → α) → (q → α) → α",
  "offspring": ["Or.elim"],
  "name": "Or.by_cases"},
 {"type":
  "∀ {α β : Type u_1} {x : Option α} {f : α → β}, f <$> x = none ↔ x = none",
  "offspring": ["Option.map_eq_none'"],
  "name": "Option.map_eq_none"},
 {"type": "{α : Type u} → {β : Type v} → (α → β) → List α → List β",
  "offspring": [],
  "name": "List.map"},
 {"type": "{α : Type u} → Array α → (α → Bool) → Option ℕ",
  "offspring": [],
  "name": "Array.findIdx?"},
 {"type": "∀ {a b c : Prop}, (b ↔ c) → (a ∧ b ↔ a ∧ c)",
  "offspring": ["and_congr", "Iff.rfl"],
  "name": "and_congr_right'"},
 {"type":
  "∀ {α : Type u_1} (j : ℕ) (a : Array α), j < Array.size a → ∀ (j' : ℕ), j = j' + 1 → j' < Array.size a",
  "offspring": ["Nat.lt_trans", "Nat.lt_succ_self"],
  "name": "Array.insertionSort.swapLoop.proof_1"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β → β) → β → List α → β × List β",
  "offspring": [],
  "name": "List.scanrAux"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["Nat.max"], "name": "Nat.imax"},
 {"type":
  "∀ {α : Type u_1} (b : α) (bs : List α), [] = b :: bs → List.noConfusionType False [] (b :: bs)",
  "offspring": [],
  "name": "List.hasDecEq.proof_3"},
 {"type":
  "{g : Type u} → (g → ℕ × ℕ) → (g → ℕ × g) → (g → g × g) → RandomGen g",
  "offspring": [],
  "name": "RandomGen.mk"},
 {"type": "Type u", "offspring": [], "name": "PNonScalar"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk"],
  "name": "UInt64.add"},
 {"type": "∀ {a b : ℤ}, 0 < a → 0 < b → 0 < a + b",
  "offspring": ["Int.add_lt_add", "Int.zero_add"],
  "name": "Int.add_pos"},
 {"type":
  "{α : Sort u_1} → [inst : Setoid α] → (p : α → Prop) → Setoid (Subtype p)",
  "offspring": ["Setoid.mk", "HasEquiv.Equiv", "Subtype.equivalence"],
  "name": "Subtype.instSetoidSubtype"},
 {"type": "∀ {α : Type u_1} {o : Option α}, o ≠ none ↔ Option.isSome o = true",
  "offspring":
  ["ne_eq",
   "eq_false_of_decide",
   "Option.isSome_none",
   "eq_false'",
   "Option.isSome_some"],
  "name": "Option.ne_none_iff_isSome"},
 {"type": "Append ByteArray",
  "offspring": ["Append.mk", "ByteArray.append"],
  "name": "ByteArray.instAppendByteArray"},
 {"type": "∀ (m : ℕ), Nat.lcm 0 m = 0",
  "offspring": [],
  "name": "Nat.lcm_zero_left"},
 {"type":
  "Lean.Meta.SimpTheorems → Lean.Expr → Lean.Expr → Lean.MetaM (Option Lean.Meta.Simp.Result)",
  "offspring": ["StateRefT'.run'"],
  "name": "Tactic.NormCast.proveEqUsing"},
 {"type":
  "{α : Sort u} → {a : α} → {β : Sort v} → Sort u_1 → CoeDep α a β → CoeDep α a β → Sort u_1",
  "offspring": [],
  "name": "CoeDep.noConfusionType"},
 {"type": "∀ (p : Prop), (False ↔ p) = ¬p",
  "offspring": [],
  "name": "false_iff"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {g : β → Option α},\n  Function.is_partial_inv f g → ∀ (x y : β) (b : α), g x = some b → g y = some b → x = y",
  "offspring": [],
  "name": "Function.injective_of_partial_inv_right"},
 {"type": "∀ (m n : ℕ), Nat.gcd m n = Nat.gcd (n % m) m",
  "offspring": ["Nat.gcd_succ"],
  "name": "Nat.gcd_rec"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {f : α → α} (h : ∀ (a : α), p a → p (f a)),\n  Function.involutive f → Function.involutive (Subtype.map f h)",
  "offspring": ["Subtype.ext"],
  "name": "Subtype.map_involutive"},
 {"type": "∀ {a b : Prop}, ¬(a → b) → a",
  "offspring": ["Decidable.of_not_imp"],
  "name": "of_not_imp"},
 {"type":
  "∀ {M : Type u_1} [inst : CommMonoid M] (a b : M) (n : ℕ), (a * b) ^ n = a ^ n * b ^ n",
  "offspring":
  ["Nat.zero_eq",
   "pow_zero",
   "mul_one",
   "pow_succ",
   "Semigroup.mul_assoc",
   "mul_left_comm"],
  "name": "mul_pow"},
 {"type": "Type → Type",
  "offspring": ["Sum", "Task", "Except"],
  "name": "Tactic.Cache"},
 {"type": "(α : Sort u) → SizeOf α",
  "offspring": ["SizeOf.mk", "default.sizeOf"],
  "name": "instSizeOf"},
 {"type":
  "{α₁ α₂ α₃ α₄ α₅ β : Type u} →\n  (α₁ → α₂ → α₃ → α₄ → α₅ → β) →\n    ((α₁ → α₂ → α₃ → α₄ → α₅ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → β) → ℕ → α₁ → α₂ → α₃ → α₄ → α₅ → β",
  "offspring": [],
  "name": "bfix5"},
 {"type": "∀ (a : UInt16), 0 * a = 0",
  "offspring":
  ["UInt16.zero_def", "UInt16.mul_def", "UInt16.mk", "MonoidWithZero.zero_mul"],
  "name": "UInt16.instSemiringUInt16.proof_9"},
 {"type":
  "Mathlib.Prelude.Rename.RenameMap → Lean.Name × Lean.Name → Mathlib.Prelude.Rename.RenameMap",
  "offspring": [],
  "name": "Mathlib.Prelude.Rename.RenameMap.insertPair"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {b : β} {l : List α}, b ∈ List.map f l ↔ ∃ a, a ∈ l ∧ b = f a",
  "offspring":
  ["List.not_mem_nil",
   "false_and",
   "exists_false",
   "List.map_cons",
   "List.mem_cons",
   "List.Mem.head",
   "List.Mem.tail"],
  "name": "List.mem_map"},
 {"type":
  "{ω σ : Type} →\n  {m : Type → Type} → [inst : Monad m] → [inst : MonadLiftT (ST ω) m] → {α : Type} → StateRefT' ω σ m α → σ → m α",
  "offspring": ["StateRefT'.run"],
  "name": "StateRefT'.run'"},
 {"type":
  "∀ {α : Type u} [self : Preorder α] (a b c : α), a ≤ b → b ≤ c → a ≤ c",
  "offspring": [],
  "name": "Preorder.le_trans"},
 {"type": "∀ (x : UInt16), { val := AddMonoid.nsmul 0 x.val } = { val := 0.1 }",
  "offspring": ["AddMonoid.nsmul_zero'"],
  "name": "UInt16.instSemiringUInt16.proof_4"},
 {"type": "∀ (n : ℕ), Nat.gcd 1 n = 1",
  "offspring": ["Nat.gcd", "Nat.gcd_succ", "Nat.mod_one"],
  "name": "Nat.gcd_one_left"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → [self : MonadControlT m n] → {α : Type u} → (({β : Type u} → n β → m (stM m n β)) → m α) → n α",
  "offspring": [],
  "name": "MonadControlT.liftWith"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HAppend"},
 {"type": "∀ {p q : Prop}, (p ↔ p ∧ q) ↔ p → q",
  "offspring": ["Iff.comm", "and_iff_left_iff_imp", "Iff.rfl"],
  "name": "iff_self_and"},
 {"type": "∀ (m n k : ℕ), m - n - k = m - k - n",
  "offspring": ["Nat.sub_sub"],
  "name": "Nat.sub.right_comm"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (x : α) (i : Fin (Array.size (Array.push a x))),\n  Array.get (Array.push a x) i = if h : ↑i < Array.size a then Array.get a { val := ↑i, isLt := h } else x",
  "offspring":
  ["dif_pos",
   "Option.some.inj",
   "Array.get?_eq_get",
   "Array.get?_push_lt",
   "dif_neg",
   "le_antisymm",
   "Nat.le_of_lt_succ",
   "Array.size_push",
   "le_of_not_lt",
   "Nat.instLinearOrderNat",
   "Array.get?_push_eq"],
  "name": "Array.get_push"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "variables"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, (∃ x, p x) → Nonempty α",
  "offspring": ["Exists.elim"],
  "name": "Classical.inhabited_of_exists.proof_1"},
 {"type":
  "{α : Type u} →\n  {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (α → β → m β) → Array α → USize → USize → β → m β",
  "offspring": ["Array.uget", "lcProof", "Array.foldrMUnsafe.fold"],
  "name": "Array.foldrMUnsafe.fold"},
 {"type":
  "∀ {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} {a₁ : α} {b₁ : β} {a₂ : α} {b₂ : β},\n  ra a₁ a₂ → rb b₁ b₂ → Prod.RProd ra rb (a₁, b₁) (a₂, b₂)",
  "offspring": [],
  "name": "Prod.RProd.intro"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«term∀__,_»"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_≃_»"},
 {"type": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a",
  "offspring":
  ["HPow.hPow", "Nat.one_eq_succ_zero", "pow_succ", "pow_zero", "one_mul"],
  "name": "pow_one"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α} {s₁ s₂ : List β},\n  List.map f l = s₁ ++ s₂ → ∃ l₁ l₂, l = l₁ ++ l₂ ∧ List.map f l₁ = s₁ ∧ List.map f l₂ = s₂",
  "offspring": [],
  "name": "List.map_eq_append_split"},
 {"type": "sizeOf Ordering.gt = 1",
  "offspring": [],
  "name": "Ordering.gt.sizeOf_spec"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk"],
  "name": "UInt8.sub"},
 {"type":
  "{g : Type} → (α : Type u) → [inst : Random α] → [inst : RandomGen g] → RandG g α",
  "offspring": ["Random.random"],
  "name": "Random.rand"},
 {"type": "∀ (a : USize), a * 0 = 0",
  "offspring":
  ["USize.zero_def", "USize.mul_def", "USize.mk", "MonoidWithZero.mul_zero"],
  "name": "USize.instSemiringUSize.proof_10"},
 {"type": "∀ {p : Prop} [s : Decidable p], ¬p → decide p = false",
  "offspring": [],
  "name": "decide_eq_false"},
 {"type": "Type u → Type u", "offspring": [], "name": "Semigroup"},
 {"type": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "offspring": [],
  "name": "Exists.intro"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b ∨ a = b → a ≤ b",
  "offspring": ["le_of_lt", "le_refl"],
  "name": "le_of_lt_or_eq"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "stx_?"},
 {"type": "∀ (m n : ℕ), -[1+ m] * Int.negOfNat n = Int.ofNat (Nat.succ m * n)",
  "offspring": [],
  "name": "Int.negSucc_ofNat_mul_negOfNat"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} {f : α → β} {c : γ}, Function.const β c ∘ f = Function.const α c",
  "offspring": [],
  "name": "Function.const_comp"},
 {"type":
  "∀ {k : ℕ} {a : Nat.Linear.Expr} {k_1 : ℕ} {a_1 : Nat.Linear.Expr},\n  Nat.Linear.Expr.mulL k a = Nat.Linear.Expr.mulL k_1 a_1 → k = k_1 ∧ a = a_1",
  "offspring": [],
  "name": "Nat.Linear.Expr.mulL.inj"},
 {"type": "{α : Type u_1} → Option α → List α",
  "offspring": [],
  "name": "Option.toList"},
 {"type":
  "{A : Type u} → Sort u_1 → AddCommSemigroup A → AddCommSemigroup A → Sort u_1",
  "offspring": [],
  "name": "AddCommSemigroup.noConfusionType"},
 {"type":
  "∀ {M : Type u_1} [inst : CommSemigroup M] (a b c : M), a * b * c = a * c * b",
  "offspring": ["Semigroup.mul_assoc", "CommSemigroup.mul_comm"],
  "name": "mul_right_comm"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a < b ∨ a = b",
  "offspring": ["Decidable.lt_or_eq_of_le"],
  "name": "lt_or_eq_of_le"},
 {"type": "Mathlib.Tactic.Lint.NamedLinter → Lean.Name",
  "offspring": ["Mathlib.Tactic.Lint.NamedLinter.declName"],
  "name": "Mathlib.Tactic.Lint.NamedLinter.name"},
 {"type": "Lean.CoreM (Array Lean.Name)",
  "offspring": ["Array.map"],
  "name": "Mathlib.Tactic.Lint.getDeclsInCurrModule"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (a b c d : Nat.Linear.Expr),\n  Nat.Linear.Poly.cancel (Nat.Linear.Expr.toNormPoly (Nat.Linear.Expr.inc a)) (Nat.Linear.Expr.toNormPoly b) =\n      (Nat.Linear.Expr.toPoly (Nat.Linear.Expr.inc c), Nat.Linear.Expr.toPoly d) →\n    (Nat.Linear.Expr.denote ctx a < Nat.Linear.Expr.denote ctx b) =\n      (Nat.Linear.Expr.denote ctx c < Nat.Linear.Expr.denote ctx d)",
  "offspring": ["Nat.Linear.Expr.of_cancel_le", "Nat.Linear.Expr.inc"],
  "name": "Nat.Linear.Expr.of_cancel_lt"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [inst : MonadExcept ε m] → {α : Type v} → OrElse (m α)",
  "offspring": ["OrElse.mk", "MonadExcept.orElse"],
  "name": "MonadExcept.instOrElse"},
 {"type":
  "∀ {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} {a₁ : α} (b₁ : β) {a₂ : α} (b₂ : β),\n  ra a₁ a₂ → Prod.Lex ra rb (a₁, b₁) (a₂, b₂)",
  "offspring": [],
  "name": "Prod.Lex.left"},
 {"type":
  "∀ (α : Lean.Expr) (univ : Lean.Level) (cs : Lean.Expr),\n  sizeOf { α := α, univ := univ, cs := cs } = 1 + sizeOf α + sizeOf univ + sizeOf cs",
  "offspring": [],
  "name": "Tactic.Ring.Cache.mk.sizeOf_spec"},
 {"type": "{α : Type u} → Sort u_1 → AndThen α → AndThen α → Sort u_1",
  "offspring": [],
  "name": "AndThen.noConfusionType"},
 {"type":
  "∀ (a b : ℕ), Int.ofNat a = -[1+ b] → Int.noConfusionType False (Int.ofNat a) -[1+ b]",
  "offspring": [],
  "name": "Int.decEq.proof_5"},
 {"type": "Array Lean.Expr → ℕ → Tactic.Ring.State",
  "offspring": [],
  "name": "Tactic.Ring.State.mk"},
 {"type":
  "∀ {α : Type u_1} (a y : α) (l : List α), (a ∈ y :: l) = (a = y ∨ a ∈ l)",
  "offspring": ["List.mem_cons"],
  "name": "List.mem_cons_eq"},
 {"type":
  "ℕ → Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly × Nat.Linear.Poly",
  "offspring": ["List.reverse", "cond", "Nat.blt", "Nat.sub"],
  "name": "Nat.Linear.Poly.cancelAux"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk"],
  "name": "USize.mod"},
 {"type":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a → q a) → ∀ (a : ∀ (a : α), p a) (a : α), q a",
  "offspring": [],
  "name": "forall_imp"},
 {"type": "∀ {a b : Prop}, ¬a → ((a ↔ b) ↔ ¬b)",
  "offspring": ["mt", "iff_of_false"],
  "name": "iff_false_left"},
 {"type": "{α : Type u_1} → List α → List (α × α)",
  "offspring": ["List.zip", "List.reverse"],
  "name": "List.revzip"},
 {"type":
  "∀ {α : Type u} (as bs : List α), List.reverseAux as bs = List.reverseAux as [] ++ bs",
  "offspring": ["List.nil_append", "List.append_assoc"],
  "name": "List.reverseAux_eq_append"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (fuel : ℕ) (m₁ m₂ r₁ r₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_le ctx (Nat.Linear.Poly.cancelAux fuel m₁ m₂ r₁ r₂) →\n    Nat.Linear.Poly.denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)",
  "offspring":
  ["Nat.blt", "Nat.Linear.Poly.cancelAux", "List.append_nil", "Nat.sub_eq"],
  "name": "Nat.Linear.Poly.of_denote_le_cancelAux"},
 {"type": "∀ {α : Sort u_1} {a b : α}, HEq a b ↔ a = b",
  "offspring": ["heq_of_eq"],
  "name": "heq_iff_eq"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, b < a → min a b = b",
  "offspring": ["min_eq_right", "le_of_lt"],
  "name": "min_eq_right_of_lt"},
 {"type": "∀ (a : UInt64), -a + a = 0",
  "offspring":
  ["UInt64.eq_of_val_eq",
   "UInt64.neg_def",
   "UInt64.add_def",
   "UInt64.mk",
   "add_left_neg",
   "UInt64.zero_def"],
  "name": "UInt64.instRingUInt64.proof_6"},
 {"type": "∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p self.val",
  "offspring": [],
  "name": "Subtype.property"},
 {"type": "∀ {a b : ℤ}, -a ≤ b → -b ≤ a",
  "offspring": [],
  "name": "Int.neg_le_of_neg_le"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) (Int.ofNat x) = (fun n => { val := ↑n }) (Int.ofNat x)",
  "offspring": [],
  "name": "UInt64.instRingUInt64.proof_7"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort v} [inst : ∀ (a : α), Nonempty (β a)], Nonempty ((a : α) → β a)",
  "offspring": ["instNonemptyForAll_2.proof_1"],
  "name": "instNonemptyForAll_2"},
 {"type": "∀ {α : Type u} [inst : SizeOf α], sizeOf none = 1",
  "offspring": [],
  "name": "Option.none.sizeOf_spec"},
 {"type":
  "{α : Type u_1} → {p : α → Prop} → [inst : DecidablePred p] → (o : Option α) → Decidable (∃ a, a ∈ o ∧ p a)",
  "offspring":
  ["Option.decidable_exists_mem.proof_1",
   "Option.decidable_exists_mem.proof_2",
   "Option.decidable_exists_mem.proof_3"],
  "name": "Option.decidable_exists_mem"},
 {"type": "{α : Sort u} → {β : α → Sort v} → (self : PSigma β) → β self.fst",
  "offspring": [],
  "name": "PSigma.snd"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β}, Function.has_RightInverse f → Function.surjective f",
  "offspring": ["Function.RightInverse.surjective"],
  "name": "Function.has_RightInverse.surjective"},
 {"type": "∀ {a : Prop}, ¬(a ↔ ¬a)", "offspring": [], "name": "iff_not_self"},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (f : (a : α) → motive (Quot.mk r a)) →\n        (∀ (a b : α), r a b → (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) → (q : Quot r) → motive q",
  "offspring":
  ["Quot.liftIndepPr1",
   "PSigma.snd",
   "Quot.lift",
   "Quot.indep",
   "Quot.indepCoherent"],
  "name": "Quot.rec"},
 {"type":
  "∀ {β : Type u_1} {γ : Type u_2} {α : Type u_3} (g : β → γ) (f : α → β) (l : List α),\n  List.map g (List.map f l) = List.map (g ∘ f) l",
  "offspring": ["Function.comp_apply", "List.map"],
  "name": "List.map_map"},
 {"type":
  "{ω σ : Type} → {m : Type → Type} → (ε : Type u_1) → [inst : MonadExceptOf ε m] → MonadExceptOf ε (StateRefT' ω σ m)",
  "offspring":
  ["MonadExceptOf.mk", "StateRefT'.lift", "throwThe", "tryCatchThe"],
  "name": "StateRefT'.instMonadExceptOfStateRefT'"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} (a : α), p a → ∀ (o : α), o ∈ some a → p o",
  "offspring": ["Option.some_inj"],
  "name": "Option.decidable_forall_mem.proof_2"},
 {"type": "∀ {α : Type u_1} (a b : α), (bif true then a else b) = a",
  "offspring": [],
  "name": "cond_true"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), max a b = max b a",
  "offspring": ["eq_max", "le_max_right", "le_max_left", "max_le"],
  "name": "max_comm"},
 {"type": "∀ {a b c : ℤ}, c < a + b → -b < a - c",
  "offspring": ["Int.lt_sub_left_of_add_lt", "Int.sub_right_lt_of_lt_add"],
  "name": "Int.neg_lt_sub_right_of_lt_add"},
 {"type": "∀ {α : Sort u₁} {β : Sort u₂} (f : α → β), id ∘ f = f",
  "offspring": [],
  "name": "Function.left_id"},
 {"type":
  "∀ {σ α : Type u_1} [inst : Subsingleton σ] [inst : Subsingleton α], Subsingleton (StateM σ α)",
  "offspring": ["Subsingleton.intro", "Subsingleton.elim"],
  "name": "instSubsingletonStateM.proof_1"},
 {"type": "∀ {a b : ℤ}, a + b = 0 → -a = b",
  "offspring":
  ["Int.add_zero", "Int.add_assoc", "Int.add_left_neg", "Int.zero_add"],
  "name": "Int.neg_eq_of_add_eq_zero"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a : α} {h : p a} {a' : α} {h' : p a'},\n  { val := a, property := h } = { val := a', property := h' } ↔ a = a'",
  "offspring": ["Subtype.ext_iff"],
  "name": "Subtype.mk_eq_mk"},
 {"type": "∀ (n : ℕ), n ≤ n",
  "offspring": ["Nat.le.refl"],
  "name": "Nat.le_refl"},
 {"type":
  "{ε σ α δ : Type u} → [inst : EStateM.Backtrackable δ σ] → EStateM ε σ α → (Unit → EStateM ε σ α) → EStateM ε σ α",
  "offspring":
  ["EStateM.Result.ok",
   "EStateM.Backtrackable.restore",
   "EStateM.Backtrackable.save"],
  "name": "EStateM.orElse"},
 {"type": "Substring → ℕ → String.Pos → String.Pos",
  "offspring": ["Substring.next"],
  "name": "Substring.nextn"},
 {"type": "∀ (n : ℕ), ¬n < n",
  "offspring": ["Nat.not_succ_le_self"],
  "name": "Nat.lt_irrefl"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → [self : MonadFunctorT m n] → {α : Type u} → ({β : Type u} → m β → m β) → n α → n α",
  "offspring": [],
  "name": "MonadFunctorT.monadMap"},
 {"type": "∀ (n x : ℕ), Nat.succ n * x = x + n * x",
  "offspring": ["Nat.succ_mul"],
  "name": "Nat.instCommSemiringNat.proof_1"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "boolIfThenElse"},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Monad m] → (ℕ → α → m α) → ℕ → ℕ → α → m α",
  "offspring": [],
  "name": "Nat.foldM.loop"},
 {"type":
  "Mathlib.Tactic.Lint.Linter → Lean.Name → Mathlib.Tactic.Lint.NamedLinter",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.NamedLinter.mk"},
 {"type":
  "∀ {α : Sort u_1} (p : α → Prop) (hp h' : ∃ y, p y), p (Classical.indefiniteDescription (fun x => p x) hp).val",
  "offspring": ["Subtype.property"],
  "name": "Classical.strongIndefiniteDescription.proof_1"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop} {b : Prop},\n  (ExistsUnique fun x => p x) → (∀ (x : α), p x → (∀ (y : α), p y → y = x) → b) → b",
  "offspring": ["Exists.elim"],
  "name": "ExistsUnique.elim"},
 {"type": "{α : Type u} → {β : Type v} → List (α × β) → Std.AssocList α β",
  "offspring": [],
  "name": "List.toAssocList"},
 {"type":
  "{m : Type u → Type v} → {ε : Type u} → [inst : MonadFinally m] → [inst : Monad m] → MonadFinally (ExceptT ε m)",
  "offspring":
  ["MonadFinally.mk",
   "ExceptT.mk",
   "MonadFinally.tryFinally'",
   "Except.error",
   "Except.ok",
   "Prod"],
  "name": "ExceptT.finally"},
 {"type": "(a b : ℤ) → Decidable (a < b)",
  "offspring": ["Int.NonNeg.mk"],
  "name": "Int.decLt"},
 {"type": "∀ {p : Prop}, (p → False) → p = False",
  "offspring": [],
  "name": "eq_false'"},
 {"type": "∀ (a a_1 : ℕ), (-[1+ a] = -[1+ a_1]) = (a = a_1)",
  "offspring": [],
  "name": "Int.negSucc.injEq"},
 {"type": "∀ {a b : UInt16}, a = b → a.val = b.val",
  "offspring": [],
  "name": "UInt16.val_eq_of_eq"},
 {"type": "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), 0 * a = 0",
  "offspring": [],
  "name": "GroupWithZero.zero_mul"},
 {"type": "∀ {a b c : ℤ}, b < a → c < 0 → c * a < c * b",
  "offspring": [],
  "name": "Int.mul_lt_mul_of_neg_left"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → (self : BinaryHeap α lt) → Fin (BinaryHeap.size self) → α → BinaryHeap α lt",
  "offspring":
  ["BinaryHeap.mk",
   "Subtype.val",
   "BinaryHeap.heapifyUp",
   "Array.set",
   "BinaryHeap.arr",
   "BinaryHeap.increaseKey.proof_1"],
  "name": "BinaryHeap.increaseKey"},
 {"type": "∀ (a i : ℕ), a - i ≤ Nat.succ a - i",
  "offspring":
  ["Nat.le_of_lt",
   "Nat.lt_succ_self",
   "Nat.sub_succ",
   "Nat.pred",
   "Nat.succ_sub_succ",
   "Nat.pred_le"],
  "name": "Nat.sub_le_succ_sub"},
 {"type":
  "∀ {m n : ℕ}, 0 < Nat.gcd m n → ∃ m' n', Nat.coprime m' n' ∧ m = m' * Nat.gcd m n ∧ n = n' * Nat.gcd m n",
  "offspring":
  ["HDiv.hDiv",
   "Nat.coprime_div_gcd_div_gcd",
   "Nat.div_mul_cancel",
   "Nat.gcd_dvd_left",
   "Nat.gcd_dvd_right"],
  "name": "Nat.exists_coprime"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (y : Fin (UnionFind.size self)) (self₁ : UnionFind α),\n  UnionFind.size self₁ = UnionFind.size self → ↑y < UnionFind.size self₁",
  "offspring": ["Fin.isLt"],
  "name": "UnionFind.union.proof_1"},
 {"type": "{G : Type u} → [self : Semigroup G] → Mul G",
  "offspring": [],
  "name": "Semigroup.toMul"},
 {"type":
  "∀ {σ β : Type u} {m : Type u → Type v} (s s' : σ) (k : PUnit → σ → m β), StateCpsT.runK (set s') s k = k PUnit.unit s'",
  "offspring": [],
  "name": "StateCpsT.runK_set"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : ℕ) (a : Fin n),\n  (fun x a => Fin.ofNat' x (_ : 0 < n) * a) (Nat.succ x) a = a + (fun x a => Fin.ofNat' x (_ : 0 < n) * a) x a",
  "offspring":
  ["Fin.nsmuls_eq",
   "Fin.size_positive'",
   "Fin.add_def",
   "Nat.add_mod_mod",
   "Fin.mk.injEq",
   "Nat.succ_mul"],
  "name": "instAddCommMonoidFin.proof_4"},
 {"type": "Type → Type u_1 → Type u_1",
  "offspring": ["StateM", "ULift"],
  "name": "RandG"},
 {"type": "∀ {c t e : Prop} [inst : Decidable c], (if c then t else e) → c → t",
  "offspring": [],
  "name": "implies_of_if_pos"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → (α → m (Option β)) → m (Option β)",
  "offspring":
  ["ForIn.forIn",
   "ForInStep",
   "MProd",
   "ForInStep.done",
   "MProd.snd",
   "MProd.fst"],
  "name": "Array.findSomeM?"},
 {"type": "∀ (n : ℕ), Int.negOfNat n = Int.subNatNat 0 n",
  "offspring": [],
  "name": "Int.negOfNat_eq_subNatNat_zero"},
 {"type": "∀ {a b c : ℕ}, a + b ≤ a + c → b ≤ c",
  "offspring":
  ["Nat.le.dest", "Nat.le.intro", "Nat.add_left_cancel", "Nat.add_assoc"],
  "name": "Nat.le_of_add_le_add_left"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → [inst : Monad m] → Monad (ExceptT ε m)",
  "offspring": ["Monad.mk"],
  "name": "ExceptT.instMonadExceptT"},
 {"type":
  "{P : Sort u} → {x y : Tactic.NormCast.Label} → x = y → Tactic.NormCast.Label.noConfusionType P x y",
  "offspring": ["noConfusionEnum"],
  "name": "Tactic.NormCast.Label.noConfusion"},
 {"type": "∀ {p q : Prop}, q → p → q",
  "offspring": [],
  "name": "instDecidableForAll.proof_1"},
 {"type":
  "{A : Type u} → [toAdd : Add A] → (∀ (a b c : A), a + b + c = a + (b + c)) → AddSemigroup A",
  "offspring": [],
  "name": "AddSemigroup.mk"},
 {"type":
  "∀ {α : Sort v} {β : α → Sort u} {a₁ a₂ : α} (b : (x : α) → β x),\n  a₁ = a₂ →\n    HEq\n      (let x := a₁;\n      b x)\n      (let x := a₂;\n      b x)",
  "offspring": ["HEq.rfl"],
  "name": "let_value_heq"},
 {"type": "{α : Type u} → Sort u_1 → Sub α → Sub α → Sort u_1",
  "offspring": [],
  "name": "Sub.noConfusionType"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HDiv α β γ",
  "offspring": [],
  "name": "HDiv.mk"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.«command#list_linters»"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → (self : BinaryHeap α lt) → Fin (BinaryHeap.size self) → α",
  "offspring": ["Array.get", "BinaryHeap.arr"],
  "name": "BinaryHeap.get"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), a <<< b % n < n",
  "offspring": [],
  "name": "Fin.shiftLeft.proof_1"},
 {"type": "0 = { val := 0 }", "offspring": [], "name": "UInt64.zero_def"},
 {"type": "AndOp USize",
  "offspring": ["AndOp.mk", "USize.land"],
  "name": "instAndOpUSize"},
 {"type": "∀ {α : Type u_1} {a b : List α}, [] = a ++ b ↔ a = [] ∧ b = []",
  "offspring": ["eq_comm", "List.append_eq_nil", "Iff.rfl"],
  "name": "List.nil_eq_append_iff"},
 {"type": "∀ {α : Type u} [inst : SizeOf α], sizeOf [] = 1",
  "offspring": [],
  "name": "List.nil.sizeOf_spec"},
 {"type": "True = False → False",
  "offspring": ["trivial"],
  "name": "false_of_true_eq_false"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.tacticExt1?___"},
 {"type": "{α : Sort u} → α → plift α", "offspring": [], "name": "plift.up"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α), a :: as = [] → List.noConfusionType False (a :: as) []",
  "offspring": [],
  "name": "List.getLastD.proof_1"},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal} {p : Prop}, Sat.Literal.reify v l p → Sat.Valuation.neg v l → p",
  "offspring": [],
  "name": "Sat.Literal.reify.prop"},
 {"type": "{α : Type u} → {β : Type v} → α → β → α × β",
  "offspring": [],
  "name": "Prod.mk"},
 {"type": "Inhabited System.FilePath",
  "offspring": ["System.FilePath.mk", "Inhabited.default"],
  "name": "System.instInhabitedFilePath"},
 {"type": "∀ (n : ℕ), n + 0 = n", "offspring": [], "name": "Nat.add_zero"},
 {"type": "∀ {α : Sort u} [inst : Setoid α] (a : α), a ≈ a",
  "offspring": ["Equivalence.refl", "Setoid.iseqv"],
  "name": "Setoid.refl"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f : α → β},\n  Function.bijective f → Function.LeftInverse (Function.surj_inv (_ : Function.surjective f)) f",
  "offspring":
  ["Function.RightInverse_of_injective_of_LeftInverse",
   "Function.RightInverse_surj_inv"],
  "name": "Function.LeftInverse_surj_inv"},
 {"type": "{α : Type u} → Sort u_1 → LE α → LE α → Sort u_1",
  "offspring": [],
  "name": "LE.noConfusionType"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} (a b c : α), TC r a b → TC r b c → TC r a c",
  "offspring": [],
  "name": "TC.trans"},
 {"type": "{α β : Type u} → [inst : Inhabited β] → ((α → β) → α → β) → α → β",
  "offspring": ["fixCore1", "Inhabited.default"],
  "name": "fix1"},
 {"type":
  "∀ {v : Sat.Valuation} {f : Sat.Fmla} {p : Prop}, (¬Sat.Valuation.satisfies_fmla v f → p) → Sat.Fmla.reify v f p",
  "offspring": [],
  "name": "Sat.Fmla.reify.mk"},
 {"type":
  "∀ {ctx : Nat.Linear.Context} {m₁ m₂ : Nat.Linear.Poly},\n  Nat.Linear.Poly.denote_le ctx (m₁, m₂) → Nat.Linear.Poly.denote_le ctx (Nat.Linear.Poly.cancel m₁ m₂)",
  "offspring":
  ["Nat.Linear.Poly.denote_le_cancelAux",
   "List.reverse_nil",
   "List.nil_append"],
  "name": "Nat.Linear.Poly.denote_le_cancel"},
 {"type":
  "∀ (i : Fin 0), ↑((fun i => Fin.elim0 i) i) ≠ ↑i → (fun i => 0) ↑i < (fun i => 0) ↑((fun i => Fin.elim0 i) i)",
  "offspring": ["Fin.elim0"],
  "name": "UFModel.empty.proof_1"},
 {"type": "∀ {α : Sort u} [inst : Inhabited α], Nonempty α",
  "offspring": ["instNonempty.proof_1"],
  "name": "instNonempty"},
 {"type": "EmptyCollection ByteArray",
  "offspring": ["EmptyCollection.mk", "ByteArray.empty"],
  "name": "ByteArray.instEmptyCollectionByteArray"},
 {"type": "Lean.ToExpr Sat.Literal",
  "offspring": [],
  "name": "Sat.instToExprLiteral"},
 {"type": "∀ {α : Type u_1} (p : α → Prop), ¬∃ x, x ∈ [] ∧ p x",
  "offspring": ["sorryAx"],
  "name": "List.not_bex_nil"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → List β), List.bind [] f = []",
  "offspring": [],
  "name": "List.nil_bind"},
 {"type": "∀ {a b : ℤ}, a ≤ -b → b ≤ -a",
  "offspring": [],
  "name": "Int.le_neg_of_le_neg"},
 {"type":
  "∀ {α : Sort u_1} (x y : α) [inst : Decidable (x = y)], x ≠ y ∨ x = y",
  "offspring": ["dec_em'"],
  "name": "Decidable.ne_or_eq"},
 {"type": "Sort u → Nat.Linear.Expr → Nat.Linear.Expr → Sort u",
  "offspring": [],
  "name": "Nat.Linear.Expr.noConfusionType"},
 {"type": "Type u → Type u", "offspring": [], "name": "ToString"},
 {"type": "{α : Sort u} → {β : Sort v} → (α → β) → CoeTC α β",
  "offspring": [],
  "name": "CoeTC.mk"},
 {"type": "{α : Sort u} → (α → α → Prop) → α → α → Prop",
  "offspring": [],
  "name": "TC"},
 {"type":
  "∀ {α : Sort u} {motive : α → Prop} {a b : α}, a = b → motive a → motive b",
  "offspring": [],
  "name": "Eq.subst"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (P : Prop) [inst : Decidable P] (x : P → α) (y : ¬P → α),\n  f (dite P x y) = if h : P then f (x h) else f (y h)",
  "offspring":
  ["dite_congr",
   "Eq.mpr_prop",
   "Eq.mpr_not",
   "dite_true",
   "True.intro",
   "instDecidableFalse",
   "dite_false",
   "not_false"],
  "name": "apply_dite"},
 {"type": "AndOp UInt8",
  "offspring": ["AndOp.mk", "UInt8.land"],
  "name": "instAndOpUInt8"},
 {"type":
  "Nat.Linear.PolyCnstr → Nat.Linear.Certificate → Nat.Linear.PolyCnstr",
  "offspring":
  ["Nat.Linear.ExprCnstr",
   "Nat.Linear.PolyCnstr.combine",
   "Nat.Linear.PolyCnstr.mul",
   "Nat.add",
   "Nat.Linear.ExprCnstr.toNormPoly"],
  "name": "Nat.Linear.Certificate.combineHyps"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β},\n  Function.surjective f → ∀ {p : β → Prop}, (∀ (y : β), p y) ↔ ∀ (x : α), p (f x)",
  "offspring": [],
  "name": "Function.surjective.forall"},
 {"type": "List ℕ → ℕ → ℕ",
  "offspring": [],
  "name": "Nat.Linear.Var.denote.go"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "offspring": [],
  "name": "Function.comp"},
 {"type": "∀ {p q : Prop}, ¬p → ¬q → (p ↔ q)",
  "offspring": [],
  "name": "instDecidableIff.proof_4"},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "offspring": [],
  "name": "List.tails"},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : SizeOf α] [inst_1 : SizeOf β] (val : α), sizeOf (Sum.inl val) = 1 + sizeOf val",
  "offspring": [],
  "name": "Sum.inl.sizeOf_spec"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.LibrarySearch.«termLibrary_search%»"},
 {"type": "∀ {k x y : ℕ}, 0 < k → (x ≤ y / k ↔ x * k ≤ y)",
  "offspring":
  ["Nat.mod.inductionOn",
   "Nat.div_eq",
   "and_self",
   "ite_true",
   "Nat.zero_eq",
   "Nat.zero_le",
   "Nat.zero_mul",
   "Nat.add_one",
   "Nat.add_le_add_iff_le_right",
   "Nat.succ_mul",
   "Nat.add_sub_cancel",
   "Nat.sub_le_sub_right_iff",
   "Iff.rfl",
   "instDecidableFalse",
   "ite_false",
   "Nat.not_succ_le_zero",
   "false_iff",
   "not_le",
   "Nat.instLinearOrderNat",
   "Nat.lt_of_lt_of_le",
   "Nat.le_add_right"],
  "name": "Nat.le_div_iff_mul_le"},
 {"type": "∀ {α : Sort u_1}, α → True ↔ True",
  "offspring": ["iff_true_intro", "trivial"],
  "name": "imp_true_iff"},
 {"type": "(a b : UInt16) → Decidable (a < b)",
  "offspring": ["UInt16.decLt"],
  "name": "instDecidableLtUInt16InstLTUInt16"},
 {"type": "∀ (a b c : ℤ), (a - b) * c = a * c - b * c",
  "offspring":
  ["Trans.trans",
   "Int.distrib_right",
   "Int.neg_mul_eq_neg_mul_symm",
   "Int.sub_eq_add_neg"],
  "name": "Int.sub_mul"},
 {"type": "{R : Type u} → [self : AddGroupWithOne R] → Neg R",
  "offspring": [],
  "name": "AddGroupWithOne.toNeg"},
 {"type": "{α : Sort u} → (α → α → Prop) → Prop",
  "offspring": [],
  "name": "Equivalence"},
 {"type": "∀ {a b : ℤ}, a ≤ 0 → 0 ≤ b → a * b ≤ 0",
  "offspring": [],
  "name": "Int.mul_nonpos_of_nonpos_of_nonneg"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (h₁ : p a) (b : α) (h₂ : p b),\n  ¬a = b → { val := a, property := h₁ } = { val := b, property := h₂ } → False",
  "offspring": [],
  "name": "Subtype.instDecidableEqSubtype.proof_2"},
 {"type": "sizeOf Mathlib.Tactic.Lint.LintVerbosity.low = 1",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.low.sizeOf_spec"},
 {"type":
  "∀ {M : Type u} [self : Monoid M] (n : ℕ) (x : M), Monoid.npow (Nat.succ n) x = x * Monoid.npow n x",
  "offspring": [],
  "name": "Monoid.npow_succ'"},
 {"type": "{α : Type u_1} → [inst : ShiftRight α] → HShiftRight α α α",
  "offspring": ["HShiftRight.mk", "ShiftRight.shiftRight"],
  "name": "instHShiftRight"},
 {"type": "∀ {n m : ℕ}, ¬n < m → n ≥ m",
  "offspring": ["GE.ge", "Nat.lt_or_ge"],
  "name": "Nat.ge_of_not_lt"},
 {"type": "∀ {n : ℕ} (hi : Fin n) (r : ℕ), r ≤ ↑hi → r < n",
  "offspring": ["Nat.lt_of_le_of_lt", "Fin.isLt"],
  "name":
  "Random.instBoundedRandomFinToPreorderToPartialOrderInstLinearOrderFin.proof_1"},
 {"type":
  "∀ (x x_1 x_2 : USize), { val := (x + x_1 + x_2).1 } = { val := (x + (x_1 + x_2)).1 }",
  "offspring": ["USize.mk", "AddSemigroup.add_assoc"],
  "name": "USize.instAddSemigroupUSize.proof_1"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HPow"},
 {"type":
  "∀ {α : Type u_1} (x : Array α), Array.size x > 0 → Array.size x - 1 < Array.size x",
  "offspring": ["Nat.sub_lt"],
  "name": "Array.popWhile.proof_2"},
 {"type":
  "∀ {α : Type u} (a : α) (as : List α), List.reverse (a :: as) = List.reverse as ++ [a]",
  "offspring": ["List.reverseAux", "List.reverseAux_eq_append"],
  "name": "List.reverse_cons"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadStateOf σ m] → σ → m PUnit",
  "offspring": [],
  "name": "MonadStateOf.set"},
 {"type":
  "∀ {ctx : Nat.Linear.Context} {m₁ m₂ : Nat.Linear.Poly},\n  Nat.Linear.Poly.denote_eq ctx (m₁, m₂) → Nat.Linear.Poly.denote_eq ctx (Nat.Linear.Poly.cancel m₁ m₂)",
  "offspring":
  ["Nat.Linear.Poly.denote_eq_cancelAux",
   "List.reverse_nil",
   "List.nil_append"],
  "name": "Nat.Linear.Poly.denote_eq_cancel"},
 {"type": "∀ {m n : ℕ}, m ∣ n → 0 < n → 0 < m",
  "offspring":
  ["Nat.pos_of_ne_zero",
   "Nat.lt_irrefl",
   "Nat.eq_zero_of_zero_dvd",
   "Dvd.dvd",
   "Nat.instDvdNat"],
  "name": "Nat.pos_of_dvd_of_pos"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (p₁ p₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.combine p₁ p₂) =\n    Nat.Linear.Poly.denote ctx p₁ + Nat.Linear.Poly.denote ctx p₂",
  "offspring": ["Nat.Linear.Poly.denote_combineAux"],
  "name": "Nat.Linear.Poly.denote_combine"},
 {"type":
  "∀ {R : Type u} [self : NonUnitalNonAssocSemiring R], NonUnitalNonAssocSemiring.natCast 0 = 0",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.natCast_zero"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "termDepIfThenElse"},
 {"type": "∀ {α : Type u} (as bs : List α), List.append as bs = as ++ bs",
  "offspring": [],
  "name": "List.List.append_eq"},
 {"type":
  "∀ {α : Type u_1} {n : ℕ} (a b : Array α) (hsz₁ : Array.size a = n) (hsz₂ : Array.size b = n),\n  (∀ (i : ℕ) (hi : i < n), Array.getLit a i hsz₁ hi = Array.getLit b i hsz₂ hi) → a = b",
  "offspring": ["Array.ext"],
  "name": "Array.extLit"},
 {"type": "∀ {p q : Prop}, (p ↔ q) → ¬p → q → False",
  "offspring": [],
  "name": "decidable_of_decidable_of_iff.proof_1"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → ({α : Type u} → (ρ → ρ) → m α → m α) → MonadWithReaderOf ρ m",
  "offspring": [],
  "name": "MonadWithReaderOf.mk"},
 {"type": "∀ {m n : ℕ}, m ^ Nat.succ n = m * m ^ n",
  "offspring": ["Nat.pow_succ"],
  "name": "Nat.Nat.pow_succ'"},
 {"type": "List Lean.Expr → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.mkAndN"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → Float → m β) → (as : FloatArray) → (stop : ℕ) → stop ≤ FloatArray.size as → ℕ → ℕ → β → m β",
  "offspring": ["FloatArray.get", "FloatArray.foldlM.loop.proof_1"],
  "name": "FloatArray.foldlM.loop"},
 {"type":
  "∀ (toLinter : Mathlib.Tactic.Lint.Linter) (declName : Lean.Name) (toLinter_1 : Mathlib.Tactic.Lint.Linter)\n  (declName_1 : Lean.Name),\n  ({ toLinter := toLinter, declName := declName } = { toLinter := toLinter_1, declName := declName_1 }) =\n    (toLinter = toLinter_1 ∧ declName = declName_1)",
  "offspring":
  ["Mathlib.Tactic.Lint.Linter",
   "Mathlib.Tactic.Lint.NamedLinter",
   "Mathlib.Tactic.Lint.NamedLinter.mk"],
  "name": "Mathlib.Tactic.Lint.NamedLinter.mk.injEq"},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : ToString α] → [inst : ToString β] → ToString (α ⊕ β)",
  "offspring": ["ToString.mk", "addParenHeuristic"],
  "name": "instToStringSum"},
 {"type":
  "{α₁ α₂ β : Type u} → (α₁ → α₂ → β) → ((α₁ → α₂ → β) → α₁ → α₂ → β) → ℕ → α₁ → α₂ → β",
  "offspring": [],
  "name": "bfix2"},
 {"type": "{α : Type u} → {β : Type v} → [h : Inhabited β] → Inhabited (α ⊕ β)",
  "offspring": ["Sum.inr", "Inhabited.default"],
  "name": "Sum.inhabitedRight"},
 {"type":
  "∀ {G : Type u} [inst : Semigroup G] [inst_1 : IsMulRightCancel G] (a : G) {b c : G}, b * a = c * a ↔ b = c",
  "offspring": ["mul_right_cancel"],
  "name": "mul_left_inj"},
 {"type": "Semiring UInt64",
  "offspring":
  ["Semiring.mk",
   "UInt64.instSemiringUInt64.proof_13",
   "UInt64.instSemiringUInt64.proof_14",
   "UInt64.instSemiringUInt64.proof_15",
   "UInt64.instSemiringUInt64.proof_16",
   "Semigroup",
   "UInt64.instSemigroupUInt64",
   "AddCommSemigroup",
   "UInt64.instAddCommSemigroupUInt64"],
  "name": "UInt64.instSemiringUInt64"},
 {"type": "Type u → Type u", "offspring": [], "name": "Union"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "exacts"},
 {"type":
  "∀ {lits : Array ℤ} {expr proof : Lean.Expr} {lits_1 : Array ℤ} {expr_1 proof_1 : Lean.Expr},\n  { lits := lits, expr := expr, proof := proof } = { lits := lits_1, expr := expr_1, proof := proof_1 } →\n    lits = lits_1 ∧ expr = expr_1 ∧ proof = proof_1",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Clause.mk.inj"},
 {"type": "Type u → Type u", "offspring": [], "name": "Xor"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HAdd α β γ → HAdd α β γ → Sort u_1",
  "offspring": [],
  "name": "HAdd.noConfusionType"},
 {"type": "{α : Type u} → (α → α → α) → Prop",
  "offspring": [],
  "name": "associative"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} →\n    [self : MonadControl m n] → {α : Type u} → (({β : Type u} → n β → m (MonadControl.stM m n β)) → m α) → n α",
  "offspring": [],
  "name": "MonadControl.liftWith"},
 {"type": "DecidableEq ℤ",
  "offspring": ["Int.decEq"],
  "name": "Int.instDecidableEqInt"},
 {"type": "∀ (p q : Prop), ¬(p ∨ q) ↔ ¬p ∧ ¬q",
  "offspring": ["mt", "Or.elim"],
  "name": "not_or"},
 {"type": "Mathlib.Tactic.Lint.LintVerbosity",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.medium"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (n : ℕ), Array.size a = n → n ≤ Array.size a",
  "offspring": ["Nat.le_refl"],
  "name": "Array.toArrayLit.proof_1"},
 {"type": "{R : Type u} → [self : Semiring R] → ℕ → R → R",
  "offspring": [],
  "name": "Semiring.npow"},
 {"type": "{α : Type} → Lean.Meta.DiscrTree.Trie α → StateT (Array α) Id Unit",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.trieElements"},
 {"type": "∀ (m n k : ℕ), Nat.gcd m n ∣ Nat.gcd (m * k) n",
  "offspring": ["Nat.gcd_dvd_gcd_of_dvd_left", "Nat.dvd_mul_right"],
  "name": "Nat.gcd_dvd_gcd_mul_right"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : α → α → Prop} {s : β → β → Prop},\n  WellFounded r → WellFounded s → WellFounded (PSigma.RevLex r s)",
  "offspring":
  ["WellFounded.intro", "Acc", "PSigma.revLexAccessible", "WellFounded.apply"],
  "name": "PSigma.revLex.proof_1"},
 {"type": "∀ {α : Type u_1} {a b : α}, some a = some b ↔ a = b",
  "offspring": ["Option.some.injEq"],
  "name": "Option.some_inj"},
 {"type": "{α : Type u} → Subarray α → Array α",
  "offspring":
  ["Id.run",
   "ForIn.forIn",
   "Id.instMonadId",
   "Array.push",
   "Array.mkEmpty",
   "Subarray.stop",
   "Subarray.start"],
  "name": "Array.ofSubarray"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_*_»"},
 {"type":
  "∀ {G : Type u} [inst : Mul G] [self : IsMulRightCancel G] (a b c : G), b * a = c * a → b = c",
  "offspring": [],
  "name": "IsMulRightCancel.mul_right_cancel"},
 {"type":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), AddGroupWithOne.intCast -[1+ n] = -AddMonoidWithOne.natCast (n + 1)",
  "offspring": [],
  "name": "AddGroupWithOne.intCast_negSucc"},
 {"type": "Sat.Fmla → Sat.Fmla → Sat.Fmla",
  "offspring": [],
  "name": "Sat.Fmla.and"},
 {"type":
  "∀ (toString : String), sizeOf { toString := toString } = 1 + sizeOf toString",
  "offspring": [],
  "name": "System.FilePath.mk.sizeOf_spec"},
 {"type": "∀ (val : Fin UInt8.size), sizeOf { val := val } = 1 + sizeOf val",
  "offspring": [],
  "name": "UInt8.mk.sizeOf_spec"},
 {"type": "∀ (x y : ℕ), x % y ≤ x",
  "offspring":
  ["Nat.lt_or_ge",
   "Nat.mod_eq_of_lt",
   "Nat.le_refl",
   "Nat.eq_zero_or_pos",
   "Nat.mod_zero",
   "Nat.le_trans",
   "Nat.le_of_lt"],
  "name": "Nat.mod_le"},
 {"type": "64 = 32 ∨ 64 = 64",
  "offspring": [],
  "name": "System.Platform.getNumBits.proof_1"},
 {"type": "∀ {n : ℕ} (x x_1 : Fin n), x + x_1 = x_1 + x",
  "offspring": ["Fin.eq_of_val_eq", "Fin.add_def", "Fin.size_positive"],
  "name": "instAddCommSemigroupFin.proof_2"},
 {"type": "∀ (a b : UInt16), a + b = { val := a.val + b.val }",
  "offspring": [],
  "name": "UInt16.add_def"},
 {"type": "∀ (n m : ℕ), n + m - n = m",
  "offspring": [],
  "name": "Nat.add_sub_cancel_left"},
 {"type": "∀ (data : Array UInt8), sizeOf { data := data } = 1 + sizeOf data",
  "offspring": [],
  "name": "ByteArray.mk.sizeOf_spec"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (f : α → β) → {p : β → Prop} → (∀ (a : α), p (f a)) → α → Subtype p",
  "offspring": ["Subtype.mk"],
  "name": "Subtype.coind"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α), a :: as = [] → List.noConfusionType False (a :: as) []",
  "offspring": [],
  "name": "List.getLast?.proof_1"},
 {"type": "{R : Type u} → [self : Distrib R] → Add R",
  "offspring": [],
  "name": "Distrib.toAdd"},
 {"type":
  "∀ {α : Type u} (f : α → α → α), commutative f → associative f → right_commutative f",
  "offspring": [],
  "name": "right_comm"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) ↔ p a'",
  "offspring": [],
  "name": "forall_eq"},
 {"type":
  "∀ {α : Type u} [i : Nonempty α] {β : Sort v} {f : α → β}, Function.injective f ↔ Function.has_LeftInverse f",
  "offspring":
  ["Function.injective.has_LeftInverse", "Function.has_LeftInverse.injective"],
  "name": "Function.injective_iff_has_LeftInverse"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "commandGenIntDeclars__"},
 {"type": "Substring → String", "offspring": [], "name": "Substring.toString"},
 {"type": "∀ {a b : Prop}, ¬a → ¬b ↔ b → a",
  "offspring": ["Decidable.not_imp_not"],
  "name": "not_imp_not"},
 {"type": "{α : Type u} → (α → α) → Inv α", "offspring": [], "name": "Inv.mk"},
 {"type": "∀ {a b c d : Prop}, (a ↔ c) → (c → (b ↔ d)) → (a → b ↔ c → d)",
  "offspring": ["Iff.trans", "imp_congr_left", "imp_congr_right"],
  "name": "imp_congr_ctx"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : Fin (Array.size a)), Array.get a i = List.get a.data i",
  "offspring": [],
  "name": "Array.get_eq_get"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop} (q : Quot r), (∀ (a : α), motive (Quot.mk r a)) → motive q",
  "offspring": ["Quot.ind"],
  "name": "Quot.inductionOn"},
 {"type": "∀ (n : ℕ), Nat.coprime 0 n ↔ n = 1",
  "offspring": ["Nat.gcd_zero_left"],
  "name": "Nat.coprime_zero_left"},
 {"type":
  "∀ {m k : ℕ} (p : ℕ), Nat.gcd k m = Nat.succ p → Nat.succ p = Nat.gcd k m",
  "offspring": [],
  "name": "Nat.prod_dvd_and_dvd_of_dvd_prod.proof_4"},
 {"type": "{α : Type u} → Array α → List α → Array α",
  "offspring": ["List.foldl", "Array.push"],
  "name": "Array.appendList"},
 {"type":
  "∀ {n : ℕ} (a b : Fin n), Option.isSome (Fin.checkedMul a b) = true ↔ ↑a * ↑b < n",
  "offspring":
  ["decide_eq_true_iff",
   "eq_false_of_decide",
   "Nat.lt_of_not_le",
   "decide_eq_false",
   "Nat.not_le_of_lt"],
  "name": "Fin.checked_mul_spec"},
 {"type": "Type", "offspring": [], "name": "Task.Priority"},
 {"type": "∀ {α : Type u_1} {o : Option α}, ¬Option.isSome o = true ↔ o = none",
  "offspring":
  ["Option.isSome_none",
   "eq_false_of_decide",
   "Option.isSome_some",
   "eq_false'"],
  "name": "Option.not_isSome_iff_eq_none"},
 {"type":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] {a b : α}, (a == b) = false → a ≠ b",
  "offspring": [],
  "name": "ne_of_beq_false"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : Option α} {f : α → β}, Option.map f x = none ↔ x = none",
  "offspring": ["Option.map_none'", "Option.map_some'", "eq_false'"],
  "name": "Option.map_eq_none'"},
 {"type": "Type", "offspring": [], "name": "Tactic.Ring.State"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (j i : ℕ), i + 1 + j = Array.size as → i + (j + 1) = Array.size as",
  "offspring": ["Nat.add_assoc"],
  "name": "Array.mapIdxM.map.proof_2"},
 {"type":
  "∀ {α : Type u_1} [inst : LinearOrder α] (x y : α), ¬x < y → ¬y < x → x = y",
  "offspring": ["le_antisymm", "le_of_not_gt"],
  "name": "lt_by_cases.proof_1"},
 {"type":
  "{m : Type u → Type v} → {γ : Type w₁} → {α : outParam (Type w₂)} → Sort u_1 → ForM m γ α → ForM m γ α → Sort u_1",
  "offspring": [],
  "name": "ForM.noConfusionType"},
 {"type":
  "∀ (toString toString_1 : String), ({ toString := toString } = { toString := toString_1 }) = (toString = toString_1)",
  "offspring": ["System.FilePath", "System.FilePath.mk"],
  "name": "System.FilePath.mk.injEq"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a > b → ¬a ≤ b",
  "offspring": ["le_not_le_of_lt"],
  "name": "not_le_of_gt"},
 {"type": "∀ {α : Type u_1} (as : Array α), Array.size as ≤ Array.size as",
  "offspring": ["Nat.le_refl"],
  "name": "Array.forIn.proof_1"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort u_2} {r : α → α → Prop} {s : (a : α) → β a → β a → Prop} {a : α},\n  Acc r a → (∀ (a : α), WellFounded (s a)) → ∀ (b : β a), Acc (PSigma.Lex r s) { fst := a, snd := b }",
  "offspring": ["Acc.intro", "WellFounded.apply"],
  "name": "PSigma.lexAccessible.proof_1"},
 {"type": "∀ {a : ℤ}, 0 ≤ a → a = ↑(Int.natAbs a)",
  "offspring": ["Int.eq_ofNat_of_zero_le"],
  "name": "Int.eq_natAbs_of_zero_le"},
 {"type": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "offspring": [],
  "name": "LinearOrder.toPartialOrder"},
 {"type":
  "{α : Type u} → {β : Type v} → Sort u_1 → Pow α β → Pow α β → Sort u_1",
  "offspring": [],
  "name": "Pow.noConfusionType"},
 {"type": "{α : Type u_1} → Membership α (Option α)",
  "offspring": ["Membership.mk"],
  "name": "Option.instMembershipOption"},
 {"type":
  "{α : Type u_1} →\n  (α → α → Bool) → (x : ℕ) → (x_1 : Array α) → x ≤ Array.size x_1 → { a' // Array.size a' = Array.size x_1 }",
  "offspring":
  ["Subtype.mk",
   "BinaryHeap.mkHeap.loop.proof_1",
   "BinaryHeap.mkHeap.loop.proof_4",
   "Subtype.val",
   "BinaryHeap.mkHeap.loop.proof_3",
   "BinaryHeap.heapifyDown",
   "BinaryHeap.mkHeap.loop.proof_2"],
  "name": "BinaryHeap.mkHeap.loop"},
 {"type": "∀ (x : ℕ) {z : ℕ}, 0 < z → (z + x) / z = Nat.succ (x / z)",
  "offspring": ["Nat.add_div_right"],
  "name": "Nat.add_div_left"},
 {"type": "{p : Prop} → ¬p → Decidable p",
  "offspring": [],
  "name": "Decidable.isFalse"},
 {"type":
  "∀ (arr : ByteArray) (off : ℕ), sizeOf { arr := arr, off := off } = 1 + sizeOf arr + sizeOf off",
  "offspring": ["ByteArray", "instSizeOfNat"],
  "name": "ByteSliceT.mk.sizeOf_spec"},
 {"type":
  "{ε : Type u} → {α : Type v} → [inst : Inhabited ε] → Inhabited (Except ε α)",
  "offspring": ["Except.error", "Inhabited.default"],
  "name": "instInhabitedExcept"},
 {"type": "∀ {a : Prop}, a → False ↔ ¬a",
  "offspring": ["Iff.rfl"],
  "name": "imp_false"},
 {"type": "∀ (a b : ℤ), a < b ↔ a + 1 ≤ b",
  "offspring": ["Iff.refl"],
  "name": "Int.lt_iff_add_one_le"},
 {"type": "∀ (a : Prop), a ∧ ¬a ↔ False",
  "offspring": [],
  "name": "and_not_self_iff"},
 {"type": "∀ {a b c d : ℤ}, a < c → b ≤ d → 0 < b → 0 ≤ c → a * b < c * d",
  "offspring":
  ["Trans.trans",
   "Int.mul_lt_mul_of_pos_right",
   "Int.mul_le_mul_of_nonneg_left"],
  "name": "Int.mul_lt_mul"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun a a_1 => a ≤ a_1] {a b : α}, a ≤ b → a < b ∨ a = b",
  "offspring": ["le_antisymm", "lt_of_le_not_le"],
  "name": "Decidable.lt_or_eq_of_le"},
 {"type": "ShiftRight UInt16",
  "offspring": ["ShiftRight.mk", "UInt16.shiftRight"],
  "name": "instShiftRightUInt16"},
 {"type": "{α : Type u} → {β : Type v} → [h : Inhabited α] → Inhabited (α ⊕ β)",
  "offspring": ["Sum.inl", "Inhabited.default"],
  "name": "Sum.inhabitedLeft"},
 {"type": "∀ {a b c d : ℕ}, a ∣ b → c ∣ d → a * c ∣ b * d",
  "offspring": ["Nat.mul_assoc"],
  "name": "Nat.mul_dvd_mul"},
 {"type":
  "∀ {α : Type u_1} {x : Option α}, x ≠ none → ∀ (y : α), some (Option.getD x y) = x",
  "offspring": ["Option.getD_some"],
  "name": "Option.getD_of_ne_none"},
 {"type": "UInt32 → USize",
  "offspring": ["Nat.toUSize", "UInt32.toNat"],
  "name": "UInt32.toUSize"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Functor f] [self : LawfulFunctor f] {α β : Type u},\n  Functor.mapConst = Functor.map ∘ Function.const β",
  "offspring": [],
  "name": "LawfulFunctor.map_const"},
 {"type": "∀ (a : ℤ) {b : ℤ}, 0 ≤ b → a - b ≤ a",
  "offspring":
  ["Trans.trans",
   "Int.add_le_add_left",
   "Int.neg_nonpos_of_nonneg",
   "Int.add_zero"],
  "name": "Int.sub_le_self"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → Sort u_1 → MonadControlT m n → MonadControlT m n → Sort u_1",
  "offspring": [],
  "name": "MonadControlT.noConfusionType"},
 {"type": "∀ {α : Type u_1} {l : List α}, 0 < List.length l ↔ l ≠ []",
  "offspring": ["List.ne_nil_of_length_pos", "List.length_pos_of_ne_nil"],
  "name": "List.length_pos_iff_ne_nil"},
 {"type": "∀ (m n : ℕ), m * n % n = 0",
  "offspring": ["Nat.mul_mod_right"],
  "name": "Nat.mul_mod_left"},
 {"type": "∀ (n m k : ℕ), n * (m - k) = n * m - n * k",
  "offspring": ["Nat.mul_sub_right_distrib"],
  "name": "Nat.mul_sub_left_distrib"},
 {"type": "∀ {a b c : Prop}, a ∧ b ∧ c ↔ b ∧ c ∧ a",
  "offspring": ["and_comm", "And.left_comm", "Iff.rfl"],
  "name": "And.rotate"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {l : List α} {a : α},\n  a ∈ l → p a → List.length (List.erasep p l) = Nat.pred (List.length l)",
  "offspring":
  ["List.length_append", "List.length_cons", "List.exists_of_erasep"],
  "name": "List.length_erasep_of_mem"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (i : ℕ), i + 1 ≤ Array.size as → Array.size as - 1 - i < Array.size as",
  "offspring":
  ["Nat.lt_of_le_of_lt",
   "Nat.sub_le",
   "Nat.sub_lt",
   "Nat.zero_lt_of_lt",
   "Nat.lt_of_lt_of_le",
   "Nat.lt_succ_self"],
  "name": "Array.forIn.loop.proof_1"},
 {"type":
  "Substring → optParam String \" \" → String.Pos → String.Pos → String.Pos → List Substring → List Substring",
  "offspring": [],
  "name": "Substring.splitOn.loop"},
 {"type": "ℕ → Tactic.NormCast.CoeFnType",
  "offspring":
  ["cond",
   "Nat.ble",
   "Nat.beq",
   "Tactic.NormCast.CoeFnType.coeFn",
   "Tactic.NormCast.CoeFnType.coeSort",
   "Tactic.NormCast.CoeFnType.coe"],
  "name": "Tactic.NormCast.CoeFnType.ofNat"},
 {"type":
  "∀ {α : Type u} (as : List α), List.length (List.dropLast as) = List.length as - 1",
  "offspring": [],
  "name": "List.length_dropLast"},
 {"type": "∀ (a : Prop), xor a a = False",
  "offspring": ["and_not_self", "or_self"],
  "name": "xor_self"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i j : Fin (Array.size a)), Array.size a = Array.size (Array.set a i (Array.get a j))",
  "offspring": ["Array.size_set", "Array.get"],
  "name": "Array.swap.proof_1"},
 {"type": "∀ {n m : ℕ}, Nat.succ n ≤ m → n ≤ m",
  "offspring": ["Nat.le_trans", "Nat.le_succ"],
  "name": "Nat.le_of_succ_le"},
 {"type":
  "{α : Type u} → (α → List Lean.Format → List Lean.Format) → ReprTuple α",
  "offspring": [],
  "name": "ReprTuple.mk"},
 {"type":
  "{ω σ : Type} → {m : Type → Type} → [inst : Alternative m] → [inst : Monad m] → Alternative (StateRefT' ω σ m)",
  "offspring": [],
  "name": "StateRefT'.instAlternativeStateRefT'"},
 {"type":
  "∀ {ε σ α : Type u} {a : ε} {a_1 : σ} {a_2 : ε} {a_3 : σ},\n  EStateM.Result.error a a_1 = EStateM.Result.error a_2 a_3 → a = a_2 ∧ a_1 = a_3",
  "offspring": [],
  "name": "EStateM.Result.error.inj"},
 {"type": "∀ {α : Type u_1} (l : List α), [] ⊆ l",
  "offspring": ["List.mem_nil_iff"],
  "name": "List.nil_subset"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c",
  "offspring": ["le_not_le_of_lt", "lt_of_le_not_le", "le_trans"],
  "name": "lt_trans"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk", "HShiftLeft.hShiftLeft", "UInt8.modn"],
  "name": "UInt8.shiftLeft"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<$>_»"},
 {"type": "∀ {b a : ℕ}, b ≤ a → Nat.min a b = b",
  "offspring": ["Nat.min", "Nat.min_comm", "Nat.min_eq_left"],
  "name": "Nat.min_eq_right"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.disjoint l₁ l₂ ↔ ∀ ⦃a : α⦄, a ∈ l₁ → ¬a ∈ l₂",
  "offspring": [],
  "name": "List.disjoint_left"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {g : β → φ} {f : α → β},\n  Function.bijective g → Function.bijective f → Function.bijective (g ∘ f)",
  "offspring": ["Function.injective.comp", "Function.surjective.comp"],
  "name": "Function.bijective.comp"},
 {"type": "ShiftRight UInt32",
  "offspring": ["ShiftRight.mk", "UInt32.shiftRight"],
  "name": "instShiftRightUInt32"},
 {"type": "∀ (b : Bool), (false && b) = false",
  "offspring": [],
  "name": "Bool.false_and"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] (a : A), -a + a = 0",
  "offspring": ["add_left_neg"],
  "name": "neg_add_self"},
 {"type": "ToString Lean.Format",
  "offspring": ["ToString.mk"],
  "name": "instToStringFormat"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a' = a ∧ p a) ↔ p a'",
  "offspring": ["eq_comm", "exists_eq_left"],
  "name": "exists_eq_left'"},
 {"type": "{α : Type u} → Array α → Array α",
  "offspring": ["Array.mk", "List.dropLast", "Array.data"],
  "name": "Array.pop"},
 {"type": "∀ {n m : ℕ}, Nat.pred n ≤ m → n ≤ Nat.succ m",
  "offspring": ["Nat.zero_le", "Nat.succ_le_succ"],
  "name": "Nat.le_succ_of_pred_le"},
 {"type": "∀ (b : ℕ), 0 % b = 0",
  "offspring": ["Nat.mod_eq"],
  "name": "Nat.zero_mod"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "Set.«term⋃₀_»"},
 {"type":
  "∀ {α : Type u} {xs : List α} {i j : ℕ}, i < List.length xs → List.Nodup xs → List.get? xs i = List.get? xs j → i = j",
  "offspring": ["Nat.succ.injEq", "Nat.lt_of_succ_lt_succ"],
  "name": "List.get?_injective"},
 {"type": "0 < UInt64.size",
  "offspring": [],
  "name": "instInhabitedUInt64.proof_1"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (p q : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (p ++ q) = Nat.Linear.Poly.denote ctx p + Nat.Linear.Poly.denote ctx q",
  "offspring":
  ["List.nil_append", "Nat.zero_add", "List.List.append_eq", "Nat.add_assoc"],
  "name": "Nat.Linear.Poly.denote_append"},
 {"type":
  "∀ {α : Type u} {β : Type v} (val val_1 : β), (Sum.inr val = Sum.inr val_1) = (val = val_1)",
  "offspring": ["Sum.inr"],
  "name": "Sum.inr.injEq"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, Function.injective fun a => a.val",
  "offspring": ["Subtype.ext"],
  "name": "Subtype.coe_injective"},
 {"type": "{p : Prop} → Decidable p → Bool",
  "offspring": ["Decidable.decide"],
  "name": "toBoolUsing"},
 {"type":
  "{M : Type u} → [toOne : One M] → [toMul : Mul M] → (∀ (a : M), 1 * a = a) → (∀ (a : M), a * 1 = a) → MulOneClass M",
  "offspring": [],
  "name": "MulOneClass.mk"},
 {"type": "∀ {n m : ℕ}, n < m → ∀ (k : ℕ), k + n < k + m",
  "offspring":
  ["Nat.lt_of_succ_le",
   "Nat.add_le_add_left",
   "Nat.succ_le_of_lt",
   "Nat.add_succ"],
  "name": "Nat.add_lt_add_left"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<*_»"},
 {"type": "{M : Type u} → Sort u_1 → CommMonoid M → CommMonoid M → Sort u_1",
  "offspring": [],
  "name": "CommMonoid.noConfusionType"},
 {"type": "{α : Type u_1} → OptionM α → Option α",
  "offspring": [],
  "name": "OptionM.run"},
 {"type": "Lean.PrettyPrinter.Delaborator.Delab",
  "offspring":
  ["Tactic.NormCast.coeDelaborator",
   "Tactic.NormCast.CoeFnInfo.mk",
   "Tactic.NormCast.CoeFnType.coe"],
  "name": "Nat.cast.delaborator"},
 {"type": "{α : Type u} → [inst : Inhabited α] → String → ℕ → ℕ → String → α",
  "offspring": ["panic", "instToStringNat"],
  "name": "panicWithPos"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop}, (∀ (a : α), Acc r a) → WellFounded r",
  "offspring": [],
  "name": "WellFounded.intro"},
 {"type":
  "∀ {α : Type u_1} (n : ℕ) (a : α) (l : List α), List.length (List.leftpad n a l) = max n (List.length l)",
  "offspring":
  ["List.length_append", "List.length_repeat'", "Nat.sub_add_eq_max"],
  "name": "List.leftpad_length"},
 {"type":
  "∀ {α : Type u_1} {t₁ t₂ : List α} (s : List α), s ++ t₁ = s ++ t₂ ↔ t₁ = t₂",
  "offspring": ["Function.injective.eq_iff", "List.append_right_injective"],
  "name": "List.append_right_inj"},
 {"type":
  "∀ {α : Type u_1} (x : α) (xs : List α) (n : ℕ) (a : α), List.set (x :: xs) (Nat.succ n) a = x :: List.set xs n a",
  "offspring": [],
  "name": "List.set_succ"},
 {"type": "{m : Type u → Type v} → {α : Type u} → OptionT m α → m (Option α)",
  "offspring": [],
  "name": "OptionT.run"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬b < a → a ≤ b",
  "offspring": ["lt_trichotomy", "le_of_lt", "le_refl"],
  "name": "le_of_not_lt"},
 {"type": "Lean.Syntax → List Lean.MVarId → Lean.Elab.Tactic.TacticM Unit",
  "offspring": [],
  "name": "repeat'Aux"},
 {"type": "Fin UInt16.size → UInt16", "offspring": [], "name": "UInt16.mk"},
 {"type": "{α : Type u_1} → Subarray α → Subarray α",
  "offspring":
  ["Subarray.start",
   "Subarray.stop",
   "Subarray.mk",
   "Subarray.as",
   "Subarray.popFront.proof_1",
   "Subarray.h₂"],
  "name": "Subarray.popFront"},
 {"type":
  "∀ {α : Type u_1} (a b : List α),\n  List.length a = List.length b →\n    (∀ (i : ℕ) (hi₁ : i < List.length a) (hi₂ : i < List.length b),\n        List.get a { val := i, isLt := hi₁ } = List.get b { val := i, isLt := hi₂ }) →\n      a = b",
  "offspring": ["List.length_cons"],
  "name": "Array.ext.extAux"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, c ≤ a → c ≤ b → (∀ {d : α}, d ≤ a → d ≤ b → d ≤ c) → c = min a b",
  "offspring": ["le_antisymm", "le_min", "min_le_left", "min_le_right"],
  "name": "eq_min"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Functor f],\n  (∀ {α β : Type u}, Functor.mapConst = Functor.map ∘ Function.const β) →\n    (∀ {α : Type u} (x : f α), id <$> x = x) →\n      (∀ {α β γ : Type u} (g : α → β) (h : β → γ) (x : f α), (h ∘ g) <$> x = h <$> g <$> x) → LawfulFunctor f",
  "offspring": [],
  "name": "LawfulFunctor.mk"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, (∃ x, ¬p x) → ¬∀ (x : α), p x",
  "offspring": [],
  "name": "not_forall_of_exists_not"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (xs ys : List α) (f : α → List β),\n  List.bind (xs ++ ys) f = List.bind xs f ++ List.bind ys f",
  "offspring":
  ["List.bind", "List.cons_append", "List.cons_bind", "List.append_assoc"],
  "name": "List.append_bind"},
 {"type": "∀ {α : Type u_1} (y : α) {a : α} {l : List α}, a ∈ l → a ∈ y :: l",
  "offspring": ["List.Mem.tail"],
  "name": "List.mem_cons_of_mem"},
 {"type": "Lean.Expr → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring": [],
  "name": "Tactic.Ring.eval"},
 {"type":
  "∀ {α : Sort u} {φ : α → Sort v} {a a' : α} (h : a = a') (p : φ a), HEq (Eq.recOn h p) p",
  "offspring": [],
  "name": "eqRec_heq"},
 {"type": "∀ (a : UInt8), -a = { val := -a.val }",
  "offspring": [],
  "name": "UInt8.neg_def"},
 {"type":
  "∀ {n : ℕ} (lo hi : Fin n) (r : ℕ),\n  ↑lo ≤ r → r ≤ ↑hi → lo ≤ { val := r, isLt := (_ : r < n) } ∧ { val := r, isLt := (_ : r < n) } ≤ hi",
  "offspring": [],
  "name":
  "Random.instBoundedRandomFinToPreorderToPartialOrderInstLinearOrderFin.proof_2"},
 {"type": "∀ {a b : Prop}, a → b ↔ ¬a ∨ b",
  "offspring": ["Decidable.imp_iff_not_or"],
  "name": "imp_iff_not_or"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk"],
  "name": "UInt64.sub"},
 {"type": "∀ {n : ℕ} (a b : Fin n), a + b = b + a",
  "offspring": ["AddCommSemigroup.add_comm"],
  "name": "instAddCommMonoidFin.proof_5"},
 {"type": "∀ (x z : ℕ), (x + z) % x = z % x",
  "offspring": ["Nat.add_mod_right"],
  "name": "Nat.add_mod_left"},
 {"type": "∀ {n m k : ℕ}, k ≤ m → (n - k ≤ m - k ↔ n ≤ m)",
  "offspring": ["Nat.le_of_le_of_sub_le_sub_right", "Nat.sub_le_sub_right"],
  "name": "Nat.sub_le_sub_right_iff"},
 {"type": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "offspring": ["AddMonoidWithOne.natCast_zero"],
  "name": "Nat.cast_zero"},
 {"type": "{α β σ : Type u} → α → σ → DoResultPR α β σ",
  "offspring": [],
  "name": "DoResultPR.pure"},
 {"type": "∀ (m k : ℕ), m % k + k * (m / k) = m",
  "offspring":
  ["Nat.mod.inductionOn",
   "Nat.div_eq",
   "Nat.mod_eq",
   "and_self",
   "ite_true",
   "Nat.mul_succ",
   "Nat.add_assoc",
   "Nat.sub_add_cancel",
   "instDecidableFalse",
   "ite_false",
   "Nat.mul_zero",
   "Nat.add_zero"],
  "name": "Nat.mod_add_div"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "offspring": ["Preorder.lt_iff_le_not_le"],
  "name": "lt_iff_le_not_le"},
 {"type": "∀ (n m : ℕ), Nat.succ n - Nat.succ m = n - m",
  "offspring": ["Nat.succ_sub_succ_eq_sub"],
  "name": "Nat.succ_sub_succ"},
 {"type": "∀ {a b c : ℤ}, a + b < c → a < c - b",
  "offspring": [],
  "name": "Int.lt_sub_right_of_add_lt"},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} → {δ : Type u_4} → {ε : Type u_5} → (α → β → γ → δ → ε) → List α → List β → List γ → List δ → List ε",
  "offspring": [],
  "name": "List.zipWith₄"},
 {"type": "{ε : Type} → MonadLift BaseIO (EIO ε)",
  "offspring": ["MonadLift.mk"],
  "name": "instMonadLiftBaseIOEIO"},
 {"type":
  "∀ {α : Type u_1} {f : α → α → α} {b : Option α}, Option.lift_or_get f none b = b",
  "offspring": [],
  "name": "Option.lift_or_get_none_left"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "Function.«term_∘₂_»"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β) → (α → γ) → (β → γ) → β → γ",
  "offspring": ["Classical.choose"],
  "name": "Function.extend"},
 {"type":
  "{f : Type u → Type v} → ({α β : Type u} → f α → (Unit → f β) → f β) → SeqRight f",
  "offspring": [],
  "name": "SeqRight.mk"},
 {"type": "Inhabited UInt16",
  "offspring": ["UInt16.ofNatCore", "instInhabitedUInt16.proof_1"],
  "name": "instInhabitedUInt16"},
 {"type": "{α : Type u} → {β : α → Type v} → (self : Sigma β) → β self.fst",
  "offspring": [],
  "name": "Sigma.snd"},
 {"type": "∀ (a i : ℕ), i < a → a - (i + 1) < a - i",
  "offspring":
  ["Nat.add_succ",
   "Nat.sub_succ",
   "Nat.pred_lt",
   "Nat.not_eq_zero_of_lt",
   "Nat.zero_lt_sub_of_lt"],
  "name": "Nat.sub_succ_lt_self"},
 {"type": "∀ {a b c : ℕ}, b ≤ a → a - b = c → a = c + b",
  "offspring": ["Nat.sub_add_cancel"],
  "name": "Nat.eq_add_of_sub_eq"},
 {"type":
  "{α : Type u_1} → {β : Sort u_2} → (ℕ → α → β → β) → ℕ → β → List α → β",
  "offspring": [],
  "name": "List.foldrIdxAux"},
 {"type": "∀ (a : USize), a + 0 = a",
  "offspring":
  ["USize.zero_def",
   "USize.add_def",
   "USize.mk",
   "add_zero",
   "USize.mk_val_eq"],
  "name": "USize.instSemiringUSize.proof_1"},
 {"type": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k * n ≤ k * m",
  "offspring": ["Nat.le.dest"],
  "name": "Nat.mul_le_mul_left"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt) (x m : α),\n  BinaryHeap.max self = some m →\n    0 < Array.size (Array.set self.arr { val := 0, isLt := (_ : 0 < BinaryHeap.size self) } x)",
  "offspring": ["Array.size_set", "BinaryHeap.size_pos_of_max"],
  "name": "BinaryHeap.replaceMax.proof_2"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«termListΠ»"},
 {"type": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "offspring": ["MulOneClass.mk", "Monoid.one_mul", "Monoid.mul_one"],
  "name": "Monoid.toMulOneClass"},
 {"type": "String → System.SearchPath",
  "offspring":
  ["List.map", "System.FilePath.mk", "System.SearchPath.separator"],
  "name": "System.SearchPath.parse"},
 {"type": "∀ (m n : ℕ), n ∣ Nat.lcm m n",
  "offspring": ["Nat.dvd_lcm_left", "Nat.lcm_comm"],
  "name": "Nat.dvd_lcm_right"},
 {"type":
  "∀ {α : Type u} (a : α) (as bs : List α), a :: as ++ bs = a :: (as ++ bs)",
  "offspring": [],
  "name": "List.cons_append"},
 {"type":
  "∀ {α : Type u_1} (as : List α) (p : α → Bool) (x : α), x ∈ List.filter p as ↔ x ∈ as ∧ p x = true",
  "offspring": ["List.mem_filterAux", "List.not_mem_nil", "or_false"],
  "name": "List.mem_filter"},
 {"type": "{A : Type u} → [self : SubNegMonoid A] → AddMonoid A",
  "offspring": [],
  "name": "SubNegMonoid.toAddMonoid"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddGroup"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → [inst : CoeHead α β] → [inst : CoeTC β δ] → CoeHTCT α δ",
  "offspring": ["CoeHTCT.mk", "CoeTC.coe", "CoeHead.coe"],
  "name": "coeOfHeadOfTC"},
 {"type": "{α : Type u_1} → Id α → α", "offspring": [], "name": "Id.run"},
 {"type":
  "∀ {α : Type u_1} {s₁ s₂ t₁ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → List.length s₁ = List.length s₂ → t₁ = t₂",
  "offspring": ["List.append_inj"],
  "name": "List.append_inj_right"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk", "Fin.xor", "UInt64.size"],
  "name": "UInt64.xor"},
 {"type":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a = b)",
  "offspring": ["LinearOrder.decidable_eq"],
  "name": "instDecidableEq"},
 {"type":
  "∀ (n m : Fin UInt16.size), ¬n = m → { val := n } = { val := m } → False",
  "offspring": [],
  "name": "UInt16.decEq.proof_2"},
 {"type": "{α : Type u} → α → List α → List α",
  "offspring": [],
  "name": "List.intersperse"},
 {"type":
  "(m : Type u_1 → Type u_2) →\n  (n : Type u_1 → Type u_3) →\n    (o : Type u_1 → Type u_4) → [inst : MonadFunctor n o] → [inst : MonadFunctorT m n] → MonadFunctorT m o",
  "offspring":
  ["MonadFunctorT.mk", "MonadFunctor.monadMap", "MonadFunctorT.monadMap"],
  "name": "instMonadFunctorT"},
 {"type": "{α : Type u_1} → {n : ℕ} → (Fin n → α) → ℕ → Option α",
  "offspring": [],
  "name": "List.ofFnNthVal"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, ¬a ∈ l → List.erase l a = l",
  "offspring":
  ["List.erase_cons", "if_neg", "Ne.symm", "not_or", "List.mem_cons"],
  "name": "List.erase_of_not_mem"},
 {"type": "{R : Type u} → [self : AddMonoidWithOne R] → ℕ → R",
  "offspring": [],
  "name": "AddMonoidWithOne.natCast"},
 {"type": "{α : Type u_1} → (a : Array α) → Fin (Array.size a) → α → Array α",
  "offspring": ["Array.mk", "List.set", "Array.data"],
  "name": "Array.set"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_|||_»"},
 {"type": "Tactic.NormCast.CoeFnType",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.coe"},
 {"type": "Tactic.NormCast.CoeFnInfo → Lean.PrettyPrinter.Delaborator.Delab",
  "offspring":
  ["Tactic.NormCast.CoeFnType.coe",
   "Tactic.NormCast.CoeFnType.coeSort",
   "Tactic.NormCast.CoeFnInfo.type",
   "GT.gt",
   "Tactic.NormCast.CoeFnInfo.numArgs",
   "Alternative.failure",
   "Tactic.NormCast.CoeFnInfo.coercee",
   "ForIn.forIn",
   "Option.all",
   "Array.get?",
   "Array.push",
   "Array.isEmpty",
   "Array.append",
   "instBEqNat"],
  "name": "Tactic.NormCast.coeDelaborator"},
 {"type":
  "∀ {α : Type u_4} {β : Type u_6} {γ : Type u_3} {δ : Type u_5} {ε : Type u_1} {ζ : Type u_2} (f : α → β) (f' : γ → δ)\n  (g : β → ε) (g' : δ → ζ), Prod.map g g' ∘ Prod.map f f' = Prod.map (g ∘ f) (g' ∘ f')",
  "offspring": ["Function.comp_apply", "prod_map"],
  "name": "Prod.map_comp_map"},
 {"type": "Unit → Bool",
  "offspring": [],
  "name": "System.Platform.getIsEmscripten"},
 {"type":
  "{α : Type u} → (a : Array α) → (i : USize) → α → USize.toNat i < Array.size a → Array α",
  "offspring": ["Array.set", "USize.toNat"],
  "name": "Array.uset"},
 {"type": "Ordering → Bool", "offspring": [], "name": "Ordering.isLE"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : Array α),\n  (Array.isEqv a b fun a b => decide (a = b)) = false → a = b → False",
  "offspring": ["Array.isEqv", "Decidable.decide", "Array.isEqv_self"],
  "name": "Array.instDecidableEqArray.proof_3"},
 {"type": "(a b : UInt64) → Decidable (a = b)",
  "offspring": ["UInt64.decEq.proof_1", "UInt64.decEq.proof_2"],
  "name": "UInt64.decEq"},
 {"type": "{α : Type u} → Sort u_1 → Task α → Task α → Sort u_1",
  "offspring": [],
  "name": "Task.noConfusionType"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.RightInverse f g → g ∘ f = id",
  "offspring": [],
  "name": "Function.RightInverse.comp_eq_id"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (k : ℕ) (v : Nat.Linear.Var) (p : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.insertSorted k v p) =\n    Nat.Linear.Poly.denote ctx p + k * Nat.Linear.Var.denote ctx v",
  "offspring":
  ["Nat.zero_add",
   "cond_true",
   "Nat.add_left_comm",
   "Bool.of_not_eq_true",
   "cond_false",
   "Nat.add_assoc"],
  "name": "Nat.Linear.Poly.denote_insertSorted"},
 {"type": "∀ {n m : ℕ}, n - m = 0 → n ≤ m",
  "offspring":
  ["Nat.sub_zero",
   "le_refl",
   "Nat.zero_le",
   "Nat.add_le_add_right",
   "Nat.add_sub_add_right"],
  "name": "Nat.le_of_sub_eq_zero"},
 {"type": "Task.Priority", "offspring": [], "name": "Task.Priority.default"},
 {"type": "∀ (n : ℕ), -Int.ofNat (Nat.succ n) = -[1+ n]",
  "offspring": [],
  "name": "Int.neg_ofNat_of_succ"},
 {"type": "∀ {p q : Prop} (hp : p) (hq : q), HEq hp hq",
  "offspring": [],
  "name": "proof_irrel_heq"},
 {"type": "Sat.Clause", "offspring": [], "name": "Sat.Clause.nil"},
 {"type": "System.FilePath → BaseIO Bool",
  "offspring": ["System.FilePath.metadata", "Except.toBool"],
  "name": "System.FilePath.pathExists"},
 {"type": "{n : ℕ} → OfNat UInt16 n",
  "offspring": ["OfNat.mk", "UInt16.ofNat"],
  "name": "instOfNatUInt16"},
 {"type":
  "∀ {α : Sort u_1} {r : α → α → Prop}, WellFounded r → WellFounded (TC r)",
  "offspring": ["WellFounded.intro", "TC.accessible", "WellFounded.apply"],
  "name": "TC.wf.proof_1"},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeSort α β] → α → β",
  "offspring": [],
  "name": "CoeSort.coe"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε β : Type u_1} {e : ε} [inst : Monad m], ExceptCpsT.run (throw e) = pure (Except.error e)",
  "offspring": [],
  "name": "ExceptCpsT.run_throw"},
 {"type": "{α : Type u_1} → ℕ → Array α → Array α",
  "offspring":
  ["WellFounded.fix",
   "WellFoundedRelation.rel",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Array.swap",
   "Nat.lt_of_le_of_lt",
   "Nat.pred_le",
   "Array.size_swap",
   "Nat.sub_succ_lt_self",
   "Array.pop"],
  "name": "Array.eraseIdxAux"},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "offspring":
  ["or",
   "MonadExcept.tryCatch",
   "Tactic.NormCast.isCoeOf?",
   "DoResultPR",
   "Tactic.NormCast.mkCoe",
   "Tactic.NormCast.proveEqUsingDown",
   "Alternative.failure",
   "DoResultPR.pure",
   "Tactic.NormCast.isNumeral?",
   "DoResultPR.return"],
  "name": "Tactic.NormCast.splittingProcedure"},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (β → Float → m β) → FloatArray → USize → USize → β → m β",
  "offspring": ["FloatArray.uget", "lcProof", "FloatArray.foldlMUnsafe.fold"],
  "name": "FloatArray.foldlMUnsafe.fold"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x y : Fin (UnionFind.size self)),\n  (Array.get self.arr y).parent = ↑y →\n    ¬↑x = ↑y →\n      ¬(Array.get self.arr y).rank < (Array.get self.arr x).rank →\n        ∃ n m,\n          UFModel.Models\n            (if e : (Array.get self.arr x).rank = (Array.get self.arr y).rank then\n              Array.set\n                (Array.set self.arr x\n                  { parent := ↑y, value := (Array.get self.arr x).value, rank := (Array.get self.arr x).rank })\n                { val := ↑y,\n                  isLt :=\n                    (_ :\n                      ↑y <\n                        Array.size\n                          (Array.set self.arr x\n                            { parent := ↑y, value := (Array.get self.arr x).value,\n                              rank := (Array.get self.arr x).rank })) }\n                { parent := (Array.get self.arr y).parent, value := (Array.get self.arr y).value,\n                  rank := (Array.get self.arr y).rank + 1 }\n            else\n              Array.set self.arr x\n                { parent := ↑y, value := (Array.get self.arr x).value, rank := (Array.get self.arr x).rank })\n            m",
  "offspring":
  ["UnionFind.arr",
   "UFModel.setParentBump",
   "UFModel.Models.rank_eq",
   "not_lt",
   "Nat.instLinearOrderNat",
   "UFModel.Models.parent_eq'",
   "UFModel.parent",
   "UnionFind.size",
   "UnionFind.model'"],
  "name": "UnionFind.link.proof_3"},
 {"type": "Add ℤ",
  "offspring": ["Add.mk", "Int.add"],
  "name": "Int.instAddInt"},
 {"type": "∀ {p : Prop} (P : p → Prop), ¬p → ∀ (h2 : p), P h2",
  "offspring": [],
  "name": "forall_prop_decidable.proof_2"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Repr α] → [inst : Repr β] → Repr (α ⊕ β)",
  "offspring": ["reprArg"],
  "name": "instReprSum"},
 {"type": "∀ (n : ℕ), ¬Nat.succ n ≤ n",
  "offspring": ["Nat.not_succ_le_zero", "Nat.le_of_succ_le_succ"],
  "name": "Nat.not_succ_le_self"},
 {"type": "Type u → Type u", "offspring": [], "name": "MulZeroClass"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → Sort u_1 → MonadLiftT m n → MonadLiftT m n → Sort u_1",
  "offspring": [],
  "name": "MonadLiftT.noConfusionType"},
 {"type": "Lean.Expr → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring":
  ["Tactic.Ring.addAtom",
   "MonadReader.read",
   "Tactic.Ring.Cache.α",
   "Tactic.Ring.HornerExpr.xadd'",
   "Tactic.Ring.mkAppCS",
   "Tactic.Ring.HornerExpr.const"],
  "name": "Tactic.Ring.evalAtom"},
 {"type":
  "∀ {α : Type u} {y : α} {ys : List α} {x : α},\n  List.getLast (x :: y :: ys) (_ : x :: y :: ys ≠ []) = List.getLast (y :: ys) (_ : y :: ys ≠ [])",
  "offspring": [],
  "name": "List.getLast_cons_cons"},
 {"type": "ToString Unit",
  "offspring": ["ToString.mk"],
  "name": "instToStringUnit"},
 {"type": "∀ {a b c : ℕ}, a < b → b < c → a < c",
  "offspring": ["Nat.lt_trans"],
  "name": "Nat.instTransNatLtInstLTNat.proof_1"},
 {"type": "∀ {p : Prop}, p ∨ ¬p", "offspring": ["em"], "name": "or_not"},
 {"type": "{α : Type u} → ℕ → α → Array α",
  "offspring": ["Array.mk", "List.replicate"],
  "name": "Array.mkArray"},
 {"type": "DecidableRel fun a a_1 => a ∣ a_1",
  "offspring": ["decidable_of_decidable_of_iff", "Nat.decidable_dvd.proof_1"],
  "name": "Nat.decidable_dvd"},
 {"type": "{α : Type s} → α → ulift α", "offspring": [], "name": "ulift.up"},
 {"type":
  "{α : Type u} → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → Subarray α",
  "offspring": ["Subarray.mk", "Nat.le_refl", "Array.toSubarray.proof_1"],
  "name": "Array.toSubarray"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l ↔ ∃ n, List.get? l n = some a",
  "offspring":
  ["List.mem_iff_get", "List.Fin.exists_iff", "List.get", "List.get?_eq_some"],
  "name": "List.mem_iff_get?"},
 {"type":
  "∀ {α : Type u_1} {x : Option (Option α)}, Option.join x ≠ none ↔ ∃ z, x = some (some z)",
  "offspring":
  ["ne_eq",
   "Option.bind",
   "Option.bind_eq_none",
   "Option.mem_def",
   "id_eq",
   "not_forall",
   "not_not",
   "exists_prop",
   "exists_eq_right"],
  "name": "Option.join_ne_none"},
 {"type":
  "∀ {β : Type u_1} (rb : β → β → Prop) {a₂ : ℕ} {b₂ : β} {a₁ : ℕ} {b₁ : β},\n  a₁ ≤ a₂ → rb b₁ b₂ → Prod.Lex Nat.lt rb (a₁, b₁) (a₂, b₂)",
  "offspring": ["Nat.eq_or_lt_of_le", "Prod.Lex.right", "Prod.Lex.left"],
  "name": "Prod.Lex.right'.proof_1"},
 {"type": "Float → Float", "offspring": [], "name": "Float.sqrt"},
 {"type": "(α : Type u_1) → (α → α → Bool) → Type u_1",
  "offspring": [],
  "name": "BinaryHeap"},
 {"type": "Xor UInt32",
  "offspring": ["Xor.mk", "UInt32.xor"],
  "name": "instXorUInt32"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Sort v} (f : (a : α) → motive (Quot.mk r a)),\n  (∀ (a b : α), r a b → (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) →\n    ∀ (a b : α), r a b → Quot.indep f a = Quot.indep f b",
  "offspring": ["PSigma.eta", "Quot.sound"],
  "name": "Quot.indepCoherent"},
 {"type": "Type u → Type u", "offspring": [], "name": "Task"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_4} {δ : Type u_3} (f : α → γ) (g : β → δ) (p : α × β),\n  (Prod.map f g p).snd = g p.snd",
  "offspring": ["prod_map"],
  "name": "Prod.map_snd"},
 {"type": "∀ {n : ℕ}, Fin n → 0 < n",
  "offspring": ["Nat.eq_or_lt_of_le", "Nat.zero_le", "Nat.lt_trans"],
  "name": "Fin.size_positive"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : β → β → Prop} (f : α → β), WellFounded r → WellFounded (InvImage r f)",
  "offspring":
  ["WellFounded.intro", "InvImage.accessible", "WellFounded.apply"],
  "name": "InvImage.wf.proof_1"},
 {"type": "ReprAtom ℕ",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomNat"},
 {"type": "∀ (α : Sort u) {β : Sort v} [inst : Nonempty β], Nonempty (α → β)",
  "offspring": ["instNonemptyForAll.proof_1"],
  "name": "instNonemptyForAll"},
 {"type": "{p q : Prop} → [d : Decidable (p ↔ q)] → Decidable (p = q)",
  "offspring": ["instDecidableEqProp.proof_1"],
  "name": "instDecidableEqProp"},
 {"type":
  "∀ {P : ℕ → ℕ → Prop} (m n : ℕ), (∀ (n : ℕ), P 0 n) → (∀ (m n : ℕ), 0 < m → P (n % m) m → P m n) → P m n",
  "offspring":
  ["WellFounded.induction",
   "WellFoundedRelation.wf",
   "Nat.lt_wfRel",
   "Nat.succ_pos"],
  "name": "Nat.gcd.induction"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk"],
  "name": "UInt16.add"},
 {"type": "UInt32 → Fin UInt32.size", "offspring": [], "name": "UInt32.val"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (α → β → γ → δ) → List α → List β → List γ → List δ",
  "offspring": [],
  "name": "List.zipWith₃"},
 {"type":
  "∀ {σ : Type u} [inst : SizeOf σ] (a : σ), sizeOf (DoResultBC.continue a) = 1 + sizeOf a",
  "offspring": [],
  "name": "DoResultBC.continue.sizeOf_spec"},
 {"type": "Lean.ParametricAttribute (Array Lean.Name)",
  "offspring": [],
  "name": "simpsAttr"},
 {"type": "∀ {n a : ℕ}, a < n → ↑(Fin.ofNat' a (_ : 0 < n)) = a",
  "offspring": ["Nat.mod_eq_of_lt"],
  "name": "Fin.val_eq_of_lt"},
 {"type":
  "(ρ : Type u) → {m : Type u → Type v} → [inst : MonadWithReaderOf ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "offspring": ["MonadWithReaderOf.withReader"],
  "name": "withTheReader"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«tactic·.__;_»"},
 {"type": "∀ {n m : ℕ}, ¬n < m ↔ m ≤ n",
  "offspring": ["Nat.le_of_not_lt", "Nat.not_lt_of_le"],
  "name": "Nat.not_lt"},
 {"type": "{R : Type u_1} → [inst : AddGroupWithOne R] → ℤ → R",
  "offspring": ["AddGroupWithOne.intCast"],
  "name": "Int.cast"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt), Array.size self.arr = Array.size self.arr",
  "offspring": ["BinaryHeap.arr"],
  "name": "BinaryHeap.popMaxAux.proof_1"},
 {"type": "∀ (p : ℕ → Prop) (n : ℕ), n < 0 → ¬p n",
  "offspring": ["Nat.not_lt_zero"],
  "name": "Nat.find_x.proof_3"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.injective f → ∀ {a : α} {l : List α}, f a ∈ List.map f l ↔ a ∈ l",
  "offspring": ["List.exists_of_mem_map", "List.mem_map_of_mem"],
  "name": "List.mem_map_of_injective"},
 {"type": "{g : Type u} → [self : RandomGen g] → g → ℕ × ℕ",
  "offspring": [],
  "name": "RandomGen.range"},
 {"type":
  "∀ {toString toString_1 : String}, { toString := toString } = { toString := toString_1 } → toString = toString_1",
  "offspring": [],
  "name": "System.FilePath.mk.inj"},
 {"type":
  "∀ {R : Type u} [self : Distrib R] (a b c : R), a * (b + c) = a * b + a * c",
  "offspring": [],
  "name": "Distrib.left_distrib"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "offspring": [],
  "name": "propext"},
 {"type": "Sort u → UInt64 → UInt64 → Sort u",
  "offspring": [],
  "name": "UInt64.noConfusionType"},
 {"type": "∀ {m n : ℕ}, m < n → Int.subNatNat m n = -[1+ Nat.pred (n - m)]",
  "offspring":
  ["Int.subNatNat_of_sub_eq_succ",
   "Nat.succ_pred_eq_of_pos",
   "Nat.sub_pos_of_lt"],
  "name": "Int.subNatNat_of_lt"},
 {"type": "∀ (m n : ℕ), Int.ofNat m * -[1+ n] = Int.negOfNat (m * Nat.succ n)",
  "offspring": [],
  "name": "Int.ofNat_mul_negSucc_ofNat"},
 {"type": "∀ {a b : Prop}, ¬(a ∧ b) ↔ a → ¬b",
  "offspring": ["and_imp"],
  "name": "not_and"},
 {"type": "{α : Type u} → (α → α → Prop) → Dvd α",
  "offspring": [],
  "name": "Dvd.mk"},
 {"type": "∀ {a b : ℤ}, -a < b → -b < a",
  "offspring": [],
  "name": "Int.neg_lt_of_neg_lt"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∨_»"},
 {"type": "∀ (a : ℤ), Int.sign a = 1 ↔ 0 < a",
  "offspring": ["Int.pos_of_sign_eq_one", "Int.sign_eq_one_of_pos"],
  "name": "Int.sign_eq_one_iff_pos"},
 {"type": "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l → l ≠ []",
  "offspring": [],
  "name": "List.ne_nil_of_mem"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.nolint"},
 {"type": "∀ {a b : ℕ}, ¬a < b → a = b ∨ b < a",
  "offspring": ["Or.resolve_left", "Nat.lt_trichotomy"],
  "name": "Nat.eq_or_lt_of_not_lt"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["HShiftLeft.hShiftLeft", "Fin.shiftLeft.proof_1"],
  "name": "Fin.shiftLeft"},
 {"type": "∀ (a b : ℕ), (¬a > b) = (a ≤ b)",
  "offspring": ["Nat.not_lt_eq"],
  "name": "Nat.not_gt_eq"},
 {"type":
  "{m : Type u → Type v} → ({α β : Type u} → m α → (Option α → m β) → m (α × β)) → MonadFinally m",
  "offspring": [],
  "name": "MonadFinally.mk"},
 {"type": "ShiftLeft UInt16",
  "offspring": ["ShiftLeft.mk", "UInt16.shiftLeft"],
  "name": "instShiftLeftUInt16"},
 {"type":
  "{α : Type} →\n  [inst : Inhabited α] → (as : Array α) → α → (α → α → Bool) → optParam ℕ 0 → optParam ℕ (Array.size as - 1) → Bool",
  "offspring": ["Array.binSearchAux", "instInhabitedBool", "Option.isSome"],
  "name": "Array.binSearchContains"},
 {"type":
  "{G : Type u} → [inst : Mul G] → (∀ (a b c : G), a * b = a * c → b = c) → IsMulLeftCancel G",
  "offspring": [],
  "name": "IsMulLeftCancel.mk"},
 {"type": "∀ (m n : ℕ), n * (m / n) ≤ m",
  "offspring":
  ["Nat.eq_zero_or_pos",
   "Nat.zero_mul",
   "Nat.zero_le",
   "Nat.le_div_iff_mul_le",
   "Nat.le_refl"],
  "name": "Nat.mul_div_le"},
 {"type":
  "∀ {v : Sat.Valuation} {f : Sat.Fmla},\n  (∀ (c : Sat.Clause), c ∈ f → Sat.Valuation.satisfies v c) → Sat.Valuation.satisfies_fmla v f",
  "offspring": [],
  "name": "Sat.Valuation.satisfies_fmla.mk"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAdd α β γ] → α → β → γ",
  "offspring": [],
  "name": "HAdd.hAdd"},
 {"type": "∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ ~ l₂ ↔ l₂ ~ l₁",
  "offspring": ["List.Perm.symm"],
  "name": "List.Perm_comm"},
 {"type": "{f : Type u → Type v} → [self : Applicative f] → Functor f",
  "offspring": [],
  "name": "Applicative.toFunctor"},
 {"type": "∀ {a b : ℤ}, b ≠ 0 → b * a = b → a = 1",
  "offspring": ["Int.eq_of_mul_eq_mul_left", "Int.mul_one"],
  "name": "Int.eq_one_of_mul_eq_self_right"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → ℕ → (ℕ → m Unit) → m Unit",
  "offspring": [],
  "name": "Nat.forM"},
 {"type": "{n : ℕ} → LinearOrder (Fin n)",
  "offspring": ["LinearOrder.mk", "Fin.le_total", "inferInstance"],
  "name": "instLinearOrderFin"},
 {"type": "∀ {n m : ℕ}, n ≤ m → ¬n = m → n < m",
  "offspring": ["Nat.lt_or_ge", "Nat.le_antisymm"],
  "name": "Nat.lt_of_le_of_ne"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≥ b → ¬a < b",
  "offspring": ["not_le_of_gt"],
  "name": "not_lt_of_ge"},
 {"type": "∀ {a b c : ℤ}, a < b + c → -c + a < b",
  "offspring": ["Int.neg_add_lt_left_of_lt_add", "Int.add_comm"],
  "name": "Int.neg_add_lt_right_of_lt_add"},
 {"type": "∀ {α : Sort u} (x : α), (Classical.epsilon fun y => y = x) = x",
  "offspring": ["Classical.epsilon_spec"],
  "name": "Classical.epsilon_singleton"},
 {"type": "{m : Type u → Type v} → Sort u_1 → Bind m → Bind m → Sort u_1",
  "offspring": [],
  "name": "Bind.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p q : α × β}, Prod.swap p = Prod.swap q ↔ p = q",
  "offspring": ["Function.injective.eq_iff", "Prod.swap_injective"],
  "name": "Prod.swap_inj"},
 {"type": "∀ {n m : ℕ}, n < m → Nat.succ n < Nat.succ m",
  "offspring": ["Nat.succ_le_succ"],
  "name": "Nat.succ_lt_succ"},
 {"type": "RandomGen StdGen",
  "offspring": ["RandomGen.mk", "stdRange", "stdNext", "stdSplit"],
  "name": "instRandomGenStdGen"},
 {"type": "∀ (a : UInt64), 0 * a = 0",
  "offspring":
  ["UInt64.zero_def", "UInt64.mul_def", "UInt64.mk", "MonoidWithZero.zero_mul"],
  "name": "UInt64.instSemiringUInt64.proof_9"},
 {"type":
  "∀ {n : ℕ} (a b : Fin n), a - b = { val := (↑a + (n - ↑b)) % n, isLt := (_ : (↑a + (n - ↑b)) % n < n) }",
  "offspring": [],
  "name": "Fin.sub_def"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → [inst : Coe β δ] → [inst : CoeTC α β] → CoeTC α δ",
  "offspring": ["CoeTC.mk", "Coe.coe", "CoeTC.coe"],
  "name": "coeTrans"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.«tacticPick_goal-_»"},
 {"type": "∀ {a b : Prop}, ¬a → ((b ↔ a) ↔ ¬b)",
  "offspring": ["Iff.trans", "Iff.comm", "iff_false_left"],
  "name": "iff_false_right"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (l₁ l₂ : List α), List.map f (l₁ ++ l₂) = List.map f l₁ ++ List.map f l₂",
  "offspring":
  ["List.map", "List.nil_append", "List.List.append_eq", "List.cons_append"],
  "name": "List.map_append"},
 {"type": "Complement UInt64",
  "offspring": ["Complement.mk", "UInt64.complement"],
  "name": "instComplementUInt64"},
 {"type": "{α : Sort u} → [self : Inhabited α] → α",
  "offspring": [],
  "name": "Inhabited.default"},
 {"type": "∀ {a c b d : ℕ}, a < c → b ≤ d → 0 < b → a * b < c * d",
  "offspring":
  ["Nat.lt_of_lt_of_le",
   "Nat.mul_lt_mul_of_pos_right",
   "Nat.mul_le_mul_of_nonneg_left"],
  "name": "Nat.mul_lt_mul"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a₁ x : α) (n₁ n₂ : ℕ) (b : α) (n' : ℕ),\n  n₁ + n₂ = n' → Tactic.Ring.horner (Tactic.Ring.horner a₁ x n₁ 0) x n₂ b = Tactic.Ring.horner a₁ x n' b",
  "offspring": ["add_zero", "Semigroup.mul_assoc", "pow_add"],
  "name": "Tactic.Ring.horner_horner"},
 {"type": "∀ {n : ℕ} {i j : Fin n}, i ≠ j → ↑i ≠ ↑j",
  "offspring": ["Fin.eq_of_val_eq"],
  "name": "Fin.val_ne_of_ne"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] (a : α) (v : β a) (f : (a : α) → β a),\n  Function.update f a v a = v",
  "offspring": ["dif_pos"],
  "name": "Function.update_same"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a x : α) (n : ℕ) (b c a' b' : α),\n  a * c = a' → b * c = b' → Tactic.Ring.horner a x n b * c = Tactic.Ring.horner a' x n b'",
  "offspring": ["add_mul", "Semigroup.mul_assoc", "CommSemigroup.mul_comm"],
  "name": "Tactic.Ring.horner_mul_const"},
 {"type": "∀ {a b c : ℕ}, a ≤ b → a * c ≤ b * c",
  "offspring":
  ["Nat.le_antisymm",
   "le_refl",
   "Nat.zero_le",
   "Nat.mul_zero",
   "Nat.le_of_lt",
   "Nat.mul_lt_mul_of_pos_right",
   "not_le",
   "Nat.instLinearOrderNat"],
  "name": "Nat.mul_le_mul_of_nonneg_right"},
 {"type": "ToString ByteSlice",
  "offspring":
  ["ToString.mk", "Id.run", "ForIn.forIn", "Id.instMonadId", "UInt8.toChar"],
  "name": "instToStringByteSlice"},
 {"type": "Semiring UInt32",
  "offspring":
  ["Semiring.mk",
   "UInt32.instSemiringUInt32.proof_13",
   "UInt32.instSemiringUInt32.proof_14",
   "UInt32.instSemiringUInt32.proof_15",
   "UInt32.instSemiringUInt32.proof_16",
   "Semigroup",
   "UInt32.instSemigroupUInt32",
   "AddCommSemigroup",
   "UInt32.instAddCommSemigroupUInt32"],
  "name": "UInt32.instSemiringUInt32"},
 {"type": "∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c)",
  "offspring": [],
  "name": "Iff.trans"},
 {"type": "Hashable USize",
  "offspring": ["Hashable.mk", "USize.toUInt64"],
  "name": "instHashableUSize"},
 {"type": "{α : Type} → Array α → (α → Bool) → Option α",
  "offspring": ["Id.run", "Array.findRevM?", "Id.instMonadId"],
  "name": "Array.findRev?"},
 {"type": "sizeOf Tactic.NormCast.CoeFnType.coe = 1",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.coe.sizeOf_spec"},
 {"type": "(m : Type u_1 → Type u_2) → MonadLiftT m m",
  "offspring": ["MonadLiftT.mk"],
  "name": "instMonadLiftT_1"},
 {"type": "∀ {b : Bool}, ¬b = true → b = false",
  "offspring": [],
  "name": "Bool.of_not_eq_true"},
 {"type": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "offspring": ["HMul.mk", "Mul.mul"],
  "name": "instHMul"},
 {"type": "(n : ℕ) → n < UInt8.size → UInt8",
  "offspring": ["UInt8.mk", "UInt8.size"],
  "name": "UInt8.ofNatCore"},
 {"type":
  "∀ {m : Type u → Type u_1} {α ε : Type u} [inst : Monad m] (x : m α),\n  ExceptCpsT.run (ExceptCpsT.lift x) = do\n    let a ← x\n    pure (Except.ok a)",
  "offspring": [],
  "name": "ExceptCpsT.run_lift"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), Nat.land a b % n < n",
  "offspring": [],
  "name": "Fin.land.proof_1"},
 {"type":
  "∀ {R : Type u_1} {n : ℕ} [inst : AddMonoidWithOne R], ↑(Nat.succ n) = ↑n + 1",
  "offspring": ["AddMonoidWithOne.natCast_succ"],
  "name": "Nat.cast_succ"},
 {"type": "∀ (a : Prop), ¬¬(a ∨ ¬a)", "offspring": [], "name": "not_not_em"},
 {"type":
  "Lean.Expr × ℕ → Tactic.Ring.HornerExpr → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring":
  ["Tactic.Ring.HornerExpr.const",
   "PProd.snd",
   "Tactic.Ring.HornerExpr.xadd'",
   "Tactic.Ring.mkAppCS",
   "Tactic.Ring.HornerExpr.e"],
  "name": "Tactic.Ring.evalConstMul"},
 {"type": "Substring → (Char → Bool) → Substring",
  "offspring": ["Substring.mk"],
  "name": "Substring.dropRightWhile"},
 {"type": "{α : Sort u} → (α → α → Prop) → (α → α → Prop) → Prop",
  "offspring": [],
  "name": "Subrelation"},
 {"type": "∀ (p : Prop), (p ↔ False) = ¬p",
  "offspring": [],
  "name": "iff_false"},
 {"type": "{α : Type u_1} → Option α → Bool",
  "offspring": [],
  "name": "Option.isNone"},
 {"type": "{α : Sort u} → [self : Hashable α] → α → UInt64",
  "offspring": [],
  "name": "Hashable.hash"},
 {"type": "∀ {R : Type u_1} [inst : AddGroupWithOne R], ↑0 = 0",
  "offspring": ["Int.cast", "Int.cast_ofNat", "Nat.cast_zero"],
  "name": "Int.cast_zero"},
 {"type": "∀ {a b : Prop}, ¬b → (a → b) → ¬a",
  "offspring": ["mt"],
  "name": "Not.imp"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (n : ℕ) (hsz : Array.size a = n) (x : ℕ) (x_1 : x ≤ Array.size a),\n  Array.toListLitAux a n hsz x x_1 (List.drop x a.data) = a.data",
  "offspring": ["Nat.add", "Nat.add_zero"],
  "name": "Array.toArrayLit_eq'.aux"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (as : Array α) (start stop : ℕ) (h₁ : start ≤ stop) (h₂ : stop ≤ Array.size as),\n  sizeOf { as := as, start := start, stop := stop, h₁ := h₁, h₂ := h₂ } =\n    1 + sizeOf as + sizeOf start + sizeOf stop + sizeOf h₁ + sizeOf h₂",
  "offspring": ["instSizeOfNat"],
  "name": "Subarray.mk.sizeOf_spec"},
 {"type":
  "∀ (x x_1 x_2 : UInt64), { val := (x + x_1 + x_2).1 } = { val := (x + (x_1 + x_2)).1 }",
  "offspring": ["UInt64.mk", "AddSemigroup.add_assoc"],
  "name": "UInt64.instAddSemigroupUInt64.proof_1"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), (Equiv.symm e).toFun ∘ e.toFun = id",
  "offspring": ["Equiv.symm_apply_apply"],
  "name": "Equiv.symm_comp_self"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a : α},\n  p a → ∀ {l₁ : List α} (l₂ : List α), a ∈ l₁ → List.erasep p (l₁ ++ l₂) = List.erasep p l₁ ++ l₂",
  "offspring":
  ["Subsingleton.elim",
   "List.cons_append",
   "List.erasep_cons_of_pos",
   "List.erasep_cons_of_neg",
   "List.cons.injEq",
   "true_and",
   "List.mem_of_ne_of_mem",
   "mt"],
  "name": "List.erasep_append_left"},
 {"type": "{α : Type u} → List α → Bool",
  "offspring": [],
  "name": "List.isEmpty"},
 {"type": "Tactic.DeclCache (Std.HashMap Lean.HeadIndex (Array Lean.Name))",
  "offspring": [],
  "name": "Tactic.Find.findDeclsPerHead"},
 {"type":
  "∀ {α : Type u_1} {o : Option α} (h : Option.isSome o = true), Option.get h ∈ o",
  "offspring": ["Option.get"],
  "name": "Option.get_mem"},
 {"type": "{f : Type u → Type v} → Sort u_1 → Seq f → Seq f → Sort u_1",
  "offspring": [],
  "name": "Seq.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a₁ x : α) (n₁ : ℕ) (b₁ a₂ : α) (n₂ : ℕ) (b₂ : α) (k : ℕ) (a' b' : α),\n  n₁ + k = n₂ →\n    a₁ + Tactic.Ring.horner a₂ x k 0 = a' →\n      b₁ + b₂ = b' → Tactic.Ring.horner a₁ x n₁ b₁ + Tactic.Ring.horner a₂ x n₂ b₂ = Tactic.Ring.horner a' x n₁ b'",
  "offspring":
  ["add_comm",
   "pow_add",
   "add_assoc",
   "add_left_comm",
   "add_zero",
   "add_mul",
   "Semigroup.mul_assoc"],
  "name": "Tactic.Ring.horner_add_horner_lt"},
 {"type":
  "∀ {α : Type u_1} (x : α) (h : Option.isSome (some x) = true), Option.get h = x",
  "offspring": [],
  "name": "Option.get_some"},
 {"type":
  "∀ (i i_1 : Nat.Linear.Var), (Nat.Linear.Expr.var i = Nat.Linear.Expr.var i_1) = (i = i_1)",
  "offspring": ["Nat.Linear.Var", "Nat.Linear.Expr", "Nat.Linear.Expr.var"],
  "name": "Nat.Linear.Expr.var.injEq"},
 {"type": "∀ {ub i : ℕ}, i < ub → Nat.Up ub (i + 1) i",
  "offspring": ["Nat.lt_succ_self"],
  "name": "Nat.Up.next"},
 {"type": "Repr UInt16",
  "offspring": ["repr", "instReprNat", "UInt16.toNat"],
  "name": "instReprUInt16"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {r : α → α → Prop} {s : β → β → Prop} {a₁ a₂ : α} (b : β),\n  r a₁ a₂ → PSigma.RevLex r s { fst := a₁, snd := b } { fst := a₂, snd := b }",
  "offspring": [],
  "name": "PSigma.RevLex.left"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] (a b c : α), min (min a b) c = min a (min b c)",
  "offspring": ["eq_min", "le_trans", "min_le_left", "le_min", "min_le_right"],
  "name": "min_assoc"},
 {"type":
  "∀ {α : Type u_1} (n : ℕ) (l : List α), List.removeNth l n = List.modifyNthTail List.tail n l",
  "offspring": ["congr_arg"],
  "name": "List.removeNth_eq_nth_tail"},
 {"type": "Type u → Type u", "offspring": [], "name": "CommMonoid"},
 {"type":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a b c : α), a * b * c = a * (b * c)) → NonUnitalSemiring α",
  "offspring": [],
  "name": "NonUnitalSemiring.mk"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticRepeat'_"},
 {"type":
  "∀ {α : Type u_3} {β : Type u_5} {γ : Type u_4} {δ : Type u_6} {ε : Type u_1} {ζ : Type u_2} (f : α → β) (f' : γ → δ)\n  (g : β → ε) (g' : δ → ζ) (x : α × γ), Prod.map g g' (Prod.map f f' x) = Prod.map (g ∘ f) (g' ∘ f') x",
  "offspring": ["Prod.map", "prod_map", "Function.comp_apply"],
  "name": "Prod.map_map"},
 {"type": "{α : Type u} → [inst : BEq α] → Array α → α → Option ℕ",
  "offspring": ["Array.findIdx?"],
  "name": "Array.getIdx?"},
 {"type": "∀ {n k m : ℕ}, m ≤ k → n ≤ k - m → m + n ≤ k",
  "offspring": ["Nat.not_lt", "Nat.sub_lt_left_of_lt_add"],
  "name": "Nat.add_le_of_le_sub_left"},
 {"type": "∀ {n m : ℕ}, n - m = 0 ↔ n ≤ m",
  "offspring": ["Nat.le_of_sub_eq_zero", "Nat.sub_eq_zero_of_le"],
  "name": "Nat.sub_eq_zero_iff_le"},
 {"type": "{α : Type u} → [inst : DecidableEq α] → Union (List α)",
  "offspring": ["Union.mk", "List.union"],
  "name": "List.instUnionList"},
 {"type": "{α β σ : Type u} → β → σ → DoResultPR α β σ",
  "offspring": [],
  "name": "DoResultPR.return"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (b : β), Function.injective fun a => (a, b)",
  "offspring": ["Prod.mk.inj"],
  "name": "Prod.mk.inj_right"},
 {"type": "{α : Type u_1} → UFNode α → ℕ",
  "offspring": [],
  "name": "UFNode.rank"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → (α → m (Option β)) → m (Option β)",
  "offspring": [],
  "name": "Array.findSomeRevM?"},
 {"type": "System.FilePath → String → System.FilePath",
  "offspring":
  ["System.FilePath.parent",
   "System.FilePath.mk",
   "HDiv.hDiv",
   "System.FilePath.instHDivFilePathString"],
  "name": "System.FilePath.withFileName"},
 {"type": "∀ {n : ℕ}, n ≥ 2 → Nat.AtLeastTwo n",
  "offspring": [],
  "name": "Nat.AtLeastTwo.mk"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), (a + b) % n < n",
  "offspring": [],
  "name": "Fin.add.proof_1"},
 {"type":
  "{m : Type → Type u} → [inst : Monad m] → {α : Type} → (α → m Bool) → List α → m (Option α)",
  "offspring": [],
  "name": "List.findM?"},
 {"type":
  "{G : Type u} →\n  [toMonoid : Monoid G] →\n    [toInv : Inv G] →\n      [toDiv : Div G] →\n        (∀ (a b : G), a / b = a * b⁻¹) →\n          (gpow : ℤ → G → G) →\n            (∀ (a : G), gpow 0 a = 1) →\n              (∀ (n : ℕ) (a : G), gpow (Int.ofNat (Nat.succ n)) a = a * gpow (Int.ofNat n) a) →\n                (∀ (n : ℕ) (a : G), gpow -[1+ n] a = (gpow (Int.ofNat (Nat.succ n)) a)⁻¹) → DivInvMonoid G",
  "offspring": [],
  "name": "DivInvMonoid.mk"},
 {"type":
  "∀ {α : Type u_1} {a y : α} {l : List α}, ¬a ∈ y :: l → a ≠ y ∧ ¬a ∈ l",
  "offspring": ["List.ne_of_not_mem_cons", "List.not_mem_of_not_mem_cons"],
  "name": "List.ne_and_not_mem_of_not_mem_cons"},
 {"type": "{α : Type u_1} → List α → ℕ",
  "offspring": [],
  "name": "List.redLength"},
 {"type": "Type", "offspring": [], "name": "Ordering"},
 {"type": "(n : ℕ) → n < UInt32.size → UInt32",
  "offspring": ["UInt32.mk", "UInt32.size"],
  "name": "UInt32.ofNat'"},
 {"type": "{n : ℕ} → ℕ → Fin (Nat.succ n)",
  "offspring": ["Fin.ofNat.proof_1"],
  "name": "Fin.ofNat"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a₁ x : α) (n₁ : ℕ) (b₁ a₂ : α) (n₂ : ℕ) (aa t : α),\n  Tactic.Ring.horner a₁ x n₁ b₁ * a₂ = aa →\n    Tactic.Ring.horner aa x n₂ 0 = t → Tactic.Ring.horner a₁ x n₁ b₁ * Tactic.Ring.horner a₂ x n₂ 0 = t",
  "offspring": ["add_zero", "add_mul", "Semigroup.mul_assoc"],
  "name": "Tactic.Ring.horner_mul_horner_zero"},
 {"type": "{α : Sort u_1} → [h : Nonempty α] → Inhabited α",
  "offspring": ["Classical.choice"],
  "name": "Classical.inhabitedOfNonempty'"},
 {"type": "-0 = 0", "offspring": [], "name": "Int.neg_zero"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun a a_1 => a ≤ a_1] {a b : α}, a ≤ b → a = b ∨ a < b",
  "offspring": ["Or.symm", "Decidable.lt_or_eq_of_le"],
  "name": "Decidable.eq_or_lt_of_le"},
 {"type": "∀ {b a : Prop} [inst : Decidable a], (¬a → b) → ¬b → a",
  "offspring": ["Decidable.not_imp_symm"],
  "name": "not.decidable_imp_symm"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {s : Set α} {b : β},\n  (∃ a, a ∈ s ∧ f a = b) → Function.inv_fun_on f s b ∈ s ∧ f (Function.inv_fun_on f s b) = b",
  "offspring": [],
  "name": "Function.inv_fun_on_pos"},
 {"type": "∀ (x : UInt64), npow_rec 0 x = npow_rec 0 x",
  "offspring": [],
  "name": "UInt64.instSemiringUInt64.proof_15"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a : α) (b : β) (a' : α) (b' : β), ¬a = a' → (a, b) = (a', b') → False",
  "offspring": [],
  "name": "instDecidableEqProd.proof_3"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, a1.val = a2.val → a1 = a2",
  "offspring": ["Subtype.mk"],
  "name": "Subtype.ext"},
 {"type":
  "∀ {ε σ α : Type u} [inst : SizeOf ε] [inst_1 : SizeOf σ] [inst_2 : SizeOf α] (a : α) (a_1 : σ),\n  sizeOf (EStateM.Result.ok a a_1) = 1 + sizeOf a + sizeOf a_1",
  "offspring": [],
  "name": "EStateM.Result.ok.sizeOf_spec"},
 {"type": "∀ (n : ℕ), 0 ≤ ↑n",
  "offspring": ["Int.ofNat_le", "Nat.zero_le"],
  "name": "Int.ofNat_zero_le"},
 {"type": "{A : Type u} → [self : AddMonoid A] → ℕ → A → A",
  "offspring": [],
  "name": "AddMonoid.nsmul"},
 {"type":
  "Std.HashMap Lean.Name Lean.MessageData → Lean.CoreM Lean.MessageData",
  "offspring":
  ["ForIn.forIn",
   "ForInStep",
   "EmptyCollection.emptyCollection",
   "Option.getD",
   "Functor.map",
   "List.mapM",
   "Mathlib.Tactic.Lint.printWarnings",
   "Array.toList",
   "Array.qsort",
   "Decidable.decide"],
  "name": "Mathlib.Tactic.Lint.groupedByFilename"},
 {"type": "Inhabited StdGen",
  "offspring": ["StdGen.mk"],
  "name": "instInhabitedStdGen"},
 {"type": "∀ (x : USize), npow_rec 0 x = npow_rec 0 x",
  "offspring": [],
  "name": "USize.instSemiringUSize.proof_15"},
 {"type": "{α : Type u_1} → List α → optParam ℕ 1 → List α",
  "offspring": ["List.drop", "List.take"],
  "name": "List.rotateLeft"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {γ : Type u_4} {δ : Type u_3} {f : α → γ} {g : β → δ},\n  Prod.map f g = fun p => (f p.fst, g p.snd)",
  "offspring": ["prod_map", "implies_true"],
  "name": "Prod.map_def"},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Monad m] → (ℕ → α → m α) → α → ℕ → m α",
  "offspring": [],
  "name": "Nat.foldRevM"},
 {"type":
  "{α : Type u_1} → {σ : α → Type u_2} → List α → ((a : α) → List (σ a)) → List ((a : α) × σ a)",
  "offspring": ["List.bind", "List.map", "Sigma.mk"],
  "name": "List.sigma"},
 {"type": "Lean.Syntax → Lean.Expr → Lean.Elab.TermElabM Unit",
  "offspring":
  ["Tactic.TryThis.delabToRefinableSyntax", "Tactic.TryThis.addSuggestion"],
  "name": "Tactic.TryThis.addTermSuggestion"},
 {"type": "UInt8 → Bool",
  "offspring": ["Decidable.decide", "GE.ge", "instLEUInt8"],
  "name": "UInt8.isLower"},
 {"type": "Float → Float", "offspring": [], "name": "Float.sinh"},
 {"type": "Type u → Type u", "offspring": [], "name": "CommSemiring"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} →\n    (stM : Type u → Type u) →\n      ({α : Type u} → (({β : Type u} → n β → m (stM β)) → m α) → n α) → ({α : Type u} → stM α → n α) → MonadControlT m n",
  "offspring": [],
  "name": "MonadControlT.mk"},
 {"type": "∀ {a b : Prop} [inst : Decidable b], ¬(a ∧ ¬b) ↔ a → b",
  "offspring": ["Not.decidable_imp_symm"],
  "name": "Decidable.not_and_not_right"},
 {"type": "{α : Type u} → (α → α → α) → Mul α",
  "offspring": [],
  "name": "Mul.mk"},
 {"type": "∀ (a : UInt32), -a + a = 0",
  "offspring":
  ["UInt32.eq_of_val_eq",
   "UInt32.neg_def",
   "UInt32.add_def",
   "UInt32.mk",
   "add_left_neg",
   "UInt32.zero_def"],
  "name": "UInt32.instRingUInt32.proof_6"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop} [inst : SizeOf α] [inst_1 : (a : α) → SizeOf (p a)] (val : α) (property : p val),\n  sizeOf { val := val, property := property } = 1 + sizeOf val + sizeOf property",
  "offspring": [],
  "name": "Subtype.mk.sizeOf_spec"},
 {"type": "∀ {m n : ℕ}, n % m = 0 → m ∣ n",
  "offspring": ["HDiv.hDiv"],
  "name": "Nat.dvd_of_mod_eq_zero"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "SeqLeft"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Conv.find"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {val val_1 : β}, PSum.inr val = PSum.inr val_1 → val = val_1",
  "offspring": [],
  "name": "PSum.inr.inj"},
 {"type": "Lean.Expr → List Lean.Expr → Lean.MetaM Bool",
  "offspring": ["List.anyM", "not"],
  "name": "Mathlib.Tactic.Lint.isConditionalHyps"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a : α} {l : List α}, p a → List.erasep p (a :: l) = l",
  "offspring": ["List.erasep_cons", "ite_true"],
  "name": "List.erasep_cons_of_pos"},
 {"type":
  "{f : Type u → Type v} → Sort u_1 → Alternative f → Alternative f → Sort u_1",
  "offspring": [],
  "name": "Alternative.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {n : ℕ}, List.get? l n = none ↔ List.length l ≤ n",
  "offspring": ["Classical.byContradiction", "List.get?_len_le"],
  "name": "List.get?_eq_none_iff"},
 {"type": "∀ {α : Sort u} (b : PLift α), { down := b.down } = b",
  "offspring": ["PLift.up", "PLift.down"],
  "name": "PLift.up_down"},
 {"type": "0 < 1",
  "offspring": ["Nat.zero_lt_succ"],
  "name": "Nat.zero_lt_one"},
 {"type": "{α β σ : Type u} → σ → DoResultPRBC α β σ",
  "offspring": [],
  "name": "DoResultPRBC.continue"},
 {"type": "(α : Type u) → Setoid (List α)",
  "offspring": ["Setoid.mk", "List.Perm", "List.Perm.Equivalence"],
  "name": "List.instSetoidList"},
 {"type": "∀ {a b : ℤ}, a ≤ b → b ≤ a → a = b",
  "offspring": ["Int.le.dest"],
  "name": "Int.le_antisymm"},
 {"type": "UInt64 → USize", "offspring": [], "name": "UInt64.toUSize"},
 {"type":
  "(m : Type u_1 → Type u_2) →\n  (n : Type u_1 → Type u_3) →\n    (o : Type u_1 → Type u_4) → [inst : MonadControl n o] → [inst : MonadControlT m n] → MonadControlT m o",
  "offspring":
  ["MonadControlT.mk",
   "MonadControlT.stM",
   "MonadControl.stM",
   "MonadControl.liftWith",
   "MonadControlT.liftWith",
   "MonadControl.restoreM",
   "MonadControlT.restoreM"],
  "name": "instMonadControlT"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq α] [inst_1 : DecidableEq β] {f : α → β} {as : List α},\n  List.inj_on f as → List.card (List.map f as) = List.card as",
  "offspring":
  ["List.inj_on", "List.card_nil", "implies_true", "List.exists_of_mem_map"],
  "name": "List.card_map_eq_of_inj_on"},
 {"type": "∀ (x y : ℕ) {z : ℕ}, 0 < z → (x + y * z) / z = x / z + y",
  "offspring": ["Nat.add_mul_div_left"],
  "name": "Nat.add_mul_div_right"},
 {"type": "{α : Type u} → {β : α → Type v} → (fst : α) → β fst → Sigma β",
  "offspring": [],
  "name": "Sigma.mk"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (Option α → β → γ) → List α → List β → List γ",
  "offspring": ["List.map₂Left", "flip"],
  "name": "List.map₂Right"},
 {"type": "{α : Sort u} → [inst : Nonempty α] → α",
  "offspring": ["Classical.choice", "Classical.ofNonempty.proof_1"],
  "name": "Classical.ofNonempty"},
 {"type": "{G : Type u} → [self : CommSemigroup G] → Semigroup G",
  "offspring": [],
  "name": "CommSemigroup.toSemigroup"},
 {"type": "∀ {α : Sort u_1} {a' : α}, ∃ a, a = a'",
  "offspring": [],
  "name": "exists_eq"},
 {"type":
  "{α : Type u_1} → (α → α → Bool) → (a : Array α) → (j : ℕ) → j < Array.size a → Array α",
  "offspring": [],
  "name": "Array.insertionSort.swapLoop"},
 {"type": "∀ {a b : ℤ}, a < b → a + 1 ≤ b",
  "offspring": [],
  "name": "Int.add_one_le_of_lt"},
 {"type": "ReprAtom Char",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomChar"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l₁ : List α} (l₂ : List α),\n  ¬a ∈ l₁ → List.erase (l₁ ++ l₂) a = l₁ ++ List.erase l₂ a",
  "offspring":
  ["List.erase_eq_erasep", "List.erasep", "List.erasep_append_right"],
  "name": "List.erase_append_right"},
 {"type": "∀ {n m k : ℕ}, n + m = n + k → m = k",
  "offspring":
  ["Nat.zero_eq", "Nat.zero_add", "Nat.succ_add", "Nat.succ.injEq"],
  "name": "Nat.add_left_cancel"},
 {"type": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "offspring": [],
  "name": "HEq"},
 {"type": "∀ {b : ℕ} (a : ℕ), Nat.min a b = min a b",
  "offspring": [],
  "name": "Nat.min_eq_min"},
 {"type": "{α : Sort u_1} → (α → Prop) → Prop",
  "offspring": [],
  "name": "ExistsUnique"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (fuel : ℕ) (m₁ m₂ r₁ r₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) →\n    Nat.Linear.Poly.denote_eq ctx (Nat.Linear.Poly.cancelAux fuel m₁ m₂ r₁ r₂)",
  "offspring":
  ["Nat.sub_eq",
   "List.append_nil",
   "cond_true",
   "List.reverse_cons",
   "Nat.Linear.Poly.denote_append",
   "Nat.Linear.Poly.denote_reverse",
   "Nat.zero_add",
   "Nat.add_left_comm",
   "Bool.of_not_eq_true",
   "cond_false"],
  "name": "Nat.Linear.Poly.denote_eq_cancelAux"},
 {"type": "Lean.FVarId → Lean.Elab.Tactic.TacticM Unit",
  "offspring": ["Tactic.NormCast.derive", "Option.map"],
  "name": "Tactic.NormCast.normCastHyp"},
 {"type": "{α : Type u_1} → List α → Option α",
  "offspring": [],
  "name": "List.last'"},
 {"type":
  "∀ {m : Type → Type} {ω σ : Type} [inst : Monad m] [inst_1 : LawfulMonad m], LawfulMonad (StateRefT' ω σ m)",
  "offspring": ["instLawfulMonadStateRefT'InstMonadStateRefT'.proof_1"],
  "name": "instLawfulMonadStateRefT'InstMonadStateRefT'"},
 {"type": "∀ {a b c : Prop}, c ∨ a → (a → b) → c ∨ b",
  "offspring": ["Or.imp_right"],
  "name": "or_of_or_of_imp_right"},
 {"type": "Hashable UInt32",
  "offspring": ["Hashable.mk", "UInt32.toUInt64"],
  "name": "instHashableUInt32"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) (x : α) (xs : List α),\n  ¬p x → (¬∃ x, x ∈ xs ∧ p x) → (∃ x_1, x_1 ∈ x :: xs ∧ p x_1) → False",
  "offspring": [],
  "name": "decidableBEx.proof_4"},
 {"type": "∀ {n m : ℕ}, Nat.ble n m = true → Nat.ble n (Nat.succ m) = true",
  "offspring": ["Nat.ble"],
  "name": "Nat.ble_succ_eq_true"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_>_»"},
 {"type":
  "∀ (atoms : Array Lean.Expr) (numAtoms : ℕ) (atoms_1 : Array Lean.Expr) (numAtoms_1 : ℕ),\n  ({ atoms := atoms, numAtoms := numAtoms } = { atoms := atoms_1, numAtoms := numAtoms_1 }) =\n    (atoms = atoms_1 ∧ numAtoms = numAtoms_1)",
  "offspring": ["Tactic.Ring.State", "Tactic.Ring.State.mk"],
  "name": "Tactic.Ring.State.mk.injEq"},
 {"type": "{R : Type u} → [self : CommRing R] → Ring R",
  "offspring": [],
  "name": "CommRing.toRing"},
 {"type":
  "∀ (lo hi : ℕ), lo ≤ hi → ∀ (z : Fin (Nat.succ (hi - lo))), lo ≤ lo + ↑z ∧ lo + ↑z ≤ hi",
  "offspring":
  ["Nat.le_add_right",
   "Nat.add_le_of_le_sub_left",
   "Nat.le_of_succ_le_succ",
   "Fin.isLt"],
  "name":
  "Random.instBoundedRandomNatToPreorderToPartialOrderInstLinearOrderNat.proof_1"},
 {"type": "∀ {m n : ℕ}, m ∣ n → Nat.gcd m n = m",
  "offspring":
  ["Nat.dvd_antisymm", "Nat.gcd_dvd_left", "Nat.dvd_gcd", "Nat.dvd_refl"],
  "name": "Nat.gcd_eq_left"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b ≤ a",
  "offspring":
  ["if_pos",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "le_refl",
   "if_neg",
   "le_of_not_le"],
  "name": "min_le_left"},
 {"type": "∀ {α : Type u_1} {β : Type u_2}, Prod.swap ∘ Prod.swap = id",
  "offspring": ["Prod.swap_swap"],
  "name": "Prod.swap_swap_eq"},
 {"type": "{α β : Type u} → Sort u_1 → MProd α β → MProd α β → Sort u_1",
  "offspring": [],
  "name": "MProd.noConfusionType"},
 {"type": "∀ {a b : Prop}, ¬(a ∧ b) ↔ b → ¬a",
  "offspring": ["Iff.trans", "not_and", "imp_not_comm"],
  "name": "not_and'"},
 {"type": "{α : Type u} → [self : Dvd α] → α → α → Prop",
  "offspring": [],
  "name": "Dvd.dvd"},
 {"type": "∀ {α : Type u_1} (a b : α), (bif false then a else b) = b",
  "offspring": [],
  "name": "cond_false"},
 {"type": "{α : Type u_1} → [inst : Repr α] → ReprTuple α",
  "offspring": ["ReprTuple.mk", "repr"],
  "name": "instReprTuple"},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal} {p : Prop}, (Sat.Valuation.neg v l → p) → Sat.Literal.reify v l p",
  "offspring": [],
  "name": "Sat.Literal.reify.mk"},
 {"type": "∀ {α : Type u} [self : Preorder α] (a : α), a ≤ a",
  "offspring": [],
  "name": "Preorder.le_refl"},
 {"type":
  "∀ {α : Type u_1} (as : Array α), Array.size as + 0 = Array.size as + 0",
  "offspring": [],
  "name": "Array.mapIdxM.proof_1"},
 {"type": "{α : Type u_1} → List α → ℕ → ℕ",
  "offspring": [],
  "name": "List.lengthTRAux"},
 {"type": "Sort u → Type u", "offspring": [], "name": "PLift"},
 {"type":
  "∀ {n : ℕ} (a : Fin n) (m : ℕ), a % m = { val := ↑a % m % n, isLt := (_ : ↑a % m % n < n) }",
  "offspring": [],
  "name": "Fin.modn_def"},
 {"type":
  "{ω σ : Type} →\n  {m : Type → Type} → [inst : Monad m] → [inst : MonadLiftT (ST ω) m] → {α : Type} → StateRefT' ω σ m α → σ → m (α × σ)",
  "offspring": [],
  "name": "StateRefT'.run"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α}, List.map f l = [] ↔ l = []",
  "offspring": ["List.map"],
  "name": "List.map_eq_nil"},
 {"type":
  "{ρ : Type u_1} → {α : Type u_2} → {m : Type u_3 → Type u_4} → [inst : Stream ρ α] → ForIn m ρ α",
  "offspring": ["ForIn.mk", "Stream.forIn"],
  "name": "instForIn"},
 {"type": "ℕ → Prop", "offspring": [], "name": "Nat.isValidChar"},
 {"type": "∀ (a n : ℕ), a % n % n = a % n",
  "offspring":
  ["Or.elim", "Nat.eq_zero_or_pos", "Nat.mod_zero", "Nat.mod_eq_of_lt"],
  "name": "Nat.mod_mod"},
 {"type": "∀ (z x y : ℕ), x * z % (y * z) = x % y * z",
  "offspring": ["Nat.mul_mod_mul_left"],
  "name": "Nat.mul_mod_mul_right"},
 {"type": "∀ {n : ℕ} (a b : Fin n), a ≤ b → b ≤ a → a = b",
  "offspring": ["Fin.eq_of_val_eq", "Nat.le_antisymm"],
  "name": "Fin.le_antisymm"},
 {"type": "{ρ : Type u} → {m : Type u → Type v} → m ρ → MonadReaderOf ρ m",
  "offspring": [],
  "name": "MonadReaderOf.mk"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_+_»"},
 {"type":
  "∀ {n : ℕ} (parent : Fin n → Fin n) (rank : ℕ → ℕ)\n  (rank_lt : ∀ (i : Fin n), ↑(parent i) ≠ ↑i → rank ↑i < rank ↑(parent i)) (parent_1 : Fin n → Fin n) (rank_1 : ℕ → ℕ)\n  (rank_lt_1 : ∀ (i : Fin n), ↑(parent_1 i) ≠ ↑i → rank_1 ↑i < rank_1 ↑(parent_1 i)),\n  ({ parent := parent, rank := rank, rank_lt := rank_lt } =\n      { parent := parent_1, rank := rank_1, rank_lt := rank_lt_1 }) =\n    (parent = parent_1 ∧ rank = rank_1)",
  "offspring": ["UFModel.mk"],
  "name": "UFModel.mk.injEq"},
 {"type": "Neg UInt64",
  "offspring": ["Neg.mk", "UInt64.mk"],
  "name": "UInt64.instNegUInt64"},
 {"type": "LT UInt16",
  "offspring": ["LT.mk", "UInt16.lt"],
  "name": "instLTUInt16"},
 {"type": "Lean.Elab.Tactic.Tactic",
  "offspring": ["Tactic.NormCast.derive"],
  "name": "Tactic.NormCast.evalConvNormCast"},
 {"type":
  "∀ {A : Type u} [inst : AddSemigroup A] [inst_1 : IsAddRightCancel A] {a b c : A}, b + a = c + a → b = c",
  "offspring": ["IsAddRightCancel.add_right_cancel"],
  "name": "add_right_cancel"},
 {"type": "Tactic.NormCast.Label",
  "offspring": [],
  "name": "Tactic.NormCast.Label.squash"},
 {"type": "{α : Type u_1} → [inst : Repr α] → Repr (List α)",
  "offspring": ["repr"],
  "name": "instReprList"},
 {"type": "{α : Sort u} → (α → α → Prop) → Sort (max 1 u)",
  "offspring": ["Decidable"],
  "name": "DecidableRel"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop} {a : α} {l : List α},\n  (∀ (a' : α), a' ∈ l → R a a') →\n    ∀ {a_2 : List.Pairwise R l},\n      List.Pairwise.below a_2 → motive l a_2 → List.Pairwise.below (_ : List.Pairwise R (a :: l))",
  "offspring": [],
  "name": "List.Pairwise.below.cons"},
 {"type": "∀ {n₁ m₁ n₂ m₂ : ℕ}, n₁ ≤ n₂ → m₁ ≤ m₂ → n₁ * m₁ ≤ n₂ * m₂",
  "offspring": ["Nat.le_trans", "Nat.mul_le_mul_right", "Nat.mul_le_mul_left"],
  "name": "Nat.mul_le_mul"},
 {"type": "∀ {n m : ℕ}, n ≤ m → n - m = 0",
  "offspring": ["Nat.le.dest", "Nat.sub_self_add"],
  "name": "Nat.sub_eq_zero_of_le"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk", "HShiftRight.hShiftRight", "UInt8.modn"],
  "name": "UInt8.shiftRight"},
 {"type": "∀ {a b c : ℤ}, b < -a + c → a + b < c",
  "offspring": [],
  "name": "Int.add_lt_of_lt_neg_add"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} [inst : Subsingleton α] (f : α → β), Function.injective f",
  "offspring": ["Subsingleton.elim"],
  "name": "Function.injective_of_subsingleton"},
 {"type": "{α : Type u} → String → α → α",
  "offspring": [],
  "name": "dbgTraceIfShared"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HSub α β γ → HSub α β γ → Sort u_1",
  "offspring": [],
  "name": "HSub.noConfusionType"},
 {"type": "∀ (n m k : ℕ), n + m + k = n + k + m",
  "offspring": ["Nat.add_assoc"],
  "name": "Nat.add_right_comm"},
 {"type": "{δ σ : Type u} → [self : EStateM.Backtrackable δ σ] → σ → δ → σ",
  "offspring": [],
  "name": "EStateM.Backtrackable.restore"},
 {"type": "∀ {a b : ℤ}, 0 < a → 0 < b → 0 < a * b",
  "offspring":
  ["Nat.cast_mul",
   "Int.ofNat_succ_pos",
   "Nat.add",
   "Nat.mul",
   "Int.eq_succ_of_zero_lt"],
  "name": "Int.mul_pos"},
 {"type":
  "Tactic.Ring.HornerExpr → Lean.Expr × ℕ → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring": [],
  "name": "Tactic.Ring.evalPow"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "solve"},
 {"type":
  "∀ {α : Type u_1} (j : ℕ) (a : Array α) (h : j < Array.size a) (j' : ℕ),\n  j = j' + 1 → j' < Array.size (Array.swap a { val := j, isLt := h } { val := j', isLt := (_ : j' < Array.size a) })",
  "offspring":
  ["Array.swap", "Nat.lt_trans", "Nat.lt_succ_self", "Array.size_swap"],
  "name": "Array.insertionSort.swapLoop.proof_2"},
 {"type": "∀ {m n k : ℕ}, m ∣ k → n ∣ k → Nat.lcm m n ∣ k",
  "offspring":
  ["Nat.eq_zero_or_pos",
   "Nat.dvd_zero",
   "Nat.dvd_of_mul_dvd_mul_left",
   "Nat.gcd_pos_of_pos_left",
   "Nat.pos_of_dvd_of_pos",
   "Nat.gcd_mul_lcm",
   "Nat.gcd_mul_right",
   "Nat.dvd_gcd",
   "Nat.mul_dvd_mul_left",
   "Nat.mul_dvd_mul_right"],
  "name": "Nat.lcm_dvd"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → [inst : Monad m] → {ε' α : Type u} → (ε → ε') → ExceptT ε m α → ExceptT ε' m α",
  "offspring": ["ExceptT.mk", "Functor.map", "Except.mapError"],
  "name": "ExceptT.adapt"},
 {"type":
  "{f : Type u → Type v} → {inst : Applicative f} → Sort u_1 → LawfulApplicative f → LawfulApplicative f → Sort u_1",
  "offspring": [],
  "name": "LawfulApplicative.noConfusionType"},
 {"type": "∀ (a : UInt32), 0 + a = a",
  "offspring":
  ["UInt32.zero_def",
   "UInt32.add_def",
   "UInt32.mk",
   "zero_add",
   "UInt32.mk_val_eq"],
  "name": "UInt32.instSemiringUInt32.proof_2"},
 {"type":
  "∀ {α : Type u_1} {s₁ s₂ : List α} (t : List α), s₁ ++ t = s₂ ++ t ↔ s₁ = s₂",
  "offspring": ["Function.injective.eq_iff", "List.append_left_injective"],
  "name": "List.append_left_inj"},
 {"type": "∀ {α : Sort u₁}, Function.bijective id",
  "offspring": ["Function.injective_id", "Function.surjective_id"],
  "name": "Function.bijective_id"},
 {"type": "{α : Type u} → α → ℕ → List α → List α",
  "offspring": [],
  "name": "List.replicateTR.loop"},
 {"type":
  "{α : Type u_1} → [inst : Repr α] → [inst : ReprAtom α] → Repr (List α)",
  "offspring": ["repr"],
  "name": "instReprList_1"},
 {"type": "LinearOrder ℤ",
  "offspring": ["LinearOrder.mk", "Int.le_total", "inferInstance"],
  "name": "Int.instLinearOrderInt"},
 {"type": "ShiftLeft UInt8",
  "offspring": ["ShiftLeft.mk", "UInt8.shiftLeft"],
  "name": "instShiftLeftUInt8"},
 {"type": "{α : Type u} → Sort u_1 → Option α → Option α → Sort u_1",
  "offspring": [],
  "name": "Option.noConfusionType"},
 {"type":
  "{α : Sort u} → {β : Sort v} → (α → α → Prop) → (β → β → Prop) → (_ : α) ×' β → (_ : α) ×' β → Prop",
  "offspring": ["PSigma.Lex"],
  "name": "PSigma.lexNdep"},
 {"type": "Nat.Linear.ExprCnstr → Nat.Linear.PolyCnstr",
  "offspring":
  ["Nat.Linear.PolyCnstr.mk",
   "Nat.Linear.ExprCnstr.eq",
   "Nat.Linear.Expr.toPoly",
   "Nat.Linear.ExprCnstr.lhs",
   "Nat.Linear.ExprCnstr.rhs"],
  "name": "Nat.Linear.ExprCnstr.toPoly"},
 {"type": "{α : Sort u} → {β : Sort v} → (α → β) → Coe α β",
  "offspring": [],
  "name": "Coe.mk"},
 {"type": "∀ {α : Type u_1} (a : α) (l : List α), a :: l ≠ l",
  "offspring": ["mt", "congr_arg", "Nat.succ_ne_self"],
  "name": "List.cons_ne_self"},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "offspring": ["Option.get!", "instInhabitedNat"],
  "name": "Mathlib.Tactic.Sat.buildReify.reifyVar"},
 {"type": "∀ (a : UInt16), a * 1 = a",
  "offspring":
  ["UInt16.one_def",
   "UInt16.mul_def",
   "UInt16.mk",
   "mul_one",
   "UInt16.mk_val_eq"],
  "name": "UInt16.instSemiringUInt16.proof_14"},
 {"type":
  "∀ {α : Type u} {β : Type v} (val val_1 : α), (Sum.inl val = Sum.inl val_1) = (val = val_1)",
  "offspring": ["Sum.inl"],
  "name": "Sum.inl.injEq"},
 {"type": "∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ (a ∧ c) ∧ b",
  "offspring": ["and_comm", "And.left_comm", "Iff.rfl"],
  "name": "And.right_comm"},
 {"type":
  "{α₁ α₂ β : Type u} → [inst : Inhabited β] → ((α₁ → α₂ → β) → α₁ → α₂ → β) → α₁ → α₂ → β",
  "offspring": ["fixCore2", "Inhabited.default"],
  "name": "fix2"},
 {"type":
  "Sort u → Mathlib.Tactic.Lint.NamedLinter → Mathlib.Tactic.Lint.NamedLinter → Sort u",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.NamedLinter.noConfusionType"},
 {"type": "∀ {a b c d : ℤ}, a ≤ b → c < d → a + c < b + d",
  "offspring":
  ["lt_of_le_of_lt", "Int.add_le_add_right", "Int.add_lt_add_left"],
  "name": "Int.add_lt_add_of_le_of_lt"},
 {"type":
  "{α : Type u} → {β : α → Type v} → Sort u_1 → Sigma β → Sigma β → Sort u_1",
  "offspring": [],
  "name": "Sigma.noConfusionType"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {γ : Sort u_1} (f : α → β) {g : γ → α},\n  Function.surjective g → (Function.surjective (f ∘ g) ↔ Function.surjective f)",
  "offspring": ["Function.surjective.of_comp", "Function.surjective.comp"],
  "name": "Function.surjective.of_comp_iff"},
 {"type": "{ε σ : Type u} → MonadFinally (EStateM ε σ)",
  "offspring":
  ["MonadFinally.mk", "Prod", "EStateM.Result.ok", "EStateM.Result.error"],
  "name": "EStateM.instMonadFinallyEStateM"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {σ α : Type u_1} [inst : Monad m] (x : StateCpsT σ m α) (s : σ),\n  StateCpsT.run' x s = StateCpsT.runK x s fun a s => pure a",
  "offspring": [],
  "name": "StateCpsT.run'_eq"},
 {"type": "∀ {n : ℕ}, n ≤ 0 → n = 0",
  "offspring": ["Nat.le_antisymm", "Nat.zero_le"],
  "name": "Nat.eq_zero_of_le_zero"},
 {"type": "∀ {a b c d : ℤ}, a < b → c < d → a - d < b - c",
  "offspring": ["Int.add_lt_add", "Int.neg_lt_neg"],
  "name": "Int.sub_lt_sub"},
 {"type": "Type u✝ → Type u✝", "offspring": [], "name": "Zero"},
 {"type": "Nat.Linear.Expr → Nat.Linear.Poly",
  "offspring":
  ["cond",
   "instBEqNat",
   "Nat.Linear.fixedVar",
   "PProd.snd",
   "Nat.Linear.Poly.mul"],
  "name": "Nat.Linear.Expr.toPoly"},
 {"type": "{α : Type u} → [self : Add α] → α → α → α",
  "offspring": [],
  "name": "Add.add"},
 {"type":
  "{α : Type u} → [toPreorder : Preorder α] → (∀ (a b : α), a ≤ b → b ≤ a → a = b) → PartialOrder α",
  "offspring": [],
  "name": "PartialOrder.mk"},
 {"type": "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ (x : α), r x x",
  "offspring": [],
  "name": "Equivalence.refl"},
 {"type":
  "(a : FloatArray) → (i : USize) → Float → USize.toNat i < FloatArray.size a → FloatArray",
  "offspring": ["FloatArray.mk", "Array.uset", "Float"],
  "name": "FloatArray.uset"},
 {"type": "Div ℤ",
  "offspring": ["Div.mk", "Int.div"],
  "name": "Int.instDivInt"},
 {"type": "Repr String", "offspring": [], "name": "instReprString"},
 {"type":
  "∀ {α : Type u_1} (a b : α) (k : Unit → Decidable (a = b)),\n  withPtrEq a b (fun x => toBoolUsing (k ())) (_ : a = b → toBoolUsing (k ()) = true) = true → a = b",
  "offspring": ["ofBoolUsing_eq_true"],
  "name": "withPtrEqDecEq.proof_2"},
 {"type": "∀ {a : ℤ}, Int.sign a = 1 → 0 < a",
  "offspring": ["Int.ofNat_lt", "Nat.succ_pos"],
  "name": "Int.pos_of_sign_eq_one"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (f : α → β) (g : β → α) (l : Function.LeftInverse g f) (r : Function.RightInverse g f),\n  { toFun := f, invFun := g, left_inv := l, right_inv := r }.toFun = f",
  "offspring": [],
  "name": "Equiv.coe_fn_mk"},
 {"type":
  "∀ {α : Type u} {data data_1 : List α}, { data := data } = { data := data_1 } → data = data_1",
  "offspring": [],
  "name": "Array.mk.inj"},
 {"type": "{α : Type u_1} → {β : Sort u_2} → (α → β) → (β → Option α) → Prop",
  "offspring": [],
  "name": "Function.is_partial_inv"},
 {"type": "∀ {a b : UInt64}, a = b → a.val = b.val",
  "offspring": [],
  "name": "UInt64.val_eq_of_eq"},
 {"type": "Mod USize",
  "offspring": ["Mod.mk", "USize.mod"],
  "name": "instModUSize"},
 {"type": "ℕ → ℕ → Prop", "offspring": ["Nat.le"], "name": "Nat.lt"},
 {"type": "sizeOf Tactic.NormCast.Label.elim = 1",
  "offspring": [],
  "name": "Tactic.NormCast.Label.elim.sizeOf_spec"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : ℕ), Fin.ofInt' (Int.ofNat x) = Fin.ofInt' (Int.ofNat x)",
  "offspring": [],
  "name": "instAddGroupWithOneFin.proof_6"},
 {"type": "{α : Type u} → Sort u_1 → Inv α → Inv α → Sort u_1",
  "offspring": [],
  "name": "Inv.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α), a :: as = [] → List.noConfusionType False (a :: as) []",
  "offspring": [],
  "name": "List.getLast!.proof_1"},
 {"type": "∀ (a : ℤ), a - a = 0",
  "offspring": ["Int.sub_eq_add_neg", "Int.add_right_neg"],
  "name": "Int.sub_self"},
 {"type": "∀ {α : Sort u_1} (a b : α) (p : Prop), a = b ∧ p ↔ b = a ∧ p",
  "offspring": [],
  "name": "and_symm_left"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {l : List α}, a ∈ l → a ∈ List.insert b l",
  "offspring": ["List.mem_insert_iff"],
  "name": "List.mem_insert_of_mem"},
 {"type": "{α : Type u_1} → List α → List α → List α",
  "offspring": [],
  "name": "List.tailD"},
 {"type": "∀ (a b c : ℕ), a < b → a < b + c",
  "offspring": ["lt_of_lt_of_le", "Nat.le_add_right"],
  "name": "Nat.lt_add_right"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} →\n    (stM : Type u → Type u) →\n      ({α : Type u} → (({β : Type u} → n β → m (stM β)) → m α) → n α) →\n        ({α : Type u} → m (stM α) → n α) → MonadControl m n",
  "offspring": [],
  "name": "MonadControl.mk"},
 {"type": "∀ {m k : ℕ} (n : ℕ), Nat.coprime k m → Nat.coprime k (m ^ n)",
  "offspring": ["Nat.coprime.symm", "Nat.coprime.pow_left"],
  "name": "Nat.coprime.pow_right"},
 {"type": "(A : Type u) → [inst : AddGroup A] → IsAddRightCancel A",
  "offspring":
  ["IsAddRightCancel.mk",
   "instIsAddRightCancelToAddToAddSemigroupToAddMonoidToSubNegMonoid.proof_1"],
  "name": "instIsAddRightCancelToAddToAddSemigroupToAddMonoidToSubNegMonoid"},
 {"type": "Lean.Expr → Lean.MetaM ℕ",
  "offspring": [],
  "name": "Tactic.NormCast.countHeadCoes"},
 {"type": "∀ (n : ℕ), n % n = 0",
  "offspring":
  ["Nat.mod_eq_sub_mod", "Nat.le_refl", "Nat.sub_self", "Nat.zero_mod"],
  "name": "Nat.mod_self"},
 {"type": "{ε σ : Type u} → Monad (EStateM ε σ)",
  "offspring": ["Monad.mk"],
  "name": "EStateM.instMonadEStateM"},
 {"type": "HMod UInt16 ℕ UInt16",
  "offspring": ["HMod.mk", "UInt16.modn"],
  "name": "instHModUInt16Nat"},
 {"type": "∀ (x x_1 : USize), { val := (x - x_1).1 } = { val := (x + -x_1).1 }",
  "offspring": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "USize.instRingUSize.proof_1"},
 {"type": "{α : Type u} → Sort u_1 → Mul α → Mul α → Sort u_1",
  "offspring": [],
  "name": "Mul.noConfusionType"},
 {"type":
  "∀ {α β σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf β] [inst_2 : SizeOf σ] (a : β) (a_1 : σ),\n  sizeOf (DoResultPRBC.return a a_1) = 1 + sizeOf a + sizeOf a_1",
  "offspring": [],
  "name": "DoResultPRBC.return.sizeOf_spec"},
 {"type": "∀ (a : USize), 1 * a = a",
  "offspring":
  ["USize.one_def", "USize.mul_def", "USize.mk", "one_mul", "USize.mk_val_eq"],
  "name": "USize.instSemiringUSize.proof_13"},
 {"type": "∀ {a b c : Prop}, a ∧ b → c ↔ a → b → c",
  "offspring": [],
  "name": "and_imp"},
 {"type":
  "{m : Type u → Type v} → [self : Bind m] → {α β : Type u} → m α → (α → m β) → m β",
  "offspring": [],
  "name": "Bind.bind"},
 {"type": "Substring → Option ℕ",
  "offspring": ["Substring.isNat", "Substring.foldl"],
  "name": "Substring.toNat?"},
 {"type": "∀ {a b c : ℕ}, a ≤ b → b < c → a < c",
  "offspring": ["Nat.lt_of_le_of_lt"],
  "name": "Nat.instTransNatLeInstLENatLtInstLTNat.proof_1"},
 {"type": "{α : Type u} → [self : Append α] → α → α → α",
  "offspring": [],
  "name": "Append.append"},
 {"type": "Repr Unit", "offspring": [], "name": "instReprUnit"},
 {"type": "∀ (m n : ℕ), Int.negOfNat m * Int.ofNat n = Int.negOfNat (m * n)",
  "offspring": ["Int.mul_comm", "Int.ofNat_mul_negOfNat"],
  "name": "Int.negOfNat_mul_ofNat"},
 {"type": "∀ (x x_1 : USize), x * x_1 = x_1 * x",
  "offspring":
  ["USize.eq_of_val_eq", "USize.mul_def", "CommSemigroup.mul_comm"],
  "name": "USize.instCommRingUSize.proof_1"},
 {"type": "{A : Type u} → [self : SubNegMonoid A] → ℤ → A → A",
  "offspring": [],
  "name": "SubNegMonoid.gsmul"},
 {"type": "Repr Tactic.NormCast.CoeFnType",
  "offspring": ["GE.ge"],
  "name": "Tactic.NormCast.instReprCoeFnType"},
 {"type": "Repr Float",
  "offspring": ["Float.toString"],
  "name": "instReprFloat"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (x : m α) (y : m β),\n  (SeqRight.seqRight x fun x => y) = do\n    let _ ← x\n    y",
  "offspring":
  ["LawfulApplicative.seqRight_eq",
   "Seq.seq",
   "map_eq_pure_bind",
   "seq_eq_bind_map",
   "LawfulMonad.bind_assoc",
   "LawfulMonad.pure_bind",
   "id_eq",
   "bind_pure"],
  "name": "seqRight_eq_bind"},
 {"type": "ℕ → List Char",
  "offspring": ["Nat.toSuperDigitsAux"],
  "name": "Nat.toSuperDigits"},
 {"type": "∀ {m n : ℕ}, m ≠ 0 → n ≠ 0 → Nat.lcm m n ≠ 0",
  "offspring": [],
  "name": "Nat.lcm_ne_zero"},
 {"type": "∀ (a b c : UInt32), (a + b) * c = a * c + b * c",
  "offspring":
  ["UInt32.add_def",
   "UInt32.mul_def",
   "UInt32.mk",
   "UInt32.eq_of_val_eq",
   "Distrib.right_distrib"],
  "name": "UInt32.instSemiringUInt32.proof_8"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β}, Function.injective f → ∀ (x : α), Function.partial_inv f (f x) = some x",
  "offspring":
  ["Function.is_partial_inv_left", "Function.partial_inv_of_injective"],
  "name": "Function.partial_inv_left"},
 {"type":
  "{α : Type u_1} →\n  (self : UnionFind α) →\n    (x : Fin (UnionFind.size self)) →\n      (s : Array (UFNode α)) ×'\n        (root : Fin (Array.size s)) ×'\n          ∃ n m m',\n            UFModel.Models self.arr m ∧\n              UFModel.Models s m' ∧\n                m'.rank = m.rank ∧\n                  (∃ hr, ↑(UFModel.parent m' { val := ↑root, isLt := hr }) = ↑root) ∧\n                    UFModel.rank m ↑x ≤ UFModel.rank m ↑root",
  "offspring":
  ["WellFounded.fix",
   "UnionFind.findAux.proof_1",
   "UnionFind.findAux.proof_2",
   "Array.get"],
  "name": "UnionFind.findAux"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«stx_+»"},
 {"type": "{α : Type u} → (α → α → α) → Add α",
  "offspring": [],
  "name": "Add.mk"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (k : ℕ) (c : Nat.Linear.PolyCnstr),\n  Nat.Linear.PolyCnstr.denote ctx (Nat.Linear.PolyCnstr.mul (k + 1) c) = Nat.Linear.PolyCnstr.denote ctx c",
  "offspring": ["Nat.Linear.PolyCnstr"],
  "name": "Nat.Linear.PolyCnstr.denote_mul"},
 {"type": "DecidableEq Mathlib.Tactic.Lint.LintVerbosity",
  "offspring":
  ["Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx",
   "Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_1",
   "Mathlib.Tactic.Lint.instDecidableEqLintVerbosity.proof_2"],
  "name": "Mathlib.Tactic.Lint.instDecidableEqLintVerbosity"},
 {"type":
  "∀ (a b a_1 b_1 : Nat.Linear.Expr), (Nat.Linear.Expr.add a b = Nat.Linear.Expr.add a_1 b_1) = (a = a_1 ∧ b = b_1)",
  "offspring": ["Nat.Linear.Expr"],
  "name": "Nat.Linear.Expr.add.injEq"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "term!_"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "byContra"},
 {"type": "∀ {n m k : ℕ}, 0 < n → m = k * n → m / n = k",
  "offspring": ["Nat.mul_div_cancel"],
  "name": "Nat.div_eq_of_eq_mul_left"},
 {"type": "{δ σ : Type u} → [self : EStateM.Backtrackable δ σ] → σ → δ",
  "offspring": [],
  "name": "EStateM.Backtrackable.save"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {as bs : List α}, List.inj_on f bs → as ⊆ bs → List.inj_on f as",
  "offspring": [],
  "name": "List.inj_on_of_subset"},
 {"type": "Xor USize",
  "offspring": ["Xor.mk", "USize.xor"],
  "name": "instXorUSize"},
 {"type":
  "∀ {v : Sat.Valuation} {f₁ : Sat.Fmla} {a : Prop} {f₂ : Sat.Fmla} {b : Prop},\n  Sat.Fmla.reify v f₁ a → Sat.Fmla.reify v f₂ b → Sat.Fmla.reify v (Sat.Fmla.and f₁ f₂) (a ∨ b)",
  "offspring":
  ["Sat.Fmla.reify.mk",
   "by_contra",
   "Sat.Valuation.satisfies_fmla.mk",
   "List.mem_append",
   "Sat.Fmla.reify.prop",
   "Sat.Valuation.satisfies_fmla.prop"],
  "name": "Sat.Fmla.reify_or"},
 {"type":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), Ring.intCast -[1+ n] = -NonUnitalNonAssocSemiring.natCast (n + 1)",
  "offspring": [],
  "name": "Ring.intCast_negSucc"},
 {"type": "ℕ → ℤ", "offspring": [], "name": "Int.negSucc"},
 {"type": "∀ {n : ℕ}, Int.ofNat n = ↑n",
  "offspring": [],
  "name": "Int.ofNat_eq_cast"},
 {"type": "{G : Type u} → [self : DivInvMonoid G] → Monoid G",
  "offspring": [],
  "name": "DivInvMonoid.toMonoid"},
 {"type":
  "Lean.SimpleScopedEnvExtension (Lean.Name × Array Lean.Meta.DiscrTree.Key) (Lean.Meta.DiscrTree Lean.Name)",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.extExtension"},
 {"type": "(m n : ℕ) → Decidable (Nat.coprime m n)",
  "offspring": [],
  "name": "Nat.instDecidableCoprime"},
 {"type": "∀ {a : ℕ}, a < UInt8.size → ↑(UInt8.ofNat a).val = a",
  "offspring": ["Fin.val_eq_of_lt"],
  "name": "UInt8.val_eq_of_lt"},
 {"type": "∀ (f : Sat.Fmla), Sat.Fmla.subsumes f f",
  "offspring": ["Sat.Fmla.subsumes.mk"],
  "name": "Sat.Fmla.subsumes_self"},
 {"type": "∀ (x z : ℕ) {y : ℕ}, 0 < y → (x + y * z) / y = x / y + z",
  "offspring":
  ["Nat.mul_zero",
   "Nat.add_zero",
   "Nat.mul_succ",
   "Nat.add_assoc",
   "Nat.add_div_right"],
  "name": "Nat.add_mul_div_left"},
 {"type":
  "∀ {α : Type u} {motive : Squash α → Prop}, (∀ (a : α), motive (Squash.mk a)) → ∀ (q : Squash α), motive q",
  "offspring": ["Quot.ind"],
  "name": "Squash.ind"},
 {"type": "∀ {R : Type u_1} {n : ℕ} [inst : AddGroupWithOne R], ↑↑n = ↑n",
  "offspring": ["Int.cast_ofNat"],
  "name": "Int.cast_Nat_cast"},
 {"type": "∀ {a c b d : ℕ}, a ≤ c → b < d → 0 < c → a * b < c * d",
  "offspring":
  ["Nat.lt_of_le_of_lt",
   "Nat.mul_le_mul_of_nonneg_right",
   "Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.mul_lt_mul'"},
 {"type": "∀ {α : Type u_1} (as : Array α), Array.size as ≤ Array.size as",
  "offspring": ["Nat.le_refl"],
  "name": "Array.toSubarray.proof_1"},
 {"type": "∀ {n m : ℕ}, n ≠ 0 → n < m → Nat.pred n < Nat.pred m",
  "offspring": ["Nat.lt_of_succ_lt_succ"],
  "name": "Nat.pred_lt_pred"},
 {"type": "{α : Type u} → Sort u_1 → Union α → Union α → Sort u_1",
  "offspring": [],
  "name": "Union.noConfusionType"},
 {"type":
  "{M₀ : Type u} → Sort u_1 → MulZeroClass M₀ → MulZeroClass M₀ → Sort u_1",
  "offspring": [],
  "name": "MulZeroClass.noConfusionType"},
 {"type": "Type u → Type u", "offspring": [], "name": "PartialOrder"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "prioLow"},
 {"type": "AddSemigroup USize",
  "offspring":
  ["AddSemigroup.mk", "instAddUSize", "USize.instAddSemigroupUSize.proof_1"],
  "name": "USize.instAddSemigroupUSize"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  (∀ (a' : α), a' ∈ l → R a a') → List.Pairwise R l → List.Pairwise R (a :: l)",
  "offspring": [],
  "name": "List.Pairwise.cons"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), 0 * a = 0",
  "offspring": ["MonoidWithZero.zero_mul"],
  "name": "instCommSemiringFin.proof_3"},
 {"type": "∀ {α : Type u_1}, [] = []",
  "offspring": [],
  "name": "List.hasDecEq.proof_1"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Conv.traceLHS"},
 {"type": "ℕ → UInt16", "offspring": ["UInt16.ofNat"], "name": "Nat.toUInt16"},
 {"type":
  "{M₀ : Type u} →\n  [toMonoid : Monoid M₀] → [toZero : Zero M₀] → (∀ (a : M₀), 0 * a = 0) → (∀ (a : M₀), a * 0 = 0) → MonoidWithZero M₀",
  "offspring": [],
  "name": "MonoidWithZero.mk"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq α] [inst_1 : DecidableEq β] (f : α → β) (as : List α),\n  List.card (List.map f as) ≤ List.card as",
  "offspring":
  ["List.card_nil",
   "le_refl",
   "List.card_cons_of_mem",
   "Nat.le_trans",
   "List.card_le_card_cons"],
  "name": "List.card_map_le"},
 {"type": "{α : Type u} → [inst : DecidableEq α] → List α → List α → List α",
  "offspring": ["List.foldr", "List.insert"],
  "name": "List.union"},
 {"type": "(a b : UInt32) → Decidable (a ≤ b)",
  "offspring": [],
  "name": "UInt32.decLe"},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal},\n  (Sat.Valuation.neg v (Sat.Literal.negate l) → False) → (Sat.Valuation.neg v l → False) → False",
  "offspring": [],
  "name": "Sat.Valuation.by_cases"},
 {"type":
  "{α : Type u_1} → {p : α → Prop} → [inst : DecidablePred p] → (o : Option α) → Decidable (∀ (a : α), a ∈ o → p a)",
  "offspring":
  ["Option.decidable_forall_mem.proof_1",
   "Option.decidable_forall_mem.proof_2",
   "Option.decidable_forall_mem.proof_3"],
  "name": "Option.decidable_forall_mem"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (l : List α), List.union [] l = l",
  "offspring": [],
  "name": "List.nil_union"},
 {"type":
  "∀ {α : Type u} (as : List α), List.length (List.reverse as) = List.length as",
  "offspring":
  ["List.reverse_cons",
   "List.length_append",
   "List.reverse",
   "List.length_cons",
   "List.length_nil"],
  "name": "List.length_reverse"},
 {"type": "{α : Type u} → Sort u_1 → ShiftRight α → ShiftRight α → Sort u_1",
  "offspring": [],
  "name": "ShiftRight.noConfusionType"},
 {"type": "Inhabited (Fin UInt32.size)",
  "offspring": ["Fin.ofNat'", "UInt32.size_positive"],
  "name": "UInt32.instInhabitedFinSize"},
 {"type": "{α : Type u_1} → Sort u → UFNode α → UFNode α → Sort u",
  "offspring": [],
  "name": "UFNode.noConfusionType"},
 {"type": "∀ (n : ℕ), Nat.coprime 1 n",
  "offspring": ["Nat.gcd_one_left"],
  "name": "Nat.coprime_one_left"},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.buildReify.reifyClause"},
 {"type": "∀ (a a_1 : UInt8), a + a_1 = a_1 + a",
  "offspring": ["UInt8.add_def", "add_comm", "UInt8.mk"],
  "name": "UInt8.instSemiringUInt8.proof_6"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} (f : α → β),\n  (∀ (a : α), p a → q (f a)) → (∃ a, p a) → ∃ b, q b",
  "offspring": ["Exists.elim"],
  "name": "exists_imp_exists'"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u_1} → {β : Type u} → (α → m β) → List α → m (List β)",
  "offspring": [],
  "name": "List.mmap"},
 {"type": "∀ {a b : ℤ}, -b ≤ -a → a ≤ b",
  "offspring": [],
  "name": "Int.le_of_neg_le_neg"},
 {"type":
  "∀ (A : Type u_1) [inst : AddGroup A] (a b c : A), a + b = a + c → b = c",
  "offspring": ["neg_add_cancel_left"],
  "name":
  "instIsAddLeftCancelToAddToAddSemigroupToAddMonoidToSubNegMonoid.proof_1"},
 {"type": "∀ (p : Prop), (p ∨ False) = p", "offspring": [], "name": "or_false"},
 {"type":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.gsmul (Int.ofNat (Nat.succ n)) a = a + Ring.gsmul (Int.ofNat n) a",
  "offspring": [],
  "name": "Ring.gsmul_succ'"},
 {"type": "∀ {α : Type u_1} {o : Option α}, Option.isNone o = true ↔ o = none",
  "offspring": ["Option.eq_none_of_isNone"],
  "name": "Option.isNone_iff_eq_none"},
 {"type": "{α : Type u} → Sort u_1 → Preorder α → Preorder α → Sort u_1",
  "offspring": [],
  "name": "Preorder.noConfusionType"},
 {"type":
  "∀ (x : ℕ) (x_1 : USize), npow_rec (Nat.succ x) x_1 = npow_rec (Nat.succ x) x_1",
  "offspring": [],
  "name": "USize.instSemiringUSize.proof_16"},
 {"type": "{α : Sort u} → (a : α) → {β : Sort v} → [self : CoeDep α a β] → β",
  "offspring": [],
  "name": "CoeDep.coe"},
 {"type": "{α : Type u} → List α → List α → (α → α → Bool) → Bool",
  "offspring": [],
  "name": "List.isEqv"},
 {"type":
  "∀ {α : Sort u} {a b c : α} (r : α → α → Prop), r a b → b = c → r a c",
  "offspring": [],
  "name": "trans_rel_left"},
 {"type": "{α : Type u} → [self : Preorder α] → LT α",
  "offspring": [],
  "name": "Preorder.toLT"},
 {"type": "{α : Type u_1} → UnionFind α → ℕ",
  "offspring": ["UnionFind.arr"],
  "name": "UnionFind.size"},
 {"type": "∀ (n : ℕ), Nat.coprime n 1",
  "offspring": ["Nat.gcd_one_right"],
  "name": "Nat.coprime_one_right"},
 {"type": "Sub UInt64",
  "offspring": ["Sub.mk", "UInt64.sub"],
  "name": "instSubUInt64"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop}, (ExistsUnique fun x => p x) → ∃ x, p x",
  "offspring": [],
  "name": "ExistsUnique.exists"},
 {"type": "ℕ → NonScalar", "offspring": [], "name": "NonScalar.mk"},
 {"type":
  "∀ {ctx : Nat.Linear.Context} {m₁ m₂ : Nat.Linear.Poly},\n  Nat.Linear.Poly.denote_eq ctx (Nat.Linear.Poly.cancel m₁ m₂) → Nat.Linear.Poly.denote_eq ctx (m₁, m₂)",
  "offspring": [],
  "name": "Nat.Linear.Poly.of_denote_eq_cancel"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop} {a : List α}\n  (x : List.Pairwise R a), (∀ (a : List α) (x : List.Pairwise R a), List.Pairwise.below x → motive a x) → motive a x",
  "offspring": ["List.Pairwise.below.nil", "List.Pairwise.below.cons"],
  "name": "List.Pairwise.brecOn"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) {a : α} {l : List α}, a ∈ l → f a ∈ List.map f l",
  "offspring": ["List.Mem.head", "List.Mem.tail"],
  "name": "List.mem_map_of_mem"},
 {"type": "ToString UInt16",
  "offspring": ["ToString.mk", "instToStringNat", "UInt16.toNat"],
  "name": "instToStringUInt16"},
 {"type":
  "∀ (x x_1 x_2 : USize), { val := (x * x_1 * x_2).1 } = { val := (x * (x_1 * x_2)).1 }",
  "offspring": ["USize.mk", "Semigroup.mul_assoc"],
  "name": "USize.instSemigroupUSize.proof_1"},
 {"type": "∀ {α : Type u_1} {L₁ L₂ : List α}, List.append L₁ L₂ = L₁ ++ L₂",
  "offspring": [],
  "name": "List.append_eq_has_append"},
 {"type": "ℕ → String",
  "offspring": ["List.asString", "Nat.toDigits"],
  "name": "Nat.repr"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a₁ x : α) (n₁ : ℕ) (b₁ a₂ : α) (n₂ : ℕ) (b₂ aa haa ab bb t : α),\n  Tactic.Ring.horner a₁ x n₁ b₁ * a₂ = aa →\n    Tactic.Ring.horner aa x n₂ 0 = haa →\n      a₁ * b₂ = ab →\n        b₁ * b₂ = bb →\n          haa + Tactic.Ring.horner ab x n₁ bb = t → Tactic.Ring.horner a₁ x n₁ b₁ * Tactic.Ring.horner a₂ x n₂ b₂ = t",
  "offspring":
  ["mul_add",
   "add_mul",
   "Semigroup.mul_assoc",
   "add_zero",
   "CommSemigroup.mul_comm"],
  "name": "Tactic.Ring.horner_mul_horner"},
 {"type":
  "∀ {α : Type u_1} [inst : BEq α] [inst_1 : LawfulBEq α] {a b : α}, a ≠ b → (a == b) = false",
  "offspring": [],
  "name": "beq_false_of_ne"},
 {"type": "Type",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo"},
 {"type": "Subsingleton (Fin 0)",
  "offspring": ["Subsingleton.intro", "sorryAx"],
  "name": "instSubsingletonFinOfNatNatInstOfNatNat.proof_1"},
 {"type": "∀ {a b : ℤ}, a < b ↔ a ≤ b ∧ a ≠ b",
  "offspring": ["Int.le_of_lt", "Int.ne_of_lt", "Int.le.dest"],
  "name": "Int.lt_iff_le_and_ne"},
 {"type": "∀ (a b : UInt16), a - b = { val := a.val - b.val }",
  "offspring": [],
  "name": "UInt16.sub_def"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : α → α → Prop} {s : β → β → Prop},\n  WellFounded r → WellFounded s → WellFounded (PSigma.lexNdep r s)",
  "offspring":
  ["WellFounded.intro", "Acc", "PSigma.lexAccessible", "WellFounded.apply"],
  "name": "PSigma.lexNdepWf.proof_1"},
 {"type": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "offspring": [],
  "name": "AddGroup.toSubNegMonoid"},
 {"type": "{α : Type u_1} → Array α → (α → Bool) → Array α × Array α",
  "offspring": ["Array.foldl", "Array.push"],
  "name": "Array.split"},
 {"type": "ByteSlice → ByteArray", "offspring": [], "name": "ByteSlice.arr"},
 {"type": "UInt8 → UInt32",
  "offspring": ["Nat.toUInt32", "UInt8.toNat"],
  "name": "UInt8.toUInt32"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], (¬a → b) → ¬b → a",
  "offspring": ["Decidable.by_contradiction"],
  "name": "Decidable.not_imp_symm"},
 {"type": "∀ (m n k : ℕ), Nat.gcd (m * n) (m * k) = m * Nat.gcd n k",
  "offspring":
  ["Nat.gcd.induction",
   "Nat.mul_zero",
   "Nat.gcd_zero_left",
   "Nat.gcd_rec",
   "Nat.mul_mod_mul_left"],
  "name": "Nat.gcd_mul_left"},
 {"type": "{n : ℕ} → Xor (Fin n)",
  "offspring": ["Xor.mk", "Fin.xor"],
  "name": "Fin.instXorFin"},
 {"type": "{α : Type u_1} → (α → α → Prop) → List α → Prop",
  "offspring": [],
  "name": "List.Pairwise"},
 {"type": "Array ℕ → Mathlib.Tactic.Sat.LRATStep",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LRATStep.del"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term∃_,_»"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (a b c d : Nat.Linear.Expr),\n  Nat.Linear.Poly.cancel (Nat.Linear.Expr.toNormPoly a) (Nat.Linear.Expr.toNormPoly b) =\n      (Nat.Linear.Expr.toPoly c, Nat.Linear.Expr.toPoly d) →\n    (Nat.Linear.Expr.denote ctx a = Nat.Linear.Expr.denote ctx b) =\n      (Nat.Linear.Expr.denote ctx c = Nat.Linear.Expr.denote ctx d)",
  "offspring": [],
  "name": "Nat.Linear.Expr.of_cancel_eq"},
 {"type":
  "∀ {α : Type u_1} (i : ℕ) (l : List α), List.length (List.drop i l) = List.length l - i",
  "offspring":
  ["List.drop", "Nat.zero_sub", "Trans.trans", "Nat.succ_sub_succ_eq_sub"],
  "name": "List.length_drop"},
 {"type": "{α : Type} → Lean.MetaM α → IO (Tactic.Cache α)",
  "offspring": ["Sum.inl"],
  "name": "Tactic.Cache.mk"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {g : β → Option α},\n  Function.is_partial_inv f g → ∀ (x : α), g (f x) = some x",
  "offspring": [],
  "name": "Function.is_partial_inv_left"},
 {"type": "ℕ → ℕ → ℕ",
  "offspring": ["HDiv.hDiv", "Nat.gcd"],
  "name": "Nat.lcm"},
 {"type":
  "{c : Prop} →\n  {t : c → Prop} →\n    {e : ¬c → Prop} →\n      [dC : Decidable c] →\n        [dT : (h : c) → Decidable (t h)] → [dE : (h : ¬c) → Decidable (e h)] → Decidable (if h : c then t h else e h)",
  "offspring": [],
  "name": "instDecidableDitePropNot"},
 {"type": "{α : Type u} → (α → α → α) → Prop",
  "offspring": [],
  "name": "commutative"},
 {"type": "∀ (data : Array Float), sizeOf { data := data } = 1 + sizeOf data",
  "offspring": [],
  "name": "FloatArray.mk.sizeOf_spec"},
 {"type": "∀ {α : Sort u} (h : α = α) (a : α), cast h a = a",
  "offspring": [],
  "name": "cast_eq"},
 {"type": "Stream Substring Char",
  "offspring":
  ["Stream.mk",
   "Substring.startPos",
   "Substring.stopPos",
   "Substring.str",
   "Substring.mk"],
  "name": "instStreamSubstringChar"},
 {"type": "Nat.Linear.Context → Nat.Linear.Poly × Nat.Linear.Poly → Prop",
  "offspring": ["Nat.Linear.Poly.denote", "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote_eq"},
 {"type": "{α : Type u_1} → ℕ → α → List α → List α",
  "offspring": ["List.modifyNthTail"],
  "name": "List.insertNth"},
 {"type": "{α : Type u✝} → Sort u → Zero α → Zero α → Sort u",
  "offspring": [],
  "name": "Zero.noConfusionType"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "guardTargetStrict"},
 {"type": "∀ {a b c : ℕ}, b ≤ a → (a - b = c ↔ a = c + b)",
  "offspring": ["Nat.sub_add_cancel", "Nat.add_sub_cancel"],
  "name": "Nat.sub_eq_iff_eq_add"},
 {"type": "∀ {n n_1 : ℕ}, Nat.succ n = Nat.succ n_1 → n = n_1",
  "offspring": [],
  "name": "Nat.succ.inj"},
 {"type":
  "{α : Sort u} → {s : Setoid α} → [d : (a b : α) → Decidable (a ≈ b)] → DecidableEq (Quotient s)",
  "offspring":
  ["Quotient.recOnSubsingleton₂",
   "Quotient.mk",
   "Quotient.sound",
   "instDecidableEqQuotient.proof_2"],
  "name": "instDecidableEqQuotient"},
 {"type": "{α : Sort u} → {β : Sort v} → (α → β) → CoeHTCT α β",
  "offspring": [],
  "name": "CoeHTCT.mk"},
 {"type": "∀ {α : Type u_1} {β : Type u_2}, ULift α = ULift β",
  "offspring": ["lcProof"],
  "name": "unsafeCast.proof_1"},
 {"type":
  "∀ (a b : Nat.Linear.Expr), sizeOf (Nat.Linear.Expr.add a b) = 1 + sizeOf a + sizeOf b",
  "offspring": ["Nat.Linear.Expr"],
  "name": "Nat.Linear.Expr.add.sizeOf_spec"},
 {"type":
  "∀ {p₁ p₂ q₁ q₂ : Prop}, p₁ = p₂ → (p₂ → q₁ = q₂) → (p₁ → q₁) = (p₂ → q₂)",
  "offspring": [],
  "name": "implies_congr_ctx"},
 {"type": "Hashable UInt16",
  "offspring": ["Hashable.mk", "UInt16.toUInt64"],
  "name": "instHashableUInt16"},
 {"type": "∀ {α : Type u}, List.reverse [] = []",
  "offspring": [],
  "name": "List.reverse_nil"},
 {"type": "∀ {α : Type u_1} (a b : List α), a ≠ [] → a ++ b ≠ []",
  "offspring": ["ne_eq", "List.append_eq_nil", "false_and"],
  "name": "List.append_ne_nil_of_left_ne_nil"},
 {"type": "∀ {a : Prop}, a → ¬a ↔ ¬a", "offspring": [], "name": "imp_not_self"},
 {"type": "Ordering", "offspring": [], "name": "Ordering.lt"},
 {"type":
  "(α : Type u) → {β : Type v} → WellFoundedRelation β → WellFoundedRelation ((_ : α) ×' β)",
  "offspring":
  ["WellFoundedRelation.mk",
   "PSigma.SkipLeft",
   "WellFoundedRelation.rel",
   "PSigma.skipLeft.proof_1"],
  "name": "PSigma.skipLeft"},
 {"type": "Type s → Type (max s r)", "offspring": [], "name": "ulift"},
 {"type": "Float → floatSpec.float", "offspring": [], "name": "Float.val"},
 {"type": "∀ {a : Prop}, ¬(¬a ↔ a)",
  "offspring": ["iff_not_self", "Iff.symm"],
  "name": "not_iff_self"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {s : Type u} → {α : Type w} → (α → s → m s) → s → List α → m s",
  "offspring": [],
  "name": "List.foldrM"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (as : Array α) → (α → m (Option β)) → (x : ℕ) → x ≤ Array.size as → m (Option β)",
  "offspring": [],
  "name": "Array.findSomeRevM?.find"},
 {"type": "∀ {n m k : ℕ}, n < m → k > 0 → n * k < m * k",
  "offspring": ["Nat.mul_lt_mul_of_pos_left"],
  "name": "Nat.mul_lt_mul_of_pos_right"},
 {"type": "Tactic.Ring.Cache → Lean.Expr",
  "offspring": [],
  "name": "Tactic.Ring.Cache.cs"},
 {"type": "∀ (b : Bool), (!b == true) = (b == false)",
  "offspring": [],
  "name": "Bool.not_beq_true"},
 {"type":
  "{α : Type u_1} → [inst : LT α] → [inst : DecidableRel LT.lt] → α → α → α",
  "offspring": [],
  "name": "max"},
 {"type": "∀ {α : Type u_1}, [] <+ []",
  "offspring": [],
  "name": "List.sublist.slnil"},
 {"type": "UInt16 → Fin UInt16.size", "offspring": [], "name": "UInt16.val"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} (a : α) (h₁ : p a) (b : α) (h₂ : p b),\n  a = b → { val := a, property := h₁ } = { val := b, property := h₂ }",
  "offspring": [],
  "name": "Subtype.instDecidableEqSubtype.proof_1"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a b : Fin n), a - b = a + -b",
  "offspring": ["AddGroupWithOne.sub_eq_add_neg"],
  "name": "instCommRingFin.proof_1"},
 {"type": "OrOp UInt16",
  "offspring": ["OrOp.mk", "UInt16.lor"],
  "name": "instOrOpUInt16"},
 {"type": "List Prop → Sat.Valuation",
  "offspring": [],
  "name": "Sat.Valuation.mk"},
 {"type":
  "∀ (f f₁ f₂ : Sat.Fmla), Sat.Fmla.subsumes f (Sat.Fmla.and f₁ f₂) → Sat.Fmla.subsumes f f₂",
  "offspring":
  ["Sat.Fmla.subsumes.mk",
   "Sat.Fmla.subsumes.prop",
   "List.mem_append",
   "Sat.Clause"],
  "name": "Sat.Fmla.subsumes_right"},
 {"type": "∀ {a b : Prop}, a ∨ b ↔ ¬b → a",
  "offspring": ["Decidable.or_iff_not_imp_right"],
  "name": "or_iff_not_imp_right"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (get : α), sizeOf { get := get } = 1 + sizeOf get",
  "offspring": [],
  "name": "Task.pure.sizeOf_spec"},
 {"type": "Lean.Parsec (ℕ × Array (Array ℤ))",
  "offspring":
  ["SeqRight.seqRight",
   "SeqLeft.seqLeft",
   "Unit",
   "Mathlib.Tactic.Sat.Parser.parseNat",
   "ForIn.forIn",
   "Mathlib.Tactic.Sat.Parser.parseInts",
   "Array.push",
   "Array.mkEmpty"],
  "name": "Mathlib.Tactic.Sat.Parser.parseDimacs"},
 {"type":
  "(α : Sort u) → {β : Sort v} → [inst : Inhabited β] → Inhabited (α → β)",
  "offspring": ["Inhabited.default"],
  "name": "instInhabitedForAll"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α}, a ≠ b ↔ (a == b) = false",
  "offspring": ["decide_eq_false", "of_decide_eq_false"],
  "name": "NeqIffBeqFalse"},
 {"type": "{α : Type u} → α → ForInStep α",
  "offspring": [],
  "name": "ForInStep.yield"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {γ : Type u_4} {δ : Type u_5} {ε : Type u_3} (f : γ → δ → ε) (g : α → γ) (h : β → δ),\n  Function.uncurry (Function.bicompl f g h) = Function.uncurry f ∘ Prod.map g h",
  "offspring": [],
  "name": "Function.uncurry_bicompl"},
 {"type": "Div ℕ",
  "offspring": ["Div.mk", "Nat.div"],
  "name": "Nat.instDivNat"},
 {"type": "Type", "offspring": [], "name": "Tactic.Ring.Cache"},
 {"type": "ℤ → ℤ → ℤ", "offspring": ["HDiv.hDiv"], "name": "Int.quot"},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "offspring": [],
  "name": "MonadLiftT"},
 {"type":
  "∀ {α : Type u} [inst : LT α] {a : α} {as : List α} {b : α} {bs : List α},\n  ¬a < b → ¬b < a → List.lt as bs → List.lt (a :: as) (b :: bs)",
  "offspring": [],
  "name": "List.lt.tail"},
 {"type": "{ε σ α β : Type u} → (α → β) → EStateM ε σ α → EStateM ε σ β",
  "offspring": ["EStateM.Result.ok", "EStateM.Result.error"],
  "name": "EStateM.map"},
 {"type": "{α : Type u} → [inst : DecidableEq α] → α → List α → List α",
  "offspring": [],
  "name": "List.insert"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} {f : β → γ} {b : β}, f ∘ Function.const α b = Function.const α (f b)",
  "offspring": [],
  "name": "Function.comp_const"},
 {"type": "∀ (a : UInt32), 1 * a = a",
  "offspring":
  ["UInt32.one_def",
   "UInt32.mul_def",
   "UInt32.mk",
   "one_mul",
   "UInt32.mk_val_eq"],
  "name": "UInt32.instSemiringUInt32.proof_13"},
 {"type": "∀ (a b : ℤ), a + -b + b = a",
  "offspring": ["Int.add_assoc", "Int.add_left_neg", "Int.add_zero"],
  "name": "Int.neg_add_cancel_right"},
 {"type":
  "{m : Type u → Type v} →\n  {γ : Type w₁} → {α : outParam (Type w₂)} → ([inst : Monad m] → γ → (α → m PUnit) → m PUnit) → ForM m γ α",
  "offspring": [],
  "name": "ForM.mk"},
 {"type": "∀ (m n : ℕ), m / n ≤ m",
  "offspring": ["Nat.div_zero", "Nat.zero_le", "Nat.div_le_of_le_mul"],
  "name": "Nat.div_le_self"},
 {"type": "∀ {a b : Prop}, b → (a ∧ b ↔ a)",
  "offspring": [],
  "name": "and_iff_left"},
 {"type": "∀ (α : Sort u), (α → Sort v) → Equivalence Function.Equiv",
  "offspring":
  ["Equivalence.mk",
   "Function.Equiv.refl",
   "Function.Equiv.symm",
   "Function.Equiv.trans"],
  "name": "Function.Equiv.isEquivalence"},
 {"type": "{α : Sort u_1} → {β : Sort u_2} → [inst : Nonempty β] → (α → β) → β",
  "offspring": ["Nonempty", "Classical.choice"],
  "name": "Function.sometimes"},
 {"type": "Type u → Type u → Type u", "offspring": [], "name": "DoResultSBC"},
 {"type":
  "{α : Type u} → Sort u_1 → PartialOrder α → PartialOrder α → Sort u_1",
  "offspring": [],
  "name": "PartialOrder.noConfusionType"},
 {"type":
  "∀ {n : ℕ} {a : Fin n}, -a = { val := (n - ↑a) % n, isLt := (_ : (n - ↑a) % n < n) }",
  "offspring": [],
  "name": "Fin.neg_def"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {a₁ a₂ : α} {b₁ b₂ : β}, (a₁, b₁) = (a₂, b₂) ↔ a₁ = a₂ ∧ b₁ = b₂",
  "offspring": ["Prod.mk.inj"],
  "name": "Prod.mk.inj_iff"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → AddMonoidWithOne (Fin n)",
  "offspring":
  ["AddMonoidWithOne.mk",
   "Fin.ofNat'",
   "Fin.size_positive'",
   "instAddMonoidWithOneFin.proof_1",
   "instAddMonoidWithOneFin.proof_2",
   "AddCommMonoid"],
  "name": "instAddMonoidWithOneFin"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "Coe"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : (a : α) → Acc r a → Prop} (x : α) {h : ∀ (y : α), r y x → Acc r y},\n  (∀ (y : α), r y x → Acc.below (_ : Acc r y)) → (∀ (y : α), r y x → motive y (_ : Acc r y)) → Acc.below (_ : Acc r x)",
  "offspring": [],
  "name": "Acc.below.intro"},
 {"type": "sizeOf Tactic.NormCast.CoeFnType.coeSort = 1",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.coeSort.sizeOf_spec"},
 {"type": "∀ {p : Prop}, Nonempty p ↔ p",
  "offspring": [],
  "name": "nonempty_Prop"},
 {"type": "FloatArray → ℕ → Float",
  "offspring": ["FloatArray.get!"],
  "name": "FloatArray.getOp"},
 {"type":
  "{v : Sat.Valuation} → {f : Sat.Fmla} → {p : Prop} → Sort u → Sat.Fmla.reify v f p → Sat.Fmla.reify v f p → Sort u",
  "offspring": [],
  "name": "Sat.Fmla.reify.noConfusionType"},
 {"type": "Type u → Type u", "offspring": [], "name": "Ring"},
 {"type":
  "{α : Type u} → {β : Type v} → (β → α → β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → β",
  "offspring": ["Id.run", "Array.foldlM", "Id.instMonadId"],
  "name": "Array.foldl"},
 {"type": "∀ {a b c : ℤ}, a ≠ 0 → a * b = a * c → b = c",
  "offspring": [],
  "name": "Int.eq_of_mul_eq_mul_left"},
 {"type": "Tactic.NormCast.NormCastExtension → Lean.Meta.SimpExtension",
  "offspring": [],
  "name": "Tactic.NormCast.NormCastExtension.down"},
 {"type":
  "∀ {α : Sort u} [inst : SizeOf α] (down : α), sizeOf { down := down } = 1 + sizeOf down",
  "offspring": [],
  "name": "plift.up.sizeOf_spec"},
 {"type":
  "{m : Type → Type v} → [inst : Monad m] → {α : Type u_1} → {β : Type} → (α → m (Option β)) → List α → m (List β)",
  "offspring": [],
  "name": "List.mmapFilter"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} (h : β → γ) (g : α → β) (x : Option α),\n  Option.map h (Option.map g x) = Option.map (h ∘ g) x",
  "offspring": ["Option.map", "Option.map_none'", "Option.map_some'"],
  "name": "Option.map_map"},
 {"type":
  "{m : Type u → Type v} → [toApplicative : Applicative m] → [toBind : Bind m] → Monad m",
  "offspring": [],
  "name": "Monad.mk"},
 {"type": "{α : Type u_1} → UFNode α → α",
  "offspring": [],
  "name": "UFNode.value"},
 {"type": "Type u → Type u", "offspring": [], "name": "Id"},
 {"type": "∀ {a b : Prop}, (a ∧ b ↔ a) ↔ a → b",
  "offspring": ["and_iff_left_of_imp"],
  "name": "and_iff_left_iff_imp"},
 {"type":
  "∀ {α : Type u_1} {l l₁ l₂ : List α}, l₁ ⊆ l → List.disjoint l l₂ → List.disjoint l₁ l₂",
  "offspring": [],
  "name": "List.disjoint_of_subset_left"},
 {"type": "{α : Type u_1} → [inst : ToString α] → ToString (id α)",
  "offspring": [],
  "name": "instToStringIdType"},
 {"type": "∀ {α : Type u} {o : Option α}, Option.isNone o = true → o = none",
  "offspring": [],
  "name": "Option.eq_none_of_isNone"},
 {"type":
  "{α : Type u} → {β : Type v} → (α → α → Prop) → (β → β → Prop) → α × β → α × β → Prop",
  "offspring": [],
  "name": "Prod.Lex"},
 {"type": "∀ {α : Type u_1} {l : List α}, List.length l = 0 ↔ l = []",
  "offspring": ["List.eq_nil_of_length_eq_zero"],
  "name": "List.length_eq_zero"},
 {"type":
  "∀ {n : ℕ} (a b : Fin n), a + b = { val := (↑a + ↑b) % n, isLt := (_ : (↑a + ↑b) % n < n) }",
  "offspring": [],
  "name": "Fin.add_def"},
 {"type": "∀ {a : ℤ}, 0 ≤ a → ↑(Int.natAbs a) = a",
  "offspring": ["Int.eq_ofNat_of_zero_le"],
  "name": "Int.natAbs_of_nonneg"},
 {"type": "{α : Type} → ((σ : Type) → ST σ α) → α",
  "offspring": ["Empty", "Unit"],
  "name": "runST"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f : α → β} (h : Function.surjective f), Function.injective (Function.surj_inv h)",
  "offspring":
  ["Function.RightInverse.injective", "Function.RightInverse_surj_inv"],
  "name": "Function.injective_surj_inv"},
 {"type": "LT UInt32", "offspring": ["LT.mk"], "name": "instLTUInt32"},
 {"type": "∀ {a b : Prop}, (b → a) → (a ∨ b ↔ a)",
  "offspring": [],
  "name": "or_iff_left_of_imp"},
 {"type": "∀ {a b c : ℕ}, a + b ≤ c + b → a ≤ c",
  "offspring": ["Nat.le_of_add_le_add_left"],
  "name": "Nat.le_of_add_le_add_right"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {p : β → Prop} (h : ∀ (a : α), p (f a)),\n  Function.bijective f → Function.bijective (Subtype.coind f h)",
  "offspring": ["Subtype.coind_injective", "Subtype.coind_surjective"],
  "name": "Subtype.coind_bijective"},
 {"type":
  "{R : Type u} →\n  [toAddMonoid : AddMonoid R] →\n    [toOne : One R] →\n      (natCast : ℕ → R) → natCast 0 = 0 → (∀ (n : ℕ), natCast (n + 1) = natCast n + 1) → AddMonoidWithOne R",
  "offspring": [],
  "name": "AddMonoidWithOne.mk"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HAndThen α β γ → HAndThen α β γ → Sort u_1",
  "offspring": [],
  "name": "HAndThen.noConfusionType"},
 {"type": "{α : Type u_1} → List α → Option α",
  "offspring": ["List.getLast", "List.getLast?.proof_1"],
  "name": "List.getLast?"},
 {"type":
  "∀ {G : Type u} [inst : Semigroup G] [inst_1 : IsMulLeftCancel G] {a b c : G}, a * b = a * c → b = c",
  "offspring": ["IsMulLeftCancel.mul_left_cancel"],
  "name": "mul_left_cancel"},
 {"type":
  "(σ : Type u) → {m : Type u → Type v} → [inst : MonadStateOf σ m] → m σ",
  "offspring": ["MonadStateOf.get"],
  "name": "getThe"},
 {"type": "Lean.Expr → Lean.Elab.TermElabM Lean.Syntax",
  "offspring":
  ["readThe",
   "EmptyCollection.emptyCollection",
   "Tactic.TryThis.replaceMVarsByUnderscores"],
  "name": "Tactic.TryThis.delabToRefinableSyntax"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)], ↑0 = 0",
  "offspring": [],
  "name": "Fin.zero_def"},
 {"type": "∀ (p : Prop), (p ↔ True) = p",
  "offspring": ["trivial"],
  "name": "iff_true"},
 {"type": "{α : Sort u} → (α → α) → ℕ → α → α",
  "offspring": [],
  "name": "Nat.iterate"},
 {"type": "OrOp ℕ",
  "offspring": ["OrOp.mk", "Nat.lor"],
  "name": "Nat.instOrOpNat"},
 {"type": "{α : Type u} → {β : Type v} → α → β",
  "offspring": ["ULift.down", "cast", "unsafeCast.proof_1", "ULift.up"],
  "name": "unsafeCast"},
 {"type": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "offspring": [],
  "name": "GE.ge"},
 {"type":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∃ a, p a) ↔ ∃ a, q a)",
  "offspring": ["exists_imp_exists"],
  "name": "exists_congr"},
 {"type": "∀ (a b : Prop), xor a b = xor b a",
  "offspring": ["or_comm"],
  "name": "xor_comm"},
 {"type": "∀ (a b : USize), a % b = { val := a.val % b.val }",
  "offspring": [],
  "name": "USize.mod_def"},
 {"type":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], a ∨ b ↔ ¬(¬a ∧ ¬b)",
  "offspring": ["not_or_distrib", "Decidable.not_not", "Iff.rfl"],
  "name": "Decidable.or_iff_not_and_not"},
 {"type": "∀ {n m : ℕ}, n < m → ∀ (k : ℕ), n + k < m + k",
  "offspring": ["Nat.add_lt_add_left"],
  "name": "Nat.add_lt_add_right"},
 {"type": "Subsingleton (Fin 1)",
  "offspring": ["instSubsingletonFinOfNatNatInstOfNatNat_1.proof_1"],
  "name": "instSubsingletonFinOfNatNatInstOfNatNat_1"},
 {"type": "{α : Type u_1} → UnionFind α → Array (UFNode α)",
  "offspring": [],
  "name": "UnionFind.arr"},
 {"type": "∀ {a b c : Prop}, (a ↔ b) → (a → c ↔ b → c)",
  "offspring": [],
  "name": "imp_congr_left"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "offspring": ["Iff.elim_right.proof_1"],
  "name": "Iff.elim_right"},
 {"type": "∀ {α : Type u_1} (as : Array α), Array.size as ≤ Array.size as",
  "offspring": ["Nat.le_refl"],
  "name": "Array.foldrM.proof_1"},
 {"type": "Bool → Lean.LBool", "offspring": [], "name": "Bool.toLBool"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["Nat.bitwise", "or"], "name": "Nat.lor"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) (a : α) (l : List α), (∃ x, x ∈ a :: l ∧ p x) ↔ p a ∨ ∃ x, x ∈ l ∧ p x",
  "offspring": ["Or.elim", "List.mem_cons_self", "List.mem_cons_of_mem"],
  "name": "List.bex_cons"},
 {"type": "Ord USize",
  "offspring": ["Ord.mk", "compareOfLessAndEq", "instLTUSize"],
  "name": "instOrdUSize"},
 {"type": "Type u → Type v → Type (max u v)", "offspring": [], "name": "Sum"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.tacticSwap"},
 {"type":
  "{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadEnv m] → Lean.Name → Lean.Name → m Bool",
  "offspring":
  ["not",
   "Array.contains",
   "Option.getD",
   "Mathlib.Tactic.Lint.nolintAttr",
   "EmptyCollection.emptyCollection"],
  "name": "Mathlib.Tactic.Lint.shouldBeLinted"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → Option β) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → Array β",
  "offspring": ["Id.run", "Array.filterMapM", "Id.instMonadId"],
  "name": "Array.filterMap"},
 {"type":
  "Lean.SimpleScopedEnvExtension (Lean.Name × Tactic.NormCast.CoeFnInfo) (Lean.NameMap Tactic.NormCast.CoeFnInfo)",
  "offspring": [],
  "name": "Tactic.NormCast.coeExt"},
 {"type": "Sort u", "offspring": [], "name": "PUnit"},
 {"type": "{α : Type u} → (α → α → Ordering) → Ord α",
  "offspring": [],
  "name": "Ord.mk"},
 {"type":
  "{f : Type u → Type v} → [self : SeqRight f] → {α β : Type u} → f α → (Unit → f β) → f β",
  "offspring": [],
  "name": "SeqRight.seqRight"},
 {"type":
  "{collection : Type u} →\n  {stream : outParam (Type u)} → Sort u_1 → ToStream collection stream → ToStream collection stream → Sort u_1",
  "offspring": [],
  "name": "ToStream.noConfusionType"},
 {"type": "∀ (x x_1 : UInt8), x * x_1 = x_1 * x",
  "offspring":
  ["UInt8.eq_of_val_eq", "UInt8.mul_def", "CommSemigroup.mul_comm"],
  "name": "UInt8.instCommRingUInt8.proof_1"},
 {"type":
  "{stream : Type u} → {value : Type v} → [self : Stream stream value] → stream → Option (value × stream)",
  "offspring": [],
  "name": "Stream.next?"},
 {"type": "∀ (a b : ℤ), a * -b = -(a * b)",
  "offspring": ["Int.neg_mul_eq_mul_neg"],
  "name": "Int.mul_neg_eq_neg_mul_symm"},
 {"type": "PUnit", "offspring": [], "name": "PUnit.unit"},
 {"type": "LawfulBEq Bool",
  "offspring": ["LawfulBEq.mk"],
  "name": "instLawfulBEqBoolInstBEqInstDecidableEqBool.proof_1"},
 {"type": "∀ {c : Prop} [h₁ : Decidable c], as_true c → c",
  "offspring": [],
  "name": "of_as_true"},
 {"type":
  "{α : Type u_1} → (x y : α) → [inst : LT α] → [inst : Decidable (x < y)] → [inst : DecidableEq α] → Ordering",
  "offspring": ["Ordering.lt", "Ordering.eq", "Ordering.gt"],
  "name": "compareOfLessAndEq"},
 {"type": "∀ {a b c : ℤ}, a - b ≤ c → a - c ≤ b",
  "offspring": ["Int.sub_left_le_of_le_add", "Int.le_add_of_sub_right_le"],
  "name": "Int.sub_le_of_sub_le"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "offspring": ["Function.RightInverse"],
  "name": "Function.has_RightInverse"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α β : Type u} → (α → m (Option β)) → List α → List β → m (List β)",
  "offspring": [],
  "name": "List.filterMapM.loop"},
 {"type":
  "{α₁ α₂ α₃ α₄ α₅ β : Type u} →\n  (α₁ → α₂ → α₃ → α₄ → α₅ → β) →\n    ((α₁ → α₂ → α₃ → α₄ → α₅ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → β",
  "offspring": ["bfix5", "USize.size"],
  "name": "fixCore5"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : ℕ) (a_1 : Fin n), nsmul_rec (Nat.succ a) a_1 = a_1 + nsmul_rec a a_1",
  "offspring": ["Fin"],
  "name": "instAddGroupWithOneFin.proof_4"},
 {"type": "StdGen → StdGen × StdGen",
  "offspring": ["StdGen.mk", "StdGen.s1", "StdGen.s2", "stdNext"],
  "name": "stdSplit"},
 {"type":
  "{α : Type u} → [inst : LT α] → [h : DecidableRel fun a a_1 => a < a_1] → (l₁ l₂ : List α) → Decidable (l₁ ≤ l₂)",
  "offspring": [],
  "name": "List.instForAllListDecidableLeInstLEList"},
 {"type":
  "Lean.Environment →\n  Lean.Environment →\n    Lean.PersistentEnvExtension Lean.EnvExtensionEntry Lean.EnvExtensionEntry Lean.EnvExtensionState →\n      Lean.CoreM (Option Lean.MessageData)",
  "offspring": ["Classical.ofNonempty"],
  "name": "Mathlib.WhatsNew.diffExtension"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → a ≠ b → a < b",
  "offspring": ["lt_of_le_not_le", "mt", "le_antisymm"],
  "name": "lt_of_le_of_ne"},
 {"type": "{α : Type u} → String → (Unit → α) → α",
  "offspring": [],
  "name": "dbgTrace"},
 {"type": "∀ {α β : Sort u} {a : α} {b b' : β}, HEq a b → b = b' → HEq a b'",
  "offspring": ["HEq.trans", "heq_of_eq"],
  "name": "heq_of_heq_of_eq"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [self : LawfulApplicative f] {α β : Type u} (x : f α) (y : f β),\n  (SeqRight.seqRight x fun x => y) = Seq.seq (Function.const α id <$> x) fun x => y",
  "offspring": [],
  "name": "LawfulApplicative.seqRight_eq"},
 {"type": "{R : Type u} → Sort u_1 → Semiring R → Semiring R → Sort u_1",
  "offspring": [],
  "name": "Semiring.noConfusionType"},
 {"type":
  "Sort u → Mathlib.Tactic.Sat.Clause → Mathlib.Tactic.Sat.Clause → Sort u",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Clause.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} [inst : SizeOf α] (arr : Array α), sizeOf { arr := arr } = 1 + sizeOf arr",
  "offspring": [],
  "name": "BinaryHeap.mk.sizeOf_spec"},
 {"type": "∀ {α : Type u_1} {β : Type u_2} (p : α × β), (p.fst, p.snd) = p",
  "offspring": [],
  "name": "Prod.ext"},
 {"type": "{α : Type u} → α → Task α", "offspring": [], "name": "Task.pure"},
 {"type": "∀ (m n k : ℕ), Nat.gcd (m * n) (k * n) = Nat.gcd m k * n",
  "offspring": ["Nat.gcd_mul_left"],
  "name": "Nat.gcd_mul_right"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [h : Nonempty α], Function.surjective Prod.snd",
  "offspring": ["Nonempty.elim"],
  "name": "Prod.snd_surjective"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["Fin.add.proof_1"],
  "name": "Fin.add"},
 {"type": "Type u → (Type u → Type v) → Type u → Type v",
  "offspring": ["Except"],
  "name": "ExceptT"},
 {"type":
  "∀ {α : Type u_1} (lt : α → α → Bool) (i : ℕ) (a : Array α),\n  i + 1 ≤ Array.size a → i ≤ Array.size (BinaryHeap.heapifyDown lt a { val := i, isLt := (_ : i < Array.size a) }).val",
  "offspring":
  ["le_of_lt",
   "Nat.lt_of_succ_le",
   "Subtype.property",
   "BinaryHeap.heapifyDown"],
  "name": "BinaryHeap.mkHeap.loop.proof_3"},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : SizeOf α] [inst_1 : SizeOf β] (fst : α) (snd : β),\n  sizeOf (fst, snd) = 1 + sizeOf fst + sizeOf snd",
  "offspring": [],
  "name": "Prod.mk.sizeOf_spec"},
 {"type": "∀ {a : ℕ}, a < UInt16.size → ↑(UInt16.ofNat a).val = a",
  "offspring": ["Fin.val_eq_of_lt"],
  "name": "UInt16.val_eq_of_lt"},
 {"type": "∀ {α : Type u_1} {a : α} {l m : List α}, a ∈ m → l ⊆ m → a :: l ⊆ m",
  "offspring": ["List.cons_subset"],
  "name": "List.cons_subset_of_subset_of_mem"},
 {"type": "∀ (m n k : ℕ), (m + n % k) % k = (m + n) % k",
  "offspring": ["Nat.mod_add_mod"],
  "name": "Nat.add_mod_mod"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {l₁ l₂ : List α} (f : α → β), l₁ ⊆ l₂ → List.map f l₁ ⊆ List.map f l₂",
  "offspring": ["List.mem_map", "exists_imp_distrib", "and_imp"],
  "name": "List.map_subset"},
 {"type": "{α : Type u_1} → [inst : Ord α] → LE α",
  "offspring": ["LE.mk", "Ordering.isLE", "Ord.compare"],
  "name": "leOfOrd"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Mathlib.ExtendedBinder.extBinders"],
  "name": "Mathlib.ExtendedBinder.«term∀ᵉ_,_»"},
 {"type": "Repr Lean.SourceInfo",
  "offspring":
  ["GE.ge", "reprArg", "Substring", "instReprSubstring", "instReprNat"],
  "name": "instReprSourceInfo"},
 {"type": "{α : Type u} → {β : Type v} → (α → Option β) → List α → Option β",
  "offspring": [],
  "name": "List.findSome?"},
 {"type":
  "∀ {α : Type u_1} (s : Subarray α), s.start < s.stop → Nat.succ s.start ≤ s.stop",
  "offspring": ["Nat.succ_le_of_lt"],
  "name": "instStreamSubarray.proof_1"},
 {"type": "{M : Type u_1} → [inst : CommMonoid M] → CommSemigroup M",
  "offspring": ["CommSemigroup.mk", "CommMonoid.mul_comm"],
  "name": "instCommSemigroup"},
 {"type": "Decidable True → decide True = true",
  "offspring": ["Decidable.decide", "True.intro"],
  "name": "decide_true_eq_true"},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] (a : M) (n : ℕ), a ^ n * a = a * a ^ n",
  "offspring":
  ["Nat.zero_eq",
   "pow_zero",
   "one_mul",
   "mul_one",
   "pow_succ'",
   "Semigroup.mul_assoc"],
  "name": "pow_mul_comm"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, b ≤ a → min a b = b",
  "offspring": ["min_comm", "min_eq_left"],
  "name": "min_eq_right"},
 {"type":
  "∀ {n : ℕ} (parent : Fin n → Fin n) (rank : ℕ → ℕ)\n  (rank_lt : ∀ (i : Fin n), ↑(parent i) ≠ ↑i → rank ↑i < rank ↑(parent i)),\n  sizeOf { parent := parent, rank := rank, rank_lt := rank_lt } = 1",
  "offspring": [],
  "name": "UFModel.mk.sizeOf_spec"},
 {"type":
  "∀ {R : Type u} [self : NonUnitalNonAssocSemiring R] (n : ℕ),\n  NonUnitalNonAssocSemiring.natCast (n + 1) = NonUnitalNonAssocSemiring.natCast n + 1",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.natCast_succ"},
 {"type": "List UInt8 → ByteArray → ByteArray",
  "offspring": ["ByteArray.push"],
  "name": "List.toByteArray.loop"},
 {"type": "∀ (a b : ℤ), -(a * b) = a * -b",
  "offspring":
  ["Int.neg_eq_of_add_eq_zero",
   "Int.distrib_left",
   "Int.add_right_neg",
   "Int.mul_zero"],
  "name": "Int.neg_mul_eq_mul_neg"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk"],
  "name": "UInt32.add"},
 {"type": "∀ {a b : ℕ}, a < b → a / b = 0",
  "offspring": ["Nat.div_eq", "if_neg", "Nat.not_le_of_gt"],
  "name": "Nat.div_eq_of_lt"},
 {"type":
  "∀ {α : Type u_1} {a : α} {s t : List α}, ¬a ∈ s → ¬a ∈ t → ¬a ∈ s ++ t",
  "offspring": ["mt", "List.mem_append", "not_or"],
  "name": "List.not_mem_append"},
 {"type": "ByteArray → ℕ → ℕ → ByteSlice",
  "offspring": [],
  "name": "ByteSlice.mk"},
 {"type": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "offspring": [],
  "name": "Ne.symm"},
 {"type": "∀ (n : ℕ), ¬0 < n → n = 0",
  "offspring": ["Nat.zero_lt_succ"],
  "name": "Nat.eq_zero_of_nonpos"},
 {"type": "∀ (m n : ℕ), -[1+ m] + -[1+ n] = -[1+ Nat.succ (m + n)]",
  "offspring": [],
  "name": "Int.negSucc_ofNat_add_negSucc_ofNat"},
 {"type": "Sub ℕ", "offspring": ["Sub.mk", "Nat.sub"], "name": "instSubNat"},
 {"type": "Div System.FilePath",
  "offspring": ["Div.mk", "System.FilePath.join"],
  "name": "System.FilePath.instDivFilePath"},
 {"type":
  "∀ (x x_1 x_2 : UInt16), { val := (x * x_1 * x_2).1 } = { val := (x * (x_1 * x_2)).1 }",
  "offspring": ["UInt16.mk", "Semigroup.mul_assoc"],
  "name": "UInt16.instSemigroupUInt16.proof_1"},
 {"type":
  "∀ {α : Type u} [self : Preorder α] (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a",
  "offspring": [],
  "name": "Preorder.lt_iff_le_not_le"},
 {"type": "Type u → Type u", "offspring": [], "name": "SubNegMonoid"},
 {"type": "{m : Type u_1 → Type u_2} → {α : Type u_3} → ForIn m (Subarray α) α",
  "offspring": ["ForIn.mk", "Subarray.forIn"],
  "name": "Subarray.instForInSubarray"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l ↔ ∃ n, List.get l n = a",
  "offspring": ["List.get_of_mem", "List.get_mem"],
  "name": "List.mem_iff_get"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {y : β}, (fun x => y) = Function.const α y",
  "offspring": [],
  "name": "Function.const_def"},
 {"type":
  "{p : Prop} → {q : Sort u} → [φ : Decidable p] → (p → q) → (¬p → q) → q",
  "offspring": ["Decidable.byCases"],
  "name": "Decidable.by_cases"},
 {"type": "Type u → Type u", "offspring": [], "name": "Mod"},
 {"type": "∀ (as : ByteArray), ByteArray.size as ≤ ByteArray.size as",
  "offspring": ["Nat.le_refl", "ByteArray.size"],
  "name": "ByteArray.foldlM.proof_1"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [toLawfulFunctor : LawfulFunctor f],\n  (∀ {α β : Type u} (x : f α) (y : f β), (SeqLeft.seqLeft x fun x => y) = Seq.seq (Function.const β <$> x) fun x => y) →\n    (∀ {α β : Type u} (x : f α) (y : f β),\n        (SeqRight.seqRight x fun x => y) = Seq.seq (Function.const α id <$> x) fun x => y) →\n      (∀ {α β : Type u} (g : α → β) (x : f α), (Seq.seq (pure g) fun x_1 => x) = g <$> x) →\n        (∀ {α β : Type u} (g : α → β) (x : α), g <$> pure x = pure (g x)) →\n          (∀ {α β : Type u} (g : f (α → β)) (x : α), (Seq.seq g fun x_1 => pure x) = (fun h => h x) <$> g) →\n            (∀ {α β γ : Type u} (x : f α) (g : f (α → β)) (h : f (β → γ)),\n                (Seq.seq h fun x_1 => Seq.seq g fun x_2 => x) =\n                  Seq.seq (Seq.seq (Function.comp <$> h) fun x => g) fun x_1 => x) →\n              LawfulApplicative f",
  "offspring": [],
  "name": "LawfulApplicative.mk"},
 {"type": "{α : Type u_1} → List α → optParam ℕ 1 → List α",
  "offspring": ["List.drop", "List.take"],
  "name": "List.rotateRight"},
 {"type": "∀ {p : Prop} (P : p → Prop) (h : ¬p), ¬∃ h, P h",
  "offspring": ["mt"],
  "name": "exists_prop_decidable.proof_2"},
 {"type":
  "∀ (b : ℕ), 2 ≤ b → ∀ (f n e : ℕ), n < b ^ e → 0 < e → List.length (Nat.toDigitsCore b f n []) ≤ e",
  "offspring": ["Nat.zero_le", "Nat.lt_irrefl"],
  "name": "Nat.to_digits_core_length"},
 {"type": "∀ {a b : Prop}, ¬a → b ↔ ¬b → a",
  "offspring": ["Decidable.not_imp_comm"],
  "name": "not_imp_comm"},
 {"type": "∀ {a b c : ℕ}, a ∣ b → a ∣ c → a ∣ b + c",
  "offspring": ["Exists.elim", "Nat.left_distrib"],
  "name": "Nat.dvd_add"},
 {"type": "Sort u → Nat.Linear.PolyCnstr → Nat.Linear.PolyCnstr → Sort u",
  "offspring": [],
  "name": "Nat.Linear.PolyCnstr.noConfusionType"},
 {"type": "USize → USize → USize",
  "offspring":
  ["USize.mk",
   "HShiftRight.hShiftRight",
   "USize.modn",
   "System.Platform.numBits"],
  "name": "USize.shiftRight"},
 {"type": "{ε σ α : Type} → [inst : Inhabited ε] → Inhabited (EST ε σ α)",
  "offspring": [],
  "name": "instInhabitedEST"},
 {"type": "(a b : ℤ) → Decidable (a = b)",
  "offspring":
  ["decEq",
   "Int.decEq.proof_1",
   "Int.decEq.proof_2",
   "Int.decEq.proof_3",
   "Int.decEq.proof_4",
   "Int.decEq.proof_5",
   "Int.decEq.proof_6"],
  "name": "Int.decEq"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HSub α β γ",
  "offspring": [],
  "name": "HSub.mk"},
 {"type":
  "∀ {α : Sort u_1} {s : Setoid α} (a₁ a₂ : α), ¬a₁ ≈ a₂ → Quotient.mk s a₁ = Quotient.mk s a₂ → False",
  "offspring": ["Quotient.exact"],
  "name": "instDecidableEqQuotient.proof_2"},
 {"type":
  "∀ {k l : ℕ} (m n : ℕ), Nat.coprime k l → Nat.coprime (k ^ m) (l ^ n)",
  "offspring": ["Nat.coprime.pow_right", "Nat.coprime.pow_left"],
  "name": "Nat.coprime.pow"},
 {"type":
  "∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v",
  "offspring": ["if_pos", "if_neg"],
  "name": "ite_congr"},
 {"type": "{α : Type s} → ULift α → α", "offspring": [], "name": "ULift.down"},
 {"type": "ByteSliceT → ByteSlice",
  "offspring": ["ByteSlice.mk", "ByteArray.size"],
  "name": "ByteSliceT.toSlice"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk", "HShiftRight.hShiftRight", "UInt32.modn"],
  "name": "UInt32.shiftRight"},
 {"type": "∀ (m n k : ℕ), Nat.gcd m n ∣ Nat.gcd m (n * k)",
  "offspring": ["Nat.gcd_dvd_gcd_of_dvd_right", "Nat.dvd_mul_right"],
  "name": "Nat.gcd_dvd_gcd_mul_right_right"},
 {"type":
  "{F : Type u → Type v} → [inst : Applicative F] → {α : Type u_1} → {β : Type u} → (α → F β) → Option α → F (Option β)",
  "offspring": ["Functor.map"],
  "name": "Option.traverse"},
 {"type":
  "∀ (x : ℕ) (a : UInt8),\n  { val := Ring.gsmul -[1+ x] a.val } =\n    { val := (-(fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat (Nat.succ x)) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_neg'"],
  "name": "UInt8.instRingUInt8.proof_5"},
 {"type": "∀ {α : Type u_1} (n : ℕ) (a : α), List.set [] n a = []",
  "offspring": [],
  "name": "List.set_nil"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«binderTerm≥_»"},
 {"type":
  "∀ {m n : ℕ}, n ≤ m → ∀ (k : ℕ), Int.subNatNat (m - n) k = Int.subNatNat m (k + n)",
  "offspring": ["Int.subNatNat_add_add", "Nat.sub_add_cancel"],
  "name": "Int.subNatNat_sub"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "prioDefault"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} {a : α}, List.disjoint (a :: l₁) l₂ ↔ ¬a ∈ l₂ ∧ List.disjoint l₁ l₂",
  "offspring":
  ["Iff.trans",
   "List.disjoint_append_left",
   "List.singleton_disjoint",
   "List.disjoint"],
  "name": "List.disjoint_cons_left"},
 {"type": "ToString ℤ",
  "offspring": ["ToString.mk", "instToStringNat"],
  "name": "instToStringInt"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_≤_»"},
 {"type": "{α : Type u} → Sort u_1 → Mod α → Mod α → Sort u_1",
  "offspring": [],
  "name": "Mod.noConfusionType"},
 {"type": "Type", "offspring": [], "name": "Mathlib.Tactic.Sat.LRATStep"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a <+ a_1 → Prop} (l₁ l₂ : List α) (a : α) {a_1 : l₁ <+ l₂},\n  List.sublist.below a_1 → motive l₁ l₂ a_1 → List.sublist.below (_ : l₁ <+ a :: l₂)",
  "offspring": [],
  "name": "List.sublist.below.cons"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": [],
  "name": "unexpandSorryAx"},
 {"type": "∀ {m n : ℕ}, Nat.gcd m n = 0 → m = 0",
  "offspring": ["Nat.eq_zero_or_pos", "ne_of_lt", "Nat.gcd_pos_of_pos_left"],
  "name": "Nat.eq_zero_of_gcd_eq_zero_left"},
 {"type": "Type", "offspring": [], "name": "Nat.Linear.Var"},
 {"type": "∀ (x : UInt32), npow_rec 0 x = npow_rec 0 x",
  "offspring": [],
  "name": "UInt32.instSemiringUInt32.proof_15"},
 {"type":
  "{R : Type u_1} → {n : ℕ} → [inst : AddMonoidWithOne R] → [inst : Nat.AtLeastTwo n] → OfNat R n",
  "offspring": ["OfNat.mk"],
  "name": "instOfNat_2"},
 {"type": "∀ {α : Type u_1} (f : Set α → α), ¬Function.injective f",
  "offspring":
  ["Function.cantor_surjective", "Function.RightInverse.surjective"],
  "name": "Function.cantor_injective"},
 {"type":
  "{α : Type u} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "offspring": [],
  "name": "Membership.mem"},
 {"type": "{b : Prop} → (a : Prop) → (a ↔ b) → [D : Decidable a] → Decidable b",
  "offspring": ["decidable_of_decidable_of_iff"],
  "name": "decidable_of_iff"},
 {"type": "LE UInt64",
  "offspring": ["LE.mk", "UInt64.le"],
  "name": "instLEUInt64"},
 {"type": "Repr System.FilePath",
  "offspring": ["repr", "instReprString", "System.FilePath.toString"],
  "name": "System.instReprFilePath"},
 {"type": "@List.append = @List.appendTR",
  "offspring": ["List.reverseAux_reverseAux"],
  "name": "List.append_eq_appendTR"},
 {"type": "{n : ℕ} → UFModel n → (k : ℕ) → n ≤ k → UFModel k",
  "offspring":
  ["UFModel.mk",
   "Fin",
   "UFModel.push.proof_1",
   "UFModel.parent",
   "UFModel.rank",
   "UFModel.push.proof_2"],
  "name": "UFModel.push"},
 {"type": "∀ {a : Prop} (h₁ h₂ : a), h₁ = h₂",
  "offspring": ["proofIrrel"],
  "name": "proof_irrel"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] {h : n > 0}, Fin.ofNat' 0 h = 0",
  "offspring": [],
  "name": "Fin.ofNat'_zero"},
 {"type": "{α : Sort u} → (α → UInt64) → Hashable α",
  "offspring": [],
  "name": "Hashable.mk"},
 {"type": "(n : ℕ) → n < USize.size → USize",
  "offspring": ["USize.mk", "USize.size"],
  "name": "USize.ofNatCore"},
 {"type": "∀ {a : ℤ}, 0 < -a → a < 0",
  "offspring": [],
  "name": "Int.neg_of_neg_pos"},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → [inst_1 : Hashable α] → List α → Lean.SSet α",
  "offspring": ["List.foldl"],
  "name": "List.toSSet"},
 {"type":
  "{ε : Type u} →\n  {m : Type u → Type v} → [inst : Monad m] → {α β : Type u} → ExceptT ε m α → (α → ExceptT ε m β) → ExceptT ε m β",
  "offspring": ["ExceptT.mk", "ExceptT.bindCont"],
  "name": "ExceptT.bind"},
 {"type": "Bool",
  "offspring": ["System.Platform.getIsWindows"],
  "name": "System.Platform.isWindows"},
 {"type": "∀ {m : ℕ} (n k : ℕ), 0 < m → m * n / (m * k) = n / k",
  "offspring": ["Nat.div_div_eq_div_mul", "Nat.mul_div_cancel_left"],
  "name": "Nat.mul_div_mul"},
 {"type": "∀ (p : Prop), (p ∨ p) = p", "offspring": [], "name": "or_self"},
 {"type": "Substring → (Char → Bool) → Bool",
  "offspring": ["not", "Substring.any"],
  "name": "Substring.all"},
 {"type": "∀ (a : UInt16), -a = { val := -a.val }",
  "offspring": [],
  "name": "UInt16.neg_def"},
 {"type": "{M : Type u} → [self : Monoid M] → One M",
  "offspring": [],
  "name": "Monoid.toOne"},
 {"type": "∀ {α : Sort u} [inst : Setoid α] {a b c : α}, a ≈ b → b ≈ c → a ≈ c",
  "offspring": ["Equivalence.trans", "Setoid.iseqv"],
  "name": "Setoid.trans"},
 {"type":
  "∀ {as ps : List Prop} {p : Prop} (as₁ : List Prop),\n  as = List.reverseAux as₁ ps → Sat.Valuation.implies (Sat.Valuation.mk as) p ps (List.length as₁) → p",
  "offspring": [],
  "name": "Sat.Valuation.mk_implies"},
 {"type": "ℕ → Type", "offspring": [], "name": "UFModel"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), a ∈ List.insert a l",
  "offspring": ["List.mem_insert_iff"],
  "name": "List.mem_insert_self"},
 {"type": "∀ (n b e : ℕ), 0 < b → n < b ^ Nat.succ e → n / b < b ^ e",
  "offspring": ["Nat.pow_succ", "Nat.div_lt_iff_lt_mul"],
  "name": "Nat.nat_repr_len_aux"},
 {"type": "∀ {a b : Prop}, a → a ∨ b", "offspring": [], "name": "Or.inl"},
 {"type": "∀ {a b : Prop}, ¬a ∨ ¬b → ¬(a ∧ b)",
  "offspring": ["Or.elim"],
  "name": "not_and_of_not_or_not"},
 {"type": "∀ (b : Bool), (b && true) = b",
  "offspring": [],
  "name": "Bool.and_true"},
 {"type": "∀ {m n l : ℕ}, m - n = Nat.succ l → n < m",
  "offspring":
  ["not_le", "Nat.instLinearOrderNat", "Nat.sub_eq_zero_of_le", "eq_false'"],
  "name": "Nat.lt_of_sub_eq_succ"},
 {"type": "∀ {a b : UInt8}, a.val = b.val → a = b",
  "offspring": ["UInt8.mk"],
  "name": "UInt8.eq_of_val_eq"},
 {"type":
  "∀ {v : Sat.Valuation} {f : Sat.Fmla},\n  Sat.Valuation.satisfies_fmla v f → ∀ (c : Sat.Clause), c ∈ f → Sat.Valuation.satisfies v c",
  "offspring": [],
  "name": "Sat.Valuation.satisfies_fmla.prop"},
 {"type":
  "{G : Type u} → [toMul : Mul G] → (∀ (a b c : G), a * b * c = a * (b * c)) → Semigroup G",
  "offspring": [],
  "name": "Semigroup.mk"},
 {"type": "HMod USize ℕ USize",
  "offspring": ["HMod.mk", "USize.modn"],
  "name": "instHModUSizeNat"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«binderTerm<_»"},
 {"type": "∀ (a : UInt16), 0 + a = a",
  "offspring":
  ["UInt16.zero_def",
   "UInt16.add_def",
   "UInt16.mk",
   "zero_add",
   "UInt16.mk_val_eq"],
  "name": "UInt16.instSemiringUInt16.proof_2"},
 {"type":
  "∀ {α : Type u_1} [inst : SizeOf α] (arr : Array (UFNode α)) (model : ∃ n m, UFModel.Models arr m),\n  sizeOf { arr := arr, model := model } = 1 + sizeOf arr + sizeOf model",
  "offspring": [],
  "name": "UnionFind.mk.sizeOf_spec"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l → ∃ n, List.get l n = a",
  "offspring": ["Nat.succ_pos", "Nat.succ_lt_succ"],
  "name": "List.get_of_mem"},
 {"type":
  "∀ {α : Sort u_1} {r : α → α → Prop}, WellFounded r → ∀ (a : α), Acc r a",
  "offspring": [],
  "name": "WellFounded.apply.proof_1"},
 {"type": "{α : Sort u} → (β : Sort v) → α → β → α",
  "offspring": [],
  "name": "Function.const"},
 {"type": "{α : Type u} → (α → α → Prop) → Subset α",
  "offspring": [],
  "name": "Subset.mk"},
 {"type": "{R : Type u} → [self : Distrib R] → Mul R",
  "offspring": [],
  "name": "Distrib.toMul"},
 {"type": "USize.size > 0",
  "offspring": ["Nat.pos_pow_of_pos", "Nat.zero_lt_succ"],
  "name": "usize_size_gt_zero"},
 {"type": "(A : Type u) → [inst : Add A] → Type",
  "offspring": [],
  "name": "IsAddLeftCancel"},
 {"type": "∀ {m n k : ℕ}, k ∣ m → k ∣ n → k ∣ Nat.gcd m n",
  "offspring":
  ["Nat.gcd.induction", "Nat.gcd_zero_left", "Nat.gcd_rec", "Nat.dvd_mod_iff"],
  "name": "Nat.dvd_gcd"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → Option α",
  "offspring": [],
  "name": "List.find"},
 {"type":
  "∀ {α : Type u_1} {arr : Array (UFNode α)} {model : ∃ n m, UFModel.Models arr m} {arr_1 : Array (UFNode α)}\n  {model_1 : ∃ n m, UFModel.Models arr_1 m},\n  { arr := arr, model := model } = { arr := arr_1, model := model_1 } → arr = arr_1",
  "offspring": [],
  "name": "UnionFind.mk.inj"},
 {"type": "∀ (m n : ℕ), n % m = 0 ↔ m ∣ n",
  "offspring": ["Iff.symm", "Nat.dvd_iff_mod_eq_zero"],
  "name": "Nat.decidable_dvd.proof_1"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : (x : α) → β x}, Function.Equiv f₁ f₂ → Function.Equiv f₂ f₁",
  "offspring": [],
  "name": "Function.Equiv.symm"},
 {"type": "{α : Sort u} → {β : Sort v} → [inst : CoeHead α β] → CoeHTCT α β",
  "offspring": ["CoeHTCT.mk", "CoeHead.coe"],
  "name": "coeOfHead"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a",
  "offspring": ["le_of_not_gt", "not_lt_of_ge"],
  "name": "not_lt"},
 {"type":
  "∀ {α : Type u} [inst : LT α] {motive : (a a_1 : List α) → List.lt a a_1 → Prop} (b : α) (bs : List α),\n  List.lt.below (_ : List.lt [] (b :: bs))",
  "offspring": [],
  "name": "List.lt.below.nil"},
 {"type":
  "∀ {α : Type u_1} {x : Option α} (h : Option.isSome x = true), some (Option.get h) = x",
  "offspring": ["Option.get"],
  "name": "Option.some_get"},
 {"type": "∀ {α : Type u_1} (p : α → Prop) (x : α), x ∈ [] → p x",
  "offspring": ["sorryAx"],
  "name": "List.ball_nil"},
 {"type": "ℕ → ℕ → ℕ → Prop", "offspring": [], "name": "Nat.Up"},
 {"type":
  "{α : Type u} → {β : α → Type v} → [inst : ToString α] → [s : (x : α) → ToString (β x)] → ToString (Sigma β)",
  "offspring": ["ToString.mk"],
  "name": "instToStringSigma"},
 {"type": "ByteArray → UInt64",
  "offspring":
  ["instBEqNat",
   "ByteArray.size",
   "HOr.hOr",
   "HShiftLeft.hShiftLeft",
   "UInt8.toUInt64",
   "ByteArray.get!",
   "panicWithPosWithDecl",
   "instInhabitedUInt64"],
  "name": "ByteArray.toUInt64BE!"},
 {"type": "ShiftRight UInt64",
  "offspring": ["ShiftRight.mk", "UInt64.shiftRight"],
  "name": "instShiftRightUInt64"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadWithReaderOf ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "offspring": [],
  "name": "MonadWithReaderOf.withReader"},
 {"type": "∀ (n : ℕ), Nat.succ n = 1 + n",
  "offspring": ["Nat.succ_eq_add_one"],
  "name": "Nat.succ_eq_one_add"},
 {"type":
  "∀ {α : Type u_1} {L L' : List α},\n  L = L' → ∀ (i : Fin (List.length L)), List.get L i = List.get L' { val := ↑i, isLt := (_ : ↑i < List.length L') }",
  "offspring": [],
  "name": "List.get_of_eq"},
 {"type": "System.FilePath → System.FilePath → System.FilePath",
  "offspring":
  ["System.FilePath.isAbsolute",
   "System.FilePath.mk",
   "System.FilePath.toString",
   "System.FilePath.pathSeparator"],
  "name": "System.FilePath.join"},
 {"type": "Nat.Linear.Context → Nat.Linear.PolyCnstr → Prop",
  "offspring":
  ["cond",
   "Nat.Linear.PolyCnstr.eq",
   "Nat.Linear.Poly.denote_eq",
   "Nat.Linear.Poly",
   "Nat.Linear.PolyCnstr.lhs",
   "Nat.Linear.PolyCnstr.rhs",
   "Nat.Linear.Poly.denote_le"],
  "name": "Nat.Linear.PolyCnstr.denote"},
 {"type": "∀ {a b : Prop}, a ∨ b ↔ ¬a → b",
  "offspring": ["Decidable.or_iff_not_imp_left"],
  "name": "or_iff_not_imp_left"},
 {"type":
  "{ρ : Type u_1} →\n  {α : Type u_2} →\n    {m : Type u_3 → Type u_4} →\n      {β : Type u_3} → [inst : Stream ρ α] → [inst : Monad m] → (α → β → m (ForInStep β)) → ρ → β → m β",
  "offspring": [],
  "name": "Stream.forIn.visit"},
 {"type":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          Quotient s₁ →\n            Quotient s₂ →\n              (f : α → β → φ) → (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) → φ",
  "offspring": ["Quotient.lift₂"],
  "name": "Quotient.liftOn₂"},
 {"type": "ℕ → ℕ → Bool", "offspring": [], "name": "Nat.beq"},
 {"type":
  "{α₁ α₂ α₃ α₄ α₅ α₆ β : Type u} →\n  (α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) →\n    ((α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β) → ℕ → α₁ → α₂ → α₃ → α₄ → α₅ → α₆ → β",
  "offspring": [],
  "name": "bfix6"},
 {"type":
  "∀ (x y : ℕ), Nat.gcd (Nat.succ x) y = Nat.gcd (y % Nat.succ x) (Nat.succ x)",
  "offspring": [],
  "name": "Nat.gcd_succ"},
 {"type": "∀ (a : ℕ), Nat.beq a a = true",
  "offspring": [],
  "name": "Nat.beq_refl"},
 {"type": "Repr UInt32",
  "offspring": ["repr", "instReprNat", "UInt32.toNat"],
  "name": "instReprUInt32"},
 {"type":
  "∀ {α : Type u_1} (a b : α) {n m : ℕ} (l : List α), n ≠ m → List.set (List.set l n a) m b = List.set (List.set l m b) n a",
  "offspring": ["List.set_nil", "Nat.add_zero", "Nat.add", "Nat.succ_inj'"],
  "name": "List.set_comm"},
 {"type": "(n : ℕ) → n < UInt16.size → UInt16",
  "offspring": ["UInt16.mk", "UInt16.size"],
  "name": "UInt16.ofNatCore"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk", "Fin.land", "UInt16.size"],
  "name": "UInt16.land"},
 {"type": "Type", "offspring": [], "name": "StdGen"},
 {"type": "Sort u → UInt8 → UInt8 → Sort u",
  "offspring": [],
  "name": "UInt8.noConfusionType"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a > b → a ≤ b",
  "offspring": ["le_of_not_lt"],
  "name": "le_of_not_gt"},
 {"type":
  "{ε : Type u} → {α : Type u_1} → {β : Type u_2} → (α → β) → Except ε α → Except ε β",
  "offspring": ["Except.error", "Except.ok"],
  "name": "Except.map"},
 {"type": "∀ {α : Type u_1} {o : Option α}, o = none ↔ ∀ (a : α), ¬a ∈ o",
  "offspring": ["Option.ext", "Option.mem_def", "eq_false'", "iff_false"],
  "name": "Option.eq_none_iff_forall_not_mem"},
 {"type": "∀ {n m : ℕ}, m ≤ n → ¬n < m",
  "offspring": ["Nat.not_le_of_gt"],
  "name": "Nat.not_lt_of_le"},
 {"type": "ℕ → ℕ", "offspring": [], "name": "Nat.pred"},
 {"type": "{α : Type u_1} → [inst : BEq α] → Option α → α → Bool",
  "offspring": [],
  "name": "Option.isEqSome"},
 {"type":
  "{f : Type u → Type v} → [self : Functor f] → {α β : Type u} → α → f β → f α",
  "offspring": [],
  "name": "Functor.mapConst"},
 {"type": "Type", "offspring": [], "name": "Tactic.NormCast.Label"},
 {"type":
  "Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly × Nat.Linear.Poly",
  "offspring": ["Nat.Linear.Poly.cancelAux", "Nat.Linear.hugeFuel"],
  "name": "Nat.Linear.Poly.cancel"},
 {"type":
  "∀ (eq : Bool) (lhs rhs : Nat.Linear.Poly),\n  sizeOf { eq := eq, lhs := lhs, rhs := rhs } = 1 + sizeOf eq + sizeOf lhs + sizeOf rhs",
  "offspring": ["Nat.Linear.Poly"],
  "name": "Nat.Linear.PolyCnstr.mk.sizeOf_spec"},
 {"type": "∀ (m n : ℕ), m * n % m = 0",
  "offspring": ["Nat.zero_add", "Nat.add_mul_mod_self_left", "Nat.zero_mod"],
  "name": "Nat.mul_mod_right"},
 {"type": "ℕ → ℕ",
  "offspring":
  ["WellFounded.fix",
   "Nat.log2.proof_1",
   "GE.ge",
   "HDiv.hDiv",
   "of_decide_eq_false",
   "Decidable.decide",
   "Nat.div_eq",
   "if_pos",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var",
   "and_self",
   "Nat.succ_lt_succ",
   "Nat.lt_trans",
   "PProd.snd",
   "Nat.lt_succ_self"],
  "name": "Nat.log2"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε α : Type u_1} {x : α} [inst : Monad m], ExceptCpsT.run (pure x) = pure (Except.ok x)",
  "offspring": [],
  "name": "ExceptCpsT.run_pure"},
 {"type": "ℕ → ℕ → List ℕ", "offspring": [], "name": "List.range'"},
 {"type": "Div UInt64",
  "offspring": ["Div.mk", "UInt64.div"],
  "name": "instDivUInt64"},
 {"type":
  "∀ {α : Type u_1} (x : Option α), (HOrElse.hOrElse x fun x => none) = x",
  "offspring": [],
  "name": "Option.orelse_none"},
 {"type": "∀ {n m : ℕ}, n * m = 0 → n = 0 ∨ m = 0",
  "offspring": ["Nat.eq_zero_of_add_eq_zero_left", "Nat.succ_mul"],
  "name": "Nat.eq_zero_of_mul_eq_zero"},
 {"type": "Type u → Type u", "offspring": ["RandG", "StdGen"], "name": "Rand"},
 {"type": "{α : Type u} → Sort u_1 → List α → List α → Sort u_1",
  "offspring": [],
  "name": "List.noConfusionType"},
 {"type": "Array ℤ → Lean.Expr → Lean.Expr → Mathlib.Tactic.Sat.Clause",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Clause.mk"},
 {"type": "Mod ℕ",
  "offspring": ["Mod.mk", "Nat.mod"],
  "name": "Nat.instModNat"},
 {"type":
  "∀ {α : Sort uA} {β : Sort uB} {s₁ : Setoid α} {s₂ : Setoid β} {motive : Quotient s₁ → Quotient s₂ → Prop}\n  (q₁ : Quotient s₁) (q₂ : Quotient s₂),\n  (∀ (a : α) (b : β), motive (Quotient.mk s₁ a) (Quotient.mk s₂ b)) → motive q₁ q₂",
  "offspring": ["Quotient.ind"],
  "name": "Quotient.inductionOn₂"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Classical.«tacticBy_cases__:_»"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], ¬a → ¬b ↔ b → a",
  "offspring": ["Decidable.by_contradiction", "mt"],
  "name": "Decidable.not_imp_not"},
 {"type": "Inhabited Nat.Linear.Expr",
  "offspring": ["Inhabited.default", "instInhabitedNat"],
  "name": "Nat.Linear.instInhabitedExpr"},
 {"type":
  "∀ {α β σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf β] [inst_2 : SizeOf σ] (a : σ),\n  sizeOf (DoResultPRBC.break a) = 1 + sizeOf a",
  "offspring": [],
  "name": "DoResultPRBC.break.sizeOf_spec"},
 {"type": "∀ {a b : Prop} [inst : Decidable b], a ∨ b ↔ ¬b → a",
  "offspring": ["Iff.trans", "Or.comm", "Decidable.or_iff_not_imp_left"],
  "name": "Decidable.or_iff_not_imp_right"},
 {"type":
  "{α : Type u} →\n  [toNonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring α] →\n    (∀ (a : α), 1 * a = a) → (∀ (a : α), a * 1 = a) → NonAssocSemiring α",
  "offspring": [],
  "name": "NonAssocSemiring.mk"},
 {"type": "{α : Type u_1} → [inst : ToString α] → ToString (Subarray α)",
  "offspring": ["ToString.mk", "Subarray.toArray"],
  "name": "instToStringSubarray"},
 {"type": "Complement UInt32",
  "offspring": ["Complement.mk", "UInt32.complement"],
  "name": "instComplementUInt32"},
 {"type": "{α : Type u} → (α → α → α) → AndOp α",
  "offspring": [],
  "name": "AndOp.mk"},
 {"type": "Type",
  "offspring": ["List", "Prod", "Nat.Linear.Var"],
  "name": "Nat.Linear.Poly"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a : { a // p a }} {b : α}, a.val = b ↔ ∃ h, a = { val := b, property := h }",
  "offspring": ["Subtype.property", "Subtype.coe_eta", "Subtype.val"],
  "name": "Subtype.coe_eq_iff"},
 {"type":
  "{ε : Type u_1} →\n  {m : Type u_2 → Type u_3} → {α : Type u_2} → [inst : MonadExceptOf ε m] → [inst : Pure m] → Except ε α → m α",
  "offspring": [],
  "name": "liftExcept"},
 {"type":
  "∀ {α : Type u_1} (l : List α) (h : l ≠ []),\n  List.getLast l h = List.get l { val := List.length l - 1, isLt := (_ : List.length l - 1 < List.length l) }",
  "offspring":
  ["List.getLast_singleton",
   "List.get_singleton",
   "List.getLast_cons",
   "List.cons_ne_nil"],
  "name": "List.getLast_eq_get"},
 {"type":
  "{α : Sort u_1} → {β : α → Sort u_2} → (x : α) → ((x : α) → β x) → β x",
  "offspring": [],
  "name": "Function.eval"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (fuel : ℕ) (m₁ m₂ r₁ r₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_le ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂) →\n    Nat.Linear.Poly.denote_le ctx (Nat.Linear.Poly.cancelAux fuel m₁ m₂ r₁ r₂)",
  "offspring":
  ["Nat.sub_eq",
   "List.append_nil",
   "cond_true",
   "List.reverse_cons",
   "Nat.Linear.Poly.denote_append",
   "Nat.Linear.Poly.denote_reverse",
   "Nat.zero_add",
   "Nat.add_left_comm",
   "Bool.of_not_eq_true",
   "cond_false"],
  "name": "Nat.Linear.Poly.denote_le_cancelAux"},
 {"type": "ℤ → ℤ → ℤ", "offspring": ["HDiv.hDiv"], "name": "Int.div"},
 {"type":
  "∀ {α : Sort u_1} {φ : α → Sort v} {a a' : α} {p₁ : φ a} {p₂ : φ a'} (e : a = a'), e ▸ p₁ = p₂ → HEq p₁ p₂",
  "offspring": ["HEq.rfl"],
  "name": "heq_of_eq_rec_left"},
 {"type":
  "{ω σ : Type} → {m : Type → Type} → [inst : MonadLiftT (ST ω) m] → [inst : Monad m] → MonadStateOf σ (StateRefT' ω σ m)",
  "offspring":
  ["MonadStateOf.mk",
   "StateRefT'.get",
   "StateRefT'.set",
   "StateRefT'.modifyGet"],
  "name": "StateRefT'.instMonadStateOfStateRefT'"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {g : β → α}, Function.RightInverse g f → Function.LeftInverse f g",
  "offspring": [],
  "name": "Function.RightInverse.LeftInverse"},
 {"type": "∀ {a b c : ℤ}, a ≠ 0 → b * a = c * a → b = c",
  "offspring": [],
  "name": "Int.eq_of_mul_eq_mul_right"},
 {"type": "Type", "offspring": [], "name": "Nat"},
 {"type":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "offspring": [],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (k : ℕ) (v : Nat.Linear.Var),\n  Nat.Linear.Expr.denote ctx (Nat.Linear.monomialToExpr k v) = k * Nat.Linear.Var.denote ctx v",
  "offspring":
  ["cond_true",
   "eq_of_beq",
   "Nat.instLawfulBEqNatInstBEqNat",
   "beq_self_eq_true",
   "Nat.Linear.Var.denote.go",
   "Nat.mul_one",
   "Bool.of_not_eq_true",
   "cond_false",
   "Nat.one_mul"],
  "name": "Nat.Linear.denote_monomialToExpr"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → Sort u_1 → MonadStateOf σ m → MonadStateOf σ m → Sort u_1",
  "offspring": [],
  "name": "MonadStateOf.noConfusionType"},
 {"type":
  "{v : Sat.Valuation} → {c : Sat.Clause} → {p : Prop} → Sort u → Sat.Clause.reify v c p → Sat.Clause.reify v c p → Sort u",
  "offspring": [],
  "name": "Sat.Clause.reify.noConfusionType"},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → α → β",
  "offspring": [],
  "name": "Equiv.toFun"},
 {"type":
  "∀ {α : Type u_1} {a : α} {L : List (List α)}, a ∈ List.join L → ∃ l, l ∈ L ∧ a ∈ l",
  "offspring": ["List.mem_join"],
  "name": "List.exists_of_mem_join"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : α) (l : List α),\n  List.erase (b :: l) a = if b = a then l else b :: List.erase l a",
  "offspring":
  ["EqIffBeqTrue", "if_pos", "NeqIffBeqFalse", "Ne.symm", "if_neg"],
  "name": "List.erase_cons"},
 {"type":
  "∀ {α : Sort u_1} {s : Setoid α} {a b : α}, a ≈ b → Quot.mk HasEquiv.Equiv a = Quot.mk HasEquiv.Equiv b",
  "offspring": ["Quot.sound"],
  "name": "Quotient.sound.proof_1"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HXor"},
 {"type": "Hashable ℤ",
  "offspring": ["Hashable.mk", "UInt64.ofNat"],
  "name": "instHashableInt"},
 {"type": "∀ {α : Type u} [inst : Preorder α] (a : α), ¬a < a",
  "offspring": ["le_not_le_of_lt"],
  "name": "lt_irrefl"},
 {"type":
  "∀ {α : Type u_1} [inst : Mul α] (l r tl tr t : α), l = tl → r = tr → tl * tr = t → l * r = t",
  "offspring": [],
  "name": "Tactic.Ring.subst_into_mul"},
 {"type": "∀ {a : ℤ}, -a < 0 → 0 < a",
  "offspring": ["Int.lt_of_neg_lt_neg", "Int.neg_zero"],
  "name": "Int.pos_of_neg_neg"},
 {"type": "{ε σ : Type u} → EStateM ε σ σ",
  "offspring": ["EStateM.Result.ok"],
  "name": "EStateM.get"},
 {"type":
  "∀ {α : Sort u_2} {r : α → α → Prop} {motive : Quot r → Sort u_1} (f : (a : α) → motive (Quot.mk r a)),\n  (∀ (a b : α), r a b → HEq (f a) (f b)) → ∀ (a b : α), r a b → (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b",
  "offspring": [],
  "name": "Quot.hrecOn.proof_1"},
 {"type": "∀ {a n m : ℕ}, Nat.coprime m n → m ∣ a → n ∣ a → m * n ∣ a",
  "offspring":
  ["Nat.mul_dvd_mul_left",
   "Nat.coprime.dvd_of_dvd_mul_left",
   "Nat.coprime.symm"],
  "name": "Nat.coprime.mul_dvd_of_dvd_of_dvd"},
 {"type":
  "∀ {ε σ α : Type u} [inst : SizeOf ε] [inst_1 : SizeOf σ] [inst_2 : SizeOf α] (a : ε) (a_1 : σ),\n  sizeOf (EStateM.Result.error a a_1) = 1 + sizeOf a + sizeOf a_1",
  "offspring": [],
  "name": "EStateM.Result.error.sizeOf_spec"},
 {"type": "SizeOf Lean.Name",
  "offspring": ["SizeOf.mk"],
  "name": "instSizeOfName"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} [inst : SizeOf α] [inst_1 : SizeOf β] (toFun : α → β) (invFun : β → α)\n  (left_inv : Function.LeftInverse invFun toFun) (right_inv : Function.RightInverse invFun toFun),\n  sizeOf { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv } = 1",
  "offspring": [],
  "name": "Equiv.mk.sizeOf_spec"},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Monad m] → (ℕ → α → m α) → ℕ → α → m α",
  "offspring": [],
  "name": "Nat.foldRevM.loop"},
 {"type": "Random Bool",
  "offspring": ["Random.mk", "Random.randBool"],
  "name": "Random.instRandomBool"},
 {"type": "True", "offspring": ["True.intro"], "name": "trivial"},
 {"type": "{α : Type u} → Array α → ℕ → (α → α) → Array α",
  "offspring": ["Id.run", "Array.modifyM", "Id.instMonadId"],
  "name": "Array.modify"},
 {"type": "Type", "offspring": [], "name": "Mathlib.Tactic.Sat.LClause"},
 {"type": "{n : ℕ} → OfNat UInt64 n",
  "offspring": ["OfNat.mk", "UInt64.ofNat"],
  "name": "instOfNatUInt64"},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → List α → ℕ → α",
  "offspring": ["panicWithPosWithDecl"],
  "name": "List.get!"},
 {"type": "∀ {a b c d : ℤ}, a ≤ b → c ≤ d → a - d ≤ b - c",
  "offspring": ["Int.add_le_add", "Int.neg_le_neg"],
  "name": "Int.sub_le_sub"},
 {"type": "Nat.Linear.Expr → Nat.Linear.Poly → Nat.Linear.Expr",
  "offspring": ["Nat.Linear.Var", "Nat.Linear.monomialToExpr"],
  "name": "Nat.Linear.Poly.toExpr.go"},
 {"type":
  "{α : Type u} → (p : α → Prop) → [inst : DecidablePred p] → List α → List α",
  "offspring": [],
  "name": "List.after"},
 {"type": "∀ {α : Sort u_1} (a b : α), (a ≠ b) = ¬a = b",
  "offspring": [],
  "name": "ne_eq"},
 {"type": "Type u → Type u", "offspring": [], "name": "List"},
 {"type": "Type",
  "offspring": ["List", "Prod", "Nat.Linear.ExprCnstr"],
  "name": "Nat.Linear.Certificate"},
 {"type": "Mathlib.Tactic.Sat.Clause → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Clause.proof"},
 {"type": "{m : Type u → Type v} → {α : Type u} → m (Option α) → OptionT m α",
  "offspring": [],
  "name": "OptionT.mk"},
 {"type": "ℕ → PNonScalar", "offspring": [], "name": "PNonScalar.mk"},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_3} → ForIn' m (List α) α inferInstance",
  "offspring": ["ForIn'.mk", "List.forIn'"],
  "name": "List.instForIn'ListInferInstanceMembershipInstMembershipList"},
 {"type":
  "∀ {α : Type u_1} (a : α) (x : Option α), (HOrElse.hOrElse (some a) fun x_1 => x) = some a",
  "offspring": [],
  "name": "Option.some_orelse"},
 {"type":
  "{f : Type u → Type v} → ({α β : Type u} → f α → (Unit → f β) → f α) → SeqLeft f",
  "offspring": [],
  "name": "SeqLeft.mk"},
 {"type": "∀ (n m : ℕ), Nat.succ n + m = Nat.succ (n + m)",
  "offspring": [],
  "name": "Nat.succ_add"},
 {"type": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "offspring": ["OfNat.mk", "One.one"],
  "name": "instOfNat_1"},
 {"type": "∀ (n : ℕ), n - 0 = n", "offspring": [], "name": "Nat.sub_zero"},
 {"type": "Float → Float → Float", "offspring": [], "name": "Float.mul"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) {i : Fin (Array.size a)} {j : ℕ} (v : α),\n  ↑i ≠ j → Array.get? (Array.set a i v) j = Array.get? a j",
  "offspring": ["Array.get?_eq_get?", "List.get?_set_ne", "List.get?"],
  "name": "Array.get?_set_ne"},
 {"type": "{α : Type u} → Sort u_1 → ToBool α → ToBool α → Sort u_1",
  "offspring": [],
  "name": "ToBool.noConfusionType"},
 {"type":
  "Lean.Name → optParam Lean.AttributeKind Lean.AttributeKind.global → optParam ℕ 1000 → Lean.MetaM Unit",
  "offspring":
  ["Tactic.NormCast.pushCastExt",
   "Tactic.NormCast.NormCastExtension.squash",
   "Tactic.NormCast.normCastExt",
   "Tactic.NormCast.NormCastExtension.down"],
  "name": "Tactic.NormCast.addSquash"},
 {"type": "{n : ℕ} → Neg (Fin n)",
  "offspring": ["Neg.mk", "instNegFin.proof_1"],
  "name": "instNegFin"},
 {"type": "∀ (m n : ℕ), Nat.gcd (n * m) n = n",
  "offspring": ["Nat.gcd", "Nat.gcd_mul_left_left"],
  "name": "Nat.gcd_mul_right_left"},
 {"type": "∀ {k m n : ℕ}, k ∣ m → (k ∣ n ↔ k ∣ m + n)",
  "offspring":
  ["Nat.dvd_add",
   "Exists.elim",
   "Nat.mul_sub_left_distrib",
   "Nat.add_sub_cancel_left"],
  "name": "Nat.dvd_add_iff_right"},
 {"type": "{α : Type} → Lean.Expr → Tactic.Ring.RingM α → Lean.MetaM α",
  "offspring":
  ["StateRefT'.run'",
   "Tactic.Ring.State",
   "Tactic.Ring.Cache.mk",
   "Tactic.Ring.State.mk"],
  "name": "Tactic.Ring.RingM.run"},
 {"type":
  "{G : Type u} → Sort u_1 → DivInvMonoid G → DivInvMonoid G → Sort u_1",
  "offspring": [],
  "name": "DivInvMonoid.noConfusionType"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.isPrefix"},
 {"type": "∀ {a : Prop} (b : Prop), ¬a → ¬(a ∧ b)",
  "offspring": ["mt"],
  "name": "not_and_of_not_left"},
 {"type":
  "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), a ≠ 0 → a * a⁻¹ = 1",
  "offspring": [],
  "name": "GroupWithZero.mul_inv_cancel"},
 {"type": "∀ (n m k : ℕ), n + (m + k) = m + (n + k)",
  "offspring": ["Nat.add_assoc"],
  "name": "Nat.add_left_comm"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.TermUnsafe.termUnsafe_"},
 {"type":
  "∀ (n : ℕ) (a : UInt64),\n  { val := AddMonoid.nsmul (Nat.succ n) a.val } = { val := (a + (fun n a => { val := AddMonoid.nsmul n a.val }) n a).1 }",
  "offspring": ["AddMonoid.nsmul_succ'"],
  "name": "UInt64.instSemiringUInt64.proof_5"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) {p : Nat.Linear.Poly}, Nat.Linear.Poly.isZero p = true → Nat.Linear.Poly.denote ctx p = 0",
  "offspring": ["Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.of_isZero"},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → {motive : Quot r → Sort v} → ((a : α) → motive (Quot.mk r a)) → α → PSigma motive",
  "offspring": ["Quot.mk"],
  "name": "Quot.indep"},
 {"type":
  "Lean.Meta.SimpTheorems → Lean.Expr → Lean.Meta.SimpM Lean.Meta.Simp.Step",
  "offspring": ["Tactic.NormCast.prove", "Tactic.NormCast.splittingProcedure"],
  "name": "Tactic.NormCast.upwardAndElim"},
 {"type": "∀ (a : UInt32), a * 1 = a",
  "offspring":
  ["UInt32.one_def",
   "UInt32.mul_def",
   "UInt32.mk",
   "mul_one",
   "UInt32.mk_val_eq"],
  "name": "UInt32.instSemiringUInt32.proof_14"},
 {"type": "∀ {a b : ℕ}, ¬a < b → b ≤ a",
  "offspring": ["not_lt", "Nat.instLinearOrderNat"],
  "name": "Nat.lt_ge_by_cases.proof_1"},
 {"type": "{α : Sort u} → (α → ℕ) → SizeOf α",
  "offspring": [],
  "name": "SizeOf.mk"},
 {"type": "∀ {a b : ℤ}, a < 0 → 0 < b → a * b < 0",
  "offspring": [],
  "name": "Int.mul_neg_of_neg_of_pos"},
 {"type":
  "{α : Type u} → {m : Type → Type w} → [inst : Monad m] → (α → m Bool) → Array α → USize → USize → m Bool",
  "offspring": ["Array.uget", "lcProof", "Array.anyMUnsafe.any"],
  "name": "Array.anyMUnsafe.any"},
 {"type": "{α : Type u} → {β : Type v} → (α → β → β) → β → List α → β",
  "offspring": [],
  "name": "List.foldr"},
 {"type": "0 < USize.size",
  "offspring": ["usize_size_eq"],
  "name": "instInhabitedUSize.proof_1"},
 {"type": "{α : Type u} → (α → Type v) → Type (max u v)",
  "offspring": [],
  "name": "Sigma"},
 {"type": "{α : Sort u} → {β : Sort v} → PProd α β → β",
  "offspring": [],
  "name": "PProd.snd"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {a : α} {l : List α}, (∃ x, x ∈ l ∧ p x) → ∃ x, x ∈ a :: l ∧ p x",
  "offspring": ["List.Mem.tail"],
  "name": "List.exists_mem_cons_of_exists"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} (a : α), ¬p a → ¬∀ (a_1 : α), a_1 ∈ some a → p a_1",
  "offspring": ["mt"],
  "name": "Option.decidable_forall_mem.proof_3"},
 {"type": "∀ (a b : ℕ), Nat.succ a * Nat.succ b = a * b + a + b + 1",
  "offspring": ["Nat.mul_succ", "Nat.succ_mul", "Nat.add_right_comm"],
  "name": "Nat.succ_mul_succ_eq"},
 {"type": "{α : Type} → Array α → (α → Bool) → Option α",
  "offspring": ["Id.run", "Array.findM?", "Id.instMonadId"],
  "name": "Array.find?"},
 {"type": "Repr String.Iterator",
  "offspring": ["reprArg", "instReprString", "instReprNat"],
  "name": "instReprIterator"},
 {"type":
  "∀ {α : Sort u} {f : α → α}, Function.involutive f → Function.LeftInverse f f",
  "offspring": [],
  "name": "Function.involutive.LeftInverse"},
 {"type":
  "{α : Sort u} → {β : outParam (Sort v)} → Sort u_1 → CoeSort α β → CoeSort α β → Sort u_1",
  "offspring": [],
  "name": "CoeSort.noConfusionType"},
 {"type": "∀ {α : Type u_1} {p q : List α}, p ++ q = [] ↔ p = [] ∧ q = []",
  "offspring":
  ["List.nil_append", "true_and", "List.cons_append", "eq_false'", "false_and"],
  "name": "List.append_eq_nil"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → [inst : Monad m] → MonadLift m (ExceptT ε m)",
  "offspring": ["MonadLift.mk", "ExceptT.lift"],
  "name": "ExceptT.instMonadLiftExceptT"},
 {"type": "Type u → Type v → Type (max u v)", "offspring": [], "name": "Prod"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (β → α → m β) → β → Subarray α → m β",
  "offspring":
  ["Array.foldlM", "Subarray.as", "Subarray.start", "Subarray.stop"],
  "name": "Subarray.foldlM"},
 {"type": "∀ {a b : Prop}, a ∨ a ∨ b ↔ a ∨ b",
  "offspring": ["Or.elim"],
  "name": "or_self_left"},
 {"type": "Mathlib.Tactic.Sat.Clause → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Clause.expr"},
 {"type": "∀ {a : Prop} [inst : Decidable a], ¬¬a ↔ a",
  "offspring": ["Decidable.by_contradiction", "not_not_intro"],
  "name": "Decidable.not_not"},
 {"type":
  "∀ {α : Sort u} {s : Setoid α} (q : Quotient s), ∃ a, Quotient.mk s a = q",
  "offspring": ["Quot.exists_rep"],
  "name": "Quotient.exists_rep"},
 {"type":
  "{α : Type} → String → α → (Lean.Name → Lean.ConstantInfo → α → Lean.MetaM α) → IO (Tactic.DeclCache α)",
  "offspring": ["Tactic.Cache.mk", "ForIn.forIn", "ForInStep"],
  "name": "Tactic.DeclCache.mk"},
 {"type":
  "{α : Type u} → [self : LinearOrder α] → DecidableRel fun a a_1 => a < a_1",
  "offspring": [],
  "name": "LinearOrder.decidable_lt"},
 {"type":
  "∀ (n m : Fin USize.size), ¬n = m → { val := n } = { val := m } → False",
  "offspring": [],
  "name": "USize.decEq.proof_2"},
 {"type": "{α : Type u} → α → List α → List α",
  "offspring": [],
  "name": "List.cons"},
 {"type":
  "∀ (p q : Prop) [d₁ : Decidable p] [d₂ : Decidable q], ¬(p ∨ q) ↔ ¬p ∧ ¬q",
  "offspring": ["Or.elim"],
  "name": "Decidable.not_or_iff_and_not"},
 {"type": "Nat.zero = 0", "offspring": [], "name": "Nat.zero_eq"},
 {"type": "∀ (m : ℕ), Nat.lcm m 0 = 0",
  "offspring": ["Nat.lcm_zero_left", "Nat.lcm_comm"],
  "name": "Nat.lcm_zero_right"},
 {"type": "Task.Priority", "offspring": [], "name": "Task.Priority.dedicated"},
 {"type": "ℕ → USize",
  "offspring": ["USize.mk", "Fin.ofNat'", "USize.size", "usize_size_gt_zero"],
  "name": "USize.ofNat"},
 {"type": "ToString PUnit",
  "offspring": ["ToString.mk"],
  "name": "instToStringPUnit"},
 {"type": "∀ (a b c : ℤ), a + (b + c) = b + (a + c)",
  "offspring": ["Int.add_assoc", "Int.add_comm"],
  "name": "Int.add_left_comm"},
 {"type": "Nat.Linear.ExprCnstr → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.rhs"},
 {"type": "ReprAtom UInt32",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomUInt32"},
 {"type": "∀ (a b : UInt32), a * b = { val := a.val * b.val }",
  "offspring": [],
  "name": "UInt32.mul_def"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "commandSudoSet_option___"},
 {"type": "{α : Sort u} → [self : WellFoundedRelation α] → α → α → Prop",
  "offspring": [],
  "name": "WellFoundedRelation.rel"},
 {"type": "Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["Nat.Linear.Poly.fuse", "Nat.Linear.Poly.sort"],
  "name": "Nat.Linear.Poly.norm"},
 {"type":
  "∀ {α : Type u_1} {x : Option (Option α)} {a : α}, Option.join x = some a ↔ x = some (some a)",
  "offspring": ["Option.bind_eq_some", "id_eq", "exists_eq_right"],
  "name": "Option.join_eq_some"},
 {"type": "Float → Float", "offspring": [], "name": "Float.asinh"},
 {"type":
  "∀ {α : Sort u} {f : α → α}, Function.involutive f → ∀ {x y : α}, f x = y ↔ x = f y",
  "offspring": ["Function.injective.eq_iff'", "Function.involutive.injective"],
  "name": "Function.involutive.eq_iff"},
 {"type": "Sort u → NonScalar → NonScalar → Sort u",
  "offspring": [],
  "name": "NonScalar.noConfusionType"},
 {"type":
  "{m : Type → Type u} → [inst : Monad m] → {α : Type v} → (α → m Bool) → List α → m Bool",
  "offspring": [],
  "name": "List.anyM"},
 {"type": "ℕ → String", "offspring": ["Nat.digitChar"], "name": "hexDigitRepr"},
 {"type": "∀ {n m k : ℕ}, n < m → m ≤ k → n < k",
  "offspring": ["Nat.le_trans"],
  "name": "Nat.lt_of_lt_of_le"},
 {"type":
  "∀ {A : Type u} [inst : AddSemigroup A] [inst_1 : IsAddLeftCancel A] {a b c : A}, a + b = a + c → b = c",
  "offspring": ["IsAddLeftCancel.add_left_cancel"],
  "name": "add_left_cancel"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} → [inst : Monad m] → Array α → (α → β → m (ForInStep β)) → USize → USize → β → m β",
  "offspring":
  ["instLTUSize", "Array.forInUnsafe.loop", "Array.uget", "lcProof"],
  "name": "Array.forInUnsafe.loop"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk", "Fin.land", "UInt64.size"],
  "name": "UInt64.land"},
 {"type":
  "{ε σ δ : Type u} → [inst : EStateM.Backtrackable δ σ] → MonadExceptOf ε (EStateM ε σ)",
  "offspring": ["MonadExceptOf.mk", "EStateM.throw", "EStateM.tryCatch"],
  "name": "EStateM.instMonadExceptOfEStateM"},
 {"type": "{α : Type u_1} → Array (UFNode α) → {n : ℕ} → UFModel n → Prop",
  "offspring":
  ["UFModel.Agrees",
   "UFNode.parent",
   "UFModel.parent",
   "UFNode.rank",
   "UFModel.rank"],
  "name": "UFModel.Models"},
 {"type": "(a b : UInt16) → Decidable (a ≤ b)",
  "offspring": ["UInt16.decLe"],
  "name": "instDecidableLeUInt16InstLEUInt16"},
 {"type": "false = true → False", "offspring": [], "name": "Bool.ff_ne_tt"},
 {"type": "∀ {n m : ℕ}, Nat.succ n = Nat.succ m ↔ n = m",
  "offspring": ["Nat.succ.inj", "congr_arg"],
  "name": "Nat.succ_inj'"},
 {"type": "1 = { val := 1 }", "offspring": [], "name": "UInt8.one_def"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {g : α → List β} {f : β → γ} (l : List α),\n  List.map f (List.bind l g) = List.bind l fun a => List.map f (g a)",
  "offspring": ["List.cons_bind", "List.map_append"],
  "name": "List.bind_map"},
 {"type":
  "{α : Type} → [inst : Inhabited α] → Array α → (α → α → Bool) → ℕ → ℕ → ℕ × Array α",
  "offspring": ["Array.get!", "Array.swap!", "HDiv.hDiv"],
  "name": "Array.qpartition"},
 {"type": "{f : Type u → Type v} → Sort u_1 → Pure f → Pure f → Sort u_1",
  "offspring": [],
  "name": "Pure.noConfusionType"},
 {"type": "∀ {M : Type u} [self : MulOneClass M] (a : M), a * 1 = a",
  "offspring": [],
  "name": "MulOneClass.mul_one"},
 {"type": "∀ (k n m : ℕ), n + k ≤ m + k ↔ n ≤ m",
  "offspring": ["Nat.le_of_add_le_add_right", "Nat.add_le_add_right"],
  "name": "Nat.add_le_add_iff_le_right"},
 {"type":
  "∀ {α β σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf β] [inst_2 : SizeOf σ] (a : σ),\n  sizeOf (DoResultPRBC.continue a) = 1 + sizeOf a",
  "offspring": [],
  "name": "DoResultPRBC.continue.sizeOf_spec"},
 {"type": "Float → Float → Float", "offspring": [], "name": "Float.sub"},
 {"type":
  "∀ {α : Sort u}, Nonempty α → ∀ (p : α → Prop), (∃ y, p y) → p (Classical.epsilon p)",
  "offspring": ["Subtype.property"],
  "name": "Classical.epsilon_spec_aux"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a b : β), a = b → Sum.inr a = Sum.inr b",
  "offspring": [],
  "name": "instDecidableEqSum.proof_3"},
 {"type": "∀ {n m : ℕ}, n + m = 0 → n = 0 ∧ m = 0",
  "offspring":
  ["Nat.eq_zero_of_add_eq_zero_right", "Nat.eq_zero_of_add_eq_zero_left"],
  "name": "Nat.eq_zero_of_add_eq_zero"},
 {"type":
  "∀ {R : Type u} [self : Ring R] (n : ℕ), Ring.intCast (Int.ofNat n) = NonUnitalNonAssocSemiring.natCast n",
  "offspring": [],
  "name": "Ring.intCast_ofNat"},
 {"type": "∀ {p : Prop} [h : Decidable p], (decide ¬p) = !decide p",
  "offspring": [],
  "name": "decide_not"},
 {"type": "∀ {k m n : ℕ}, k < m → k < n → m - n < m - k",
  "offspring":
  ["Nat.add_sub_add_right",
   "Nat.lt_succ_of_le",
   "Nat.sub_le",
   "Nat.lt_of_succ_lt_succ"],
  "name": "Nat.sub_lt_sub_left"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x y : Fin (UnionFind.size self)),\n  (Array.get self.arr y).rank < (Array.get self.arr x).rank →\n    ∃ n m,\n      UFModel.Models\n        (Array.set self.arr y\n          { parent := ↑x, value := (Array.get self.arr y).value, rank := (Array.get self.arr y).rank })\n        m",
  "offspring":
  ["UnionFind.arr",
   "UFModel.setParent",
   "UFModel.Models.rank_eq",
   "UFModel.Models.setParent",
   "UFNode.mk",
   "UFNode.value",
   "Array.get",
   "UFNode.rank",
   "UnionFind.model'"],
  "name": "UnionFind.link.proof_1"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → MonadExceptOf Unit (OptionT m)",
  "offspring": ["MonadExceptOf.mk", "OptionT.fail", "OptionT.tryCatch"],
  "name": "OptionT.instMonadExceptOfUnitOptionT"},
 {"type": "{α : Type u} → {β : Type v} → (α → Option β) → List α → List β",
  "offspring": [],
  "name": "List.filterMap"},
 {"type": "∀ (n : ℕ) (x : ℤ), Int.ofNat (Nat.succ n) * x = x + Int.ofNat n * x",
  "offspring": [],
  "name": "Int.instCommRingInt.proof_1"},
 {"type": "ByteArray → ℕ → ℕ → ByteArray",
  "offspring": ["ByteArray.copySlice", "ByteArray.empty"],
  "name": "ByteArray.extract"},
 {"type": "ByteArray → ℕ → UInt8",
  "offspring": ["ByteArray.get!"],
  "name": "ByteArray.getOp"},
 {"type": "ℕ → Mathlib.Tactic.Lint.LintVerbosity",
  "offspring":
  ["cond",
   "Nat.ble",
   "Nat.beq",
   "Mathlib.Tactic.Lint.LintVerbosity.medium",
   "Mathlib.Tactic.Lint.LintVerbosity.high",
   "Mathlib.Tactic.Lint.LintVerbosity.low"],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.ofNat"},
 {"type": "Float → Float", "offspring": [], "name": "Float.log"},
 {"type": "∀ {α : Type u_1} (l₁ l₂ : List α) (a : α), l₁ <+ l₂ → l₁ <+ a :: l₂",
  "offspring": [],
  "name": "List.sublist.cons"},
 {"type": "Lean.Expr → Lean.MetaM ℕ",
  "offspring": ["Tactic.NormCast.countCoes", "Tactic.NormCast.countHeadCoes"],
  "name": "Tactic.NormCast.countInternalCoes"},
 {"type": "{α : Type u} → {β : Type v} → (α → β → β) → Prop",
  "offspring": [],
  "name": "left_commutative"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} [inst : Subsingleton β], Function.injective Prod.fst",
  "offspring": ["Prod.ext'", "Subsingleton.elim"],
  "name": "Prod.fst_injective"},
 {"type": "∀ (a b : ℕ), a ∣ a * b",
  "offspring": [],
  "name": "Nat.dvd_mul_right"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (k : ℕ) (p : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.mul.go k p) = k * Nat.Linear.Poly.denote ctx p",
  "offspring": ["Nat.mul_assoc", "Nat.left_distrib"],
  "name": "Nat.Linear.Poly.mul.go_denote"},
 {"type": "ℕ → ℕ → Tactic.NormCast.CoeFnType → Tactic.NormCast.CoeFnInfo",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnInfo.mk"},
 {"type": "∀ (m n k : ℕ), Nat.lcm (Nat.lcm m n) k = Nat.lcm m (Nat.lcm n k)",
  "offspring":
  ["Nat.dvd_antisymm",
   "Nat.lcm_dvd",
   "Nat.dvd_lcm_left",
   "Nat.dvd_trans",
   "Nat.dvd_lcm_right"],
  "name": "Nat.lcm_assoc"},
 {"type": "ℕ → ℕ → ℕ", "offspring": [], "name": "Nat.min"},
 {"type": "∀ (n : ℕ), 0 - n = 0",
  "offspring": ["Nat.sub_succ", "Nat.pred"],
  "name": "Nat.zero_sub"},
 {"type": "∀ {m : ℕ} (u : USize), m > 0 → USize.toNat (u % m) < m",
  "offspring": ["Fin.modn_lt"],
  "name": "USize.modn_lt"},
 {"type":
  "{α : Type u_1} → (lt : α → α → Bool) → (BinaryHeap α fun y x => lt x y) → Array α → Array α",
  "offspring": ["WellFounded.fix", "BinaryHeap.max"],
  "name": "Array.heapSort.loop"},
 {"type":
  "∀ {α : Sort u} [h : DecidableEq α] {a b : α} (n : a ≠ b), h a b = isFalse n",
  "offspring": ["proof_irrel"],
  "name": "decidable_eq_inr_neg"},
 {"type": "∀ {a b c d : ℕ}, a < b → c < d → a + c < b + d",
  "offspring": ["Nat.lt_trans", "Nat.add_lt_add_right", "Nat.add_lt_add_left"],
  "name": "Nat.add_lt_add"},
 {"type": "(a b : USize) → Decidable (a ≤ b)",
  "offspring": [],
  "name": "USize.decLe"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] (a b c : α), max (max a b) c = max a (max b c)",
  "offspring": ["eq_max", "le_trans", "le_max_left", "max_le", "le_max_right"],
  "name": "max_assoc"},
 {"type": "∀ {A : Type u} [self : AddMonoid A] (a : A), 0 + a = a",
  "offspring": [],
  "name": "AddMonoid.zero_add"},
 {"type":
  "{α : Type u} → (σ : Type u) → {m : Type u → Type v} → [inst : MonadStateOf σ m] → (σ → α × σ) → m α",
  "offspring": ["MonadStateOf.modifyGet"],
  "name": "modifyGetThe"},
 {"type": "∀ (a a_1 : ℕ), (Int.ofNat a = Int.ofNat a_1) = (a = a_1)",
  "offspring": [],
  "name": "Int.ofNat.injEq"},
 {"type": "∀ {a b : Prop}, a ∧ b → b ∧ a", "offspring": [], "name": "and.swap"},
 {"type":
  "∀ {m n k : ℕ}, k ∣ m → k ∣ n → Nat.gcd (m / k) (n / k) = Nat.gcd m n / k",
  "offspring":
  ["Nat.eq_zero_or_pos",
   "Nat.div_zero",
   "Nat.gcd_zero_right",
   "Nat.eq_of_mul_eq_mul_right",
   "Nat.div_mul_cancel",
   "Nat.dvd_gcd",
   "Nat.gcd_mul_right"],
  "name": "Nat.gcd_div"},
 {"type": "{α : Sort u} → [self : SizeOf α] → α → ℕ",
  "offspring": [],
  "name": "SizeOf.sizeOf"},
 {"type": "{α : Type u_1} → {β : Type u_2} → Array α → Array β → Array (α × β)",
  "offspring": ["Array.zipWith"],
  "name": "Array.zip"},
 {"type": "∀ {n m k : ℕ}, n < m → m < k → n < k",
  "offspring": ["Nat.le_trans", "Nat.le_step"],
  "name": "Nat.lt_trans"},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : DecidableEq α] → [inst : DecidableEq β] → DecidableEq (α ⊕ β)",
  "offspring":
  ["instDecidableEqSum.proof_1",
   "instDecidableEqSum.proof_2",
   "instDecidableEqSum.proof_3",
   "instDecidableEqSum.proof_4",
   "instDecidableEqSum.proof_5",
   "instDecidableEqSum.proof_6"],
  "name": "instDecidableEqSum"},
 {"type":
  "{α : Sort u} → {a : α} → {β : Sort v} → Sort u_1 → CoeT α a β → CoeT α a β → Sort u_1",
  "offspring": [],
  "name": "CoeT.noConfusionType"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["Array.append"],
  "name": "unexpandListToArray"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Prelude.Rename.align"},
 {"type":
  "∀ {α : Sort u_3} {β : Sort u_2} {γ : Sort u_1} {f : α → β} {g : γ → α},\n  Function.injective (f ∘ g) → Function.injective g",
  "offspring": [],
  "name": "Function.injective.of_comp"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.Find.tacticFind"},
 {"type":
  "∀ (x : ℕ) (a : UInt64),\n  { val := Ring.gsmul -[1+ x] a.val } =\n    { val := (-(fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat (Nat.succ x)) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_neg'"],
  "name": "UInt64.instRingUInt64.proof_5"},
 {"type": "USize → UInt64", "offspring": [], "name": "USize.toUInt64"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["Nat.bitwise", "bne"], "name": "Nat.xor"},
 {"type": "Type u → Type u", "offspring": [], "name": "EmptyCollection"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (i : ℕ), i + 1 ≤ Array.size as → i ≤ Array.size as",
  "offspring": ["Nat.le_of_lt", "Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "Array.findSomeRevM?.find.proof_2"},
 {"type": "∀ {a b : Prop}, (¬a ↔ b) ↔ (¬b ↔ a)",
  "offspring": ["Decidable.not_iff_comm"],
  "name": "not_iff_comm"},
 {"type": "{α : Sort u} → (r : α → α → Prop) → Equivalence r → Setoid α",
  "offspring": [],
  "name": "Setoid.mk"},
 {"type": "Functor Set",
  "offspring": ["Functor.mk", "Set.image"],
  "name": "Set.instFunctorSet"},
 {"type": "∀ {a b c : Prop}, (a → (b ↔ c)) → (a → b ↔ a → c)",
  "offspring": [],
  "name": "imp_congr_right"},
 {"type": "∀ {M : Type u} [self : MulOneClass M] (a : M), 1 * a = a",
  "offspring": [],
  "name": "MulOneClass.one_mul"},
 {"type": "∀ {α : Type u_1} (as : Array α), Array.size as ≤ Array.size as",
  "offspring": ["Nat.le_refl"],
  "name": "Array.foldlM.proof_1"},
 {"type":
  "{α : Type u} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (α → m PUnit) → (as : Array α) → optParam ℕ (Array.size as) → optParam ℕ 0 → m PUnit",
  "offspring": ["Array.foldrM"],
  "name": "Array.forRevM"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a < b → min a b = a",
  "offspring": ["min_eq_left", "le_of_lt"],
  "name": "min_eq_left_of_lt"},
 {"type": "ℤ → ℤ → ℕ",
  "offspring": ["Nat.gcd", "Int.natAbs"],
  "name": "Int.gcd"},
 {"type": "{n : ℕ} → Mul (Fin n)",
  "offspring": ["Mul.mk", "Fin.mul"],
  "name": "Fin.instMulFin"},
 {"type": "{α : Type u_1} → List α → α → α",
  "offspring": [],
  "name": "List.headD"},
 {"type": "{α : Type u_1} → List α → Array α",
  "offspring": ["List.toArrayAux", "Array.mkEmpty", "List.redLength"],
  "name": "List.toArray"},
 {"type": "∀ {n : ℕ} (a : Fin n), sizeOf a = ↑a + 1",
  "offspring":
  ["Fin.mk.sizeOf_spec",
   "sizeOf_nat",
   "sizeOf_default",
   "Nat.add_zero",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var"],
  "name": "Fin.sizeOf"},
 {"type": "{a : Type u_1} → [inst : Inhabited a] → Inhabited (ForInStep a)",
  "offspring": ["ForInStep.done", "Inhabited.default"],
  "name": "instInhabitedForInStep"},
 {"type": "System.SearchPath → String",
  "offspring":
  ["System.SearchPath.separator",
   "List.map",
   "System.FilePath",
   "System.FilePath.toString"],
  "name": "System.SearchPath.toString"},
 {"type": "∀ {a b : UInt32}, a.val = b.val → a = b",
  "offspring": ["UInt32.mk"],
  "name": "UInt32.eq_of_val_eq"},
 {"type": "∀ {α : Sort u_1}, ¬Nonempty α → Subsingleton α",
  "offspring": ["Subsingleton.intro", "not_nonempty_iff_imp_false"],
  "name": "subsingleton_of_not_nonempty"},
 {"type": "∀ (n : ℕ), Nat.gcd n 0 = n",
  "offspring": ["Nat.gcd_succ", "Nat.gcd", "Nat.zero_mod", "Nat.gcd_zero_left"],
  "name": "Nat.gcd_zero_right"},
 {"type":
  "∀ {α : Type u} {β : Type v} {fst : α} {snd : β} {fst_1 : α} {snd_1 : β},\n  (fst, snd) = (fst_1, snd_1) → fst = fst_1 ∧ snd = snd_1",
  "offspring": [],
  "name": "Prod.mk.inj"},
 {"type":
  "{α₁ α₂ α₃ α₄ β : Type u} →\n  [inst : Inhabited β] → ((α₁ → α₂ → α₃ → α₄ → β) → α₁ → α₂ → α₃ → α₄ → β) → α₁ → α₂ → α₃ → α₄ → β",
  "offspring": ["fixCore4", "Inhabited.default"],
  "name": "fix4"},
 {"type": "∀ (n m : ℕ), n - Nat.succ m = Nat.pred (n - m)",
  "offspring": [],
  "name": "Nat.sub_succ"},
 {"type": "{α : Type u_1} → Option α → α → α",
  "offspring": [],
  "name": "Option.getD"},
 {"type":
  "{ω σ : Type} → {m : Type → Type} → [inst : Monad m] → [inst : MonadLiftT (ST ω) m] → σ → StateRefT' ω σ m PUnit",
  "offspring": [],
  "name": "StateRefT'.set"},
 {"type": "String → String → Lean.Name → Lean.MetaM Unit",
  "offspring":
  ["Mathlib.Tactic.Sat.fromLRATAux", "Mathlib.Tactic.Sat.buildReify"],
  "name": "Mathlib.Tactic.Sat.fromLRAT"},
 {"type":
  "{m : Type u_1 → Type u_2} → {ρ : Type u_1} → MonadControl m (ReaderT ρ m)",
  "offspring": ["MonadControl.mk"],
  "name": "instMonadControlReaderT"},
 {"type":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : outParam (Type v)} → {d : outParam (Membership α ρ)} → Sort u_1 → ForIn' m ρ α d → ForIn' m ρ α d → Sort u_1",
  "offspring": [],
  "name": "ForIn'.noConfusionType"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {s : Set α} {a : α},\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → f x = f y → x = y) → a ∈ s → Function.inv_fun_on f s (f a) = a",
  "offspring": [],
  "name": "Function.inv_fun_on_eq'"},
 {"type": "Sort u → StdGen → StdGen → Sort u",
  "offspring": [],
  "name": "StdGen.noConfusionType"},
 {"type": "{α : Type u} → (α → α → α) → Div α",
  "offspring": [],
  "name": "Div.mk"},
 {"type": "{α : Type u} → [self : NonUnitalSemiring α] → SemigroupWithZero α",
  "offspring":
  ["SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero"},
 {"type": "HPow ℤ ℕ ℤ",
  "offspring": ["HPow.mk", "Int.pow"],
  "name": "Int.instHPowIntNat"},
 {"type": "∀ {α : Type u}, Subsingleton (Squash α)",
  "offspring": ["instSubsingletonSquash.proof_1"],
  "name": "instSubsingletonSquash"},
 {"type":
  "{ρ : Type u_1} →\n  {α : Type u_2} → {γ : Type u_3} → {β : Type u_4} → [inst : Stream ρ α] → [inst : Stream γ β] → Stream (ρ × γ) (α × β)",
  "offspring": ["Stream.mk", "Option", "Stream.next?"],
  "name": "instStreamProdProd"},
 {"type": "{α : Type u} → [self : ShiftLeft α] → α → α → α",
  "offspring": [],
  "name": "ShiftLeft.shiftLeft"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {arr : Array α} {f : α → β}, UFModel.Agrees arr f fun i => f (Array.get arr i)",
  "offspring": [],
  "name": "UFModel.Agrees.mk"},
 {"type": "∀ (a b c : USize), a * (b + c) = a * b + a * c",
  "offspring":
  ["USize.add_def",
   "USize.mul_def",
   "USize.mk",
   "USize.eq_of_val_eq",
   "Distrib.left_distrib"],
  "name": "USize.instSemiringUSize.proof_7"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b",
  "offspring": ["PartialOrder.le_antisymm"],
  "name": "le_antisymm"},
 {"type": "ℕ → ℕ → ℕ → List Char → List Char",
  "offspring": ["HDiv.hDiv", "Nat.digitChar"],
  "name": "Nat.toDigitsCore"},
 {"type": "∀ (b : Bool), (¬b = false) = (b = true)",
  "offspring": [],
  "name": "Bool.not_eq_false"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (k : ℕ) (p : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.mul k p) = k * Nat.Linear.Poly.denote ctx p",
  "offspring":
  ["cond_true",
   "eq_of_beq",
   "Nat.instLawfulBEqNatInstBEqNat",
   "Nat.zero_mul",
   "Bool.of_not_eq_true",
   "cond_false",
   "Nat.one_mul",
   "Nat.mul_zero",
   "Nat.mul_assoc",
   "Nat.left_distrib"],
  "name": "Nat.Linear.Poly.denote_mul"},
 {"type": "∀ {n m : ℕ}, n < m → ¬m < n",
  "offspring": ["Nat.le_lt_antisymm", "Nat.le_of_lt"],
  "name": "Nat.lt_asymm"},
 {"type": "Type", "offspring": [], "name": "Tactic.NormCast.CoeFnType"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.Attr.normCastLabel"},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "offspring": [],
  "name": "MonadLift"},
 {"type": "∀ {a : Prop}, a ↔ a", "offspring": ["Iff.refl"], "name": "Iff.rfl"},
 {"type": "∀ (x x_1 : UInt8), { val := (x - x_1).1 } = { val := (x + -x_1).1 }",
  "offspring": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "UInt8.instRingUInt8.proof_1"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ∨ a > b",
  "offspring": ["le_or_lt"],
  "name": "le_or_gt"},
 {"type": "{α : Sort u} → (r : α → α → Prop) → α → Quot r",
  "offspring": [],
  "name": "Quot.mk"},
 {"type":
  "∀ {α : Type u_1} {l l₁ l₂ : List α}, List.disjoint (l₁ ++ l₂) l ↔ List.disjoint l₁ l ∧ List.disjoint l₂ l",
  "offspring": ["List.mem_append", "or_imp_distrib", "forall_and_distrib"],
  "name": "List.disjoint_append_left"},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → {motive : (a : α) → Acc r a → Prop} → {a : α} → Acc r a → Prop",
  "offspring": [],
  "name": "Acc.below"},
 {"type": "{n : ℕ} → Fin n → Fin (Nat.succ n)",
  "offspring": ["Nat.succ_lt_succ"],
  "name": "Fin.succ"},
 {"type": "{α : Type u} → List α", "offspring": [], "name": "List.nil"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : Fin (Array.size a)) (v : α), Array.get? (Array.set a i v) ↑i = some v",
  "offspring":
  ["Array.get?_eq_get?",
   "Array.mk",
   "List.set",
   "Array.data",
   "List.get?_set_of_lt",
   "Fin.isLt"],
  "name": "Array.get?_set_eq"},
 {"type": "∀ {n : ℕ} {i j : Fin n}, ¬↑i = ↑j → ¬i = j",
  "offspring": ["Fin.val_eq_of_eq"],
  "name": "Fin.ne_of_val_ne"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«stx_<|>_»"},
 {"type": "{α : Type u_1} → Array α → (α → α → Bool) → Array α",
  "offspring": [],
  "name": "Array.insertionSort"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α β : Type u} → (α → m (Option β)) → List α → m (List β)",
  "offspring": [],
  "name": "List.filterMapM"},
 {"type": "∀ {n m : ℕ}, n + m = 0 → n = 0",
  "offspring":
  ["Nat.zero_add",
   "implies_true",
   "Nat.succ_ne_zero",
   "Nat.succ_add",
   "Nat.add_one"],
  "name": "Nat.eq_zero_of_add_eq_zero_right"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HSub α β γ] → α → β → γ",
  "offspring": [],
  "name": "HSub.hSub"},
 {"type":
  "{α : Sort u} → {γ : α → Sort v} → [self : CoeFun α γ] → (a : α) → γ a",
  "offspring": [],
  "name": "CoeFun.coe"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term_×__1»"},
 {"type": "{α : Sort u} → {p : α → Prop} → CoeHead { x // p x } α",
  "offspring": ["CoeHead.mk", "Subtype.val"],
  "name": "subtypeCoe"},
 {"type": "LawfulFunctor Option",
  "offspring": ["LawfulFunctor.mk"],
  "name": "instLawfulFunctorOptionInstFunctorOption.proof_1"},
 {"type": "∀ {n m : ℕ}, n ≤ m → ∀ (k : ℕ), n - k ≤ m - k",
  "offspring": ["Nat.pred_le_pred"],
  "name": "Nat.sub_le_sub_right"},
 {"type":
  "∀ (m n k : ℕ), -[1+ m] * Int.subNatNat n k = Int.subNatNat (Nat.succ m * k) (Nat.succ m * n)",
  "offspring": [],
  "name": "Int.negSucc_ofNat_mul_subNatNat"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, a ∈ l → List.length (List.insert a l) = List.length l",
  "offspring": ["List.insert_of_mem"],
  "name": "List.length_insert_of_mem"},
 {"type":
  "∀ {α : Sort u} {s : Setoid α} {a b : α}, a ≈ b → Quotient.mk s a = Quotient.mk s b",
  "offspring": ["Quotient.sound.proof_1"],
  "name": "Quotient.sound"},
 {"type": "∀ {n m : ℕ}, m < n → Nat.pred n < n",
  "offspring": ["Nat.pred_lt", "Nat.not_eq_zero_of_lt"],
  "name": "Nat.pred_lt'"},
 {"type": "∀ (p : Prop), (p ↔ p) = True",
  "offspring": ["trivial"],
  "name": "iff_self"},
 {"type": "Substring → String.Pos → ℕ → String.Pos",
  "offspring": ["Substring.prev"],
  "name": "Substring.prevn"},
 {"type": "∀ {a b : Prop}, ¬(a ∨ b) ↔ ¬a ∧ ¬b",
  "offspring": ["Or.elim"],
  "name": "not_or_distrib"},
 {"type": "∀ {α : Type u_1} (l : List α), l ⊆ l",
  "offspring": [],
  "name": "List.subset.refl"},
 {"type": "∀ {p : Prop}, p → ¬¬p", "offspring": [], "name": "not_not_intro"},
 {"type":
  "∀ {α : Sort u_1} {γ : Sort u_2} (r : α → γ → Prop) {a b : α} {c : γ}, a = b → r b c → r a c",
  "offspring": [],
  "name": "instTransEq.proof_1"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "offspring": ["Function.injective", "Function.surjective"],
  "name": "Function.bijective"},
 {"type": "{α : Type u} → Sort u_1 → Random α → Random α → Sort u_1",
  "offspring": [],
  "name": "Random.noConfusionType"},
 {"type": "∀ {n : ℕ} (a b c : Fin n), a ≤ b → b ≤ c → a ≤ c",
  "offspring": ["Nat.le_trans"],
  "name": "Fin.le_trans"},
 {"type":
  "{collection : Type u} → {stream : outParam (Type u)} → (collection → stream) → ToStream collection stream",
  "offspring": [],
  "name": "ToStream.mk"},
 {"type":
  "∀ {m : Type u → Type u_1} {α β ε : Type u} [inst : Monad m] (mf : ExceptT ε m (α → β)) (x : ExceptT ε m α),\n  (Seq.seq mf fun x_1 => x) = do\n    let f ← mf\n    f <$> x",
  "offspring": [],
  "name": "ExceptT.seq_eq"},
 {"type": "(P : Prop) → Hashable P",
  "offspring": ["Hashable.mk"],
  "name": "instHashable"},
 {"type":
  "{α : Sort u} → (p : α → Prop) → Nonempty α → { x // (∃ y, p y) → p x }",
  "offspring":
  ["Subtype.mk",
   "Classical.choice",
   "Classical.strongIndefiniteDescription.proof_2"],
  "name": "Classical.strongIndefiniteDescription"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "termPrintln!__"},
 {"type": "{α σ : Type u} → σ → DoResultSBC α σ",
  "offspring": [],
  "name": "DoResultSBC.break"},
 {"type": "FloatArray → Float → FloatArray",
  "offspring": ["FloatArray.mk", "Array.push", "Float"],
  "name": "FloatArray.push"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {p q : α → β → Prop},\n  (∀ (a : α) (b : β), p a b ↔ q a b) → ((∀ (a : α) (b : β), p a b) ↔ ∀ (a : α) (b : β), q a b)",
  "offspring": ["forall_congr'"],
  "name": "forall₂_congr"},
 {"type": "∀ (m n k : ℕ), Int.subNatNat (m + k) (n + k) = Int.subNatNat m n",
  "offspring":
  ["Int.subNatNat_elim",
   "Nat.add_assoc",
   "Int.subNatNat_add_left",
   "Int.subNatNat_add_right"],
  "name": "Int.subNatNat_add_add"},
 {"type": "∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a",
  "offspring": ["Preorder.le_refl"],
  "name": "le_refl"},
 {"type":
  "{P : ℕ → ℕ → Sort u} →\n  ((m : ℕ) → P 0 m) →\n    ((n : ℕ) → P (Nat.succ n) 0) → ((n m : ℕ) → P n m → P (Nat.succ n) (Nat.succ m)) → (n m : ℕ) → P n m",
  "offspring": [],
  "name": "Nat.sub_induction"},
 {"type": "{ε σ : Type} → STWorld σ (EST ε σ)",
  "offspring": ["STWorld.mk"],
  "name": "instSTWorldEST"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "offspring": [],
  "name": "Iff.elim_left.proof_1"},
 {"type": "∀ {α : Type u} (n : ℕ) (v : α), Array.size (mkArray n v) = n",
  "offspring": ["List.length_replicate"],
  "name": "Array.size_mkArray"},
 {"type": "{α : Type u} → Array α → Array α",
  "offspring": ["HDiv.hDiv"],
  "name": "Array.reverse"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → Option (m α) → m (Option α)",
  "offspring": ["Functor.map"],
  "name": "Option.maybe"},
 {"type":
  "∀ (α : Sort u) {β : α → Sort v} [inst : ∀ (a : α), Nonempty (β a)], Nonempty ((a : α) → β a)",
  "offspring": ["instNonemptyForAll_1.proof_1"],
  "name": "instNonemptyForAll_1"},
 {"type": "{ε α : Type} → [inst : Inhabited ε] → Inhabited (EIO ε α)",
  "offspring": [],
  "name": "instInhabitedEIO"},
 {"type": "ℕ → USize", "offspring": ["USize.ofNat"], "name": "Nat.toUSize"},
 {"type": "Char", "offspring": [], "name": "System.FilePath.extSeparator"},
 {"type":
  "∀ {α β : Sort u} [h₁ : Subsingleton α], α = β → ∀ (a : α) (b : β), HEq a b",
  "offspring": ["Subsingleton.helim.proof_1"],
  "name": "Subsingleton.helim"},
 {"type": "∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ ~ l₂ → l₂ ~ l₁",
  "offspring":
  ["List.Perm.nil", "List.Perm.cons", "List.Perm.swap", "List.Perm.trans"],
  "name": "List.Perm.symm"},
 {"type": "{α : Sort u} → (a : α) → CoeT α a α",
  "offspring": ["CoeT.mk"],
  "name": "coeId"},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "offspring": ["Mathlib.Tactic.Sat.buildReify.v", "panicWithPosWithDecl"],
  "name": "Mathlib.Tactic.Sat.buildReify.reifyLiteral"},
 {"type": "Lean.Environment → Mathlib.Prelude.Rename.RenameMap",
  "offspring": ["Mathlib.Prelude.Rename.renameExtension"],
  "name": "Mathlib.Prelude.Rename.getRenameMap"},
 {"type":
  "∀ {m : Type u → Type u_1} {β γ α σ : Type u} [inst : Monad m] (x : m α) (f : α → StateCpsT σ m β) (s : σ)\n  (k : β → σ → m γ),\n  StateCpsT.runK (StateCpsT.lift x >>= f) s k = do\n    let a ← x\n    StateCpsT.runK (f a) s k",
  "offspring": [],
  "name": "StateCpsT.runK_bind_lift"},
 {"type":
  "{a b : ℕ} → {C : Sort u} → (a < b → C) → (a = b → C) → (b < a → C) → C",
  "offspring": ["Nat.lt_ge_by_cases", "Nat.le_antisymm"],
  "name": "Nat.lt_by_cases"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → (α → β) → WellFoundedRelation β → WellFoundedRelation α",
  "offspring":
  ["WellFoundedRelation.mk",
   "InvImage",
   "WellFoundedRelation.rel",
   "invImage.proof_1"],
  "name": "invImage"},
 {"type": "sizeOf Ordering.lt = 1",
  "offspring": [],
  "name": "Ordering.lt.sizeOf_spec"},
 {"type": "AddCommSemigroup UInt16",
  "offspring":
  ["AddCommSemigroup.mk",
   "UInt16.instAddSemigroupUInt16",
   "UInt16.instAddCommSemigroupUInt16.proof_1"],
  "name": "UInt16.instAddCommSemigroupUInt16"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (x : Option α) (f : α → Option β) (g : β → Option γ),\n  Option.bind (Option.bind x f) g = Option.bind x fun y => Option.bind (f y) g",
  "offspring": [],
  "name": "Option.bind_assoc"},
 {"type": "∀ {p : Prop}, (¬p → False) → p",
  "offspring": ["Decidable.byContradiction"],
  "name": "Classical.byContradiction"},
 {"type": "∀ (a a_1 : UInt16), a + a_1 = a_1 + a",
  "offspring": ["UInt16.add_def", "add_comm", "UInt16.mk"],
  "name": "UInt16.instSemiringUInt16.proof_6"},
 {"type": "{α : Type u_1} → {β : Type u_2} → Set (α → β) → Prop",
  "offspring": ["Ne"],
  "name": "set.separates_points"},
 {"type":
  "∀ {α : Type u} [inst : BEq α] [self : LawfulBEq α] (a : α), (a == a) = true",
  "offspring": [],
  "name": "LawfulBEq.rfl"},
 {"type":
  "∀ {α : Type u} {p : α → Prop} {a1 a2 : { x // p x }}, a1.val = a2.val → a1 = a2",
  "offspring": ["Subtype.val", "Subtype.mk"],
  "name": "Subtype.eq"},
 {"type": "∀ {n m k : ℕ}, n ≤ m → m < k → n < k",
  "offspring": ["Nat.le_trans", "Nat.succ_le_succ"],
  "name": "Nat.lt_of_le_of_lt"},
 {"type": "{α : Type u_1} → Append (Subarray α)",
  "offspring": ["Append.mk", "Array.toSubarray", "Subarray.toArray"],
  "name": "instAppendSubarray"},
 {"type": "∀ {A : Type u} [inst : AddCommSemigroup A] (a b : A), a + b = b + a",
  "offspring": ["AddCommSemigroup.add_comm"],
  "name": "add_comm"},
 {"type":
  "{m : Type u → Type v} → Sort u_1 → MonadFinally m → MonadFinally m → Sort u_1",
  "offspring": [],
  "name": "MonadFinally.noConfusionType"},
 {"type": "{M : Type u} → [self : MulOneClass M] → One M",
  "offspring": [],
  "name": "MulOneClass.toOne"},
 {"type": "@List.replicate = @List.replicateTR",
  "offspring": ["List.replicateTR_loop_replicate_eq"],
  "name": "List.replicate_eq_replicateTR"},
 {"type": "{α : Type u_1} → [inst : AndOp α] → HAnd α α α",
  "offspring": ["HAnd.mk", "AndOp.and"],
  "name": "instHAnd"},
 {"type": "Decidable False → decide False = false",
  "offspring": [],
  "name": "decide_false_eq_false"},
 {"type": "{α : Type u} → (α → α → α) → ShiftRight α",
  "offspring": [],
  "name": "ShiftRight.mk"},
 {"type": "{α : Type u} → (Char → α → α) → α → Substring → α",
  "offspring": [],
  "name": "Substring.foldr"},
 {"type": "∀ {α : Type u_1}, Option.isNone none = true",
  "offspring": [],
  "name": "Option.isNone_none"},
 {"type": "OrOp UInt64",
  "offspring": ["OrOp.mk", "UInt64.lor"],
  "name": "instOrOpUInt64"},
 {"type": "∀ (n m k : ℕ), n * (m + k) = n * m + n * k",
  "offspring":
  ["Nat.zero_mul", "Nat.succ_mul", "Nat.add_assoc", "Nat.add_left_comm"],
  "name": "Nat.left_distrib"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HPow α β γ] → α → β → γ",
  "offspring": [],
  "name": "HPow.hPow"},
 {"type": "∀ {S₀ : Type u} [self : SemigroupWithZero S₀] (a : S₀), 0 * a = 0",
  "offspring": [],
  "name": "SemigroupWithZero.zero_mul"},
 {"type":
  "∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)",
  "offspring": [],
  "name": "NonUnitalSemiring.mul_assoc"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.LeftInverse f g → Function.surjective f",
  "offspring":
  ["Function.RightInverse.surjective", "Function.LeftInverse.RightInverse"],
  "name": "Function.LeftInverse.surjective"},
 {"type": "∀ {n m : ℕ} (i : Fin n), m > 0 → ↑(i % m) < m",
  "offspring": ["Nat.lt_of_le_of_lt", "Nat.mod_le"],
  "name": "Fin.modn_lt"},
 {"type": "Inhabited True",
  "offspring": ["True.intro"],
  "name": "instInhabitedTrue"},
 {"type": "Type", "offspring": [], "name": "Empty"},
 {"type": "Monad Id", "offspring": ["Monad.mk"], "name": "Id.instMonadId"},
 {"type": "∀ (m : ℕ) {n : ℕ}, 0 < n → m * n / n = m",
  "offspring": ["Nat.zero_add", "Nat.zero_div", "Nat.add_mul_div_right"],
  "name": "Nat.mul_div_cancel"},
 {"type":
  "{α : Type u_1} → [inst : LE α] → [inst : DecidableRel LE.le] → α → α → α",
  "offspring": [],
  "name": "min"},
 {"type": "{α : Type u} → [inst : DecidableEq α] → List α → List α → List α",
  "offspring": ["List.filter", "Decidable.decide"],
  "name": "List.inter"},
 {"type":
  "{ε : Type u} →\n  {m : Type v → Type w} → ({α : Type v} → ε → m α) → ({α : Type v} → m α → (ε → m α) → m α) → MonadExceptOf ε m",
  "offspring": [],
  "name": "MonadExceptOf.mk"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α},\n  a ∈ l → ∃ l₁ l₂, ¬a ∈ l₁ ∧ l = l₁ ++ a :: l₂ ∧ List.erase l a = l₁ ++ l₂",
  "offspring": ["List.exists_of_erasep", "List.erase_eq_erasep"],
  "name": "List.exists_erase_eq"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (i : ℕ), i + 1 ≤ Array.size as → i ≤ Array.size as",
  "offspring": ["Nat.le_of_lt", "Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "Array.foldrM.fold.proof_2"},
 {"type": "(n : ℕ) → Ord (Fin n)",
  "offspring": ["Ord.mk", "Ord.compare", "instOrdNat"],
  "name": "instOrdFin"},
 {"type": "{α : Sort u} → α → α → Prop",
  "offspring": [],
  "name": "emptyRelation"},
 {"type":
  "∀ (x : ℕ), (fun a => Int.ofNat a) (x + 1) = (fun a => Int.ofNat a) (x + 1)",
  "offspring": [],
  "name": "Int.instCommRingInt.proof_3"},
 {"type": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Zero S₀",
  "offspring": [],
  "name": "SemigroupWithZero.toZero"},
 {"type": "ℕ → ℕ → Prop", "offspring": ["Nat.gcd"], "name": "Nat.coprime"},
 {"type":
  "∀ {α : Sort u_1} [inst : DecidableEq α] {β : α → Sort u_2} {a b : α},\n  a ≠ b →\n    ∀ (v : β a) (w : β b) (f : (a : α) → β a),\n      Function.update (Function.update f a v) b w = Function.update (Function.update f b w) a v",
  "offspring": ["dif_pos", "dif_neg"],
  "name": "Function.update_comm"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α} {P : β → Prop},\n  (∀ (i : β), i ∈ List.map f l → P i) ↔ ∀ (j : α), j ∈ l → P (f j)",
  "offspring": ["List.mem_map_of_mem", "List.mem_map"],
  "name": "List.forall_mem_map_iff"},
 {"type":
  "{α : Type u} → {β : Type v} → (as : Array α) → (Fin (Array.size as) → α → β) → Array β",
  "offspring": ["Id.run", "Array.mapIdxM", "Id.instMonadId"],
  "name": "Array.mapIdx"},
 {"type": "{α : Type s} → α → ULift α", "offspring": [], "name": "ULift.up"},
 {"type": "UInt8 → UInt64",
  "offspring": ["Nat.toUInt64", "UInt8.toNat"],
  "name": "UInt8.toUInt64"},
 {"type": "∀ {k m n : ℕ}, k ∣ n → (k ∣ m % n ↔ k ∣ m)",
  "offspring":
  ["HDiv.hDiv",
   "Nat.mod_add_div",
   "Nat.dvd_add_iff_left",
   "Nat.dvd_trans",
   "Nat.dvd_mul_right"],
  "name": "Nat.dvd_mod_iff"},
 {"type": "Nonempty (Fin UInt16.size)",
  "offspring": ["instNonempty", "UInt16.instInhabitedFinSize"],
  "name": "UInt16.instSemiringUInt16.proof_3"},
 {"type":
  "{p : Prop} → {q : Sort u} → [dec : Decidable p] → (p → q) → (¬p → q) → q",
  "offspring": [],
  "name": "Decidable.byCases"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HOrElse"},
 {"type": "∀ (m : ℕ) {n k : ℕ}, k ∣ n → m * n / k = m * (n / k)",
  "offspring": ["Nat.eq_zero_or_pos", "Nat.div_zero", "Nat.mul_zero"],
  "name": "Nat.mul_div_assoc"},
 {"type": "WellFoundedRelation ℕ",
  "offspring": ["WellFoundedRelation.mk", "Nat.lt", "Nat.lt_wfRel.proof_1"],
  "name": "Nat.lt_wfRel"},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → α → List α",
  "offspring": [],
  "name": "List.erase"},
 {"type": "Type", "offspring": [], "name": "Sat.Literal"},
 {"type": "∀ {a : ℤ}, 0 < a → -a < 0",
  "offspring": [],
  "name": "Int.neg_neg_of_pos"},
 {"type": "∀ (b : Bool), (b || true) = true",
  "offspring": [],
  "name": "Bool.or_true"},
 {"type":
  "Array (Array ℤ) →\n  Lean.Expr →\n    ℕ →\n      ℕ →\n        Lean.Expr →\n          Lean.Expr → ℕ × Std.HashMap ℕ Mathlib.Tactic.Sat.Clause → ℕ × Std.HashMap ℕ Mathlib.Tactic.Sat.Clause",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.buildClauses"},
 {"type": "∀ (a b n : ℕ), (a + b) % n = (a % n + b % n) % n",
  "offspring": ["Nat.add_mod_mod", "Nat.mod_add_mod"],
  "name": "Nat.add_mod"},
 {"type": "NonScalar → ℕ", "offspring": [], "name": "NonScalar.val"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticIterate____"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.tacticExact_mod_cast_"},
 {"type": "∀ {a b : ℤ}, b < a → 0 < a - b",
  "offspring": [],
  "name": "Int.sub_pos_of_lt"},
 {"type":
  "∀ {α : Type u} {inst : LT α} {motive : (a a_1 : List α) → List.lt a a_1 → Prop} {a a_1 : List α} (x : List.lt a a_1),\n  (∀ (a a_2 : List α) (x : List.lt a a_2), List.lt.below x → motive a a_2 x) → motive a a_1 x",
  "offspring":
  ["List.lt.below.nil", "List.lt.below.head", "List.lt.below.tail"],
  "name": "List.lt.brecOn"},
 {"type":
  "{ω σ : Type} →\n  {m : Type → Type} → {α : Type} → [inst : Monad m] → [inst : MonadLiftT (ST ω) m] → (σ → α × σ) → StateRefT' ω σ m α",
  "offspring": [],
  "name": "StateRefT'.modifyGet"},
 {"type":
  "{f : Type → Type v} → [inst : Alternative f] → (p : Prop) → [inst : Decidable p] → f Unit",
  "offspring": ["Alternative.failure"],
  "name": "guard"},
 {"type": "Int.sign 1 = 1", "offspring": [], "name": "Int.sign_one"},
 {"type": "Substring → ℕ", "offspring": ["Nat.sub"], "name": "Substring.bsize"},
 {"type": "UInt8 → Bool",
  "offspring": ["Decidable.decide", "GE.ge", "instLEUInt8"],
  "name": "UInt8.isDigit"},
 {"type":
  "∀ {α : Type u} (head : α) (tail : List α) (head_1 : α) (tail_1 : List α),\n  (head :: tail = head_1 :: tail_1) = (head = head_1 ∧ tail = tail_1)",
  "offspring": [],
  "name": "List.cons.injEq"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] {a a' : α},\n  a ≠ a' → ∀ (v : β a') (f : (a : α) → β a), Function.update f a' v a = f a",
  "offspring": ["dif_neg"],
  "name": "Function.update_noteq"},
 {"type": "ℕ → ℕ → Bool", "offspring": [], "name": "Nat.ble"},
 {"type": "∀ {a b c : Prop}, ((a → b) → (b → a) → c) → (a ↔ b) → c",
  "offspring": ["Iff.elim.proof_1"],
  "name": "Iff.elim"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a b : α), ¬a = b → Sum.inl a = Sum.inl b → False",
  "offspring": [],
  "name": "instDecidableEqSum.proof_2"},
 {"type": "UInt64 → UInt16",
  "offspring": ["Nat.toUInt16", "UInt64.toNat"],
  "name": "UInt64.toUInt16"},
 {"type": "Subsingleton Empty",
  "offspring": ["instSubsingletonEmpty.proof_1"],
  "name": "instSubsingletonEmpty"},
 {"type": "CommRing UInt32",
  "offspring":
  ["CommRing.mk", "UInt32.instRingUInt32", "UInt32.instCommRingUInt32.proof_1"],
  "name": "UInt32.instCommRingUInt32"},
 {"type": "∀ {G : Type u} [inst : Group G] (a b : G), a * b * b⁻¹ = a",
  "offspring": ["Inv.inv", "Semigroup.mul_assoc", "mul_right_inv", "mul_one"],
  "name": "mul_inv_cancel_right"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] [inst_1 : DecidableRel fun a a_1 => a ≤ a_1] {a b : α}, a ≤ b ↔ a < b ∨ a = b",
  "offspring": ["Decidable.lt_or_eq_of_le", "le_of_lt_or_eq"],
  "name": "Decidable.le_iff_lt_or_eq"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {a₁ a₂ : α} {b₁ : β a₁} {b₂ : β a₂} (h₁ : a₁ = a₂),\n  h₁ ▸ b₁ = b₂ → { fst := a₁, snd := b₁ } = { fst := a₂, snd := b₂ }",
  "offspring": [],
  "name": "PSigma.eta"},
 {"type": "{α : Type u} → ℕ → List α → List α",
  "offspring": [],
  "name": "List.take"},
 {"type": "{n : ℕ} → LT (Fin n)", "offspring": ["LT.mk"], "name": "instLTFin"},
 {"type": "{α : Sort u} → {β : Sort v} → {γ : Sort w} → α ≃ β → β ≃ γ → α ≃ γ",
  "offspring":
  ["Equiv.mk",
   "Equiv.toFun",
   "Equiv.symm",
   "Equiv.trans.proof_1",
   "Equiv.trans.proof_2"],
  "name": "Equiv.trans"},
 {"type":
  "Trans (fun a a_1 => a ≤ a_1) (fun a a_1 => a < a_1) fun a a_1 => a < a_1",
  "offspring": ["Trans.mk", "Nat.instTransNatLeInstLENatLtInstLTNat.proof_1"],
  "name": "Nat.instTransNatLeInstLENatLtInstLTNat"},
 {"type": "LT ℤ", "offspring": ["LT.mk", "Int.lt"], "name": "Int.instLTInt"},
 {"type": "∀ {α : Type u} (a : α) (as : List α), List.Mem a (a :: as)",
  "offspring": [],
  "name": "List.Mem.head"},
 {"type": "{α : Type u} → {β : Type v} → Array α → (α → Option β) → Option β",
  "offspring": ["Id.run", "Array.findSomeM?", "Id.instMonadId"],
  "name": "Array.findSome?"},
 {"type": "∀ (p : Prop), (True ↔ p) = p",
  "offspring": ["trivial"],
  "name": "true_iff"},
 {"type": "{α : Type u} → (α → Bool) → List α → List α × List α",
  "offspring": ["List.spanAux"],
  "name": "List.span"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : LT α] [inst_1 : LT β] (s t : α × β),\n  (s < t) = (s.fst < t.fst ∨ s.fst = t.fst ∧ s.snd < t.snd)",
  "offspring": [],
  "name": "Prod.lt_def"},
 {"type":
  "Sort u → Tactic.NormCast.CoeFnType → Tactic.NormCast.CoeFnType → Sort u",
  "offspring":
  ["noConfusionTypeEnum",
   "Tactic.NormCast.CoeFnType",
   "Tactic.NormCast.CoeFnType.toCtorIdx"],
  "name": "Tactic.NormCast.CoeFnType.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {a b : α} {n : ℕ}, b ∈ List.repeat' a n ↔ n ≠ 0 ∧ b = a",
  "offspring":
  ["Ne",
   "List.not_mem_nil",
   "eq_false_of_decide",
   "false_and",
   "Nat.add_zero",
   "List.mem_cons",
   "ne_eq",
   "Nat.succ_ne_zero",
   "true_and",
   "or_iff_left_iff_imp",
   "and_imp",
   "imp_self",
   "implies_true"],
  "name": "List.mem_repeat'"},
 {"type": "{α : Type u} → List α → (α → Bool) → Bool",
  "offspring": ["List.foldr", "or"],
  "name": "List.any"},
 {"type": "LawfulFunctor Set",
  "offspring": ["Set.instLawfulFunctorSetInstFunctorSet.proof_1"],
  "name": "Set.instLawfulFunctorSetInstFunctorSet"},
 {"type": "∀ {n m : ℕ}, n ≤ m → Nat.succ n ≤ Nat.succ m",
  "offspring": ["Nat.le.refl", "Nat.le.step"],
  "name": "Nat.succ_le_succ"},
 {"type": "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × β)",
  "offspring": ["List.bind", "List.map"],
  "name": "List.product"},
 {"type": "∀ (n : ℕ), Nat.succ n - 1 = n",
  "offspring": [],
  "name": "Nat.succ_sub_one"},
 {"type": "{α : Type u} → {β : Type v} → β → α ⊕ β",
  "offspring": [],
  "name": "Sum.inr"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {l : List α}, a ∈ List.insert b l ↔ a = b ∨ a ∈ l",
  "offspring":
  ["List.insert",
   "List.insert_of_mem",
   "List.insert_of_not_mem",
   "List.mem_cons",
   "Iff.rfl"],
  "name": "List.mem_insert_iff"},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      {δ : Type u_4} →\n        {ε : Type u_5} → {ζ : Type u_6} → (α → β → γ → δ → ε → ζ) → List α → List β → List γ → List δ → List ε → List ζ",
  "offspring": [],
  "name": "List.zipWith₅"},
 {"type":
  "{α : Sort u} → {β : Sort v} → Sort u_1 → CoeTail α β → CoeTail α β → Sort u_1",
  "offspring": [],
  "name": "CoeTail.noConfusionType"},
 {"type":
  "{motive : ℕ → ℕ → Sort u} →\n  (x y : ℕ) →\n    ((x y : ℕ) → 0 < y ∧ y ≤ x → motive (x - y) y → motive x y) →\n      ((x y : ℕ) → ¬(0 < y ∧ y ≤ x) → motive x y) → motive x y",
  "offspring": ["WellFounded.fix", "Nat.sub_lt", "Nat.lt_of_lt_of_le"],
  "name": "Nat.div.inductionOn"},
 {"type": "Array Lean.Syntax → (Lean.Syntax → Bool) → Array Lean.Syntax",
  "offspring": ["Id.run", "Array.filterSepElemsM", "Id.instMonadId"],
  "name": "Array.filterSepElems"},
 {"type":
  "∀ {α : Type u_1} {h₁ h₂ : α} {t₁ t₂ : List α}, h₁ :: t₁ = h₂ :: t₂ → t₁ = t₂",
  "offspring": [],
  "name": "List.tail_eq_of_cons_eq"},
 {"type": "{ε σ α : Type} → StateM σ α → EStateM ε σ α",
  "offspring": ["EStateM.Result.ok"],
  "name": "EStateM.fromStateM"},
 {"type": "∀ (p : Prop), ¬p ∨ p",
  "offspring": ["Or.swap", "em"],
  "name": "em'"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β), WellFoundedRelation β → WellFounded (InvImage WellFoundedRelation.rel f)",
  "offspring": ["InvImage.wf", "WellFoundedRelation.wf"],
  "name": "invImage.proof_1"},
 {"type": "(a : ByteArray) → Fin (ByteArray.size a) → UInt8",
  "offspring": ["Array.get"],
  "name": "ByteArray.get"},
 {"type": "AddSemigroup UInt16",
  "offspring":
  ["AddSemigroup.mk", "instAddUInt16", "UInt16.instAddSemigroupUInt16.proof_1"],
  "name": "UInt16.instAddSemigroupUInt16"},
 {"type": "Type u → Type u", "offspring": [], "name": "Mul"},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Monad m] → [inst : Alternative m] → Option α → m α",
  "offspring": ["Alternative.failure"],
  "name": "Option.toMonad"},
 {"type":
  "{m : Type u → Type v} → [inst : Applicative m] → {α : Type w} → {β : Type u} → (α → m β) → List α → m (List β)",
  "offspring": ["Seq.seq", "Functor.map"],
  "name": "List.mapA"},
 {"type": "∀ (n : ℕ), Nat.succ n ≠ 0",
  "offspring": [],
  "name": "Nat.succ_ne_zero"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk", "Fin.xor", "UInt16.size"],
  "name": "UInt16.xor"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) {p : Nat.Linear.Poly} {k : ℕ},\n  Nat.Linear.Poly.isNum? p = some k → Nat.Linear.Poly.denote ctx p = k",
  "offspring":
  ["Nat.Linear.Poly",
   "cond_true",
   "Option.some.injEq",
   "Nat.zero_add",
   "eq_of_beq",
   "Nat.instLawfulBEqNatInstBEqNat",
   "beq_self_eq_true",
   "Nat.Linear.Var.denote.go",
   "Nat.mul_one",
   "Bool.of_not_eq_true",
   "cond_false",
   "eq_false'",
   "false_implies",
   "Option"],
  "name": "Nat.Linear.Poly.isNum?_eq_some"},
 {"type":
  "Array Lean.Expr → Bool → Lean.Expr → Lean.Expr → Mathlib.Tactic.Lint.SimpTheoremInfo",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.mk"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬b < a",
  "offspring": ["lt_irrefl", "lt_trans"],
  "name": "lt_asymm"},
 {"type": "ℕ",
  "offspring": ["Subtype.val", "System.Platform.getNumBits"],
  "name": "System.Platform.numBits"},
 {"type": "∀ {a b : ℤ}, 0 < a → 0 ≤ b → 0 < a + b",
  "offspring": ["Int.add_lt_add_of_lt_of_le", "Int.zero_add"],
  "name": "Int.add_pos_of_pos_of_nonneg"},
 {"type":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : Type v} → [self : ForIn m ρ α] → {β : Type u₁} → [inst : Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "ForIn.forIn"},
 {"type": "∀ {a : Prop}, (true = true ↔ a) → a",
  "offspring": [],
  "name": "decidable_of_bool.proof_1"},
 {"type": "{α : Type u} → Subarray α → ℕ",
  "offspring": [],
  "name": "Subarray.stop"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → β → Prop}, Option.rel r none none",
  "offspring": [],
  "name": "Option.rel.none"},
 {"type": "∀ {a b c : ℤ}, a + b < c → b < c - a",
  "offspring": [],
  "name": "Int.lt_sub_left_of_add_lt"},
 {"type":
  "(ε : Type u) → (m : Type u → Type v) → [inst : Monad m] → MonadControl m (ExceptT ε m)",
  "offspring": ["MonadControl.mk", "ExceptT.run"],
  "name": "instMonadControlExceptT"},
 {"type": "∀ {α : Type u_1} {a : α} {s t : List α}, a ∈ s ++ t ↔ a ∈ s ∨ a ∈ t",
  "offspring":
  ["List.nil_append",
   "List.not_mem_nil",
   "false_or",
   "List.cons_append",
   "List.mem_cons",
   "or_assoc"],
  "name": "List.mem_append"},
 {"type": "∀ (a : ℕ), min a 0 = 0",
  "offspring": ["min_eq_right", "Nat.instLinearOrderNat", "Nat.zero_le"],
  "name": "Nat.min_zero"},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → Sort u_1 → Equivalence r → Equivalence r → Sort u_1",
  "offspring": [],
  "name": "Equivalence.noConfusionType"},
 {"type":
  "(ρ : Type u) → (m : Type u → Type v) → (α : Type u) → [inst : Inhabited (m α)] → Inhabited (ReaderT ρ m α)",
  "offspring": ["Inhabited.default"],
  "name": "instInhabitedReaderT"},
 {"type": "ℕ → UInt32", "offspring": ["UInt32.ofNat"], "name": "Nat.toUInt32"},
 {"type": "Nat.Linear.PolyCnstr → Bool",
  "offspring": [],
  "name": "Nat.Linear.PolyCnstr.eq"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HShiftRight"},
 {"type": "{α : Type u} → (as : List α) → Fin (List.length as) → α",
  "offspring": ["List.get.proof_1"],
  "name": "List.get"},
 {"type": "(n : ℕ) → Repr (Fin n)",
  "offspring": ["repr", "instReprNat"],
  "name": "instReprFin"},
 {"type": "∀ {a : ℤ}, 0 < a → ∃ n, a = ↑(Nat.succ n)",
  "offspring": ["Int.le.dest"],
  "name": "Int.eq_succ_of_zero_lt"},
 {"type": "Functor Option",
  "offspring": ["Functor.mk", "Option.map"],
  "name": "Option.instFunctorOption"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt),\n  Array.size self.arr = 0 → Array.size self.arr = Array.size self.arr - 1",
  "offspring": ["Nat.zero_sub"],
  "name": "BinaryHeap.popMaxAux.proof_2"},
 {"type": "∀ {a b : Prop}, (b → a) → (a ∧ b ↔ b)",
  "offspring": [],
  "name": "and_iff_right_of_imp"},
 {"type": "Float → Float → Bool", "offspring": [], "name": "Float.beq"},
 {"type":
  "{α : Type u_1} →\n  {β : Sort u_2} →\n    {arr : Array α} →\n      {f : α → β} → {n : ℕ} → {a : Fin n → β} → Sort u → UFModel.Agrees arr f a → UFModel.Agrees arr f a → Sort u",
  "offspring": [],
  "name": "UFModel.Agrees.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a : α) (b : β) (a' : α) (b' : β), ¬b = b' → (a, b) = (a', b') → False",
  "offspring": [],
  "name": "instDecidableEqProd.proof_2"},
 {"type":
  "∀ {α : Type u} {β : Type v} (f : α → β) (as : List α) (bs : List β),\n  List.mapTRAux f as bs = List.reverse bs ++ List.map f as",
  "offspring": ["List.append_nil", "List.reverse_cons", "List.append_assoc"],
  "name": "List.mapTRAux_eq"},
 {"type":
  "∀ {σ β : Type u} {m : Type u → Type v} (f : σ → σ) (s : σ) (k : PUnit → σ → m β),\n  StateCpsT.runK (modify f) s k = k PUnit.unit (f s)",
  "offspring": [],
  "name": "StateCpsT.runK_modify"},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : LT α] →\n      [inst_1 : LT β] →\n        [inst_2 : DecidableEq α] →\n          [inst_3 : DecidableEq β] →\n            [inst_4 : (a b : α) → Decidable (a < b)] →\n              [inst_5 : (a b : β) → Decidable (a < b)] → (s t : α × β) → Decidable (s < t)",
  "offspring": [],
  "name": "prodHasDecidableLt"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {r : α → α → Prop} {s : β → β → Prop} (a₁ : α) {b₁ : β} (a₂ : α) {b₂ : β},\n  s b₁ b₂ → PSigma.RevLex r s { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }",
  "offspring": [],
  "name": "PSigma.RevLex.right"},
 {"type": "{α : Type u} → Sort u_1 → LinearOrder α → LinearOrder α → Sort u_1",
  "offspring": [],
  "name": "LinearOrder.noConfusionType"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β) (x : α), Equiv.toFun (Equiv.symm e) (Equiv.toFun e x) = x",
  "offspring": ["Equiv.left_inv"],
  "name": "Equiv.symm_apply_apply"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.tacticApply_ext_lemma"},
 {"type": "∀ {G : Type u} [inst : Group G] (a : G), a * a⁻¹ = 1",
  "offspring": ["Inv.inv", "mul_left_inv", "inv_inv"],
  "name": "mul_right_inv"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] →\n        (as : Array α) → (Fin (Array.size as) → α → m β) → (i j : ℕ) → i + j = Array.size as → Array β → m (Array β)",
  "offspring": [],
  "name": "Array.mapIdxM.map"},
 {"type":
  "∀ {R : Type u_1} {n : ℕ} [inst : AddGroupWithOne R], ↑(Int.ofNat n) = ↑n",
  "offspring": ["AddGroupWithOne.intCast_ofNat"],
  "name": "Int.cast_ofNat"},
 {"type": "{α : Type u} → ReprAtom α", "offspring": [], "name": "ReprAtom.mk"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.commandDeclareExtTheoremsFor__"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (as : Array α) → (α → β → m (ForInStep β)) → (i : ℕ) → i ≤ Array.size as → β → m β",
  "offspring": [],
  "name": "Array.forIn.loop"},
 {"type": "∀ {α : Type u_1} {a b : α} {l : List α}, ¬a ∈ b :: l → ¬a ∈ l",
  "offspring": ["List.Mem.tail"],
  "name": "List.not_mem_of_not_mem_cons"},
 {"type": "Sort u → Sort (max 1 u)", "offspring": [], "name": "Inhabited"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ",
  "offspring": ["List.map"],
  "name": "List.map₂Left"},
 {"type": "∀ {a b c : ℕ}, a ∣ b → b ∣ c → a ∣ c",
  "offspring": [],
  "name": "Nat.dvd_trans"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α),\n  WellFounded (invImage (fun a => UnionFind.rankMax self - UnionFind.rank self ↑a) instWellFoundedRelation).1",
  "offspring": [],
  "name": "UnionFind.findAux.proof_1"},
 {"type": "∀ {α : Type u_1} {a y : α} {l : List α}, a ∈ y :: l → a = y ∨ a ∈ l",
  "offspring": ["List.mem_cons"],
  "name": "List.eq_or_mem_of_mem_cons"},
 {"type": "{α : Type u_1} → (α → Bool) → Array α → Array α",
  "offspring": [],
  "name": "Array.takeWhile"},
 {"type": "Nonempty (Tactic.DeclCache (Lean.Meta.DiscrTree Lean.Name))",
  "offspring": ["Tactic.instNonemptyDeclCache"],
  "name": "Tactic.LibrarySearch.librarySearchLemmas.proof_1"},
 {"type": "{n : ℕ} → Sort u → Nat.AtLeastTwo n → Nat.AtLeastTwo n → Sort u",
  "offspring": [],
  "name": "Nat.AtLeastTwo.noConfusionType"},
 {"type": "∀ {α : Type u_1} {l : List α}, 0 < List.length l → l ≠ []",
  "offspring": ["Nat.lt_irrefl", "Eq.subst", "List.length_eq_zero"],
  "name": "List.ne_nil_of_length_pos"},
 {"type": "Ord UInt64",
  "offspring": ["Ord.mk", "compareOfLessAndEq", "instLTUInt64"],
  "name": "instOrdUInt64"},
 {"type":
  "{α : Sort u} → {β : α → Sort v} → [inst : DecidableEq α] → ((a : α) → β a) → (a' : α) → β a' → (a : α) → β a",
  "offspring": [],
  "name": "Function.update"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} [na : Nonempty α] [inst : Subsingleton β] (f : α → β), Function.surjective f",
  "offspring": ["Subsingleton.elim"],
  "name": "Function.surjective_to_subsingleton"},
 {"type": "Add ℕ", "offspring": ["Add.mk", "Nat.add"], "name": "instAddNat"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_3} {β : Type u_1} [inst : Monad m] (f : α → β → m (ForInStep β)) (a : α)\n  (as : List α) (b : β),\n  forIn (a :: as) b f = do\n    let x ← f a b\n    match x with\n      | ForInStep.done b => pure b\n      | ForInStep.yield b => forIn as b f",
  "offspring": [],
  "name": "List.forIn_cons"},
 {"type": "{ε : Type} → Monad (EIO ε)",
  "offspring": [],
  "name": "instMonadEIO"},
 {"type": "∀ {a b : Prop}, a ∧ b ↔ ¬(¬a ∨ ¬b)",
  "offspring": ["Decidable.and_iff_not_or_not"],
  "name": "and_iff_not_or_not"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {γ : Sort u_3} → (α → β → γ) → Prop",
  "offspring": [],
  "name": "Function.injective2"},
 {"type": "Type u → Type u", "offspring": [], "name": "DoResultBC"},
 {"type": "∀ {a b : ℤ}, a ≤ b - 1 → a < b",
  "offspring": ["Int.add_le_of_le_sub_right"],
  "name": "Int.lt_of_le_sub_one"},
 {"type": "∀ (x : UInt8), npow_rec 0 x = npow_rec 0 x",
  "offspring": [],
  "name": "UInt8.instSemiringUInt8.proof_15"},
 {"type": "Inhabited UInt8",
  "offspring": ["UInt8.ofNatCore", "instInhabitedUInt8.proof_1"],
  "name": "instInhabitedUInt8"},
 {"type": "Tactic.Ring.Cache → Lean.Level",
  "offspring": [],
  "name": "Tactic.Ring.Cache.univ"},
 {"type": "Type", "offspring": [], "name": "Mathlib.Tactic.Lint.LintVerbosity"},
 {"type": "∀ {a b c : ℤ}, a + b ≤ a + c → b ≤ c",
  "offspring": [],
  "name": "Int.le_of_add_le_add_left"},
 {"type":
  "∀ {α : Sort u_1} {r q : α → α → Prop} {a : α}, Subrelation q r → Acc r a → Acc q a",
  "offspring": ["Acc.intro"],
  "name": "Subrelation.accessible.proof_1"},
 {"type": "∀ (m n : ℕ), Nat.gcd m (Nat.gcd m n) = Nat.gcd m n",
  "offspring":
  ["Nat.dvd_antisymm",
   "Nat.gcd_dvd_right",
   "Nat.gcd",
   "Nat.dvd_gcd",
   "Nat.gcd_dvd_left",
   "Nat.dvd_refl"],
  "name": "Nat.gcd_gcd_self_right_left"},
 {"type":
  "∀ {α : Type u_1} {arr : Array (UFNode α)} {n : ℕ} {m : UFModel n},\n  UFModel.Models arr m → ∀ (i : Fin (Array.size arr)), (Array.get arr i).rank = UFModel.rank m ↑i",
  "offspring": ["UFModel.Agrees.get_eq", "UFModel.Models.size_eq", "Fin.isLt"],
  "name": "UFModel.Models.rank_eq"},
 {"type": "{α : Sort u} → {β : Sort v} → [inst : CoeTC α β] → CoeHTCT α β",
  "offspring": ["CoeHTCT.mk", "CoeTC.coe"],
  "name": "coeOfTC"},
 {"type": "{α : Type u✝} → [self : One α] → α",
  "offspring": [],
  "name": "One.one"},
 {"type":
  "∀ {α : Sort u_1} {q : Prop} {p : α → Prop}, (∃ x, p x ∧ q) ↔ (∃ x, p x) ∧ q",
  "offspring": ["and_comm", "exists_and_distrib_left"],
  "name": "exists_and_distrib_right"},
 {"type": "Bool → Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.PolyCnstr",
  "offspring": [],
  "name": "Nat.Linear.PolyCnstr.mk"},
 {"type":
  "∀ {α : Type u_1} (a b : Array α), Array.size a = Array.size b → ∀ (x : ℕ), x < Array.size a → x < Array.size b",
  "offspring": [],
  "name": "Array.isEqvAux.proof_2"},
 {"type": "{α : Type u_1} → ℕ → List α → ℕ → List α × List (List α)",
  "offspring": [],
  "name": "List.toChunksAux"},
 {"type": "Substring → Char → String.Pos",
  "offspring": [],
  "name": "Substring.posOf"},
 {"type": "BEq Ordering",
  "offspring": ["BEq.mk", "instBEqNat", "Ordering.toCtorIdx"],
  "name": "instBEqOrdering"},
 {"type":
  "∀ (s1 s2 : ℕ), sizeOf { s1 := s1, s2 := s2 } = 1 + sizeOf s1 + sizeOf s2",
  "offspring": ["instSizeOfNat"],
  "name": "StdGen.mk.sizeOf_spec"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] (a b : α), ¬a ≤ b → a < b → False",
  "offspring": ["le_of_lt"],
  "name": "decidableLt_of_decidableLe.proof_2"},
 {"type":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "offspring": [],
  "name": "implies_congr"},
 {"type":
  "∀ {α : Sort u_1} [inst : DecidableEq α] {β : α → Sort u_2} {a : α} (v w : β a) (f : (a : α) → β a),\n  Function.update (Function.update f a v) a w = Function.update f a w",
  "offspring":
  ["dite_congr",
   "Eq.mpr_prop",
   "dite_true",
   "True.intro",
   "instDecidableFalse",
   "dite_false"],
  "name": "Function.update_idem"},
 {"type":
  "{R : Type u} → Sort u_1 → AddGroupWithOne R → AddGroupWithOne R → Sort u_1",
  "offspring": [],
  "name": "AddGroupWithOne.noConfusionType"},
 {"type":
  "∀ (p : ℕ → Prop) [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, p m → Nat.find p H ≤ m",
  "offspring": ["not_lt", "Nat.instLinearOrderNat", "Nat.find_min"],
  "name": "Nat.find_min'"},
 {"type":
  "{m : Type → Type} → [inst : Monad m] → Array Lean.Syntax → (Lean.Syntax → m Lean.Syntax) → m (Array Lean.Syntax)",
  "offspring": [],
  "name": "Array.mapSepElemsM"},
 {"type":
  "{m : Type u_1 → Type u_2} → {σ : Type u_1} → [inst : Monad m] → MonadLift m (ExceptCpsT σ m)",
  "offspring": ["MonadLift.mk", "ExceptCpsT.lift"],
  "name": "ExceptCpsT.instMonadLiftExceptCpsT"},
 {"type": "∀ {n : ℕ}, Nat.AtLeastTwo (n + 2)",
  "offspring": ["instAtLeastTwoHAddNatInstHAddInstAddNatOfNat.proof_1"],
  "name": "instAtLeastTwoHAddNatInstHAddInstAddNatOfNat"},
 {"type":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop}, Nat.le.below (_ : Nat.le n n)",
  "offspring": [],
  "name": "Nat.le.below.refl"},
 {"type": "∀ (a b : ℕ), a ∣ b * a",
  "offspring": [],
  "name": "Nat.dvd_mul_left"},
 {"type": "{ε σ α : Type u} → ε → σ → EStateM.Result ε σ α",
  "offspring": [],
  "name": "EStateM.Result.error"},
 {"type": "Subsingleton (Fin 1)",
  "offspring": ["Subsingleton.intro"],
  "name": "instSubsingletonFinOfNatNatInstOfNatNat_1.proof_1"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "offspring": ["Iff.elim_right", "Iff.elim_left"],
  "name": "not_iff_not_of_iff"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {a : α} {x : Option α} (g : α → β), a ∈ x → g a ∈ Option.map g x",
  "offspring": ["Option.mem_def", "Option.map_some'"],
  "name": "Option.mem_map_of_mem"},
 {"type":
  "{R : Type u} → Sort u_1 → NonUnitalNonAssocSemiring R → NonUnitalNonAssocSemiring R → Sort u_1",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.noConfusionType"},
 {"type":
  "{ρ : Type u_1} →\n  {α : Type u_2} →\n    {m : Type u_3 → Type u_4} →\n      {β : Type u_3} → [inst : Stream ρ α] → [inst : Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "Stream.forIn"},
 {"type": "Nat.Linear.Expr → Nat.Linear.Poly",
  "offspring": ["Nat.Linear.Poly.norm", "Nat.Linear.Expr.toPoly"],
  "name": "Nat.Linear.Expr.toNormPoly"},
 {"type": "{α : Sort u} → {β : Sort v} → Sort u_1 → α ≃ β → α ≃ β → Sort u_1",
  "offspring": [],
  "name": "Equiv.noConfusionType"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} → [inst : Monad m] → (as : List α) → β → ((a : α) → a ∈ as → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "List.forIn'"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {i j : ℕ},\n  i ≠ j →\n    ∀ (a : α) (hj : j < List.length (List.set l i a)),\n      List.get (List.set l i a) { val := j, isLt := hj } = List.get l { val := j, isLt := (_ : j < List.length l) }",
  "offspring":
  ["Option.some_inj", "List.get?_eq_get", "List.get?", "List.get?_set_ne"],
  "name": "List.get_set_ne"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∣_»"},
 {"type": "{α : Type u} → α → ℕ → List α",
  "offspring": [],
  "name": "List.repeat'"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HAndThen"},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β → α) → α → List β → List α",
  "offspring": [],
  "name": "List.scanl"},
 {"type": "sizeOf Tactic.NormCast.Label.move = 1",
  "offspring": [],
  "name": "Tactic.NormCast.Label.move.sizeOf_spec"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (a : α), sizeOf (ForInStep.yield a) = 1 + sizeOf a",
  "offspring": [],
  "name": "ForInStep.yield.sizeOf_spec"},
 {"type": "ShiftLeft USize",
  "offspring": ["ShiftLeft.mk", "USize.shiftLeft"],
  "name": "instShiftLeftUSize"},
 {"type": "{n : ℕ} → UFModel n → Fin n → Fin n",
  "offspring": [],
  "name": "UFModel.parent"},
 {"type": "Ordering", "offspring": [], "name": "Ordering.eq"},
 {"type": "∀ (m n : ℕ), Nat.lcm m n = Nat.lcm n m",
  "offspring": [],
  "name": "Nat.lcm_comm"},
 {"type": "{α : Type u_1} → Array α → Array α",
  "offspring": ["Array.getEvenElems"],
  "name": "Array.getSepElems"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort u_2} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "offspring": [],
  "name": "congr_fun"},
 {"type": "∀ {a b : Prop}, b → a ∨ b", "offspring": [], "name": "Or.inr"},
 {"type": "∀ {a b c : Prop}, (c → (a ↔ b)) → (a ∧ c ↔ b ∧ c)",
  "offspring": ["Iff.trans", "And.comm", "and_congr_right"],
  "name": "and_congr_left"},
 {"type": "∀ (n m k : ℕ), (n + m) * k = n * k + m * k",
  "offspring": ["Nat.right_distrib"],
  "name": "Nat.add_mul"},
 {"type": "∀ {a b : ℤ}, a + 1 ≤ b → a < b",
  "offspring": [],
  "name": "Int.lt_of_add_one_le"},
 {"type": "∀ {G : Type u} [inst : Group G] (a : G), a⁻¹ * a = 1",
  "offspring": ["mul_left_inv"],
  "name": "inv_mul_self"},
 {"type": "Nat.Linear.Expr → ℕ → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.Expr.mulR"},
 {"type": "{α : Type u_1} → Membership α (Set α)",
  "offspring": ["Membership.mk", "Set.mem"],
  "name": "Set.instMembershipSet"},
 {"type":
  "{A : Type u} → Sort u_1 → SubNegMonoid A → SubNegMonoid A → Sort u_1",
  "offspring": [],
  "name": "SubNegMonoid.noConfusionType"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadState σ m] → σ → m PUnit",
  "offspring": [],
  "name": "MonadState.set"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ ⊆ l₂ ↔ ∀ {a : α}, a ∈ l₁ → a ∈ l₂",
  "offspring": ["Iff.rfl"],
  "name": "List.subset_def"},
 {"type": "∀ (p : Prop), Subsingleton (Decidable p)",
  "offspring": ["instSubsingletonDecidable.proof_1"],
  "name": "instSubsingletonDecidable"},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {β : Type u_1} → [inst : Monad m] → (UInt8 → β → m (ForInStep β)) → ByteArray → ℕ → ℕ → ℕ → β → m β",
  "offspring": ["WellFounded.fix", "ByteArray.get!"],
  "name": "ByteSlice.forIn.loop"},
 {"type":
  "{m : Type → Type u_1} →\n  {α : Type} →\n    [inst : Monad m] → (α → m Bool) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m (Array α)",
  "offspring": ["Array.foldlM", "Array.push"],
  "name": "Array.filterM"},
 {"type": "(n : ℕ) → ToString (Fin n)",
  "offspring": ["ToString.mk", "instToStringNat"],
  "name": "instToStringFin"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α},\n  a ∈ l → List.length (List.erase l a) = Nat.pred (List.length l)",
  "offspring": ["List.erase_eq_erasep", "List.length_erasep_of_mem"],
  "name": "List.length_erase_of_mem"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a > b → b ≥ c → a > c",
  "offspring": ["lt_of_le_of_lt"],
  "name": "gt_of_gt_of_ge"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«tacticBy_cases__:_»"},
 {"type":
  "∀ {A : Type u} [self : SubNegMonoid A] (n : ℕ) (a : A),\n  SubNegMonoid.gsmul (Int.ofNat (Nat.succ n)) a = a + SubNegMonoid.gsmul (Int.ofNat n) a",
  "offspring": [],
  "name": "SubNegMonoid.gsmul_succ'"},
 {"type": "∀ {a b c : ℤ}, a < b + c → a - c < b",
  "offspring": [],
  "name": "Int.sub_right_lt_of_lt_add"},
 {"type": "optParam (Array ℕ) #[] → Lean.Parsec (Array ℕ)",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Parser.parseNats"},
 {"type": "(fun n => { val := ↑n }) 0 = (fun n => { val := ↑n }) 0",
  "offspring": [],
  "name": "USize.instSemiringUSize.proof_11"},
 {"type": "∀ {a b : ℤ}, a < b → a ≤ b",
  "offspring": ["Int.le.intro", "Int.lt.dest"],
  "name": "Int.le_of_lt"},
 {"type": "{α : Type u} → (α → Bool) → List α → List α → List α",
  "offspring": ["List.reverse"],
  "name": "List.filterAux"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β → γ) → Array α → Array β → ℕ → Array γ → Array γ",
  "offspring":
  ["WellFounded.fix",
   "Array.push",
   "WellFoundedRelation.rel",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Array.get",
   "Nat.sub_succ_lt_self"],
  "name": "Array.zipWithAux"},
 {"type": "∀ {a b : ℤ}, 0 < a → b < 0 → a * b < 0",
  "offspring": [],
  "name": "Int.mul_neg_of_pos_of_neg"},
 {"type": "Mathlib.Tactic.Lint.SimpTheoremInfo → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.lhs"},
 {"type": "OrOp USize",
  "offspring": ["OrOp.mk", "USize.lor"],
  "name": "instOrOpUSize"},
 {"type": "{α : Type u_1} → {β : Type u_2} → α × β → β × α",
  "offspring": [],
  "name": "Prod.swap"},
 {"type":
  "{α : Type u} → Sort u_1 → NonUnitalSemiring α → NonUnitalSemiring α → Sort u_1",
  "offspring": [],
  "name": "NonUnitalSemiring.noConfusionType"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddGroupWithOne"},
 {"type": "∀ {α : Type u_1} (a : Array α), Array.size a = Array.size a",
  "offspring": [],
  "name": "Array.eraseIdx'.proof_1"},
 {"type": "Float → Float", "offspring": [], "name": "Float.sin"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → (as : Array α) → (stop : ℕ) → stop ≤ Array.size as → ℕ → ℕ → β → m β",
  "offspring": ["Array.get", "Array.foldlM.loop.proof_1"],
  "name": "Array.foldlM.loop"},
 {"type": "{α β σ : Type u} → σ → DoResultPRBC α β σ",
  "offspring": [],
  "name": "DoResultPRBC.break"},
 {"type": "ℕ → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.buildReify.v"},
 {"type": "∀ {α : Type u_1} {l₁ l₂ l₃ : List α}, l₁ ⊆ l₂ → l₂ ⊆ l₃ → l₁ ⊆ l₃",
  "offspring": [],
  "name": "List.subset.trans"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HOrElse α β γ → HOrElse α β γ → Sort u_1",
  "offspring": [],
  "name": "HOrElse.noConfusionType"},
 {"type":
  "{α₁ α₂ α₃ β : Type u} → [inst : Inhabited β] → ((α₁ → α₂ → α₃ → β) → α₁ → α₂ → α₃ → β) → α₁ → α₂ → α₃ → β",
  "offspring": ["fixCore3", "Inhabited.default"],
  "name": "fix3"},
 {"type": "Type u → Type u", "offspring": [], "name": "GroupWithZero"},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "offspring": [],
  "name": "MonadControl"},
 {"type": "{α : Type} → IO α → Except IO.Error α",
  "offspring": ["unsafeEIO"],
  "name": "unsafeIO"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β},\n  Function.injective f → Function.surjective (Function.inv_fun f)",
  "offspring":
  ["Function.LeftInverse.surjective", "Function.LeftInverse_inv_fun"],
  "name": "Function.inv_fun_surjective"},
 {"type": "{α : Type u} → Sort u_1 → AndOp α → AndOp α → Sort u_1",
  "offspring": [],
  "name": "AndOp.noConfusionType"},
 {"type": "∀ {a b : ℤ}, 0 ≤ a → a < b → a * a < b * b",
  "offspring": ["Int.mul_lt_mul'", "Int.le_of_lt", "lt_of_le_of_lt"],
  "name": "Int.mul_self_lt_mul_self"},
 {"type": "{α : Type u} → Array α → ℕ → Array α",
  "offspring": [],
  "name": "Array.shrink"},
 {"type":
  "outParam (Type u) → (Type v → Type w) → Type (max (max u (v + 1)) w)",
  "offspring": [],
  "name": "MonadExcept"},
 {"type": "{α : Type u_1} → [inst : OfNat α 1] → One α",
  "offspring": ["One.mk"],
  "name": "instOne"},
 {"type":
  "∀ {α : Type u_1} (i : ℕ) (a : Array α), i + 1 ≤ Array.size a → i < Array.size a",
  "offspring": ["Nat.lt_of_succ_le"],
  "name": "BinaryHeap.mkHeap.loop.proof_2"},
 {"type": "Sort u → USize → USize → Sort u",
  "offspring": [],
  "name": "USize.noConfusionType"},
 {"type": "∀ {α : Type u_1} (a : α), a ∈ [a]",
  "offspring": ["List.mem_cons_self"],
  "name": "List.mem_singleton_self"},
 {"type": "Float → Float", "offspring": [], "name": "Float.tan"},
 {"type":
  "{α : Type u} → (Unit → α) → optParam Task.Priority Task.Priority.default → Task α",
  "offspring": ["Task.pure"],
  "name": "Task.spawn"},
 {"type": "Neg UInt8",
  "offspring": ["Neg.mk", "UInt8.mk"],
  "name": "UInt8.instNegUInt8"},
 {"type": "∀ {n m : ℕ}, Nat.succ n ≤ m → Nat.succ n ≤ Nat.succ m",
  "offspring": ["Nat.le_step"],
  "name": "Nat.lt.step.proof_1"},
 {"type":
  "∀ (atoms : Array Lean.Expr) (numAtoms : ℕ),\n  sizeOf { atoms := atoms, numAtoms := numAtoms } = 1 + sizeOf atoms + sizeOf numAtoms",
  "offspring": ["instSizeOfNat"],
  "name": "Tactic.Ring.State.mk.sizeOf_spec"},
 {"type": "∀ {a b : Prop}, (a ↔ b) ↔ (b ↔ a)",
  "offspring": ["Iff.symm"],
  "name": "Iff.comm"},
 {"type": "∀ {a : ℤ}, a ≠ 0 → 0 < Int.natAbs a",
  "offspring":
  ["Or.resolve_left",
   "Nat.eq_zero_or_pos",
   "mt",
   "Int.eq_zero_ofNatAbs_eq_zero"],
  "name": "Int.natAbs_pos_of_ne_zero"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {l : List α}, a ∈ List.insert b l → a = b ∨ a ∈ l",
  "offspring": ["List.mem_insert_iff"],
  "name": "List.eq_or_mem_of_mem_insert"},
 {"type": "∀ {p q : Prop}, p → q → p ∧ ¬q ∨ q ∧ ¬p → False",
  "offspring": [],
  "name": "instDecidableXor.proof_1"},
 {"type": "{α : Type u_1} → Union (Set α)",
  "offspring": ["Union.mk", "Set.union"],
  "name": "Set.instUnionSet"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["cond"],
  "name": "unexpandSigma"},
 {"type":
  "{α : Sort u} → {p : α → α → Bool} → is_dec_eq p → is_dec_refl p → DecidableEq α",
  "offspring": ["decidable_eq_of_bool_pred.proof_1"],
  "name": "decidable_eq_of_bool_pred"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (α → β → m β) → (as : Array α) → optParam ℕ 0 → (i : ℕ) → i ≤ Array.size as → β → m β",
  "offspring": ["instBEqNat"],
  "name": "Array.foldrM.fold"},
 {"type":
  "{n : ℕ} →\n  (parent : Fin n → Fin n) → (rank : ℕ → ℕ) → (∀ (i : Fin n), ↑(parent i) ≠ ↑i → rank ↑i < rank ↑(parent i)) → UFModel n",
  "offspring": [],
  "name": "UFModel.mk"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (head : α) (tail : List α), sizeOf (head :: tail) = 1 + sizeOf head + sizeOf tail",
  "offspring": [],
  "name": "List.cons.sizeOf_spec"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : α) → (a_1 : List α) → List.Chain R a a_1 → Prop} {a b : α}\n  {l : List α},\n  R a b →\n    ∀ {a_2 : List.Chain R b l}, List.Chain.below a_2 → motive b l a_2 → List.Chain.below (_ : List.Chain R a (b :: l))",
  "offspring": [],
  "name": "List.Chain.below.cons"},
 {"type": "ℕ", "offspring": [], "name": "Nat.Linear.fixedVar"},
 {"type": "∀ {α : Sort u_1}, (∃ a, True) ↔ Nonempty α",
  "offspring": ["trivial"],
  "name": "exists_true_iff_nonempty"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticBy_cases_"},
 {"type": "{α : Type u_1} → ℕ → α → ℕ → UFNode α",
  "offspring": [],
  "name": "UFNode.mk"},
 {"type":
  "∀ {α σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf σ] (a : α) (a_1 : σ),\n  sizeOf (DoResultSBC.pureReturn a a_1) = 1 + sizeOf a + sizeOf a_1",
  "offspring": [],
  "name": "DoResultSBC.pureReturn.sizeOf_spec"},
 {"type": "ℕ → List ℕ → List ℕ",
  "offspring": ["List.reverse"],
  "name": "List.iotaTR.go"},
 {"type": "{n : ℕ} → Hashable (Fin n)",
  "offspring": ["Hashable.mk", "Nat.toUInt64"],
  "name": "instHashableFin"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → UInt8 → m β) → β → (as : ByteArray) → optParam ℕ 0 → optParam ℕ (ByteArray.size as) → m β",
  "offspring": ["ByteArray.size", "ByteArray.foldlM.proof_1"],
  "name": "ByteArray.foldlM"},
 {"type":
  "∀ {i i_1 : Nat.Linear.Var}, Nat.Linear.Expr.var i = Nat.Linear.Expr.var i_1 → i = i_1",
  "offspring": [],
  "name": "Nat.Linear.Expr.var.inj"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1},\n  WellFoundedRelation α →\n    WellFoundedRelation β → WellFounded (Prod.RProd WellFoundedRelation.rel WellFoundedRelation.rel)",
  "offspring": ["Subrelation.wf", "WellFoundedRelation.wf", "Prod.RProdSubLex"],
  "name": "Prod.rprod.proof_1"},
 {"type": "∀ {n : ℕ} (a : Fin n), ↑a % n = ↑a",
  "offspring": ["Nat.mod_eq_of_lt", "Fin.isLt"],
  "name": "Fin.mod_eq_val"},
 {"type": "{α : Type u} → (α → α → α) → ShiftLeft α",
  "offspring": [],
  "name": "ShiftLeft.mk"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → (γ → δ) → (α → β → γ) → α → β → δ",
  "offspring": [],
  "name": "Function.bicompr"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} (a : α) (h : p a), { val := a, property := h }.val = a",
  "offspring": [],
  "name": "Subtype.coe_mk"},
 {"type": "Sub UInt32",
  "offspring": ["Sub.mk", "UInt32.sub"],
  "name": "instSubUInt32"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → OptionT m α → (Unit → OptionT m α) → OptionT m α",
  "offspring": ["OptionT.mk"],
  "name": "OptionT.orElse"},
 {"type": "∀ {a b c d : Prop}, (a → c) → (b → d) → a ∧ b → c ∧ d",
  "offspring": ["And.imp"],
  "name": "and_implies"},
 {"type": "∀ (a b : ℤ), a + b = b + a",
  "offspring": ["Int.ofNat_add_ofNat", "Int.negSucc_ofNat_add_negSucc_ofNat"],
  "name": "Int.add_comm"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a : α} {l : List α}, a ∈ List.erasep p l → a ∈ l",
  "offspring": ["List.erasep_subset"],
  "name": "List.mem_of_mem_erasep"},
 {"type": "Type", "offspring": [], "name": "USize"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → α → α × BinaryHeap α lt",
  "offspring":
  ["BinaryHeap.max",
   "BinaryHeap.insertExtractMax.proof_1",
   "BinaryHeap.mk",
   "Subtype.val",
   "BinaryHeap.heapifyDown",
   "BinaryHeap.insertExtractMax.proof_2",
   "Array.set",
   "BinaryHeap.arr",
   "BinaryHeap.size_pos_of_max"],
  "name": "BinaryHeap.insertExtractMax"},
 {"type": "Nat.Linear.Context → Nat.Linear.ExprCnstr → Prop",
  "offspring":
  ["cond",
   "Nat.Linear.ExprCnstr.eq",
   "Nat.Linear.Expr.denote",
   "Nat.Linear.ExprCnstr.lhs",
   "Nat.Linear.ExprCnstr.rhs"],
  "name": "Nat.Linear.ExprCnstr.denote"},
 {"type": "List Char",
  "offspring": ["System.Platform.isWindows"],
  "name": "System.FilePath.pathSeparators"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)], ↑1 = 1 % n",
  "offspring": [],
  "name": "Fin.one_def"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3}, (α → β → γ) → Nonempty α → Nonempty β → Nonempty γ",
  "offspring": [],
  "name": "Nonempty.map2"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, (∀ (n : ℕ), List.get? l₁ n = List.get? l₂ n) → l₁ = l₂",
  "offspring": ["List.get?"],
  "name": "List.ext"},
 {"type":
  "∀ (e : Lean.Expr) (coeff : ℕ), sizeOf (Tactic.Ring.HornerExpr.const e coeff) = 1 + sizeOf e + sizeOf coeff",
  "offspring": ["instSizeOfNat"],
  "name": "Tactic.Ring.HornerExpr.const.sizeOf_spec"},
 {"type": "∀ {a b : ℤ}, a ≤ b → a - b ≤ 0",
  "offspring": [],
  "name": "Int.sub_nonpos_of_le"},
 {"type": "∀ (m n : ℕ), Nat.gcd m n ∣ m",
  "offspring": ["Nat.gcd_dvd"],
  "name": "Nat.gcd_dvd_left"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.«termExt_iff_proof%»"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : Function.HasUncurry α β γ] → α → β → γ",
  "offspring": [],
  "name": "Function.HasUncurry.uncurry"},
 {"type": "Fin UInt64.size → UInt64", "offspring": [], "name": "UInt64.mk"},
 {"type": "Float → Float", "offspring": [], "name": "Float.cos"},
 {"type": "∀ (a b : Bool), ((a == b) = true) = (a = b)",
  "offspring": [],
  "name": "Bool.beq_to_eq"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → (α → m β) → m (Array β)",
  "offspring": [],
  "name": "Array.sequenceMap"},
 {"type": "∀ (n m k : ℕ), n * m * k = n * (m * k)",
  "offspring": [],
  "name": "Nat.mul_assoc"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} (h : n < List.length l), List.get? l n = some (List.get l { val := n, isLt := h })",
  "offspring": ["Nat.add"],
  "name": "List.get?_eq_get"},
 {"type": "∀ {α : Type u_1} (s : List α), Function.injective fun t => s ++ t",
  "offspring": ["List.append_left_cancel"],
  "name": "List.append_right_injective"},
 {"type": "{n : ℕ} → ShiftRight (Fin n)",
  "offspring": ["ShiftRight.mk", "Fin.shiftRight"],
  "name": "Fin.instShiftRightFin"},
 {"type": "Nat.Linear.PolyCnstr → Bool",
  "offspring":
  ["cond",
   "Nat.Linear.PolyCnstr.eq",
   "Nat.Linear.Poly.isZero",
   "Nat.Linear.PolyCnstr.lhs",
   "Nat.Linear.PolyCnstr.rhs"],
  "name": "Nat.Linear.PolyCnstr.isValid"},
 {"type":
  "∀ {α : Type u} [inst : LT α] {a : α} (as : List α) {b : α} (bs : List α), a < b → List.lt (a :: as) (b :: bs)",
  "offspring": [],
  "name": "List.lt.head"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (x : m α), x >>= pure = x",
  "offspring": [],
  "name": "bind_pure"},
 {"type": "∀ (m n : ℕ), -[1+ m] + Int.ofNat n = Int.subNatNat n (Nat.succ m)",
  "offspring": [],
  "name": "Int.negSucc_ofNat_add_ofNat"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l : List α), List.erase l a ⊆ l",
  "offspring": ["List.erase_eq_erasep", "List.erasep_subset"],
  "name": "List.erase_subset"},
 {"type": "Float → Float", "offspring": [], "name": "Float.atan"},
 {"type": "Lean.Elab.Tactic.Tactic",
  "offspring": ["not"],
  "name": "evalGuardHyp"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → [inst : Monad m] → {α : Type u} → α → ExceptT ε m α",
  "offspring": ["ExceptT.mk", "Except.ok"],
  "name": "ExceptT.pure"},
 {"type": "{α : Type u_1} → Option (Option α) → Option α",
  "offspring": ["Option.bind"],
  "name": "Option.join"},
 {"type":
  "{α : Sort u} → {β : Sort v} → Sort u_1 → CoeTC α β → CoeTC α β → Sort u_1",
  "offspring": [],
  "name": "CoeTC.noConfusionType"},
 {"type": "Float → Float", "offspring": [], "name": "Float.cbrt"},
 {"type": "Mul ℕ", "offspring": ["Mul.mk", "Nat.mul"], "name": "instMulNat"},
 {"type": "Type u → Type u", "offspring": [], "name": "Set"},
 {"type": "∀ (x y z : ℕ), (x + y * z) % z = x % z",
  "offspring": ["Nat.add_mul_mod_self_left"],
  "name": "Nat.add_mul_mod_self_right"},
 {"type":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a < b)",
  "offspring": ["LinearOrder.decidable_lt"],
  "name": "instDecidableLtToLTToPreorderToPartialOrder"},
 {"type": "∀ {G : Type u} [self : CommGroup G] (a b : G), a * b = b * a",
  "offspring": [],
  "name": "CommGroup.mul_comm"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«termDecl_name%»"},
 {"type": "0 ≠ 1", "offspring": [], "name": "Nat.zero_ne_one"},
 {"type": "{α : Sort u} → {β : Sort v} → [inst : Coe α β] → CoeTC α β",
  "offspring": ["CoeTC.mk", "Coe.coe"],
  "name": "coeBase"},
 {"type": "Type u → Type u", "offspring": [], "name": "Distrib"},
 {"type": "∀ {R : Type u} [self : CommSemiring R] (a b : R), a * b = b * a",
  "offspring": [],
  "name": "CommSemiring.mul_comm"},
 {"type": "∀ {a b c : ℤ}, b ≤ c - a → a + b ≤ c",
  "offspring": [],
  "name": "Int.add_le_of_le_sub_left"},
 {"type":
  "∀ {α β : Type u} (fst : α) (snd : β) (fst_1 : α) (snd_1 : β),\n  ({ fst := fst, snd := snd } = { fst := fst_1, snd := snd_1 }) = (fst = fst_1 ∧ snd = snd_1)",
  "offspring": [],
  "name": "MProd.mk.injEq"},
 {"type":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop} {m : ℕ} {a : Nat.le n m},\n  Nat.le.below a → motive m a → Nat.le.below (_ : Nat.le n (Nat.succ m))",
  "offspring": [],
  "name": "Nat.le.below.step"},
 {"type": "∀ (b : Bool), (!!b) = b", "offspring": [], "name": "Bool.not_not"},
 {"type": "∀ (n : ℕ), n ≤ Nat.succ n",
  "offspring": ["Nat.le.step", "Nat.le.refl"],
  "name": "Nat.le_succ"},
 {"type": "∀ {α : Sort u_1}, Nonempty (PLift α) ↔ Nonempty α",
  "offspring": ["Nonempty", "PLift", "PLift.up"],
  "name": "nonempty_plift"},
 {"type":
  "∀ {ε : Type u} {α : Type v} [inst : SizeOf ε] [inst_1 : SizeOf α] (a : α), sizeOf (Except.ok a) = 1 + sizeOf a",
  "offspring": [],
  "name": "Except.ok.sizeOf_spec"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["Fin.mod.proof_1"],
  "name": "Fin.mod"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} → [inst : Monad m] → (α → m β) → USize → USize → Array NonScalar → m (Array PNonScalar)",
  "offspring":
  ["instLTUSize",
   "unsafeCast",
   "NonScalar",
   "Array.mapMUnsafe.map",
   "Array.uset",
   "lcProof",
   "Inhabited.default",
   "instInhabitedNonScalar",
   "Array.uget"],
  "name": "Array.mapMUnsafe.map"},
 {"type": "∀ (n m k : ℕ), (n - m) * k = n * k - m * k",
  "offspring":
  ["Nat.zero_eq",
   "Nat.sub_zero",
   "Nat.zero_mul",
   "Nat.sub_succ",
   "Nat.pred",
   "Nat.mul_pred_left",
   "Nat.succ_mul",
   "Nat.sub_sub"],
  "name": "Nat.mul_sub_right_distrib"},
 {"type":
  "∀ {α : Type u_1} (f : α → α) (n : ℕ) (l : List α), List.get? (List.modifyNth f n l) n = f <$> List.get? l n",
  "offspring":
  ["List.get?_modifyNth",
   "Functor.map",
   "Option",
   "Option.instFunctorOption",
   "if_pos",
   "List.get?"],
  "name": "List.get?_modifyNth_eq"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {r : α → α → Prop} {s : β → β → Prop},\n  WellFounded r → WellFounded s → WellFounded (PSigma.lexNdep r s)",
  "offspring": ["PSigma.lexNdepWf.proof_1"],
  "name": "PSigma.lexNdepWf"},
 {"type": "{p : Prop} → ToString (Decidable p)",
  "offspring": ["ToString.mk"],
  "name": "instToStringDecidable"},
 {"type": "Lean.Name → Tactic.NormCast.CoeFnInfo → Lean.MetaM Unit",
  "offspring":
  ["Tactic.NormCast.CoeFnInfo", "Tactic.NormCast.instToExprCoeFnInfo"],
  "name": "Tactic.NormCast.addCoeDelaborator"},
 {"type": "Lean.Meta.SimpExtension",
  "offspring": [],
  "name": "Tactic.NormCast.pushCastExt"},
 {"type": "UInt8 → Bool",
  "offspring": ["or", "UInt8.isAlpha", "UInt8.isDigit"],
  "name": "UInt8.isAlphanum"},
 {"type": "AddSemigroup UInt64",
  "offspring":
  ["AddSemigroup.mk", "instAddUInt64", "UInt64.instAddSemigroupUInt64.proof_1"],
  "name": "UInt64.instAddSemigroupUInt64"},
 {"type": "{α : Type u} → (α → Bool) → List α → Option α",
  "offspring": [],
  "name": "List.find?"},
 {"type": "ReprAtom UInt16",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomUInt16"},
 {"type": "∀ (n : ℤ), (fun n x => x ^ n) 0 n = (fun n x => x ^ n) 0 n",
  "offspring": [],
  "name": "Int.instCommRingInt.proof_4"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "«termIfLet_:=_Then_Else_»"},
 {"type":
  "∀ {m : Type u → Type v} [inst : Monad m] [self : LawfulMonad m] {α β : Type u} (x : α) (f : α → m β), pure x >>= f = f x",
  "offspring": [],
  "name": "LawfulMonad.pure_bind"},
 {"type": "outParam (Type u) → (Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "MonadWithReader"},
 {"type": "(m : Type u_1 → Type u_2) → MonadFunctorT m m",
  "offspring": ["MonadFunctorT.mk"],
  "name": "monadFunctorRefl"},
 {"type": "∀ {a x : ℕ}, x < a → 0 < a",
  "offspring": ["Nat.lt_trans", "Nat.zero_lt_succ"],
  "name": "zero_lt_of_lt"},
 {"type": "Lean.Expr → Lean.Meta.SimpM (Option Lean.Expr)",
  "offspring": ["Option.map"],
  "name": "Tactic.NormCast.prove"},
 {"type": "∀ (m n k : ℕ), Nat.gcd m (n + k * m) = Nat.gcd m n",
  "offspring": ["Nat.gcd_rec", "Nat.add_mul_mod_self_right"],
  "name": "Nat.gcd_add_mul_self"},
 {"type": "¬Nonempty Empty",
  "offspring": ["sorryAx"],
  "name": "nonempty_empty"},
 {"type":
  "(f : Type u → Type v) → (α : Type u) → [inst : Alternative f] → OrElse (f α)",
  "offspring": ["OrElse.mk", "Alternative.orElse"],
  "name": "instOrElse"},
 {"type": "∀ {α : Type u} (self : Subarray α), self.start ≤ self.stop",
  "offspring": [],
  "name": "Subarray.h₁"},
 {"type": "System.FilePath → Option String",
  "offspring":
  ["or",
   "System.FilePath.toString",
   "List.contains",
   "System.FilePath.pathSeparators"],
  "name": "System.FilePath.fileName"},
 {"type": "{α β : Type u} → (α → β) → ((α → β) → α → β) → α → β",
  "offspring": ["bfix1", "USize.size"],
  "name": "fixCore1"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HShiftRight α β γ",
  "offspring": [],
  "name": "HShiftRight.mk"},
 {"type":
  "{α : Type u} → {m : Type → Type u_1} → [inst : Monad m] → Array α → (α → m Bool) → m (Option ℕ)",
  "offspring": ["ForIn.forIn", "ForInStep.done", "MProd.snd", "MProd.fst"],
  "name": "Array.findIdxM?"},
 {"type":
  "{α : Sort u} →\n  {C : α → Sort v} → {r : α → α → Prop} → WellFounded r → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → C x",
  "offspring": ["WellFounded.fix"],
  "name": "WellFounded.fix'"},
 {"type": "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → Option α",
  "offspring": ["Array.get?", "BinaryHeap.arr"],
  "name": "BinaryHeap.max"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → [self : MonadFunctor m n] → {α : Type u} → ({β : Type u} → m β → m β) → n α → n α",
  "offspring": [],
  "name": "MonadFunctor.monadMap"},
 {"type": "Mathlib.Tactic.Sat.LClause → Array ℤ",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LClause.lits"},
 {"type":
  "{m : Type u₁ → Type u₂} → {ρ : Type u} → {α : outParam (Type v)} → Sort u_1 → ForIn m ρ α → ForIn m ρ α → Sort u_1",
  "offspring": [],
  "name": "ForIn.noConfusionType"},
 {"type": "BEq ℕ", "offspring": ["BEq.mk", "Nat.beq"], "name": "instBEqNat"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_$__»"},
 {"type": "∀ {a b c : ℤ}, b < c - a → a + b < c",
  "offspring": [],
  "name": "Int.add_lt_of_lt_sub_left"},
 {"type": "∀ (m n : ℕ), Int.ofNat m = Int.ofNat n ↔ m = n",
  "offspring": ["Int.ofNat.inj"],
  "name": "Int.ofNat_eq_ofNat_iff"},
 {"type": "{α : Type u} → (α → α) → ℕ → α → α",
  "offspring": [],
  "name": "Nat.repeat"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (as : List α), List.equiv (List.insert a as) (a :: as)",
  "offspring": ["List.mem_insert_iff", "List.mem_cons"],
  "name": "List.insert_equiv_cons"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≥ b → b > c → a > c",
  "offspring": ["lt_of_lt_of_le"],
  "name": "gt_of_ge_of_gt"},
 {"type": "∀ (a b : UInt32), a - b = { val := a.val - b.val }",
  "offspring": [],
  "name": "UInt32.sub_def"},
 {"type": "{α : Sort u} → (x a : α) → x = a → α",
  "offspring": [],
  "name": "namedPattern"},
 {"type": "ByteSliceT → ℕ → UInt8",
  "offspring": ["ByteArray.get!", "ByteSliceT.arr", "ByteSliceT.off"],
  "name": "ByteSliceT.getOp"},
 {"type":
  "Lean.Meta.SimpExtension → Lean.Meta.SimpExtension → Lean.Meta.SimpExtension → Tactic.NormCast.NormCastExtension",
  "offspring": [],
  "name": "Tactic.NormCast.NormCastExtension.mk"},
 {"type": "∀ (a : ℤ), Int.sign a = 0 ↔ a = 0",
  "offspring": ["Int.eq_zero_of_sign_eq_zero", "Int.sign_zero"],
  "name": "Int.sign_eq_zero_iff_zero"},
 {"type": "∀ (p : Prop), (True ∨ p) = True",
  "offspring": ["trivial"],
  "name": "true_or"},
 {"type": "{α : Sort u} → {a : α} → {β : Sort v} → β → CoeDep α a β",
  "offspring": [],
  "name": "CoeDep.mk"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → Option α × List α",
  "offspring": [],
  "name": "List.extractp"},
 {"type": "{α β : Type u} → [inst : Inhabited β] → ((α → β) → α → β) → α → β",
  "offspring": ["fixCore1", "Inhabited.default"],
  "name": "fix"},
 {"type":
  "{α : Type u_1} → {m : Type u_1 → Type u_2} → [inst : Monad m] → m (Option α) → m α → m α",
  "offspring": ["Option.melim"],
  "name": "Option.mgetD"},
 {"type": "∀ (m : ℕ) {n : ℕ}, 0 < n → m * n / n = m",
  "offspring": ["Nat.mul_div_right"],
  "name": "Nat.mul_div_left"},
 {"type": "∀ {α : Sort u} {r : α → α → Prop} {z : α}, Acc r z → Acc (TC r) z",
  "offspring": ["TC.accessible.proof_1"],
  "name": "TC.accessible"},
 {"type":
  "(float : Type) → float → (lt le : float → float → Prop) → DecidableRel lt → DecidableRel le → FloatSpec",
  "offspring": [],
  "name": "FloatSpec.mk"},
 {"type":
  "{α : Type u} → (a : Array α) → Fin (Array.size a) → Fin (Array.size a) → Array α",
  "offspring": ["Array.set", "Array.swap.proof_1", "Array.get"],
  "name": "Array.swap"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "List.«term_<:+:_»"},
 {"type": "∀ {α : Type u_1} {o : Option α} {a b : α}, a ∈ o → b ∈ o → a = b",
  "offspring": ["Option.some.inj"],
  "name": "Option.mem_unique"},
 {"type":
  "{α σ : Type u} → {m : Type u → Type v} → [inst : Monad m] → StateCpsT σ m α → σ → m α",
  "offspring": ["StateCpsT.runK"],
  "name": "StateCpsT.run'"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → Sort u_1 → MonadFunctor m n → MonadFunctor m n → Sort u_1",
  "offspring": [],
  "name": "MonadFunctor.noConfusionType"},
 {"type": "Type u_1 → Function.injective some",
  "offspring": ["Option.some_inj"],
  "name": "Option.some_injective"},
 {"type": "Int.natAbs 0 = 0", "offspring": [], "name": "Int.natAbs_zero"},
 {"type":
  "{α : Type u} →\n  {m : Type → Type w} →\n    [inst : Monad m] → (α → m Bool) → (as : Array α) → (stop : ℕ) → stop ≤ Array.size as → ℕ → m Bool",
  "offspring":
  ["WellFounded.fix",
   "Array.anyM.loop.proof_1",
   "Array.get",
   "Array.anyM.loop.proof_2",
   "Array.anyM.loop.proof_3"],
  "name": "Array.anyM.loop"},
 {"type": "∀ {α : Type u_1} (l₁ l₂ : List α), l₂ ⊆ l₁ ++ l₂",
  "offspring": ["List.mem_append_right"],
  "name": "List.subset_append_right"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i j : Fin (Array.size a)), Array.size (Array.swap a i j) = Array.size a",
  "offspring": [],
  "name": "Array.size_swap"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_&&&_»"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (x : Option α) → ((a : α) → a ∈ x → Option β) → Option β",
  "offspring": ["Option.pbind.proof_1"],
  "name": "Option.pbind"},
 {"type": "∀ {a : ℤ}, a ≤ 0 → ↑(Int.natAbs a) = -a",
  "offspring":
  ["Int.natAbs_neg", "Int.natAbs_of_nonneg", "Int.neg_nonneg_of_nonpos"],
  "name": "Int.ofNat_natAbs_of_nonpos"},
 {"type": "∀ {n : ℕ}, n > 0 → ∀ {i j : ℕ}, i ≤ j → n ^ i ≤ n ^ j",
  "offspring": ["Nat.le_or_eq_or_le_succ", "Nat.le_refl"],
  "name": "Nat.pow_le_pow_of_le_right"},
 {"type":
  "{v : Sat.Valuation} →\n  {l : Sat.Literal} → {p : Prop} → Sort u → Sat.Literal.reify v l p → Sat.Literal.reify v l p → Sort u",
  "offspring": [],
  "name": "Sat.Literal.reify.noConfusionType"},
 {"type": "∀ (a : USize), a * 1 = a",
  "offspring":
  ["USize.one_def", "USize.mul_def", "USize.mk", "mul_one", "USize.mk_val_eq"],
  "name": "USize.instSemiringUSize.proof_14"},
 {"type": "∀ (n k : ℕ), n ≤ n + k",
  "offspring": ["Nat.le_refl", "Nat.le_succ_of_le"],
  "name": "Nat.le_add_right"},
 {"type": "(n : ℕ) → OfNat ℕ n",
  "offspring": ["OfNat.mk"],
  "name": "instOfNatNat"},
 {"type": "USize → ℕ → USize", "offspring": ["USize.mk"], "name": "USize.modn"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : ℕ) (a : Fin n), Fin.ofNat' x (_ : 0 < n) * a = Fin.ofNat' (x * ↑a) (_ : 0 < n)",
  "offspring":
  ["Fin.eq_of_val_eq", "Fin.mul_def", "Nat.mod_eq_of_lt", "Nat.mul_mod"],
  "name": "Fin.nsmuls_eq"},
 {"type": "∀ {a b c : ℤ}, a ≤ b + c → -b + a ≤ c",
  "offspring": ["Int.add_comm", "Int.sub_left_le_of_le_add"],
  "name": "Int.neg_add_le_left_of_le_add"},
 {"type":
  "∀ {α : Type u} (as : List α) (a : α), List.length (List.concat as a) = List.length as + 1",
  "offspring": ["List.length_cons", "List.concat"],
  "name": "List.length_concat"},
 {"type":
  "{α : Type u_1} →\n  (self : UnionFind α) →\n    Fin (UnionFind.size self) →\n      (s : UnionFind α) ×\n        (root : Fin (UnionFind.size s)) ×'\n          UnionFind.size s = UnionFind.size self ∧ (Array.get s.arr root).parent = ↑root",
  "offspring": ["UnionFind.findAux"],
  "name": "UnionFind.find"},
 {"type": "{A : Type u} → [self : AddMonoid A] → Zero A",
  "offspring": [],
  "name": "AddMonoid.toZero"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → ¬b ≤ a → a < b",
  "offspring": ["lt_iff_le_not_le"],
  "name": "lt_of_le_not_le"},
 {"type": "{G : Type u} → [self : CommGroup G] → Group G",
  "offspring": [],
  "name": "CommGroup.toGroup"},
 {"type": "UInt64 → Float", "offspring": [], "name": "UInt64.toFloat"},
 {"type": "∀ {n k : ℕ}, 0 < k → n < k + n",
  "offspring": ["Nat.lt_add_of_pos_right"],
  "name": "Nat.lt_add_of_pos_left"},
 {"type":
  "∀ {α : Sort u} {s : Setoid α} {motive : Quotient s → Prop},\n  (∀ (a : α), motive (Quotient.mk s a)) → ∀ (q : Quot Setoid.r), motive q",
  "offspring": ["Quot.ind"],
  "name": "Quotient.ind"},
 {"type": "∀ (m n : ℕ), -[1+ m] * Int.ofNat n = Int.negOfNat (Nat.succ m * n)",
  "offspring": [],
  "name": "Int.negSucc_ofNat_ofNat"},
 {"type": "(a b : Float) → Decidable (a < b)",
  "offspring": [],
  "name": "Float.decLt"},
 {"type": "{α : Type u_1} → [inst : ToString α] → Lean.ToFormat α",
  "offspring": [],
  "name": "instToFormat"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → α → List α → ℕ",
  "offspring": ["List.countp"],
  "name": "List.count"},
 {"type":
  "{ε σ δ : Type u} →\n  [inst : EStateM.Backtrackable δ σ] → {α : Type u} → EStateM ε σ α → (ε → EStateM ε σ α) → EStateM ε σ α",
  "offspring":
  ["EStateM.Result.ok",
   "EStateM.Backtrackable.restore",
   "EStateM.Backtrackable.save"],
  "name": "EStateM.tryCatch"},
 {"type": "Complement UInt16",
  "offspring": ["Complement.mk", "UInt16.complement"],
  "name": "instComplementUInt16"},
 {"type":
  "∀ {α : Sort u_2} {β : α → Sort u_1} {f₁ f₂ : (x : α) → β x}, f₁ = f₂ ↔ ∀ (a : α), f₁ a = f₂ a",
  "offspring": [],
  "name": "Function.funext_iff"},
 {"type": "Repr Bool", "offspring": [], "name": "instReprBool"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.«tacticExt___:_»"},
 {"type": "UInt16 → ℕ → UInt16",
  "offspring": ["UInt16.mk"],
  "name": "UInt16.modn"},
 {"type":
  "{α : Type u} →\n  {m : Type → Type w} →\n    [inst : Monad m] → (α → m Bool) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m Bool",
  "offspring": [],
  "name": "Array.anyMUnsafe"},
 {"type": "∀ (a : ℤ), a < a + 1",
  "offspring": ["Int.le_refl"],
  "name": "Int.lt_succ"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → [self : MonadControlT m n] → {α : Type u} → stM m n α → n α",
  "offspring": [],
  "name": "MonadControlT.restoreM"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x y : Fin (UnionFind.size self)),\n  ↑y <\n    Array.size\n      (Array.set self.arr x\n        { parent := ↑y, value := (Array.get self.arr x).value, rank := (Array.get self.arr x).rank })",
  "offspring":
  ["Array.size_set",
   "UFNode.mk",
   "UFNode.value",
   "Array.get",
   "UFNode.rank",
   "Fin.isLt"],
  "name": "UnionFind.link.proof_2"},
 {"type": "ℕ × ℕ", "offspring": [], "name": "stdRange"},
 {"type": "Fin USize.size → USize", "offspring": [], "name": "USize.mk"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "termℕ"},
 {"type": "∀ {G : Type u} [inst : Group G] (a : G), a⁻¹ * a = 1",
  "offspring": ["Group.mul_left_inv"],
  "name": "mul_left_inv"},
 {"type": "∀ {a : Prop}, ¬¬¬a → ¬a",
  "offspring": ["not_not_intro"],
  "name": "not_of_not_not_not"},
 {"type": "ByteArray → ℕ → ByteArray → ℕ → ℕ → optParam Bool true → ByteArray",
  "offspring": ["ByteArray.mk", "Array.extract", "ByteArray.data"],
  "name": "ByteArray.copySlice"},
 {"type":
  "(ρ : Type u) → (m : Type u → Type v) → [inst : MonadReaderOf ρ m] → MonadReader ρ m",
  "offspring": ["MonadReader.mk", "readThe"],
  "name": "instMonadReader"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : Fin n), npow_rec 0 x = npow_rec 0 x",
  "offspring": [],
  "name": "instMonoidWithZeroFin.proof_2"},
 {"type": "System.FilePath → IO (Array IO.FS.DirEntry)",
  "offspring": [],
  "name": "System.FilePath.readDir"},
 {"type": "Type u✝ → Type u✝", "offspring": [], "name": "One"},
 {"type": "Mul UInt8",
  "offspring": ["Mul.mk", "UInt8.mul"],
  "name": "instMulUInt8"},
 {"type":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ) (a : R),\n  AddGroupWithOne.gsmul -[1+ n] a = -AddGroupWithOne.gsmul (Int.ofNat (Nat.succ n)) a",
  "offspring": [],
  "name": "AddGroupWithOne.gsmul_neg'"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : Array α), (Array.isEqv a a fun x y => decide (x = y)) = true",
  "offspring": ["dite_congr", "Array.isEqvAux_self", "dite_true"],
  "name": "Array.isEqv_self"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a : β) (b : α),\n  Sum.inr a = Sum.inl b → Sum.noConfusionType False (Sum.inr a) (Sum.inl b)",
  "offspring": [],
  "name": "instDecidableEqSum.proof_5"},
 {"type": "∀ {α : Type u_1}, [] = []",
  "offspring": [],
  "name": "List.getLast.proof_1"},
 {"type": "∀ (p : Prop) [inst : Decidable p], p ∨ ¬p",
  "offspring": [],
  "name": "dec_em"},
 {"type": "LawfulFunctor Set",
  "offspring": ["LawfulFunctor.mk", "Functor.map"],
  "name": "Set.instLawfulFunctorSetInstFunctorSet.proof_1"},
 {"type": "Hashable Bool",
  "offspring": ["Hashable.mk"],
  "name": "instHashableBool"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Hashable α] → [inst : Hashable β] → Hashable (α × β)",
  "offspring": ["Hashable.mk", "mixHash", "Hashable.hash"],
  "name": "instHashableProd"},
 {"type": "{C : Sort u_1} → Empty → C",
  "offspring": ["sorryAx"],
  "name": "Empty.elim"},
 {"type": "∀ {A : Type u} [self : AddCommMonoid A] (a b : A), a + b = b + a",
  "offspring": [],
  "name": "AddCommMonoid.add_comm"},
 {"type": "{α : Sort u} → PLift α → α", "offspring": [], "name": "PLift.down"},
 {"type":
  "∀ (hyps : Array Lean.Expr) (isConditional : Bool) (lhs rhs : Lean.Expr),\n  sizeOf { hyps := hyps, isConditional := isConditional, lhs := lhs, rhs := rhs } =\n    1 + sizeOf hyps + sizeOf isConditional + sizeOf lhs + sizeOf rhs",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.mk.sizeOf_spec"},
 {"type":
  "(ρ : Type u) → (m : Type u → Type v) → [inst : MonadWithReaderOf ρ m] → MonadWithReader ρ m",
  "offspring": ["MonadWithReader.mk", "withTheReader"],
  "name": "instMonadWithReader"},
 {"type": "ℤ → ℕ → ℤ", "offspring": [], "name": "Int.pow"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : List α) → List.Pairwise R a → Prop},\n  List.Pairwise.below (_ : List.Pairwise R [])",
  "offspring": [],
  "name": "List.Pairwise.below.nil"},
 {"type": "{α : Sort u} → {β : Sort v} → α → α ⊕' β",
  "offspring": [],
  "name": "PSum.inl"},
 {"type": "{α : Type u} → CoeTail α (Option α)",
  "offspring": ["CoeTail.mk"],
  "name": "optionCoe"},
 {"type": "ByteSliceT → ℕ", "offspring": [], "name": "ByteSliceT.off"},
 {"type": "LE ℤ", "offspring": ["LE.mk", "Int.le"], "name": "Int.instLEInt"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type w} → {β : Type u} → (α → m β) → Option α → m (Option β)",
  "offspring": ["Option.maybe", "Option.map"],
  "name": "Option.mmap"},
 {"type":
  "{M₀ : Type u} → Sort u_1 → MulZeroOneClass M₀ → MulZeroOneClass M₀ → Sort u_1",
  "offspring": [],
  "name": "MulZeroOneClass.noConfusionType"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["cond"],
  "name": "Set.setOf.unexpander"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.equiv"},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (q : Quot r) →\n        (f : (a : α) → motive (Quot.mk r a)) →\n          (∀ (a b : α), r a b → (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b) → motive q",
  "offspring": ["Quot.rec"],
  "name": "Quot.recOn"},
 {"type": "Substring → Char",
  "offspring": ["Substring.get"],
  "name": "Substring.front"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticFunext__"},
 {"type":
  "∀ {m : Type u → Type v} [inst : Monad m] [self : LawfulMonad m] {α β : Type u} (f : m (α → β)) (x : m α),\n  (do\n      let a ← f\n      a <$> x) =\n    Seq.seq f fun x_1 => x",
  "offspring": [],
  "name": "LawfulMonad.bind_map"},
 {"type":
  "{m : Type u_1 → Type u_2} → {α σ : Type u_1} → [inst : Monad m] → m α → StateCpsT σ m α",
  "offspring": [],
  "name": "StateCpsT.lift"},
 {"type": "∀ {n m : ℕ} (k : ℕ), n ≤ m → n * k ≤ m * k",
  "offspring": ["Nat.mul_le_mul_left"],
  "name": "Nat.mul_le_mul_right"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] (a : A), -a + a = 0",
  "offspring": ["AddGroup.add_left_neg"],
  "name": "add_left_neg"},
 {"type": "∀ {α : Type u_1} {a : α} {l₁ l₂ : List α}, a :: l₁ ⊆ l₂ → l₁ ⊆ l₂",
  "offspring": ["List.mem_cons_of_mem"],
  "name": "List.subset_of_cons_subset"},
 {"type": "Inhabited ℕ", "offspring": [], "name": "instInhabitedNat"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "rawNatLit"},
 {"type": "ByteArray → ByteSlice",
  "offspring": ["ByteSlice.mk", "ByteArray.size"],
  "name": "ByteArray.toSlice"},
 {"type": "{α : Type u} → Array α → ℕ → Option α",
  "offspring": ["Array.get"],
  "name": "Array.get?"},
 {"type":
  "{α : Type u} →\n  [inst : Preorder α] →\n    [self : BoundedRandom α] →\n      {g : Type} → (lo hi : α) → lo ≤ hi → [inst_1 : RandomGen g] → RandG g { a // lo ≤ a ∧ a ≤ hi }",
  "offspring": [],
  "name": "BoundedRandom.randomR"},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeHead α β] → α → β",
  "offspring": [],
  "name": "CoeHead.coe"},
 {"type":
  "{A : Type u} → [inst : Add A] → (∀ (a b c : A), a + b = a + c → b = c) → IsAddLeftCancel A",
  "offspring": [],
  "name": "IsAddLeftCancel.mk"},
 {"type": "UInt64 → UInt64 → Prop", "offspring": [], "name": "UInt64.le"},
 {"type": "{α : Type u_1} → α → Set α",
  "offspring": ["setOf"],
  "name": "Set.singleton"},
 {"type": "∀ {n m k : ℕ}, n ≤ m → m ≤ k → n ≤ k",
  "offspring": ["Nat.le.step"],
  "name": "Nat.le_trans"},
 {"type": "∀ (p : Prop) [inst : Decidable p], ¬¬p ↔ p",
  "offspring": ["Decidable.of_not_not", "not_not_intro"],
  "name": "Decidable.not_not_iff"},
 {"type": "ByteArray → ByteSliceT",
  "offspring": ["ByteSliceT.mk"],
  "name": "ByteArray.toSliceT"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (l : List α), List.length (List.map f l) = List.length l",
  "offspring": ["List.length_nil", "List.length_cons", "List.map"],
  "name": "List.length_map"},
 {"type": "Array Lean.Syntax → (Lean.Syntax → Lean.Syntax) → Array Lean.Syntax",
  "offspring": ["Id.run", "Array.mapSepElemsM", "Id.instMonadId"],
  "name": "Array.mapSepElems"},
 {"type": "Substring → Substring",
  "offspring": ["Substring.dropRightWhile"],
  "name": "Substring.trimRight"},
 {"type": "ByteArray → (UInt8 → Bool) → ℕ → Option ℕ",
  "offspring": [],
  "name": "ByteArray.findIdx?.loop"},
 {"type": "USize → USize → USize",
  "offspring":
  ["USize.mk",
   "HShiftLeft.hShiftLeft",
   "USize.modn",
   "System.Platform.numBits"],
  "name": "USize.shiftLeft"},
 {"type":
  "∀ {lits : Array ℤ} {expr : Lean.Expr} {depth : ℕ} {lits_1 : Array ℤ} {expr_1 : Lean.Expr} {depth_1 : ℕ},\n  { lits := lits, expr := expr, depth := depth } = { lits := lits_1, expr := expr_1, depth := depth_1 } →\n    lits = lits_1 ∧ expr = expr_1 ∧ depth = depth_1",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LClause.mk.inj"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "coeNotation"},
 {"type": "{α : Type} → BaseIO α → α",
  "offspring": ["Empty", "EStateM.Result.error", "EStateM.run"],
  "name": "unsafeBaseIO"},
 {"type": "Inhabited PNonScalar",
  "offspring": ["PNonScalar.mk", "Inhabited.default", "instInhabitedNat"],
  "name": "instInhabitedPNonScalar"},
 {"type": "Semigroup UInt64",
  "offspring":
  ["Semigroup.mk", "instMulUInt64", "UInt64.instSemigroupUInt64.proof_1"],
  "name": "UInt64.instSemigroupUInt64"},
 {"type": "(Bool → Bool → Bool) → ℕ → ℕ → ℕ",
  "offspring": [],
  "name": "Nat.bitwise"},
 {"type": "{α : Type u} → (α → α → α) → (α → α → α) → Prop",
  "offspring": [],
  "name": "left_distributive"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → [inst : CoeSort α β] → CoeTail α β",
  "offspring": ["CoeTail.mk", "CoeSort.coe"],
  "name": "instCoeTail_1"},
 {"type":
  "{f : Type u → Type v} → Sort u_1 → SeqRight f → SeqRight f → Sort u_1",
  "offspring": [],
  "name": "SeqRight.noConfusionType"},
 {"type": "Substring → Substring → Bool",
  "offspring":
  ["instBEqNat", "Substring.bsize", "Substring.str", "Substring.startPos"],
  "name": "Substring.beq"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (stop : ℕ), stop ≤ Array.size as → ∀ (j : ℕ), j < stop → j < Array.size as",
  "offspring": ["Nat.lt_of_lt_of_le"],
  "name": "Array.foldlM.loop.proof_1"},
 {"type": "Coe Bool Prop", "offspring": ["Coe.mk"], "name": "boolToProp"},
 {"type":
  "∀ {α : Sort u_1} {β : Type u_2} (f : α → β) (p : α → Prop), Subtype.restrict f p = f ∘ Subtype.val",
  "offspring": [],
  "name": "Subtype.restrict_def"},
 {"type": "∀ {α : Type u_1} {s₁ s₂ t : List α}, s₁ ++ t = s₂ ++ t → s₁ = s₂",
  "offspring": ["List.append_inj_left'"],
  "name": "List.append_right_cancel"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop},\n  (∀ (x : { a // p a }), q x) ↔ ∀ (a : α) (b : p a), q { val := a, property := b }",
  "offspring": ["Subtype.mk"],
  "name": "Subtype.forall"},
 {"type":
  "{ε : outParam (Type u)} → {m : Type v → Type w} → Sort u_1 → MonadExcept ε m → MonadExcept ε m → Sort u_1",
  "offspring": [],
  "name": "MonadExcept.noConfusionType"},
 {"type": "Mod UInt32",
  "offspring": ["Mod.mk", "UInt32.mod"],
  "name": "instModUInt32"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) ↔ ∀ (x : α), ¬p x",
  "offspring": ["exists_imp_distrib"],
  "name": "not_exists"},
 {"type":
  "∀ {up down squash up_1 down_1 squash_1 : Lean.Meta.SimpExtension},\n  { up := up, down := down, squash := squash } = { up := up_1, down := down_1, squash := squash_1 } →\n    up = up_1 ∧ down = down_1 ∧ squash = squash_1",
  "offspring": [],
  "name": "Tactic.NormCast.NormCastExtension.mk.inj"},
 {"type":
  "∀ {v : Sat.Valuation} {l : Sat.Literal} {a : Prop} {c : Sat.Clause} {b : Prop},\n  Sat.Literal.reify v l a → Sat.Clause.reify v c b → Sat.Clause.reify v (Sat.Clause.cons l c) (a ∧ b)",
  "offspring":
  ["Sat.Clause.reify.mk",
   "Sat.Literal.reify.prop",
   "by_contra",
   "Not.elim",
   "Sat.Clause.reify.prop"],
  "name": "Sat.Clause.reify_and"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : ℕ) (x_1 : Fin n), npow_rec (Nat.succ x) x_1 = npow_rec (Nat.succ x) x_1",
  "offspring": [],
  "name": "instMonoidWithZeroFin.proof_3"},
 {"type": "(α : Sort u) → [i : α] → α",
  "offspring": [],
  "name": "inferInstanceAs"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (p : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (List.reverse p) = Nat.Linear.Poly.denote ctx p",
  "offspring":
  ["Nat.Linear.Poly.denote_reverseAux", "Nat.Linear.Poly", "List.append_nil"],
  "name": "Nat.Linear.Poly.denote_reverse"},
 {"type": "MonadFinally Id",
  "offspring": ["MonadFinally.mk"],
  "name": "Id.finally"},
 {"type": "Lean.Name → Lean.CoreM (Option Tactic.NormCast.CoeFnInfo)",
  "offspring": ["Tactic.NormCast.coeExt"],
  "name": "Tactic.NormCast.getCoeFnInfo?"},
 {"type": "outParam Type → (Type → Type) → Type",
  "offspring": [],
  "name": "STWorld"},
 {"type": "Substring → (Char → Bool) → Bool",
  "offspring": [],
  "name": "Substring.any"},
 {"type": "{α : Type u} → Subarray α → Array α",
  "offspring": [],
  "name": "Subarray.as"},
 {"type": "∀ (z x y : ℕ), z * x % (z * y) = z * (x % y)",
  "offspring":
  ["Nat.mul_zero", "Nat.mod_zero", "Nat.zero_mul", "Nat.strong_rec_on"],
  "name": "Nat.mul_mod_mul_left"},
 {"type":
  "∀ {α : Sort u_1} {r : α → α → Prop} {x y : α}, Acc r x → r y x → Acc r y",
  "offspring": [],
  "name": "Acc.inv.proof_1"},
 {"type": "Type → Type → Type → Type", "offspring": ["EStateM"], "name": "EST"},
 {"type": "∀ (as : FloatArray), FloatArray.size as ≤ FloatArray.size as",
  "offspring": ["Nat.le_refl", "FloatArray.size"],
  "name": "FloatArray.forIn.proof_1"},
 {"type": "(n m : ℕ) → Decidable (n = m)",
  "offspring":
  ["Nat.beq",
   "Nat.decEq.proof_1",
   "Nat.eq_of_beq_eq_true",
   "Nat.ne_of_beq_eq_false"],
  "name": "Nat.decEq"},
 {"type": "{α : Sort u} → {p : α → Prop} → (∃ x, p x) → α",
  "offspring": ["Subtype.val", "Classical.indefiniteDescription"],
  "name": "Classical.choose"},
 {"type": "ℤ → ℤ → ℤ", "offspring": ["Int.subNatNat"], "name": "Int.fmod"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : ℕ), i + 1 ≤ Array.size a → i ≤ Array.size a",
  "offspring": ["Nat.le_of_succ_le"],
  "name": "Array.toListLitAux.proof_1"},
 {"type":
  "{m : Type u → Type v} → {α β : Type u} → [inst : MonadFinally m] → [inst : Functor m] → m α → m β → m α",
  "offspring": ["Functor.map", "MonadFinally.tryFinally'"],
  "name": "tryFinally"},
 {"type":
  "∀ {σ α : Type u_1} [inst : Subsingleton σ] [inst : Subsingleton α], Subsingleton (StateM σ α)",
  "offspring": ["instSubsingletonStateM.proof_1"],
  "name": "instSubsingletonStateM"},
 {"type":
  "∀ {R : Type u} [self : AddGroupWithOne R] (a : R), AddGroupWithOne.gsmul 0 a = 0",
  "offspring": [],
  "name": "AddGroupWithOne.gsmul_zero'"},
 {"type": "ToString String.Iterator",
  "offspring": ["ToString.mk"],
  "name": "instToStringIterator"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → Option β → γ) → List α → List β → List γ × List β",
  "offspring": ["List.map"],
  "name": "List.map₂Left'"},
 {"type": "Type", "offspring": ["List"], "name": "Nat.Linear.Context"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → (ℕ → m Unit) → ℕ → m Unit",
  "offspring": [],
  "name": "Nat.forRevM.loop"},
 {"type":
  "∀ {n : ℕ} {motive : (a : ℕ) → Nat.le n a → Prop} {a : ℕ} (x : Nat.le n a),\n  (∀ (a : ℕ) (x : Nat.le n a), Nat.le.below x → motive a x) → motive a x",
  "offspring": ["Nat.le.below.refl", "Nat.le.below.step"],
  "name": "Nat.le.brecOn"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {l : List α} {a : α},\n  a ∈ l → p a → ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b) ∧ p a ∧ l = l₁ ++ a :: l₂ ∧ List.erasep p l = l₁ ++ l₂",
  "offspring":
  ["List.forall_mem_nil",
   "List.nil_append",
   "List.erasep_cons_of_pos",
   "and_self",
   "List.forall_mem_cons",
   "List.cons_append",
   "List.erasep_cons_of_neg"],
  "name": "List.exists_of_erasep"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (n_1 : ℕ), AddMonoidWithOne.natCast (n_1 + 1) = AddMonoidWithOne.natCast n_1 + 1",
  "offspring": ["AddMonoidWithOne.natCast_succ"],
  "name": "instAddGroupWithOneFin.proof_2"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2}, Function.LeftInverse Prod.swap Prod.swap",
  "offspring": ["Prod.swap_swap"],
  "name": "Prod.swap_LeftInverse"},
 {"type": "∀ (a b c : UInt64), (a + b) * c = a * c + b * c",
  "offspring":
  ["UInt64.add_def",
   "UInt64.mul_def",
   "UInt64.mk",
   "UInt64.eq_of_val_eq",
   "Distrib.right_distrib"],
  "name": "UInt64.instSemiringUInt64.proof_8"},
 {"type":
  "∀ (x : Mathlib.Tactic.Lint.LintVerbosity),\n  Mathlib.Tactic.Lint.LintVerbosity.ofNat (Mathlib.Tactic.Lint.LintVerbosity.toCtorIdx x) = x",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.ofNat_toCtorIdx"},
 {"type": "{α : Type u} → List α → Std.PersistentArray α",
  "offspring": ["List.toPersistentArrayAux"],
  "name": "List.toPersistentArray"},
 {"type":
  "{α : Sort u} → (rel : α → α → Prop) → WellFounded rel → WellFoundedRelation α",
  "offspring": [],
  "name": "WellFoundedRelation.mk"},
 {"type":
  "{ε σ α δ : Type u} → [inst : EStateM.Backtrackable δ σ] → OrElse (EStateM ε σ α)",
  "offspring": ["OrElse.mk", "EStateM.orElse"],
  "name": "EStateM.instOrElseEStateM"},
 {"type":
  "{f : Type u → Type v} → {α : Type u} → [inst : Functor f] → f α → f PUnit",
  "offspring": ["Functor.mapConst"],
  "name": "Functor.discard"},
 {"type": "List Bool → Bool", "offspring": ["List.any"], "name": "List.or"},
 {"type": "Array Float → FloatArray", "offspring": [], "name": "FloatArray.mk"},
 {"type":
  "{α : Sort u} → {a : α} → {β : Sort u} → {a_1 : β} → Sort u_1 → HEq a a_1 → HEq a a_1 → Sort u_1",
  "offspring": [],
  "name": "HEq.noConfusionType"},
 {"type": "∀ {a b : Prop}, a → (a ∧ b ↔ b)",
  "offspring": [],
  "name": "and_iff_right"},
 {"type":
  "∀ (x x_1 x_2 : UInt32), { val := (x + x_1 + x_2).1 } = { val := (x + (x_1 + x_2)).1 }",
  "offspring": ["UInt32.mk", "AddSemigroup.add_assoc"],
  "name": "UInt32.instAddSemigroupUInt32.proof_1"},
 {"type": "Pow ℕ ℕ", "offspring": ["Pow.mk", "Nat.pow"], "name": "instPowNat"},
 {"type":
  "∀ {R : Type u} [self : AddGroupWithOne R] (n : ℕ), AddGroupWithOne.intCast (Int.ofNat n) = AddMonoidWithOne.natCast n",
  "offspring": [],
  "name": "AddGroupWithOne.intCast_ofNat"},
 {"type":
  "∀ {α : Type u_1} [inst : SizeOf α] (a : Thunk α), sizeOf a = 1 + sizeOf (Thunk.get a)",
  "offspring": [],
  "name": "Thunk.sizeOf_eq"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.LeftInverse f g ↔ f ∘ g = id",
  "offspring": ["Function.LeftInverse.comp_eq_id", "congr_fun"],
  "name": "Function.LeftInverse_iff_comp"},
 {"type": "∀ (a : ℤ), a * 1 = a",
  "offspring": ["Int.mul_comm", "Int.one_mul"],
  "name": "Int.mul_one"},
 {"type": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "offspring":
  ["MulZeroClass.mk", "MulZeroOneClass.zero_mul", "MulZeroOneClass.mul_zero"],
  "name": "MulZeroOneClass.toMulZeroClass"},
 {"type": "{α : Type u} → Sort u_1 → LT α → LT α → Sort u_1",
  "offspring": [],
  "name": "LT.noConfusionType"},
 {"type":
  "∀ {α : Type u} {β : Type u_1} [inst : Preorder α] [inst_1 : LinearOrder β] {a b : α} {c d : β},\n  (d < c → b < a) → a ≤ b → c ≤ d",
  "offspring": ["le_of_not_lt", "not_le_of_gt"],
  "name": "le_imp_le_of_lt_imp_lt"},
 {"type":
  "∀ {α : Sort u_1} {h : Decidable True} (t e : α), (if True then t else e) = t",
  "offspring": ["if_pos", "trivial"],
  "name": "if_true"},
 {"type":
  "{A : Type u} → [toAddSemigroup : AddSemigroup A] → (∀ (a b : A), a + b = b + a) → AddCommSemigroup A",
  "offspring": [],
  "name": "AddCommSemigroup.mk"},
 {"type": "{α : Type u} → List α → Array α",
  "offspring": [],
  "name": "Array.mk"},
 {"type":
  "(m : Type u → Type v) → (n : Type u → Type w) → [self : MonadControlT m n] → Type u → Type u",
  "offspring": [],
  "name": "MonadControlT.stM"},
 {"type":
  "{A : Type u} → [toSubNegMonoid : SubNegMonoid A] → (∀ (a : A), -a + a = 0) → AddGroup A",
  "offspring": [],
  "name": "AddGroup.mk"},
 {"type": "Sort u → Ordering → Ordering → Sort u",
  "offspring": ["noConfusionTypeEnum", "Ordering", "Ordering.toCtorIdx"],
  "name": "Ordering.noConfusionType"},
 {"type": "{α : Type u} → α → ForInStep α",
  "offspring": [],
  "name": "ForInStep.done"},
 {"type": "{α : Type u_1} → ℕ → List α → α → List α × List α",
  "offspring": [],
  "name": "List.splitAtD"},
 {"type": "Type u → Type u", "offspring": [], "name": "AndThen"},
 {"type":
  "{α : Sort u_1} → [inst : HasEquiv α] → (p : α → Prop) → HasEquiv (Subtype p)",
  "offspring": ["HasEquiv.mk", "HasEquiv.Equiv", "Subtype.val"],
  "name": "Subtype.instHasEquivSubtype"},
 {"type":
  "Lean.MVarId →\n  Lean.Meta.DiscrTree Lean.Name → optParam ℕ 6 → Lean.MetaM (Option (Array (Lean.MetavarContext × List Lean.MVarId)))",
  "offspring":
  ["MonadState.get",
   "MonadExcept.tryCatch",
   "DoResultPR.return",
   "MonadStateOf.set",
   "DoResultPR.pure",
   "ForIn.forIn",
   "Sum.inr",
   "Sum.inl",
   "ForInStep",
   "MProd",
   "ForInStep.done",
   "Array.push",
   "MProd.snd",
   "MProd.fst"],
  "name": "Tactic.LibrarySearch.librarySearch"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["Fin.sub.proof_1"],
  "name": "Fin.sub"},
 {"type": "{n : ℕ} → BoundedRandom (Fin n)",
  "offspring":
  ["BoundedRandom.mk",
   "Random.randBound",
   "Random.instBoundedRandomNatToPreorderToPartialOrderInstLinearOrderNat",
   "RandG",
   "Subtype",
   "Subtype.mk",
   "Random.instBoundedRandomFinToPreorderToPartialOrderInstLinearOrderFin.proof_1",
   "Random.instBoundedRandomFinToPreorderToPartialOrderInstLinearOrderFin.proof_2"],
  "name":
  "Random.instBoundedRandomFinToPreorderToPartialOrderInstLinearOrderFin"},
 {"type": "{ε : Type u} → {α : Type u_1} → Except ε α → Option α",
  "offspring": [],
  "name": "Except.toOption"},
 {"type": "∀ {α β : Type u_1} (x : Id α) (f : α → id β), x >>= f = f x",
  "offspring": [],
  "name": "Id.bind_eq"},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α → List α",
  "offspring": ["List.elem", "List.erase"],
  "name": "List.bagInter"},
 {"type": "∀ {a : Prop}, a → (¬a ↔ False)",
  "offspring": ["iff_false_intro", "not_not_intro"],
  "name": "not_iff_false_intro"},
 {"type": "Sat.Valuation → Sat.Clause → Prop → Prop",
  "offspring": [],
  "name": "Sat.Clause.reify"},
 {"type": "Lean.Expr → Lean.MetaM ℕ",
  "offspring": [],
  "name": "Tactic.NormCast.countCoes"},
 {"type":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∀ (a : α), p a) ↔ ∀ (a : α), q a)",
  "offspring": [],
  "name": "forall_congr'"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {l₁ : List α} (l₂ : List α),\n  (∀ (b : α), b ∈ l₁ → ¬p b) → List.erasep p (l₁ ++ l₂) = l₁ ++ List.erasep p l₂",
  "offspring":
  ["Subsingleton.elim",
   "List.cons_append",
   "List.erasep_cons_of_neg",
   "List.forall_mem_cons"],
  "name": "List.erasep_append_right"},
 {"type": "{m : Type u_1 → Type u_2} → ForIn m ByteSlice UInt8",
  "offspring": ["ForIn.mk", "ByteSlice.forIn.loop"],
  "name": "ByteSlice.instForInByteSliceUInt8"},
 {"type": "{α : Type u} → [inst : Inhabited α] → Array α → α",
  "offspring": ["Array.get!"],
  "name": "Array.back"},
 {"type": "(fun n => { val := ↑n }) 0 = (fun n => { val := ↑n }) 0",
  "offspring": [],
  "name": "UInt64.instSemiringUInt64.proof_11"},
 {"type": "∀ {n : ℕ}, Nat.le n n", "offspring": [], "name": "Nat.le.refl"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_|>_»"},
 {"type": "∀ (a : ℤ), 0 + a = a",
  "offspring": ["Int.add_zero", "Int.add_comm"],
  "name": "Int.zero_add"},
 {"type": "Unit → { n // n = 32 ∨ n = 64 }",
  "offspring": [],
  "name": "System.Platform.getNumBits"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_4} {δ : Type u_2} (f : α → γ) (g : β → δ),\n  Prod.snd ∘ Prod.map f g = g ∘ Prod.snd",
  "offspring": ["Prod.map_snd"],
  "name": "Prod.map_snd'"},
 {"type": "Substring → ℕ → Substring",
  "offspring": ["Substring.mk", "Substring.nextn"],
  "name": "Substring.drop"},
 {"type": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), c + a ≤ c + b",
  "offspring": ["Int.le.intro", "Int.add_assoc", "Int.le.dest"],
  "name": "Int.add_le_add_left"},
 {"type": "∀ {a b c : ℤ}, a ≤ b + c → a - c ≤ b",
  "offspring": [],
  "name": "Int.sub_right_le_of_le_add"},
 {"type": "Hashable String",
  "offspring": ["Hashable.mk"],
  "name": "instHashableString"},
 {"type":
  "∀ (f : Type u → Type v) [inst : Functor f] [inst_1 : LawfulFunctor f] {α β : Type u} (h : α ≃ β) (y : f β),\n  Equiv.toFun (Equiv.symm (Functor.map_equiv f h)) y = (Equiv.symm h).toFun <$> y",
  "offspring": [],
  "name": "Functor.map_equiv_symm_apply"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α) (b : α) (bs : List α), ¬as = bs → a :: as = b :: bs → False",
  "offspring": [],
  "name": "List.hasDecEq.proof_5"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk", "Fin.lor", "UInt8.size"],
  "name": "UInt8.lor"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], (a → b) → ¬a ∨ b",
  "offspring": [],
  "name": "Decidable.not_or_of_imp"},
 {"type": "∀ {a : Prop}, ¬¬a ↔ a",
  "offspring": ["Decidable.not_not"],
  "name": "not_not"},
 {"type": "{α : Sort u} → [inst : Setoid α] → HasEquiv α",
  "offspring": ["HasEquiv.mk", "Setoid.r"],
  "name": "instHasEquiv"},
 {"type": "∀ {a b c d : Prop}, (a ↔ c) → (b ↔ d) → ((a ↔ b) ↔ (c ↔ d))",
  "offspring": ["Iff.trans", "Iff.symm"],
  "name": "iff_congr"},
 {"type": "{α : Sort u_1} → {γ : Sort u_2} → (r : α → γ → Prop) → Trans Eq r r",
  "offspring": ["Trans.mk", "instTransEq.proof_1"],
  "name": "instTransEq"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (a : α) (l : List α), List.map f (a :: l) = f a :: List.map f l",
  "offspring": [],
  "name": "List.map_cons"},
 {"type": "∀ {α : Type u_1} (a : Array α), List.toArray a.data = a",
  "offspring": ["Array.data", "Array.ext'", "List.toArray_data"],
  "name": "Array.data_toArray"},
 {"type": "Ring UInt64",
  "offspring":
  ["Ring.mk",
   "UInt64.instSemiringUInt64",
   "UInt64.instNegUInt64",
   "instSubUInt64",
   "UInt64.instRingUInt64.proof_1",
   "UInt64.mk",
   "Ring.gsmul",
   "UInt64.instRingUInt64.proof_3",
   "UInt64.instRingUInt64.proof_4",
   "UInt64.instRingUInt64.proof_5",
   "UInt64.instRingUInt64.proof_6",
   "Int.cast",
   "UInt64.instRingUInt64.proof_7",
   "UInt64.instRingUInt64.proof_8"],
  "name": "UInt64.instRingUInt64"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {ra : α → α → Prop} {rb : β → β → Prop} (a b : α × β),\n  Prod.RProd ra rb a b → Prod.Lex ra rb a b",
  "offspring": ["Prod.Lex.left"],
  "name": "Prod.RProdSubLex.proof_1"},
 {"type": "{α : Type u_1} → Array α → (α → α → Bool) → Option α",
  "offspring": ["Array.foldl", "Array.get"],
  "name": "Array.getMax?"},
 {"type": "Inhabited Mathlib.Tactic.Lint.LintVerbosity",
  "offspring": ["Mathlib.Tactic.Lint.LintVerbosity.low"],
  "name": "Mathlib.Tactic.Lint.instInhabitedLintVerbosity"},
 {"type": "∀ {a b c : ℤ}, a < b + c → a - b < c",
  "offspring": [],
  "name": "Int.sub_left_lt_of_lt_add"},
 {"type": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "offspring": [],
  "name": "Eq.symm"},
 {"type": "{m : Type → Type} → [inst : Monad m] → m Bool → m Lean.LBool",
  "offspring": ["Bool.toLBool"],
  "name": "toLBoolM"},
 {"type": "∀ (b : Bool), (b || b) = b",
  "offspring": [],
  "name": "Bool.or_self"},
 {"type": "Nat.Linear.ExprCnstr → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.lhs"},
 {"type": "∀ {m k : ℕ} (n : ℕ), m ∣ k → Nat.gcd m n ∣ Nat.gcd k n",
  "offspring":
  ["Nat.dvd_gcd", "Nat.dvd_trans", "Nat.gcd_dvd_left", "Nat.gcd_dvd_right"],
  "name": "Nat.gcd_dvd_gcd_of_dvd_left"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "List.«term_<+:_»"},
 {"type": "∀ {a b c : Prop}, (a ∨ b) ∨ c ↔ (a ∨ c) ∨ b",
  "offspring": ["or_assoc", "or_comm", "Iff.rfl"],
  "name": "or.right_comm"},
 {"type":
  "{α σ : Type u} → {m : Type u → Type v} → [inst : Monad m] → StateCpsT σ m α → σ → m (α × σ)",
  "offspring": ["StateCpsT.runK"],
  "name": "StateCpsT.run"},
 {"type":
  "{α : Type u} → (p : α → Prop) → [inst : DecidablePred p] → CoeDep (α → Prop) p (α → Bool)",
  "offspring": ["CoeDep.mk", "Decidable.decide"],
  "name": "Decidable.predToBool"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → CommRing (Fin n)",
  "offspring":
  ["CommRing.mk", "instCommRingFin.proof_8", "CommSemiring", "AddGroupWithOne"],
  "name": "instCommRingFin"},
 {"type":
  "∀ {α : Sort u_2} {r : α → α → Prop} {motive : Quot r → Sort u_1} [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))]\n  (f : (a : α) → motive (Quot.mk r a)) (a b : α), r a b → (_ : Quot.mk r a = Quot.mk r b) ▸ f a = f b",
  "offspring": ["Subsingleton.elim"],
  "name": "Quot.recOnSubsingleton.proof_1"},
 {"type": "∀ {α : Type u_1} (a : Array α), Array.size a = Array.size a",
  "offspring": [],
  "name": "BinaryHeap.mkHeap.loop.proof_1"},
 {"type": "{α : Type u} → [self : Sub α] → α → α → α",
  "offspring": [],
  "name": "Sub.sub"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : BEq α] [inst_1 : BEq β] [inst_2 : LawfulBEq α] [inst_3 : LawfulBEq β],\n  LawfulBEq (α × β)",
  "offspring": ["LawfulBEq.mk", "beq_self_eq_true", "Bool.and_self"],
  "name": "instLawfulBEqProdInstBEqProd.proof_1"},
 {"type": "∀ (α : Sort u_1) (x : α), id (id x) = id (id x)",
  "offspring": [],
  "name": "Equiv.refl.proof_2"},
 {"type": "{R : Type u} → [self : AddGroupWithOne R] → Sub R",
  "offspring": [],
  "name": "AddGroupWithOne.toSub"},
 {"type": "∀ {a b : ℤ}, a - b < 0 → a < b",
  "offspring": [],
  "name": "Int.lt_of_sub_neg"},
 {"type":
  "System.FilePath → (optParam (System.FilePath → IO Bool) fun x => pure true) → IO (Array System.FilePath)",
  "offspring": ["Functor.map"],
  "name": "System.FilePath.walkDir"},
 {"type":
  "∀ {α : Type u_1} {a : α} {L : List (List α)}, a ∈ List.join L ↔ ∃ l, l ∈ L ∧ a ∈ l",
  "offspring":
  ["List.not_mem_nil",
   "false_and",
   "exists_false",
   "List.mem_append",
   "List.Mem.head",
   "List.Mem.tail"],
  "name": "List.mem_join"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.tacticExt_or_skip__"},
 {"type": "∀ (a : UInt16), { val := a.val } = a",
  "offspring": ["UInt16.size", "UInt16.mk"],
  "name": "UInt16.mk_val_eq"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term%[_|_]»"},
 {"type": "ℕ", "offspring": [], "name": "UInt32.size"},
 {"type": "(α : Type u) → [inst : Preorder α] → Type (max 1 u)",
  "offspring": [],
  "name": "BoundedRandom"},
 {"type":
  "∀ {α : Type u_1} (x : α) (p : α → Bool) (as bs : List α), x ∈ List.filterAux p as bs ↔ x ∈ as ∧ p x = true ∨ x ∈ bs",
  "offspring":
  ["List.mem_reverse",
   "List.not_mem_nil",
   "false_and",
   "false_or",
   "List.mem_cons"],
  "name": "List.mem_filterAux"},
 {"type": "Float → Float", "offspring": [], "name": "Float.asin"},
 {"type": "{α : Type u} → [self : AndOp α] → α → α → α",
  "offspring": [],
  "name": "AndOp.and"},
 {"type":
  "∀ {α : Type u} {β : Type v} {ra : α → α → Prop} {rb : β → β → Prop} (a b : α × β),\n  Prod.RProd ra rb a b → Prod.Lex ra rb a b",
  "offspring": ["Prod.RProdSubLex.proof_1"],
  "name": "Prod.RProdSubLex"},
 {"type": "Type u → Type u", "offspring": [], "name": "Group"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (β → β → β) → (α → β) → β → α → β",
  "offspring": [],
  "name": "Function.comp_right"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → (α → β → γ) → List α → List β → List γ",
  "offspring": [],
  "name": "List.zipWith"},
 {"type": "∀ {a b c : ℤ}, a - c ≤ b → a ≤ b + c",
  "offspring": [],
  "name": "Int.le_add_of_sub_right_le"},
 {"type": "(m : Type u → Type v) → [inst : Pure m] → MonadControlT m m",
  "offspring": ["MonadControlT.mk"],
  "name": "instMonadControlT_1"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HSub"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : Array α),\n  (Array.isEqv a b fun a b => decide (a = b)) = Array.isEqv a b fun a b => decide (a = b)",
  "offspring": ["Array.isEqv", "Decidable.decide"],
  "name": "Array.instDecidableEqArray.proof_1"},
 {"type": "∀ {a b c d : ℤ}, a < b → c ≤ d → a - d < b - c",
  "offspring": ["Int.add_lt_add_of_lt_of_le", "Int.neg_le_neg"],
  "name": "Int.sub_lt_sub_of_lt_of_le"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a b : Fin n), a + b = b + a",
  "offspring": ["AddCommMonoid.add_comm"],
  "name": "instCommSemiringFin.proof_1"},
 {"type": "Bool → UInt64", "offspring": [], "name": "Bool.toUInt64"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«command__Binder_predicate_____=>_»"},
 {"type": "Neg Float",
  "offspring": ["Neg.mk", "Float.neg"],
  "name": "instNegFloat"},
 {"type": "∀ {i n : ℕ}, i < n → n - 1 - i < n",
  "offspring":
  ["Nat.sub_sub", "Nat.sub_lt", "Nat.lt_of_lt_of_le", "Nat.zero_lt_succ"],
  "name": "Nat.sub_one_sub_lt"},
 {"type": "(Type u → Type v) → Type u → Type v",
  "offspring": ["Option"],
  "name": "OptionT"},
 {"type":
  "{α : Type u} → {β : Type v} → WellFoundedRelation α → WellFoundedRelation β → WellFoundedRelation (α × β)",
  "offspring":
  ["WellFoundedRelation.mk",
   "Prod.RProd",
   "WellFoundedRelation.rel",
   "Prod.rprod.proof_1"],
  "name": "Prod.rprod"},
 {"type": "∀ (n : ℕ), - -[1+ n] = Int.ofNat (Nat.succ n)",
  "offspring": [],
  "name": "Int.neg_neg_ofNat_succ"},
 {"type":
  "∀ {α : Type u_1} {arr : Array (UFNode α)} {n : ℕ} {m : UFModel n},\n  UFModel.Models arr m →\n    ∀ (i j : Fin n) (H : UFModel.rank m ↑i < UFModel.rank m ↑j) (hi : ↑i < Array.size arr) (x : UFNode α),\n      x.parent = ↑j →\n        x.rank = (Array.get arr { val := ↑i, isLt := hi }).rank →\n          UFModel.Models (Array.set arr { val := ↑i, isLt := hi } x) (UFModel.setParent m i j H)",
  "offspring":
  ["UFModel.Agrees.set",
   "instDecidableFalse",
   "Ne.symm",
   "ite_false",
   "ite_true",
   "UFModel.Agrees.get_eq"],
  "name": "UFModel.Models.setParent"},
 {"type":
  "{f : Type u → Type v} →\n  [toApplicative : Applicative f] → ({α : Type u} → f α) → ({α : Type u} → f α → (Unit → f α) → f α) → Alternative f",
  "offspring": [],
  "name": "Alternative.mk"},
 {"type": "{n : ℕ} → Sort u → Fin n → Fin n → Sort u",
  "offspring": [],
  "name": "Fin.noConfusionType"},
 {"type": "{α : Type u} → (α → α) → ℕ → α → α",
  "offspring": [],
  "name": "Nat.repeat.loop"},
 {"type": "∀ {n k : ℕ}, 0 < k → n < n + k",
  "offspring": ["Nat.add_lt_add_left"],
  "name": "Nat.lt_add_of_pos_right"},
 {"type":
  "∀ {α : Type u_1} (l₁ l₂ : List α) (a : α), l₁ <+ l₂ → a :: l₁ <+ a :: l₂",
  "offspring": [],
  "name": "List.sublist.cons2"},
 {"type": "NonemptyType → Type u",
  "offspring": ["Subtype.val"],
  "name": "NonemptyType.type"},
 {"type": "∀ (a : ℕ), sizeOf -[1+ a] = 1 + sizeOf a",
  "offspring": ["instSizeOfNat"],
  "name": "Int.negSucc.sizeOf_spec"},
 {"type": "{α : Type u} → [inst : DecidableEq α] → DecidableEq (List α)",
  "offspring": ["List.hasDecEq"],
  "name": "instDecidableEqList"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "termSudoSet_option___In_"},
 {"type": "∀ {m n : ℕ}, n ∣ m → Nat.gcd m n = n",
  "offspring": ["Nat.gcd_comm", "Nat.gcd_eq_left"],
  "name": "Nat.gcd_eq_right"},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] (n : ℕ) (a : M), a ^ Nat.succ n = a * a ^ n",
  "offspring": ["Monoid.npow_succ'"],
  "name": "pow_succ'"},
 {"type": "∀ (x : UInt64), { val := AddMonoid.nsmul 0 x.val } = { val := 0.1 }",
  "offspring": ["AddMonoid.nsmul_zero'"],
  "name": "UInt64.instSemiringUInt64.proof_4"},
 {"type": "∀ (x : ℕ), (fun a => a) (Int.ofNat x) = (fun a => a) (Int.ofNat x)",
  "offspring": [],
  "name": "Int.instCommRingInt.proof_9"},
 {"type": "Repr StdGen",
  "offspring": ["repr", "instReprNat"],
  "name": "instReprStdGen"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (c a x : α) (n : ℕ) (b a' b' : α),\n  c * a = a' → c * b = b' → c * Tactic.Ring.horner a x n b = Tactic.Ring.horner a' x n b'",
  "offspring": ["mul_add", "Semigroup.mul_assoc"],
  "name": "Tactic.Ring.horner_const_mul"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → {a : ℕ} → OfNat (Fin n) a",
  "offspring": ["OfNat.mk", "Fin.ofNat'", "Fin.size_positive'"],
  "name": "instOfNatFin"},
 {"type": "{α : Sort u} → {β : outParam (Sort v)} → (α → β) → CoeSort α β",
  "offspring": [],
  "name": "CoeSort.mk"},
 {"type":
  "∀ {p q : Prop} [inst : Decidable p] [inst : Decidable q], ¬(p ∧ q) ↔ ¬p ∨ ¬q",
  "offspring": ["Decidable.not_and_iff_or_not"],
  "name": "Decidable.not_and"},
 {"type": "ToString UInt8",
  "offspring": ["ToString.mk", "instToStringNat", "UInt8.toNat"],
  "name": "instToStringUInt8"},
 {"type": "∀ (n m : ℕ), Nat.succ n * m = n * m + m",
  "offspring": ["Nat.mul_succ", "Nat.add_succ", "Nat.add_right_comm"],
  "name": "Nat.succ_mul"},
 {"type": "∀ {α : Type u_1} (a : α) (l : List α), a :: l ≠ []",
  "offspring": [],
  "name": "List.cons_ne_nil"},
 {"type": "∀ (a b : ℕ), (¬a ≤ b) = (b + 1 ≤ a)",
  "offspring": ["Nat.gt_of_not_le", "Nat.not_le_of_gt"],
  "name": "Nat.not_le_eq"},
 {"type":
  "∀ (n : ℕ) (a : USize),\n  { val := AddMonoid.nsmul (Nat.succ n) a.val } = { val := (a + (fun n a => { val := AddMonoid.nsmul n a.val }) n a).1 }",
  "offspring": ["AddMonoid.nsmul_succ'"],
  "name": "USize.instSemiringUSize.proof_5"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β},\n  Function.surjective f → Function.RightInverse (Function.inv_fun f) f",
  "offspring": ["Function.inv_fun_eq"],
  "name": "Function.RightInverse_inv_fun"},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} → WellFounded r → {C : α → Sort v} → (a : α) → ((x : α) → ((y : α) → r y x → C y) → C x) → C a",
  "offspring": ["WellFounded.apply"],
  "name": "WellFounded.recursion"},
 {"type": "{α : Sort u} → {β : Sort v} → [inst : CoeTail α β] → CoeHTCT α β",
  "offspring": ["CoeHTCT.mk", "CoeTail.coe"],
  "name": "coeOfTail"},
 {"type": "∀ (a b : USize), a - b = { val := a.val - b.val }",
  "offspring": [],
  "name": "USize.sub_def"},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} → {p : α → Prop} → {q : β → Prop} → (f : α → β) → (∀ (a : α), p a → q (f a)) → Subtype p → Subtype q",
  "offspring": ["Subtype.mk", "Subtype.val", "Subtype.map.proof_1"],
  "name": "Subtype.map"},
 {"type":
  "∀ {α : Type u_1} (f : α → α) (n : ℕ) (l : List α),\n  List.modifyNth f n l = Option.getD ((fun a => List.set l n (f a)) <$> List.get? l n) l",
  "offspring": ["Functor.map", "Option.instFunctorOption", "congr_arg"],
  "name": "List.modifyNth_eq_set"},
 {"type": "∀ {m k n : ℕ}, 0 < n → n * m = n * k → m = k",
  "offspring": ["Nat.le_antisymm", "Nat.le_of_mul_le_mul_left", "Nat.le_of_eq"],
  "name": "Nat.eq_of_mul_eq_mul_left"},
 {"type": "∀ (m n : ℕ), m ≤ n ∨ n ≤ m",
  "offspring": ["Nat.lt_or_ge", "Nat.le_of_lt"],
  "name": "Nat.le_total"},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → ByteArray → β → (UInt8 → β → m (ForInStep β)) → m β",
  "offspring": ["USize.ofNat", "ByteArray.size"],
  "name": "ByteArray.forInUnsafe"},
 {"type": "∀ (p : Prop), Subsingleton (Decidable p)",
  "offspring": ["Subsingleton.intro"],
  "name": "instSubsingletonDecidable.proof_1"},
 {"type": "{n : ℕ} → OrOp (Fin n)",
  "offspring": ["OrOp.mk", "Fin.lor"],
  "name": "Fin.instOrOpFin"},
 {"type": "∀ {a b c d e f : ℤ}, a ≤ d → b ≤ e → c ≤ f → a + b + c ≤ d + e + f",
  "offspring": ["le_trans", "Int.add_le_add", "le_refl"],
  "name": "Int.add_le_add_three"},
 {"type": "Type u → Type", "offspring": [], "name": "ReprAtom"},
 {"type": "∀ (n : ℕ), n = 0 ∨ n > 0",
  "offspring": ["Nat.succ_pos"],
  "name": "Nat.eq_zero_or_pos"},
 {"type": "{α : Sort u} → [self : HasEquiv α] → α → α → Sort v",
  "offspring": [],
  "name": "HasEquiv.Equiv"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β} {x : α}, p.fst = x ↔ p = (x, p.snd)",
  "offspring": ["Prod.mk.injEq", "and_true"],
  "name": "Prod.fst_eq_iff"},
 {"type": "Nonempty (Fin USize.size)",
  "offspring": ["instNonempty", "USize.instInhabitedFinSize"],
  "name": "USize.instRingUSize.proof_2"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.«command#lintMathlibAll+-*Only__»"},
 {"type":
  "∀ {α : Type u} [inst : BEq α] [inst_1 : LawfulBEq α], LawfulBEq (List α)",
  "offspring": ["List.instLawfulBEqListInstBEqList.proof_1"],
  "name": "List.instLawfulBEqListInstBEqList"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.injective f → Function.injective (Option.map f)",
  "offspring": ["Option.some.inj"],
  "name": "Option.map_injective"},
 {"type":
  "{motive : Tactic.Ring.HornerExpr → Prop} → Tactic.Ring.HornerExpr → Prop",
  "offspring": [],
  "name": "Tactic.Ring.HornerExpr.ibelow"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {s : Set α} {b : β},\n  (¬∃ a, a ∈ s ∧ f a = b) → Function.inv_fun_on f s b = Classical.choice n",
  "offspring": [],
  "name": "Function.inv_fun_on_neg"},
 {"type": "{α : Type u} → [self : Inter α] → α → α → α",
  "offspring": [],
  "name": "Inter.inter"},
 {"type":
  "{α : Type u_1} → {x : BEq α} → {x_1 : Hashable α} → [inst : Repr α] → Repr (Lean.SSet α)",
  "offspring": ["reprArg"],
  "name": "instReprSSet"},
 {"type":
  "∀ {α : Type u_1} {parent : ℕ} {value : α} {rank parent_1 : ℕ} {value_1 : α} {rank_1 : ℕ},\n  { parent := parent, value := value, rank := rank } = { parent := parent_1, value := value_1, rank := rank_1 } →\n    parent = parent_1 ∧ value = value_1 ∧ rank = rank_1",
  "offspring": [],
  "name": "UFNode.mk.inj"},
 {"type": "{α : Sort u} → Sort u_1 → PLift α → PLift α → Sort u_1",
  "offspring": [],
  "name": "PLift.noConfusionType"},
 {"type": "{σ : Type u} → σ → DoResultBC σ",
  "offspring": [],
  "name": "DoResultBC.continue"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) {x y : α}, x = y → ¬f x = f y → False",
  "offspring": [],
  "name": "noConfusionEnum.proof_1"},
 {"type":
  "∀ {α : Sort u_1} {h : Decidable False} (t e : α), (if False then t else e) = e",
  "offspring": ["if_neg", "not_false"],
  "name": "if_false"},
 {"type": "Tactic.DeclCache (Lean.Meta.DiscrTree Lean.Name)",
  "offspring": [],
  "name": "Tactic.LibrarySearch.librarySearchLemmas"},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.buildReify.reifyClause1"},
 {"type": "∀ {p : Prop} [inst : Decidable p], ¬¬p → p",
  "offspring": ["Decidable.byContradiction"],
  "name": "Decidable.of_not_not"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk"],
  "name": "UInt32.mod"},
 {"type":
  "∀ {α : Type u_3} {β : Type u_4} {γ : Type u_1} {δ : Type u_2} (f : α → γ) (g : β → δ) (a : α) (b : β),\n  Prod.map f g (a, b) = (f a, g b)",
  "offspring": [],
  "name": "Prod.map_mk"},
 {"type":
  "∀ {α : Type u_1} {h₁ h₂ : α} {t₁ t₂ : List α}, h₁ :: t₁ = h₂ :: t₂ → h₁ = h₂",
  "offspring": [],
  "name": "List.head_eq_of_cons_eq"},
 {"type": "∀ {a : Prop}, ¬a → (a ↔ False)",
  "offspring": [],
  "name": "iff_false_intro"},
 {"type":
  "{f : Type u → Type v} →\n  [toFunctor : Functor f] →\n    [toPure : Pure f] → [toSeq : Seq f] → [toSeqLeft : SeqLeft f] → [toSeqRight : SeqRight f] → Applicative f",
  "offspring": [],
  "name": "Applicative.mk"},
 {"type": "∀ (n : ℕ), -[1+ n] = -(Int.ofNat n + 1)",
  "offspring": [],
  "name": "Int.negSucc_ofNat_eq"},
 {"type": "Type", "offspring": [], "name": "Int"},
 {"type": "LT UInt64",
  "offspring": ["LT.mk", "UInt64.lt"],
  "name": "instLTUInt64"},
 {"type":
  "{α : Type u} → {β : Type v} → (α → β → β) → β → (as : Array α) → optParam ℕ (Array.size as) → optParam ℕ 0 → β",
  "offspring": ["Id.run", "Array.foldrM", "Id.instMonadId"],
  "name": "Array.foldr"},
 {"type":
  "∀ {m : Type u → Type u_1} {β γ σ : Type u} [inst : Monad m] (f : σ → StateCpsT σ m β) (s : σ) (k : β → σ → m γ),\n  StateCpsT.runK (get >>= f) s k = StateCpsT.runK (f s) s k",
  "offspring": [],
  "name": "StateCpsT.runK_bind_get"},
 {"type": "Prop → Prop → Prop", "offspring": [], "name": "implies"},
 {"type": "(ds : FloatArray) → Fin (FloatArray.size ds) → Float",
  "offspring": ["Array.get"],
  "name": "FloatArray.get"},
 {"type": "(α : Sort u) → optParam Bool true → α",
  "offspring": [],
  "name": "sorryAx"},
 {"type":
  "∀ {a b c : Prop} [inst : Decidable b], a → b ∨ c ↔ (a → b) ∨ (a → c)",
  "offspring":
  ["true_or", "implies_true", "false_or", "Iff.symm", "or_iff_right_of_imp"],
  "name": "Decidable.imp_or_distrib'"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HMod α β γ] → α → β → γ",
  "offspring": [],
  "name": "HMod.hMod"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : ∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "offspring": ["instSubsingletonForAll.proof_1"],
  "name": "instSubsingletonForAll"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (m₁ m₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_eq ctx (Nat.Linear.Poly.cancel m₁ m₂) = Nat.Linear.Poly.denote_eq ctx (m₁, m₂)",
  "offspring":
  ["Nat.Linear.Poly.of_denote_eq_cancel", "Nat.Linear.Poly.denote_eq_cancel"],
  "name": "Nat.Linear.Poly.denote_eq_cancel_eq"},
 {"type": "{α : Type u_1} → (α → Bool) → Array α → Array α",
  "offspring":
  ["WellFounded.fix",
   "Array.popWhile.proof_1",
   "GT.gt",
   "Array.get",
   "Array.popWhile.proof_2",
   "Array.pop",
   "Array.popWhile.proof_3"],
  "name": "Array.popWhile"},
 {"type": "Type", "offspring": [], "name": "UInt16"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [self : LawfulApplicative f], LawfulFunctor f",
  "offspring": [],
  "name": "LawfulApplicative.toLawfulFunctor"},
 {"type": "Type u → Type u", "offspring": [], "name": "Subset"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HAppend α β γ → HAppend α β γ → Sort u_1",
  "offspring": [],
  "name": "HAppend.noConfusionType"},
 {"type": "∀ {α : Type u} {p : α → Prop}, (x : α) ×' p x → ∃ x, p x",
  "offspring": [],
  "name": "ex_of_PSigma"},
 {"type":
  "∀ {e : Lean.Expr} {a : Tactic.Ring.HornerExpr} {x n : Lean.Expr × ℕ} {b : Tactic.Ring.HornerExpr} {e_1 : Lean.Expr}\n  {a_1 : Tactic.Ring.HornerExpr} {x_1 n_1 : Lean.Expr × ℕ} {b_1 : Tactic.Ring.HornerExpr},\n  Tactic.Ring.HornerExpr.xadd e a x n b = Tactic.Ring.HornerExpr.xadd e_1 a_1 x_1 n_1 b_1 →\n    e = e_1 ∧ a = a_1 ∧ x = x_1 ∧ n = n_1 ∧ b = b_1",
  "offspring": [],
  "name": "Tactic.Ring.HornerExpr.xadd.inj"},
 {"type":
  "∀ (x : ℕ) (a : UInt64),\n  { val := Ring.gsmul (Int.ofNat (Nat.succ x)) a.val } =\n    { val := (a + (fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat x) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_succ'"],
  "name": "UInt64.instRingUInt64.proof_4"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : Subsingleton α], Function.injective Prod.snd",
  "offspring": ["Prod.ext'", "Subsingleton.elim"],
  "name": "Prod.snd_injective"},
 {"type": "ℕ → Nat.Linear.Expr → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.Expr.mulL"},
 {"type": "∀ {a : Prop}, ¬(¬a ∧ a)", "offspring": [], "name": "not_and_self"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.Perm"},
 {"type": "{α : Type u_1} → Sort u → UnionFind α → UnionFind α → Sort u",
  "offspring": [],
  "name": "UnionFind.noConfusionType"},
 {"type": "Type u → Type u", "offspring": ["OptionT"], "name": "OptionM"},
 {"type": "∀ {a b c : ℤ}, a + b < c → b < -a + c",
  "offspring": [],
  "name": "Int.lt_neg_add_of_add_lt"},
 {"type": "∀ {α : Type u_1} {l : List α} (a : 0 < List.length l), ∃ a, a ∈ l",
  "offspring": ["List.mem_cons_self"],
  "name": "List.exists_mem_of_length_pos"},
 {"type": "∀ (p : Prop), (True → p) = p",
  "offspring": ["trivial"],
  "name": "true_implies"},
 {"type": "Lean.Elab.Tactic.TacticM Unit",
  "offspring": [],
  "name": "evalIntrov.introsDep"},
 {"type": "Decidable True",
  "offspring": ["trivial"],
  "name": "instDecidableTrue"},
 {"type": "ℕ → ℤ", "offspring": [], "name": "Int.ofNat"},
 {"type":
  "{α : Sort u} → {β : Sort v} → [inst : CoeHTCT α β] → (a : α) → CoeT α a β",
  "offspring": ["CoeT.mk", "CoeHTCT.coe"],
  "name": "coeOfHTCT"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], ¬(a ∧ b) ↔ ¬a ∨ ¬b",
  "offspring": ["not_and_of_not_or_not"],
  "name": "Decidable.not_and_distrib"},
 {"type": "(fun a => a) 0 = (fun a => a) 0",
  "offspring": [],
  "name": "Nat.instCommSemiringNat.proof_2"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → Sort u_1 → MonadLift m n → MonadLift m n → Sort u_1",
  "offspring": [],
  "name": "MonadLift.noConfusionType"},
 {"type": "Neg UInt16",
  "offspring": ["Neg.mk", "UInt16.mk"],
  "name": "UInt16.instNegUInt16"},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] (a : α) (as : List α), a :: as < [] → False",
  "offspring": [],
  "name": "List.hasDecidableLt.proof_2"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (α → β → m (ForInStep β)) → List α → β → m β",
  "offspring": [],
  "name": "List.forIn.loop"},
 {"type":
  "{g : Type} → {n : ℕ} → [inst : RandomGen g] → RandG g (Fin (Nat.succ n))",
  "offspring": ["Prod.map", "Fin.ofNat", "ULift.up", "randNat"],
  "name": "Random.randFin"},
 {"type": "{α : Type u} → Sort u_1 → ForInStep α → ForInStep α → Sort u_1",
  "offspring": [],
  "name": "ForInStep.noConfusionType"},
 {"type": "{α : Type u_1} → (α → α) → List α → List α",
  "offspring": [],
  "name": "List.modifyLast"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] (a : A), - -a = a",
  "offspring": ["neg_eq_of_add_eq_zero", "add_left_neg"],
  "name": "neg_neg"},
 {"type": "Coe ℕ ℤ", "offspring": ["Coe.mk"], "name": "instCoeNatInt"},
 {"type":
  "{α : Type u} → Sort u_1 → EmptyCollection α → EmptyCollection α → Sort u_1",
  "offspring": [],
  "name": "EmptyCollection.noConfusionType"},
 {"type": "∀ (n m : ℕ), n - (n + m) = 0",
  "offspring": [],
  "name": "Nat.sub_self_add"},
 {"type": "∀ {M : Type u} [inst : Monoid M] (a : M), 1 * a = a",
  "offspring": ["Monoid.one_mul"],
  "name": "one_mul"},
 {"type":
  "{α : Sort u} → {β : Sort v} → Sort u_1 → PProd α β → PProd α β → Sort u_1",
  "offspring": [],
  "name": "PProd.noConfusionType"},
 {"type": "∀ {n m k : ℕ}, n + m = n + k ↔ m = k",
  "offspring": ["Nat.add_left_cancel"],
  "name": "Nat.add_left_cancel_iff"},
 {"type":
  "∀ {m : Type u → Type u_1} {α β : Type u} [inst : Monad m] [inst_1 : LawfulMonad m] (f : m (α → β)) (x : m α),\n  (Seq.seq f fun x_1 => x) = do\n    let a ← f\n    a <$> x",
  "offspring": ["LawfulMonad.bind_map"],
  "name": "seq_eq_bind_map"},
 {"type":
  "{ω σ : Type} → {m : Type → Type} → {α : Type} → m α → StateRefT' ω σ m α",
  "offspring": [],
  "name": "StateRefT'.lift"},
 {"type": "{α : Type u_1} → UnionFind α → ℕ → ℕ",
  "offspring": ["UnionFind.size", "UFNode.rank", "Array.get", "UnionFind.arr"],
  "name": "UnionFind.rank"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), (a + (n - b)) % n < n",
  "offspring": [],
  "name": "Fin.sub.proof_1"},
 {"type": "{σ : Type u} → σ → PUnit → σ",
  "offspring": [],
  "name": "EStateM.dummyRestore"},
 {"type":
  "∀ {numArgs coercee : ℕ} {type : Tactic.NormCast.CoeFnType} {numArgs_1 coercee_1 : ℕ}\n  {type_1 : Tactic.NormCast.CoeFnType},\n  { numArgs := numArgs, coercee := coercee, type := type } =\n      { numArgs := numArgs_1, coercee := coercee_1, type := type_1 } →\n    numArgs = numArgs_1 ∧ coercee = coercee_1 ∧ type = type_1",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnInfo.mk.inj"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_3} {γ : Sort u_2} {p : α → Prop} {q : β → Prop} {r : γ → Prop} {x : Subtype p} (f : α → β)\n  (h : ∀ (a : α), p a → q (f a)) (g : β → γ) (l : ∀ (a : β), q a → r (g a)),\n  Subtype.map g l (Subtype.map f h x) = Subtype.map (g ∘ f) (_ : ∀ (a : α), p a → r (g (f a))) x",
  "offspring": [],
  "name": "Subtype.map_comp"},
 {"type": "∀ (a b : ℕ), a + b - b = a",
  "offspring": ["Nat.add_sub_self_left"],
  "name": "Nat.add_sub_self_right"},
 {"type":
  "∀ {α : Sort uA} {β : Sort uB} {φ : Sort uC} {s₁ : Setoid α} {s₂ : Setoid β} {s₃ : Setoid φ}\n  {motive : Quotient s₁ → Quotient s₂ → Quotient s₃ → Prop} (q₁ : Quotient s₁) (q₂ : Quotient s₂) (q₃ : Quotient s₃),\n  (∀ (a : α) (b : β) (c : φ), motive (Quotient.mk s₁ a) (Quotient.mk s₂ b) (Quotient.mk s₃ c)) → motive q₁ q₂ q₃",
  "offspring": ["Quotient.ind"],
  "name": "Quotient.inductionOn₃"},
 {"type": "ℤ → ℤ → ℤ", "offspring": [], "name": "Int.mod"},
 {"type":
  "∀ {α : Type u} [inst : LT α] {motive : (a a_1 : List α) → List.lt a a_1 → Prop} {a : α} (as : List α) {b : α}\n  (bs : List α), a < b → List.lt.below (_ : List.lt (a :: as) (b :: bs))",
  "offspring": [],
  "name": "List.lt.below.head"},
 {"type": "∀ {b : Bool}, b = false → ¬b = true",
  "offspring": [],
  "name": "ne_true_of_eq_false"},
 {"type": "∀ (m n : ℕ), Nat.gcd m n ∣ m ∧ Nat.gcd m n ∣ n",
  "offspring":
  ["Nat.gcd.induction",
   "Nat.gcd_zero_left",
   "Nat.mul_zero",
   "Nat.mul_one",
   "Nat.gcd_rec",
   "Nat.dvd_mod_iff"],
  "name": "Nat.gcd_dvd"},
 {"type": "Sort u → ByteArray → ByteArray → Sort u",
  "offspring": [],
  "name": "ByteArray.noConfusionType"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → OptionT m α",
  "offspring": ["OptionT.mk"],
  "name": "OptionT.fail"},
 {"type": "(a b : UInt32) → Decidable (a < b)",
  "offspring": ["UInt32.decLt"],
  "name": "instDecidableLtUInt32InstLTUInt32"},
 {"type":
  "∀ {ε : Type u} {α : Type v} (a a_1 : α), (Except.ok a = Except.ok a_1) = (a = a_1)",
  "offspring": ["Except.ok"],
  "name": "Except.ok.injEq"},
 {"type": "Mod ℤ",
  "offspring": ["Mod.mk", "Int.mod"],
  "name": "Int.instModInt"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (n_1 : ℕ), AddMonoidWithOne.natCast (n_1 + 1) = AddMonoidWithOne.natCast n_1 + 1",
  "offspring": ["AddMonoidWithOne.natCast_succ"],
  "name": "instCommSemiringFin.proof_6"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) {n : ℕ} {m : UFModel n},\n  UFModel.Models self.arr m → ∀ {i : ℕ}, i < UnionFind.size self → UnionFind.rank self i = UFModel.rank m i",
  "offspring":
  ["dite_congr", "UFModel.Models.rank_eq", "Eq.mpr_prop", "dite_true"],
  "name": "UnionFind.rank_eq"},
 {"type": "LawfulMonad Id",
  "offspring": ["Id.instLawfulMonadIdInstMonadId.proof_1"],
  "name": "Id.instLawfulMonadIdInstMonadId"},
 {"type":
  "Lean.Name → optParam Lean.AttributeKind Lean.AttributeKind.global → optParam ℕ 1000 → Lean.MetaM Unit",
  "offspring":
  ["Tactic.NormCast.NormCastExtension.up", "Tactic.NormCast.normCastExt"],
  "name": "Tactic.NormCast.addElim"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [inst : BEq α] [inst_1 : BEq β] [inst_2 : LawfulBEq α] [inst_3 : LawfulBEq β],\n  LawfulBEq (α × β)",
  "offspring": ["instLawfulBEqProdInstBEqProd.proof_1"],
  "name": "instLawfulBEqProdInstBEqProd"},
 {"type": "ℕ → ℕ → ℕ", "offspring": [], "name": "Nat.add"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (i : ℕ), i + 1 ≤ Array.size as → i ≤ Array.size as",
  "offspring": ["Nat.le_of_lt", "Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "Array.forIn.loop.proof_2"},
 {"type":
  "{P : Sort u} → {x y : Tactic.NormCast.CoeFnType} → x = y → Tactic.NormCast.CoeFnType.noConfusionType P x y",
  "offspring": ["noConfusionEnum"],
  "name": "Tactic.NormCast.CoeFnType.noConfusion"},
 {"type": "BEq Nat.Linear.PolyCnstr",
  "offspring": ["BEq.mk", "Nat.Linear.Poly"],
  "name": "Nat.Linear.instBEqPolyCnstr"},
 {"type": "ByteArray → Bool",
  "offspring": ["instBEqNat", "ByteArray.size"],
  "name": "ByteArray.isEmpty"},
 {"type": "{α : Type u} → {β : Type v} → (α → β → α) → Pow α β",
  "offspring": [],
  "name": "Pow.mk"},
 {"type": "∀ {n m : ℕ}, n ≤ m → Nat.ble n m = true",
  "offspring": ["Nat.ble", "Nat.ble_self_eq_true", "Nat.ble_succ_eq_true"],
  "name": "Nat.ble_eq_true_of_le"},
 {"type": "Nat.zero = 0", "offspring": [], "name": "Nat.ctor_eq_zero"},
 {"type": "Mathlib.Tactic.Sat.Clause → Array ℤ",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Clause.lits"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (arr arr_1 : Array α), ({ arr := arr } = { arr := arr_1 }) = (arr = arr_1)",
  "offspring": ["BinaryHeap.mk"],
  "name": "BinaryHeap.mk.injEq"},
 {"type": "{α : Sort u_1} → {p : α → Prop} → Subtype p → α",
  "offspring": ["Subtype.val"],
  "name": "Subtype.simps.coe"},
 {"type":
  "(ρ : Type u) → {m : Type u → Type v} → [inst : MonadReaderOf ρ m] → m ρ",
  "offspring": ["MonadReaderOf.read"],
  "name": "readThe"},
 {"type": "{α : Type u} → [self : OrOp α] → α → α → α",
  "offspring": [],
  "name": "OrOp.or"},
 {"type": "ToString String",
  "offspring": ["ToString.mk"],
  "name": "instToStringString"},
 {"type":
  "∀ {ι : Sort u_1} [inst : DecidableEq ι] {α : ι → Sort u_2} {β : ι → Sort u_3} (f : (i : ι) → α i → β i)\n  (g : (i : ι) → α i) (i : ι) (v : α i) (j : ι),\n  f j (Function.update g i v j) = Function.update (fun k => f k (g k)) i (f i v) j",
  "offspring": ["Function.update_same", "Function.update_noteq", "ne_eq"],
  "name": "Function.apply_update"},
 {"type": "∀ (a : USize), 0 * a = 0",
  "offspring":
  ["USize.zero_def", "USize.mul_def", "USize.mk", "MonoidWithZero.zero_mul"],
  "name": "USize.instSemiringUSize.proof_9"},
 {"type":
  "∀ {β : Sort u_1} {α : Sort u_2} {y : β} {x : α}, Function.const α y x = y",
  "offspring": [],
  "name": "Function.const_apply"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.tacticRw_mod_cast____"},
 {"type": "{α : Type u} → Array α → ℕ",
  "offspring": ["Array.data"],
  "name": "Array.size"},
 {"type": "(a b : UInt8) → Decidable (a ≤ b)",
  "offspring": [],
  "name": "UInt8.decLe"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → [self : MonadLift m n] → {α : Type u} → m α → n α",
  "offspring": [],
  "name": "MonadLift.monadLift"},
 {"type": "∀ {a b c : ℤ}, b ≤ -a + c → a + b ≤ c",
  "offspring": [],
  "name": "Int.add_le_of_le_neg_add"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk", "Fin.lor", "UInt32.size"],
  "name": "UInt32.lor"},
 {"type": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "offspring": [],
  "name": "MulZeroClass.zero_mul"},
 {"type":
  "∀ {f : Type u → Type v} [inst : Applicative f] [self : LawfulApplicative f] {α β : Type u} (g : α → β) (x : α),\n  g <$> pure x = pure (g x)",
  "offspring": [],
  "name": "LawfulApplicative.map_pure"},
 {"type": "{α : Type u_1} → Option α → Bool",
  "offspring": [],
  "name": "Option.toBool"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) {p : Nat.Linear.Poly},\n  Nat.Linear.Poly.isNonZero p = true → Nat.Linear.Poly.denote ctx p > 0",
  "offspring":
  ["eq_of_beq",
   "Nat.instLawfulBEqNatInstBEqNat",
   "beq_self_eq_true",
   "Nat.Linear.Var.denote.go",
   "cond_true",
   "Nat.mul_one",
   "Nat.lt_of_succ_le",
   "Nat.le_trans",
   "Decidable.decide",
   "Nat.Linear.Poly.isNonZero",
   "decide_eq_true_eq",
   "Nat.le_add_right"],
  "name": "Nat.Linear.Poly.of_isNonZero"},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → β → α",
  "offspring": [],
  "name": "Equiv.invFun"},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] (n : ℕ) (a : M), a ^ Nat.succ n = a ^ n * a",
  "offspring": ["pow_succ'", "pow_mul_comm"],
  "name": "pow_succ"},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Bool",
  "offspring": [],
  "name": "List.isPrefixOf"},
 {"type": "BEq Float",
  "offspring": ["BEq.mk", "Float.beq"],
  "name": "instBEqFloat"},
 {"type": "ToString System.FilePath",
  "offspring": ["ToString.mk", "System.FilePath.toString"],
  "name": "System.instToStringFilePath"},
 {"type": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "offspring": [],
  "name": "Eq.trans"},
 {"type":
  "∀ {R : Type u} [self : Semiring R] (n : ℕ) (x : R), Semiring.npow (Nat.succ n) x = x * Semiring.npow n x",
  "offspring": [],
  "name": "Semiring.npow_succ'"},
 {"type": "∀ (n : ℕ), n - n = 0",
  "offspring": ["Nat.sub_zero", "Nat.succ_sub_succ"],
  "name": "Nat.sub_self"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∀ (x : α × β), p x) ↔ ∀ (a : α) (b : β), p (a, b)",
  "offspring": [],
  "name": "Prod.forall"},
 {"type": "OfScientific Float",
  "offspring":
  ["OfScientific.mk",
   "Float.ofBinaryScientific",
   "HDiv.hDiv",
   "HShiftLeft.hShiftLeft",
   "HPow.hPow",
   "Nat.log2"],
  "name": "instOfScientificFloat"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk", "HShiftLeft.hShiftLeft", "UInt16.modn"],
  "name": "UInt16.shiftLeft"},
 {"type": "Lean.Elab.Tactic.TacticM Unit",
  "offspring": ["Tactic.NormCast.derive"],
  "name": "Tactic.NormCast.normCastTarget"},
 {"type": "∀ {a b c : Prop}, (a ∧ b ↔ a ∧ c) ↔ a → (b ↔ c)",
  "offspring": ["true_and", "and_congr_right"],
  "name": "And.congr_right_iff"},
 {"type": "{α : Type u} → List α → List α → List α",
  "offspring": ["List.reverseAux", "List.reverse"],
  "name": "List.appendTR"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], a → b ↔ ¬a ∨ b",
  "offspring": ["Decidable.not_or_of_imp", "Or.neg_resolve_left"],
  "name": "Decidable.imp_iff_not_or"},
 {"type": "Mathlib.Tactic.Lint.SimpTheoremInfo → Bool",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.SimpTheoremInfo.isConditional"},
 {"type":
  "∀ {α : Type u_1} {o : Option α} {a : α}, o = some a ↔ ∃ h, Option.get h = a",
  "offspring":
  ["eq_false'",
   "false_iff",
   "not_exists",
   "sorryAx",
   "Option.some.injEq",
   "Option.get_some",
   "exists_prop",
   "Option.isSome_some",
   "true_and"],
  "name": "Option.eq_some_iff_get_eq"},
 {"type": "ℕ", "offspring": [], "name": "UInt64.size"},
 {"type": "{α : Type u_1} → {β : Sort u_2} → (α → β) → List α → Prop",
  "offspring": [],
  "name": "List.inj_on"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["cond", "Array.append"],
  "name": "unexpandExists"},
 {"type": "∀ {i a : ℕ}, i < a → 0 < a - i",
  "offspring": ["Nat.eq_or_lt_of_le", "Nat.add_one", "Nat.add_sub_self_left"],
  "name": "Nat.zero_lt_sub_of_lt"},
 {"type":
  "{m : Type u_1 → Type u_2} → {α : Type u_1} → [inst : Monad m] → ExceptCpsT α m α → m α",
  "offspring": [],
  "name": "ExceptCpsT.runCatch"},
 {"type": "∀ {n : ℕ}, ↑n = n", "offspring": [], "name": "Nat.cast_id"},
 {"type": "∀ {a b : ℤ}, a < b → a ≤ b - 1",
  "offspring": ["Int.le_sub_right_of_add_le"],
  "name": "Int.le_sub_one_of_lt"},
 {"type": "∀ {R : Type u} [self : AddGroupWithOne R] (a b : R), a - b = a + -b",
  "offspring": [],
  "name": "AddGroupWithOne.sub_eq_add_neg"},
 {"type": "Tactic.NormCast.Label → ℕ",
  "offspring": [],
  "name": "Tactic.NormCast.Label.toCtorIdx"},
 {"type":
  "Lean.Expr → Tactic.Ring.HornerExpr → Lean.Expr × ℕ → Lean.Expr × ℕ → Tactic.Ring.HornerExpr → Tactic.Ring.HornerExpr",
  "offspring": [],
  "name": "Tactic.Ring.HornerExpr.xadd"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} → [inst : Monad m] → (as : Array α) → (Fin (Array.size as) → α → m β) → m (Array β)",
  "offspring": [],
  "name": "Array.mapIdxM"},
 {"type": "∀ {m n : ℕ}, m ∣ n ↔ Nat.gcd n m = m",
  "offspring": ["Nat.gcd_comm", "Nat.gcd_eq_left_iff_dvd"],
  "name": "Nat.gcd_eq_right_iff_dvd"},
 {"type": "∀ {b : Bool}, ¬b = false → b = true",
  "offspring": [],
  "name": "eq_true_of_ne_false"},
 {"type": "∀ {n m : ℕ}, n ≤ m → n ≤ Nat.succ m",
  "offspring": ["Nat.le_trans", "Nat.le_succ"],
  "name": "Nat.le_succ_of_le"},
 {"type": "{R : Type u_1} → [inst : AddGroupWithOne R] → CoeTail ℤ R",
  "offspring": ["CoeTail.mk", "Int.cast"],
  "name": "instCoeTailInt"},
 {"type": "UInt32 → UInt32", "offspring": [], "name": "UInt32.complement"},
 {"type":
  "∀ (k : ℕ) (a : Nat.Linear.Expr), sizeOf (Nat.Linear.Expr.mulL k a) = 1 + sizeOf k + sizeOf a",
  "offspring": ["instSizeOfNat", "Nat.Linear.Expr"],
  "name": "Nat.Linear.Expr.mulL.sizeOf_spec"},
 {"type": "UInt64 → UInt64 → UInt64", "offspring": [], "name": "mixHash"},
 {"type": "{α : Type u} → Inhabited (Array α)",
  "offspring": ["Array.empty"],
  "name": "Array.instInhabitedArray"},
 {"type": "{α : Sort u} → {β : Sort v} → α → β → PProd α β",
  "offspring": [],
  "name": "PProd.mk"},
 {"type": "{α : Type u} → [inst : Preorder α] → Trans LE.le LT.lt LT.lt",
  "offspring": ["Trans.mk", "instTransLeToLELtToLT.proof_1"],
  "name": "instTransLeToLELtToLT"},
 {"type": "∀ (a : UInt64), 0 + a = a",
  "offspring":
  ["UInt64.zero_def",
   "UInt64.add_def",
   "UInt64.mk",
   "zero_add",
   "UInt64.mk_val_eq"],
  "name": "UInt64.instSemiringUInt64.proof_2"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.bijective f → Function.injective f",
  "offspring": [],
  "name": "Function.bijective.injective"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [inst : MonadExcept ε m] → {α : Type v} → m α → (Unit → m α) → m α",
  "offspring": ["MonadExcept.tryCatch"],
  "name": "MonadExcept.orElse"},
 {"type": "{M : Type u} → [inst : Monoid M] → HPow M ℕ M",
  "offspring": ["HPow.mk", "Monoid.npow"],
  "name": "Monoid.HPow"},
 {"type": "ℕ → ℤ → Float",
  "offspring":
  ["Float.scaleB",
   "UInt64.toFloat",
   "Nat.toUInt64",
   "HShiftRight.hShiftRight",
   "Nat.log2"],
  "name": "Float.ofBinaryScientific"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Applicative m] → (ℕ → α → m β) → ℕ → List α → m (List β)",
  "offspring": ["Seq.seq", "Functor.map"],
  "name": "List.mapIdxM.loop"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {s : Set α} {b : β},\n  (∃ a, a ∈ s ∧ f a = b) → Function.inv_fun_on f s b ∈ s",
  "offspring": ["Function.inv_fun_on_pos"],
  "name": "Function.inv_fun_on_mem"},
 {"type": "DecidableEq PUnit",
  "offspring": ["PUnit.subsingleton"],
  "name": "instDecidableEqPUnit"},
 {"type":
  "∀ {n : ℕ} (m : UFModel n) (x y : Fin n),\n  UFModel.rank m ↑x < UFModel.rank m ↑y →\n    ∀ (i : Fin n),\n      ↑((fun i => if ↑x = ↑i then y else UFModel.parent m i) i) ≠ ↑i →\n        UFModel.rank m ↑i < UFModel.rank m ↑((fun i => if ↑x = ↑i then y else UFModel.parent m i) i)",
  "offspring": ["ne_eq", "if_pos", "if_neg", "UFModel.rank_lt"],
  "name": "UFModel.setParent.proof_1"},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ × ℕ → α → α",
  "offspring": ["Nat.foldAux"],
  "name": "Prod.foldI"},
 {"type":
  "{R : Type u} →\n  [toSemiring : Semiring R] →\n    [toNeg : Neg R] →\n      [toSub : Sub R] →\n        (∀ (a b : R), a - b = a + -b) →\n          (gsmul : ℤ → R → R) →\n            (∀ (a : R), gsmul 0 a = 0) →\n              (∀ (n : ℕ) (a : R), gsmul (Int.ofNat (Nat.succ n)) a = a + gsmul (Int.ofNat n) a) →\n                (∀ (n : ℕ) (a : R), gsmul -[1+ n] a = -gsmul (Int.ofNat (Nat.succ n)) a) →\n                  (∀ (a : R), -a + a = 0) →\n                    (intCast : ℤ → R) →\n                      (∀ (n : ℕ), intCast (Int.ofNat n) = NonUnitalNonAssocSemiring.natCast n) →\n                        (∀ (n : ℕ), intCast -[1+ n] = -NonUnitalNonAssocSemiring.natCast (n + 1)) → Ring R",
  "offspring": [],
  "name": "Ring.mk"},
 {"type":
  "∀ (α : Sort u_1) {β : Sort u_2} [inst : Nonempty β], Nonempty (α → β)",
  "offspring": ["Classical.ofNonempty"],
  "name": "instNonemptyForAll.proof_1"},
 {"type": "Inhabited Prop", "offspring": [], "name": "instInhabitedProp"},
 {"type": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "offspring": ["OfNat.mk", "Zero.zero"],
  "name": "instOfNat"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {r : α → β → Prop} {s : β → γ → Prop} {t : α → γ → Prop}\n  [self : Trans r s t] {a : α} {b : β} {c : γ}, r a b → s b c → t a c",
  "offspring": [],
  "name": "Trans.trans"},
 {"type": "{α : Type u} → HAppend (Array α) (List α) (Array α)",
  "offspring": ["HAppend.mk", "Array.appendList"],
  "name": "Array.instHAppendArrayList"},
 {"type":
  "∀ {α : Sort u} {f : α → α}, Function.involutive f → Function.RightInverse f f",
  "offspring": [],
  "name": "Function.involutive.RightInverse"},
 {"type": "{C : Sort u} → False → C", "offspring": [], "name": "False.elim"},
 {"type": "∀ {M : Type u} [self : CommMonoid M] (a b : M), a * b = b * a",
  "offspring": [],
  "name": "CommMonoid.mul_comm"},
 {"type":
  "∀ {eq : Bool} {lhs rhs : Nat.Linear.Poly} {eq_1 : Bool} {lhs_1 rhs_1 : Nat.Linear.Poly},\n  { eq := eq, lhs := lhs, rhs := rhs } = { eq := eq_1, lhs := lhs_1, rhs := rhs_1 } →\n    eq = eq_1 ∧ lhs = lhs_1 ∧ rhs = rhs_1",
  "offspring": [],
  "name": "Nat.Linear.PolyCnstr.mk.inj"},
 {"type": "∀ (a : Prop), False → a ↔ True",
  "offspring": ["trivial"],
  "name": "false_implies_iff"},
 {"type":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a",
  "offspring": [],
  "name": "forall_congr"},
 {"type": "{α : Type u} → [inst : BEq α] → List α → α → α → List α",
  "offspring": [],
  "name": "List.replace"},
 {"type": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "offspring": ["Subsingleton.elim.proof_1"],
  "name": "Subsingleton.elim"},
 {"type": "Bool",
  "offspring": ["System.Platform.getIsEmscripten"],
  "name": "System.Platform.isEmscripten"},
 {"type": "{α : Type u} → [self : Inv α] → α → α",
  "offspring": [],
  "name": "Inv.inv"},
 {"type": "∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ a ∧ b ∧ c",
  "offspring": [],
  "name": "And.assoc"},
 {"type": "{α : Type u} → {β : Type v} → Sort u_1 → α × β → α × β → Sort u_1",
  "offspring": [],
  "name": "Prod.noConfusionType"},
 {"type": "∀ (a b c : UInt16), (a + b) * c = a * c + b * c",
  "offspring":
  ["UInt16.add_def",
   "UInt16.mul_def",
   "UInt16.mk",
   "UInt16.eq_of_val_eq",
   "Distrib.right_distrib"],
  "name": "UInt16.instSemiringUInt16.proof_8"},
 {"type":
  "{α σ : Type u} → Sort u_1 → DoResultSBC α σ → DoResultSBC α σ → Sort u_1",
  "offspring": [],
  "name": "DoResultSBC.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {m : Type u_2 → Type u_3} (as : List α),\n  ((a : α) → a ∈ as → β → m (ForInStep β)) →\n    ∀ (x : List α), (∃ bs, bs ++ x = as) → ∀ (a : α) (as' : List α), (∃ bs, bs ++ a :: as' = as) → a ∈ as",
  "offspring": [],
  "name": "List.forIn'.loop.proof_1"},
 {"type": "{α : Sort u} → (α → α → Sort v) → HasEquiv α",
  "offspring": [],
  "name": "HasEquiv.mk"},
 {"type":
  "Lean.Meta.Simp.Context → Std.HashMap Lean.Name Lean.Name → Lean.Expr → Array Lean.Name",
  "offspring":
  ["Id.run",
   "ForIn.forIn",
   "Id.instMonadId",
   "ForInStep",
   "Mathlib.Tactic.Lint.isEqnLemma?",
   "EmptyCollection.emptyCollection"],
  "name": "Mathlib.Tactic.Lint.heuristicallyExtractSimpTheoremsCore"},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ → α → α",
  "offspring": [],
  "name": "Nat.foldRev.loop"},
 {"type": "∀ {α : Sort u} {a : α}, a ≠ a → False",
  "offspring": [],
  "name": "Ne.irrefl"},
 {"type": "∀ {a a_1 : ℕ}, Sat.Literal.neg a = Sat.Literal.neg a_1 → a = a_1",
  "offspring": [],
  "name": "Sat.Literal.neg.inj"},
 {"type":
  "∀ {n : ℕ} (a b : Fin n), a * b = { val := ↑a * ↑b % n, isLt := (_ : ↑a * ↑b % n < n) }",
  "offspring": [],
  "name": "Fin.mul_def"},
 {"type":
  "∀ {α : Type u} [i : Nonempty α] {β : Sort v} {f : α → β}, Function.injective f → Function.has_LeftInverse f",
  "offspring": ["Function.inv_fun", "Function.LeftInverse_inv_fun"],
  "name": "Function.injective.has_LeftInverse"},
 {"type": "EmptyCollection FloatArray",
  "offspring": ["EmptyCollection.mk", "FloatArray.empty"],
  "name": "FloatArray.instEmptyCollectionFloatArray"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β} {b : β}, (∃ a, f a = b) → f (Function.inv_fun f b) = b",
  "offspring": ["Function.inv_fun_on_eq", "trivial"],
  "name": "Function.inv_fun_eq"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticAssumption'"},
 {"type": "∀ {b : Bool}, ¬b = true → b = false",
  "offspring": [],
  "name": "eq_false_of_ne_true"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → ℤ → Fin n",
  "offspring": [],
  "name": "Fin.ofInt'"},
 {"type":
  "∀ (lits : Array ℤ) (expr : Lean.Expr) (depth : ℕ),\n  sizeOf { lits := lits, expr := expr, depth := depth } = 1 + sizeOf lits + sizeOf expr + sizeOf depth",
  "offspring": ["instSizeOfNat"],
  "name": "Mathlib.Tactic.Sat.LClause.mk.sizeOf_spec"},
 {"type": "{α : Type u_1} → List α → List (List α) → List (List α)",
  "offspring": [],
  "name": "List.transposeAux"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk"],
  "name": "USize.sub"},
 {"type": "ByteArray → UInt64",
  "offspring":
  ["instBEqNat",
   "ByteArray.size",
   "HOr.hOr",
   "HShiftLeft.hShiftLeft",
   "UInt8.toUInt64",
   "ByteArray.get!",
   "panicWithPosWithDecl",
   "instInhabitedUInt64"],
  "name": "ByteArray.toUInt64LE!"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_*>_»"},
 {"type": "∀ (a : ℕ) {b c : ℕ}, b ∣ c → a * b ∣ a * c",
  "offspring": ["Nat.mul_dvd_mul", "Nat.dvd_refl"],
  "name": "Nat.mul_dvd_mul_left"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} {δ : Type u_4} {f : α → γ} {g : β → δ},\n  Function.injective f → Function.injective g → Function.injective (Prod.map f g)",
  "offspring": [],
  "name": "Function.injective.prod_map"},
 {"type": "UInt64 → UInt64 → UInt64",
  "offspring": ["UInt64.mk", "HShiftRight.hShiftRight", "UInt64.modn"],
  "name": "UInt64.shiftRight"},
 {"type":
  "∀ (n : ℕ) (x : ℤ), (fun n x => x ^ n) (Nat.succ n) x = x * (fun n x => x ^ n) n x",
  "offspring": ["Int.mul_comm"],
  "name": "Int.instCommRingInt.proof_5"},
 {"type": "∀ {a b : ℤ} {n : ℕ}, a + ↑(Nat.succ n) = b → a < b",
  "offspring": ["Int.lt_add_succ"],
  "name": "Int.lt.intro"},
 {"type": "{α : Type u} → (α → α → α) → α → Prop",
  "offspring": [],
  "name": "right_identity"},
 {"type":
  "{G : Type u} → {inst : Mul G} → Sort u_1 → IsMulLeftCancel G → IsMulLeftCancel G → Sort u_1",
  "offspring": [],
  "name": "IsMulLeftCancel.noConfusionType"},
 {"type": "{α : Sort u_1} → [inst : SizeOf α] → SizeOf (Unit → α)",
  "offspring": ["SizeOf.mk"],
  "name": "instSizeOfForAllUnit"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Mathlib.ExtendedBinder.extBinders"],
  "name": "Mathlib.ExtendedBinder.«term∃ᵉ_,_»"},
 {"type": "∀ {a b c : Prop}, (b ↔ c) → (a ∨ b ↔ a ∨ c)",
  "offspring": ["or_congr", "Iff.rfl"],
  "name": "or_congr_right"},
 {"type": "∀ (a b : ℤ), -a * b = a * -b",
  "offspring": ["Int.neg_mul_eq_neg_mul_symm", "Int.mul_neg_eq_neg_mul_symm"],
  "name": "Int.neg_mul_comm"},
 {"type": "Lean.Elab.Tactic.TacticM Unit",
  "offspring": ["List"],
  "name": "evalIntrov.intro1PStep"},
 {"type": "Type u → Type u", "offspring": ["Quot"], "name": "Squash"},
 {"type": "∀ {α : Sort u}, Nonempty α → ∃ x, True",
  "offspring": ["trivial"],
  "name": "Classical.exists_true_of_nonempty"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → (¬a ↔ ¬b)",
  "offspring": ["mt"],
  "name": "not_congr"},
 {"type": "∀ (n : ℕ), Nat.ble n n = true",
  "offspring": ["Nat.ble"],
  "name": "Nat.ble_self_eq_true"},
 {"type": "AndOp ℕ",
  "offspring": ["AndOp.mk", "Nat.land"],
  "name": "Nat.instAndOpNat"},
 {"type": "Float → USize", "offspring": [], "name": "Float.toUSize"},
 {"type": "Sort u → Sort (max 1 u)",
  "offspring": ["Equiv"],
  "name": "Equiv.perm"},
 {"type": "UInt32 → UInt64",
  "offspring": ["Nat.toUInt64", "UInt32.toNat"],
  "name": "UInt32.toUInt64"},
 {"type":
  "∀ (x : ℕ) (a : USize),\n  { val := Ring.gsmul -[1+ x] a.val } =\n    { val := (-(fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat (Nat.succ x)) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_neg'"],
  "name": "USize.instRingUSize.proof_5"},
 {"type": "{motive : ℕ → Sort u} → ℕ → Sort (max 1 u)",
  "offspring": ["PProd"],
  "name": "Nat.below"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : (a : α) → Acc r a → Prop} {a : α} (x : Acc r a),\n  (∀ (a : α) (x : Acc r a), Acc.below x → motive a x) → motive a x",
  "offspring": ["Acc.below.intro"],
  "name": "Acc.brecOn"},
 {"type": "{α : Type u_1} → Array α → ℕ → α → α",
  "offspring": ["Array.get"],
  "name": "Array.getD"},
 {"type":
  "∀ (numArgs coercee : ℕ) (type : Tactic.NormCast.CoeFnType) (numArgs_1 coercee_1 : ℕ)\n  (type_1 : Tactic.NormCast.CoeFnType),\n  ({ numArgs := numArgs, coercee := coercee, type := type } =\n      { numArgs := numArgs_1, coercee := coercee_1, type := type_1 }) =\n    (numArgs = numArgs_1 ∧ coercee = coercee_1 ∧ type = type_1)",
  "offspring":
  ["Tactic.NormCast.CoeFnType",
   "Tactic.NormCast.CoeFnInfo",
   "Tactic.NormCast.CoeFnInfo.mk"],
  "name": "Tactic.NormCast.CoeFnInfo.mk.injEq"},
 {"type": "{α : Sort u} → Sort u_1 → Hashable α → Hashable α → Sort u_1",
  "offspring": [],
  "name": "Hashable.noConfusionType"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≠ b ↔ a < b ∨ a > b",
  "offspring": ["lt_or_gt_of_ne", "Ne", "ne_of_lt", "ne_of_gt"],
  "name": "ne_iff_lt_or_gt"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α ε : Type u_1} [inst : Monad m] (x : α), ExceptT.run (pure x) = pure (Except.ok x)",
  "offspring": [],
  "name": "ExceptT.run_pure"},
 {"type":
  "{α : Type u} → (P : α → Prop) → [inst : DecidablePred P] → List α → List (List α)",
  "offspring": ["List.splitOnPAux"],
  "name": "List.splitOnP"},
 {"type":
  "∀ {m n : ℕ}, 0 < Nat.gcd m n → Nat.coprime (m / Nat.gcd m n) (n / Nat.gcd m n)",
  "offspring":
  ["Nat.coprime_iff_gcd_eq_one",
   "Nat.gcd_div",
   "Nat.gcd_dvd_left",
   "Nat.gcd_dvd_right",
   "Nat.div_self"],
  "name": "Nat.coprime_div_gcd_div_gcd"},
 {"type": "∀ (a b : Bool), ((a && b) = true) = (a = true ∧ b = true)",
  "offspring": [],
  "name": "Bool.and_eq_true"},
 {"type": "∀ {p q : Prop}, ¬(p ↔ q) → p = q → False",
  "offspring": ["Iff.rfl"],
  "name": "instDecidableEqProp.proof_1"},
 {"type": "Type u → Type u", "offspring": [], "name": "Add"},
 {"type":
  "{α : Type u_1} → {lt : α → α → Bool} → Sort u → BinaryHeap α lt → BinaryHeap α lt → Sort u",
  "offspring": [],
  "name": "BinaryHeap.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (i : ℕ) (h : i < Array.size a),\n  Array.size a = Array.size (Array.set a { val := i, isLt := h } (unsafeCast ()))",
  "offspring": ["Array.size_set", "unsafeCast", "Unit"],
  "name": "Array.modifyMUnsafe.proof_1"},
 {"type": "∀ {a b c : ℤ}, a ≤ b + c → a - b ≤ c",
  "offspring": [],
  "name": "Int.sub_left_le_of_le_add"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {l₁ l₂ : List α},\n  (∀ (x : α), x ∈ l₁ ++ l₂ → p x) ↔ (∀ (x : α), x ∈ l₁ → p x) ∧ ∀ (x : α), x ∈ l₂ → p x",
  "offspring":
  ["List.mem_append", "or_imp_distrib", "forall_and_distrib", "Iff.rfl"],
  "name": "List.forall_mem_append"},
 {"type":
  "∀ {α : Sort u_1} {p : Nonempty α → Prop}, (∀ (h : Nonempty α), p h) ↔ α → p (_ : Nonempty α)",
  "offspring": [],
  "name": "Nonempty.forall"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (α × Option β) × List β",
  "offspring": ["List.map₂Left'"],
  "name": "List.zipLeft'"},
 {"type": "{A : Type u} → [self : AddCommGroup A] → AddGroup A",
  "offspring": [],
  "name": "AddCommGroup.toAddGroup"},
 {"type": "∀ (n : ℕ), -[1+ n] = -Int.ofNat (n + 1)",
  "offspring": [],
  "name": "Int.negSucc_ofNat_coe"},
 {"type": "{G : Type u} → [self : DivInvMonoid G] → Inv G",
  "offspring": [],
  "name": "DivInvMonoid.toInv"},
 {"type": "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), e.toFun = e.toFun",
  "offspring": [],
  "name": "Equiv.to_fun_as_coe"},
 {"type": "Float → UInt64", "offspring": [], "name": "Float.toUInt64"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "guardExprStrict"},
 {"type": "∀ {a : Prop}, a → a ↔ True",
  "offspring": ["iff_true_intro"],
  "name": "imp_self"},
 {"type": "(a b : USize) → Decidable (a < b)",
  "offspring": ["USize.decLt"],
  "name": "instDecidableLtUSizeInstLTUSize"},
 {"type":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a > b → b > c → a > c",
  "offspring": ["lt_trans"],
  "name": "gt_trans"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] (f : (a : α) → β a) (a' : α),\n  Function.injective (Function.update f a')",
  "offspring": [],
  "name": "Function.update_injective"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (p r : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.sort.go p r) = Nat.Linear.Poly.denote ctx p + Nat.Linear.Poly.denote ctx r",
  "offspring":
  ["Nat.zero_add", "Nat.Linear.Poly.denote_insertSorted", "Nat.add_left_comm"],
  "name": "Nat.Linear.Poly.denote_sort_go"},
 {"type": "∀ (n m k : ℕ), n + m + k = n + (m + k)",
  "offspring": [],
  "name": "Nat.add_assoc"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (n_1 : ℕ), AddGroupWithOne.intCast (Int.ofNat n_1) = AddMonoidWithOne.natCast n_1",
  "offspring": ["AddGroupWithOne.intCast_ofNat"],
  "name": "instCommRingFin.proof_6"},
 {"type":
  "∀ {α : Sort u_1} {r q : α → α → Prop}, Subrelation q r → WellFounded r → WellFounded q",
  "offspring":
  ["WellFounded.intro", "Subrelation.accessible", "WellFounded.apply"],
  "name": "Subrelation.wf.proof_1"},
 {"type":
  "{ε : Type u_1} → {α : Type u_2} → [inst : Repr ε] → [inst : Repr α] → Repr (Except ε α)",
  "offspring": ["reprArg"],
  "name": "instReprExcept"},
 {"type":
  "∀ {α : Type u_1} {a b : α} {l : List α}, a ∈ b :: l → a = b ∨ a ≠ b ∧ a ∈ l",
  "offspring": ["Or.resolve_left", "List.mem_cons"],
  "name": "List.eq_or_ne_mem_of_mem"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ <+ l₂ → List.length l₁ ≤ List.length l₂",
  "offspring": ["le_refl", "Nat.le_succ_of_le", "Nat.succ_le_succ"],
  "name": "List.length_le_of_sublist"},
 {"type": "∀ (a : UInt64), a * 0 = 0",
  "offspring":
  ["UInt64.zero_def", "UInt64.mul_def", "UInt64.mk", "MonoidWithZero.mul_zero"],
  "name": "UInt64.instSemiringUInt64.proof_10"},
 {"type": "∀ {p q : Prop}, (p → q) → (¬p → q) → q",
  "offspring": ["Decidable.byCases"],
  "name": "Classical.byCases"},
 {"type": "∀ {n : ℕ}, ↑1 = 1",
  "offspring": ["Nat.mod_eq_of_lt", "Nat.succ_lt_succ", "Nat.zero_lt_succ"],
  "name": "Fin.one_val"},
 {"type": "USize → USize", "offspring": [], "name": "USize.complement"},
 {"type": "Nat.Linear.ExprCnstr → Bool",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.eq"},
 {"type": "{ε σ α : Type u} → (σ → α × σ) → EStateM ε σ α",
  "offspring": ["EStateM.Result.ok"],
  "name": "EStateM.modifyGet"},
 {"type": "∀ {a b c : ℤ}, -c + a ≤ b → a ≤ b + c",
  "offspring": ["Int.le_add_of_sub_right_le", "Int.add_comm"],
  "name": "Int.le_add_of_neg_add_le_right"},
 {"type": "Float → Float → Float", "offspring": [], "name": "Float.pow"},
 {"type": "∀ (n : ℕ), Nat.coprime n n ↔ n = 1",
  "offspring": ["Nat.gcd_self"],
  "name": "Nat.coprime_self"},
 {"type":
  "{α : Sort u} → {γ : outParam (α → Sort v)} → Sort u_1 → CoeFun α γ → CoeFun α γ → Sort u_1",
  "offspring": [],
  "name": "CoeFun.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) (p q : α × β),\n  r p.fst q.fst ∨ p.fst = q.fst ∧ s p.snd q.snd ↔ Prod.Lex r s p q",
  "offspring": ["Iff.symm", "Prod.lex_def"],
  "name": "Prod.Lex.decidable.proof_1"},
 {"type": "∀ {n : ℕ} [self : Nat.AtLeastTwo n], n ≥ 2",
  "offspring": [],
  "name": "Nat.AtLeastTwo.prop"},
 {"type": "∀ {α : Sort u_1} (a : α), HEq a a ↔ True",
  "offspring": ["iff_true_intro", "HEq.rfl"],
  "name": "heq_self_iff_true"},
 {"type": "{m : Type u → Type v} → Sort u_1 → Monad m → Monad m → Sort u_1",
  "offspring": [],
  "name": "Monad.noConfusionType"},
 {"type": "{α : Type u_1} → [inst : Repr α] → Repr (id α)",
  "offspring": [],
  "name": "instReprIdType"},
 {"type": "Lean.AttributeImpl",
  "offspring":
  ["Unit",
   "Mathlib.Tactic.Ext.liftCommandElabM",
   "Mathlib.Tactic.Ext.extExtension"],
  "name": "Mathlib.Tactic.Ext.extAttribute"},
 {"type": "{α : Type u_1} → (lt : α → α → Bool) → Array α → BinaryHeap α lt",
  "offspring": ["BinaryHeap.mk", "Subtype.val", "BinaryHeap.mkHeap"],
  "name": "Array.toBinaryHeap"},
 {"type":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∃ a, p a) → ∃ a, q a",
  "offspring": ["Exists.elim"],
  "name": "exists_imp_exists"},
 {"type": "∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 0 = 1",
  "offspring": ["Monoid.npow_zero'"],
  "name": "pow_zero"},
 {"type": "∀ (n : ℕ) {m : ℕ}, 0 < m → m * n / m = n",
  "offspring":
  ["Nat.zero_eq",
   "Nat.mul_zero",
   "Nat.zero_div",
   "Nat.mul_succ",
   "Nat.add_div_right"],
  "name": "Nat.mul_div_right"},
 {"type":
  "∀ {α : Type u} [inst : DecidableEq α] {a : α} {as : List α}, List.elem a as = true → a ∈ as",
  "offspring":
  ["eq_false_of_decide",
   "false_implies",
   "List.Mem.head",
   "decide_eq_true_eq",
   "List.Mem.tail"],
  "name": "List.mem_of_elem_eq_true"},
 {"type": "∀ (val : Fin UInt64.size), sizeOf { val := val } = 1 + sizeOf val",
  "offspring": [],
  "name": "UInt64.mk.sizeOf_spec"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b",
  "offspring": ["le_not_le_of_lt"],
  "name": "le_of_lt"},
 {"type": "∀ {a b c : ℕ}, a - b ≤ c → a ≤ c + b",
  "offspring":
  ["Nat.le.dest",
   "Nat.le_total",
   "Nat.le_trans",
   "Nat.le_add_left",
   "Nat.le.intro"],
  "name": "Nat.le_add_of_sub_le"},
 {"type":
  "∀ {n : ℕ} (m : UFModel n) (x y : Fin n),\n  UFModel.rank m ↑x ≤ UFModel.rank m ↑y →\n    ↑(UFModel.parent m y) = ↑y →\n      ∀ (i : Fin n),\n        ↑((fun i => if ↑x = ↑i then y else UFModel.parent m i) i) ≠ ↑i →\n          (fun i => if ↑y = i ∧ UFModel.rank m ↑x = UFModel.rank m ↑y then UFModel.rank m ↑y + 1 else UFModel.rank m i)\n              ↑i <\n            (fun i =>\n                if ↑y = i ∧ UFModel.rank m ↑x = UFModel.rank m ↑y then UFModel.rank m ↑y + 1 else UFModel.rank m i)\n              ↑((fun i => if ↑x = ↑i then y else UFModel.parent m i) i)",
  "offspring":
  ["ne_eq",
   "if_pos",
   "true_and",
   "false_and",
   "if_neg",
   "Nat.lt_succ_self",
   "lt_of_le_of_ne",
   "and_true"],
  "name": "UFModel.setParentBump.proof_1"},
 {"type": "∀ (b : Bool), (b || false) = b",
  "offspring": [],
  "name": "Bool.or_false"},
 {"type": "∀ {p q : Prop}, p → ¬q → (p ↔ q) → False",
  "offspring": [],
  "name": "instDecidableIff.proof_2"},
 {"type": "{α : Type u} → (α → Bool) → List α → List α",
  "offspring": ["List.filterAux"],
  "name": "List.filter"},
 {"type": "∀ {a : ℤ}, 0 < a → Int.sign a = 1",
  "offspring": ["Int.eq_succ_of_zero_lt"],
  "name": "Int.sign_eq_one_of_pos"},
 {"type":
  "∀ {M : Type u} [inst : Monoid M] {a b c : M}, b * a = 1 → a * c = 1 → b = c",
  "offspring": ["one_mul", "Semigroup.mul_assoc", "mul_one"],
  "name": "left_inv_eq_right_inv"},
 {"type": "∀ (a b : ℤ), a ≤ b ↔ Int.NonNeg (b - a)",
  "offspring": ["Iff.refl"],
  "name": "Int.le_def"},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    {R : α → β → Prop} →\n      {motive : (a : List α) → (a_1 : List β) → List.Forall₂ R a a_1 → Prop} →\n        {a : List α} → {a_1 : List β} → List.Forall₂ R a a_1 → Prop",
  "offspring": [],
  "name": "List.Forall₂.below"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x : Fin (UnionFind.size self)),\n  ¬(Array.get self.arr x).parent = ↑x →\n    UnionFind.rankMax self - UnionFind.rank self (Array.get self.arr x).parent <\n      UnionFind.rankMax self - UnionFind.rank self ↑x",
  "offspring":
  ["Nat.sub_lt_sub_left", "UnionFind.lt_rankMax", "UnionFind.rank_lt"],
  "name": "UnionFind.findAux.proof_3"},
 {"type": "{α : Type u_1} → EmptyCollection (Set α)",
  "offspring": ["EmptyCollection.mk"],
  "name": "Set.instEmptyCollectionSet"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["Nat.xor", "Fin.xor.proof_1"],
  "name": "Fin.xor"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (p : α → Prop) [inst : DecidablePred p] {f : { a // p a } → β} {f' : { a // ¬p a } → β},\n  Function.injective f →\n    Function.injective f' →\n      (∀ {x x' : α} {hx : p x} {hx' : ¬p x'}, f { val := x, property := hx } ≠ f' { val := x', property := hx' }) →\n        Function.injective fun x => if h : p x then f { val := x, property := h } else f' { val := x, property := h }",
  "offspring": [],
  "name": "Function.injective.dite"},
 {"type":
  "∀ {id : ℕ} {lits proof : Array ℤ} {id_1 : ℕ} {lits_1 proof_1 : Array ℤ},\n  Mathlib.Tactic.Sat.LRATStep.add id lits proof = Mathlib.Tactic.Sat.LRATStep.add id_1 lits_1 proof_1 →\n    id = id_1 ∧ lits = lits_1 ∧ proof = proof_1",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LRATStep.add.inj"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "offspring": [],
  "name": "congr_arg"},
 {"type":
  "∀ {α : Type u_1} (a : α) (n : ℕ) (l : List α), List.get? (List.set l n a) n = (fun x => a) <$> List.get? l n",
  "offspring":
  ["List.set_eq_modifyNth",
   "List.get?_modifyNth_eq",
   "Functor.map",
   "Option.instFunctorOption"],
  "name": "List.get?_set_eq"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b",
  "offspring": ["lt_of_le_not_le", "Or.resolve_right", "le_total"],
  "name": "lt_of_not_ge"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a < b → a < c → a < min b c",
  "offspring": ["Or.elim", "le_or_gt", "min_eq_left", "min_eq_right_of_lt"],
  "name": "lt_min"},
 {"type": "Substring → (Char → Bool) → Substring",
  "offspring": ["Substring.mk"],
  "name": "Substring.dropWhile"},
 {"type": "{α : Sort u} → Fin 0 → α",
  "offspring": ["Nat.not_lt_zero"],
  "name": "Fin.elim0"},
 {"type":
  "∀ {α : Type u_1} (n : ℕ) (l : List α), List.modifyNthTail id n l = l",
  "offspring": ["congr_arg"],
  "name": "List.modifyNthTail_id"},
 {"type": "{R : Type u} → [self : AddMonoidWithOne R] → One R",
  "offspring": [],
  "name": "AddMonoidWithOne.toOne"},
 {"type": "∀ (a b : Prop), ((a → b) → a) → a",
  "offspring": ["Decidable.peirce"],
  "name": "peirce"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] {h : n > 0}, Fin.ofNat' 1 h = 1",
  "offspring": [],
  "name": "Fin.ofNat'_one"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": [],
  "name": "unexpandListNil"},
 {"type": "∀ (n m : Fin UInt8.size), n = m → { val := n } = { val := m }",
  "offspring": [],
  "name": "UInt8.decEq.proof_1"},
 {"type": "∀ {a : ℕ}, a < UInt64.size → ↑(UInt64.ofNat a).val = a",
  "offspring": ["Fin.val_eq_of_lt"],
  "name": "UInt64.val_eq_of_lt"},
 {"type": "∀ (a : ℕ), min 0 a = 0",
  "offspring": ["min_eq_left", "Nat.instLinearOrderNat", "Nat.zero_le"],
  "name": "Nat.zero_min"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ),\n  Function.injective2 f → ∀ {a₁ a₂ : α} {b₁ b₂ : β}, f a₁ b₁ = f a₂ b₂ → a₁ = a₂",
  "offspring": [],
  "name": "Function.injective2.left"},
 {"type": "∀ {p : Prop} (P : p → Prop) (h : p), P h ↔ ∀ (h : p), P h",
  "offspring": [],
  "name": "forall_prop_decidable.proof_1"},
 {"type": "{p q : Prop} → [hp : Decidable p] → (p ↔ q) → Decidable q",
  "offspring": ["decidable_of_decidable_of_iff.proof_1"],
  "name": "decidable_of_decidable_of_iff"},
 {"type": "∀ (m n : ℕ), Nat.gcd m n = Nat.gcd n m",
  "offspring":
  ["Nat.dvd_antisymm", "Nat.dvd_gcd", "Nat.gcd_dvd_right", "Nat.gcd_dvd_left"],
  "name": "Nat.gcd_comm"},
 {"type": "∀ {p : Prop} [h : Decidable p], ((!decide p) = true) = ¬p",
  "offspring": ["Bool.not_false", "Bool.not_true", "eq_false_of_decide"],
  "name": "not_decide_eq_true"},
 {"type": "∀ {α : Type u_1} {l₁ l₂ l : List α}, l₁ ++ l₂ ⊆ l ↔ l₁ ⊆ l ∧ l₂ ⊆ l",
  "offspring":
  ["List.subset_def",
   "List.mem_append_left",
   "List.mem_append_right",
   "List.append_subset_of_subset_of_subset"],
  "name": "List.append_subset_iff"},
 {"type":
  "{p : Prop} → (P : p → Prop) → [Dp : Decidable p] → [DP : (h : p) → Decidable (P h)] → Decidable (∀ (h : p), P h)",
  "offspring":
  ["decidable_of_decidable_of_iff",
   "forall_prop_decidable.proof_1",
   "forall_prop_decidable.proof_2"],
  "name": "forall_prop_decidable"},
 {"type": "{α : Type u_1} → List α → ℕ → Option α",
  "offspring": [],
  "name": "List.get?"},
 {"type": "{α : Sort u} → {β : Sort v} → α ≃ β → β ≃ α",
  "offspring":
  ["Equiv.mk",
   "Equiv.invFun",
   "Equiv.toFun",
   "Equiv.right_inv",
   "Equiv.left_inv"],
  "name": "Equiv.symm"},
 {"type":
  "∀ (c : Prop) {h : Decidable c} {α : Sort u} (t e : α), (if h : c then t else e) = if c then t else e",
  "offspring": [],
  "name": "dif_eq_if"},
 {"type": "Type u → Type u → Type u → Type u",
  "offspring": [],
  "name": "DoResultPR"},
 {"type": "{α : Type u_1} → (a : Array α) → Fin (Array.size a) → Array α",
  "offspring": ["Array.eraseIdxAux"],
  "name": "Array.feraseIdx"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Conv.convRHS"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": ["cond"],
  "name": "unexpandPSigma"},
 {"type": "Substring → String.Pos → Char",
  "offspring": [],
  "name": "Substring.get"},
 {"type": "{α : Type u} → [self : ShiftRight α] → α → α → α",
  "offspring": [],
  "name": "ShiftRight.shiftRight"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "Monad"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {p q : α → β → Prop},\n  (∀ (a : α) (b : β), p a b ↔ q a b) → ((∃ a b, p a b) ↔ ∃ a b, q a b)",
  "offspring": ["exists_congr"],
  "name": "exists₂_congr"},
 {"type": "{α : Type u_1} → {n : ℕ} → [inst : OfNat α n] → OfNat (Id α) n",
  "offspring": [],
  "name": "Id.instOfNatId"},
 {"type": "∀ {n : ℕ} (a : ℕ), a < n → ∀ (b : ℕ), a / b % n < n",
  "offspring": [],
  "name": "Fin.div.proof_1"},
 {"type": "∀ (m : ℕ), Nat.lcm 1 m = m",
  "offspring": [],
  "name": "Nat.lcm_one_left"},
 {"type": "∀ {a b c : Prop}, a ∧ b ∨ c ↔ (a ∨ c) ∧ (b ∨ c)",
  "offspring": ["Iff.trans", "Or.comm", "or_and_distrib_left", "and_congr"],
  "name": "and_or_distrib_right"},
 {"type": "{α : Type u_1} → [inst : Repr α] → Repr (Subarray α)",
  "offspring": ["repr", "Subarray.toArray"],
  "name": "instReprSubarray"},
 {"type": "Sat.Valuation → Sat.Literal → Prop → Prop",
  "offspring": [],
  "name": "Sat.Literal.reify"},
 {"type": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "offspring": [],
  "name": "Iff.intro"},
 {"type": "ℤ → ℤ", "offspring": ["Int.negOfNat"], "name": "Int.neg"},
 {"type": "∀ (a b c : UInt8), a * (b + c) = a * b + a * c",
  "offspring":
  ["UInt8.add_def",
   "UInt8.mul_def",
   "UInt8.mk",
   "UInt8.eq_of_val_eq",
   "Distrib.left_distrib"],
  "name": "UInt8.instSemiringUInt8.proof_7"},
 {"type": "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "offspring": ["HPow.mk", "Pow.pow"],
  "name": "instHPow"},
 {"type": "∀ {α : Type u_1} (p : α → Prop), (∃ x, x ∈ [] ∧ p x) → False",
  "offspring": [],
  "name": "decidableBEx.proof_1"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → ({α : Type u} → m α → n α) → MonadLiftT m n",
  "offspring": [],
  "name": "MonadLiftT.mk"},
 {"type": "∀ {α : Type u_1} (a : α), List.length [a] = 1",
  "offspring": [],
  "name": "List.length_singleton"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "Alternative"},
 {"type":
  "∀ {m : Type (max u_1 u_2) → Type u_3} {σ α : Type (max u_1 u_2)} [inst : Monad m] (x : StateCpsT σ m α) (s : σ),\n  StateCpsT.run x s = StateCpsT.runK x s fun a s => pure (a, s)",
  "offspring": [],
  "name": "StateCpsT.run_eq"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_%_»"},
 {"type": "∀ {α : Type u_1} {o : Option α}, o ≠ none ↔ ∃ x, some x = o",
  "offspring":
  ["ne_eq",
   "eq_false_of_decide",
   "eq_false'",
   "exists_false",
   "Option.some.injEq",
   "exists_eq"],
  "name": "Option.ne_none_iff_exists"},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      [h : ∀ (a : α), Subsingleton (motive (Quot.mk r a))] → (q : Quot r) → ((a : α) → motive (Quot.mk r a)) → motive q",
  "offspring": ["Quot.rec", "Quot.recOnSubsingleton.proof_1"],
  "name": "Quot.recOnSubsingleton"},
 {"type":
  "{α : Type u} →\n  {β : outParam (Type v)} →\n    {γ : outParam (Type w)} → Sort u_1 → Function.HasUncurry α β γ → Function.HasUncurry α β γ → Sort u_1",
  "offspring": [],
  "name": "Function.HasUncurry.noConfusionType"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {p : α → β → Prop}, (∃ x, p x.fst x.snd) ↔ ∃ a b, p a b",
  "offspring": ["Prod.exists"],
  "name": "Prod.exists'"},
 {"type": "∀ {a b c : Prop}, (b → c) → a ∨ b → a ∨ c",
  "offspring": ["Or.imp"],
  "name": "Or.imp_right"},
 {"type": "∀ (n m : ℕ), n - m ≤ n",
  "offspring": ["Nat.le_refl", "Nat.le_trans", "Nat.pred_le"],
  "name": "Nat.sub_le"},
 {"type": "∀ (n : ℕ), Nat.coprime n 1 ↔ true = true",
  "offspring": ["Nat.gcd_one_right"],
  "name": "Nat.coprime_one_right_iff"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "classical"},
 {"type": "∀ (b : Bool), (!b == false) = (b == true)",
  "offspring": [],
  "name": "Bool.not_beq_false"},
 {"type": "Lean.Expr → Lean.Expr → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.mkIff"},
 {"type": "∀ {a b c : ℤ}, -b ≤ a - c → c ≤ a + b",
  "offspring": ["Int.le_add_of_sub_right_le", "Int.add_le_of_le_sub_left"],
  "name": "Int.le_add_of_neg_le_sub_right"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_↔_»"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HAdd α β γ",
  "offspring": [],
  "name": "HAdd.mk"},
 {"type": "∀ {α : Type u_1} (x y : α), Option.getD (some x) y = x",
  "offspring": [],
  "name": "Option.getD_some"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (x y : α), x < y ↔ ¬x ≥ y",
  "offspring": ["not_le_of_gt", "lt_of_not_ge"],
  "name": "lt_iff_not_ge"},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] (a b : α), ¬b ≤ a → a = b → False",
  "offspring": ["le_refl"],
  "name": "decidableEq_of_decidableLe.proof_1"},
 {"type": "{n : ℕ} → Fin n → Fin n → Option (Fin n)",
  "offspring": ["Fin.overflowingMul"],
  "name": "Fin.checkedMul"},
 {"type": "Type u → (Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "MonadStateOf"},
 {"type": "∀ (n : ℕ), n + 1 ≠ 0",
  "offspring": ["Nat.succ_ne_zero"],
  "name": "Nat.add_one_ne_zero"},
 {"type": "∀ {α : Sort u_1} {a' : α}, ∃ a, a' = a",
  "offspring": [],
  "name": "exists_eq'"},
 {"type": "{M : Type u} → [self : Monoid M] → ℕ → M → M",
  "offspring": [],
  "name": "Monoid.npow"},
 {"type": "{α : Type u} → (α → α → α) → (α → α → α) → Prop",
  "offspring": [],
  "name": "right_distributive"},
 {"type":
  "∀ {α : Sort v} {β : α → Sort u} (a : α) {b₁ b₂ : (x : α) → β x},\n  (∀ (x : α), b₁ x = b₂ x) →\n    (let x := a;\n      b₁ x) =\n      let x := a;\n      b₂ x",
  "offspring": [],
  "name": "let_body_eq"},
 {"type": "{α : Type u_1} → α → Set α → Prop",
  "offspring": [],
  "name": "Set.mem"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "offspring": [],
  "name": "Function.injective"},
 {"type": "∀ {α : Type u_1} (p : α → Prop) (x : α), x ∈ [] → p x",
  "offspring": [],
  "name": "List.forall_mem_nil"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk", "HDiv.hDiv"],
  "name": "UInt8.div"},
 {"type":
  "∀ (lits : Array ℤ) (expr : Lean.Expr) (depth : ℕ) (lits_1 : Array ℤ) (expr_1 : Lean.Expr) (depth_1 : ℕ),\n  ({ lits := lits, expr := expr, depth := depth } = { lits := lits_1, expr := expr_1, depth := depth_1 }) =\n    (lits = lits_1 ∧ expr = expr_1 ∧ depth = depth_1)",
  "offspring": ["Mathlib.Tactic.Sat.LClause", "Mathlib.Tactic.Sat.LClause.mk"],
  "name": "Mathlib.Tactic.Sat.LClause.mk.injEq"},
 {"type": "Tactic.Ring.State → Array Lean.Expr",
  "offspring": [],
  "name": "Tactic.Ring.State.atoms"},
 {"type":
  "∀ (x : ℕ), { val := ↑(x + 1) } = { val := ((fun n => { val := ↑n }) x + 1).1 }",
  "offspring": ["Fin.ofNat'_succ", "UInt8.size"],
  "name": "UInt8.instSemiringUInt8.proof_12"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_3} [inst : Monad m] (f : α → m PUnit) (a : α) (as : List α),\n  forM (a :: as) f = do\n    f a\n    forM as f",
  "offspring": [],
  "name": "List.forM_cons"},
 {"type": "{α : Type u_1} → UnionFind α → α → UnionFind α",
  "offspring":
  ["UnionFind.mk",
   "Array.push",
   "UnionFind.arr",
   "UFNode.mk",
   "UnionFind.push.proof_1"],
  "name": "UnionFind.push"},
 {"type": "FloatArray → ℕ → Option Float",
  "offspring": ["FloatArray.size", "FloatArray.get"],
  "name": "FloatArray.get?"},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α → List α",
  "offspring": ["List.reverse", "List.elem"],
  "name": "List.eraseDupsAux"},
 {"type": "∀ (x y : ℕ), x % y = if 0 < y ∧ y ≤ x then (x - y) % y else x",
  "offspring":
  ["WellFounded.fix_eq", "Nat.sub_lt", "Nat.lt_of_lt_of_le", "WellFounded.fix"],
  "name": "Nat.mod_eq"},
 {"type":
  "{f : Type u → Type v} → [self : Seq f] → {α β : Type u} → f (α → β) → (Unit → f α) → f β",
  "offspring": [],
  "name": "Seq.seq"},
 {"type": "{α : Sort u} → Sort u_1 → SizeOf α → SizeOf α → Sort u_1",
  "offspring": [],
  "name": "SizeOf.noConfusionType"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → OptionT m α → (Unit → OptionT m α) → OptionT m α",
  "offspring": ["OptionT.mk"],
  "name": "OptionT.tryCatch"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p] (l : List α),\n  List.erasep p l = l ∨ ∃ a l₁ l₂, (∀ (b : α), b ∈ l₁ → ¬p b) ∧ p a ∧ l = l₁ ++ a :: l₂ ∧ List.erasep p l = l₁ ++ l₂",
  "offspring":
  ["List.exists_of_erasep",
   "List.erasep_of_forall_not",
   "not_exists",
   "not_and"],
  "name": "List.exists_or_eq_self_of_erasep"},
 {"type": "∀ {G : Type u} [self : DivInvMonoid G] (a b : G), a / b = a * b⁻¹",
  "offspring": [],
  "name": "DivInvMonoid.div_eq_mul_inv"},
 {"type":
  "∀ {α : Type u_1} {i : ℕ} (as bs : List α),\n  ¬i < List.length as →\n    ∀ {h' : i < List.length (as ++ bs)} {h'' : i - List.length as < List.length bs},\n      List.get (as ++ bs) { val := i, isLt := h' } = List.get bs { val := i - List.length as, isLt := h'' }",
  "offspring":
  ["Nat.zero_eq",
   "List.length_cons",
   "Nat.zero_sub",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var",
   "eq_false_of_decide",
   "List.append",
   "Nat.succ_sub_succ",
   "Nat.not_lt_eq",
   "Nat.Linear.ExprCnstr.eq_of_toNormPoly_eq",
   "Nat.not_le_eq"],
  "name": "List.get_append_right"},
 {"type": "{R : Type u} → Sort u_1 → Distrib R → Distrib R → Sort u_1",
  "offspring": [],
  "name": "Distrib.noConfusionType"},
 {"type": "{n : ℕ} → Mod (Fin n)",
  "offspring": ["Mod.mk", "Fin.mod"],
  "name": "Fin.instModFin"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (j i : ℕ), i + 1 + j = Array.size as → j < Array.size as",
  "offspring": ["Nat.add_assoc", "Nat.le_add_right"],
  "name": "Array.mapIdxM.map.proof_1"},
 {"type": "Float → UInt8", "offspring": [], "name": "Float.toUInt8"},
 {"type": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], α → b ↔ b",
  "offspring": ["Nonempty.elim"],
  "name": "forall_const"},
 {"type": "∀ {α : Sort u} (a b : α), HEq a b = (a = b)",
  "offspring": ["heq_of_eq"],
  "name": "heq_eq_eq"},
 {"type":
  "{α : Type u} → {m : Type v → Type w} → [inst : Monad m] → (α → m PUnit) → Subarray α → m PUnit",
  "offspring": ["Array.forM", "Subarray.as", "Subarray.start", "Subarray.stop"],
  "name": "Subarray.forM"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} (f : β → φ) (b : β), f ∘ Function.const α b = Function.const α (f b)",
  "offspring": [],
  "name": "Function.comp_const_right"},
 {"type": "∀ {a : Prop}, (false = true ↔ a) → ¬a",
  "offspring": ["mt", "Bool.ff_ne_tt"],
  "name": "decidable_of_bool.proof_2"},
 {"type":
  "∀ {n : ℕ} (p : Fin n → Prop), (∃ i, p i) ↔ ∃ i h, p { val := i, isLt := h }",
  "offspring": ["Fin.isLt"],
  "name": "List.Fin.exists_iff"},
 {"type": "Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["Nat.Linear.Poly.insertSorted"],
  "name": "Nat.Linear.Poly.sort.go"},
 {"type":
  "{α : Type u} → (as : Array α) → (α → Bool) → optParam ℕ 0 → optParam ℕ (Array.size as) → Bool",
  "offspring": ["Id.run", "Array.anyM", "Id.instMonadId"],
  "name": "Array.any"},
 {"type": "{m : Type u → Type v} → [inst : Monad m] → Alternative (OptionT m)",
  "offspring": ["Alternative.mk", "OptionT.fail", "OptionT.orElse"],
  "name": "OptionT.instAlternativeOptionT"},
 {"type":
  "∀ {α : Type u_1} (l : List α) (a : α), List.get? (l ++ [a]) (List.length l) = some a",
  "offspring": ["List.get?", "List.cons_append", "List.length_cons"],
  "name": "List.get?_concat_length"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HOr α β γ → HOr α β γ → Sort u_1",
  "offspring": [],
  "name": "HOr.noConfusionType"},
 {"type":
  "(m : Type u → Type v) → (n : Type u → Type w) → [self : MonadControl m n] → Type u → Type u",
  "offspring": [],
  "name": "MonadControl.stM"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {β : Quot r → Prop}, (∀ (a : α), β (Quot.mk r a)) → ∀ (q : Quot r), β q",
  "offspring": [],
  "name": "Quot.ind"},
 {"type":
  "∀ {α : Type u_1} {s₁ s₂ t₁ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → List.length t₁ = List.length t₂ → s₁ = s₂ ∧ t₁ = t₂",
  "offspring":
  ["List.append_inj",
   "Nat.add_right_cancel",
   "List.length_append",
   "congr_arg"],
  "name": "List.append_inj'"},
 {"type": "∀ {n m : ℕ}, ↑n < ↑m ↔ n < m",
  "offspring":
  ["Int.instLTInt",
   "Int.lt_iff_add_one_le",
   "Int.instLEInt",
   "Nat.cast_succ",
   "Int.ofNat_le",
   "Iff.rfl"],
  "name": "Int.ofNat_lt"},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ → α → α",
  "offspring": [],
  "name": "Nat.foldRev"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β} {x : β}, p.snd = x ↔ p = (p.fst, x)",
  "offspring": ["Prod.mk.injEq", "true_and"],
  "name": "Prod.snd_eq_iff"},
 {"type": "∀ {a b : Prop}, (a ↔ b) ↔ (b → a) ∧ (a → b)",
  "offspring": ["Iff.trans", "iff_def", "And.comm"],
  "name": "iff_def'"},
 {"type": "∀ {a b c d : Prop}, a ∨ b ∨ c → (a → d) → (b → d) → (c → d) → d",
  "offspring": ["Or.elim"],
  "name": "Or.elim3"},
 {"type": "{A : Type u} → [self : AddCommMonoid A] → AddCommSemigroup A",
  "offspring": ["AddCommSemigroup.mk", "AddCommMonoid.add_comm"],
  "name": "AddCommMonoid.toAddCommSemigroup"},
 {"type": "Array ℤ → Lean.Expr",
  "offspring":
  ["Array.foldr", "Sat.Literal", "Sat.instToExprLiteral", "Sat.Literal.ofInt"],
  "name": "Mathlib.Tactic.Sat.buildClause"},
 {"type": "{α : Type u} → (a : Array α) → Fin (Array.size a) → α",
  "offspring": ["List.get", "Array.data"],
  "name": "Array.get"},
 {"type": "Type → Type",
  "offspring": ["Tactic.Ring.Cache", "StateRefT'", "Tactic.Ring.State"],
  "name": "Tactic.Ring.RingM"},
 {"type": "System.FilePath → Option String",
  "offspring": ["Option.map", "System.FilePath.fileName"],
  "name": "System.FilePath.fileStem"},
 {"type":
  "∀ {α : Sort u_1} [inst : Setoid α], (α → Prop) → Equivalence HasEquiv.Equiv",
  "offspring":
  ["Equivalence.mk", "Subtype.refl", "Subtype.symm", "Subtype.trans"],
  "name": "Subtype.equivalence"},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β → β) → β → List α → List β",
  "offspring": ["List.scanrAux"],
  "name": "List.scanr"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → Float → m β) → β → (as : FloatArray) → optParam ℕ 0 → optParam ℕ (FloatArray.size as) → m β",
  "offspring": ["FloatArray.size"],
  "name": "FloatArray.foldlMUnsafe"},
 {"type": "ℕ → Array ℕ",
  "offspring": ["Nat.fold", "flip", "Array.push"],
  "name": "Array.range"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«stx_,*»"},
 {"type": "(ε σ : Type) → Monad (EST ε σ)",
  "offspring": [],
  "name": "instMonadEST"},
 {"type": "ℕ → Lean.Expr → Lean.Expr × Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.buildReify.reifyFmla"},
 {"type":
  "{δ : outParam (Type u)} → {σ : Type u} → (σ → δ) → (σ → δ → σ) → EStateM.Backtrackable δ σ",
  "offspring": [],
  "name": "EStateM.Backtrackable.mk"},
 {"type": "{α : Type u_1} → [inst : Hashable α] → Hashable (Option α)",
  "offspring": ["Hashable.mk", "mixHash", "Hashable.hash"],
  "name": "instHashableOption"},
 {"type": "∀ {a b : Prop} {p : Prop → Prop}, (a ↔ b) → p a → p b",
  "offspring": ["Eq.subst"],
  "name": "Iff.subst"},
 {"type": "DecidableEq UInt8",
  "offspring": ["UInt8.decEq"],
  "name": "instDecidableEqUInt8"},
 {"type": "Float → UInt16", "offspring": [], "name": "Float.toUInt16"},
 {"type": "∀ (n m : ℕ), n + m = m + n",
  "offspring": ["Nat.zero_add"],
  "name": "Nat.add_comm"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.LeftInverse f g → f ∘ g = id",
  "offspring": [],
  "name": "Function.LeftInverse.comp_eq_id"},
 {"type": "Lean.Expr → ℕ → Lean.Expr → ℕ → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.buildReify.mkPS"},
 {"type": "∀ {α β : Type u_1} {a : α} {f : α → β}, f <$> some a = some (f a)",
  "offspring": [],
  "name": "Option.map_some"},
 {"type":
  "(ω σ : Type) → (m : Type → Type) → MonadControl m (StateRefT' ω σ m)",
  "offspring": [],
  "name": "instMonadControlStateRefT'"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → {γ : Type u_3} → (α → β ⊕ γ) → List α → List β × List γ",
  "offspring": ["Prod.map"],
  "name": "List.partitionMap"},
 {"type": "∀ {p : Prop} {q : p → Prop} (h : p), (∀ (h' : p), q h') ↔ q h",
  "offspring": [],
  "name": "forall_prop_of_true"},
 {"type": "∀ {a b : Prop}, a ∧ b → b ∧ a", "offspring": [], "name": "And.symm"},
 {"type": "∀ (val : Fin USize.size), sizeOf { val := val } = 1 + sizeOf val",
  "offspring": [],
  "name": "USize.mk.sizeOf_spec"},
 {"type": "{f : Type u → Type v} → [self : Pure f] → {α : Type u} → α → f α",
  "offspring": [],
  "name": "Pure.pure"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} (s : Subtype p), sizeOf s = sizeOf s.val + 1",
  "offspring":
  ["Subtype.mk.sizeOf_spec", "sizeOf_default", "Nat.add_zero", "Nat.zero_add"],
  "name": "Subtype.sizeOf"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.RightInverse f g ↔ g ∘ f = id",
  "offspring": ["Function.RightInverse.comp_eq_id", "congr_fun"],
  "name": "Function.RightInverse_iff_comp"},
 {"type": "∀ {α : Type u_1}, Subsingleton (Squash α)",
  "offspring": ["Subsingleton.intro", "Squash.ind", "Quot.sound", "True.intro"],
  "name": "instSubsingletonSquash.proof_1"},
 {"type": "Add USize",
  "offspring": ["Add.mk", "USize.add"],
  "name": "instAddUSize"},
 {"type":
  "{α : Type u_1} →\n  {R : α → α → Prop} →\n    {motive : (a : α) → (a_1 : List α) → List.Chain R a a_1 → Prop} →\n      {a : α} → {a_1 : List α} → List.Chain R a a_1 → Prop",
  "offspring": [],
  "name": "List.Chain.below"},
 {"type": "∀ (n : ℕ), 0 + n = n", "offspring": [], "name": "Nat.zero_add"},
 {"type": "{α : Type u_1} → (α → α → α) → Option α → Option α → Option α",
  "offspring": [],
  "name": "Option.lift_or_get"},
 {"type": "(a b : ℤ) → Decidable (a ≤ b)",
  "offspring": ["Int.NonNeg.mk"],
  "name": "Int.decLe"},
 {"type": "Char → String",
  "offspring": ["hexDigitRepr", "HDiv.hDiv"],
  "name": "charToHex"},
 {"type": "Hashable UInt64",
  "offspring": ["Hashable.mk"],
  "name": "instHashableUInt64"},
 {"type":
  "∀ (x : ℕ) (a : UInt16),\n  { val := Ring.gsmul (Int.ofNat (Nat.succ x)) a.val } =\n    { val := (a + (fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat x) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_succ'"],
  "name": "UInt16.instRingUInt16.proof_4"},
 {"type":
  "∀ {α : Sort u} {t : False → α} {e : ¬False → α}, dite False t e = e not_false",
  "offspring": [],
  "name": "dite_false"},
 {"type": "Sort u → Bool → Bool → Sort u",
  "offspring": [],
  "name": "Bool.noConfusionType"},
 {"type": "Semiring USize",
  "offspring":
  ["Semiring.mk",
   "USize.instSemiringUSize.proof_13",
   "USize.instSemiringUSize.proof_14",
   "USize.instSemiringUSize.proof_15",
   "USize.instSemiringUSize.proof_16",
   "Semigroup",
   "USize.instSemigroupUSize",
   "AddCommSemigroup",
   "USize.instAddCommSemigroupUSize"],
  "name": "USize.instSemiringUSize"},
 {"type": "ℕ → ℤ", "offspring": [], "name": "Int.negOfNat"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [inst : MonadExcept ε m] → {α : Type v} → m α → m α → optParam Bool true → m α",
  "offspring": ["MonadExcept.tryCatch"],
  "name": "MonadExcept.orelse'"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {motive : Quot r → Prop},\n  (∀ (a : α), motive (Quot.mk r a)) → ∀ (a : α), (_ : motive (Quot.mk r a)) = (_ : motive (Quot.mk r a))",
  "offspring": [],
  "name": "Quot.indBeta"},
 {"type": "∀ {n m : ℕ}, n ≤ m → n < m ∨ n = m",
  "offspring": ["Or.imp_right", "Nat.le_antisymm", "Nat.lt_or_ge"],
  "name": "Nat.lt_or_eq_of_le"},
 {"type": "{a : Prop} → {α : Sort u_1} → ¬a → a → α",
  "offspring": [],
  "name": "Not.elim"},
 {"type": "OrOp UInt32",
  "offspring": ["OrOp.mk", "UInt32.lor"],
  "name": "instOrOpUInt32"},
 {"type":
  "{α : Type u} →\n  [inst : Preorder α] →\n    ({g : Type} → (lo hi : α) → lo ≤ hi → [inst_1 : RandomGen g] → RandG g { a // lo ≤ a ∧ a ≤ hi }) → BoundedRandom α",
  "offspring": [],
  "name": "BoundedRandom.mk"},
 {"type":
  "{α : Type u} → (as : Array α) → (start stop : ℕ) → start ≤ stop → stop ≤ Array.size as → Subarray α",
  "offspring": [],
  "name": "Subarray.mk"},
 {"type": "Lean.Meta.Simp.Context → Lean.Expr → Array Lean.Name",
  "offspring":
  ["Mathlib.Tactic.Lint.heuristicallyExtractSimpTheoremsCore",
   "Mathlib.Tactic.Lint.constToSimpDeclMap"],
  "name": "Mathlib.Tactic.Lint.heuristicallyExtractSimpTheorems"},
 {"type": "{α : Type u} → {β : Type v} → α × β → β",
  "offspring": [],
  "name": "Prod.snd"},
 {"type": "∀ {α : Sort u_1}, ¬Nonempty α ↔ α → False",
  "offspring": [],
  "name": "not_nonempty_iff_imp_false"},
 {"type": "∀ {α : Type u_1} {l₁ l₂ l₃ : List α}, l₁ ~ l₂ → l₂ ~ l₃ → l₁ ~ l₃",
  "offspring": [],
  "name": "List.Perm.trans"},
 {"type":
  "{α : Type u_1} → {R : α → α → Prop} → [inst : DecidableRel R] → (l : List α) → Decidable (List.Pairwise R l)",
  "offspring":
  ["List.decidablePairwise.proof_1",
   "List.Pairwise.nil",
   "decidableBAll",
   "List.decidablePairwise.proof_2",
   "List.decidablePairwise.proof_3",
   "List.decidablePairwise.proof_4"],
  "name": "List.decidablePairwise"},
 {"type": "FloatArray",
  "offspring": ["FloatArray.mkEmpty"],
  "name": "FloatArray.empty"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.disjoint"},
 {"type": "∀ {a b : Prop}, (a → b) → ¬b → ¬a", "offspring": [], "name": "mt"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (stop : ℕ), stop ≤ Array.size as → ∀ (x : ℕ), x < stop → x < Array.size as",
  "offspring": ["Nat.lt_of_lt_of_le"],
  "name": "Array.anyM.loop.proof_2"},
 {"type":
  "∀ {α : Type u} [inst : BEq α], (∀ (a b : α), (a == b) = true → a = b) → (∀ (a : α), (a == a) = true) → LawfulBEq α",
  "offspring": [],
  "name": "LawfulBEq.mk"},
 {"type": "{α : Type u} → [self : LE α] → α → α → Prop",
  "offspring": [],
  "name": "LE.le"},
 {"type": "{α : Type u} → (ℕ → Bool → ℕ → α) → OfScientific α",
  "offspring": [],
  "name": "OfScientific.mk"},
 {"type":
  "∀ {α : Type u} (as : List α) (n : ℕ), List.length as + n = List.lengthTRAux as n",
  "offspring": ["Nat.zero_add", "Nat.succ_add"],
  "name": "List.length_add_eq_lengthTRAux"},
 {"type": "∀ (n m : Fin USize.size), n = m → { val := n } = { val := m }",
  "offspring": [],
  "name": "USize.decEq.proof_1"},
 {"type":
  "(α : Type) → Lean.Expr → Lean.Syntax → optParam Lean.DefinitionSafety Lean.DefinitionSafety.safe → Lean.Elab.TermElabM α",
  "offspring": ["Mathlib.Eval.evalExpr"],
  "name": "Mathlib.Eval.evalTerm"},
 {"type": "{α : Type u_1} → Option α → (Unit → Option α) → Option α",
  "offspring": [],
  "name": "Option.orElse"},
 {"type": "∀ {m n a : ℕ}, Nat.coprime m n → a ∣ n → Nat.coprime m (n / a)",
  "offspring": ["Nat.coprime.symm", "Nat.coprime.coprime_div_left"],
  "name": "Nat.coprime.coprime_div_right"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, a ∈ l → List.insert a l = l",
  "offspring":
  ["if_pos", "List.instDecidableMemListInstMembershipList", "List"],
  "name": "List.insert_of_mem"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (x : α), Array.get? (Array.push a x) (Array.size a) = some x",
  "offspring":
  ["List.concat_eq_append", "Array.get?_eq_get?", "List.get?_concat_length"],
  "name": "Array.get?_push_eq"},
 {"type": "∀ {α : Sort u_1} (b : plift α), { down := b.down } = b",
  "offspring": ["plift.up", "plift.down"],
  "name": "plift.up_down"},
 {"type": "∀ (a b : ℕ), ((!a == b) = true) = ¬a = b",
  "offspring":
  ["not", "instBEqNat", "LawfulBEq.rfl", "Nat.instLawfulBEqNatInstBEqNat"],
  "name": "Nat.not_beq_eq_true_eq"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (n : ℕ) (a : α) (l : List α),\n  List.repeat' a (n - List.length l) <+: List.leftpad n a l",
  "offspring": [],
  "name": "List.leftpad_prefix"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.disjoint l₁ l₂ ↔ ∀ (a : α), a ∈ l₁ → ∀ (b : α), b ∈ l₂ → a ≠ b",
  "offspring": [],
  "name": "List.disjoint_iff_ne"},
 {"type": "Type u → Type u", "offspring": [], "name": "ShiftLeft"},
 {"type": "∀ (n k m : ℕ), n + k - (m + k) = n - m",
  "offspring":
  ["Nat.zero_eq", "Nat.add_zero", "Nat.add_succ", "Nat.succ_sub_succ"],
  "name": "Nat.add_sub_add_right"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f : α → β} (h : Function.surjective f) (b : β), f (Function.surj_inv h b) = b",
  "offspring": ["Classical.choose_spec"],
  "name": "Function.surj_inv_eq"},
 {"type": "Sat.Valuation → Sat.Fmla → Prop",
  "offspring": [],
  "name": "Sat.Valuation.satisfies_fmla"},
 {"type": "outParam (Type u) → Type v → Type (max u v)",
  "offspring": [],
  "name": "Membership"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMul α β γ",
  "offspring": [],
  "name": "HMul.mk"},
 {"type": "∀ (a : ℤ) {b : ℤ}, 0 < b → a < a + b",
  "offspring": [],
  "name": "Int.lt_add_of_pos_right"},
 {"type": "{a b : Prop} → {α : Sort u_1} → (a → b → α) → a ∧ b → α",
  "offspring": [],
  "name": "And.elim"},
 {"type": "FloatArray → ℕ → Float",
  "offspring": ["Array.get!", "instInhabitedFloat"],
  "name": "FloatArray.get!"},
 {"type":
  "∀ (f : Type u_2 → Type u_1) [inst : Functor f] [inst_1 : LawfulFunctor f] {α β : Type u_2} (h : α ≃ β) (x : f α),\n  (Equiv.symm h).toFun <$> h.toFun <$> x = x",
  "offspring":
  ["Functor.map_map", "Equiv.symm_comp_self", "LawfulFunctor.id_map"],
  "name": "Functor.map_equiv.proof_1"},
 {"type": "∀ (a : ℤ), 0 * a = 0",
  "offspring": ["Int.mul_zero", "Int.mul_comm"],
  "name": "Int.zero_mul"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} (f : α → β),\n  (∀ (a : α), p a → q (f a)) → ∀ (x : Subtype p), q (f x.val)",
  "offspring": ["Subtype.val", "Subtype.prop"],
  "name": "Subtype.map.proof_1"},
 {"type": "ShiftRight UInt8",
  "offspring": ["ShiftRight.mk", "UInt8.shiftRight"],
  "name": "instShiftRightUInt8"},
 {"type": "∀ (a : ℤ), a + 0 = a", "offspring": [], "name": "Int.add_zero"},
 {"type": "{g : Type} → [inst : RandomGen g] → RandG g (ℕ × ℕ)",
  "offspring": ["MonadState.get", "RandomGen.range", "ULift.down"],
  "name": "Rand.range"},
 {"type":
  "∀ {α : Type u_1} {a : Option α}, Option.isSome a = false ↔ Option.isNone a = true",
  "offspring":
  ["Option.isSome_none",
   "Option.isNone_none",
   "Option.isSome_some",
   "eq_false_of_decide",
   "Option.isNone_some"],
  "name": "Option.not_isSome"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} (f : (x : α) → β x), Function.Equiv f f",
  "offspring": [],
  "name": "Function.Equiv.refl"},
 {"type": "{α : Type u_1} → (lt : α → α → Bool) → BinaryHeap α lt",
  "offspring": ["BinaryHeap.mk"],
  "name": "BinaryHeap.empty"},
 {"type": "Sub Float",
  "offspring": ["Sub.mk", "Float.sub"],
  "name": "instSubFloat"},
 {"type": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), a + c ≤ b + c",
  "offspring": ["Int.add_le_add_left", "Int.add_comm"],
  "name": "Int.add_le_add_right"},
 {"type":
  "{stream : Type u} → {value : outParam (Type v)} → Sort u_1 → Stream stream value → Stream stream value → Sort u_1",
  "offspring": [],
  "name": "Stream.noConfusionType"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b ≤ b",
  "offspring":
  ["if_pos",
   "instDecidableLeToLEToPreorderToPartialOrder",
   "if_neg",
   "le_refl"],
  "name": "min_le_right"},
 {"type": "∀ {α : Sort u_1} (p : α → Prop), (∃ x, p x) → Nonempty { x // p x }",
  "offspring": ["Nonempty", "Subtype", "Subtype.mk"],
  "name": "Classical.indefiniteDescription.proof_1"},
 {"type": "¬True ↔ False",
  "offspring": ["iff_false_intro", "not_not_intro", "trivial"],
  "name": "not_true"},
 {"type": "HDiv System.FilePath String System.FilePath",
  "offspring": ["HDiv.mk", "System.FilePath.join", "System.FilePath.mk"],
  "name": "System.FilePath.instHDivFilePathString"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → (List α → List β) → List β",
  "offspring": [],
  "name": "List.sublistsAux₁"},
 {"type": "∀ {b a : ℕ}, 0 < b → b ≤ a → a / b = (a - b) / b + 1",
  "offspring": ["Nat.div_eq", "if_pos"],
  "name": "Nat.div_eq_sub_div"},
 {"type": "∀ (a b : UInt32), a % b = { val := a.val % b.val }",
  "offspring": [],
  "name": "UInt32.mod_def"},
 {"type":
  "∀ (eq : Bool) (lhs rhs : Nat.Linear.Expr),\n  sizeOf { eq := eq, lhs := lhs, rhs := rhs } = 1 + sizeOf eq + sizeOf lhs + sizeOf rhs",
  "offspring": ["Nat.Linear.Expr"],
  "name": "Nat.Linear.ExprCnstr.mk.sizeOf_spec"},
 {"type": "∀ {m n k : ℕ}, Nat.coprime k n → k ∣ m * n → k ∣ m",
  "offspring":
  ["Nat.mul_one",
   "Nat.gcd",
   "Nat.coprime.gcd_eq_one",
   "Nat.gcd_mul_left",
   "Nat.dvd_gcd",
   "Nat.dvd_mul_left"],
  "name": "Nat.coprime.dvd_of_dvd_mul_right"},
 {"type":
  "∀ (e : Lean.Expr) (a : Tactic.Ring.HornerExpr) (x n : Lean.Expr × ℕ) (b : Tactic.Ring.HornerExpr),\n  sizeOf (Tactic.Ring.HornerExpr.xadd e a x n b) = 1 + sizeOf e + sizeOf a + sizeOf x + sizeOf n + sizeOf b",
  "offspring": ["Tactic.Ring.HornerExpr"],
  "name": "Tactic.Ring.HornerExpr.xadd.sizeOf_spec"},
 {"type": "Substring → ℕ → Substring",
  "offspring": ["Substring.mk", "Substring.prevn", "Substring.bsize"],
  "name": "Substring.dropRight"},
 {"type": "{α : Type u} → [inst : Preorder α] → Trans GT.gt GE.ge GT.gt",
  "offspring": ["Trans.mk", "instTransGtToLTGeToLE.proof_1"],
  "name": "instTransGtToLTGeToLE"},
 {"type": "UInt8 → UInt16",
  "offspring": ["Nat.toUInt16", "UInt8.toNat"],
  "name": "UInt8.toUInt16"},
 {"type": "∀ {a b : Prop}, (a ↔ b) ↔ a ∧ b ∨ ¬a ∧ ¬b",
  "offspring": ["Decidable.iff_iff_and_or_not_and_not"],
  "name": "iff_iff_and_or_not_and_not"},
 {"type":
  "{F : Type u → Type v} → [inst : Applicative F] → {α : Type u_1} → {β : Type u} → (α → F β) → List α → F (List β)",
  "offspring": ["Seq.seq", "Functor.map"],
  "name": "List.traverse"},
 {"type":
  "∀ {α : Type u_1} (f : α → α) (n : ℕ) (l : List α) (m : ℕ),\n  List.get? (List.modifyNth f n l) m = (fun a => if n = m then f a else a) <$> List.get? l m",
  "offspring":
  ["Functor.map",
   "Option.instFunctorOption",
   "if_pos",
   "instDecidableFalse",
   "if_false",
   "mt",
   "Nat.succ.inj",
   "not_false_iff"],
  "name": "List.get?_modifyNth"},
 {"type": "Inhabited UInt32",
  "offspring": ["UInt32.ofNatCore", "instInhabitedUInt32.proof_1"],
  "name": "instInhabitedUInt32"},
 {"type": "∀ {G : Type u} [self : CommSemigroup G] (a b : G), a * b = b * a",
  "offspring": [],
  "name": "CommSemigroup.mul_comm"},
 {"type": "{m : Type u → Type v} → [self : Monad m] → Applicative m",
  "offspring": [],
  "name": "Monad.toApplicative"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HXor α β γ] → α → β → γ",
  "offspring": [],
  "name": "HXor.hXor"},
 {"type": "{α : Sort u} → Setoid α → Sort u",
  "offspring": ["Quot", "Setoid.r"],
  "name": "Quotient"},
 {"type": "Inhabited NonScalar",
  "offspring": ["NonScalar.mk", "Inhabited.default", "instInhabitedNat"],
  "name": "instInhabitedNonScalar"},
 {"type":
  "{m : Type u → Type v} → (ε : Type u) → [inst : Monad m] → [inst : MonadExceptOf ε m] → MonadExceptOf ε (OptionT m)",
  "offspring": ["MonadExceptOf.mk", "OptionT.mk", "throwThe", "tryCatchThe"],
  "name": "OptionT.instMonadExceptOfOptionT"},
 {"type": "∀ {b a : Prop}, ¬(a → b) → ¬b",
  "offspring": ["mt", "imp_intro"],
  "name": "not_of_not_imp"},
 {"type": "∀ (a b : ℤ), a - b + b = a",
  "offspring": ["Int.neg_add_cancel_right"],
  "name": "Int.sub_add_cancel"},
 {"type": "{n : ℕ} → AndOp (Fin n)",
  "offspring": ["AndOp.mk", "Fin.land"],
  "name": "Fin.instAndOpFin"},
 {"type": "Nat.Linear.ExprCnstr → Nat.Linear.PolyCnstr",
  "offspring":
  ["Nat.Linear.Poly",
   "Nat.Linear.PolyCnstr.mk",
   "Nat.Linear.ExprCnstr.eq",
   "Nat.Linear.Poly.cancel",
   "Nat.Linear.Expr.toNormPoly",
   "Nat.Linear.ExprCnstr.lhs",
   "Nat.Linear.ExprCnstr.rhs"],
  "name": "Nat.Linear.ExprCnstr.toNormPoly"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {r : α → β → Prop} {a : α} {b : β}, r a b → Option.rel r (some a) (some b)",
  "offspring": [],
  "name": "Option.rel.some"},
 {"type": "{gen : Type u} → [inst : RandomGen gen] → gen → ℕ → ℕ → ℕ × gen",
  "offspring": ["RandomGen.range", "GT.gt"],
  "name": "randNat"},
 {"type": "Nat.Linear.PolyCnstr → Nat.Linear.ExprCnstr",
  "offspring":
  ["Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.PolyCnstr.eq",
   "Nat.Linear.Poly.toExpr",
   "Nat.Linear.PolyCnstr.lhs",
   "Nat.Linear.PolyCnstr.rhs"],
  "name": "Nat.Linear.PolyCnstr.toExpr"},
 {"type": "∀ {a b : UInt64}, a.val = b.val → a = b",
  "offspring": ["UInt64.mk"],
  "name": "UInt64.eq_of_val_eq"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.injective f → ∀ {x y : α}, f x ≠ f y ↔ x ≠ y",
  "offspring": ["mt", "congr_arg", "Function.injective.ne"],
  "name": "Function.injective.ne_iff"},
 {"type": "Sort u → outParam (Sort v) → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "CoeSort"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.bijective f → Function.surjective f",
  "offspring": [],
  "name": "Function.bijective.surjective"},
 {"type": "Type", "offspring": [], "name": "ByteSlice"},
 {"type": "UInt8 → UInt8", "offspring": [], "name": "UInt8.complement"},
 {"type": "Lean.Name → Lean.CoreM Bool",
  "offspring": ["List.any"],
  "name": "Mathlib.Tactic.Lint.isAutoDecl"},
 {"type": "Type", "offspring": [], "name": "Nat.Linear.ExprCnstr"},
 {"type": "∀ {a b c : ℤ}, a < c - b → a + b < c",
  "offspring": [],
  "name": "Int.add_lt_of_lt_sub_right"},
 {"type": "∀ {n m : ℕ}, m < n → ¬n ≤ m",
  "offspring": ["Nat.not_le_of_gt"],
  "name": "Nat.not_le_of_lt"},
 {"type":
  "∀ {σ : Type u} [inst : SizeOf σ] (a : σ), sizeOf (DoResultBC.break a) = 1 + sizeOf a",
  "offspring": [],
  "name": "DoResultBC.break.sizeOf_spec"},
 {"type": "∀ (b : Bool), (true && b) = b",
  "offspring": [],
  "name": "Bool.true_and"},
 {"type":
  "{α : Type u_1} → (r : α → α → Prop) → [s : DecidableRel r] → DecidableRel (Option.lt r)",
  "offspring": ["trivial", "not_false"],
  "name": "Option.instDecidableRelOptionLt"},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (β → UInt8 → m β) → ByteArray → USize → USize → β → m β",
  "offspring": ["ByteArray.uget", "lcProof", "ByteArray.foldlMUnsafe.fold"],
  "name": "ByteArray.foldlMUnsafe.fold"},
 {"type": "∀ (a : ℕ), sizeOf (Int.ofNat a) = 1 + sizeOf a",
  "offspring": ["instSizeOfNat"],
  "name": "Int.ofNat.sizeOf_spec"},
 {"type":
  "∀ {α : Type u} (a : Array α) (v : α), Array.size (Array.push a v) = Array.size a + 1",
  "offspring": ["List.length_concat", "Array.data"],
  "name": "Array.size_push"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "Int.«term-[1+_]»"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.denote ctx (Nat.Linear.ExprCnstr.toPoly c) = Nat.Linear.ExprCnstr.denote ctx c",
  "offspring":
  ["Nat.Linear.ExprCnstr",
   "cond_true",
   "Nat.Linear.Expr.denote_toPoly",
   "Bool.of_not_eq_true",
   "cond_false"],
  "name": "Nat.Linear.ExprCnstr.denote_toPoly"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {l : List α}, (∀ (a : α), a ∈ l → ¬p a) → List.erasep p l = l",
  "offspring":
  ["List.erasep_cons_of_neg",
   "List.Mem.head",
   "List.forall_mem_of_forall_mem_cons"],
  "name": "List.erasep_of_forall_not"},
 {"type": "∀ {a b c : ℤ}, a + b < a + c → b < c",
  "offspring": [],
  "name": "Int.lt_of_add_lt_add_left"},
 {"type": "ℕ → ℕ → ℕ", "offspring": [], "name": "Nat.shiftLeft"},
 {"type": "∀ (p : Prop), (p ∧ False) = False",
  "offspring": [],
  "name": "and_false"},
 {"type":
  "∀ {β : Type v} (rb : β → β → Prop) {a₂ : ℕ} {b₂ : β} {a₁ : ℕ} {b₁ : β},\n  a₁ ≤ a₂ → rb b₁ b₂ → Prod.Lex Nat.lt rb (a₁, b₁) (a₂, b₂)",
  "offspring": ["Prod.Lex.right'.proof_1"],
  "name": "Prod.Lex.right'"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → List β} {b : β} {l : List α}, b ∈ List.bind l f ↔ ∃ a, a ∈ l ∧ b ∈ f a",
  "offspring": ["List.mem_join", "List.mem_map"],
  "name": "List.mem_bind"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l : List α} (h₁ : a :: l ≠ []) (h₂ : l ≠ []), List.getLast (a :: l) h₁ = List.getLast l h₂",
  "offspring": [],
  "name": "List.getLast_cons"},
 {"type": "∀ (a b c : ℤ), a + b - c = a + (b - c)",
  "offspring": ["Int.sub_eq_add_neg", "Int.add_assoc"],
  "name": "Int.add_sub_assoc"},
 {"type": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), a - c ≤ b - c",
  "offspring": ["Int.add_le_add_right"],
  "name": "Int.sub_le_sub_right"},
 {"type": "Type u_1 → Type u_1", "offspring": [], "name": "UFNode"},
 {"type": "∀ {a : Prop}, (a ↔ False) → ¬a",
  "offspring": [],
  "name": "not_of_iff_false"},
 {"type": "∀ {α : Type u_1} {l : List α}, l = [] ↔ ∀ (a : α), ¬a ∈ l",
  "offspring": [],
  "name": "List.eq_nil_iff_forall_not_mem"},
 {"type": "∀ {α : Type u_1} (l : List α), l ~ l",
  "offspring": ["List.Perm.nil", "List.Perm.cons"],
  "name": "List.Perm.refl"},
 {"type":
  "∀ {A : Type u} [inst : AddSemigroup A] [inst_1 : IsAddLeftCancel A] {a b c : A}, a + b = a + c ↔ b = c",
  "offspring": ["add_left_cancel"],
  "name": "add_left_cancel_iff"},
 {"type": "ℕ → ℕ → ℕ", "offspring": ["Nat.bitwise"], "name": "Nat.land"},
 {"type": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "offspring": [],
  "name": "Subtype.mk"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Mathlib.Tactic.renameArg"],
  "name": "Mathlib.Tactic.rename'"},
 {"type":
  "∀ (p : ℕ → Prop) [inst : DecidablePred p] (H : ∃ n, p n) {m : ℕ}, m < Nat.find p H → ¬p m",
  "offspring": ["Subtype.property", "Nat.find_x"],
  "name": "Nat.find_min"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (x : α) (n : ℕ) (b : α), Tactic.Ring.horner 0 x n b = b",
  "offspring": ["MonoidWithZero.zero_mul", "zero_add"],
  "name": "Tactic.Ring.zero_horner"},
 {"type": "Float → Float → Float", "offspring": [], "name": "Float.div"},
 {"type": "{α : Type u} → (α → α → Bool) → BEq α",
  "offspring": [],
  "name": "BEq.mk"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] (a : A), a + -a = 0",
  "offspring": ["add_right_neg"],
  "name": "add_neg_self"},
 {"type": "{n : ℕ} → AddCommSemigroup (Fin n)",
  "offspring": ["AddCommSemigroup.mk", "instAddCommSemigroupFin.proof_2"],
  "name": "instAddCommSemigroupFin"},
 {"type": "∀ {α : Type u} (as : List α), [] ++ as = as",
  "offspring": [],
  "name": "List.nil_append"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk"],
  "name": "UInt16.mod"},
 {"type":
  "{α : Type u_1} → (a : Array α) → (n : ℕ) → Array.size a = n → (i : ℕ) → i ≤ Array.size a → List α → List α",
  "offspring":
  ["Array.toListLitAux.proof_1", "Array.getLit", "Array.toListLitAux.proof_2"],
  "name": "Array.toListLitAux"},
 {"type": "{α : Type u_1} → Set (Set α) → Set α",
  "offspring": ["setOf"],
  "name": "Set.sUnion"},
 {"type": "{ε : Type u} → Monad (Except ε)",
  "offspring": ["Monad.mk"],
  "name": "Except.instMonadExcept"},
 {"type": "Substring → ℕ → Substring",
  "offspring": ["Substring.mk", "Substring.prevn", "Substring.bsize"],
  "name": "Substring.takeRight"},
 {"type": "{α : Sort u} → {β : Sort v} → PProd α β → α",
  "offspring": [],
  "name": "PProd.fst"},
 {"type":
  "∀ {α : Sort u} {b c : Prop} [dec_b : Decidable b] {x : b → α} {u : c → α} {y : ¬b → α} {v : ¬c → α},\n  (b ↔ c) → (∀ (h : c), x (_ : b) = u h) → (∀ (h : ¬c), y (_ : ¬b) = v h) → dite b x y = dite c u v",
  "offspring": ["dif_ctx_congr"],
  "name": "dif_ctx_simp_congr"},
 {"type": "∀ {n : ℕ} {i j : Fin n}, i = j → ↑i = ↑j",
  "offspring": [],
  "name": "Fin.val_eq_of_eq"},
 {"type": "@List.length = @List.lengthTR",
  "offspring": ["List.length_add_eq_lengthTRAux", "Nat.add_zero"],
  "name": "List.length_eq_lengthTR"},
 {"type": "Type u → Type u", "offspring": [], "name": "Preorder"},
 {"type": "ℕ → ℕ → ℕ", "offspring": [], "name": "Nat.max"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {γ : Sort u_1} (f : α → β) {g : γ → α},\n  Function.bijective g → (Function.injective (f ∘ g) ↔ Function.injective f)",
  "offspring":
  ["Function.bijective.surjective",
   "Function.injective.comp",
   "Function.bijective.injective"],
  "name": "Function.injective.of_comp_iff'"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop} (h : ∃ x, p x), p (Classical.choose h)",
  "offspring": ["Subtype.property"],
  "name": "Classical.choose_spec"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop}, (ExistsUnique fun x => p x) → ∀ {y₁ y₂ : α}, p y₁ → p y₂ → y₁ = y₂",
  "offspring": [],
  "name": "unique_of_exists_unique"},
 {"type": "UInt64 → UInt64", "offspring": [], "name": "UInt64.complement"},
 {"type": "(a b : UInt32) → Decidable (a = b)",
  "offspring": ["UInt32.decEq.proof_1", "UInt32.decEq.proof_2"],
  "name": "UInt32.decEq"},
 {"type":
  "{α : Type u} →\n  {β : Type v} → [inst : Inhabited α] → [inst : Inhabited β] → (α → α → Bool) → (Option α → β) → Array α → α → ℕ → ℕ → β",
  "offspring": [],
  "name": "Array.binSearchAux"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HDiv"},
 {"type": "{a : Prop} → (b : Prop) → (a ↔ b) → [D : Decidable b] → Decidable a",
  "offspring": ["decidable_of_decidable_of_iff", "Iff.symm"],
  "name": "decidable_of_iff'"},
 {"type": "∀ {α : Sort u_1} {r : α → α → Prop} {z : α}, Acc r z → Acc (TC r) z",
  "offspring": ["Acc.intro", "Acc.inv"],
  "name": "TC.accessible.proof_1"},
 {"type": "{α : Type u_1} → [inst : BEq α] → BEq (Array α)",
  "offspring": ["BEq.mk", "Array.isEqv"],
  "name": "Array.instBEqArray"},
 {"type":
  "∀ {α : Type u_1}, Option.isSome (Option.choice α) = true ↔ Nonempty α",
  "offspring": ["Option.get", "dif_pos", "Option.isSome_some"],
  "name": "Option.choice_isSome_iff_nonempty"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β), e.invFun = (Equiv.symm e).toFun",
  "offspring": [],
  "name": "Equiv.inv_fun_as_coe"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, Function.injective Subtype.val",
  "offspring": ["Subtype.coe_injective"],
  "name": "Subtype.val_injective"},
 {"type": "{α : Type u} → [inst : ToString α] → ToString (ULift α)",
  "offspring": ["ToString.mk", "ULift.down"],
  "name": "instToStringULift"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.disjoint l₁ l₂ → List.disjoint l₂ l₁",
  "offspring": [],
  "name": "List.disjoint_symm"},
 {"type":
  "{G : Type u} → Sort u_1 → CommSemigroup G → CommSemigroup G → Sort u_1",
  "offspring": [],
  "name": "CommSemigroup.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {l l₁ l₂ : List α}, l₂ ⊆ l → List.disjoint l₁ l → List.disjoint l₁ l₂",
  "offspring": [],
  "name": "List.disjoint_of_subset_right"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "Seq"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → β → Prop) → Option α → Option β → Prop",
  "offspring": [],
  "name": "Option.rel"},
 {"type": "∀ {α : Sort u} (a : α), HEq a a",
  "offspring": [],
  "name": "HEq.refl"},
 {"type":
  "∀ {α : Type u_1} {arr : Array (UFNode α)} {n : ℕ} {m : UFModel n},\n  UFModel.Models arr m →\n    ∀ (i : ℕ) (h₁ : i < Array.size arr) (h₂ : i < n),\n      (Array.get arr { val := i, isLt := h₁ }).parent = ↑(UFModel.parent m { val := i, isLt := h₂ })",
  "offspring": ["UFModel.Agrees.get_eq"],
  "name": "UFModel.Models.parent_eq"},
 {"type": "∀ {a b c : ℤ}, -b < a - c → c < a + b",
  "offspring": ["Int.lt_add_of_sub_right_lt", "Int.add_lt_of_lt_sub_left"],
  "name": "Int.lt_add_of_neg_lt_sub_right"},
 {"type": "ToString ℕ",
  "offspring": ["ToString.mk", "Nat.repr"],
  "name": "instToStringNat"},
 {"type": "∀ {n m k : ℕ}, 0 < m → n * m = k * m → n = k",
  "offspring": ["Nat.eq_of_mul_eq_mul_left"],
  "name": "Nat.eq_of_mul_eq_mul_right"},
 {"type":
  "∀ (b f n : ℕ) (c : Char) (tl : List Char),\n  List.length (Nat.toDigitsCore b f n (c :: tl)) = List.length (Nat.toDigitsCore b f n tl) + 1",
  "offspring": ["if_true", "instDecidableFalse", "if_false"],
  "name": "Nat.to_digits_core_lens_eq"},
 {"type":
  "(Type u → Type v) → (Type u → Type w) → Type (max (max (u + 1) v) w)",
  "offspring": [],
  "name": "MonadFunctor"},
 {"type": "{p q : Prop} → [hp : Decidable p] → p = q → Decidable q",
  "offspring": [],
  "name": "decidable_of_decidable_of_eq"},
 {"type":
  "{α : Type u_1} → [inst : BEq α] → (a : Array α) → α → Option (Fin (Array.size a))",
  "offspring": ["Array.indexOfAux"],
  "name": "Array.indexOf?"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) ↔ ∃ a b, q { val := a, property := b }",
  "offspring": ["Subtype.mk"],
  "name": "Subtype.exists"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_⊕_»"},
 {"type": "Sort u → Tactic.NormCast.Label → Tactic.NormCast.Label → Sort u",
  "offspring":
  ["noConfusionTypeEnum",
   "Tactic.NormCast.Label",
   "Tactic.NormCast.Label.toCtorIdx"],
  "name": "Tactic.NormCast.Label.noConfusionType"},
 {"type": "{α : Sort u} → {β : α → Sort v} → PSigma β → α",
  "offspring": [],
  "name": "PSigma.fst"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {a : α} {l : List α},\n  List.Pairwise R (a :: l) ↔ (∀ (a' : α), a' ∈ l → R a a') ∧ List.Pairwise R l",
  "offspring": ["List.Pairwise", "And.elim", "List.Pairwise.cons"],
  "name": "List.Pairwise_cons"},
 {"type": "∀ {a b c : ℤ}, b ≤ c → 0 < a → b < c + a",
  "offspring": ["Int.add_lt_add_of_le_of_lt", "Int.add_zero"],
  "name": "Int.lt_add_of_le_of_pos"},
 {"type":
  "∀ {α : Type u} {β : Type v} [inst : SizeOf α] [inst_1 : SizeOf β] (val : β), sizeOf (Sum.inr val) = 1 + sizeOf val",
  "offspring": [],
  "name": "Sum.inr.sizeOf_spec"},
 {"type": "∀ {n m : ℕ}, n ≤ m → ∃ k, n + k = m",
  "offspring": ["Nat.not_succ_le_zero"],
  "name": "Nat.le.dest"},
 {"type": "∀ {a b : ℤ}, a ≤ b → ∃ n, a + ↑n = b",
  "offspring":
  ["Int.add_comm",
   "Int.sub_eq_add_neg",
   "Int.add_assoc",
   "add_left_neg",
   "add_zero",
   "Int.le.dest_sub"],
  "name": "Int.le.dest"},
 {"type": "ByteArray → ℕ → UInt8",
  "offspring": ["Array.get!", "instInhabitedUInt8"],
  "name": "ByteArray.get!"},
 {"type": "{α : Type} → Tactic.DeclCache α → Lean.MetaM α",
  "offspring": ["Tactic.Cache.get", "ForIn.forIn", "ForInStep"],
  "name": "Tactic.DeclCache.get"},
 {"type": "{α : Sort u_1} → {a : α} → α", "offspring": [], "name": "hidden"},
 {"type": "{α : Type u} → {β : Type v} → (ℕ → α → β) → List α → List β",
  "offspring": ["List.mapIdxAux"],
  "name": "List.mapIdx"},
 {"type": "∀ (a b : ℤ), a - b = a + -b",
  "offspring": ["Int.sub_eq_add_neg"],
  "name": "Int.instCommRingInt.proof_6"},
 {"type": "∀ {R : Type u_1} [inst : Semiring R] {m n : ℕ}, ↑(m * n) = ↑m * ↑n",
  "offspring":
  ["Nat.zero_eq",
   "Nat.mul_zero",
   "Nat.cast_zero",
   "MonoidWithZero.mul_zero",
   "Nat.mul_succ",
   "Nat.cast_add",
   "Nat.cast_succ",
   "mul_add",
   "mul_one"],
  "name": "Nat.cast_mul"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {φ : Sort u₃} {g : β → φ} {f : α → β},\n  Function.surjective g → Function.surjective f → Function.surjective (g ∘ f)",
  "offspring": ["Exists.elim"],
  "name": "Function.surjective.comp"},
 {"type": "CommRing UInt8",
  "offspring":
  ["CommRing.mk", "UInt8.instRingUInt8", "UInt8.instCommRingUInt8.proof_1"],
  "name": "UInt8.instCommRingUInt8"},
 {"type": "∀ {α : Type u} {l₁ l₂ : List α}, l₁ ~ l₂ → l₁ ⊆ l₂",
  "offspring":
  ["List.nil_subset",
   "List.cons_subset_cons",
   "List.mem_cons",
   "List.Mem.tail",
   "List.Mem.head",
   "List.subset.trans"],
  "name": "List.Perm.subset"},
 {"type":
  "∀ {b c x y u v : Prop} [dec_b : Decidable b],\n  (b ↔ c) → (c → (x ↔ u)) → (¬c → (y ↔ v)) → ((if b then x else y) ↔ if c then u else v)",
  "offspring": ["if_ctx_congr_prop"],
  "name": "if_ctx_simp_congr_prop"},
 {"type": "∀ {G₀ : Type u} [self : GroupWithZero G₀] (a : G₀), a * 0 = 0",
  "offspring": [],
  "name": "GroupWithZero.mul_zero"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {a b : α} {l : List α}, R a b → List.Chain R b l → List.Chain R a (b :: l)",
  "offspring": [],
  "name": "List.Chain.cons"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → ℕ → (ℕ → m Unit) → m Unit",
  "offspring": [],
  "name": "Nat.forRevM"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "CoeTC"},
 {"type": "{α : Sort u} → Nonempty α → Inhabited α",
  "offspring": ["Classical.choice"],
  "name": "Classical.inhabited_of_nonempty"},
 {"type":
  "{α : Sort u₁} →\n  {β : Sort u₂} → {φ : Sort u₃} → {δ : Sort u₄} → {ζ : Sort u₁} → (α → β → φ) → (φ → δ → ζ) → (α → β → δ) → α → β → ζ",
  "offspring": [],
  "name": "Function.combine"},
 {"type":
  "{α : Type u_1} → (R : α → α → Prop) → [inst : DecidableRel R] → List α → List α",
  "offspring": [],
  "name": "List.pwFilter"},
 {"type": "{α : Type u} → [inst : BEq α] → Array α → α → Bool",
  "offspring": ["Array.any"],
  "name": "Array.contains"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → [inst : CoeFun α fun x => β] → CoeTail α β",
  "offspring": ["CoeTail.mk", "CoeFun.coe"],
  "name": "instCoeTail"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.WhatsNew.commandWhatsnewIn__"},
 {"type": "∀ {α : Sort u_1} (a b : α) (p : Prop), p ∧ a = b ↔ p ∧ b = a",
  "offspring": [],
  "name": "and_symm_right"},
 {"type":
  "{α : Sort u2} →\n  {a : α} → {motive : {β : Sort u2} → β → Sort u1} → {β : Sort u2} → {b : β} → HEq a b → motive a → motive b",
  "offspring": [],
  "name": "HEq.ndrecOn"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Prelude.Rename.lookup3"},
 {"type": "∀ (m n k : ℕ), Nat.gcd (Nat.gcd m n) k = Nat.gcd m (Nat.gcd n k)",
  "offspring":
  ["Nat.dvd_antisymm",
   "Nat.dvd_gcd",
   "Nat.dvd_trans",
   "Nat.gcd_dvd_left",
   "Nat.gcd_dvd_right"],
  "name": "Nat.gcd_assoc"},
 {"type": "∀ {a b c : ℤ}, a + b ≤ c → b ≤ -a + c",
  "offspring": [],
  "name": "Int.le_neg_add_of_add_le"},
 {"type": "{m : Type u → Type v} → MonadFunctor m (OptionT m)",
  "offspring": ["MonadFunctor.mk"],
  "name": "OptionT.instMonadFunctorOptionT"},
 {"type": "Sort u → FloatArray → FloatArray → Sort u",
  "offspring": [],
  "name": "FloatArray.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} {a : α} (l : List α) (h : List.concat l a ≠ []), List.getLast (List.concat l a) h = a",
  "offspring": ["List.concat_eq_append", "List.getLast_append"],
  "name": "List.getLast_concat"},
 {"type": "Nonempty (Fin UInt8.size)",
  "offspring": ["instNonempty", "UInt8.instInhabitedFinSize"],
  "name": "UInt8.instSemiringUInt8.proof_3"},
 {"type": "{α : Type u_1} → List (List α) → List (List α)",
  "offspring": ["List.bind", "List.map"],
  "name": "List.sections"},
 {"type":
  "∀ {α : Type u_1} (a b : Array α),\n  Array.size a = Array.size b →\n    (∀ (i : ℕ) (hi₁ : i < Array.size a) (hi₂ : i < Array.size b),\n        Array.get a { val := i, isLt := hi₁ } = Array.get b { val := i, isLt := hi₂ }) →\n      a = b",
  "offspring": ["Array.mk", "Array.ext.extAux"],
  "name": "Array.ext"},
 {"type":
  "{n : ℕ} → (m : UFModel n) → (x y : Fin n) → UFModel.rank m ↑x < UFModel.rank m ↑y → UFModel n",
  "offspring":
  ["UFModel.mk", "UFModel.parent", "UFModel.rank", "UFModel.setParent.proof_1"],
  "name": "UFModel.setParent"},
 {"type": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "offspring": [],
  "name": "GT.gt"},
 {"type":
  "∀ {α : Type u_1} (x : Array α),\n  Array.size x > 0 → (invImage (fun a => Array.size a) instWellFoundedRelation).1 (Array.pop x) x",
  "offspring": ["sizeOf_nat", "Nat.lt_eq", "Array.size_pop", "Nat.pred_lt'"],
  "name": "Array.popWhile.proof_3"},
 {"type": "∀ {p q : Prop}, (p ↔ q ∧ p) ↔ p → q",
  "offspring": ["and_comm", "iff_self_and", "Iff.rfl"],
  "name": "iff_and_self"},
 {"type": "∀ (a : ℤ) {b : ℤ}, 0 < b → a - b < a",
  "offspring":
  ["Trans.trans", "Int.add_lt_add_left", "Int.neg_neg_of_pos", "Int.add_zero"],
  "name": "Int.sub_lt_self"},
 {"type": "∀ {a : ℤ}, 0 ≤ a → -a ≤ 0",
  "offspring": [],
  "name": "Int.neg_nonpos_of_nonneg"},
 {"type":
  "∀ {A : Type u} [inst : AddMonoid A] [inst_1 : IsAddLeftCancel A] {a b : A}, a = a + b ↔ b = 0",
  "offspring": ["add_left_cancel_iff", "add_zero", "eq_comm", "Iff.rfl"],
  "name": "self_eq_add_right"},
 {"type": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "offspring": [],
  "name": "absurd"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {a a' : α} {b b' : α → β},\n  a = a' →\n    (∀ (x : α), b x = b' x) →\n      (let x := a;\n        b x) =\n        let x := a';\n        b' x",
  "offspring": [],
  "name": "let_congr"},
 {"type":
  "∀ {α : Type u_1} {a y : α} {l : List α}, a ≠ y → ¬a ∈ l → ¬a ∈ y :: l",
  "offspring": ["List.eq_or_mem_of_mem_cons", "not_or"],
  "name": "List.not_mem_cons_of_ne_of_not_mem"},
 {"type": "Type u → Type u", "offspring": [], "name": "AndOp"},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "offspring": ["List.map"],
  "name": "List.inits"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt) (n : ℕ),\n  Array.size self.arr = n + 1 → 0 < Array.size self.arr",
  "offspring": ["Nat.succ_pos"],
  "name": "BinaryHeap.popMaxAux.proof_3"},
 {"type": "Hashable System.FilePath",
  "offspring":
  ["Hashable.mk", "mixHash", "Hashable.hash", "instHashableString"],
  "name": "System.instHashableFilePath"},
 {"type": "{α : Type u_1} → (as : List α) → as ≠ [] → α",
  "offspring": [],
  "name": "List.head"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (β → α → m β) → β → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m β",
  "offspring": ["Array.foldlM.proof_1"],
  "name": "Array.foldlM"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} (hd : α) (tl : List α), ¬List.Pairwise R tl → List.Pairwise R (hd :: tl) → False",
  "offspring": [],
  "name": "List.decidablePairwise.proof_4"},
 {"type":
  "∀ {α : Type u_1} {a : α} {L : List (List α)} {l : List α}, l ∈ L → a ∈ l → a ∈ List.join L",
  "offspring": ["List.mem_join"],
  "name": "List.mem_join_of_mem"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (i : Fin (UnionFind.size self)),\n  (Array.get self.arr i).rank < UnionFind.rankMax self",
  "offspring": ["Nat.lt_succ_iff", "Subtype.property", "Fin.isLt"],
  "name": "UnionFind.lt_rankMax'"},
 {"type": "{α : Type u_1} → [inst : Xor α] → HXor α α α",
  "offspring": ["HXor.mk", "Xor.xor"],
  "name": "instHXor"},
 {"type": "∀ {α : Sort u} [self : Subsingleton α] (a b : α), a = b",
  "offspring": [],
  "name": "Subsingleton.allEq"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α ε β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (x : m α)\n  (f : α → ExceptT ε m β),\n  ExceptT.run (ExceptT.lift x >>= f) = do\n    let a ← x\n    ExceptT.run (f a)",
  "offspring":
  ["map_eq_pure_bind",
   "Except",
   "Except.error",
   "LawfulMonad.bind_assoc",
   "LawfulMonad.pure_bind"],
  "name": "ExceptT.run_bind_lift"},
 {"type": "∀ (k m n : ℕ), Nat.gcd k (m * n) ∣ Nat.gcd k m * Nat.gcd k n",
  "offspring": ["Nat.prod_dvd_and_dvd_of_dvd_prod", "Nat.gcd_dvd_right"],
  "name": "Nat.gcd_mul_dvd_mul_gcd"},
 {"type": "∀ (a b c : ℤ), (a + b) * c = a * c + b * c",
  "offspring": ["Int.mul_comm", "Int.distrib_left"],
  "name": "Int.distrib_right"},
 {"type": "{α : Type u✝} → α → Zero α", "offspring": [], "name": "Zero.mk"},
 {"type": "∀ {a b c : Prop}, (a → b) → a ∨ c → b ∨ c",
  "offspring": ["Or.imp"],
  "name": "Or.imp_left"},
 {"type":
  "∀ (test : Lean.Name → Lean.MetaM (Option Lean.MessageData)) (noErrorsFound errorsFound : Lean.MessageData)\n  (isFast : Bool) (test_1 : Lean.Name → Lean.MetaM (Option Lean.MessageData))\n  (noErrorsFound_1 errorsFound_1 : Lean.MessageData) (isFast_1 : Bool),\n  ({ test := test, noErrorsFound := noErrorsFound, errorsFound := errorsFound, isFast := isFast } =\n      { test := test_1, noErrorsFound := noErrorsFound_1, errorsFound := errorsFound_1, isFast := isFast_1 }) =\n    (test = test_1 ∧ noErrorsFound = noErrorsFound_1 ∧ errorsFound = errorsFound_1 ∧ isFast = isFast_1)",
  "offspring": ["Mathlib.Tactic.Lint.Linter", "Mathlib.Tactic.Lint.Linter.mk"],
  "name": "Mathlib.Tactic.Lint.Linter.mk.injEq"},
 {"type":
  "{α : Type u} → (a b : α) → (Unit → Decidable (a = b)) → Decidable (a = b)",
  "offspring":
  ["withPtrEqDecEq.proof_2",
   "withPtrEqDecEq.proof_3",
   "withPtrEq",
   "toBoolUsing",
   "withPtrEqDecEq.proof_1"],
  "name": "withPtrEqDecEq"},
 {"type":
  "{α : Type u} → {p : α → Prop} → [inst : ToString α] → ToString (Subtype p)",
  "offspring": ["ToString.mk", "Subtype.val"],
  "name": "instToStringSubtype"},
 {"type": "{α : Type u} → ℕ → α → List α",
  "offspring": [],
  "name": "List.replicate"},
 {"type": "ByteSlice → ByteArray",
  "offspring": ["ByteArray.extract"],
  "name": "ByteSlice.toArray"},
 {"type": "{g : Type} → [inst : RandomGen g] → RandG g g",
  "offspring":
  ["MonadState.get",
   "MonadStateOf.set",
   "ULift.up",
   "RandomGen.split",
   "ULift.down"],
  "name": "Rand.split"},
 {"type": "Sort u → ℤ → ℤ → Sort u",
  "offspring": [],
  "name": "Int.noConfusionType"},
 {"type": "{α : Type u} → Coe (Subarray α) (Array α)",
  "offspring": ["Coe.mk", "Array.ofSubarray"],
  "name": "Array.instCoeSubarrayArray"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∧_»"},
 {"type": "Array (Array ℤ) → ℕ → ℕ → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.buildConj"},
 {"type":
  "{m : Type → Type} → {ω σ : Type} → [inst : MonadFinally m] → [inst : Monad m] → MonadFinally (StateRefT' ω σ m)",
  "offspring": [],
  "name": "instMonadFinallyStateRefT'"},
 {"type": "AddCommSemigroup UInt8",
  "offspring":
  ["AddCommSemigroup.mk",
   "UInt8.instAddSemigroupUInt8",
   "UInt8.instAddCommSemigroupUInt8.proof_1"],
  "name": "UInt8.instAddCommSemigroupUInt8"},
 {"type": "∀ {m : ℕ} (n : ℕ), 0 < m → 0 < Nat.gcd m n",
  "offspring": ["Nat.pos_of_dvd_of_pos", "Nat.gcd_dvd_left"],
  "name": "Nat.gcd_pos_of_pos_left"},
 {"type": "∀ {n m : ℕ}, Nat.beq n m = false → ¬n = m",
  "offspring": [],
  "name": "Nat.ne_of_beq_eq_false"},
 {"type":
  "∀ {G : Type u} [self : DivInvMonoid G] (n : ℕ) (a : G),\n  DivInvMonoid.gpow -[1+ n] a = (DivInvMonoid.gpow (Int.ofNat (Nat.succ n)) a)⁻¹",
  "offspring": [],
  "name": "DivInvMonoid.gpow_neg'"},
 {"type": "floatSpec.float → Float", "offspring": [], "name": "Float.mk"},
 {"type": "{α : Type u} → (α → String) → ToString α",
  "offspring": [],
  "name": "ToString.mk"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1}, Function.RightInverse Prod.swap Prod.swap",
  "offspring": ["Prod.swap_swap"],
  "name": "Prod.swap_RightInverse"},
 {"type":
  "∀ (x y : Tactic.NormCast.CoeFnType),\n  Tactic.NormCast.CoeFnType.toCtorIdx x = Tactic.NormCast.CoeFnType.toCtorIdx y → x = y",
  "offspring": [],
  "name": "Tactic.NormCast.instDecidableEqCoeFnType.proof_1"},
 {"type":
  "{α : Type} → {m : Type → Type} → [inst : Monad m] → Array α → (α → m Bool) → m (Option α)",
  "offspring": ["ForIn.forIn", "ForInStep.done", "MProd.snd", "MProd.fst"],
  "name": "Array.findM?"},
 {"type": "∀ {m n : ℕ}, Nat.gcd m n = 0 → n = 0",
  "offspring": ["Nat.eq_zero_of_gcd_eq_zero_left", "Nat.gcd", "Nat.gcd_comm"],
  "name": "Nat.eq_zero_of_gcd_eq_zero_right"},
 {"type": "{α : Sort u_1} → [inst : SizeOf α] → WellFoundedRelation α",
  "offspring": ["sizeOfWFRel"],
  "name": "instWellFoundedRelation"},
 {"type": "∀ {p q : Prop}, ¬p → q → (p ↔ q) → False",
  "offspring": [],
  "name": "instDecidableIff.proof_3"},
 {"type":
  "{α : Type u} → {m : Type u → Type u_1} → [inst : Monad m] → Array α → ℕ → (α → m α) → m (Array α)",
  "offspring":
  ["Array.set",
   "Array.modifyMUnsafe.proof_1",
   "unsafeCast",
   "Unit",
   "Array.get"],
  "name": "Array.modifyMUnsafe"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] (a b c : α), max a (max b c) = max b (max a c)",
  "offspring": ["left_comm", "max_comm", "max_assoc"],
  "name": "max_left_comm"},
 {"type": "∀ {α : Type u_1}, Option.isSome none = false",
  "offspring": [],
  "name": "Option.isSome_none"},
 {"type": "∀ {α : Type u_1} {a b : α}, a ∈ [b] ↔ a = b",
  "offspring":
  ["List.eq_of_mem_singleton",
   "List.mem_cons",
   "List.not_mem_nil",
   "or_false",
   "imp_self"],
  "name": "List.mem_singleton"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<|>_»"},
 {"type": "{α : Type u} → (α → α → α) → Xor α",
  "offspring": [],
  "name": "Xor.mk"},
 {"type": "∀ (n : ℕ), 0 < Nat.succ n",
  "offspring": ["Nat.zero_lt_succ"],
  "name": "Nat.succ_pos"},
 {"type":
  "{α : Type u} → (a b : α) → (k : Unit → Bool) → (a = b → k () = true) → Bool",
  "offspring": ["ptrAddrUnsafe"],
  "name": "withPtrEqUnsafe"},
 {"type": "{n : ℕ} → OfNat USize n",
  "offspring": ["OfNat.mk", "USize.ofNat"],
  "name": "instOfNatUSize"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a ≤ b",
  "offspring": ["Or.resolve_left", "le_total"],
  "name": "le_of_not_ge"},
 {"type":
  "∀ {α : Type u_1} {x : Option (Option α)}, Option.bind x id = Option.join x",
  "offspring": [],
  "name": "Option.bind_id_eq_join"},
 {"type":
  "∀ {α : Type u_1} (as : List α) (a : α) (as' : List α), (∃ bs, bs ++ a :: as' = as) → ∃ bs, bs ++ as' = as",
  "offspring": [],
  "name": "List.forIn'.loop.proof_2"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.disjoint l₁ l₂ ↔ ∀ ⦃a : α⦄, a ∈ l₂ → ¬a ∈ l₁",
  "offspring": ["List.disjoint_comm"],
  "name": "List.disjoint_right"},
 {"type":
  "∀ (ids ids_1 : Array ℕ), (Mathlib.Tactic.Sat.LRATStep.del ids = Mathlib.Tactic.Sat.LRATStep.del ids_1) = (ids = ids_1)",
  "offspring":
  ["Mathlib.Tactic.Sat.LRATStep", "Mathlib.Tactic.Sat.LRATStep.del"],
  "name": "Mathlib.Tactic.Sat.LRATStep.del.injEq"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (e : Nat.Linear.Expr),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Expr.toPoly e) = Nat.Linear.Expr.denote ctx e",
  "offspring":
  ["cond_true",
   "eq_of_beq",
   "Nat.instLawfulBEqNatInstBEqNat",
   "Bool.of_not_eq_true",
   "cond_false",
   "beq_self_eq_true",
   "Nat.mul_one",
   "Nat.add_zero",
   "Nat.one_mul",
   "Nat.zero_add",
   "Nat.Linear.Poly.denote_append",
   "Nat.Linear.Poly.denote_mul"],
  "name": "Nat.Linear.Expr.denote_toPoly"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HAnd"},
 {"type": "{n : ℕ} → (a b : Fin n) → Decidable (a < b)",
  "offspring": ["Nat.decLt"],
  "name": "Fin.decLt"},
 {"type": "∀ {G : Type u} [self : Group G] (a : G), a⁻¹ * a = 1",
  "offspring": [],
  "name": "Group.mul_left_inv"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → Sort u_1 → MonadControl m n → MonadControl m n → Sort u_1",
  "offspring": [],
  "name": "MonadControl.noConfusionType"},
 {"type": "{G : Type u} → [self : DivInvMonoid G] → Div G",
  "offspring": [],
  "name": "DivInvMonoid.toDiv"},
 {"type": "∀ (n m : Fin UInt32.size), n = m → { val := n } = { val := m }",
  "offspring": [],
  "name": "UInt32.decEq.proof_1"},
 {"type": "Type 1", "offspring": [], "name": "FloatSpec"},
 {"type": "∀ {a b : ℤ} (n : ℕ), a + ↑n = b → a ≤ b",
  "offspring":
  ["Int.le.intro_sub",
   "Int.add_comm",
   "Int.sub_eq_add_neg",
   "add_neg_cancel_right"],
  "name": "Int.le.intro"},
 {"type": "{α : Type u} → (α → Char → α) → α → Substring → α",
  "offspring": [],
  "name": "Substring.foldl"},
 {"type":
  "(ε : Type u) → {m : Type v → Type w} → [inst : MonadExceptOf ε m] → {α : Type v} → ε → m α",
  "offspring": ["MonadExceptOf.throw"],
  "name": "throwThe"},
 {"type": "∀ {a b c : ℕ}, a ≤ c + b → a - b ≤ c",
  "offspring":
  ["Nat.le.dest",
   "Nat.le_total",
   "Nat.sub_eq_zero_of_le",
   "Nat.zero_le",
   "Nat.le.intro"],
  "name": "Nat.sub_le_of_le_add"},
 {"type": "{α : Type u} → [self : Sdiff α] → α → α → α",
  "offspring": [],
  "name": "Sdiff.sdiff"},
 {"type": "{α : Type u_1} → ℕ → List α → List (List α)",
  "offspring": ["List.toChunksAux"],
  "name": "List.toChunks"},
 {"type": "ℕ → Nat.Linear.Var → Nat.Linear.Expr",
  "offspring":
  ["cond",
   "Nat.Linear.Var",
   "instBEqNat",
   "Nat.Linear.fixedVar",
   "Nat.Linear.Expr.var",
   "Nat.Linear.Expr.mulL"],
  "name": "Nat.Linear.monomialToExpr"},
 {"type": "{α : Type u} → [self : AndThen α] → α → (Unit → α) → α",
  "offspring": [],
  "name": "AndThen.andThen"},
 {"type": "{α : Type u} → Sort u_1 → ShiftLeft α → ShiftLeft α → Sort u_1",
  "offspring": [],
  "name": "ShiftLeft.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a₁ x : α) (n₁ : ℕ) (b₁ a₂ : α) (n₂ : ℕ) (b₂ : α) (k : ℕ) (a' b' : α),\n  n₂ + k = n₁ →\n    Tactic.Ring.horner a₁ x k 0 + a₂ = a' →\n      b₁ + b₂ = b' → Tactic.Ring.horner a₁ x n₁ b₁ + Tactic.Ring.horner a₂ x n₂ b₂ = Tactic.Ring.horner a' x n₂ b'",
  "offspring":
  ["add_comm",
   "pow_add",
   "add_assoc",
   "add_left_comm",
   "add_zero",
   "add_mul",
   "Semigroup.mul_assoc"],
  "name": "Tactic.Ring.horner_add_horner_gt"},
 {"type": "∀ {a b c : Prop}, a ∧ b ∧ c ↔ b ∧ a ∧ c",
  "offspring": ["and_assoc", "And.comm", "Iff.rfl"],
  "name": "And.left_comm"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«prio(_)»"},
 {"type":
  "Sort u → Mathlib.Tactic.Sat.LClause → Mathlib.Tactic.Sat.LClause → Sort u",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LClause.noConfusionType"},
 {"type": "{α : Type u_1} → [inst : BEq α] → Array α → Array α → Bool",
  "offspring": ["Array.isPrefixOfAux"],
  "name": "Array.isPrefixOf"},
 {"type": "Repr Char", "offspring": [], "name": "instReprChar"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a b : Array α) (hsz : Array.size a = Array.size b) (i : ℕ),\n  i ≤ Array.size a →\n    Array.isEqvAux a b hsz (fun x y => decide (x = y)) i = true →\n      ∀ (j : ℕ),\n        i ≤ j →\n          ∀ (high : j < Array.size a),\n            Array.get a { val := j, isLt := high } = Array.get b { val := j, isLt := (_ : j < Array.size b) }",
  "offspring": ["WellFounded.fix"],
  "name": "Array.eq_of_isEqvAux"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (α → β) → Prop",
  "offspring": [],
  "name": "Function.surjective"},
 {"type": "Nonempty (Fin UInt16.size)",
  "offspring": ["instNonempty", "UInt16.instInhabitedFinSize"],
  "name": "UInt16.instRingUInt16.proof_2"},
 {"type": "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l → 0 < List.length l",
  "offspring": ["List.length_cons", "Nat.zero_lt_succ"],
  "name": "List.length_pos_of_mem"},
 {"type": "∀ (p : Prop) [inst : Decidable p], ¬p ∨ p",
  "offspring": ["Or.swap", "dec_em"],
  "name": "dec_em'"},
 {"type": "∀ {a b : Prop}, a ∧ b → a", "offspring": [], "name": "And.left"},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Bool",
  "offspring": [],
  "name": "List.beq"},
 {"type": "∀ (n : ℕ), Nat.gcd n n = n",
  "offspring": ["Nat.gcd_succ", "Nat.gcd", "Nat.mod_self", "Nat.gcd_zero_left"],
  "name": "Nat.gcd_self"},
 {"type":
  "∀ (x : ℕ) (x_1 : UInt8), npow_rec (Nat.succ x) x_1 = npow_rec (Nat.succ x) x_1",
  "offspring": [],
  "name": "UInt8.instSemiringUInt8.proof_16"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.extBinder"},
 {"type":
  "{α : Type u} → [inst : DecidableEq α] → (a b : List α) → Decidable (a = b)",
  "offspring":
  ["List.hasDecEq.proof_1",
   "List.hasDecEq.proof_2",
   "List.hasDecEq.proof_3",
   "decEq",
   "List.hasDecEq.proof_4",
   "List.hasDecEq.proof_5",
   "List.hasDecEq.proof_6"],
  "name": "List.hasDecEq"},
 {"type": "∀ {α : Type u_1} (a : α), Option.toList (some a) = [a]",
  "offspring": [],
  "name": "Option.to_list_some"},
 {"type": "{α : Type u} → (α → α → Prop) → LE α",
  "offspring": [],
  "name": "LE.mk"},
 {"type": "{ε : Type u} → {α : Type v} → α → Except ε α",
  "offspring": [],
  "name": "Except.ok"},
 {"type": "∀ {n m : ℕ}, m ≤ n → n - (n - m) = m",
  "offspring": ["Nat.sub_eq_iff_eq_add", "Nat.sub_le", "Nat.add_sub_of_le"],
  "name": "Nat.sub_sub_self"},
 {"type": "ℕ → Float",
  "offspring": ["OfScientific.ofScientific", "instOfScientificFloat"],
  "name": "Float.ofNat"},
 {"type": "{ε σ : Type u} → σ → EStateM ε σ PUnit",
  "offspring": ["EStateM.Result.ok"],
  "name": "EStateM.set"},
 {"type":
  "{ε : Type u} → {α : Type u_1} → Except ε α → (ε → Except ε α) → Except ε α",
  "offspring": ["Except.ok"],
  "name": "Except.tryCatch"},
 {"type": "∀ {a b : ℤ}, 0 ≤ a - b → b ≤ a",
  "offspring": [],
  "name": "Int.le_of_sub_nonneg"},
 {"type": "Inhabited UInt64",
  "offspring": ["UInt64.ofNatCore", "instInhabitedUInt64.proof_1"],
  "name": "instInhabitedUInt64"},
 {"type": "Type", "offspring": [], "name": "Nat.Linear.PolyCnstr"},
 {"type": "{α : Type u_1} → Array α → Array α → (α → α → Bool) → Bool",
  "offspring": ["Array.isEqvAux"],
  "name": "Array.isEqv"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} → [inst : Monad m] → ByteArray → (UInt8 → β → m (ForInStep β)) → USize → USize → β → m β",
  "offspring":
  ["instLTUSize", "ByteArray.forInUnsafe.loop", "ByteArray.uget", "lcProof"],
  "name": "ByteArray.forInUnsafe.loop"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α} (n : ℕ) (h : n < List.length l₁),\n  List.get (l₁ ++ l₂) { val := n, isLt := (_ : n < List.length (l₁ ++ l₂)) } = List.get l₁ { val := n, isLt := h }",
  "offspring": ["Nat.add"],
  "name": "List.get_append"},
 {"type": "∀ {a b c : Prop}, (a → (b ↔ c)) → (a ∧ b ↔ a ∧ c)",
  "offspring": [],
  "name": "and_congr_right"},
 {"type": "∀ {α : Type u_1} {a : α} {l m : List α}, a :: l ⊆ m ↔ a ∈ m ∧ l ⊆ m",
  "offspring":
  ["List.subset_def",
   "List.mem_cons",
   "or_imp_distrib",
   "forall_and_distrib",
   "forall_eq",
   "Iff.rfl"],
  "name": "List.cons_subset"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β},\n  Function.injective f → ∀ (g : α → γ) (e' : β → γ), Function.extend f g e' ∘ f = g",
  "offspring": ["Function.extend_apply"],
  "name": "Function.extend_comp"},
 {"type": "{α : Type u_1} → [inst : ShiftLeft α] → HShiftLeft α α α",
  "offspring": ["HShiftLeft.mk", "ShiftLeft.shiftLeft"],
  "name": "instHShiftLeft"},
 {"type": "∀ {α : Type u} (as : List α), List.reverse (List.reverse as) = as",
  "offspring": ["List.reverseAux", "List.reverseAux_reverseAux_nil"],
  "name": "List.reverse_reverse"},
 {"type": "∀ {m n k : ℕ}, 0 < k → m * k ∣ n * k → m ∣ n",
  "offspring": ["Nat.dvd_of_mul_dvd_mul_left"],
  "name": "Nat.dvd_of_mul_dvd_mul_right"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), a * 1 = a",
  "offspring": ["Monoid.mul_one"],
  "name": "instCommSemiringFin.proof_9"},
 {"type": "{α : Sort u} → Inhabited (α ≃ α)",
  "offspring": ["Equiv.refl"],
  "name": "Equiv.instInhabitedEquiv"},
 {"type": "∀ {a b c : ℕ}, b ≤ c → a ≤ c - b → a + b ≤ c",
  "offspring":
  ["Nat.le.dest", "Nat.le.intro", "Nat.eq_add_of_sub_eq", "Nat.add_left_comm"],
  "name": "Nat.add_le_of_le_sub"},
 {"type": "{α : Type u} → Array α → Array α → Array α",
  "offspring": [],
  "name": "Array.appendCore"},
 {"type": "Type u → Type u", "offspring": [], "name": "LE"},
 {"type":
  "{α : Type u} →\n  [toLE : LE α] →\n    [toLT : LT α] →\n      (∀ (a : α), a ≤ a) → (∀ (a b c : α), a ≤ b → b ≤ c → a ≤ c) → (∀ (a b : α), a < b ↔ a ≤ b ∧ ¬b ≤ a) → Preorder α",
  "offspring": [],
  "name": "Preorder.mk"},
 {"type": "∀ (n : ℕ), 1 * n = n",
  "offspring": ["Nat.mul_one"],
  "name": "Nat.one_mul"},
 {"type": "∀ {a b : ℕ}, a ∣ b → ∀ (c : ℕ), a * c ∣ b * c",
  "offspring": ["Nat.mul_dvd_mul", "Nat.dvd_refl"],
  "name": "Nat.mul_dvd_mul_right"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk", "Fin.lor", "USize.size"],
  "name": "USize.lor"},
 {"type": "{α : Type u_1} → {β : Type u_2} → Thunk α → (α → Thunk β) → Thunk β",
  "offspring": ["Thunk.mk", "Thunk.get"],
  "name": "Thunk.bind"},
 {"type": "∀ {A : Type u} [inst : AddMonoid A] (a : A), 0 + a = a",
  "offspring": ["AddMonoid.zero_add"],
  "name": "zero_add"},
 {"type": "Substring → String", "offspring": [], "name": "Substring.str"},
 {"type":
  "∀ {m : Type u → Type u_1} {n : Type u → Type u_2} {α β σ : Type u} [inst : Monad m] [inst_1 : MonadLiftT n m] (x : n α)\n  (s : σ) (k : α → σ → m β),\n  StateCpsT.runK (monadLift x) s k = do\n    let a ← monadLift x\n    k a s",
  "offspring": [],
  "name": "StateCpsT.runK_monadLift"},
 {"type":
  "∀ (data data_1 : Array Float), ({ data := data } = { data := data_1 }) = (data = data_1)",
  "offspring": ["FloatArray", "FloatArray.mk"],
  "name": "FloatArray.mk.injEq"},
 {"type": "ℕ → Nat.Linear.Poly → Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["cond", "Nat.blt", "Nat.add"],
  "name": "Nat.Linear.Poly.combineAux"},
 {"type": "∀ {α : Sort u_1} [inst : Nonempty α], Nonempty α",
  "offspring": ["inferInstance"],
  "name": "Classical.ofNonempty.proof_1"},
 {"type":
  "∀ {β : Type u_1} {α : Type u_2} {b : β} {l : List α} {f : α → List β} {a : α}, a ∈ l → b ∈ f a → b ∈ List.bind l f",
  "offspring": ["List.mem_bind"],
  "name": "List.mem_bind_of_mem"},
 {"type": "∀ {a : ℕ}, a ≠ 0 → Nat.succ (Nat.pred a) = a",
  "offspring": [],
  "name": "Nat.succ_pred"},
 {"type": "UInt32 → Prop",
  "offspring": ["Nat.isValidChar", "UInt32.toNat"],
  "name": "UInt32.isValidChar"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«binderTerm>_»"},
 {"type": "{α : Type u_1} → [inst : BEq α] → Array α → Bool",
  "offspring":
  ["WellFounded.fix",
   "Array.get",
   "WellFoundedRelation.rel",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Nat.sub_succ_lt_self"],
  "name": "Array.allDiff"},
 {"type": "{α β : Sort u} → α = β → α → β", "offspring": [], "name": "Eq.mp"},
 {"type":
  "∀ {R : Type u} [self : NonUnitalNonAssocSemiring R] (a : R), a * 0 = 0",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.mul_zero"},
 {"type": "∀ {a b : Prop} [inst : Decidable b], ¬(a ↔ b) ↔ (¬a ↔ b)",
  "offspring": ["iff_true", "iff_false", "not_not"],
  "name": "Decidable.not_iff"},
 {"type": "∀ (a b : ℕ), ¬a = b → Int.ofNat a = Int.ofNat b → False",
  "offspring": [],
  "name": "Int.decEq.proof_2"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {x : Option α} {f : α → Option β} {b : β},\n  Option.bind x f = some b ↔ ∃ a, x = some a ∧ f a = some b",
  "offspring":
  ["Option.none_bind",
   "eq_false'",
   "false_and",
   "exists_false",
   "Option.some_bind",
   "Option.some.injEq",
   "exists_eq_left'"],
  "name": "Option.bind_eq_some"},
 {"type": "∀ {x y : ℕ}, (Nat.beq x y = true) = (x = y)",
  "offspring": ["Nat.eq_of_beq_eq_true", "Nat.beq_refl"],
  "name": "Nat.beq_eq"},
 {"type": "∀ {α : Type u_1} (a : α), a ∈ [] ↔ False",
  "offspring": ["List.not_mem_nil"],
  "name": "List.mem_nil_iff"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (α → m β) → Array α → m (Array β)",
  "offspring": ["unsafeCast", "USize.ofNat"],
  "name": "Array.mapMUnsafe"},
 {"type": "∀ {p : Prop} {d : Decidable p}, toBoolUsing d = false → ¬p",
  "offspring": ["of_decide_eq_false"],
  "name": "ofBoolUsing_eq_false"},
 {"type": "{R : Type u} → [self : Semiring R] → NonUnitalSemiring R",
  "offspring": [],
  "name": "Semiring.toNonUnitalSemiring"},
 {"type": "∀ (a : UInt64), { val := Ring.gsmul 0 a.val } = { val := 0.1 }",
  "offspring": ["SubNegMonoid.gsmul_zero'"],
  "name": "UInt64.instRingUInt64.proof_3"},
 {"type": "∀ (n m : ℕ), Int.ofNat (n * m) = Int.ofNat n * Int.ofNat m",
  "offspring": [],
  "name": "Int.ofNat_mul"},
 {"type": "∀ (a b : UInt64), a * b = { val := a.val * b.val }",
  "offspring": [],
  "name": "UInt64.mul_def"},
 {"type": "Nat.Linear.Expr → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.Expr.inc"},
 {"type": "∀ {α : Type u_1} (l : List α) (a : α), List.concat l a = l ++ [a]",
  "offspring": ["List.append_nil", "List.cons_append"],
  "name": "List.concat_eq_append"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticAny_goals_"},
 {"type": "∀ {α : Sort u} {a b : α}, (a = b → False) → a ≠ b",
  "offspring": [],
  "name": "Ne.intro"},
 {"type": "∀ {α : Type u_1} (a : Array α), Array.size a / 2 ≤ Array.size a",
  "offspring": ["Nat.div_le_self"],
  "name": "BinaryHeap.mkHeap.proof_1"},
 {"type": "Sort u → Float → Float → Sort u",
  "offspring": [],
  "name": "Float.noConfusionType"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, a1 = a2 ↔ a1.val = a2.val",
  "offspring": ["Subtype.val", "Subtype.ext"],
  "name": "Subtype.ext_iff"},
 {"type": "{α : Type u} → [self : Union α] → α → α → α",
  "offspring": [],
  "name": "Union.union"},
 {"type": "∀ (p : Prop), Subsingleton p",
  "offspring": ["Subsingleton.intro", "proofIrrel"],
  "name": "instSubsingleton.proof_1"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HAnd α β γ] → α → β → γ",
  "offspring": [],
  "name": "HAnd.hAnd"},
 {"type":
  "∀ {a b c d : ℕ}, Nat.coprime c d → a * b = c * d → Nat.gcd a c * Nat.gcd b c = c",
  "offspring":
  ["Nat.dvd_antisymm",
   "Nat.coprime.dvd_of_dvd_mul_right",
   "Nat.coprime.mul",
   "Nat.coprime.gcd_left",
   "Dvd.dvd",
   "Nat.instDvdNat",
   "Nat.mul_dvd_mul",
   "Nat.gcd_dvd",
   "Nat.gcd_comm"],
  "name": "Nat.gcd_mul_gcd_of_coprime_of_mul_eq_mul"},
 {"type": "ℕ → ByteArray",
  "offspring": ["ByteArray.mk"],
  "name": "ByteArray.mkEmpty"},
 {"type": "Substring → Substring",
  "offspring": ["Substring.mk"],
  "name": "Substring.trim"},
 {"type": "{f : Type u → Type v} → [self : Applicative f] → SeqRight f",
  "offspring": [],
  "name": "Applicative.toSeqRight"},
 {"type": "{α : Type u_1} → Stream (Subarray α) α",
  "offspring": ["Stream.mk", "Subarray.start", "Subarray.stop"],
  "name": "instStreamSubarray"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → ℕ → (ℕ → m Bool) → ℕ → m Bool",
  "offspring": [],
  "name": "Nat.anyM.loop"},
 {"type": "{α : Type u_1} → [inst : Inhabited α] → List α → α",
  "offspring":
  ["panicWithPosWithDecl", "List.getLast", "List.getLast!.proof_1"],
  "name": "List.getLast!"},
 {"type": "∀ {m k : ℕ}, k ≤ m → ∀ (n : ℕ), n + m - k = n + (m - k)",
  "offspring":
  ["Nat.le.dest",
   "Nat.add_sub_cancel_left",
   "Nat.add_assoc",
   "Nat.add_sub_cancel"],
  "name": "Nat.add_sub_assoc"},
 {"type": "{α : Type u_1} → {o : Option α} → Decidable (o = none)",
  "offspring": ["decidable_of_decidable_of_iff", "Option.isNone_iff_eq_none"],
  "name": "Option.decidable_eq_none"},
 {"type": "∀ (as : FloatArray), FloatArray.size as ≤ FloatArray.size as",
  "offspring": ["Nat.le_refl", "FloatArray.size"],
  "name": "FloatArray.foldlM.proof_1"},
 {"type":
  "{α : Type u} → {m : Type u_1 → Type u_2} → {β : Type u_1} → [inst : Monad m] → (α → m (Array β)) → Array α → m (Array β)",
  "offspring": ["Array.foldlM", "Array.empty"],
  "name": "Array.concatMapM"},
 {"type": "{α : Type u_1} → List α → List α → Prop",
  "offspring": [],
  "name": "List.sublist"},
 {"type":
  "{α : Type u_1} → [inst : DecidableEq α] → List α → List α → Option (List α)",
  "offspring": [],
  "name": "List.getRest"},
 {"type": "∀ {a b : ℤ}, a < b → ∀ (c : ℤ), a - c < b - c",
  "offspring": ["Int.add_lt_add_right"],
  "name": "Int.sub_lt_sub_right"},
 {"type":
  "∀ {α : Type u_1} (a : α) (as : List α), List.length (a :: as) = Nat.succ (List.length as)",
  "offspring": [],
  "name": "List.length_cons"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} (a : { a // p a }) (h : p a.val), { val := a.val, property := h } = a",
  "offspring": ["Subtype.ext"],
  "name": "Subtype.coe_eta"},
 {"type":
  "(m : Type u → Type v) →\n  (ε₁ ε₂ : Type u) → [inst : Monad m] → [inst : MonadExceptOf ε₁ m] → MonadExceptOf ε₁ (ExceptT ε₂ m)",
  "offspring": ["MonadExceptOf.mk", "ExceptT.mk", "throwThe", "tryCatchThe"],
  "name": "instMonadExceptOfExceptT"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → ℕ",
  "offspring": [],
  "name": "List.countp"},
 {"type": "(a : Prop) → Inhabited (Decidable a)",
  "offspring": ["inferInstance"],
  "name": "Classical.decidableInhabited"},
 {"type":
  "{m : Type → Type v} → [inst : Monad m] → {α : Type} → (α → m Bool) → List α → m (List α)",
  "offspring": ["List.filterAuxM", "List.reverse"],
  "name": "List.filterRevM"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt) (x : α),\n  BinaryHeap.size self < Array.size (Array.push self.arr x)",
  "offspring": ["Array.push", "Array.size_push", "Nat.lt_succ_self"],
  "name": "BinaryHeap.insert.proof_1"},
 {"type": "∀ {a b : ℤ}, 0 ≤ b → a ≤ b + a",
  "offspring": [],
  "name": "Int.le_add_of_nonneg_left"},
 {"type": "∀ {a b : ℤ}, 0 ≤ a → 0 ≤ b → 0 ≤ a + b",
  "offspring": ["Int.add_le_add", "Int.zero_add"],
  "name": "Int.add_nonneg"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a ~ a_1 → Prop} (x y : α) (l : List α),\n  List.Perm.below (_ : y :: x :: l ~ x :: y :: l)",
  "offspring": [],
  "name": "List.Perm.below.swap"},
 {"type":
  "∀ {α : Type u} [n : Nonempty α] {β : Sort v} {f : α → β},\n  Function.injective f → Function.LeftInverse (Function.inv_fun f) f",
  "offspring": [],
  "name": "Function.LeftInverse_inv_fun"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → ({α : Type u} → ({β : Type u} → m β → m β) → n α → n α) → MonadFunctor m n",
  "offspring": [],
  "name": "MonadFunctor.mk"},
 {"type": "∀ {α : Type u} {a b : α} {l : List α}, a ∈ b :: l ↔ a = b ∨ a ∈ l",
  "offspring":
  ["List.Mem", "true_or", "or_true", "List.Mem.head", "List.Mem.tail"],
  "name": "List.mem_cons"},
 {"type": "0 = { val := 0 }", "offspring": [], "name": "USize.zero_def"},
 {"type": "{G₀ : Type u} → [self : GroupWithZero G₀] → MonoidWithZero G₀",
  "offspring":
  ["MonoidWithZero.mk", "GroupWithZero.zero_mul", "GroupWithZero.mul_zero"],
  "name": "GroupWithZero.toMonoidWithZero"},
 {"type": "∀ {a b : ℕ}, ¬a < b → b ≤ a",
  "offspring": ["Or.resolve_left", "Nat.lt_or_ge"],
  "name": "Nat.le_of_not_lt"},
 {"type":
  "{ω σ : Type} → {m : Type → Type} → [inst : Monad m] → Monad (StateRefT' ω σ m)",
  "offspring": [],
  "name": "StateRefT'.instMonadStateRefT'"},
 {"type":
  "{α : Type u} → {β : outParam (Type v)} → {γ : outParam (Type w)} → (α → β → γ) → Function.HasUncurry α β γ",
  "offspring": [],
  "name": "Function.HasUncurry.mk"},
 {"type": "{α : Type u} → [inst : Lean.ToFormat α] → Lean.ToFormat (Option α)",
  "offspring": ["Option.format"],
  "name": "instToFormatOption"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a",
  "offspring": [],
  "name": "congrFun"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.pushCast"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {s : Setoid α} → (f : α → β) → (∀ (a b : α), a ≈ b → f a = f b) → Quotient s → β",
  "offspring": ["Quot.lift"],
  "name": "Quotient.lift"},
 {"type": "ℕ → FloatArray",
  "offspring": ["FloatArray.mk", "Float"],
  "name": "FloatArray.mkEmpty"},
 {"type":
  "∀ {α β : Sort u_1} [h₁ : Subsingleton α], α = β → ∀ (a : α) (b : β), HEq a b",
  "offspring": ["heq_of_eq", "Subsingleton.elim"],
  "name": "Subsingleton.helim.proof_1"},
 {"type": "Lean.Expr → Lean.MetaM Tactic.NormCast.Label",
  "offspring":
  ["Tactic.NormCast.countCoes",
   "Tactic.NormCast.countHeadCoes",
   "Tactic.NormCast.countInternalCoes",
   "Tactic.NormCast.Label.elim",
   "Tactic.NormCast.Label.squash",
   "Tactic.NormCast.Label.move"],
  "name": "Tactic.NormCast.classifyType"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop}, Nonempty (Subtype p) ↔ ∃ a, p a",
  "offspring": ["Nonempty", "Subtype", "Subtype.mk"],
  "name": "nonempty_subtype"},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeTC α β] → α → β",
  "offspring": [],
  "name": "CoeTC.coe"},
 {"type":
  "{α : Sort u} → {β : Sort v} → {φ : Sort w} → (α → β → φ) → β → α → φ",
  "offspring": [],
  "name": "flip"},
 {"type": "∀ {a : Prop}, (a → False) → ¬a",
  "offspring": [],
  "name": "Not.intro"},
 {"type": "Type u → Type u", "offspring": [], "name": "CommRing"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (l₁ l₂ : List α),\n  List.union (a :: l₁) l₂ = List.insert a (List.union l₁ l₂)",
  "offspring": ["List.insert", "List.foldr"],
  "name": "List.cons_union"},
 {"type": "ℕ → List ℕ", "offspring": ["List.rangeAux"], "name": "List.range"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {r : β → β → Prop} (f : α → β), WellFounded r → WellFounded (InvImage r f)",
  "offspring": ["InvImage.wf.proof_1"],
  "name": "InvImage.wf"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) -[1+ x] = (fun n => { val := ↑n }) -[1+ x]",
  "offspring": [],
  "name": "UInt32.instRingUInt32.proof_8"},
 {"type":
  "∀ {A : Type u} [self : AddMonoid A] (n : ℕ) (x : A), AddMonoid.nsmul (Nat.succ n) x = x + AddMonoid.nsmul n x",
  "offspring": [],
  "name": "AddMonoid.nsmul_succ'"},
 {"type":
  "∀ {G : Type u} [inst : Semigroup G] [inst_1 : IsMulRightCancel G] {a b c : G}, b * a = c * a → b = c",
  "offspring": ["IsMulRightCancel.mul_right_cancel"],
  "name": "mul_right_cancel"},
 {"type": "Nat.Linear.Context → Nat.Linear.Poly × Nat.Linear.Poly → Prop",
  "offspring": ["Nat.Linear.Poly.denote", "Nat.Linear.Poly"],
  "name": "Nat.Linear.Poly.denote_le"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.LibrarySearch.librarySearch'"},
 {"type":
  "∀ {α : Type u_1} {n : ℕ} (a : Array α) (i : ℕ), Array.size a = n → i < n → i < Array.size a",
  "offspring": [],
  "name": "Array.getLit.proof_1"},
 {"type":
  "∀ {α : Sort u_1} {β : Type u_2} {f : α → β} (p : α → Prop),\n  Function.injective f → Function.injective (Subtype.restrict f p)",
  "offspring": ["Function.injective.comp", "Subtype.coe_injective"],
  "name": "Subtype.restrict_injective"},
 {"type": "∀ (n m : ℕ), n ≤ m + n",
  "offspring": ["Nat.le_add_right"],
  "name": "Nat.le_add_left"},
 {"type": "0 = 0", "offspring": [], "name": "Nat.discriminate.proof_1"},
 {"type": "∀ {α : Type u_1} (l₁ l₂ : List α), l₁ ⊆ l₁ ++ l₂",
  "offspring": ["List.mem_append_left"],
  "name": "List.subset_append_left"},
 {"type": "{M : Type u} → [self : Monoid M] → Semigroup M",
  "offspring": [],
  "name": "Monoid.toSemigroup"},
 {"type": "{α : Sort u} → WellFoundedRelation α",
  "offspring": ["WellFoundedRelation.mk", "emptyRelation", "emptyWf.proof_1"],
  "name": "emptyWf"},
 {"type": "∀ {n m : ℕ}, n = m → n ≤ m",
  "offspring": ["Nat.le_refl"],
  "name": "Nat.le_of_eq"},
 {"type":
  "{α : Type u_1} → {β : Sort u_2} → Array α → (α → β) → {n : ℕ} → (Fin n → β) → Prop",
  "offspring": [],
  "name": "UFModel.Agrees"},
 {"type":
  "∀ {α : Type u_1} (l : List α) (i : Fin (List.length l)), List.get l i :: List.drop (↑i + 1) l = List.drop (↑i) l",
  "offspring": ["Nat.add"],
  "name": "List.get_cons_drop"},
 {"type": "{G : Type u} → [self : DivInvMonoid G] → ℤ → G → G",
  "offspring": [],
  "name": "DivInvMonoid.gpow"},
 {"type": "{n : ℕ} → Sort u → UFModel n → UFModel n → Sort u",
  "offspring": [],
  "name": "UFModel.noConfusionType"},
 {"type": "{m : Type → Type v} → [inst : Applicative m] → m Bool → m Bool",
  "offspring": ["Functor.map", "not"],
  "name": "notM"},
 {"type": "{a b : Prop} → Sort u → (a ↔ b) → (a ↔ b) → Sort u",
  "offspring": [],
  "name": "Iff.noConfusionType"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.isValid (Nat.Linear.ExprCnstr.toNormPoly c) = true → Nat.Linear.ExprCnstr.denote ctx c = True",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.eq_true_of_isValid"},
 {"type": "Float → Float", "offspring": [], "name": "Float.log2"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "prioMid"},
 {"type": "{ε σ α : Type u} → α → σ → EStateM.Result ε σ α",
  "offspring": [],
  "name": "EStateM.Result.ok"},
 {"type":
  "{m : Type u_1 → Type u_2} → {n : Type u_1 → Type u_3} → [self : MonadLiftT m n] → {α : Type u_1} → m α → n α",
  "offspring": ["MonadLiftT.monadLift"],
  "name": "liftM"},
 {"type": "∀ {a : Prop}, a → ¬¬a",
  "offspring": [],
  "name": "non_contradictory_intro"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.bijective f → ∀ (b : β), ExistsUnique fun a => f a = b",
  "offspring": ["Function.bijective_iff_exists_unique"],
  "name": "Function.bijective.exists_unique"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {a : α} {b : β}, Prod.swap (a, b) = (b, a)",
  "offspring": [],
  "name": "Prod.swap_prod_mk"},
 {"type":
  "∀ {α : Type u} {motive : (a : α) → (a_1 : List α) → List.Mem a a_1 → Prop} (a : α) (as : List α),\n  List.Mem.below (_ : List.Mem a (a :: as))",
  "offspring": [],
  "name": "List.Mem.below.head"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) (x : α) (xs : List α), p x → ∃ x_1, x_1 ∈ x :: xs ∧ p x_1",
  "offspring": ["List.Mem.head"],
  "name": "decidableBEx.proof_2"},
 {"type": "∀ {α : Sort u₁} {β : Sort u₂} (f : α → β), f ∘ id = f",
  "offspring": [],
  "name": "Function.right_id"},
 {"type":
  "(Type u → Type v) → Type w₁ → outParam (Type w₂) → Type (max (max (max (u + 1) v) w₁) w₂)",
  "offspring": [],
  "name": "ForM"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (f : α → β) (l : List α) (n : ℕ),\n  List.get? (List.map f l) n = Option.map f (List.get? l n)",
  "offspring": ["List.get?", "List.map", "Option.map"],
  "name": "List.get?_map"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → ℤ → Fin n",
  "offspring": ["Fin.ofNat'", "Fin.size_positive'"],
  "name": "Fin.ofInt''"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<_»"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (x : α) (i : ℕ) (h : i < Array.size a),\n  Array.get? (Array.push a x) i = some (Array.get a { val := i, isLt := h })",
  "offspring":
  ["List.concat_eq_append",
   "Array.get?_eq_get?",
   "Array.get_eq_get",
   "List.get?_eq_get",
   "List.get?_append"],
  "name": "Array.get?_push_lt"},
 {"type":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∨ q)",
  "offspring": ["instDecidableOr.proof_1"],
  "name": "instDecidableOr"},
 {"type": "LE ℕ", "offspring": ["LE.mk", "Nat.le"], "name": "instLENat"},
 {"type": "Lean.ToExpr Tactic.NormCast.CoeFnType",
  "offspring": [],
  "name": "Tactic.NormCast.instToExprCoeFnType"},
 {"type":
  "∀ {α : Type u_1} {γ : α → Type v}, Nonempty ((a : α) × γ a) ↔ ∃ a, Nonempty (γ a)",
  "offspring": ["Nonempty", "Sigma", "Sigma.mk"],
  "name": "nonempty_sigma"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α ε β : Type u_1} {e : ε} [inst : Monad m] [inst_1 : LawfulMonad m]\n  (f : α → ExceptT ε m β), throw e >>= f = throw e",
  "offspring": ["LawfulMonad.pure_bind", "Except.error", "Except"],
  "name": "ExceptT.bind_throw"},
 {"type":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "offspring": [],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring"},
 {"type": "∀ {n m : ℕ}, ¬n ≤ m → n > m",
  "offspring": ["GT.gt", "Nat.lt_or_ge"],
  "name": "Nat.gt_of_not_le"},
 {"type": "∀ {α : Type u} [self : NonAssocSemiring α] (a : α), a * 1 = a",
  "offspring": [],
  "name": "NonAssocSemiring.mul_one"},
 {"type": "(G : Type u) → [inst : CommGroup G] → CommMonoid G",
  "offspring": ["CommMonoid.mk", "CommGroup.mul_comm"],
  "name": "instCommMonoid"},
 {"type": "∀ {α : Type u_1} {x : α} {l : List α}, [x] ++ l = x :: l",
  "offspring": [],
  "name": "List.singleton_append"},
 {"type": "{ε σ α : Type u} → ε → EStateM ε σ α",
  "offspring": ["EStateM.Result.error"],
  "name": "EStateM.throw"},
 {"type":
  "∀ {α : Sort u_1} {q : Prop} {p : α → Prop}, (∃ x, q ∧ p x) ↔ q ∧ ∃ x, p x",
  "offspring": [],
  "name": "exists_and_distrib_left"},
 {"type": "∀ {a b : UInt32}, a = b → a.val = b.val",
  "offspring": [],
  "name": "UInt32.val_eq_of_eq"},
 {"type": "0 < UInt16.size",
  "offspring": [],
  "name": "instInhabitedUInt16.proof_1"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β} {g : β → α},\n  Function.injective f → Function.LeftInverse f g → Function.RightInverse f g",
  "offspring": [],
  "name": "Function.RightInverse_of_injective_of_LeftInverse"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {as bs : List α},\n  List.disjoint as bs → List.card (List.union as bs) = List.card as + List.card bs",
  "offspring":
  ["List.card_eq_of_equiv",
   "List.union_equiv_append",
   "List.card_append_disjoint"],
  "name": "List.card_union_disjoint"},
 {"type":
  "∀ {α : Type u_1} {a : α} {o : Option α} (h : Option.isSome o = true), a ∈ o → Option.get h = a",
  "offspring": [],
  "name": "Option.get_of_mem"},
 {"type": "∀ (a : ℤ), 1 * a = a", "offspring": [], "name": "Int.one_mul"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {as : List α}, a ∈ as → List.card (a :: as) = List.card as",
  "offspring": ["if_pos"],
  "name": "List.card_cons_of_mem"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddMonoid"},
 {"type": "∀ {a : ℤ}, Int.natAbs a = 0 → a = 0",
  "offspring": ["congr_arg", "Nat.succ_ne_zero"],
  "name": "Int.eq_zero_ofNatAbs_eq_zero"},
 {"type": "Float → Float", "offspring": [], "name": "Float.exp"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} {motive : (a : α) → (a_1 : List α) → List.Chain R a a_1 → Prop} {a : α}\n  {a_1 : List α} (x : List.Chain R a a_1),\n  (∀ (a : α) (a_2 : List α) (x : List.Chain R a a_2), List.Chain.below x → motive a a_2 x) → motive a a_1 x",
  "offspring": ["List.Chain.below.nil", "List.Chain.below.cons"],
  "name": "List.Chain.brecOn"},
 {"type": "ℕ → UInt32",
  "offspring": ["UInt32.mk", "Fin.ofNat"],
  "name": "UInt32.ofNat"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → Sort u_1 → MonadWithReaderOf ρ m → MonadWithReaderOf ρ m → Sort u_1",
  "offspring": [],
  "name": "MonadWithReaderOf.noConfusionType"},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {γ : Type u_3} → {δ : Type u_4} → {ε : Type u_5} → (γ → δ → ε) → (α → γ) → (β → δ) → α → β → ε",
  "offspring": [],
  "name": "Function.bicompl"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«binderTerm∈_»"},
 {"type": "ByteSliceT → ℕ",
  "offspring": ["ByteArray.size", "ByteSliceT.arr", "ByteSliceT.off"],
  "name": "ByteSliceT.size"},
 {"type":
  "∀ {α : Sort u} {a b c : α} (r : α → α → Prop), a = b → r b c → r a c",
  "offspring": [],
  "name": "trans_rel_right"},
 {"type": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "offspring": ["Decidable"],
  "name": "DecidablePred"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (c : Nat.Linear.PolyCnstr) (cs : Nat.Linear.Certificate),\n  (Nat.Linear.PolyCnstr.denote ctx (Nat.Linear.Certificate.combineHyps c cs) → False) →\n    Nat.Linear.PolyCnstr.denote ctx c → Nat.Linear.Certificate.denote ctx cs",
  "offspring": [],
  "name": "Nat.Linear.Certificate.of_combineHyps"},
 {"type": "{m : Type u → Type v} → [inst : Monad m] → Monad (OptionT m)",
  "offspring": ["Monad.mk"],
  "name": "OptionT.instMonadOptionT"},
 {"type":
  "{ρ : Type u} →\n  {m : Type u → Type v} →\n    {n : Type u → Type w} → [inst : MonadLift m n] → [inst : MonadReaderOf ρ m] → MonadReaderOf ρ n",
  "offspring": ["MonadReaderOf.mk", "MonadReader.read"],
  "name": "instMonadReaderOf"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HDiv α β γ → HDiv α β γ → Sort u_1",
  "offspring": [],
  "name": "HDiv.noConfusionType"},
 {"type": "{α : Type u_1} → ToStream (Subarray α) (Subarray α)",
  "offspring": ["ToStream.mk"],
  "name": "instToStreamSubarray"},
 {"type": "∀ {v : Sat.Valuation}, Sat.Clause.reify v Sat.Clause.nil True",
  "offspring": ["Sat.Clause.reify.mk", "trivial"],
  "name": "Sat.Clause.reify_zero"},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      (q : Quotient s) →\n        (f : (a : α) → motive (Quotient.mk s a)) →\n          (∀ (a b : α), a ≈ b → (_ : Quotient.mk s a = Quotient.mk s b) ▸ f a = f b) → motive q",
  "offspring": ["Quot.recOn"],
  "name": "Quotient.recOn"},
 {"type":
  "{M₀ : Type u} → Sort u_1 → MonoidWithZero M₀ → MonoidWithZero M₀ → Sort u_1",
  "offspring": [],
  "name": "MonoidWithZero.noConfusionType"},
 {"type": "{α : Type u_1} → [inst : Repr α] → Repr (ULift α)",
  "offspring": ["reprArg", "ULift.down"],
  "name": "instReprULift"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} (a : α) (f : α → Option β), Option.bind (some a) f = f a",
  "offspring": [],
  "name": "Option.some_bind"},
 {"type": "∀ (a b : ℤ), -a * -b = a * b",
  "offspring":
  ["Int.mul_neg_eq_neg_mul_symm", "Int.neg_mul_eq_neg_mul_symm", "neg_neg"],
  "name": "Int.neg_mul_neg"},
 {"type": "∀ {a b : Prop}, (a → b) → (b → a) → a = b",
  "offspring": [],
  "name": "Eq.propIntro"},
 {"type": "∀ {a b c d : ℤ}, a ≤ c → b < d → 0 ≤ b → 0 < c → a * b < c * d",
  "offspring":
  ["Trans.trans",
   "Int.mul_le_mul_of_nonneg_right",
   "Int.mul_lt_mul_of_pos_left"],
  "name": "Int.mul_lt_mul'"},
 {"type": "{p : Prop} → p → Decidable p",
  "offspring": [],
  "name": "Decidable.isTrue"},
 {"type": "∀ (n : ℕ), 1 + n = Nat.succ n",
  "offspring": [],
  "name": "Nat.one_add"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β), Function.bijective f ↔ ∀ (b : β), ExistsUnique fun a => f a = b",
  "offspring":
  ["Function.bijective.injective",
   "Function.bijective.surjective",
   "unique_of_exists_unique",
   "ExistsUnique.exists"],
  "name": "Function.bijective_iff_exists_unique"},
 {"type":
  "{m : Type → Type v} → [inst : Monad m] → {α : Type} → (α → m Bool) → List α → List α → m (List α)",
  "offspring": ["cond"],
  "name": "List.filterAuxM"},
 {"type": "∀ (n : ℕ), 0 ≤ Int.ofNat n",
  "offspring": ["Int.NonNeg.mk"],
  "name": "Int.ofNat_nonneg"},
 {"type": "{α : Type u_1} → {β : Type u_2} → (α → β) → Option α → Option β",
  "offspring": ["Option.bind"],
  "name": "Option.map"},
 {"type": "Lean.TrailingParserDescr",
  "offspring": [],
  "name": "Array.«term__[_:_]»"},
 {"type":
  "(m : Type u → Type v) →\n  {n : Type u → Type w} →\n    [s1 : MonadControlT m n] →\n      [s2 : Bind n] → {α : Type u} → (({β : Type u} → n β → m (stM m n β)) → m (stM m n α)) → n α",
  "offspring": ["MonadControlT.liftWith", "MonadControlT.restoreM"],
  "name": "controlAt"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "Function.«term↿_»"},
 {"type": "∀ (a b : ℤ), a * b = b * a",
  "offspring":
  ["Int.ofNat_mul_ofNat",
   "Int.ofNat_mul_negSucc_ofNat",
   "Int.negSucc_ofNat_ofNat",
   "Int.negOfNat",
   "Int.mul_negSucc_ofNat_negSucc_ofNat"],
  "name": "Int.mul_comm"},
 {"type": "{α : Type u} → Sort u_1 → Neg α → Neg α → Sort u_1",
  "offspring": [],
  "name": "Neg.noConfusionType"},
 {"type": "∀ {a : Prop}, ¬a → a ↔ a",
  "offspring": ["Decidable.not_imp_self"],
  "name": "not_imp_self"},
 {"type": "∀ {n m : ℕ}, n < m → n < Nat.succ m",
  "offspring": ["Nat.lt.step.proof_1"],
  "name": "Nat.lt.step"},
 {"type":
  "{ω σ : Type} → {m : Type → Type} → [inst : Monad m] → [inst : MonadLiftT (ST ω) m] → StateRefT' ω σ m σ",
  "offspring": [],
  "name": "StateRefT'.get"},
 {"type": "{α : Type u_1} → (lt : α → α → Bool) → α → BinaryHeap α lt",
  "offspring": ["BinaryHeap.mk"],
  "name": "BinaryHeap.singleton"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (e : α ≃ β) (x : β), Equiv.toFun e (Equiv.toFun (Equiv.symm e) x) = x",
  "offspring": ["Equiv.right_inv"],
  "name": "Equiv.apply_symm_apply"},
 {"type": "∀ (n : ℕ), Nat.pred n ≤ n",
  "offspring": ["Nat.le.refl", "Nat.le_succ"],
  "name": "Nat.pred_le"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {x : Option (Option α)},\n  Option.join (Option.map (Option.map f) x) = Option.map f (Option.join x)",
  "offspring":
  ["Option.map_none'",
   "Option.none_bind",
   "Option.map_some'",
   "Option.some_bind",
   "id_eq"],
  "name": "Option.join_map_eq_map_join"},
 {"type": "ToBool Bool", "offspring": ["ToBool.mk"], "name": "instToBoolBool"},
 {"type": "∀ {p : Prop}, ¬p → p ≠ True",
  "offspring": [],
  "name": "ne_true_of_not"},
 {"type": "{ε : Type u} → {α : Type u_1} → Except ε α → Bool",
  "offspring": [],
  "name": "Except.toBool"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (n : ℕ), Array.size a = n → ∀ (i : ℕ), i + 1 ≤ Array.size a → i < n",
  "offspring": ["Nat.lt_of_lt_of_eq", "Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "Array.toListLitAux.proof_2"},
 {"type": "UInt64 → UInt32",
  "offspring": ["Nat.toUInt32", "UInt64.toNat"],
  "name": "UInt64.toUInt32"},
 {"type": "(a b : USize) → Decidable (a ≤ b)",
  "offspring": ["USize.decLe"],
  "name": "instDecidableLeUSizeInstLEUSize"},
 {"type":
  "{α : Type u} → [inst : PartialOrder α] → [inst : DecidableRel fun a a_1 => a ≤ a_1] → DecidableEq α",
  "offspring":
  ["le_antisymm",
   "decidableEq_of_decidableLe.proof_1",
   "decidableEq_of_decidableLe.proof_2"],
  "name": "decidableEq_of_decidableLe"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Type u_2} (f : (x : α) → β x) (p : α → Prop) (x : Subtype p), Subtype.restrict f p x = f x.val",
  "offspring": [],
  "name": "Subtype.restrict_apply"},
 {"type":
  "∀ {α : Type u_1} {x : α} {lt : α → α → Bool} {self : BinaryHeap α lt},\n  BinaryHeap.max self = some x → 0 < BinaryHeap.size self",
  "offspring":
  ["Decidable.of_not_not",
   "dite_congr",
   "instDecidableFalse",
   "Array.get",
   "Eq.mpr_prop",
   "dite_false",
   "eq_false'"],
  "name": "BinaryHeap.size_pos_of_max"},
 {"type": "Nonempty (Fin USize.size)",
  "offspring": ["instNonempty", "USize.instInhabitedFinSize"],
  "name": "USize.instSemiringUSize.proof_3"},
 {"type": "{α : Type u} → [inst : ToString α] → Bool → List α → String",
  "offspring": [],
  "name": "List.toStringAux"},
 {"type": "(a b : UInt16) → Decidable (a ≤ b)",
  "offspring": [],
  "name": "UInt16.decLe"},
 {"type": "ℕ → Float", "offspring": ["Float.ofNat"], "name": "Nat.toFloat"},
 {"type": "∀ (y : ℕ), Nat.gcd 0 y = y",
  "offspring": [],
  "name": "Nat.gcd_zero_left"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term‹_›»"},
 {"type": "Type u → Type u → Type u → Type u",
  "offspring": [],
  "name": "EStateM.Result"},
 {"type": "∀ (n m : ℕ), Nat.beq n m = Nat.beq n m",
  "offspring": ["Nat.beq"],
  "name": "Nat.decEq.proof_1"},
 {"type": "Sort u → Sat.Literal → Sat.Literal → Sort u",
  "offspring": [],
  "name": "Sat.Literal.noConfusionType"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_⊕'_»"},
 {"type": "∀ {a b : Prop}, (a ∧ b) ∧ b ↔ a ∧ b",
  "offspring": [],
  "name": "and_self_right"},
 {"type":
  "{m : Type u_1 → Type u_2} → {α ε : Type u_1} → [inst : Monad m] → m α → ExceptCpsT ε m α",
  "offspring": [],
  "name": "ExceptCpsT.lift"},
 {"type": "∀ {a b : ℤ}, a ≤ b → a < b + 1",
  "offspring": ["Int.add_le_add_right"],
  "name": "Int.lt_add_one_of_le"},
 {"type":
  "∀ {α : Type u_1} {R : α → α → Prop} (hd : α) (tl : List α),\n  (¬∀ (x : α), x ∈ tl → R hd x) → List.Pairwise R (hd :: tl) → False",
  "offspring": [],
  "name": "List.decidablePairwise.proof_2"},
 {"type": "LawfulBEq Char",
  "offspring":
  ["LawfulBEq.mk", "of_decide_eq_self_eq_true", "instDecidableEqChar"],
  "name": "instLawfulBEqCharInstBEqInstDecidableEqChar.proof_1"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (p q : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (List.reverseAux p q) = Nat.Linear.Poly.denote ctx (p ++ q)",
  "offspring":
  ["List.nil_append",
   "Nat.Linear.Poly.denote_append",
   "Nat.add_left_comm",
   "List.List.append_eq",
   "Nat.add_assoc"],
  "name": "Nat.Linear.Poly.denote_reverseAux"},
 {"type": "∀ {a b c : Prop}, (a ↔ b) → (a ∨ c ↔ b ∨ c)",
  "offspring": ["or_congr", "Iff.rfl"],
  "name": "or_congr_left"},
 {"type": "Lean.Meta.Simp.Context → Std.HashMap Lean.Name Lean.Name",
  "offspring":
  ["Id.run",
   "ForIn.forIn",
   "Id.instMonadId",
   "ForInStep",
   "Unit",
   "Mathlib.Tactic.Lint.elements",
   "EmptyCollection.emptyCollection"],
  "name": "Mathlib.Tactic.Lint.constToSimpDeclMap"},
 {"type": "∀ {a b : Prop}, ¬a ∨ b → a → b",
  "offspring": ["Or.elim"],
  "name": "Or.neg_resolve_left"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → a → b", "offspring": [], "name": "Iff.mp"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → [inst : Monad m] → {α β : Type u} → (α → β) → ExceptT ε m α → ExceptT ε m β",
  "offspring": ["ExceptT.mk", "Except.ok", "Except.error"],
  "name": "ExceptT.map"},
 {"type": "{α : Type u} → Array α → ℕ → α → α × Array α",
  "offspring": ["Array.swapAt"],
  "name": "Array.swapAt!"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Ext.tacticSubst_eqs"},
 {"type":
  "{m : Type u → Type v} →\n  {γ : Type w₁} → {α : Type w₂} → [self : ForM m γ α] → [inst : Monad m] → γ → (α → m PUnit) → m PUnit",
  "offspring": [],
  "name": "ForM.forM"},
 {"type":
  "∀ (x : ℕ) (x_1 : UInt16), npow_rec (Nat.succ x) x_1 = npow_rec (Nat.succ x) x_1",
  "offspring": [],
  "name": "UInt16.instSemiringUInt16.proof_16"},
 {"type": "Bool → Bool", "offspring": [], "name": "not"},
 {"type": "{α : Type u} → [inst : Preorder α] → Trans LE.le LE.le LE.le",
  "offspring": ["Trans.mk", "instTransLeToLE.proof_1"],
  "name": "instTransLeToLE"},
 {"type": "∀ {a b : Prop}, ¬(a → b) ↔ a ∧ ¬b",
  "offspring": ["Decidable.not_imp"],
  "name": "not_imp"},
 {"type": "{α : Type u} → Sort u_1 → ReprAtom α → ReprAtom α → Sort u_1",
  "offspring": [],
  "name": "ReprAtom.noConfusionType"},
 {"type": "∀ (a b : PUnit), a = b",
  "offspring": [],
  "name": "PUnit.subsingleton"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {g : β → α} {f : α → β}, Function.LeftInverse g f → Function.injective f",
  "offspring": [],
  "name": "Function.LeftInverse.injective"},
 {"type": "UInt16 → UInt16", "offspring": [], "name": "UInt16.complement"},
 {"type": "∀ {M : Type u} [inst : Monoid M] (a : M), a * 1 = a",
  "offspring": ["Monoid.mul_one"],
  "name": "mul_one"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadWithReader ρ m] → {α : Type u} → (ρ → ρ) → m α → m α",
  "offspring": [],
  "name": "MonadWithReader.withReader"},
 {"type": "∀ {m n : ℕ}, m ∣ n → n ∣ m → m = n",
  "offspring":
  ["Nat.eq_zero_of_zero_dvd",
   "Nat.le_antisymm",
   "Nat.le_of_dvd",
   "Nat.succ_pos"],
  "name": "Nat.dvd_antisymm"},
 {"type":
  "{α : Type u} →\n  {β : α → Sort v} →\n    (s : Set α) → ((i : α) → β i) → ((i : α) → β i) → [inst : (j : α) → Decidable (j ∈ s)] → (i : α) → β i",
  "offspring": [],
  "name": "set.piecewise"},
 {"type": "∀ {m n k : ℕ}, 0 < k → k * m ∣ k * n → m ∣ n",
  "offspring": ["Exists.elim", "Nat.eq_of_mul_eq_mul_left", "Nat.mul_assoc"],
  "name": "Nat.dvd_of_mul_dvd_mul_left"},
 {"type": "∀ {n : ℕ} {i j : Fin n}, ↑i = ↑j → i = j",
  "offspring": [],
  "name": "Fin.eq_of_val_eq"},
 {"type": "∀ {a b : Prop}, (a ∧ b ↔ b) ↔ b → a",
  "offspring": ["and_iff_right_of_imp"],
  "name": "and_iff_right_iff_imp"},
 {"type": "∀ {α : Type u_1} (a : α), ¬a ∈ none",
  "offspring": [],
  "name": "Option.not_mem_none"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.Ring.tacticRing"},
 {"type":
  "∀ {n : ℕ} (val : ℕ) (isLt : val < n), sizeOf { val := val, isLt := isLt } = 1 + sizeOf val + sizeOf isLt",
  "offspring": ["instSizeOfNat"],
  "name": "Fin.mk.sizeOf_spec"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (i : Fin n) {m : Fin n}, 0 < m → i % m < m",
  "offspring": [],
  "name": "Fin.mod_lt"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α), ∃ n m, UFModel.Models self.arr m",
  "offspring": [],
  "name": "UnionFind.model"},
 {"type":
  "∀ (p : Prop) (α : p → Type u_1) (f g : (hp : p) → α hp), (∀ (a : p), f a = g a) ↔ (fun hp => f hp) = fun hp => g hp",
  "offspring": ["Iff.symm", "Function.funext_iff"],
  "name": "Function.decidable_eq_pfun.proof_1"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x : Fin (UnionFind.size self)) (s : Array (UFNode α))\n  (root : Fin (Array.size s)),\n  (∃ n m m',\n      UFModel.Models self.arr m ∧\n        UFModel.Models s m' ∧\n          m'.rank = m.rank ∧\n            (∃ hr, ↑(UFModel.parent m' { val := ↑root, isLt := hr }) = ↑root) ∧\n              UFModel.rank m ↑x ≤ UFModel.rank m ↑root) →\n    (∃ n m, UFModel.Models s m) ∧ Array.size s = UnionFind.size self ∧ (Array.get s root).parent = ↑root",
  "offspring": ["UFModel.Models.size_eq", "UFModel.Models.parent_eq"],
  "name": "UnionFind.find.proof_1"},
 {"type": "∀ {α : Sort u}, α → Nonempty α",
  "offspring": [],
  "name": "Nonempty.intro"},
 {"type": "Subsingleton (Fin 0)",
  "offspring": ["instSubsingletonFinOfNatNatInstOfNatNat.proof_1"],
  "name": "instSubsingletonFinOfNatNatInstOfNatNat"},
 {"type": "∀ {a b c : ℤ}, a + b ≤ c → b ≤ c - a",
  "offspring": [],
  "name": "Int.le_sub_left_of_add_le"},
 {"type": "{α : Type u} → ℕ → List α → List (ℕ × α)",
  "offspring": [],
  "name": "List.enumFrom"},
 {"type": "∀ {α : Type u_1} (l : List α), (List.toArray l).data = l",
  "offspring": ["List.toArrayAux_data", "Array.mkEmpty", "List.redLength"],
  "name": "List.toArray_data"},
 {"type":
  "∀ {α : Type u_1} {l : List α} {n : ℕ} {a b : α}, a ∈ List.set l n b → a ∈ l ∨ a = b",
  "offspring":
  ["List.set",
   "Or.elim",
   "List.mem_cons",
   "List.mem_cons_of_mem",
   "List.mem_cons_self",
   "Nat.add"],
  "name": "List.mem_or_eq_of_mem_set"},
 {"type": "∀ (α : Sort u_1), ¬Nonempty α → α → False",
  "offspring": [],
  "name": "Classical.typeDecidable.proof_1"},
 {"type": "CoeSort Bool Prop",
  "offspring": ["CoeSort.mk"],
  "name": "boolToSort"},
 {"type": "{A : Type u} → Sort u_1 → AddMonoid A → AddMonoid A → Sort u_1",
  "offspring": [],
  "name": "AddMonoid.noConfusionType"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tactic_"},
 {"type": "(a : ByteArray) → Fin (ByteArray.size a) → UInt8 → ByteArray",
  "offspring": ["ByteArray.mk", "Array.set"],
  "name": "ByteArray.set"},
 {"type": "∀ {α : Type u_1} (t : List α), Function.injective fun s => s ++ t",
  "offspring": ["List.append_right_cancel"],
  "name": "List.append_left_injective"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {g : β → α}, Function.RightInverse f g → Function.injective f",
  "offspring":
  ["Function.LeftInverse.injective", "Function.RightInverse.LeftInverse"],
  "name": "Function.RightInverse.injective"},
 {"type":
  "∀ {α : Type u_1} (s : Subarray α), s.start < s.stop → s.start + 1 ≤ s.stop",
  "offspring": ["Nat.le_of_lt_succ", "Nat.add_lt_add_right"],
  "name": "Subarray.popFront.proof_1"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, a1.val = a2.val → a1 = a2",
  "offspring": ["Subtype.ext"],
  "name": "Subtype.ext_val"},
 {"type": "∀ (x x_1 : UInt64), x * x_1 = x_1 * x",
  "offspring":
  ["UInt64.eq_of_val_eq", "UInt64.mul_def", "CommSemigroup.mul_comm"],
  "name": "UInt64.instCommRingUInt64.proof_1"},
 {"type": "UInt16 → UInt32",
  "offspring": ["Nat.toUInt32", "UInt16.toNat"],
  "name": "UInt16.toUInt32"},
 {"type": "∀ {α : Sort u} {p : α → Prop} {a b : α}, b = a → p a → p b",
  "offspring": [],
  "name": "Eq.substr"},
 {"type":
  "∀ {α : Type u_1} (lt : α → α → Bool) (a : Array α),\n  Fin (Array.size a) → Array.size (BinaryHeap.mkHeap lt a).val = Array.size a",
  "offspring": ["Subtype.property"],
  "name": "BinaryHeap.size_mkHeap"},
 {"type": "∀ {m n k : ℕ}, Nat.coprime k m → k ∣ m * n → k ∣ n",
  "offspring": ["Nat.coprime.dvd_of_dvd_mul_right"],
  "name": "Nat.coprime.dvd_of_dvd_mul_left"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (n : ℕ) (hsz : Array.size a = n), a = Array.toArrayLit a n hsz",
  "offspring": ["sorryAx"],
  "name": "Array.toArrayLit_eq"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → List α → List α",
  "offspring": ["List.pwFilter", "Ne"],
  "name": "List.eraseDup"},
 {"type":
  "(Lean.Name → Lean.MetaM (Option Lean.MessageData)) →\n  Lean.MessageData → Lean.MessageData → Bool → Mathlib.Tactic.Lint.Linter",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.mk"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.tacticNorm_cast__"},
 {"type": "Float → String", "offspring": [], "name": "Float.toString"},
 {"type": "{α : Sort u} → Sort u_1 → Setoid α → Setoid α → Sort u_1",
  "offspring": [],
  "name": "Setoid.noConfusionType"},
 {"type": "{α : Type u_1} → Set α", "offspring": ["setOf"], "name": "Set.univ"},
 {"type": "{α : Type u} → {β : Type v} → List α → List β → List (α × β)",
  "offspring": ["List.zipWith"],
  "name": "List.zip"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk"],
  "name": "UInt16.sub"},
 {"type": "∀ (n m k : ℕ), n - m - k = n - (m + k)",
  "offspring":
  ["Nat.zero_eq",
   "Nat.sub_zero",
   "Nat.add_zero",
   "Nat.add_succ",
   "Nat.sub_succ",
   "Nat.pred"],
  "name": "Nat.sub_sub"},
 {"type": "{α : Type u_1} → [inst : BEq α] → Array α → α → Array α",
  "offspring": ["Array.indexOf?", "Array.feraseIdx"],
  "name": "Array.erase"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} (a : α), (∀ (a_1 : α), a_1 ∈ some a → p a_1) → p a",
  "offspring": ["Option.mem_def"],
  "name": "Option.pmap.proof_1"},
 {"type": "{α : Type u} → Sort u_1 → Ord α → Ord α → Sort u_1",
  "offspring": [],
  "name": "Ord.noConfusionType"},
 {"type": "{ω σ : Type} → {m : Type → Type} → MonadLift m (StateRefT' ω σ m)",
  "offspring": ["MonadLift.mk", "StateRefT'.lift"],
  "name": "StateRefT'.instMonadLiftStateRefT'"},
 {"type":
  "∀ {α : Type u} [inst : SizeOf α] (fn : Unit → α), sizeOf { fn := fn } = 1 + sizeOf fn",
  "offspring": [],
  "name": "Thunk.mk.sizeOf_spec"},
 {"type": "{α : Type u} → ℕ → List α → List α",
  "offspring": [],
  "name": "List.drop"},
 {"type": "Lean.PrettyPrinter.Delaborator.Delab",
  "offspring":
  ["Tactic.NormCast.coeDelaborator",
   "Tactic.NormCast.CoeFnInfo.mk",
   "Tactic.NormCast.CoeFnType.coe"],
  "name": "Int.cast.delaborator"},
 {"type": "∀ {M₀ : Type u} [self : MulZeroOneClass M₀] (a : M₀), a * 0 = 0",
  "offspring": [],
  "name": "MulZeroOneClass.mul_zero"},
 {"type": "UFModel 0",
  "offspring": ["UFModel.mk", "Fin.elim0", "UFModel.empty.proof_1"],
  "name": "UFModel.empty"},
 {"type": "∀ (a : UInt64), 1 * a = a",
  "offspring":
  ["UInt64.one_def",
   "UInt64.mul_def",
   "UInt64.mk",
   "one_mul",
   "UInt64.mk_val_eq"],
  "name": "UInt64.instSemiringUInt64.proof_13"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Mathlib.ExtendedBinder.extBinder"],
  "name": "Mathlib.ExtendedBinder.extBinderParenthesized"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt),\n  BinaryHeap.size (BinaryHeap.popMax self) = BinaryHeap.size self - 1",
  "offspring": ["Subtype.property", "BinaryHeap.popMaxAux"],
  "name": "BinaryHeap.size_popMax"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop}, List.Forall₂ R [] []",
  "offspring": [],
  "name": "List.Forall₂.nil"},
 {"type": "Inhabited NonemptyType",
  "offspring": ["Subtype.mk"],
  "name": "instInhabitedNonemptyType"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_&&_»"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<*>_»"},
 {"type":
  "∀ {α : Type u_1} (parent : ℕ) (value : α) (rank parent_1 : ℕ) (value_1 : α) (rank_1 : ℕ),\n  ({ parent := parent, value := value, rank := rank } = { parent := parent_1, value := value_1, rank := rank_1 }) =\n    (parent = parent_1 ∧ value = value_1 ∧ rank = rank_1)",
  "offspring": ["UFNode.mk"],
  "name": "UFNode.mk.injEq"},
 {"type":
  "∀ {α : Sort u} {b : α → Sort v} {p : (x : α) → b x → Prop}, (∀ (x : α), ∃ y, p x y) ↔ ∃ f, ∀ (x : α), p x (f x)",
  "offspring": ["Classical.axiomOfChoice"],
  "name": "Classical.skolem"},
 {"type": "{n : ℕ} → OfNat UInt32 n",
  "offspring": ["OfNat.mk", "UInt32.ofNat"],
  "name": "instOfNatUInt32"},
 {"type": "{α : Sort u} → (α → Prop) → Prop",
  "offspring": [],
  "name": "Exists"},
 {"type":
  "∀ (lits : Array ℤ) (expr proof : Lean.Expr) (lits_1 : Array ℤ) (expr_1 proof_1 : Lean.Expr),\n  ({ lits := lits, expr := expr, proof := proof } = { lits := lits_1, expr := expr_1, proof := proof_1 }) =\n    (lits = lits_1 ∧ expr = expr_1 ∧ proof = proof_1)",
  "offspring": ["Mathlib.Tactic.Sat.Clause", "Mathlib.Tactic.Sat.Clause.mk"],
  "name": "Mathlib.Tactic.Sat.Clause.mk.injEq"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "commandAddElim__"},
 {"type": "∀ {a b : Prop}, (a ∨ b ↔ a) ↔ b → a",
  "offspring": ["or_iff_left_of_imp"],
  "name": "or_iff_left_iff_imp"},
 {"type": "∀ {α : Type u_1} {a b : Array α}, a.data = b.data → a = b",
  "offspring": ["Array.data", "Array.mk"],
  "name": "Array.ext'"},
 {"type":
  "{n : ℕ} → {α : Sort u_1} → (n = 0 → α) → ((m : ℕ) → n = Nat.succ m → α) → α",
  "offspring": ["Nat.discriminate.proof_1", "Nat.discriminate.proof_2"],
  "name": "Nat.discriminate"},
 {"type": "{α : Type u_1} → Set α → Set α",
  "offspring": ["setOf"],
  "name": "Set.compl"},
 {"type": "Lean.ParserDescr", "offspring": ["calcStep"], "name": "calc"},
 {"type":
  "{α : Type u₁} → {β : Type u₂} → {φ : Type u₃} → (α → β → φ) → α × β → φ",
  "offspring": [],
  "name": "Function.uncurry"},
 {"type":
  "∀ (x x_1 : UInt16), { val := (x - x_1).1 } = { val := (x + -x_1).1 }",
  "offspring": ["SubNegMonoid.sub_eq_add_neg"],
  "name": "UInt16.instRingUInt16.proof_1"},
 {"type":
  "{α : Type} →\n  [inst : Inhabited α] → (as : Array α) → (α → α → Bool) → optParam ℕ 0 → optParam ℕ (Array.size as - 1) → Array α",
  "offspring": [],
  "name": "Array.qsort"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)], AddMonoidWithOne.natCast 0 = 0",
  "offspring": ["AddMonoidWithOne.natCast_zero"],
  "name": "instAddGroupWithOneFin.proof_1"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a <+ a_1 → Prop} (l₁ l₂ : List α) (a : α) {a_1 : l₁ <+ l₂},\n  List.sublist.below a_1 → motive l₁ l₂ a_1 → List.sublist.below (_ : a :: l₁ <+ a :: l₂)",
  "offspring": [],
  "name": "List.sublist.below.cons2"},
 {"type": "Tactic.NormCast.Label",
  "offspring": [],
  "name": "Tactic.NormCast.Label.move"},
 {"type": "∀ {n : ℕ} (a b : Fin n), a ≤ b ∨ b ≤ a",
  "offspring": ["Nat.le_total"],
  "name": "Fin.le_total"},
 {"type":
  "{α : Sort u_1} → {β : Type u_2} → (ℕ → α → β → α) → ℕ → α → List β → α",
  "offspring": [],
  "name": "List.foldlIdxAux"},
 {"type":
  "Lean.Name → optParam (Option Tactic.NormCast.CoeFnInfo) none → Lean.MetaM Unit",
  "offspring":
  ["Tactic.NormCast.CoeFnInfo",
   "GT.gt",
   "Tactic.NormCast.CoeFnInfo.mk",
   "Tactic.NormCast.CoeFnType.coe",
   "Tactic.NormCast.coeExt",
   "Tactic.NormCast.addCoeDelaborator"],
  "name": "Tactic.NormCast.registerCoercion"},
 {"type": "∀ {α : Type u_1}, UFModel.Models #[] UFModel.empty",
  "offspring": ["UFModel.Agrees.empty"],
  "name": "UFModel.Models.empty"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → (l : List α) → Decidable (∃ x, x ∈ l ∧ p x)",
  "offspring":
  ["decidableBEx.proof_1",
   "decidableBEx.proof_2",
   "decidableBEx.proof_3",
   "decidableBEx.proof_4"],
  "name": "decidableBEx"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<->_»"},
 {"type": "FloatSpec → Type", "offspring": [], "name": "FloatSpec.float"},
 {"type": "{α : Type u} → (α → α → α) → OrOp α",
  "offspring": [],
  "name": "OrOp.mk"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term~~~_»"},
 {"type": "Nat.Linear.Certificate → Nat.Linear.PolyCnstr",
  "offspring":
  ["Nat.Linear.ExprCnstr",
   "Nat.Linear.PolyCnstr.mk",
   "Nat.Linear.Certificate.combineHyps",
   "Nat.Linear.PolyCnstr.mul",
   "Nat.add",
   "Nat.Linear.ExprCnstr.toNormPoly"],
  "name": "Nat.Linear.Certificate.combine"},
 {"type": "{R : Type u} → [self : Semiring R] → NonAssocSemiring R",
  "offspring": ["NonAssocSemiring.mk", "Semiring.one_mul", "Semiring.mul_one"],
  "name": "Semiring.toNonAssocSemiring"},
 {"type": "{α : Type u} → Sort u_1 → ToString α → ToString α → Sort u_1",
  "offspring": [],
  "name": "ToString.noConfusionType"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] → (α → β → m β) → β → (as : Array α) → optParam ℕ (Array.size as) → optParam ℕ 0 → m β",
  "offspring": [],
  "name": "Array.foldrM"},
 {"type":
  "∀ {c : Prop} {h : Decidable c}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e",
  "offspring": [],
  "name": "if_neg"},
 {"type": "{α : Type u_1} → (α → Bool) → Option α → Bool",
  "offspring": [],
  "name": "Option.any"},
 {"type": "ℕ → List ℕ → List ℕ", "offspring": [], "name": "List.rangeAux"},
 {"type": "UInt8 → Fin UInt8.size", "offspring": [], "name": "UInt8.val"},
 {"type": "∀ {a a_1 : ℕ}, Int.ofNat a = Int.ofNat a_1 → a = a_1",
  "offspring": [],
  "name": "Int.ofNat.inj"},
 {"type": "∀ {α : Sort u₁}, Function.injective id",
  "offspring": [],
  "name": "Function.injective_id"},
 {"type": "Type u → Type u", "offspring": [], "name": "ForInStep"},
 {"type": "Sort u → UInt16 → UInt16 → Sort u",
  "offspring": [],
  "name": "UInt16.noConfusionType"},
 {"type":
  "{α : Type u_1} → (self : UnionFind α) → Fin (UnionFind.size self) → Fin (UnionFind.size self) → UnionFind α",
  "offspring":
  ["UnionFind.link",
   "UnionFind.union.proof_2",
   "UnionFind.find",
   "UnionFind.union.proof_1"],
  "name": "UnionFind.union"},
 {"type": "∀ {α : Type u_1} (as : Array α), Array.size as ≤ Array.size as",
  "offspring": ["Nat.le_refl"],
  "name": "Array.anyM.proof_1"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l → ∃ s t, l = s ++ a :: t",
  "offspring": ["List.cons_append"],
  "name": "List.mem_constructor"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (as : List α), List.elem a as = true ↔ a ∈ as",
  "offspring": ["List.mem_of_elem_eq_true", "List.elem_eq_true_of_mem"],
  "name": "List.instDecidableMemListInstMembershipList.proof_1"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddMonoidWithOne"},
 {"type": "∀ {α : Type u_1} {l : List α}, List.length l = 0 → l = []",
  "offspring": [],
  "name": "List.eq_nil_of_length_eq_zero"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop} {b : Prop}, (∃ x, p x) → (∀ (a : α), p a → b) → b",
  "offspring": [],
  "name": "Exists.elim"},
 {"type": "{α : Type u_1} → List α → List α",
  "offspring": [],
  "name": "List.dropLast"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∘_»"},
 {"type": "∀ (n m : ℕ), n ^ Nat.succ m = n ^ m * n",
  "offspring": [],
  "name": "Nat.pow_succ"},
 {"type": "∀ {a b : Prop}, (a ∨ b) ∨ b ↔ a ∨ b",
  "offspring": ["Or.elim"],
  "name": "or_self_right"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "Bind"},
 {"type": "∀ {a b c : ℤ}, a < b + c → -b + a < c",
  "offspring": ["Int.add_comm", "Int.sub_left_lt_of_lt_add"],
  "name": "Int.neg_add_lt_left_of_lt_add"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], a ∨ b ↔ ¬a → b",
  "offspring": ["Or.resolve_left"],
  "name": "Decidable.or_iff_not_imp_left"},
 {"type": "∀ {a b c d : ℤ}, a < b → c < d → a + c < b + d",
  "offspring": ["lt_trans", "Int.add_lt_add_right", "Int.add_lt_add_left"],
  "name": "Int.add_lt_add"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {a b : α}, Option.guard p a = some b ↔ a = b ∧ p a",
  "offspring":
  ["ite_true",
   "Option.some.injEq",
   "and_true",
   "instDecidableFalse",
   "ite_false",
   "eq_false'",
   "and_false"],
  "name": "Option.guard_eq_some"},
 {"type": "∀ {p : Prop} {s : Decidable p}, decide p = false → p = False",
  "offspring": ["of_decide_eq_false"],
  "name": "eq_false_of_decide"},
 {"type": "∀ {a b c d : ℤ}, a ≤ b → c ≤ d → a + c ≤ b + d",
  "offspring": ["le_trans", "Int.add_le_add_right", "Int.add_le_add_left"],
  "name": "Int.add_le_add"},
 {"type":
  "∀ {α : Type u_1} (n : ℕ) (l : List α), List.take n l ++ List.drop n l = l",
  "offspring": ["List.take", "List.drop", "congr_arg"],
  "name": "List.take_append_drop"},
 {"type": "{α : Type u} → {β : Type u_1} → (α → Array β) → Array α → Array β",
  "offspring": ["Array.foldl", "Array.empty"],
  "name": "Array.concatMap"},
 {"type": "∀ (n : ℕ), Nat.succ n ≤ 0 → False",
  "offspring": [],
  "name": "Nat.not_succ_le_zero"},
 {"type": "Char",
  "offspring": ["System.Platform.isWindows"],
  "name": "System.FilePath.pathSeparator"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Repr α] → [inst : ReprTuple β] → Repr (α × β)",
  "offspring": ["List.reverse", "ReprTuple.reprTuple", "repr"],
  "name": "instReprProd"},
 {"type": "∀ {n : ℕ}, n ≠ 0 → Nat.pred n < n",
  "offspring": ["Nat.lt_succ_of_le", "Nat.le_refl"],
  "name": "Nat.pred_lt"},
 {"type":
  "∀ (m n k : ℕ), Int.subNatNat (m + n) k = Int.ofNat m + Int.subNatNat n k",
  "offspring": [],
  "name": "Int.subNatNat_add"},
 {"type": "∀ {a b : ℕ}, a < b → a ≠ b",
  "offspring": ["Nat.not_le_of_lt", "Nat.le_refl"],
  "name": "Nat.ne_of_lt"},
 {"type":
  "{α : Type u_1} → (arr : Array (UFNode α)) → (∃ n m, UFModel.Models arr m) → UnionFind α",
  "offspring": [],
  "name": "UnionFind.mk"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«stx_*»"},
 {"type": "Ordering → ℕ", "offspring": [], "name": "Ordering.toCtorIdx"},
 {"type": "Lean.ParserDescr",
  "offspring": ["Tactic.NormCast.Attr.normCastLabel"],
  "name": "Tactic.NormCast.Attr.normCast"},
 {"type": "{α : Sort u} → {a : α} → {β : Sort v} → β → CoeT α a β",
  "offspring": [],
  "name": "CoeT.mk"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HOr α β γ] → α → β → γ",
  "offspring": [],
  "name": "HOr.hOr"},
 {"type": "∀ {a b : ℤ}, a < b → ∀ (c : ℤ), c - b < c - a",
  "offspring": ["Int.add_lt_add_left", "Int.neg_lt_neg"],
  "name": "Int.sub_lt_sub_left"},
 {"type":
  "∀ {α : Sort u_1} {a a' : α} {β : Sort u_2} (y : β) (h : a = a'), h ▸ y = y",
  "offspring": [],
  "name": "eq_rec_constant"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ),\n  Function.injective2 f → ∀ {a₁ a₂ : α} {b₁ b₂ : β}, f a₁ b₁ = f a₂ b₂ ↔ a₁ = a₂ ∧ b₁ = b₂",
  "offspring": ["congr_arg2"],
  "name": "Function.injective2.eq_iff"},
 {"type":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : outParam (Type v)} → ({β : Type u₁} → [inst : Monad m] → ρ → β → (α → β → m (ForInStep β)) → m β) → ForIn m ρ α",
  "offspring": [],
  "name": "ForIn.mk"},
 {"type": "∀ {α : Prop}, α", "offspring": [], "name": "lcProof"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → {α : Type u_2} → (α → α → m Unit) → List α → m Unit",
  "offspring": ["List.mmap'"],
  "name": "List.mmap'Diag"},
 {"type": "∀ (a : Prop), a = True ∨ a = False",
  "offspring": ["True.intro"],
  "name": "Classical.propComplete"},
 {"type": "{α : Type u} → [inst : Inhabited α] → Array α → ℕ → α",
  "offspring": ["Array.get!"],
  "name": "Array.getOp"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (as : List α), List.card as ≤ List.card (a :: as)",
  "offspring":
  ["List.card_cons_of_mem",
   "le_refl",
   "List.card_cons_of_not_mem",
   "Nat.le_succ"],
  "name": "List.card_le_card_cons"},
 {"type": "{α : Type u} → (ℕ → α → α) → ℕ → α → α",
  "offspring": ["Nat.foldAux"],
  "name": "Nat.fold"},
 {"type": "{α : Type u_1} → [inst : LT α] → LT (Option α)",
  "offspring": ["LT.mk", "Option.lt"],
  "name": "instLTOption"},
 {"type":
  "∀ {α : Type u_1} {a : α} [inst : DecidableEq α] [inst_1 : SizeOf α] {as : Array α},\n  Array.anyM.loop (fun b => decide (a = b)) as (Array.size as) (_ : Array.size as ≤ Array.size as) 0 = true →\n    ∀ (j : ℕ),\n      Array.anyM.loop (fun b => decide (a = b)) as (Array.size as) (_ : Array.size as ≤ Array.size as) j = true →\n        sizeOf a < sizeOf as",
  "offspring":
  ["WellFounded.fix",
   "Array.get",
   "Nat.lt_of_lt_of_le",
   "Nat.le_refl",
   "Array.sizeOf_get_lt",
   "dif_neg",
   "eq_false'",
   "WellFounded.fix_eq",
   "Array.anyM.loop.proof_1",
   "Array.anyM.loop.proof_2",
   "Array.anyM.loop.proof_3",
   "Id.instMonadId",
   "Decidable.decide",
   "of_decide_eq_false",
   "instDecidableFalse"],
  "name": "Array.sizeOf_lt_of_mem.aux"},
 {"type":
  "∀ (x y : Tactic.NormCast.Label), Tactic.NormCast.Label.toCtorIdx x = Tactic.NormCast.Label.toCtorIdx y → x = y",
  "offspring": [],
  "name": "Tactic.NormCast.instDecidableEqLabel.proof_1"},
 {"type": "∀ {n m : ℕ}, 0 < n → 1 < m → n / m < n",
  "offspring": [],
  "name": "Nat.div_lt_self"},
 {"type": "LE USize",
  "offspring": ["LE.mk", "USize.le"],
  "name": "instLEUSize"},
 {"type":
  "∀ {α : Type u} (data data_1 : List α), ({ data := data } = { data := data_1 }) = (data = data_1)",
  "offspring": ["Array.mk"],
  "name": "Array.mk.injEq"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (k : ℕ) (v : Nat.Linear.Var) (p : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx ((k, v) :: p) = k * Nat.Linear.Var.denote ctx v + Nat.Linear.Poly.denote ctx p",
  "offspring": ["Nat.zero_add", "Nat.add_left_comm"],
  "name": "Nat.Linear.Poly.denote_cons"},
 {"type":
  "∀ {α : Type u_1} {a : List α} {l : List (List α)}, List.join (a :: l) = a ++ List.join l",
  "offspring": [],
  "name": "List.join_cons"},
 {"type": "{ε : Type} → MonadFinally (EIO ε)",
  "offspring": [],
  "name": "instMonadFinallyEIO"},
 {"type": "∀ {α : Sort u_1} (a b : α), (if False then a else b) = b",
  "offspring": [],
  "name": "ite_false"},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} →\n    [inst : DecidableEq α] →\n      (r : α → α → Prop) →\n        (s : β → β → Prop) → [inst : DecidableRel r] → [inst : DecidableRel s] → DecidableRel (Prod.Lex r s)",
  "offspring": ["decidable_of_decidable_of_iff", "Prod.Lex.decidable.proof_1"],
  "name": "Prod.Lex.decidable"},
 {"type": "Lean.Expr → Lean.MetaM (Array Lean.Expr)",
  "offspring":
  ["ForIn.forIn",
   "ForInStep",
   "MProd",
   "Subarray",
   "Stream.next?",
   "ForInStep.done",
   "Array.push",
   "MProd.snd",
   "MProd.fst",
   "ToStream.toStream"],
  "name": "Tactic.NormCast.getSimpArgs"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<=_»"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → Membership α (Array α)",
  "offspring": ["Membership.mk", "Array.contains"],
  "name": "Array.instMembershipArray"},
 {"type": "{α : Type u_1} → (α → α → Bool) → Array α → ℕ → ℕ → Array α",
  "offspring": ["Array.insertionSort.swapLoop"],
  "name": "Array.insertionSort.traverse"},
 {"type": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Zero M₀",
  "offspring": [],
  "name": "MonoidWithZero.toZero"},
 {"type": "∀ {α : Type u_1} {l : List α}, l ≠ [] → 0 < List.length l",
  "offspring": ["Nat.pos_iff_ne_zero", "List.length_eq_zero"],
  "name": "List.length_pos_of_ne_nil"},
 {"type":
  "{α : Type u} → [inst : Preorder α] → [inst_1 : DecidableRel fun a a_1 => a ≤ a_1] → DecidableRel fun a a_1 => a < a_1",
  "offspring":
  ["decidableLt_of_decidableLe.proof_1",
   "lt_of_le_not_le",
   "decidableLt_of_decidableLe.proof_2"],
  "name": "decidableLt_of_decidableLe"},
 {"type": "∀ (x y : ℕ), x / y = if 0 < y ∧ y ≤ x then (x - y) / y + 1 else 0",
  "offspring":
  ["WellFounded.fix_eq", "Nat.sub_lt", "Nat.lt_of_lt_of_le", "WellFounded.fix"],
  "name": "Nat.div_eq"},
 {"type": "∀ {p : Prop}, p → p = True",
  "offspring": ["trivial"],
  "name": "eq_true"},
 {"type": "Type u → Type u", "offspring": [], "name": "ToBool"},
 {"type": "∀ {a b : ℤ}, a - b = 0 ↔ a = b",
  "offspring": ["Int.eq_of_sub_eq_zero", "Int.sub_eq_zero_of_eq"],
  "name": "Int.sub_eq_zero_iff_eq"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop} (x : Subtype p), p x.val",
  "offspring": ["Subtype.property"],
  "name": "Subtype.prop"},
 {"type": "{α : Type u} → [self : OfScientific α] → ℕ → Bool → ℕ → α",
  "offspring": [],
  "name": "OfScientific.ofScientific"},
 {"type": "{α : Type u_1} → {lt : α → α → Bool} → Array α → BinaryHeap α lt",
  "offspring": [],
  "name": "BinaryHeap.mk"},
 {"type": "(fun n => { val := ↑n }) 0 = (fun n => { val := ↑n }) 0",
  "offspring": [],
  "name": "UInt8.instSemiringUInt8.proof_11"},
 {"type": "LE Float",
  "offspring": ["LE.mk", "Float.le"],
  "name": "instLEFloat"},
 {"type": "(True ↔ False) ↔ False",
  "offspring": ["iff_false_intro", "trivial"],
  "name": "true_iff_false"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<&>_»"},
 {"type": "{α : Type u_1} → ℕ → Array α → ℕ → Array α",
  "offspring":
  ["WellFounded.fix",
   "WellFoundedRelation.rel",
   "instSizeOfNat",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Array.swap!",
   "Nat.pred_lt'"],
  "name": "Array.insertAtAux"},
 {"type":
  "{α : Sort u_1} →\n  {β : Sort u_2} →\n    {γ : Sort u_3} →\n      {r : α → β → Prop} →\n        {s : β → γ → Prop} →\n          {t : outParam (α → γ → Prop)} → (∀ {a : α} {b : β} {c : γ}, r a b → s b c → t a c) → Trans r s t",
  "offspring": [],
  "name": "Trans.mk"},
 {"type":
  "∀ (n m : Fin UInt64.size), ¬n = m → { val := n } = { val := m } → False",
  "offspring": [],
  "name": "UInt64.decEq.proof_2"},
 {"type": "∀ {α : Type u_1} {R : α → α → Prop} {a : α}, List.Chain R a []",
  "offspring": [],
  "name": "List.Chain.nil"},
 {"type": "∀ (m n : ℕ), Int.ofNat m * Int.ofNat n = Int.ofNat (m * n)",
  "offspring": [],
  "name": "Int.ofNat_mul_ofNat"},
 {"type":
  "{m : Type u → Type v} →\n  [inst : Monad m] → [inst : Alternative m] → {α : Type w} → {β : Type u} → (α → m β) → List α → m β",
  "offspring": ["Alternative.failure", "HOrElse.hOrElse"],
  "name": "List.firstM"},
 {"type": "UInt16 → UInt16 → Prop", "offspring": [], "name": "UInt16.le"},
 {"type": "0 ≠ 1", "offspring": ["sorryAx"], "name": "Int.zero_ne_one"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.«termSatisfiesBinderPred%__»"},
 {"type":
  "∀ {α : Type u_1} (a : Array α), WellFounded (invImage (fun a_1 => Array.size a - a_1) instWellFoundedRelation).1",
  "offspring": [],
  "name": "Array.indexOfAux.proof_1"},
 {"type":
  "∀ (x x_1 x_2 : UInt64), { val := (x * x_1 * x_2).1 } = { val := (x * (x_1 * x_2)).1 }",
  "offspring": ["UInt64.mk", "Semigroup.mul_assoc"],
  "name": "UInt64.instSemigroupUInt64.proof_1"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Bind m] {x : m α} {f g : α → m β},\n  (∀ (a : α), f a = g a) → x >>= f = x >>= g",
  "offspring": [],
  "name": "bind_congr"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HXor α β γ → HXor α β γ → Sort u_1",
  "offspring": [],
  "name": "HXor.noConfusionType"},
 {"type": "{α : Sort u} → α → α → Prop", "offspring": [], "name": "Ne"},
 {"type":
  "∀ {α : Sort u_1} {p q : α → Prop},\n  (∀ (x : α), p x ↔ q x) → ∀ {a1 : { x // p x }} {a2 : { x // q x }}, HEq a1 a2 ↔ a1.val = a2.val",
  "offspring": ["Iff.trans", "heq_iff_eq", "Subtype.ext_iff"],
  "name": "Subtype.heq_iff_coe_eq"},
 {"type": "ByteSlice → String",
  "offspring":
  ["Id.run", "ForIn.forIn", "ByteSlice", "Id.instMonadId", "UInt8.toChar"],
  "name": "ByteSlice.toString"},
 {"type": "∀ (n : ℕ) (x : ℤ), Int.ofNat (Nat.succ n) * x = x + Int.ofNat n * x",
  "offspring":
  ["Int.ofNat_succ", "Int.distrib_right", "Int.add_comm", "Int.one_mul"],
  "name": "Int.instCommRingInt.proof_7"},
 {"type":
  "{α : Type u} →\n  {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → (α → m β) → ℕ → ℕ → Array β → m (Array β)",
  "offspring": ["Array.get", "Array.push"],
  "name": "Array.sequenceMap.loop"},
 {"type": "∀ (a : USize), -a = { val := -a.val }",
  "offspring": [],
  "name": "USize.neg_def"},
 {"type": "∀ (n : UInt8), Nat.isValidChar ↑(UInt32.ofNat ↑n.val).val",
  "offspring": ["UInt8.toChar_aux", "Fin.isLt"],
  "name": "UInt8.toChar.proof_1"},
 {"type": "∀ {m n : ℕ}, m ≤ n → m ≠ n → m < n",
  "offspring": ["Nat.eq_or_lt_of_le"],
  "name": "Nat.lt_of_le_and_ne"},
 {"type":
  "∀ {m : Type u → Type v} [inst : Monad m] [self : LawfulMonad m] {α β γ : Type u} (x : m α) (f : α → m β) (g : β → m γ),\n  x >>= f >>= g = x >>= fun x => f x >>= g",
  "offspring": [],
  "name": "LawfulMonad.bind_assoc"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) {x x' : α} {y y' : β}, x = x' → y = y' → f x y = f x' y'",
  "offspring": [],
  "name": "congr_arg2"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] (a b : A), -a + (a + b) = b",
  "offspring": ["add_assoc", "add_left_neg", "zero_add"],
  "name": "neg_add_cancel_left"},
 {"type": "Sort u → System.FilePath → System.FilePath → Sort u",
  "offspring": [],
  "name": "System.FilePath.noConfusionType"},
 {"type": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "offspring": [],
  "name": "Iff.elim_right.proof_1"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_1} {γ : Sort u_3} {f : α → β} {g : β → α} {h : β → γ} {i : γ → β},\n  Function.LeftInverse f g → Function.LeftInverse h i → Function.LeftInverse (h ∘ f) (g ∘ i)",
  "offspring": [],
  "name": "Function.LeftInverse.comp"},
 {"type": "Subsingleton PUnit",
  "offspring": ["Subsingleton.intro", "PUnit.subsingleton"],
  "name": "instSubsingletonPUnit"},
 {"type": "{σ : Type u} → σ → DoResultBC σ",
  "offspring": [],
  "name": "DoResultBC.break"},
 {"type": "∀ {b c : Prop} {α : Sort u_1}, α → b ∧ c ↔ (α → b) ∧ (α → c)",
  "offspring": [],
  "name": "imp_and_distrib"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (Option α × β)",
  "offspring": ["List.map₂Right"],
  "name": "List.zipRight"},
 {"type": "{α : Type u_1} → [inst : Hashable α] → Hashable (List α)",
  "offspring": ["Hashable.mk", "List.foldl", "mixHash", "Hashable.hash"],
  "name": "instHashableList"},
 {"type": "∀ {α : Type u_1} (l : List α), l = l",
  "offspring": [],
  "name": "List.decidablePairwise.proof_1"},
 {"type": "{α : Type u} → EmptyCollection (Array α)",
  "offspring": ["EmptyCollection.mk", "Array.empty"],
  "name": "Array.instEmptyCollectionArray"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {x : α} {l₁ l₂ : List α}, x ∈ List.union l₁ l₂ ↔ x ∈ l₁ ∨ x ∈ l₂",
  "offspring":
  ["List.nil_union",
   "List.not_mem_nil",
   "false_or",
   "List.cons_union",
   "List.mem_insert_iff",
   "List.mem_cons",
   "or_assoc"],
  "name": "List.mem_union_iff"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk"],
  "name": "UInt32.sub"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] (a : A), a + -a = 0",
  "offspring": ["add_left_neg", "neg_neg"],
  "name": "add_right_neg"},
 {"type": "ByteArray → ByteArray → ByteArray",
  "offspring": ["ByteArray.copySlice", "ByteArray.size"],
  "name": "ByteArray.append"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_≥_»"},
 {"type": "∀ {a : ℕ}, 0 ∣ a → a = 0",
  "offspring": ["Exists.elim", "Nat.zero_mul"],
  "name": "Nat.eq_zero_of_zero_dvd"},
 {"type": "{α : Type} → String → IO α → IO α",
  "offspring": [],
  "name": "allocprof"},
 {"type": "∀ (a : ℤ), - -a = a", "offspring": [], "name": "Int.neg_neg"},
 {"type":
  "∀ {α : Type u_1} (x : α) {l₁ l₂ : List α}, l₁ ~ l₂ → x :: l₁ ~ x :: l₂",
  "offspring": [],
  "name": "List.Perm.cons"},
 {"type": "∀ {a : Prop} [inst : Decidable a], ¬a → a ↔ a",
  "offspring": [],
  "name": "Decidable.not_imp_self"},
 {"type":
  "∀ {v : Sat.Valuation} {f : Sat.Fmla} {p : Prop}, Sat.Fmla.reify v f p → ¬Sat.Valuation.satisfies_fmla v f → p",
  "offspring": [],
  "name": "Sat.Fmla.reify.prop"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {r : α → α → Prop} {s : (a : α) → β a → β a → Prop} (a : α) {b₁ b₂ : β a},\n  s a b₁ b₂ → PSigma.Lex r s { fst := a, snd := b₁ } { fst := a, snd := b₂ }",
  "offspring": [],
  "name": "PSigma.Lex.right"},
 {"type": "∀ (n m : ℕ), n + Nat.succ m = Nat.succ (n + m)",
  "offspring": [],
  "name": "Nat.add_succ"},
 {"type": "Nat.Linear.Expr → Nat.Linear.Expr → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.Expr.add"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HShiftLeft"},
 {"type": "{α : Type u_1} → [inst : Lean.ToFormat α] → List α → Lean.Format",
  "offspring": [],
  "name": "List.format"},
 {"type":
  "{ε σ α β : Type u} → EStateM ε σ α → (α → EStateM ε σ β) → EStateM ε σ β",
  "offspring": ["EStateM.Result.error"],
  "name": "EStateM.bind"},
 {"type":
  "{α : Type u} → (a : Array α) → (i : USize) → USize.toNat i < Array.size a → α",
  "offspring": ["Array.get", "USize.toNat"],
  "name": "Array.uget"},
 {"type":
  "∀ {α : Type u_1} [inst : PartialOrder α] (a b : α), ¬a ≤ b → a = b → False",
  "offspring": ["le_refl"],
  "name": "decidableEq_of_decidableLe.proof_2"},
 {"type": "∀ {α : Sort u₁}, Function.surjective id",
  "offspring": [],
  "name": "Function.surjective_id"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {arr : Array α} {f : α → β} {n : ℕ} {g : Fin n → β},\n  n = Array.size arr →\n    (∀ (i : ℕ) (h₁ : i < Array.size arr) (h₂ : i < n),\n        f (Array.get arr { val := i, isLt := h₁ }) = g { val := i, isLt := h₂ }) →\n      UFModel.Agrees arr f g",
  "offspring": [],
  "name": "UFModel.Agrees.mk'"},
 {"type":
  "{β : Type v} → (β → UInt8 → β) → β → (as : ByteArray) → optParam ℕ 0 → optParam ℕ (ByteArray.size as) → β",
  "offspring": ["Id.run", "ByteArray.foldlM", "Id.instMonadId"],
  "name": "ByteArray.foldl"},
 {"type":
  "{m : Type u → Type v} → [inst : Applicative m] → {α : Type w} → List α → (α → m PUnit) → m PUnit",
  "offspring": ["SeqRight.seqRight"],
  "name": "List.forA"},
 {"type": "0 < UInt8.size", "offspring": [], "name": "UInt8.size_positive"},
 {"type": "Semiring UInt8",
  "offspring":
  ["Semiring.mk",
   "UInt8.instSemiringUInt8.proof_13",
   "UInt8.instSemiringUInt8.proof_14",
   "UInt8.instSemiringUInt8.proof_15",
   "UInt8.instSemiringUInt8.proof_16",
   "Semigroup",
   "UInt8.instSemigroupUInt8",
   "AddCommSemigroup",
   "UInt8.instAddCommSemigroupUInt8"],
  "name": "UInt8.instSemiringUInt8"},
 {"type": "UInt16 → UInt16 → UInt16",
  "offspring": ["UInt16.mk"],
  "name": "UInt16.mul"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f g : α → β} {x : Option α},\n  (∀ (a : α), a ∈ x → f a = g a) → Option.map f x = Option.map g x",
  "offspring": ["Option.map_none'", "Option.map_some'", "Option.mem_def"],
  "name": "Option.map_congr"},
 {"type": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → MulZeroClass S₀",
  "offspring":
  ["MulZeroClass.mk",
   "SemigroupWithZero.zero_mul",
   "SemigroupWithZero.mul_zero"],
  "name": "SemigroupWithZero.toMulZeroClass"},
 {"type": "∀ (n : ℕ), n < UInt8.size → Nat.isValidChar ↑(UInt32.ofNat n).val",
  "offspring": ["UInt32.val_eq_of_lt", "Nat.lt_trans", "UInt8.size"],
  "name": "UInt8.toChar_aux"},
 {"type": "∀ {α : Type u_1} {R : α → α → Prop}, List.Pairwise R []",
  "offspring": [],
  "name": "List.Pairwise.nil"},
 {"type":
  "{α : Type u_1} →\n  (self : UnionFind α) → (x y : Fin (UnionFind.size self)) → (Array.get self.arr y).parent = ↑y → UnionFind α",
  "offspring":
  ["UFNode.rank",
   "UnionFind.mk",
   "Array.set",
   "UnionFind.arr",
   "UFNode.mk",
   "UFNode.value",
   "UnionFind.link.proof_1",
   "UnionFind.link.proof_3",
   "UnionFind.link.proof_2",
   "UFNode.parent",
   "Array.get"],
  "name": "UnionFind.link"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → {α : Type u} → ExceptT ε m α → m (Except ε α)",
  "offspring": [],
  "name": "ExceptT.run"},
 {"type":
  "{m : Type → Type v} → [inst : Monad m] → {α : Type u_1} → {β : Type} → (α → m β) → List α → m Unit",
  "offspring": ["SeqRight.seqRight"],
  "name": "List.mmap'"},
 {"type": "ByteArray → ℕ → List UInt8 → List UInt8",
  "offspring": [],
  "name": "ByteArray.toList.loop"},
 {"type": "{σ : Type u} → σ → PUnit",
  "offspring": [],
  "name": "EStateM.dummySave"},
 {"type": "Sat.Fmla → Sat.Fmla → Prop",
  "offspring": [],
  "name": "Sat.Fmla.subsumes"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} {f : α → β}, Option.map f none = none",
  "offspring": [],
  "name": "Option.map_none'"},
 {"type": "∀ {p q r : Prop}, implies p q → implies q r → implies p r",
  "offspring": [],
  "name": "implies.trans"},
 {"type":
  "ℕ → optParam Bool false → Lean.Elab.Tactic.TacticM (Lean.MVarId × List Lean.MVarId × List Lean.MVarId)",
  "offspring": ["GT.gt", "List.splitAt"],
  "name": "Mathlib.Tactic.splitGoalsAndGetNth"},
 {"type": "∀ {α : Type u_1} (a : α) (l : List α), l ⊆ a :: l",
  "offspring": ["List.Mem.tail"],
  "name": "List.subset_cons"},
 {"type": "∀ {a b : USize}, a.val = b.val → a = b",
  "offspring": ["USize.mk"],
  "name": "USize.eq_of_val_eq"},
 {"type":
  "∀ {α : Type u_1} (a : α) {n : ℕ} {l : List α}, n < List.length l → List.get? (List.set l n a) n = some a",
  "offspring":
  ["List.get?_set_eq",
   "Functor.map",
   "Option.instFunctorOption",
   "List.get?_eq_get"],
  "name": "List.get?_set_of_lt"},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      (f : (a : α) → motive (Quotient.mk s a)) →\n        (∀ (a b : α), a ≈ b → (_ : Quotient.mk s a = Quotient.mk s b) ▸ f a = f b) → (q : Quotient s) → motive q",
  "offspring": ["Quot.rec"],
  "name": "Quotient.rec"},
 {"type": "0 < UInt64.size", "offspring": [], "name": "UInt64.size_positive"},
 {"type": "{α : Type u✝} → Sort u → One α → One α → Sort u",
  "offspring": [],
  "name": "One.noConfusionType"},
 {"type":
  "∀ {α : Type u} (as : Array α) (start stop : ℕ) (h₁ : start ≤ stop) (h₂ : stop ≤ Array.size as) (as_1 : Array α)\n  (start_1 stop_1 : ℕ) (h₁_1 : start_1 ≤ stop_1) (h₂_1 : stop_1 ≤ Array.size as_1),\n  ({ as := as, start := start, stop := stop, h₁ := h₁, h₂ := h₂ } =\n      { as := as_1, start := start_1, stop := stop_1, h₁ := h₁_1, h₂ := h₂_1 }) =\n    (as = as_1 ∧ start = start_1 ∧ stop = stop_1)",
  "offspring": ["Subarray.mk"],
  "name": "Subarray.mk.injEq"},
 {"type": "∀ {n m : ℕ}, Nat.succ n < m → n < m",
  "offspring": ["Nat.le_of_succ_le"],
  "name": "Nat.lt_of_succ_lt"},
 {"type": "UInt8 → Char",
  "offspring": ["UInt8.toUInt32", "UInt8.toChar.proof_1"],
  "name": "UInt8.toChar"},
 {"type": "∀ (n m : ℕ), n * Nat.succ m = n * m + n",
  "offspring": [],
  "name": "Nat.mul_succ"},
 {"type": "∀ (a : UInt16), sizeOf a = UInt16.toNat a + 2",
  "offspring":
  ["UInt16.mk.sizeOf_spec",
   "Fin.sizeOf",
   "UInt16.size",
   "Nat.Linear.ExprCnstr.eq_true_of_isValid",
   "Nat.Linear.ExprCnstr.mk",
   "Nat.Linear.Expr.var"],
  "name": "UInt16.sizeOf"},
 {"type": "String → System.FilePath",
  "offspring": [],
  "name": "System.FilePath.mk"},
 {"type":
  "{m : Type u → Type v} → {n : Type u → Type w} → Sort u_1 → MonadFunctorT m n → MonadFunctorT m n → Sort u_1",
  "offspring": [],
  "name": "MonadFunctorT.noConfusionType"},
 {"type": "Add UInt16",
  "offspring": ["Add.mk", "UInt16.add"],
  "name": "instAddUInt16"},
 {"type": "ℤ → Float",
  "offspring": ["Float.ofNat", "Float.neg"],
  "name": "Float.ofInt"},
 {"type": "{α : Type u_1} → Array α → (α → α → Bool) → Array α",
  "offspring": [],
  "name": "Array.heapSort"},
 {"type": "{α : Type u_1} → ℕ → α → List α → List α",
  "offspring": ["List.repeat'"],
  "name": "List.leftpad"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HMod"},
 {"type":
  "Tactic.Ring.HornerExpr →\n  Lean.Expr × ℕ → Lean.Expr × ℕ → Tactic.Ring.HornerExpr → Tactic.Ring.RingM Tactic.Ring.HornerExpr",
  "offspring":
  ["Tactic.Ring.mkAppCS",
   "Tactic.Ring.HornerExpr.e",
   "Tactic.Ring.HornerExpr.xadd"],
  "name": "Tactic.Ring.HornerExpr.xadd'"},
 {"type": "sizeOf Mathlib.Tactic.Lint.LintVerbosity.medium = 1",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.medium.sizeOf_spec"},
 {"type": "ℕ → UInt16",
  "offspring": ["UInt16.mk", "Fin.ofNat"],
  "name": "UInt16.ofNat"},
 {"type":
  "{α : Type u} → {m : Type u → Type u_1} → [inst : Monad m] → Array α → ℕ → (α → m α) → m (Array α)",
  "offspring": ["Array.set", "Array.get"],
  "name": "Array.modifyM"},
 {"type": "@List.map = @List.mapTR",
  "offspring": ["List.mapTRAux_eq", "List.reverse_nil", "List.nil_append"],
  "name": "List.map_eq_mapTR"},
 {"type": "∀ (a : ℤ), Int.NonNeg a ∨ Int.NonNeg (-a)",
  "offspring": ["Int.NonNeg.mk"],
  "name": "Int.nonneg_or_nonneg_neg"},
 {"type": "∀ {α : Sort u_1}, ¬∃ a, False",
  "offspring": [],
  "name": "exists_false"},
 {"type": "Xor UInt16",
  "offspring": ["Xor.mk", "UInt16.xor"],
  "name": "instXorUInt16"},
 {"type": "∀ {x y : ℕ}, Nat.sub x y = x - y",
  "offspring": [],
  "name": "Nat.sub_eq"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HMod α β γ",
  "offspring": [],
  "name": "HMod.mk"},
 {"type":
  "{α : outParam (Type u)} → {γ : Type v} → (α → γ → Prop) → Membership α γ",
  "offspring": [],
  "name": "Membership.mk"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α}, List.disjoint l₁ l₂ ↔ List.disjoint l₂ l₁",
  "offspring": ["List.disjoint_symm"],
  "name": "List.disjoint_comm"},
 {"type": "∀ (x k n : ℕ), n * k ≤ x → (x - n * k) % n = x % n",
  "offspring": ["Nat.mul_zero", "Nat.sub_zero"],
  "name": "Nat.sub_mul_mod"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.Conv.convLHS"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (b : α → β),\n  a₁ = a₂ →\n    (let x := a₁;\n      b x) =\n      let x := a₂;\n      b x",
  "offspring": [],
  "name": "let_value_eq"},
 {"type": "{α β : Sort u} → α = β → α → β", "offspring": [], "name": "cast"},
 {"type": "∀ (a : PUnit), a = PUnit.unit",
  "offspring": ["PUnit.subsingleton"],
  "name": "PUnit.eq_punit"},
 {"type":
  "∀ (i : Nat.Linear.Var), sizeOf (Nat.Linear.Expr.var i) = 1 + sizeOf i",
  "offspring": ["Nat.Linear.Var", "instSizeOfNat"],
  "name": "Nat.Linear.Expr.var.sizeOf_spec"},
 {"type": "{α : Type u} → (α → α → α) → Prop",
  "offspring": [],
  "name": "right_cancelative"},
 {"type": "{α : Type u_1} → (lt : α → α → Bool) → Inhabited (BinaryHeap α lt)",
  "offspring": ["BinaryHeap.empty"],
  "name": "BinaryHeap.instInhabitedBinaryHeap"},
 {"type": "{α : Type u} → [self : Complement α] → α → α",
  "offspring": [],
  "name": "Complement.complement"},
 {"type": "(a b : USize) → Decidable (a = b)",
  "offspring": ["USize.decEq.proof_1", "USize.decEq.proof_2"],
  "name": "USize.decEq"},
 {"type": "∀ {m n : ℕ}, Int.ofNat m = Int.ofNat n → m = n",
  "offspring": ["Int.ofNat.inj"],
  "name": "Int.coe_nat_inj"},
 {"type": "Sort u → Prop", "offspring": [], "name": "Nonempty"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_∉_»"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y z : α}, r x y → r y z → r x z",
  "offspring": [],
  "name": "Equivalence.trans"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ max a b",
  "offspring":
  ["if_pos",
   "instDecidableLtToLTToPreorderToPartialOrder",
   "le_refl",
   "if_neg",
   "le_of_not_lt"],
  "name": "le_max_left"},
 {"type":
  "∀ (as : FloatArray) (i : ℕ), i + 1 ≤ FloatArray.size as → i ≤ FloatArray.size as",
  "offspring": ["Nat.le_of_lt", "Nat.lt_of_lt_of_le", "Nat.lt_succ_self"],
  "name": "FloatArray.forIn.loop.proof_2"},
 {"type":
  "{α : Type u} →\n  {β : Type v} →\n    {m : Type v → Type w} →\n      [inst : Monad m] →\n        (as : List α) → ((a : α) → a ∈ as → β → m (ForInStep β)) → (x : List α) → β → (∃ bs, bs ++ x = as) → m β",
  "offspring": [],
  "name": "List.forIn'.loop"},
 {"type": "ToString UInt64",
  "offspring": ["ToString.mk", "instToStringNat", "UInt64.toNat"],
  "name": "instToStringUInt64"},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α → List α",
  "offspring": ["List.elem", "List.erase"],
  "name": "List.diff"},
 {"type":
  "{α : Type u} → (as : Array α) → (α → Bool) → (i j : ℕ) → i + j = Array.size as → Option ℕ",
  "offspring": ["Array.findIdx?.loop.proof_1", "Array.get"],
  "name": "Array.findIdx?.loop"},
 {"type":
  "∀ {A : Type u} [self : SubNegMonoid A] (n : ℕ) (a : A),\n  SubNegMonoid.gsmul -[1+ n] a = -SubNegMonoid.gsmul (Int.ofNat (Nat.succ n)) a",
  "offspring": [],
  "name": "SubNegMonoid.gsmul_neg'"},
 {"type": "Type u → Type u", "offspring": [], "name": "NonUnitalSemiring"},
 {"type":
  "∀ {m : Type u → Type u_1} {β γ σ : Type u} [inst : Monad m] (f : σ → σ) (g : PUnit → StateCpsT σ m β) (s : σ)\n  (k : β → σ → m γ), StateCpsT.runK (modify f >>= g) s k = StateCpsT.runK (g PUnit.unit) (f s) k",
  "offspring": [],
  "name": "StateCpsT.runK_bind_modify"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {as : List α}, a ∈ as → List.card (List.insert a as) = List.card as",
  "offspring": ["Subsingleton.elim", "List.insert_of_mem"],
  "name": "List.card_insert_of_mem"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → m σ → (σ → m PUnit) → ({α : Type u} → (σ → α × σ) → m α) → MonadStateOf σ m",
  "offspring": [],
  "name": "MonadStateOf.mk"},
 {"type":
  "{ε : Type u} → {α : Type u_1} → {β : Type u_2} → Except ε α → (α → Except ε β) → Except ε β",
  "offspring": ["Except.error"],
  "name": "Except.bind"},
 {"type":
  "{α : Type u} → (a b : α) → (k : Unit → Bool) → (a = b → k () = true) → Bool",
  "offspring": [],
  "name": "withPtrEq"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), 1 * a = a",
  "offspring": ["Monoid.one_mul"],
  "name": "instCommSemiringFin.proof_8"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {l : List α}, ¬a ∈ l → List.insert a l = a :: l",
  "offspring":
  ["if_neg", "List.instDecidableMemListInstMembershipList", "List"],
  "name": "List.insert_of_not_mem"},
 {"type":
  "∀ {b c x y u v : Prop} [dec_b : Decidable b] [dec_c : Decidable c],\n  (b ↔ c) → (c → (x ↔ u)) → (¬c → (y ↔ v)) → ((if b then x else y) ↔ if c then u else v)",
  "offspring": ["not_iff_not_of_iff"],
  "name": "if_ctx_congr_prop"},
 {"type": "Sat.Valuation → Sat.Clause → Prop",
  "offspring": ["Sat.Literal"],
  "name": "Sat.Valuation.satisfies"},
 {"type": "BoundedRandom ℕ",
  "offspring":
  ["BoundedRandom.mk",
   "Random.rand",
   "Fin",
   "Subtype.mk",
   "Random.instBoundedRandomNatToPreorderToPartialOrderInstLinearOrderNat.proof_1"],
  "name":
  "Random.instBoundedRandomNatToPreorderToPartialOrderInstLinearOrderNat"},
 {"type": "Unit → Bool",
  "offspring": [],
  "name": "System.Platform.getIsWindows"},
 {"type":
  "∀ {k m n : ℕ}, Nat.coprime k m → Nat.coprime k n → Nat.coprime k (m * n)",
  "offspring": ["Nat.coprime.symm", "Nat.coprime.mul"],
  "name": "Nat.coprime.mul_right"},
 {"type": "∀ (n : ℕ), Nat.succ n = n + 1",
  "offspring": [],
  "name": "Nat.succ_eq_add_one"},
 {"type": "∀ {α : Sort u_1} (a : α), a = a ↔ True",
  "offspring": ["iff_true_intro"],
  "name": "eq_self_iff_true"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} [inst : Decidable (∃ x, ¬p x)] [inst : (x : α) → Decidable (p x)],\n  (¬∀ (x : α), p x) ↔ ∃ x, ¬p x",
  "offspring": ["not.decidable_imp_symm", "not_forall_of_exists_not"],
  "name": "Decidable.not_forall"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → AddGroupWithOne (Fin n)",
  "offspring":
  ["AddGroupWithOne.mk",
   "Fin.sub_def",
   "Fin.add_def",
   "instNegFin.proof_1",
   "Nat.add_mod_mod",
   "Fin.size_positive",
   "instAddGroupWithOneFin.proof_3",
   "instAddGroupWithOneFin.proof_4",
   "instAddGroupWithOneFin.proof_5",
   "add_comm",
   "Fin.eq_of_val_eq",
   "Nat.add_sub_cancel'",
   "Nat.le_of_lt",
   "Fin.isLt",
   "Nat.mod_self",
   "Fin.zero_def",
   "Fin.ofInt'",
   "instAddGroupWithOneFin.proof_6",
   "instAddGroupWithOneFin.proof_7",
   "AddMonoidWithOne"],
  "name": "instAddGroupWithOneFin"},
 {"type":
  "{σ : outParam (Type u)} → {m : Type u → Type v} → Sort u_1 → MonadState σ m → MonadState σ m → Sort u_1",
  "offspring": [],
  "name": "MonadState.noConfusionType"},
 {"type": "∀ {α β : Prop}, α → β → α", "offspring": [], "name": "imp_intro"},
 {"type": "{α : Type u_1} → List α → List α",
  "offspring": ["panicWithPosWithDecl"],
  "name": "List.tail!"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "stx!_"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {s : Type u} → {α : Type w} → (s → α → m s) → s → List α → m s",
  "offspring": [],
  "name": "List.foldlM"},
 {"type": "∀ {α : Type u_1} {β : Type u_2}, Function.bijective Prod.swap",
  "offspring": ["Prod.swap_injective", "Prod.swap_surjective"],
  "name": "Prod.swap_bijective"},
 {"type": "{α : Type u} → [self : Preorder α] → LE α",
  "offspring": [],
  "name": "Preorder.toLE"},
 {"type": "DecidableEq String",
  "offspring": [],
  "name": "instDecidableEqString"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.NormCast.termMod_cast_"},
 {"type":
  "∀ {α : Type u_1} (a b : α) (k : Unit → Decidable (a = b)),\n  withPtrEq a b (fun x => toBoolUsing (k ())) (_ : a = b → toBoolUsing (k ()) = true) = false → ¬a = b",
  "offspring": ["ofBoolUsing_eq_false"],
  "name": "withPtrEqDecEq.proof_3"},
 {"type":
  "{α : Sort u} → {β : α → Sort v} → (α → α → Prop) → ((a : α) → β a → β a → Prop) → PSigma β → PSigma β → Prop",
  "offspring": [],
  "name": "PSigma.Lex"},
 {"type": "Int.ofNat 1 = 1", "offspring": [], "name": "Int.ofNat_one"},
 {"type":
  "{α : Sort u} → {β : α → Sort v} → Sort u_1 → PSigma β → PSigma β → Sort u_1",
  "offspring": [],
  "name": "PSigma.noConfusionType"},
 {"type": "{α : Sort u} → {β : Sort v} → (α → β) → CoeTail α β",
  "offspring": [],
  "name": "CoeTail.mk"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {p : α → Prop} {q : β → Prop} {f : α → β} (h : ∀ (a : α), p a → q (f a)),\n  Function.injective f → Function.injective (Subtype.map f h)",
  "offspring":
  ["Subtype.coind_injective",
   "Function.injective.comp",
   "Subtype.coe_injective"],
  "name": "Subtype.map_injective"},
 {"type": "∀ (m n k : ℕ), Nat.gcd m n ∣ Nat.gcd (k * m) n",
  "offspring": ["Nat.gcd_dvd_gcd_of_dvd_left", "Nat.dvd_mul_left"],
  "name": "Nat.gcd_dvd_gcd_mul_left"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "introv"},
 {"type": "{α : Type u} → Bool → α → α → α", "offspring": [], "name": "cond"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (as bs : List α), List.equiv (List.union as bs) (as ++ bs)",
  "offspring": ["List.mem_union_iff", "List.mem_append"],
  "name": "List.union_equiv_append"},
 {"type":
  "{α : Type u} →\n  {m : Type → Type w} →\n    [inst : Monad m] → (α → m Bool) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m Bool",
  "offspring": ["Array.anyM.proof_1"],
  "name": "Array.anyM"},
 {"type":
  "∀ {p : Prop} [h : Decidable p] {h₁ : p → Sort u} {h₂ : ¬p → Sort u} [h₃ : ∀ (h : p), Subsingleton (h₁ h)]\n  [h₄ : ∀ (h : ¬p), Subsingleton (h₂ h)], Subsingleton (Decidable.casesOn h h₂ h₁)",
  "offspring": [],
  "name": "recSubsingleton"},
 {"type": "Mul Float",
  "offspring": ["Mul.mk", "Float.mul"],
  "name": "instMulFloat"},
 {"type":
  "∀ (lits : Array ℤ) (expr proof : Lean.Expr),\n  sizeOf { lits := lits, expr := expr, proof := proof } = 1 + sizeOf lits + sizeOf expr + sizeOf proof",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.Clause.mk.sizeOf_spec"},
 {"type": "{R : Type u} → [self : NonUnitalNonAssocSemiring R] → ℕ → R",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.natCast"},
 {"type":
  "∀ (as : ByteArray) (stop : ℕ), stop ≤ ByteArray.size as → ∀ (j : ℕ), j < stop → j < ByteArray.size as",
  "offspring": ["Nat.lt_of_lt_of_le"],
  "name": "ByteArray.foldlM.loop.proof_1"},
 {"type": "UInt8 → Bool",
  "offspring": ["or", "UInt8.isUpper", "UInt8.isLower"],
  "name": "UInt8.isAlpha"},
 {"type": "∀ (n m : ℕ), n - m = n - min n m",
  "offspring":
  ["GE.ge",
   "min_eq_right",
   "Nat.instLinearOrderNat",
   "Nat.sub_eq_zero_of_le",
   "le_of_not_ge",
   "min_eq_left",
   "Nat.sub_self"],
  "name": "Nat.sub_eq_sub_min"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] (a b : A), a + b + -b = a",
  "offspring": ["add_assoc", "add_right_neg", "add_zero"],
  "name": "add_neg_cancel_right"},
 {"type": "Lean.TagAttribute",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.mathlibLinterAttr"},
 {"type": "{α : Sort u} → {β : Sort v} → β → α ⊕' β",
  "offspring": [],
  "name": "PSum.inr"},
 {"type":
  "{α : Type u} → (α → α → Bool) → List α → List (List α) → List (List α)",
  "offspring": ["List.reverse"],
  "name": "List.groupByAux"},
 {"type": "{α : Type u} → List α → List α → List α",
  "offspring": [],
  "name": "List.reverseAux"},
 {"type":
  "{R : Type u} →\n  [toMul : Mul R] →\n    [toAdd : Add R] →\n      (∀ (a b c : R), a * (b + c) = a * b + a * c) → (∀ (a b c : R), (a + b) * c = a * c + b * c) → Distrib R",
  "offspring": [],
  "name": "Distrib.mk"},
 {"type":
  "{α : Type u} →\n  {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Subarray α → β → (α → β → m (ForInStep β)) → m β",
  "offspring": ["USize.ofNat", "Subarray.stop"],
  "name": "Subarray.forInUnsafe"},
 {"type": "∀ {a b : ℤ}, a < b + 1 → a ≤ b",
  "offspring": ["Int.le_of_add_le_add_right"],
  "name": "Int.le_of_lt_add_one"},
 {"type": "∀ {α : Sort u_1} (a : α), a ≠ a ↔ False",
  "offspring": ["not_iff_false_intro"],
  "name": "ne_self_iff_false"},
 {"type":
  "∀ {R : Type u_1} [inst : Distrib R] (a b c : R), a * (b + c) = a * b + a * c",
  "offspring": ["Distrib.left_distrib"],
  "name": "mul_add"},
 {"type": "∀ (p : Prop) [inst : Decidable p], p ∨ ¬p",
  "offspring": ["Decidable.byCases"],
  "name": "Decidable.em"},
 {"type": "Bool",
  "offspring": ["System.Platform.getIsOSX"],
  "name": "System.Platform.isOSX"},
 {"type": "∀ {α : Type u} (self : Subarray α), self.stop ≤ Array.size self.as",
  "offspring": [],
  "name": "Subarray.h₂"},
 {"type": "∀ {a b : Prop}, ¬a → ¬b → ¬(a ∨ b)",
  "offspring": [],
  "name": "not_or_intro"},
 {"type": "{n : ℕ} → Add (Fin n)",
  "offspring": ["Add.mk", "Fin.add"],
  "name": "Fin.instAddFin"},
 {"type": "BEq Substring",
  "offspring": ["BEq.mk", "Substring.beq"],
  "name": "Substring.hasBeq"},
 {"type":
  "∀ {α : Type u_1} {n : ℕ} (l : List α), List.length l = n + 1 → ∃ h t, l = h :: t",
  "offspring": ["Nat.succ_ne_zero"],
  "name": "List.exists_of_length_succ"},
 {"type": "String → String.Pos → String.Pos → Substring",
  "offspring": [],
  "name": "Substring.mk"},
 {"type": "∀ (a : ℤ) (n : ℕ), a < a + ↑(Nat.succ n)",
  "offspring": ["Int.le.intro", "Int.add_comm", "Int.add_left_comm"],
  "name": "Int.lt_add_succ"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} {arr arr_1 : Array α}, { arr := arr } = { arr := arr_1 } → arr = arr_1",
  "offspring": [],
  "name": "BinaryHeap.mk.inj"},
 {"type": "Int.sign (-1) = -1", "offspring": [], "name": "Int.sign_neg_one"},
 {"type":
  "∀ {α : Type u_1} {l l₁ l₂ : List α}, List.disjoint (l₁ ++ l₂) l → List.disjoint l₂ l",
  "offspring": ["List.disjoint_append_left"],
  "name": "List.disjoint_of_disjoint_append_left_right"},
 {"type": "Bool → Nat.Linear.Expr → Nat.Linear.Expr → Nat.Linear.ExprCnstr",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.mk"},
 {"type": "Nonempty (Fin UInt8.size)",
  "offspring": ["instNonempty", "UInt8.instInhabitedFinSize"],
  "name": "UInt8.instRingUInt8.proof_2"},
 {"type": "{α : Type u} → Sort u_1 → OrElse α → OrElse α → Sort u_1",
  "offspring": [],
  "name": "OrElse.noConfusionType"},
 {"type": "Lean.Expr → Lean.Level → Lean.Expr → Tactic.Ring.Cache",
  "offspring": [],
  "name": "Tactic.Ring.Cache.mk"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Tactic.LibrarySearch.librarySearch!"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (as : FloatArray) → (Float → β → m (ForInStep β)) → (i : ℕ) → i ≤ FloatArray.size as → β → m β",
  "offspring": [],
  "name": "FloatArray.forIn.loop"},
 {"type": "ℤ → Prop", "offspring": [], "name": "Int.NonNeg"},
 {"type":
  "(a : ByteArray) → (i : USize) → USize.toNat i < ByteArray.size a → UInt8",
  "offspring": ["Array.uget"],
  "name": "ByteArray.uget"},
 {"type": "HMod UInt32 ℕ UInt32",
  "offspring": ["HMod.mk", "UInt32.modn"],
  "name": "instHModUInt32Nat"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a <+ a_1 → Prop}, List.sublist.below (_ : [] <+ [])",
  "offspring": [],
  "name": "List.sublist.below.slnil"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a : α) (n : ℕ) (b c : α), a ^ n = b → b * a = c → a ^ (n + 1) = c",
  "offspring": ["pow_succ"],
  "name": "Tactic.Ring.pow_succ_eq"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l : List α}, a ∈ l → ∃ n, List.get? l n = some a",
  "offspring": ["List.get?_eq_get", "List.get", "List.get_of_mem"],
  "name": "List.get?_of_mem"},
 {"type": "{R : Type u} → [self : CommRing R] → CommSemiring R",
  "offspring": ["CommSemiring.mk", "CommRing.mul_comm"],
  "name": "CommRing.toCommSemiring"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk"],
  "name": "USize.add"},
 {"type": "Lean.Environment → Lean.Environment → Lean.CoreM Lean.MessageData",
  "offspring":
  ["ForIn.forIn",
   "ForInStep",
   "Array",
   "Id.run",
   "Id.instMonadId",
   "Prod",
   "Array.push",
   "Mathlib.WhatsNew.diffExtension",
   "Array.isEmpty",
   "Array.toList"],
  "name": "Mathlib.WhatsNew.whatsNew"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} [inst : SizeOf α] [inst_1 : SizeOf β] (val : α), sizeOf (PSum.inl val) = 1 + sizeOf val",
  "offspring": [],
  "name": "PSum.inl.sizeOf_spec"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) {p q : α × β},\n  Prod.Lex r s p q ↔ r p.fst q.fst ∨ p.fst = q.fst ∧ s p.snd q.snd",
  "offspring":
  ["true_or", "and_self", "or_true", "Prod.Lex.left", "Prod.Lex.right"],
  "name": "Prod.lex_def"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → BEq α",
  "offspring": ["BEq.mk", "Decidable.decide"],
  "name": "instBEq"},
 {"type": "∀ {α : Type u_1} {a b : α} {n : ℕ}, b ∈ List.repeat' a n → b = a",
  "offspring": ["List.mem_repeat'"],
  "name": "List.eq_of_mem_repeat'"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} {a : α}, (∀ (x : α), x ∈ [a] → p x) ↔ p a",
  "offspring": ["List.mem_singleton", "forall_eq", "Iff.rfl"],
  "name": "List.forall_mem_singleton"},
 {"type": "Ring UInt16",
  "offspring":
  ["Ring.mk",
   "UInt16.instSemiringUInt16",
   "UInt16.instNegUInt16",
   "instSubUInt16",
   "UInt16.instRingUInt16.proof_1",
   "UInt16.mk",
   "Ring.gsmul",
   "UInt16.instRingUInt16.proof_3",
   "UInt16.instRingUInt16.proof_4",
   "UInt16.instRingUInt16.proof_5",
   "UInt16.instRingUInt16.proof_6",
   "Int.cast",
   "UInt16.instRingUInt16.proof_7",
   "UInt16.instRingUInt16.proof_8"],
  "name": "UInt16.instRingUInt16"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a : α), max a a = a",
  "offspring": ["ite_self"],
  "name": "max_self"},
 {"type":
  "∀ {α : Sort u} {α' : Sort w} [inst : DecidableEq α] [inst_1 : DecidableEq α'] {β : Sort u_1} (g : α' → β) {f : α → α'},\n  Function.injective f → ∀ (i : α) (a : β), Function.update g (f i) a ∘ f = Function.update (g ∘ f) i a",
  "offspring": ["Function.update_comp_eq_of_injective'"],
  "name": "Function.update_comp_eq_of_injective"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m], LawfulMonad (ExceptT ε m)",
  "offspring":
  ["LawfulMonad.mk",
   "ExceptT.bind_pure_comp",
   "ExceptT.ext",
   "ExceptT.run_bind",
   "ExceptT.run_pure",
   "ExceptT.run",
   "Except.error",
   "LawfulMonad.pure_bind",
   "Except.ok",
   "LawfulMonad.bind_assoc",
   "bind_congr"],
  "name": "ExceptT.instLawfulMonadExceptTInstMonadExceptT.proof_1"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (α → List α → β) → List α → List β",
  "offspring": ["List.mapWithPrefixSuffix"],
  "name": "List.mapWithComplement"},
 {"type":
  "∀ (s1 s2 s1_1 s2_1 : ℕ), ({ s1 := s1, s2 := s2 } = { s1 := s1_1, s2 := s2_1 }) = (s1 = s1_1 ∧ s2 = s2_1)",
  "offspring": ["StdGen", "StdGen.mk"],
  "name": "StdGen.mk.injEq"},
 {"type":
  "∀ {A : Type u} [inst : AddMonoid A] [inst_1 : IsAddLeftCancel A] {a b : A}, a + b = a ↔ b = 0",
  "offspring": ["add_left_cancel_iff", "add_zero", "Iff.rfl"],
  "name": "add_right_eq_self"},
 {"type": "UInt32 → Prop",
  "offspring": ["instLTUInt32"],
  "name": "isValidChar"},
 {"type": "∀ {a b : Prop}, a = b → (a ↔ b)",
  "offspring": ["Iff.rfl"],
  "name": "Eq.to_iff"},
 {"type":
  "(f : Type u → Type v) → [inst : Functor f] → [inst : LawfulFunctor f] → {α β : Type u} → α ≃ β → f α ≃ f β",
  "offspring":
  ["Equiv.mk",
   "Functor.map",
   "Equiv.toFun",
   "Equiv.symm",
   "Functor.map_equiv.proof_1",
   "Functor.map_equiv.proof_2"],
  "name": "Functor.map_equiv"},
 {"type": "LawfulBEq String",
  "offspring": ["instLawfulBEqStringInstBEqInstDecidableEqString.proof_1"],
  "name": "instLawfulBEqStringInstBEqInstDecidableEqString"},
 {"type": "(A : Type u) → [inst : Add A] → Type",
  "offspring": [],
  "name": "IsAddRightCancel"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → MonadWithReaderOf ρ (ReaderT ρ m)",
  "offspring": ["MonadWithReaderOf.mk"],
  "name": "instMonadWithReaderOfReaderT"},
 {"type": "∀ {α : Type u_1} {a y : α} {l : List α}, a ≠ y → a ∈ y :: l → a ∈ l",
  "offspring": ["Or.elim", "List.eq_or_mem_of_mem_cons"],
  "name": "List.mem_of_ne_of_mem"},
 {"type": "Nat.Linear.Var → Nat.Linear.Expr",
  "offspring": [],
  "name": "Nat.Linear.Expr.var"},
 {"type": "0 < UInt8.size",
  "offspring": [],
  "name": "instInhabitedUInt8.proof_1"},
 {"type": "List Float → FloatArray",
  "offspring": [],
  "name": "List.toFloatArray"},
 {"type": "ByteArray → ℕ", "offspring": [], "name": "ByteArray.size"},
 {"type": "∀ (x y : ℕ), min (Nat.succ x) (Nat.succ y) = Nat.succ (min x y)",
  "offspring": [],
  "name": "Nat.min_succ_succ"},
 {"type": "{α : Type u_1} → (α → α → Prop) → Option α → Option α → Prop",
  "offspring": [],
  "name": "Option.lt"},
 {"type": "∀ {a : Prop}, HEq a True → a",
  "offspring": [],
  "name": "of_heq_true"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a b c : Fin n), (a + b) * c = a * c + b * c",
  "offspring":
  ["CommSemigroup.mul_comm",
   "Fin.eq_of_val_eq",
   "Fin.add_def",
   "Fin.mul_def",
   "Fin.size_positive",
   "Nat.add_mod_mod",
   "Nat.mod_add_mod",
   "Nat.mul_mod",
   "Nat.mod_eq_of_lt",
   "Fin.isLt",
   "Distrib.left_distrib"],
  "name": "instCommSemiringFin.proof_2"},
 {"type": "∀ {a b : ℤ} (n : ℕ), b - a = ↑n → a ≤ b",
  "offspring": ["Int.le_def", "Int.NonNeg.mk"],
  "name": "Int.le.intro_sub"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} →\n    [inst : Monad m] → (β → UInt8 → m β) → (as : ByteArray) → (stop : ℕ) → stop ≤ ByteArray.size as → ℕ → ℕ → β → m β",
  "offspring": ["ByteArray.get", "ByteArray.foldlM.loop.proof_1"],
  "name": "ByteArray.foldlM.loop"},
 {"type": "∀ {a b : ℤ}, a ≤ b → ∀ (c : ℤ), c - b ≤ c - a",
  "offspring": ["Int.add_le_add_left", "Int.neg_le_neg"],
  "name": "Int.sub_le_sub_left"},
 {"type": "∀ {A : Type u} [self : SubNegMonoid A] (a b : A), a - b = a + -b",
  "offspring": [],
  "name": "SubNegMonoid.sub_eq_add_neg"},
 {"type": "∀ {n : ℕ} (a : Fin n), (n - ↑a) % n < n",
  "offspring": ["lt_of_le_of_lt", "Nat.zero_le", "Fin.isLt"],
  "name": "instNegFin.proof_1"},
 {"type": "{α : Type u} → [inst : Lean.ToFormat α] → Option α → Lean.Format",
  "offspring": [],
  "name": "Option.format"},
 {"type":
  "(Type u₁ → Type u₂) → Type u → outParam (Type v) → Type (max (max (max u (u₁ + 1)) u₂) v)",
  "offspring": [],
  "name": "ForIn"},
 {"type":
  "∀ {m : Type → Type} {ω σ : Type} [inst : Monad m] [inst_1 : LawfulMonad m], LawfulMonad (ReaderT (ST.Ref ω σ) m)",
  "offspring": [],
  "name": "instLawfulMonadStateRefT'InstMonadStateRefT'.proof_1"},
 {"type": "∀ {x y : ℕ}, Nat.lt x y = (x < y)",
  "offspring": [],
  "name": "Nat.lt_eq"},
 {"type": "{α : Type s} → ulift α → α", "offspring": [], "name": "ulift.down"},
 {"type": "ℕ → List ℕ", "offspring": [], "name": "List.iota"},
 {"type": "Bool", "offspring": [], "name": "Bool.true"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (xs : List α) (ys : List β) (x : α) (y : β),\n  (x, y) ∈ List.product xs ys ↔ x ∈ xs ∧ y ∈ ys",
  "offspring":
  ["List.mem_bind",
   "List.mem_map",
   "Prod.mk.injEq",
   "exists_eq_right_right'",
   "and_imp"],
  "name": "List.product_spec"},
 {"type": "Type u_1 → Option.toList none = []",
  "offspring": [],
  "name": "Option.to_list_none"},
 {"type": "{α : Type u} → Array α → Std.PersistentArray α",
  "offspring": ["Array.toPersistentArray"],
  "name": "Array.toPArray"},
 {"type": "∀ (a b : UInt32), a + b = { val := a.val + b.val }",
  "offspring": [],
  "name": "UInt32.add_def"},
 {"type":
  "∀ {σ : Type u_1} {m : Type u_1 → Type u_2}, LawfulMonad (ExceptCpsT σ m)",
  "offspring":
  ["ExceptCpsT.instLawfulMonadExceptCpsTInstMonadExceptCpsT.proof_1"],
  "name": "ExceptCpsT.instLawfulMonadExceptCpsTInstMonadExceptCpsT"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : DecidableEq α] → [inst : DecidableEq β] → DecidableEq (α × β)",
  "offspring":
  ["decEq",
   "instDecidableEqProd.proof_1",
   "instDecidableEqProd.proof_2",
   "instDecidableEqProd.proof_3"],
  "name": "instDecidableEqProd"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Applicative m] → List α → (ℕ → α → m β) → m (List β)",
  "offspring": [],
  "name": "List.mapIdxM"},
 {"type":
  "{P : Sort u} →\n  {x y : Mathlib.Tactic.Lint.LintVerbosity} → x = y → Mathlib.Tactic.Lint.LintVerbosity.noConfusionType P x y",
  "offspring": ["noConfusionEnum"],
  "name": "Mathlib.Tactic.Lint.LintVerbosity.noConfusion"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {as bs : List α}, List.equiv as bs → List.card as = List.card bs",
  "offspring":
  ["Nat.le_antisymm",
   "List.card_subset_le",
   "List.equiv_iff_subset_and_subset"],
  "name": "List.card_eq_of_equiv"},
 {"type": "{α : Type u_1} → Array α → ℕ → α → Array α",
  "offspring":
  ["GT.gt", "panicWithPosWithDecl", "Array.insertAtAux", "Array.push"],
  "name": "Array.insertAt"},
 {"type": "∀ (a : UInt8), { val := Ring.gsmul 0 a.val } = { val := 0.1 }",
  "offspring": ["SubNegMonoid.gsmul_zero'"],
  "name": "UInt8.instRingUInt8.proof_3"},
 {"type":
  "∀ {α : Type u} {β : Type v} {val val_1 : β}, Sum.inr val = Sum.inr val_1 → val = val_1",
  "offspring": [],
  "name": "Sum.inr.inj"},
 {"type":
  "∀ {α : Type u_1} (a b : α) (k : Unit → Decidable (a = b)), a = b → toBoolUsing (k ()) = true",
  "offspring": ["toBoolUsing_eq_true"],
  "name": "withPtrEqDecEq.proof_1"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "termWithout_expected_type_"},
 {"type":
  "∀ (p : ℕ → Prop) [inst : DecidablePred p] (H : ∃ n, p n), p (Nat.find p H)",
  "offspring": ["Subtype.property"],
  "name": "Nat.find_spec"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {p : β → Prop} → {f : α → β} → [inst : DecidablePred p] → DecidablePred (p ∘ f)",
  "offspring": [],
  "name": "instDecidablePredCompProp"},
 {"type": "BoundedRandom ℤ",
  "offspring":
  ["BoundedRandom.mk",
   "Random.randBound",
   "Random.instBoundedRandomNatToPreorderToPartialOrderInstLinearOrderNat",
   "Int.natAbs",
   "Random.instBoundedRandomIntToPreorderToPartialOrderInstLinearOrderInt.proof_1",
   "RandG",
   "Subtype",
   "Subtype.mk",
   "Random.instBoundedRandomIntToPreorderToPartialOrderInstLinearOrderInt.proof_2"],
  "name":
  "Random.instBoundedRandomIntToPreorderToPartialOrderInstLinearOrderInt"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadState σ m] → {α : Type u} → (σ → α × σ) → m α",
  "offspring": [],
  "name": "MonadState.modifyGet"},
 {"type":
  "∀ {arr : ByteArray} {off : ℕ} {arr_1 : ByteArray} {off_1 : ℕ},\n  { arr := arr, off := off } = { arr := arr_1, off := off_1 } → arr = arr_1 ∧ off = off_1",
  "offspring": [],
  "name": "ByteSliceT.mk.inj"},
 {"type": "{α : Type u_1} → ToStream (List α) (List α)",
  "offspring": ["ToStream.mk"],
  "name": "instToStreamList"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), min a b = min b a",
  "offspring": ["eq_min", "min_le_right", "min_le_left", "le_min"],
  "name": "min_comm"},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} →\n    {motive : Quot r → Sort v} →\n      (q : Quot r) → (f : (a : α) → motive (Quot.mk r a)) → (∀ (a b : α), r a b → HEq (f a) (f b)) → motive q",
  "offspring": ["Quot.recOn", "Quot.hrecOn.proof_1"],
  "name": "Quot.hrecOn"},
 {"type":
  "{α : Type u_1} → {motive : (a a_1 : List α) → a <+ a_1 → Prop} → {a a_1 : List α} → a <+ a_1 → Prop",
  "offspring": [],
  "name": "List.sublist.below"},
 {"type": "Lean.PrettyPrinter.Delaborator.Delab",
  "offspring":
  ["Tactic.NormCast.coeDelaborator",
   "Tactic.NormCast.CoeFnInfo.mk",
   "Tactic.NormCast.CoeFnType.coe"],
  "name": "Fin.val.delaborator"},
 {"type":
  "∀ {m : Type u → Type v} [inst : Monad m] [self : LawfulMonad m], LawfulApplicative m",
  "offspring": [],
  "name": "LawfulMonad.toLawfulApplicative"},
 {"type":
  "∀ (p : ℕ → Prop) (m : ℕ), (∀ (n : ℕ), n < m → ¬p n) → ¬p m → ∀ (n : ℕ), n ≤ m → ¬p n",
  "offspring": ["Or.elim", "lt_or_eq_of_le"],
  "name": "Nat.find_x.proof_2"},
 {"type": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "offspring": [],
  "name": "AddGroupWithOne.toAddMonoidWithOne"},
 {"type": "ReprAtom UInt8",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomUInt8"},
 {"type": "CommRing ℤ",
  "offspring": ["CommRing.mk", "Int.mul_comm"],
  "name": "Int.instCommRingInt"},
 {"type": "{α : Type u} → Array α → Bool",
  "offspring": ["Decidable.decide"],
  "name": "Array.isEmpty"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (p : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote ctx (Nat.Linear.Poly.fuse p) = Nat.Linear.Poly.denote ctx p",
  "offspring": [],
  "name": "Nat.Linear.Poly.denote_fuse"},
 {"type": "{α : Type u_1} → ℕ → List α → α → List α",
  "offspring": ["List.headD", "List.tail"],
  "name": "List.takeD"},
 {"type": "0 < 1", "offspring": ["Nat.zero_lt_one"], "name": "Nat.one_pos"},
 {"type": "Type u → Type u",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring"},
 {"type": "{α : Type u} → ℕ → Array α",
  "offspring": ["Array.mk"],
  "name": "Array.mkEmpty"},
 {"type": "∀ {p : Prop} [φ : Decidable p], (¬p → False) → p",
  "offspring": ["Decidable.byContradiction"],
  "name": "Decidable.by_contradiction"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} [inst : Monad m] [inst_1 : LawfulMonad m] {x : m PUnit},\n  (do\n      x\n      pure PUnit.unit) =\n    x",
  "offspring": ["bind_pure"],
  "name": "bind_pure_unit"},
 {"type": "∀ (a a_1 : USize), a + a_1 = a_1 + a",
  "offspring": ["USize.add_def", "add_comm", "USize.mk"],
  "name": "USize.instSemiringUSize.proof_6"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "tacticDecreasing_tactic"},
 {"type": "(ℕ → Bool) → ℕ → ℕ → Bool",
  "offspring": ["or"],
  "name": "Nat.anyAux"},
 {"type":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] (l : List α), List.erasep p l ⊆ l",
  "offspring":
  ["List.exists_or_eq_self_of_erasep",
   "List.subset.refl",
   "List.mem_append",
   "List.mem_cons_of_mem"],
  "name": "List.erasep_subset"},
 {"type": "{α : Type u_1} → OrElse (Option α)",
  "offspring": ["OrElse.mk", "Option.orElse"],
  "name": "Option.instOrElseOption"},
 {"type":
  "∀ {m n : ℕ}, 0 < Nat.gcd m n → ∃ g m' n', 0 < g ∧ Nat.coprime m' n' ∧ m = m' * g ∧ n = n' * g",
  "offspring": ["Nat.exists_coprime"],
  "name": "Nat.exists_coprime'"},
 {"type":
  "{α : Type u_1} → (a : Array α) → Fin (Array.size a) → { r // Array.size r = Array.size a - 1 }",
  "offspring": ["Array.eraseIdxSzAux", "Array.eraseIdx'.proof_1"],
  "name": "Array.eraseIdx'"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term∃!_,_»"},
 {"type": "{G₀ : Type u} → [self : GroupWithZero G₀] → Zero G₀",
  "offspring": [],
  "name": "GroupWithZero.toZero"},
 {"type":
  "∀ {α : Sort u} {b c : Prop} [dec_b : Decidable b] [dec_c : Decidable c] {x : b → α} {u : c → α} {y : ¬b → α}\n  {v : ¬c → α}, (b ↔ c) → (∀ (h : c), x (_ : b) = u h) → (∀ (h : ¬c), y (_ : ¬b) = v h) → dite b x y = dite c u v",
  "offspring": ["not_iff_not_of_iff"],
  "name": "dif_ctx_congr"},
 {"type": "∀ {a b c d : ℤ}, a ≤ c → b ≤ d → 0 ≤ b → 0 ≤ c → a * b ≤ c * d",
  "offspring":
  ["Trans.trans",
   "Int.mul_le_mul_of_nonneg_right",
   "Int.mul_le_mul_of_nonneg_left"],
  "name": "Int.mul_le_mul"},
 {"type": "{α : Type u} → {β : Type v} → [self : Pow α β] → α → β → α",
  "offspring": [],
  "name": "Pow.pow"},
 {"type": "Type u → Type u", "offspring": [], "name": "Sub"},
 {"type":
  "{ε : Type u} → {m : Type v → Type w} → [self : MonadExceptOf ε m] → {α : Type v} → m α → (ε → m α) → m α",
  "offspring": [],
  "name": "MonadExceptOf.tryCatch"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {f : α → β} (hf : Function.surjective f), Function.RightInverse (Function.surj_inv hf) f",
  "offspring": ["Function.surj_inv_eq"],
  "name": "Function.RightInverse_surj_inv"},
 {"type": "{α : Type u} → (α → Bool) → ToBool α",
  "offspring": [],
  "name": "ToBool.mk"},
 {"type":
  "∀ {α : Type u_1} {s₁ s₂ t₁ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → List.length s₁ = List.length s₂ → s₁ = s₂ ∧ t₁ = t₂",
  "offspring": ["List.eq_nil_of_length_eq_zero", "Nat.succ.inj"],
  "name": "List.append_inj"},
 {"type": "∀ {a b : Prop}, (¬a → b) → ¬b → a",
  "offspring": ["Not.decidable_imp_symm"],
  "name": "Not.imp_symm"},
 {"type": "{α : Type u} → [self : LT α] → α → α → Prop",
  "offspring": [],
  "name": "LT.lt"},
 {"type": "∀ {m : ℕ} (n : ℕ), 0 < n → Nat.gcd m n ≤ n",
  "offspring": ["Nat.le_of_dvd", "Nat.gcd_dvd_right"],
  "name": "Nat.gcd_le_right"},
 {"type": "(!false) = true", "offspring": [], "name": "Bool.not_false"},
 {"type": "{α : Sort u} → [inst : SizeOf α] → WellFoundedRelation α",
  "offspring": ["measure"],
  "name": "sizeOfWFRel"},
 {"type": "∀ (α : Sort u), (α → True) = True",
  "offspring": ["trivial", "True.intro"],
  "name": "implies_true"},
 {"type": "∀ (a : ℤ), Int.sign a * Int.ofNat (Int.natAbs a) = a",
  "offspring": ["Int.one_mul", "Int.neg_eq_neg_one_mul"],
  "name": "Int.sign_mul_natAbs"},
 {"type":
  "∀ {k m : ℕ} (n : ℕ), Nat.coprime k m → Nat.gcd m (n * k) = Nat.gcd m n",
  "offspring": ["Nat.coprime.gcd_mul_left_cancel_right"],
  "name": "Nat.coprime.gcd_mul_right_cancel_right"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} (q : Quot r), ∃ a, Quot.mk r a = q",
  "offspring": ["Quot.inductionOn"],
  "name": "Quot.exists_rep"},
 {"type": "ℕ → WellFoundedRelation ℕ",
  "offspring": ["WellFoundedRelation.mk", "Nat.Up", "Nat.Up.WF"],
  "name": "Nat.upRel"},
 {"type": "Inhabited ℤ", "offspring": [], "name": "Int.instInhabitedInt"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.«tacticUse_,,»"},
 {"type": "∀ (a : UInt64), { val := a.val } = a",
  "offspring": ["UInt64.size", "UInt64.mk"],
  "name": "UInt64.mk_val_eq"},
 {"type": "Mathlib.Tactic.Sat.LClause → ℕ",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LClause.depth"},
 {"type": "∀ (p : Prop), p ∨ ¬p", "offspring": [], "name": "Classical.em"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α : Type u_1} [inst : Monad m] (x : m α), monadLift x = x",
  "offspring": [],
  "name": "monadLift_self"},
 {"type": "{A : Type u} → [self : AddMonoid A] → AddSemigroup A",
  "offspring": [],
  "name": "AddMonoid.toAddSemigroup"},
 {"type": "∀ {a b c : Prop}, (a ∨ b) ∨ c ↔ a ∨ b ∨ c",
  "offspring": ["Or.imp_right", "Or.imp_left"],
  "name": "Or.assoc"},
 {"type": "∀ {a b : ℤ}, 0 ≤ a → 0 < b → 0 < a + b",
  "offspring": ["Int.add_lt_add_of_le_of_lt", "Int.zero_add"],
  "name": "Int.add_pos_of_nonneg_of_pos"},
 {"type": "{α : Type u_1} → [inst : OrElse α] → HOrElse α α α",
  "offspring": ["HOrElse.mk", "OrElse.orElse"],
  "name": "instHOrElse"},
 {"type": "{α : Type u_1} → [inst : Repr α] → Repr (Id α)",
  "offspring": [],
  "name": "instReprId"},
 {"type":
  "{motive : ℕ → ℕ → Sort u} →\n  (x y : ℕ) →\n    ((x y : ℕ) → 0 < y ∧ y ≤ x → motive (x - y) y → motive x y) →\n      ((x y : ℕ) → ¬(0 < y ∧ y ≤ x) → motive x y) → motive x y",
  "offspring": ["Nat.div.inductionOn"],
  "name": "Nat.mod.inductionOn"},
 {"type": "∀ {a b : ℤ}, a ≤ 0 → b < 0 → a + b < 0",
  "offspring": ["Int.add_lt_add_of_le_of_lt", "Int.zero_add"],
  "name": "Int.add_neg_of_nonpos_of_neg"},
 {"type": "{α : Type u_1} → {β : Type u_2} → Array (α × β) → Array α × Array β",
  "offspring": ["Array.foldl", "Array.push"],
  "name": "Array.unzip"},
 {"type": "MonadFinally BaseIO",
  "offspring": [],
  "name": "instMonadFinallyBaseIO"},
 {"type": "{α : Sort u₁} → {β : Sort u₂} → (β → α) → (α → β) → Prop",
  "offspring": [],
  "name": "Function.LeftInverse"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≤ b → min a b = a",
  "offspring": ["eq_min", "le_refl"],
  "name": "min_eq_left"},
 {"type": "(f : Type u → Type v) → [inst : Functor f] → Prop",
  "offspring": [],
  "name": "LawfulFunctor"},
 {"type": "Type u → Type u", "offspring": [], "name": "DivInvMonoid"},
 {"type": "{α : Type u_1} → List (Option α) → List α → List α",
  "offspring": ["List.reduceOption"],
  "name": "List.fillNones"},
 {"type": "{α : Type u_1} → (α → α → Prop) → α → List α → Prop",
  "offspring": [],
  "name": "List.Chain"},
 {"type":
  "{α : Sort u_1} → {β : α → Type u_2} → ((x : α) → β x) → (p : α → Prop) → (x : Subtype p) → β x.val",
  "offspring": [],
  "name": "Subtype.restrict"},
 {"type": "ByteArray → ℕ → ByteSliceT",
  "offspring": [],
  "name": "ByteSliceT.mk"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → List α → List ℕ",
  "offspring": ["List.foldrIdx"],
  "name": "List.findIdxs"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Monad m] (x : m α) (f : α → ExceptCpsT β m β),\n  ExceptCpsT.runCatch (ExceptCpsT.lift x >>= f) = do\n    let a ← x\n    ExceptCpsT.runCatch (f a)",
  "offspring": [],
  "name": "ExceptCpsT.runCatch_bind_lift"},
 {"type": "{α : Type} → Lean.MessageData → Lean.MetaM α → Lean.MetaM α",
  "offspring": ["MonadExcept.tryCatch"],
  "name": "Mathlib.Tactic.Lint.decorateError"},
 {"type": "{ε σ α : Type u} → α → EStateM ε σ α",
  "offspring": ["EStateM.Result.ok"],
  "name": "EStateM.pure"},
 {"type": "∀ {S₀ : Type u} [self : SemigroupWithZero S₀] (a : S₀), a * 0 = 0",
  "offspring": [],
  "name": "SemigroupWithZero.mul_zero"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (x : α) (xs : List α) (f : α → List β), List.bind (x :: xs) f = f x ++ List.bind xs f",
  "offspring": ["List.join", "List.map"],
  "name": "List.cons_bind"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β}, (Prod.swap p).snd = p.fst",
  "offspring": [],
  "name": "Prod.snd_swap"},
 {"type":
  "∀ {k m n : ℕ}, Nat.coprime k (m * n) ↔ Nat.coprime k m ∧ Nat.coprime k n",
  "offspring": ["Nat.coprime_comm", "Nat.coprime_mul_iff_left", "Iff.rfl"],
  "name": "Nat.coprime_mul_iff_right"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_>>>_»"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (i k : ℕ),\n  (∀ (j : ℕ), j < i → ∀ (h : j < Array.size self.arr), (Array.get self.arr { val := j, isLt := h }).rank ≤ k) →\n    ∀ (j : ℕ),\n      j < i + 1 →\n        ∀ (h : j < Array.size self.arr),\n          (Array.get self.arr { val := j, isLt := h }).rank ≤\n            max k (if h : i < Array.size self.arr then (Array.get self.arr { val := i, isLt := h }).rank else 0)",
  "offspring":
  ["lt_or_eq_of_le",
   "Nat.le_of_lt_succ",
   "le_trans",
   "le_max_left",
   "Nat.instLinearOrderNat",
   "UFNode.rank",
   "Array.get",
   "UnionFind.arr",
   "max",
   "dite_congr",
   "Eq.mpr_prop",
   "dite_true",
   "le_max_right"],
  "name": "UnionFind.rankMaxAux.proof_2"},
 {"type": "(G : Type u) → [inst : Mul G] → Type",
  "offspring": [],
  "name": "IsMulRightCancel"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {x : α} {l₁ l₂ : List α}, x ∈ List.inter l₁ l₂ ↔ x ∈ l₁ ∧ x ∈ l₂",
  "offspring":
  ["List.mem_filter",
   "Decidable.decide",
   "List.not_mem_nil",
   "decide_eq_true_eq",
   "false_and",
   "List.mem_cons"],
  "name": "List.mem_inter_iff"},
 {"type": "∀ {α : Type u_1} (p : α → Prop), ¬∃ x, x ∈ [] ∧ p x",
  "offspring": [],
  "name": "List.not_exists_mem_nil"},
 {"type":
  "∀ {α : Type u_1} {a : α} {l₁ l₂ : List α}, List.disjoint l₁ (a :: l₂) → List.disjoint l₁ l₂",
  "offspring": ["List.disjoint_of_subset_right", "List.subset_cons"],
  "name": "List.disjoint_of_disjoint_cons_right"},
 {"type": "Sat.Literal → Sat.Clause → Sat.Clause",
  "offspring": [],
  "name": "Sat.Clause.cons"},
 {"type": "{R : Type u} → [self : NonUnitalNonAssocSemiring R] → Mul R",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.toMul"},
 {"type":
  "∀ {A : Type u} [inst : AddSemigroup A] [inst_1 : IsAddRightCancel A] {a b c : A}, b + a = c + a ↔ b = c",
  "offspring": ["add_right_cancel"],
  "name": "add_right_cancel_iff"},
 {"type": "∀ (n m : ℕ), Nat.succ n + m = n + Nat.succ m",
  "offspring": ["Nat.succ_add", "Nat.add_succ"],
  "name": "Nat.succ_add_eq_succ_add"},
 {"type": "ByteArray",
  "offspring": ["ByteArray.mkEmpty"],
  "name": "ByteArray.empty"},
 {"type": "∀ {p q : Prop}, ¬p → q → p ∧ ¬q ∨ q ∧ ¬p",
  "offspring": [],
  "name": "instDecidableXor.proof_3"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«termΣ_,_»"},
 {"type": "∀ (m n : ℕ), Int.toNat (Int.ofNat (m - n)) = m - n",
  "offspring": [],
  "name": "Int.toNat_sub"},
 {"type": "Array UInt8 → ByteArray", "offspring": [], "name": "ByteArray.mk"},
 {"type":
  "WellFounded (invImage (fun a => sizeOf a) instWellFoundedRelation).1",
  "offspring": [],
  "name": "Nat.log2.proof_1"},
 {"type": "Lean.Elab.Command.CommandElab",
  "offspring": ["Option.getD", "Array.append"],
  "name": "elabVariables"},
 {"type":
  "∀ {α : Type u_3} {β : Type u_2} {γ : Type u_1} {δ : Type u_4} (f : α → γ) (g : β → δ),\n  Prod.fst ∘ Prod.map f g = f ∘ Prod.fst",
  "offspring": ["Prod.map_fst"],
  "name": "Prod.map_fst'"},
 {"type": "{n : ℕ} → UFModel n → ℕ → ℕ",
  "offspring": [],
  "name": "UFModel.rank"},
 {"type": "Type u → Type u", "offspring": [], "name": "Semiring"},
 {"type":
  "∀ {α : Type u_1} {p : Option α → Prop}, (∃ x, p x) ↔ p none ∨ ∃ x, p (some x)",
  "offspring": ["Or.elim"],
  "name": "Option.exists"},
 {"type":
  "∀ {A : Type u} [inst : Add A] [self : IsAddRightCancel A] (a b c : A), b + a = c + a → b = c",
  "offspring": [],
  "name": "IsAddRightCancel.add_right_cancel"},
 {"type": "{α : Type u} → {m : Type u_1 → Type u_2} → ForIn m (Array α) α",
  "offspring": ["ForIn.mk", "Array.forIn"],
  "name": "Array.instForInArray"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [h : Nonempty α] [h2 : Nonempty β], Nonempty (α × β)",
  "offspring": ["Nonempty.elim"],
  "name": "instNonemptyProd.proof_1"},
 {"type":
  "{β : Type v} → (β → Float → β) → β → (as : FloatArray) → optParam ℕ 0 → optParam ℕ (FloatArray.size as) → β",
  "offspring": ["Id.run", "FloatArray.foldlM", "Id.instMonadId"],
  "name": "FloatArray.foldl"},
 {"type": "UInt64 → UInt8",
  "offspring": ["Nat.toUInt8", "UInt64.toNat"],
  "name": "UInt64.toUInt8"},
 {"type": "ReprAtom UInt64",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomUInt64"},
 {"type": "∀ (n m : ℕ), Nat.succ n - Nat.succ m = n - m",
  "offspring": ["Nat.pred"],
  "name": "Nat.succ_sub_succ_eq_sub"},
 {"type":
  "{α₁ α₂ α₃ α₄ α₅ β : Type u} →\n  [inst : Inhabited β] → ((α₁ → α₂ → α₃ → α₄ → α₅ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → β) → α₁ → α₂ → α₃ → α₄ → α₅ → β",
  "offspring": ["fixCore5", "Inhabited.default"],
  "name": "fix5"},
 {"type": "1 = { val := 1 }", "offspring": [], "name": "USize.one_def"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {g : β → α}, Function.LeftInverse g f → Function.RightInverse f g",
  "offspring": [],
  "name": "Function.LeftInverse.RightInverse"},
 {"type": "{α : Type u_1} → List α → List (List α)",
  "offspring": ["List.sublists'Aux"],
  "name": "List.sublists'"},
 {"type": "{n : ℕ} → Fin n → Fin n → Bool",
  "offspring": ["Decidable.decide"],
  "name": "Fin.addOverflows?"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → List α → β → (α → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "List.forIn"},
 {"type": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "offspring": ["HSub.mk", "Sub.sub"],
  "name": "instHSub"},
 {"type": "{α : Type u_1} → List α → ℕ → List α",
  "offspring": ["List.splitAt"],
  "name": "List.rotate"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (α → m β) → Array α → m (Array β)",
  "offspring": ["Array.foldlM", "Array.push", "Array.mkEmpty"],
  "name": "Array.mapM"},
 {"type": "∀ {p q : Prop}, ¬p → ¬q → p ∧ ¬q ∨ q ∧ ¬p → False",
  "offspring": [],
  "name": "instDecidableXor.proof_4"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β},\n  Function.injective f → ∀ (g : α → γ) (e' : β → γ) (a : α), Function.extend f g e' (f a) = g a",
  "offspring":
  ["Function.extend_def",
   "dite_congr",
   "exists_apply_eq_apply",
   "Eq.mpr_prop",
   "dif_pos",
   "congr_arg",
   "Classical.choose_spec"],
  "name": "Function.extend_apply"},
 {"type": "∀ {p q : Prop}, (∃ h, q) ↔ p ∧ q",
  "offspring": [],
  "name": "exists_prop"},
 {"type":
  "{α : Sort u} → {a : α} → {p : α → Sort v} → {b : α} → HEq a b → p a → p b",
  "offspring": [],
  "name": "HEq.elim"},
 {"type": "∀ (a b c : UInt64), a * (b + c) = a * b + a * c",
  "offspring":
  ["UInt64.add_def",
   "UInt64.mul_def",
   "UInt64.mk",
   "UInt64.eq_of_val_eq",
   "Distrib.left_distrib"],
  "name": "UInt64.instSemiringUInt64.proof_7"},
 {"type": "ℤ → ℤ → ℕ", "offspring": ["Int.toNat"], "name": "Int.natMod"},
 {"type":
  "∀ {α : Type u_1} {a : α} [inst : DecidableEq α] [inst_1 : SizeOf α] {as : Array α}, a ∈ as → sizeOf a < sizeOf as",
  "offspring": [],
  "name": "Array.sizeOf_lt_of_mem"},
 {"type":
  "{α : Type u} → ({g : Type} → [inst : RandomGen g] → RandG g α) → Random α",
  "offspring": [],
  "name": "Random.mk"},
 {"type": "(α : Sort u_1) → [h : Nonempty α] → α",
  "offspring": ["Classical.choice"],
  "name": "Classical.arbitrary"},
 {"type": "∀ {a b c : ℤ}, a < b → 0 < c → c * a < c * b",
  "offspring": [],
  "name": "Int.mul_lt_mul_of_pos_left"},
 {"type": "{α : Type u} → (α → α → α) → Sub α",
  "offspring": [],
  "name": "Sub.mk"},
 {"type":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "offspring": ["instDecidableAnd.proof_1", "instDecidableAnd.proof_2"],
  "name": "instDecidableAnd"},
 {"type": "∀ {α : Sort u_1}, WellFounded emptyRelation",
  "offspring": ["WellFounded.intro", "Acc.intro", "Acc"],
  "name": "emptyWf.proof_1"},
 {"type":
  "∀ {α : Type u_1} {x : Option α}, Option.isSome x = true ↔ ∃ a, x = some a",
  "offspring":
  ["eq_false_of_decide",
   "eq_false'",
   "exists_false",
   "Option.some.injEq",
   "exists_eq'"],
  "name": "Option.isSome_iff_exists"},
 {"type": "{α : Type u_1} → Array (Option α) → Array α",
  "offspring": ["Array.filterMap"],
  "name": "Array.reduceOption"},
 {"type": "∀ {b : Bool}, b = true → ¬b = false",
  "offspring": [],
  "name": "ne_false_of_eq_true"},
 {"type":
  "∀ {A : Type u} [self : AddMonoid A] (x : A), AddMonoid.nsmul 0 x = 0",
  "offspring": [],
  "name": "AddMonoid.nsmul_zero'"},
 {"type": "Nat.Linear.Context → Nat.Linear.Certificate → Prop",
  "offspring": ["Nat.Linear.ExprCnstr"],
  "name": "Nat.Linear.Certificate.denote"},
 {"type": "{α : Sort u} → (α → Sort v) → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "PSigma"},
 {"type": "∀ {a b : ℕ}, a < b → a < Nat.succ b",
  "offspring": ["Nat.le_succ_of_le"],
  "name": "Nat.lt_succ_of_lt"},
 {"type":
  "{α : Type u} → [inst : LinearOrder α] → (x y : α) → {P : Sort u_1} → (x < y → P) → (x = y → P) → (y < x → P) → P",
  "offspring": ["lt_by_cases.proof_1"],
  "name": "lt_by_cases"},
 {"type": "{R : Type u} → [self : AddGroupWithOne R] → ℤ → R",
  "offspring": [],
  "name": "AddGroupWithOne.intCast"},
 {"type":
  "{ε : Type u} → {m : Type u → Type v} → [inst : Monad m] → MonadLift (Except ε) (ExceptT ε m)",
  "offspring": ["MonadLift.mk", "ExceptT.mk"],
  "name": "ExceptT.instMonadLiftExceptExceptT"},
 {"type":
  "∀ {α : Sort u} {s : Setoid α} {a b : α}, Quotient.mk s a = Quotient.mk s b → a ≈ b",
  "offspring": ["Quot.inductionOn", "Setoid.refl"],
  "name": "Quotient.exact"},
 {"type": "Inhabited (Fin USize.size)",
  "offspring": ["Fin.ofNat'", "USize.size_positive"],
  "name": "USize.instInhabitedFinSize"},
 {"type": "∀ (m : ℕ), Nat.lcm m m = m",
  "offspring": ["Nat.lcm", "Nat.eq_zero_or_pos", "Nat.lcm_zero_left"],
  "name": "Nat.lcm_self"},
 {"type":
  "{α : Type u} → [inst : Inhabited α] → String → String → ℕ → ℕ → String → α",
  "offspring": ["panic", "instToStringNat"],
  "name": "panicWithPosWithDecl"},
 {"type": "∀ (b : Bool), (b && false) = false",
  "offspring": [],
  "name": "Bool.and_false"},
 {"type": "Substring → (Char → Bool) → Substring",
  "offspring": ["Substring.mk"],
  "name": "Substring.takeWhile"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (n_1 : ℕ) (a : Fin n),\n  AddGroupWithOne.gsmul (Int.ofNat (Nat.succ n_1)) a = a + AddGroupWithOne.gsmul (Int.ofNat n_1) a",
  "offspring": ["AddGroupWithOne.gsmul_succ'"],
  "name": "instCommRingFin.proof_3"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<|_»"},
 {"type": "(ds : FloatArray) → Fin (FloatArray.size ds) → Float → FloatArray",
  "offspring": ["FloatArray.mk", "Array.set", "Float"],
  "name": "FloatArray.set"},
 {"type":
  "∀ {α : Type u_1} (a : α) {n : ℕ} (m : Fin (List.length (List.repeat' a n))), List.get (List.repeat' a n) m = a",
  "offspring": ["List.eq_of_mem_repeat'", "List.get_mem", "List.repeat'"],
  "name": "List.get_repeat'"},
 {"type": "∀ {a b : ℤ}, 0 ≤ b → a ≤ a + b",
  "offspring": [],
  "name": "Int.le_add_of_nonneg_right"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a₁ x : α) (n : ℕ) (b₁ a₂ b₂ a' b' t : α),\n  a₁ + a₂ = a' →\n    b₁ + b₂ = b' → Tactic.Ring.horner a' x n b' = t → Tactic.Ring.horner a₁ x n b₁ + Tactic.Ring.horner a₂ x n b₂ = t",
  "offspring": ["add_assoc", "add_left_comm", "add_mul"],
  "name": "Tactic.Ring.horner_add_horner_eq"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.injective f → ∀ {a b : α}, f a = f b ↔ a = b",
  "offspring": ["congr_arg"],
  "name": "Function.injective.eq_iff"},
 {"type": "∀ {a : ℤ}, 0 ≤ a → ∃ n, a = ↑n",
  "offspring": [],
  "name": "Int.eq_ofNat_of_zero_le"},
 {"type": "{α : Sort u} → (a : α) → {β : Sort v} → [self : CoeT α a β] → β",
  "offspring": [],
  "name": "CoeT.coe"},
 {"type": "{α : Type u} → Option α → Lean.LOption α",
  "offspring": [],
  "name": "Option.toLOption"},
 {"type": "∀ {m n : ℕ}, m ≤ Nat.succ n → m ≤ n ∨ m = Nat.succ n",
  "offspring": ["Decidable.byCases"],
  "name": "Nat.le_or_eq_or_le_succ"},
 {"type": "∀ {M : Type u} [self : Monoid M] (x : M), Monoid.npow 0 x = 1",
  "offspring": [],
  "name": "Monoid.npow_zero'"},
 {"type":
  "∀ {data data_1 : Array Float}, { data := data } = { data := data_1 } → data = data_1",
  "offspring": [],
  "name": "FloatArray.mk.inj"},
 {"type": "∀ {α : Type u_1} (c : ℕ), ∃ n m, UFModel.Models (Array.mkEmpty c) m",
  "offspring": ["UFModel.empty", "UFModel.Models.empty"],
  "name": "UnionFind.mkEmpty.proof_1"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_>>=_»"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {f : α → β} {b : β} {l : List α}, b ∈ List.map f l → ∃ a, a ∈ l ∧ f a = b",
  "offspring":
  ["List.map",
   "List.eq_or_mem_of_mem_cons",
   "List.mem_cons_self",
   "List.mem_cons_of_mem"],
  "name": "List.exists_of_mem_map"},
 {"type":
  "∀ {α : Type u} {p : α → Prop} (a : { x // p x }) (h : p a.val), { val := a.val, property := h } = a",
  "offspring": [],
  "name": "Subtype.eta"},
 {"type": "∀ {a b c : ℤ}, a ≤ c - b → a + b ≤ c",
  "offspring": [],
  "name": "Int.add_le_of_le_sub_right"},
 {"type":
  "{α : Type} → [inst : Inhabited α] → Std.HashMap Lean.Name α → Lean.CoreM (Array (Lean.Name × α))",
  "offspring":
  ["ForIn.forIn",
   "ForInStep",
   "Array.qsort",
   "Decidable.decide",
   "EmptyCollection.emptyCollection"],
  "name": "Mathlib.Tactic.Lint.sortResults"},
 {"type": "ShiftRight USize",
  "offspring": ["ShiftRight.mk", "USize.shiftRight"],
  "name": "instShiftRightUSize"},
 {"type":
  "{collection stream : Type u} → [self : ToStream collection stream] → collection → stream",
  "offspring": [],
  "name": "ToStream.toStream"},
 {"type": "SizeOf ℕ", "offspring": ["SizeOf.mk"], "name": "instSizeOfNat"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {b₁ b₂ : β} {s : β → β → Prop} (a₁ a₂ : α),\n  s b₁ b₂ → PSigma.RevLex emptyRelation s { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ }",
  "offspring": ["PSigma.RevLex.right"],
  "name": "PSigma.mkSkipLeft.proof_1"},
 {"type":
  "Mathlib.Tactic.Lint.Linter → Lean.Name → Lean.MetaM (Option Lean.MessageData)",
  "offspring": [],
  "name": "Mathlib.Tactic.Lint.Linter.test"},
 {"type": "{α : Type u_1} → List (Option α) → List α",
  "offspring": ["List.filterMap"],
  "name": "List.reduceOption"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∃ x, p x) ↔ ∃ a b, p (a, b)",
  "offspring": [],
  "name": "Prod.exists"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] (f : (a : α) → β a) {a : α} {b : β a} (p : (a : α) → β a → Prop),\n  (∀ (x : α), p x (Function.update f a b x)) ↔ p a b ∧ ∀ (x : α), x ≠ a → p x (f x)",
  "offspring": [],
  "name": "Function.forall_update_iff"},
 {"type":
  "{ρ : outParam (Type u)} → {m : Type u → Type v} → Sort u_1 → MonadReader ρ m → MonadReader ρ m → Sort u_1",
  "offspring": [],
  "name": "MonadReader.noConfusionType"},
 {"type":
  "(p : ℕ → Prop) → [inst : DecidablePred p] → (∃ n, p n) → { n // p n ∧ ∀ (m : ℕ), m < n → ¬p m }",
  "offspring":
  ["WellFounded.fix'",
   "WellFounded.intro",
   "Acc",
   "Subtype.mk",
   "Nat.find_x.proof_1",
   "Nat.find_x.proof_3"],
  "name": "Nat.find_x"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (k a x : α) (n : ℕ) (b b' : α),\n  k + b = b' → k + Tactic.Ring.horner a x n b = Tactic.Ring.horner a x n b'",
  "offspring": ["add_comm", "add_assoc"],
  "name": "Tactic.Ring.const_add_horner"},
 {"type": "Type", "offspring": [], "name": "Unit"},
 {"type": "∀ {a b : Prop} [inst : Decidable a], ¬(a → b) ↔ a ∧ ¬b",
  "offspring": ["Decidable.of_not_imp", "not_of_not_imp", "not_imp_of_and_not"],
  "name": "Decidable.not_imp"},
 {"type": "{α : Sort u} → α → α", "offspring": [], "name": "inline"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (a : Fin n), AddGroupWithOne.gsmul 0 a = 0",
  "offspring": ["AddGroupWithOne.gsmul_zero'"],
  "name": "instCommRingFin.proof_2"},
 {"type": "∀ {a b : Prop}, ¬(a ↔ b) → a ≠ b",
  "offspring": ["mt", "Eq.to_iff"],
  "name": "neq_of_not_iff"},
 {"type":
  "(a : ByteArray) → (i : USize) → UInt8 → USize.toNat i < ByteArray.size a → ByteArray",
  "offspring": ["ByteArray.mk", "Array.uset"],
  "name": "ByteArray.uset"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → List α → List β → List (Option α × β) × List α",
  "offspring": ["List.map₂Right'"],
  "name": "List.zipRight'"},
 {"type":
  "{α : Sort u} → {r : α → α → Prop} → {motive : (a a_1 : α) → TC r a a_1 → Prop} → {a a_1 : α} → TC r a a_1 → Prop",
  "offspring": [],
  "name": "TC.below"},
 {"type": "∀ {α : Type u_1} (l : List α), List.disjoint l []",
  "offspring":
  ["List.disjoint", "List.disjoint_comm", "List.disjoint_nil_left"],
  "name": "List.disjoint_nil_right"},
 {"type": "ℕ", "offspring": [], "name": "Nat.zero"},
 {"type": "Ord ℕ",
  "offspring": ["Ord.mk", "compareOfLessAndEq"],
  "name": "instOrdNat"},
 {"type": "∀ (a : UInt8), 0 + a = a",
  "offspring":
  ["UInt8.zero_def",
   "UInt8.add_def",
   "UInt8.mk",
   "zero_add",
   "UInt8.mk_val_eq"],
  "name": "UInt8.instSemiringUInt8.proof_2"},
 {"type": "0 < USize.size",
  "offspring": ["usize_size_gt_zero"],
  "name": "USize.size_positive"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk"],
  "name": "UInt8.mul"},
 {"type": "{σ : outParam Type} → {m : Type → Type} → STWorld σ m",
  "offspring": [],
  "name": "STWorld.mk"},
 {"type":
  "∀ {α : Type u_1} (as : Array α) (j i : ℕ), i + 1 + j = Array.size as → i + (j + 1) = Array.size as",
  "offspring": ["Nat.add_assoc"],
  "name": "Array.findIdx?.loop.proof_2"},
 {"type": "∀ (x : UInt32), { val := AddMonoid.nsmul 0 x.val } = { val := 0.1 }",
  "offspring": ["AddMonoid.nsmul_zero'"],
  "name": "UInt32.instSemiringUInt32.proof_4"},
 {"type": "Add UInt8",
  "offspring": ["Add.mk", "UInt8.add"],
  "name": "instAddUInt8"},
 {"type":
  "Sort u → Mathlib.Tactic.Sat.LRATStep → Mathlib.Tactic.Sat.LRATStep → Sort u",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LRATStep.noConfusionType"},
 {"type": "String → String",
  "offspring": ["or", "not"],
  "name": "addParenHeuristic"},
 {"type": "∀ {a b : Prop}, ¬(a ∧ ¬b) ↔ a → b",
  "offspring": ["Decidable.not_and_not_right"],
  "name": "not_and_not_right"},
 {"type": "HMod UInt64 ℕ UInt64",
  "offspring": ["HMod.mk", "UInt64.modn"],
  "name": "instHModUInt64Nat"},
 {"type": "Type u → Type u", "offspring": [], "name": "Complement"},
 {"type": "Type", "offspring": [], "name": "Mathlib.Tactic.Sat.Clause"},
 {"type": "∀ {R : Type u_1} [inst : Semiring R] {m n : ℕ}, ↑(m ^ n) = ↑m ^ n",
  "offspring":
  ["HPow.hPow",
   "Nat.zero_eq",
   "Nat.pow_zero",
   "Nat.cast_one",
   "pow_zero",
   "Nat.Nat.pow_succ'",
   "Nat.cast_mul",
   "pow_succ'"],
  "name": "Nat.cast_pow"},
 {"type": "∀ (a a_1 : UInt64), a + a_1 = a_1 + a",
  "offspring": ["UInt64.add_def", "add_comm", "UInt64.mk"],
  "name": "UInt64.instSemiringUInt64.proof_6"},
 {"type":
  "{α : Type u} → [inst : LinearOrder α] → (a b : α) → Decidable (a ≤ b)",
  "offspring": ["LinearOrder.decidable_le"],
  "name": "instDecidableLeToLEToPreorderToPartialOrder"},
 {"type": "∀ (m n k : ℕ), m / n / k = m / (n * k)",
  "offspring":
  ["Nat.eq_zero_or_pos",
   "Nat.mul_zero",
   "Nat.div_zero",
   "Nat.zero_mul",
   "Nat.zero_div",
   "Nat.le_antisymm",
   "Nat.le_div_iff_mul_le",
   "Nat.mul_pos",
   "Nat.mul_assoc",
   "Nat.le_refl"],
  "name": "Nat.div_div_eq_div_mul"},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → List α",
  "offspring": ["List.filter", "List.notElem"],
  "name": "List.removeAll"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HXor α β γ",
  "offspring": [],
  "name": "HXor.mk"},
 {"type":
  "{α : Sort u} →\n  {β : Sort v} →\n    {δ : Sort w} → {γ : Sort w'} → [inst : CoeHead α β] → [inst : CoeTail δ γ] → [inst : CoeTC β δ] → CoeHTCT α γ",
  "offspring": ["CoeHTCT.mk", "CoeTail.coe", "CoeTC.coe", "CoeHead.coe"],
  "name": "coeOfHeafOfTCOfTail"},
 {"type":
  "∀ {α : Type u_1} {l₁ l₂ : List α},\n  List.length l₁ = List.length l₂ →\n    (∀ (n : ℕ) (h₁ : n < List.length l₁) (h₂ : n < List.length l₂),\n        List.get l₁ { val := n, isLt := h₁ } = List.get l₂ { val := n, isLt := h₂ }) →\n      l₁ = l₂",
  "offspring": ["List.ext", "List.get?", "List.get?_eq_get", "List.get"],
  "name": "List.ext_get"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadStateOf σ m] → {α : Type u} → (σ → α × σ) → m α",
  "offspring": [],
  "name": "MonadStateOf.modifyGet"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term{__:_//_}»"},
 {"type": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "offspring": [],
  "name": "MulZeroOneClass.toMulOneClass"},
 {"type": "∀ {p : Prop} (P : p → Prop) (h : p), P h ↔ ∃ h, P h",
  "offspring": [],
  "name": "exists_prop_decidable.proof_1"},
 {"type":
  "∀ {R : Type u_1} [inst : Distrib R] (a b c : R), (a + b) * c = a * c + b * c",
  "offspring": ["Distrib.right_distrib"],
  "name": "add_mul"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": [],
  "name": "unexpandIte"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {ε α β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (x : ExceptT ε m α)\n  (y : ExceptT ε m β), (SeqRight.seqRight x fun x => y) = Seq.seq (Function.const α id <$> x) fun x => y",
  "offspring": [],
  "name": "ExceptT.seqRight_eq"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.injective f → ∀ {a₁ a₂ : α}, a₁ ≠ a₂ → f a₁ ≠ f a₂",
  "offspring": ["mt"],
  "name": "Function.injective.ne"},
 {"type": "∀ {R : Type u} [self : CommRing R] (a b : R), a * b = b * a",
  "offspring": [],
  "name": "CommRing.mul_comm"},
 {"type":
  "∀ {M : Type u_1} [inst : CommSemigroup M] (a b c : M), a * (b * c) = b * (a * c)",
  "offspring": ["Semigroup.mul_assoc", "CommSemigroup.mul_comm"],
  "name": "mul_left_comm"},
 {"type": "∀ (n : ℕ), n / 0 = 0",
  "offspring":
  ["HDiv.hDiv",
   "Nat.div_eq",
   "instDecidableFalse",
   "eq_false_of_decide",
   "false_and",
   "Nat.sub_zero",
   "ite_false"],
  "name": "Nat.div_zero"},
 {"type": "Type u → Type u", "offspring": [], "name": "MonoidWithZero"},
 {"type": "∀ {p : Prop} {s : Decidable p}, decide p = true → p = True",
  "offspring": ["trivial"],
  "name": "eq_true_of_decide"},
 {"type": "{α : Type u_1} → {lt : α → α → Bool} → BinaryHeap α lt → ℕ",
  "offspring": ["BinaryHeap.arr"],
  "name": "BinaryHeap.size"},
 {"type":
  "∀ {eq : Bool} {lhs rhs : Nat.Linear.Expr} {eq_1 : Bool} {lhs_1 rhs_1 : Nat.Linear.Expr},\n  { eq := eq, lhs := lhs, rhs := rhs } = { eq := eq_1, lhs := lhs_1, rhs := rhs_1 } →\n    eq = eq_1 ∧ lhs = lhs_1 ∧ rhs = rhs_1",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.mk.inj"},
 {"type": "∀ {n : ℕ} (x x_1 x_2 : Fin n), x + x_1 + x_2 = x + (x_1 + x_2)",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Fin.add_def",
   "Fin.size_positive",
   "Nat.mod_add_mod",
   "Nat.add_assoc",
   "Nat.add_mod_mod"],
  "name": "instAddCommSemigroupFin.proof_1"},
 {"type": "¬True = False",
  "offspring": ["ne_false_of_self", "trivial"],
  "name": "true_ne_false"},
 {"type": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "offspring": ["Or.elim"],
  "name": "Or.resolve_right"},
 {"type":
  "{α : Sort u2} →\n  {r : α → α → Prop} →\n    {C : α → Sort u1} →\n      ((x : α) → (∀ (y : α), r y x → Acc r y) → ((y : α) → r y x → C y) → C x) → {a : α} → Acc r a → C a",
  "offspring": [],
  "name": "Acc.ndrec"},
 {"type": "∀ (n : ℕ), Nat.succ n ≤ Nat.succ n",
  "offspring": ["Nat.le_refl"],
  "name": "Nat.lt.base.proof_1"},
 {"type": "Mod UInt16",
  "offspring": ["Mod.mk", "UInt16.mod"],
  "name": "instModUInt16"},
 {"type": "{p : Prop} → Repr (Decidable p)",
  "offspring": [],
  "name": "instReprDecidable"},
 {"type": "(a b : UInt64) → Decidable (a ≤ b)",
  "offspring": ["UInt64.decLe"],
  "name": "instDecidableLeUInt64InstLEUInt64"},
 {"type": "ToString USize",
  "offspring": ["ToString.mk", "instToStringNat", "USize.toNat"],
  "name": "instToStringUSize"},
 {"type": "∀ {n : ℕ} (a : ℕ), a % (n + 1) < n + 1",
  "offspring": ["Nat.zero_lt_succ"],
  "name": "Fin.ofNat.proof_1"},
 {"type": "Type u → Type u", "offspring": [], "name": "RandomGen"},
 {"type": "∀ {a b : Prop}, (a ↔ b) ↔ a = b",
  "offspring": ["iff_of_eq"],
  "name": "iff_iff_eq"},
 {"type":
  "{α : Type u_1} →\n  {R : α → α → Prop} → {motive : (a : List α) → List.Pairwise R a → Prop} → {a : List α} → List.Pairwise R a → Prop",
  "offspring": [],
  "name": "List.Pairwise.below"},
 {"type":
  "∀ {α : Sort u₁} {β : Sort u₂} {f : α → β}, Function.has_LeftInverse f → Function.injective f",
  "offspring": ["Exists.elim", "Function.LeftInverse.injective"],
  "name": "Function.has_LeftInverse.injective"},
 {"type": "∀ {m k n : ℕ}, n ∣ m → Nat.coprime k m → Nat.coprime k n",
  "offspring": ["Nat.coprime.symm", "Nat.coprime.coprime_dvd_left"],
  "name": "Nat.coprime.coprime_dvd_right"},
 {"type": "∀ (x y : Unit), x = y", "offspring": ["Unit"], "name": "Unit.ext"},
 {"type":
  "{S₀ : Type u} → Sort u_1 → SemigroupWithZero S₀ → SemigroupWithZero S₀ → Sort u_1",
  "offspring": [],
  "name": "SemigroupWithZero.noConfusionType"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (n : ℕ) (hsz : Array.size a = n), a = Array.toArrayLit a n hsz",
  "offspring": [],
  "name": "Array.toArrayLit_eq'"},
 {"type": "FloatArray → ℕ → List Float → List Float",
  "offspring": [],
  "name": "FloatArray.toList.loop"},
 {"type": "∀ (a : UInt8), a * 0 = 0",
  "offspring":
  ["UInt8.zero_def", "UInt8.mul_def", "UInt8.mk", "MonoidWithZero.mul_zero"],
  "name": "UInt8.instSemiringUInt8.proof_10"},
 {"type": "(a b : UInt8) → Decidable (a < b)",
  "offspring": [],
  "name": "UInt8.decLt"},
 {"type": "∀ {a b : ℤ}, b ≤ a → 0 ≤ a - b",
  "offspring": [],
  "name": "Int.sub_nonneg_of_le"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → Array α → β → (α → β → m (ForInStep β)) → m β",
  "offspring": ["USize.ofNat"],
  "name": "Array.forInUnsafe"},
 {"type": "∀ (n : ℕ), 0 * n = 0",
  "offspring": ["Nat.mul_succ"],
  "name": "Nat.zero_mul"},
 {"type": "ℕ → Type", "offspring": [], "name": "Fin"},
 {"type": "UInt64 → ℕ", "offspring": ["UInt64.size"], "name": "UInt64.toNat"},
 {"type": "Tactic.NormCast.NormCastExtension → Lean.Meta.SimpExtension",
  "offspring": [],
  "name": "Tactic.NormCast.NormCastExtension.squash"},
 {"type":
  "∀ {α : Sort u} {p : α → Prop} (val : α) (property : p val) (val_1 : α) (property_1 : p val_1),\n  ({ val := val, property := property } = { val := val_1, property := property_1 }) = (val = val_1)",
  "offspring": ["Subtype.mk"],
  "name": "Subtype.mk.injEq"},
 {"type":
  "∀ (v v_1 : ℕ), (Nat.Linear.Expr.num v = Nat.Linear.Expr.num v_1) = (v = v_1)",
  "offspring": ["Nat.Linear.Expr"],
  "name": "Nat.Linear.Expr.num.injEq"},
 {"type": "Ring USize",
  "offspring":
  ["Ring.mk",
   "USize.instSemiringUSize",
   "USize.instNegUSize",
   "instSubUSize",
   "USize.instRingUSize.proof_1",
   "USize.mk",
   "Ring.gsmul",
   "USize.instRingUSize.proof_3",
   "USize.instRingUSize.proof_4",
   "USize.instRingUSize.proof_5",
   "USize.instRingUSize.proof_6",
   "Int.cast",
   "USize.instRingUSize.proof_7",
   "USize.instRingUSize.proof_8"],
  "name": "USize.instRingUSize"},
 {"type": "∀ {a : ℕ}, a < UInt32.size → ↑(UInt32.ofNat a).val = a",
  "offspring": ["Fin.val_eq_of_lt"],
  "name": "UInt32.val_eq_of_lt"},
 {"type":
  "∀ {α : Type u_2} {β : Sort u_1} [inst : Subsingleton β] (f : α → β) (a b : α), True → f a = f b",
  "offspring": ["Subsingleton.elim"],
  "name": "Squash.lift.proof_1"},
 {"type": "∀ (a b : ℕ), (¬a ≥ b) = (a + 1 ≤ b)",
  "offspring": ["Nat.not_le_eq"],
  "name": "Nat.not_ge_eq"},
 {"type":
  "∀ {α : Type u_1} (lt : α → α → Bool) (a : Array α) (i : Fin (Array.size a)),\n  Array.size (BinaryHeap.heapifyUp lt a i).val = Array.size a",
  "offspring": ["Subtype.property", "BinaryHeap.heapifyUp"],
  "name": "BinaryHeap.size_heapifyUp"},
 {"type":
  "∀ {data data_1 : Array UInt8}, { data := data } = { data := data_1 } → data = data_1",
  "offspring": [],
  "name": "ByteArray.mk.inj"},
 {"type": "∀ {α : Sort u} (a : α), a = a", "offspring": [], "name": "Eq.refl"},
 {"type": "{α : Type u} → [inst : BEq α] → α → Array α → Bool",
  "offspring": ["Array.contains"],
  "name": "Array.elem"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Functor m] {x : m α} {f g : α → β},\n  (∀ (a : α), f a = g a) → f <$> x = g <$> x",
  "offspring": [],
  "name": "map_congr"},
 {"type": "{G : Type u} → Sort u_1 → Semigroup G → Semigroup G → Sort u_1",
  "offspring": [],
  "name": "Semigroup.noConfusionType"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_≈_»"},
 {"type":
  "{β : Type v} →\n  {m : Type v → Type w} → [inst : Monad m] → FloatArray → (Float → β → m (ForInStep β)) → USize → USize → β → m β",
  "offspring":
  ["instLTUSize", "FloatArray.forInUnsafe.loop", "FloatArray.uget", "lcProof"],
  "name": "FloatArray.forInUnsafe.loop"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_\\/_»"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": [],
  "name": "Set.singletonUnexpander"},
 {"type": "1 = { val := 1 }", "offspring": [], "name": "UInt64.one_def"},
 {"type": "∀ {n : ℕ} {a b : Fin n}, a = b ↔ ↑a = ↑b",
  "offspring": ["Fin.ext"],
  "name": "Fin.ext_iff"},
 {"type": "LawfulFunctor Option",
  "offspring": ["instLawfulFunctorOptionInstFunctorOption.proof_1"],
  "name": "instLawfulFunctorOptionInstFunctorOption"},
 {"type": "DecidableEq USize",
  "offspring": ["USize.decEq"],
  "name": "instDecidableEqUSize"},
 {"type": "Type u → Type u", "offspring": [], "name": "AddCommMonoid"},
 {"type":
  "∀ {α : Type u_1} (a : Array α) (x : ℕ),\n  x < Array.size a → (invImage (fun a_1 => Array.size a - a_1) instWellFoundedRelation).1 (x + 1) x",
  "offspring": ["sizeOf_nat", "Nat.lt_eq", "Nat.sub_succ_lt_self"],
  "name": "Array.isEqvAux.proof_3"},
 {"type": "∀ {m n : ℕ}, n - m = 0 → Int.subNatNat m n = Int.ofNat (m - n)",
  "offspring": [],
  "name": "Int.subNatNat_of_sub_eq_zero"},
 {"type": "Type", "offspring": [], "name": "Sat.Valuation"},
 {"type":
  "∀ {f f' : Sat.Fmla}, (∀ (x : Sat.Clause), x ∈ f' → x ∈ f) → Sat.Fmla.subsumes f f'",
  "offspring": [],
  "name": "Sat.Fmla.subsumes.mk"},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] (a : α) (as : List α) (b : α) (bs : List α),\n  ¬(fun a a_1 => a < a_1) a b → ¬as < bs → a :: as < b :: bs → False",
  "offspring": [],
  "name": "List.hasDecidableLt.proof_4"},
 {"type": "Int.natAbs 1 = 1", "offspring": [], "name": "Int.natAbs_one"},
 {"type": "True", "offspring": [], "name": "True.intro"},
 {"type":
  "∀ {α : Type u_1} (a : Array α), Array.size (Array.pop a) = Array.size a - 1",
  "offspring": ["List.length_dropLast", "Array.data"],
  "name": "Array.size_pop"},
 {"type":
  "{m : Type u → Type u_1} → [inst : Monad m] → {α β : Type u} → (α → α → m β) → List α → m (List β)",
  "offspring": ["List.mmap"],
  "name": "List.mmapUpperTriangle"},
 {"type": "∀ {α : Type u_1} [inst : LT α], [] < [] → False",
  "offspring": [],
  "name": "List.hasDecidableLt.proof_1"},
 {"type": "Lean.Name → Lean.Elab.TermElabM Lean.Name",
  "offspring": ["Option.getD"],
  "name": "Mathlib.TermUnsafe.mkAuxName"},
 {"type": "{a : Type u_1} → [inst : Inhabited a] → Inhabited (Task a)",
  "offspring": ["Task.pure", "Inhabited.default"],
  "name": "instInhabitedTask"},
 {"type":
  "{α : Sort u_1} → {β : α → Sort u_2} → [inst : CoeFun α β] → (a : α) → CoeDep α a (β a)",
  "offspring": ["CoeDep.mk", "CoeFun.coe"],
  "name": "instCoeDep"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} (a b : α), a = b → Sum.inl a = Sum.inl b",
  "offspring": [],
  "name": "instDecidableEqSum.proof_1"},
 {"type": "∀ {α : Sort u}, (∀ (a b : α), a = b) → Subsingleton α",
  "offspring": [],
  "name": "Subsingleton.intro"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {x y : α}, Acc r x → r y x → Acc r y",
  "offspring": ["Acc.inv.proof_1"],
  "name": "Acc.inv"},
 {"type": "{α : Type u} → [inst : Inhabited α] → Array α → ℕ → α",
  "offspring": ["Array.getD", "Inhabited.default"],
  "name": "Array.get!"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (e : Nat.Linear.Expr) (p : Nat.Linear.Poly),\n  Nat.Linear.Expr.denote ctx (Nat.Linear.Poly.toExpr.go e p) =\n    Nat.Linear.Expr.denote ctx e + Nat.Linear.Poly.denote ctx p",
  "offspring":
  ["Nat.zero_add", "Nat.Linear.denote_monomialToExpr", "Nat.add_left_comm"],
  "name": "Nat.Linear.Poly.denote_toExpr_go"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a b : α} {l : List α}, a ∈ List.erase l b → a ∈ l",
  "offspring": ["List.erase_subset"],
  "name": "List.mem_of_mem_erase"},
 {"type": "{α : Type u} → Array α → List α",
  "offspring": [],
  "name": "Array.data"},
 {"type":
  "{α : Sort u} → Sort u_1 → Subsingleton α → Subsingleton α → Sort u_1",
  "offspring": [],
  "name": "Subsingleton.noConfusionType"},
 {"type":
  "∀ {α : Type u₁} {β : Type u₂} {φ : Type u₃} (f : α × β → φ), Function.uncurry (Function.curry f) = f",
  "offspring": ["Function.uncurry", "Function.curry"],
  "name": "Function.uncurry_curry"},
 {"type": "{α : Sort u} → {β : Sort v} → [self : CoeTail α β] → α → β",
  "offspring": [],
  "name": "CoeTail.coe"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → ℕ → (ℕ → m Bool) → ℕ → m Bool",
  "offspring": [],
  "name": "Nat.allM.loop"},
 {"type": "Type", "offspring": ["List", "Sat.Literal"], "name": "Sat.Clause"},
 {"type": "∀ {a b c : Prop}, a → b ∨ c ↔ (a → b) ∨ (a → c)",
  "offspring": ["Decidable.imp_or_distrib'"],
  "name": "imp_or_distrib'"},
 {"type": "∀ {a b c : Prop}, a ∨ b → (a → c) → (b → c) → c",
  "offspring": [],
  "name": "Or.elim"},
 {"type": "∀ {a : ℕ}, a < USize.size → ↑(USize.ofNat a).val = a",
  "offspring": ["Fin.val_eq_of_lt"],
  "name": "USize.val_eq_of_lt"},
 {"type": "∀ (m n : ℕ), m ∣ n ↔ n % m = 0",
  "offspring": ["Nat.mod_eq_zero_of_dvd", "Nat.dvd_of_mod_eq_zero"],
  "name": "Nat.dvd_iff_mod_eq_zero"},
 {"type": "Type u → Type u", "offspring": [], "name": "ReprTuple"},
 {"type": "Type", "offspring": [], "name": "Mathlib.Tactic.Lint.NamedLinter"},
 {"type": "∀ (p : Prop), (p ∧ p) = p", "offspring": [], "name": "and_self"},
 {"type":
  "{σ : outParam Type} → {m : Type → Type} → Sort u → STWorld σ m → STWorld σ m → Sort u",
  "offspring": [],
  "name": "STWorld.noConfusionType"},
 {"type": "Lean.Syntax → String",
  "offspring": [],
  "name": "Mathlib.Util.LibraryNote.getDocCommentContent"},
 {"type":
  "∀ {α : Type u} {a : α} {as : List α} (bs : List α), a ∈ as → a ∈ as ++ bs",
  "offspring": ["List.Mem.head", "List.append", "List.Mem.tail"],
  "name": "List.mem_append_of_mem_left"},
 {"type": "∀ (α : Sort u) (default : α), optParam α default = α",
  "offspring": ["optParam_eq"],
  "name": "opt_param_eq"},
 {"type":
  "(ε : outParam (Type u)) → (m : Type v → Type w) → [inst : MonadExceptOf ε m] → MonadExcept ε m",
  "offspring": ["MonadExcept.mk", "throwThe", "tryCatchThe"],
  "name": "instMonadExcept"},
 {"type":
  "∀ {α : Type u_1} {as bs : List α}, List.equiv as bs ↔ as ⊆ bs ∧ bs ⊆ as",
  "offspring": [],
  "name": "List.equiv_iff_subset_and_subset"},
 {"type": "Prop → Prop → Prop", "offspring": [], "name": "And"},
 {"type": "Float → Float → Float", "offspring": [], "name": "Float.add"},
 {"type":
  "{α : Type} →\n  [inst : Inhabited α] → (as : Array α) → α → (α → α → Bool) → optParam ℕ 0 → optParam ℕ (Array.size as - 1) → Option α",
  "offspring": ["Array.binSearchAux"],
  "name": "Array.binSearch"},
 {"type": "∀ (x : UInt8), { val := AddMonoid.nsmul 0 x.val } = { val := 0.1 }",
  "offspring": ["AddMonoid.nsmul_zero'"],
  "name": "UInt8.instSemiringUInt8.proof_4"},
 {"type": "WellFounded Nat.lt",
  "offspring": ["WellFounded.intro", "Acc.intro", "Nat.not_lt_zero"],
  "name": "Nat.lt_wfRel.proof_1"},
 {"type": "UInt8 → UInt8 → Prop", "offspring": [], "name": "UInt8.le"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (f : α → β) (x : m α),\n  f <$> x = do\n    let a ← x\n    pure (f a)",
  "offspring": ["LawfulMonad.bind_pure_comp"],
  "name": "map_eq_pure_bind"},
 {"type": "0 = { val := 0 }", "offspring": [], "name": "UInt32.zero_def"},
 {"type": "Inhabited PUnit", "offspring": [], "name": "instInhabitedPUnit"},
 {"type":
  "∀ {α : Type u_1} [inst : CommSemiring α] (a x : α) (n : ℕ) (b k b' : α),\n  b + k = b' → Tactic.Ring.horner a x n b + k = Tactic.Ring.horner a x n b'",
  "offspring": ["add_assoc"],
  "name": "Tactic.Ring.horner_add_const"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} →\n    [inst : MonadControlT m n] →\n      [inst_1 : Bind n] → {α : Type u} → (({β : Type u} → n β → m (stM m n β)) → m (stM m n α)) → n α",
  "offspring": ["controlAt"],
  "name": "control"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_<<<_»"},
 {"type": "{α : Type u} → [self : Div α] → α → α → α",
  "offspring": [],
  "name": "Div.div"},
 {"type": "(n m : ℕ) → Decidable (n ≤ m)",
  "offspring":
  ["Nat.ble", "Nat.le_of_ble_eq_true", "Nat.not_le_of_not_ble_eq_true"],
  "name": "Nat.decLe"},
 {"type": "AddSemigroup UInt32",
  "offspring":
  ["AddSemigroup.mk", "instAddUInt32", "UInt32.instAddSemigroupUInt32.proof_1"],
  "name": "UInt32.instAddSemigroupUInt32"},
 {"type": "FloatArray → List Float",
  "offspring": [],
  "name": "FloatArray.toList"},
 {"type":
  "∀ (a : Nat.Linear.Expr) (k : ℕ), sizeOf (Nat.Linear.Expr.mulR a k) = 1 + sizeOf a + sizeOf k",
  "offspring": ["Nat.Linear.Expr", "instSizeOfNat"],
  "name": "Nat.Linear.Expr.mulR.sizeOf_spec"},
 {"type":
  "∀ (x n p : ℕ), x < n * p → (n * p - Nat.succ x) / n = p - Nat.succ (x / n)",
  "offspring": [],
  "name": "Nat.mul_sub_div"},
 {"type": "{α : Type u} → Array α → List α",
  "offspring": ["Array.foldr"],
  "name": "Array.toList"},
 {"type": "Ord UInt16",
  "offspring": ["Ord.mk", "compareOfLessAndEq", "instLTUInt16"],
  "name": "instOrdUInt16"},
 {"type": "ReprAtom Bool",
  "offspring": ["ReprAtom.mk"],
  "name": "instReprAtomBool"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β → Option γ} (a : Option α) (b : Option β),\n  (Option.bind a fun x => Option.bind b (f x)) = Option.bind b fun y => Option.bind a fun x => f x y",
  "offspring": [],
  "name": "Option.bind_comm"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_!=_»"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β) (g : α → γ) (e' : β → γ) (b : β)\n  [hd : Decidable (∃ a, f a = b)], Function.extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b",
  "offspring": ["Subsingleton.elim", "Classical.propDecidable"],
  "name": "Function.extend_def"},
 {"type": "∀ {p q : Prop}, p = q ↔ (p ↔ q)",
  "offspring": ["Iff.symm", "iff_iff_eq"],
  "name": "eq_iff_iff"},
 {"type": "¬False ↔ True",
  "offspring": ["iff_true_intro", "not_false"],
  "name": "not_false_iff"},
 {"type": "Sort u → Lean.Syntax → Sort u",
  "offspring": [],
  "name": "autoParam"},
 {"type": "{R : Type u} → [self : AddGroupWithOne R] → ℤ → R → R",
  "offspring": [],
  "name": "AddGroupWithOne.gsmul"},
 {"type":
  "{A : Type u} → Sort u_1 → AddCommGroup A → AddCommGroup A → Sort u_1",
  "offspring": [],
  "name": "AddCommGroup.noConfusionType"},
 {"type": "∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b",
  "offspring": ["le_refl"],
  "name": "le_of_eq"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≤ b → max a b = b",
  "offspring": ["max_comm", "max_eq_left"],
  "name": "max_eq_right"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {b : Prop} {a' : α}, (∃ a, p a ∧ b ∧ a = a') ↔ p a' ∧ b",
  "offspring": [],
  "name": "exists_eq_right_right"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (cs : Nat.Linear.Certificate),\n  (Nat.Linear.PolyCnstr.denote ctx (Nat.Linear.Certificate.combine cs) → False) → Nat.Linear.Certificate.denote ctx cs",
  "offspring":
  ["cond",
   "Nat.Linear.Poly.denote_le",
   "Nat.Linear.Poly",
   "cond_true",
   "true_implies",
   "Nat.Linear.Certificate.of_combineHyps",
   "Nat.Linear.PolyCnstr.mul",
   "Nat.Linear.ExprCnstr.toNormPoly",
   "Nat.Linear.PolyCnstr",
   "Nat.Linear.PolyCnstr.denote",
   "Nat.Linear.Certificate",
   "Nat.Linear.Certificate.combineHyps",
   "Nat.Linear.PolyCnstr.denote_mul",
   "Nat.Linear.ExprCnstr.denote_toNormPoly"],
  "name": "Nat.Linear.Certificate.of_combine"},
 {"type": "{α : Sort u} → α → α", "offspring": [], "name": "id"},
 {"type": "{α : Type u} → Sort u_1 → ReprTuple α → ReprTuple α → Sort u_1",
  "offspring": [],
  "name": "ReprTuple.noConfusionType"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] (a b : α), a < b ∨ a ≥ b",
  "offspring": ["lt_or_le"],
  "name": "lt_or_ge"},
 {"type":
  "{ε σ α : Type u} → [inst : ToString ε] → [inst : ToString α] → ToString (EStateM.Result ε σ α)",
  "offspring": ["ToString.mk"],
  "name": "EStateM.instToStringResult"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x : ℕ),\n  x < 0 → ∀ (x_2 : x < Array.size self.arr), (Array.get self.arr { val := x, isLt := x_2 }).rank ≤ 0",
  "offspring": ["sorryAx"],
  "name": "UnionFind.rankMaxAux.proof_1"},
 {"type":
  "∀ {m : Type u → Type v} {α ε : Type u} [inst : Monad m] (x : m α), ExceptT.run (ExceptT.lift x) = Except.ok <$> x",
  "offspring": [],
  "name": "ExceptT.run_lift"},
 {"type": "∀ (p : Prop), Subsingleton p",
  "offspring": ["instSubsingleton.proof_1"],
  "name": "instSubsingleton"},
 {"type":
  "∀ {α : Type u_1} {p : Option α → Prop}, (∀ (x : Option α), p x) ↔ p none ∧ ∀ (x : α), p (some x)",
  "offspring": [],
  "name": "Option.forall"},
 {"type": "sizeOf Tactic.NormCast.CoeFnType.coeFn = 1",
  "offspring": [],
  "name": "Tactic.NormCast.CoeFnType.coeFn.sizeOf_spec"},
 {"type": "{α : Type u_1} → Set α → Set (Set α)",
  "offspring": ["setOf", "Subset.subset"],
  "name": "Set.powerset"},
 {"type":
  "{p : ℕ → Sort u} → (a : ℕ) → p 0 → ((n : ℕ) → ((m : ℕ) → m ≤ n → p m) → p (Nat.succ n)) → p a",
  "offspring": ["Nat.strong_rec_on", "Nat.lt_succ_of_le"],
  "name": "Nat.case_strong_rec_on"},
 {"type": "∀ {a b : Prop}, a ∧ b → b", "offspring": [], "name": "And.right"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → DecidableEq (Array α)",
  "offspring":
  ["Array.isEqv",
   "Decidable.decide",
   "Array.instDecidableEqArray.proof_1",
   "Array.instDecidableEqArray.proof_2",
   "Array.instDecidableEqArray.proof_3"],
  "name": "Array.instDecidableEqArray"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term¬_»"},
 {"type":
  "∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((ExistsUnique fun a => p a) ↔ ExistsUnique fun a => q a)",
  "offspring": ["exists_congr", "and_congr", "forall_congr'", "imp_congr_left"],
  "name": "exists_unique_congr"},
 {"type":
  "∀ {σ : Type u_1} {m : Type u_1 → Type u_2}, LawfulMonad (StateCpsT σ m)",
  "offspring": ["StateCpsT.instLawfulMonadStateCpsTInstMonadStateCpsT.proof_1"],
  "name": "StateCpsT.instLawfulMonadStateCpsTInstMonadStateCpsT"},
 {"type": "Substring → String.Pos",
  "offspring": [],
  "name": "Substring.startPos"},
 {"type":
  "∀ {n : ℕ} (a b : Fin n), Option.isSome (Fin.checkedSub a b) = true ↔ ↑b ≤ ↑a",
  "offspring":
  ["decide_eq_true_iff",
   "eq_false_of_decide",
   "Nat.le_of_not_lt",
   "decide_eq_false",
   "Nat.not_lt_of_le"],
  "name": "Fin.checked_sub_spec"},
 {"type": "∀ {a : Prop}, ¬¬¬a ↔ ¬a",
  "offspring": ["mt", "not_not_intro"],
  "name": "not_not_not"},
 {"type": "{α : Type u_1} → [inst : DecidableEq α] → List α → ℕ",
  "offspring": [],
  "name": "List.card"},
 {"type": "Type → Type → (Type → Type) → Type → Type",
  "offspring": [],
  "name": "StateRefT'"},
 {"type": "∀ (a b : ℕ), ((a == b) = true) = (a = b)",
  "offspring":
  ["eq_of_beq",
   "instBEqNat",
   "Nat.instLawfulBEqNatInstBEqNat",
   "LawfulBEq.rfl"],
  "name": "Nat.beq_eq_true_eq"},
 {"type":
  "∀ {α : Type u_1} {a b c : List α} {x : α}, a ++ b = x :: c ↔ a = [] ∧ b = x :: c ∨ ∃ a', a = x :: a' ∧ c = a' ++ b",
  "offspring":
  ["List.nil_append",
   "true_and",
   "eq_false'",
   "false_and",
   "exists_false",
   "or_false",
   "List.cons_append",
   "List.cons.injEq",
   "false_or",
   "and_self"],
  "name": "List.append_eq_cons_iff"},
 {"type":
  "{n : ℕ} → {motive : (a : ℕ) → Nat.le n a → Prop} → {a : ℕ} → Nat.le n a → Prop",
  "offspring": [],
  "name": "Nat.le.below"},
 {"type": "∀ {a b : ℕ}, a ≤ b → a + (b - a) = b",
  "offspring": ["Nat.zero_eq", "Nat.sub_zero", "Nat.zero_add"],
  "name": "Nat.add_sub_of_le"},
 {"type": "ToStream String Substring",
  "offspring": ["ToStream.mk"],
  "name": "instToStreamStringSubstring"},
 {"type": "LT ℕ", "offspring": ["LT.mk", "Nat.lt"], "name": "instLTNat"},
 {"type":
  "∀ {α : Type u_1} {arr : Array (UFNode α)} {n : ℕ} {m : UFModel n},\n  UFModel.Models arr m →\n    ∀ (k : ℕ),\n      k = n + 1 →\n        ∀ (x : α), UFModel.Models (Array.push arr { parent := n, value := x, rank := 0 }) (UFModel.push m k (_ : n ≤ k))",
  "offspring":
  ["And.imp",
   "UFModel.Agrees.push",
   "instDecidableFalse",
   "lt_irrefl",
   "dite_false"],
  "name": "UFModel.Models.push"},
 {"type": "{α : Type u} → [inst : BEq α] → List α → α → Bool",
  "offspring": ["List.elem"],
  "name": "List.contains"},
 {"type": "∀ {m n : ℕ}, Nat.pow m n = m ^ n",
  "offspring": [],
  "name": "Nat.Nat.pow_eq"},
 {"type":
  "{m : Type u → Type v} →\n  {n : Type u → Type w} → [self : MonadControl m n] → {α : Type u} → m (MonadControl.stM m n α) → n α",
  "offspring": [],
  "name": "MonadControl.restoreM"},
 {"type":
  "{α : Type u_1} → (lt : α → α → Bool) → EmptyCollection (BinaryHeap α lt)",
  "offspring": ["EmptyCollection.mk", "BinaryHeap.empty"],
  "name": "BinaryHeap.instEmptyCollectionBinaryHeap"},
 {"type": "∀ (a b : Prop), (a ↔ b) ↔ (a → b) ∧ (b → a)",
  "offspring": [],
  "name": "iff_iff_implies_and_implies"},
 {"type": "Ord ℤ",
  "offspring": ["Ord.mk", "compareOfLessAndEq", "Int.instLTInt"],
  "name": "instOrdInt"},
 {"type": "{n : ℕ} → Random (Fin (Nat.succ n))",
  "offspring": ["Random.mk", "Random.randFin"],
  "name": "Random.instRandomFinSucc"},
 {"type":
  "∀ {c : Prop} {h : Decidable c} (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = e hnc",
  "offspring": [],
  "name": "dif_neg"},
 {"type": "Type u → Type u", "offspring": [], "name": "Inter"},
 {"type": "ℕ", "offspring": [], "name": "UInt16.size"},
 {"type": "Inhabited Float",
  "offspring": ["Float.mk", "FloatSpec.val", "floatSpec"],
  "name": "instInhabitedFloat"},
 {"type": "{n : ℕ} → Inhabited (Fin (n + 1))",
  "offspring": [],
  "name": "Fin.instInhabitedFinHAddNatInstHAddInstAddNatOfNat"},
 {"type": "Nat.Linear.Poly → Nat.Linear.Poly",
  "offspring": ["cond", "instBEqNat", "Nat.add"],
  "name": "Nat.Linear.Poly.fuse"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] {α' : Sort u_1} (g : (a : α) → β a) {f : α' → α} {i : α}\n  (a : β i), (∀ (x : α'), f x ≠ i) → (fun j => Function.update g i a (f j)) = fun j => g (f j)",
  "offspring": ["Function.update_noteq"],
  "name": "Function.update_comp_eq_of_forall_ne'"},
 {"type": "Prop", "offspring": [], "name": "True"},
 {"type": "Substring → String.Pos → Bool",
  "offspring": ["instBEqNat"],
  "name": "Substring.atEnd"},
 {"type":
  "{m : Type u₁ → Type u₂} →\n  {ρ : Type u} →\n    {α : Type v} →\n      {d : Membership α ρ} →\n        [self : ForIn' m ρ α d] →\n          {β : Type u₁} → [inst : Monad m] → (x : ρ) → β → ((a : α) → a ∈ x → β → m (ForInStep β)) → m β",
  "offspring": [],
  "name": "ForIn'.forIn'"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt), BinaryHeap.max self = BinaryHeap.max self",
  "offspring": ["BinaryHeap.max"],
  "name": "BinaryHeap.insertExtractMax.proof_1"},
 {"type": "{α : Type u} → Sort u_1 → BEq α → BEq α → Sort u_1",
  "offspring": [],
  "name": "BEq.noConfusionType"},
 {"type": "{α : Type u} → [inst : DecidableEq α] → Inter (List α)",
  "offspring": ["Inter.mk", "List.inter"],
  "name": "List.instInterList"},
 {"type":
  "{α : Sort uA} →\n  {β : Sort uB} →\n    {φ : Sort uC} →\n      {s₁ : Setoid α} →\n        {s₂ : Setoid β} →\n          (f : α → β → φ) →\n            (∀ (a₁ : α) (b₁ : β) (a₂ : α) (b₂ : β), a₁ ≈ a₂ → b₁ ≈ b₂ → f a₁ b₁ = f a₂ b₂) →\n              Quotient s₁ → Quotient s₂ → φ",
  "offspring":
  ["Quotient.lift", "Quotient.lift₂.proof_1", "Quotient.lift₂.proof_2"],
  "name": "Quotient.lift₂"},
 {"type":
  "{α : Type u_1} → (a b : Array α) → Array.size a = Array.size b → (α → α → Bool) → ℕ → Bool",
  "offspring":
  ["WellFounded.fix",
   "Array.isEqvAux.proof_1",
   "Array.get",
   "Array.isEqvAux.proof_2",
   "Array.isEqvAux.proof_3"],
  "name": "Array.isEqvAux"},
 {"type": "Lean.Expr → Lean.MetaM Lean.Meta.Simp.Result",
  "offspring":
  ["Alternative.failure",
   "Tactic.NormCast.proveEqUsingDown",
   "Tactic.NormCast.isNumeral?"],
  "name": "Tactic.NormCast.numeralToCoe"},
 {"type": "{M₀ : Type u} → [self : MonoidWithZero M₀] → SemigroupWithZero M₀",
  "offspring":
  ["SemigroupWithZero.mk",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.mul_zero"],
  "name": "MonoidWithZero.toSemigroupWithZero"},
 {"type": "{α : Type u} → [inst : BEq α] → α → List α → Bool",
  "offspring": ["not", "List.elem"],
  "name": "List.notElem"},
 {"type":
  "∀ {α : Type u} {x y : Option α}, (∀ (z : α), x = some z ↔ y = some z) → x = y",
  "offspring": [],
  "name": "Option.eq_of_eq_some"},
 {"type":
  "{α : Sort u} →\n  {s : Setoid α} →\n    {motive : Quotient s → Sort v} →\n      (q : Quotient s) → (f : (a : α) → motive (Quotient.mk s a)) → (∀ (a b : α), a ≈ b → HEq (f a) (f b)) → motive q",
  "offspring": ["Quot.hrecOn"],
  "name": "Quotient.hrecOn"},
 {"type": "∀ (a b c : UInt32), a * (b + c) = a * b + a * c",
  "offspring":
  ["UInt32.add_def",
   "UInt32.mul_def",
   "UInt32.mk",
   "UInt32.eq_of_val_eq",
   "Distrib.left_distrib"],
  "name": "UInt32.instSemiringUInt32.proof_7"},
 {"type": "Type u → Type v → Type (max u v)", "offspring": [], "name": "Pow"},
 {"type": "{ε α : Type} → OrElse (EIO ε α)",
  "offspring": ["OrElse.mk", "MonadExcept.orElse"],
  "name": "instOrElseEIO"},
 {"type":
  "∀ {α : Type u_1} {motive : (a a_1 : List α) → a ~ a_1 → Prop}, List.Perm.below (_ : [] ~ [])",
  "offspring": [],
  "name": "List.Perm.below.nil"},
 {"type": "{α : Type u_1} → [inst : Ord α] → LT α",
  "offspring":
  ["LT.mk", "Ordering", "instBEqOrdering", "Ord.compare", "Ordering.lt"],
  "name": "ltOfOrd"},
 {"type": "∀ {m n : ℕ}, m < n ↔ m ≤ n ∧ ¬n ≤ m",
  "offspring": ["Nat.le_of_lt", "Nat.not_le_of_gt", "Nat.gt_of_not_le"],
  "name": "Nat.lt_iff_le_not_le"},
 {"type":
  "∀ {α : Type u_1} (f : α → α) {m n : ℕ} (l : List α), m ≠ n → List.get? (List.modifyNth f m l) n = List.get? l n",
  "offspring":
  ["List.get?_modifyNth",
   "Functor.map",
   "Option.instFunctorOption",
   "if_neg",
   "instDecidableEqNat",
   "id_map'",
   "instLawfulFunctorOptionInstFunctorOption"],
  "name": "List.get?_modifyNth_ne"},
 {"type": "{α : Type u_1} → [inst : Append α] → HAppend α α α",
  "offspring": ["HAppend.mk", "Append.append"],
  "name": "instHAppend"},
 {"type":
  "{α : Type u} → {β : Type v} → (α → β) → Task α → optParam Task.Priority Task.Priority.default → Task β",
  "offspring": ["Task.pure", "Task.get"],
  "name": "Task.map"},
 {"type": "FloatSpec", "offspring": [], "name": "floatSpec"},
 {"type": "∀ {a b : UInt16}, a.val = b.val → a = b",
  "offspring": ["UInt16.mk"],
  "name": "UInt16.eq_of_val_eq"},
 {"type": "∀ (v : ℕ), sizeOf (PNonScalar.mk v) = 1 + sizeOf v",
  "offspring": ["instSizeOfNat"],
  "name": "PNonScalar.mk.sizeOf_spec"},
 {"type": "{α : Type u_1} → (α → Bool) → Array α → Array α × Array α",
  "offspring":
  ["Id.run",
   "ForIn.forIn",
   "Id.instMonadId",
   "Array.push",
   "MProd.snd",
   "MProd.fst"],
  "name": "Array.partition"},
 {"type": "∀ (x x_1 : UInt64), { val := (x + x_1).1 } = { val := (x_1 + x).1 }",
  "offspring": ["UInt64.mk", "AddCommSemigroup.add_comm"],
  "name": "UInt64.instAddCommSemigroupUInt64.proof_1"},
 {"type": "∀ {a b c d : ℤ}, a ≤ b → c < d → a - d < b - c",
  "offspring": ["Int.add_lt_add_of_le_of_lt", "Int.neg_lt_neg"],
  "name": "Int.sub_lt_sub_of_le_of_lt"},
 {"type":
  "{α : Type u_1} → {motive : (a a_1 : List α) → a ~ a_1 → Prop} → {a a_1 : List α} → a ~ a_1 → Prop",
  "offspring": [],
  "name": "List.Perm.below"},
 {"type": "(α : Sort u) → α → Sort v → Sort (max 1 v)",
  "offspring": [],
  "name": "CoeT"},
 {"type": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "offspring": [],
  "name": "Subtype"},
 {"type": "{α : Type u_1} → (α → Bool) → Array α → ℕ → Array α → Array α",
  "offspring":
  ["WellFounded.fix",
   "Array.push",
   "WellFoundedRelation.rel",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Array.get",
   "Nat.sub_succ_lt_self"],
  "name": "Array.takeWhile.go"},
 {"type":
  "{α : Type} → [inst : Inhabited α] → (α → α → Bool) → ℕ → α → Array α → ℕ → ℕ → ℕ × Array α",
  "offspring":
  ["WellFounded.fix",
   "Array.get!",
   "WellFoundedRelation.rel",
   "sizeOf_nat",
   "Nat.lt_eq",
   "Array.swap!",
   "Nat.sub_succ_lt_self"],
  "name": "Array.qpartition.loop"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {γ : Sort u_1} (f : α → β) {g : γ → α},\n  Function.bijective g → (Function.bijective (f ∘ g) ↔ Function.bijective f)",
  "offspring":
  ["and_congr",
   "Function.injective.of_comp_iff'",
   "Function.surjective.of_comp_iff",
   "Function.bijective.surjective"],
  "name": "Function.bijective.of_comp_iff"},
 {"type": "{α : Type u} → α → Array α",
  "offspring": ["Array.mkArray"],
  "name": "Array.singleton"},
 {"type": "{α β : Sort u} → α = β → β → α", "offspring": [], "name": "Eq.mpr"},
 {"type":
  "∀ (k l : ℕ) {m n : ℕ}, Nat.coprime m n → Nat.coprime (Nat.gcd k m) (Nat.gcd l n)",
  "offspring": ["Nat.coprime.gcd_right", "Nat.coprime.gcd_left"],
  "name": "Nat.coprime.gcd_both"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → (List α → α → List α → β) → List α → List α → List β",
  "offspring": ["List.concat"],
  "name": "List.mapWithPrefixSuffixAux"},
 {"type": "∀ {α : Type u_1} [inst : DecidableEq α], List.card [] = 0",
  "offspring": [],
  "name": "List.card_nil"},
 {"type":
  "∀ {α : Sort u} {b c : Prop} [dec_b : Decidable b] [dec_c : Decidable c] {x y u v : α},\n  (b ↔ c) → x = u → y = v → (if b then x else y) = if c then u else v",
  "offspring": ["if_ctx_congr"],
  "name": "if_congr"},
 {"type":
  "∀ {a b : Prop} [inst : Decidable a] [inst : Decidable b], (¬a ↔ b) ↔ (¬b ↔ a)",
  "offspring":
  ["iff_def", "and_congr", "Decidable.not_imp_comm", "imp_not_comm"],
  "name": "Decidable.not_iff_comm"},
 {"type": "∀ {n m k : ℕ}, n < m → k > 0 → k * n < k * m",
  "offspring":
  ["Nat.lt_of_lt_of_le",
   "Nat.add_lt_add_left",
   "Nat.mul",
   "Nat.mul_le_mul_left",
   "Nat.succ_le_of_lt",
   "Nat.mul_succ"],
  "name": "Nat.mul_lt_mul_of_pos_left"},
 {"type": "∀ {A : Type u} [inst : AddGroup A] {a b : A}, a + b = 0 → -a = b",
  "offspring": ["left_neg_eq_right_neg", "neg_add_self"],
  "name": "neg_eq_of_add_eq_zero"},
 {"type": "StdGen → ℕ", "offspring": [], "name": "StdGen.s1"},
 {"type": "{α : Type u} → [inst : LT α] → List α → List α → Prop",
  "offspring": [],
  "name": "List.lt"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (e e' : Nat.Linear.Expr),\n  (Nat.Linear.Expr.toNormPoly e == Nat.Linear.Expr.toPoly e') = true →\n    Nat.Linear.Expr.denote ctx e = Nat.Linear.Expr.denote ctx e'",
  "offspring": [],
  "name": "Nat.Linear.Expr.eq_of_toNormPoly_eq"},
 {"type": "outParam (Type u) → (Type u → Type v) → Type v",
  "offspring": [],
  "name": "MonadReader"},
 {"type": "{α : Sort u} → (α → α → Bool) → Prop",
  "offspring": [],
  "name": "is_dec_eq"},
 {"type": "Inhabited ByteArray",
  "offspring": ["ByteArray.empty"],
  "name": "ByteArray.instInhabitedByteArray"},
 {"type":
  "∀ {α β : Type u_1} {x : Option α} {f : α → β} {b : β}, f <$> x = some b ↔ ∃ a, x = some a ∧ f a = b",
  "offspring":
  ["Option.map_eq_map",
   "Option.map_none'",
   "eq_false'",
   "false_and",
   "exists_false",
   "Option.map_some'",
   "Option.some.injEq",
   "exists_eq_left'"],
  "name": "Option.map_eq_some"},
 {"type":
  "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : Fin n), Monoid.npow 0 x = 1",
  "offspring": ["Monoid.npow_zero'"],
  "name": "instCommSemiringFin.proof_10"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type w} → {β : Type u} → (α → m (Option β)) → List α → m (Option β)",
  "offspring": [],
  "name": "List.findSomeM?"},
 {"type": "∀ {m n : ℕ}, m < Nat.succ n → m ≤ n",
  "offspring": ["Nat.le_of_succ_le_succ"],
  "name": "Nat.le_of_lt_succ"},
 {"type": "LawfulBEq String",
  "offspring":
  ["LawfulBEq.mk", "of_decide_eq_self_eq_true", "instDecidableEqString"],
  "name": "instLawfulBEqStringInstBEqInstDecidableEqString.proof_1"},
 {"type": "∀ {α : Type u_1}, Option.map id = id",
  "offspring": ["Option.map_id"],
  "name": "Option.map_id'"},
 {"type":
  "∀ (x : ℕ), { val := ↑(x + 1) } = { val := ((fun n => { val := ↑n }) x + 1).1 }",
  "offspring": ["Fin.ofNat'_succ", "UInt32.size"],
  "name": "UInt32.instSemiringUInt32.proof_12"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {a a' : α} (b : α → β),\n  a = a' →\n    (let x := a;\n      b x) =\n      let x := a';\n      b x",
  "offspring": [],
  "name": "let_val_congr"},
 {"type":
  "∀ {α : Type u₁} {β : Type u₂} {g : β → α} {f : α → β}, Function.LeftInverse g f → g ∘ f = id",
  "offspring": [],
  "name": "Function.LeftInverse.id"},
 {"type": "Type u → ℕ → Type u", "offspring": [], "name": "OfNat"},
 {"type": "Mod UInt8",
  "offspring": ["Mod.mk", "UInt8.mod"],
  "name": "instModUInt8"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "command_Lemma___"},
 {"type": "{n : ℕ} → Fin n → Fin n → Option (Fin n)",
  "offspring": ["Fin.overflowingAdd"],
  "name": "Fin.checkedAdd"},
 {"type": "Lean.PrettyPrinter.Unexpander",
  "offspring": [],
  "name": "unexpandEqRec"},
 {"type":
  "{α : Type u_1} →\n  {β : Type u_2} → {p : α → Prop} → ((a : α) → p a → β) → (x : Option α) → (∀ (a : α), a ∈ x → p a) → Option β",
  "offspring": ["Option.pmap.proof_1"],
  "name": "Option.pmap"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [self : MonadState σ m] → m σ",
  "offspring": [],
  "name": "MonadState.get"},
 {"type": "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a",
  "offspring": ["Iff.symm", "lt_iff_not_ge"],
  "name": "not_le"},
 {"type": "{α : Type u_1} → (α → α) → List α → List α",
  "offspring": [],
  "name": "List.modifyHead"},
 {"type":
  "∀ {A : Type u} [inst : Add A] [self : IsAddLeftCancel A] (a b c : A), a + b = a + c → b = c",
  "offspring": [],
  "name": "IsAddLeftCancel.add_left_cancel"},
 {"type":
  "∀ {α : Type u_1} {l l₁ l₂ : List α}, List.disjoint (l₁ ++ l₂) l → List.disjoint l₁ l",
  "offspring": ["List.disjoint_append_left"],
  "name": "List.disjoint_of_disjoint_append_left_left"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : β → β → Prop} {a : α} (f : α → β), Acc r (f a) → Acc (InvImage r f) a",
  "offspring": ["Acc.intro"],
  "name": "InvImage.accessible.proof_1"},
 {"type":
  "{α₁ α₂ β : Type u} → (α₁ → α₂ → β) → ((α₁ → α₂ → β) → α₁ → α₂ → β) → α₁ → α₂ → β",
  "offspring": ["bfix2", "USize.size"],
  "name": "fixCore2"},
 {"type": "∀ {n m : ℕ}, n ≤ m → n = m ∨ n < m",
  "offspring": ["Nat.succ_le_succ", "Nat.zero_le", "Nat.not_succ_le_zero"],
  "name": "Nat.eq_or_lt_of_le"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "tacticSimp_wf"},
 {"type": "{α : Type u} → List α → (α → Bool) → Bool",
  "offspring": ["List.foldr"],
  "name": "List.all"},
 {"type": "Prop → Prop → Prop", "offspring": [], "name": "Iff"},
 {"type": "∀ {n : ℕ}, 0 < n ↔ n ≠ 0",
  "offspring":
  ["of_decide_eq_false",
   "Decidable.decide",
   "Nat.succ_ne_zero",
   "Nat.pos_of_ne_zero"],
  "name": "Nat.pos_iff_ne_zero"},
 {"type": "{R : Type u} → [self : NonUnitalNonAssocSemiring R] → Distrib R",
  "offspring":
  ["Distrib.mk",
   "NonUnitalNonAssocSemiring.left_distrib",
   "NonUnitalNonAssocSemiring.right_distrib"],
  "name": "NonUnitalNonAssocSemiring.toDistrib"},
 {"type": "∀ {n m : ℕ} (k : ℕ), n ≤ m → k - m ≤ k - n",
  "offspring": ["Nat.le.dest", "Nat.sub_sub", "Nat.sub_le"],
  "name": "Nat.sub_le_sub_left"},
 {"type": "∀ {α : Sort u} (a : α), { down := a }.down = a",
  "offspring": [],
  "name": "PLift.down_up"},
 {"type": "{n : ℕ} → ShiftLeft (Fin n)",
  "offspring": ["ShiftLeft.mk", "Fin.shiftLeft"],
  "name": "Fin.instShiftLeftFin"},
 {"type":
  "{m : Type u_1 → Type u_2} →\n  {α : Type u_3} →\n    {β : Type u_1} →\n      [inst : Monad m] → (α → m (Option β)) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → m (Array β)",
  "offspring": ["Array.foldlM", "Array.push"],
  "name": "Array.filterMapM"},
 {"type": "{f : Type u → Type v} → Sort u_1 → SeqLeft f → SeqLeft f → Sort u_1",
  "offspring": [],
  "name": "SeqLeft.noConfusionType"},
 {"type":
  "{α₁ α₂ α₃ β : Type u} → (α₁ → α₂ → α₃ → β) → ((α₁ → α₂ → α₃ → β) → α₁ → α₂ → α₃ → β) → α₁ → α₂ → α₃ → β",
  "offspring": ["bfix3", "USize.size"],
  "name": "fixCore3"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HPow α β γ",
  "offspring": [],
  "name": "HPow.mk"},
 {"type": "∀ (n m : ℕ), n - m + min n m = n",
  "offspring":
  ["min",
   "Nat.sub_eq_sub_min",
   "Nat.sub_add_cancel",
   "min_le_left",
   "Nat.instLinearOrderNat"],
  "name": "Nat.sub_add_min_cancel"},
 {"type": "∀ {n : ℕ} [inst : Nonempty (Fin n)] (x : Fin n), x * 0 = 0",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Fin.mul_def",
   "Fin.zero_def",
   "Nat.mul_zero",
   "Nat.zero_mod",
   "Fin.size_positive"],
  "name": "instMonoidWithZeroFin.proof_5"},
 {"type": "{α : Type u} → [inst : BEq α] → List α → List α → Bool",
  "offspring": ["List.isPrefixOf", "List.reverse"],
  "name": "List.isSuffixOf"},
 {"type": "{α : Type u} → {β : Type v} → (α → β → β) → β → Subarray α → β",
  "offspring": ["Id.run", "Subarray.foldrM", "Id.instMonadId"],
  "name": "Subarray.foldr"},
 {"type": "ℤ → String", "offspring": ["Nat.repr"], "name": "Int.repr"},
 {"type": "∀ {α β : Sort u} (h : α = β) (a : α), HEq (cast h a) a",
  "offspring": [],
  "name": "cast_heq"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → {f : α → β} → [inst : DecidableEq β] → Function.injective f → DecidableEq α",
  "offspring": ["decidable_of_iff", "Function.injective.eq_iff"],
  "name": "Function.injective.decidable_eq"},
 {"type": "List Lean.Name → Lean.CoreM (List Mathlib.Tactic.Lint.NamedLinter)",
  "offspring": ["List.mapM", "Mathlib.Tactic.Lint.getLinter"],
  "name": "Mathlib.Tactic.Lint.getLinters"},
 {"type": "(True ↔ False) → False",
  "offspring": ["trivial"],
  "name": "false_of_true_iff_false"},
 {"type": "False ≠ True", "offspring": ["trivial"], "name": "false_ne_true"},
 {"type": "∀ {α : Sort u_1} (n : α), sizeOf n = 0",
  "offspring": [],
  "name": "sizeOf_default"},
 {"type": "∀ {k m n : ℕ}, n ≤ m → k ∣ m → k ∣ n → k ∣ m - n",
  "offspring": ["Nat.dvd_add_iff_left", "Nat.sub_add_cancel"],
  "name": "Nat.dvd_sub"},
 {"type": "∀ (ub : ℕ), WellFounded (Nat.Up ub)",
  "offspring":
  ["Subrelation.wf",
   "WellFoundedRelation.rel",
   "Nat.sub_lt_sub_left",
   "WellFoundedRelation.wf"],
  "name": "Nat.Up.WF"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} (toFun : α → β) (invFun : β → α) (left_inv : Function.LeftInverse invFun toFun)\n  (right_inv : Function.RightInverse invFun toFun) (toFun_1 : α → β) (invFun_1 : β → α)\n  (left_inv_1 : Function.LeftInverse invFun_1 toFun_1) (right_inv_1 : Function.RightInverse invFun_1 toFun_1),\n  ({ toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv } =\n      { toFun := toFun_1, invFun := invFun_1, left_inv := left_inv_1, right_inv := right_inv_1 }) =\n    (toFun = toFun_1 ∧ invFun = invFun_1)",
  "offspring": ["Equiv.mk"],
  "name": "Equiv.mk.injEq"},
 {"type": "Lean.Expr → Lean.Expr → Lean.MetaM Lean.Expr",
  "offspring": [],
  "name": "Tactic.NormCast.mkCoe"},
 {"type": "Type", "offspring": [], "name": "Mathlib.Prelude.Rename.RenameMap"},
 {"type":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → α → Option α",
  "offspring": [],
  "name": "Option.guard"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type w} → List α → (α → m PUnit) → m PUnit",
  "offspring": [],
  "name": "List.forM"},
 {"type":
  "∀ {n : ℕ} (a m : Fin n), a % m = { val := ↑a % ↑m % n, isLt := (_ : ↑a % ↑m % n < n) }",
  "offspring": [],
  "name": "Fin.mod_def"},
 {"type": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → Zero M₀",
  "offspring": [],
  "name": "MulZeroOneClass.toZero"},
 {"type": "USize → USize → USize",
  "offspring": ["USize.mk", "Fin.xor", "USize.size"],
  "name": "USize.xor"},
 {"type": "∀ (x : ℕ) {y : ℕ}, y > 0 → x % y < y",
  "offspring": ["Nat.mod.inductionOn"],
  "name": "Nat.mod_lt"},
 {"type": "{α : Type u} → Array α → ℕ → ℕ → Array α",
  "offspring": ["Array.ofSubarray", "Array.toSubarray"],
  "name": "Array.extract"},
 {"type": "{α : Type u_1} → [inst : BEq α] → List α → List α",
  "offspring": ["List.eraseDupsAux"],
  "name": "List.eraseDups"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) (Int.ofNat x) = (fun n => { val := ↑n }) (Int.ofNat x)",
  "offspring": [],
  "name": "UInt8.instRingUInt8.proof_7"},
 {"type": "{α : Type u} → [self : OrElse α] → α → (Unit → α) → α",
  "offspring": [],
  "name": "OrElse.orElse"},
 {"type": "System.Platform.numBits = 32 ∨ System.Platform.numBits = 64",
  "offspring": ["Subtype.property"],
  "name": "System.Platform.numBits_eq"},
 {"type": "Nat.Linear.Poly → Option ℕ",
  "offspring": ["Nat.Linear.Var", "cond", "instBEqNat", "Nat.Linear.fixedVar"],
  "name": "Nat.Linear.Poly.isNum?"},
 {"type": "∀ (as : ByteArray), ByteArray.size as ≤ ByteArray.size as",
  "offspring": ["Nat.le_refl", "ByteArray.size"],
  "name": "ByteArray.forIn.proof_1"},
 {"type":
  "∀ {α : Sort u} {f : α → α},\n  Function.involutive f → ∀ (P : Prop) [inst : Decidable P] (x : α), f (if P then x else f x) = if ¬P then x else f x",
  "offspring": ["apply_ite", "ite_not"],
  "name": "Function.involutive.ite_not"},
 {"type": "UInt32 → UInt8",
  "offspring": ["Nat.toUInt8", "UInt32.toNat"],
  "name": "UInt32.toUInt8"},
 {"type": "∀ {α : Type u_1} {p : α → Prop}, (∃ a, a ∈ none ∧ p a) → False",
  "offspring": [],
  "name": "Option.decidable_exists_mem.proof_1"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} [inst : DecidableEq α] (a : α) (f : (a : α) → β a), Function.update f a (f a) = f",
  "offspring": ["Function.update_eq_iff"],
  "name": "Function.update_eq_self"},
 {"type": "∀ {m k : ℕ} (n : ℕ), m ∣ k → Nat.gcd n m ∣ Nat.gcd n k",
  "offspring":
  ["Nat.dvd_gcd", "Nat.gcd_dvd_left", "Nat.dvd_trans", "Nat.gcd_dvd_right"],
  "name": "Nat.gcd_dvd_gcd_of_dvd_right"},
 {"type":
  "{ε σ α : Type u} → [inst : Repr ε] → [inst : Repr α] → Repr (EStateM.Result ε σ α)",
  "offspring": ["reprArg"],
  "name": "EStateM.instReprResult"},
 {"type":
  "{β : Type v} → {m : Type v → Type w} → [inst : Monad m] → FloatArray → β → (Float → β → m (ForInStep β)) → m β",
  "offspring": ["USize.ofNat", "FloatArray.size"],
  "name": "FloatArray.forInUnsafe"},
 {"type":
  "∀ {α : Sort u} {f : α → α}, Function.involutive f → Function.surjective f",
  "offspring": [],
  "name": "Function.involutive.surjective"},
 {"type": "(f : Type u → Type v) → [inst : Applicative f] → Prop",
  "offspring": [],
  "name": "LawfulApplicative"},
 {"type":
  "{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadQuotation m] → Lean.Syntax → m Lean.Syntax",
  "offspring": [],
  "name": "Tactic.TryThis.replaceMVarsByUnderscores"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_2} [h : Nonempty α] [h2 : Nonempty β], Nonempty (α × β)",
  "offspring": ["instNonemptyProd.proof_1"],
  "name": "instNonemptyProd"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«term_≠_»"},
 {"type": "{α : Type u} → α → USize", "offspring": [], "name": "ptrAddrUnsafe"},
 {"type": "∀ {b a : ℕ}, b < a → a ≠ 0",
  "offspring": ["Nat.not_lt_zero"],
  "name": "Nat.not_eq_zero_of_lt"},
 {"type":
  "∀ {α : Type u_1} (p : α → Prop) (a : α) (l : List α), (∃ x, x ∈ a :: l ∧ p x) ↔ p a ∨ ∃ x, x ∈ l ∧ p x",
  "offspring":
  ["List.or_exists_of_exists_mem_cons",
   "Or.elim",
   "List.exists_mem_cons_of",
   "List.exists_mem_cons_of_exists"],
  "name": "List.exists_mem_cons_iff"},
 {"type": "∀ {a b c : Prop}, a ∧ (b ∨ c) ↔ a ∧ b ∨ a ∧ c",
  "offspring": ["Or.imp", "And.imp_right"],
  "name": "and_or_distrib_left"},
 {"type": "∀ {R : Type u} [self : Semiring R] (x : R), Semiring.npow 0 x = 1",
  "offspring": [],
  "name": "Semiring.npow_zero'"},
 {"type": "{n : ℕ} → Fin n → Fin n → Bool × Fin n",
  "offspring": ["Decidable.decide"],
  "name": "Fin.underflowingSub"},
 {"type": "{α σ : Type u} → α → σ → DoResultSBC α σ",
  "offspring": [],
  "name": "DoResultSBC.pureReturn"},
 {"type":
  "∀ {α : Type u_1} {s₁ s₂ t₁ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → List.length t₁ = List.length t₂ → t₁ = t₂",
  "offspring": ["List.append_inj'"],
  "name": "List.append_inj_right'"},
 {"type":
  "∀ {α : Sort u_1} {β : α → Sort v}, Nonempty (PSigma β) ↔ ∃ a, Nonempty (β a)",
  "offspring": ["Nonempty", "PSigma"],
  "name": "nonempty_psigma"},
 {"type": "∀ {a b : ℕ}, a ≥ b → a % b = (a - b) % b",
  "offspring": ["Nat.eq_zero_or_pos", "Nat.sub_zero", "if_pos", "Nat.mod_eq"],
  "name": "Nat.mod_eq_sub_mod"},
 {"type": "∀ {a : Prop}, (a ↔ True) → a",
  "offspring": ["True.intro"],
  "name": "of_iff_true"},
 {"type":
  "{α : Type u_1} → {β : Type u_2} → [inst : Repr α] → [inst : ReprTuple β] → ReprTuple (α × β)",
  "offspring": ["ReprTuple.mk", "List", "ReprTuple.reprTuple", "repr"],
  "name": "instReprTupleProd"},
 {"type": "{m : Type u_1 → Type u_2} → ForIn m FloatArray Float",
  "offspring": ["ForIn.mk", "FloatArray.forIn"],
  "name": "FloatArray.instForInFloatArrayFloat"},
 {"type": "Lean.TrailingParserDescr", "offspring": [], "name": "«stx_,*,?»"},
 {"type": "{n : ℕ} → Fin n → Fin n → Fin n",
  "offspring": ["Nat.land", "Fin.land.proof_1"],
  "name": "Fin.land"},
 {"type":
  "∀ {α : Type u_1} [inst : Subsingleton α] (a : α), Option.choice α = some a",
  "offspring": ["dif_pos", "Option.some.injEq", "Subsingleton.elim"],
  "name": "Option.choice_eq"},
 {"type": "{n : ℕ} → [inst : Nonempty (Fin n)] → CommSemiring (Fin n)",
  "offspring":
  ["CommSemiring.mk",
   "instCommSemiringFin.proof_12",
   "AddMonoidWithOne",
   "AddCommMonoid",
   "CommSemigroup",
   "MonoidWithZero"],
  "name": "instCommSemiringFin"},
 {"type":
  "∀ {α : Type u_1} [inst : LT α] (a : α) (as : List α) (b : α) (bs : List α),\n  ¬(fun a a_1 => a < a_1) a b → b < a → a :: as < b :: bs → False",
  "offspring": [],
  "name": "List.hasDecidableLt.proof_3"},
 {"type": "UInt8 → ℕ → UInt8", "offspring": ["UInt8.mk"], "name": "UInt8.modn"},
 {"type":
  "∀ (m n k : ℕ), -[1+ m] + -[1+ n] + Int.ofNat k = -[1+ m] + (-[1+ n] + Int.ofNat k)",
  "offspring":
  ["Int.negSucc_ofNat_add_negSucc_ofNat",
   "Int.negSucc_ofNat_add_ofNat",
   "Int.subNatNat",
   "Int.add_comm",
   "Int.subNatNat_add_negSucc_ofNat",
   "Nat.add_succ",
   "Nat.succ_add"],
  "name": "Int.add_assoc_aux2"},
 {"type": "∀ {m n : ℕ}, Nat.coprime n m → Nat.coprime m n",
  "offspring": ["Nat.gcd_comm"],
  "name": "Nat.coprime.symm"},
 {"type":
  "Nonempty (Tactic.DeclCache (Std.HashMap Lean.HeadIndex (Array Lean.Name)))",
  "offspring": ["Tactic.instNonemptyDeclCache"],
  "name": "Tactic.Find.findDeclsPerHead.proof_1"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≠ b → a < b ∨ a > b",
  "offspring": ["lt_trichotomy"],
  "name": "lt_or_gt_of_ne"},
 {"type":
  "∀ {v : Sat.Valuation} {a : Prop} {n : ℕ}, (v n ↔ a) → Sat.Literal.reify v (Sat.Literal.neg n) a",
  "offspring": ["Sat.Literal.reify.mk"],
  "name": "Sat.Literal.reify_neg"},
 {"type":
  "∀ {α : Sort u} [h : DecidableEq α] (a : α), h a a = isTrue (_ : a = a)",
  "offspring": [],
  "name": "decidable_eq_inl_refl"},
 {"type":
  "∀ {k m : ℕ} (n : ℕ), Nat.coprime k m → Nat.gcd m (k * n) = Nat.gcd m n",
  "offspring": ["Nat.gcd_comm", "Nat.coprime.gcd_mul_left_cancel"],
  "name": "Nat.coprime.gcd_mul_left_cancel_right"},
 {"type": "Sort u → Sort v → Sort (max (max 1 u) v)",
  "offspring": [],
  "name": "PProd"},
 {"type":
  "{σ : Type u} → {m : Type u → Type v} → [inst : MonadState σ m] → (σ → σ) → m PUnit",
  "offspring": ["MonadState.modifyGet"],
  "name": "modify"},
 {"type":
  "∀ {α' : Sort w} [inst : DecidableEq α'] {α : Sort u_1} {β : Sort u_2} (g : α' → β) {f : α → α'} {i : α'} (a : β),\n  (∀ (x : α), f x ≠ i) → Function.update g i a ∘ f = g ∘ f",
  "offspring": ["Function.update_comp_eq_of_forall_ne'"],
  "name": "Function.update_comp_eq_of_forall_ne"},
 {"type": "∀ {m n k : ℕ}, k ∣ Nat.gcd m n ↔ k ∣ m ∧ k ∣ n",
  "offspring": ["Nat.dvd_trans", "Nat.gcd_dvd", "Nat.dvd_gcd"],
  "name": "Nat.dvd_gcd_iff"},
 {"type":
  "{α : Type u} → Sort u_1 → NonAssocSemiring α → NonAssocSemiring α → Sort u_1",
  "offspring": [],
  "name": "NonAssocSemiring.noConfusionType"},
 {"type": "∀ {a b : Prop}, a → b → a ∧ b",
  "offspring": [],
  "name": "And.intro"},
 {"type":
  "∀ {c t e : Prop} [inst : Decidable c], (if c then t else e) → ¬c → e",
  "offspring": [],
  "name": "implies_of_if_neg"},
 {"type": "∀ {α : Type u} (a : α), { down := a }.down = a",
  "offspring": [],
  "name": "ulift.down_up"},
 {"type": "{α : Type u✝} → α → One α", "offspring": [], "name": "One.mk"},
 {"type": "∀ {α : Sort u_1} (a : α), { down := a }.down = a",
  "offspring": [],
  "name": "plift.down_up"},
 {"type": "∀ {α : Type u_1} {l : List α}, l ⊆ [] → l = []",
  "offspring": ["List.mem_cons_self"],
  "name": "List.eq_nil_of_subset_nil"},
 {"type": "{n : ℕ} → LE (Fin n)", "offspring": ["LE.mk"], "name": "instLEFin"},
 {"type": "∀ (b : Bool), (¬b = true) = (b = false)",
  "offspring": [],
  "name": "Bool.not_eq_true"},
 {"type": "Type", "offspring": [], "name": "ByteArray"},
 {"type": "∀ {m n : ℕ}, n ≤ m → Int.subNatNat m n = Int.ofNat (m - n)",
  "offspring": ["Int.subNatNat_of_sub_eq_zero", "Nat.sub_eq_zero_of_le"],
  "name": "Int.subNatNat_of_le"},
 {"type":
  "∀ (c : Nat.Linear.ExprCnstr),\n  Nat.Linear.PolyCnstr.norm (Nat.Linear.ExprCnstr.toPoly c) = Nat.Linear.ExprCnstr.toNormPoly c",
  "offspring": [],
  "name": "Nat.Linear.ExprCnstr.toPoly_norm_eq"},
 {"type": "{n : ℕ} → OfNat Float n",
  "offspring": ["OfNat.mk", "Float.ofNat"],
  "name": "instOfNatFloat"},
 {"type": "{α : Type u_1} → [inst : Ord α] → DecidableRel LT.lt",
  "offspring": ["Ordering", "instBEqOrdering", "Ord.compare", "Ordering.lt"],
  "name": "instDecidableRelLtLtOfOrd"},
 {"type": "∀ {α : Sort u} (a b : α), (a ≠ b) = ¬a = b",
  "offspring": [],
  "name": "Ne.def"},
 {"type": "Mod UInt64",
  "offspring": ["Mod.mk", "UInt64.mod"],
  "name": "instModUInt64"},
 {"type": "Int.sign 0 = 0", "offspring": [], "name": "Int.sign_zero"},
 {"type": "∀ (a : UInt8), a + 0 = a",
  "offspring":
  ["UInt8.zero_def",
   "UInt8.add_def",
   "UInt8.mk",
   "add_zero",
   "UInt8.mk_val_eq"],
  "name": "UInt8.instSemiringUInt8.proof_1"},
 {"type": "∀ {a b : ℕ}, a - b + b = max a b",
  "offspring":
  ["le_total",
   "Nat.instLinearOrderNat",
   "max_eq_right",
   "Nat.sub_eq_zero_iff_le",
   "Nat.zero_add",
   "max_eq_left",
   "Nat.sub_add_cancel"],
  "name": "Nat.sub_add_eq_max"},
 {"type": "Semigroup UInt32",
  "offspring":
  ["Semigroup.mk", "instMulUInt32", "UInt32.instSemigroupUInt32.proof_1"],
  "name": "UInt32.instSemigroupUInt32"},
 {"type":
  "∀ {α : Type u_2} {p : α → Prop} [inst : DecidablePred p] {β : Type u_1} (f : β → α) (l : List β),\n  List.erasep p (List.map f l) = List.map f (List.erasep (p ∘ f) l)",
  "offspring":
  ["List.erasep_cons_of_pos", "Function.comp_apply", "List.erasep_cons_of_neg"],
  "name": "List.erasep_map"},
 {"type": "{α : Type u} → List α → List α",
  "offspring": [],
  "name": "List.init"},
 {"type": "{α : Sort u_1} → {p : α → Prop} → (∃ a, p a) → α",
  "offspring": ["Classical.choose"],
  "name": "Exists.choose"},
 {"type": "∀ (α : Prop), True → α ↔ α",
  "offspring": ["trivial"],
  "name": "true_implies_iff"},
 {"type": "∀ (n : ℕ), ¬n < 0",
  "offspring": ["Nat.not_succ_le_zero"],
  "name": "Nat.not_lt_zero"},
 {"type":
  "∀ {α : Type u_1} {f : α → α → α} {a b : α}, Option.lift_or_get f (some a) (some b) = some (f a b)",
  "offspring": [],
  "name": "Option.lift_or_get_some_some"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type w} → {β : Type u} → (α → m β) → List α → m (List β)",
  "offspring": [],
  "name": "List.mapM"},
 {"type":
  "∀ {α : Type u_1} {β : Sort u_2} {f : α → β} {arr : Array α} {n : ℕ} {m : Fin n → β},\n  UFModel.Agrees arr f m →\n    ∀ (i : ℕ) (h₁ : i < Array.size arr) (h₂ : i < n),\n      f (Array.get arr { val := i, isLt := h₁ }) = m { val := i, isLt := h₂ }",
  "offspring": [],
  "name": "UFModel.Agrees.get_eq"},
 {"type": "{α : Type u} → (Unit → α) → Thunk α",
  "offspring": [],
  "name": "Thunk.mk"},
 {"type": "(α : Type u) → Inhabited (List α)",
  "offspring": [],
  "name": "instInhabitedList_1"},
 {"type": "{α : Type u} → Sort u_1 → Xor α → Xor α → Sort u_1",
  "offspring": [],
  "name": "Xor.noConfusionType"},
 {"type": "Nat.Linear.Poly → Bool",
  "offspring": [],
  "name": "Nat.Linear.Poly.isZero"},
 {"type":
  "{R : Type u} → [self : NonUnitalNonAssocSemiring R] → MulZeroClass R",
  "offspring":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass"},
 {"type": "∀ (a : USize), 0 + a = a",
  "offspring":
  ["USize.zero_def",
   "USize.add_def",
   "USize.mk",
   "zero_add",
   "USize.mk_val_eq"],
  "name": "USize.instSemiringUSize.proof_2"},
 {"type": "Type u → (Type u → Type v) → Type u → Type (max (u + 1) v)",
  "offspring": [],
  "name": "StateCpsT"},
 {"type":
  "{ε σ α δ : Type u} →\n  [inst : EStateM.Backtrackable δ σ] → EStateM ε σ α → EStateM ε σ α → optParam Bool true → EStateM ε σ α",
  "offspring":
  ["EStateM.Result.ok",
   "EStateM.Backtrackable.restore",
   "EStateM.Result.error",
   "EStateM.Backtrackable.save"],
  "name": "EStateM.orElse'"},
 {"type": "∀ (n : ℕ), Int.natAbs ↑n = n",
  "offspring": [],
  "name": "Int.natAbs_cast"},
 {"type": "{n : ℕ} → OfNat ℤ n",
  "offspring": ["OfNat.mk"],
  "name": "Int.instOfNatInt"},
 {"type": "Ord String",
  "offspring": ["Ord.mk", "compareOfLessAndEq"],
  "name": "instOrdString"},
 {"type":
  "∀ {α : Sort u} {β : Sort v} {val val_1 : α}, PSum.inl val = PSum.inl val_1 → val = val_1",
  "offspring": [],
  "name": "PSum.inl.inj"},
 {"type": "∀ {α : Sort u₁} {β : Sort u₂} (f : α → β), f ∘ id = f",
  "offspring": [],
  "name": "Function.comp.right_id"},
 {"type":
  "∀ {α : Sort u} {f : α → α}, Function.involutive f → Function.bijective f",
  "offspring":
  ["Function.involutive.injective", "Function.involutive.surjective"],
  "name": "Function.involutive.bijective"},
 {"type":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, b < a → max a b = a",
  "offspring": ["max_eq_left", "le_of_lt"],
  "name": "max_eq_left_of_lt"},
 {"type":
  "∀ {α : Type u_1} (x : α) (as : List α), x ∈ List.reverse as ↔ x ∈ as",
  "offspring": ["List.mem_reverseAux", "List.not_mem_nil", "or_false"],
  "name": "List.mem_reverse"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {f₁ f₂ : (x : α) → β x}, (∀ (x : α), f₁ x = f₂ x) → f₁ = f₂",
  "offspring": [],
  "name": "funext"},
 {"type":
  "{α₁ α₂ α₃ α₄ β : Type u} →\n  (α₁ → α₂ → α₃ → α₄ → β) → ((α₁ → α₂ → α₃ → α₄ → β) → α₁ → α₂ → α₃ → α₄ → β) → ℕ → α₁ → α₂ → α₃ → α₄ → β",
  "offspring": [],
  "name": "bfix4"},
 {"type": "{α : Sort u} → (α → α → Prop) → α → Prop",
  "offspring": [],
  "name": "Acc"},
 {"type":
  "∀ {α : Type u_1} [inst : Preorder α] (a b : α), b ≤ a → a < b → False",
  "offspring": ["not_le_of_gt"],
  "name": "decidableLt_of_decidableLe.proof_1"},
 {"type": "∀ (a : UInt32), a * 0 = 0",
  "offspring":
  ["UInt32.zero_def", "UInt32.mul_def", "UInt32.mk", "MonoidWithZero.mul_zero"],
  "name": "UInt32.instSemiringUInt32.proof_10"},
 {"type": "Inhabited (Fin UInt16.size)",
  "offspring": ["Fin.ofNat'", "UInt16.size_positive"],
  "name": "UInt16.instInhabitedFinSize"},
 {"type": "(Type u → Type v) → Type (max (u + 1) v)",
  "offspring": [],
  "name": "MonadFinally"},
 {"type": "1 ≠ 0", "offspring": [], "name": "Nat.one_ne_zero"},
 {"type": "∀ {A : Type u} [self : AddCommSemigroup A] (a b : A), a + b = b + a",
  "offspring": [],
  "name": "AddCommSemigroup.add_comm"},
 {"type":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : α → β → Sort u₃} → ((x : α) → (y : β) → φ x y) → (y : β) → (x : α) → φ x y",
  "offspring": [],
  "name": "Function.swap"},
 {"type": "∀ (n m : ℕ), n * Nat.pred m = n * m - n",
  "offspring": ["Nat.mul_pred_left"],
  "name": "Nat.mul_pred_right"},
 {"type": "{α : Type u_1} → (α → Bool) → Option α → Bool",
  "offspring": [],
  "name": "Option.all"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → Sort u_1 → HMod α β γ → HMod α β γ → Sort u_1",
  "offspring": [],
  "name": "HMod.noConfusionType"},
 {"type": "{α : Type u_1} → List α → α → α",
  "offspring": ["List.getLast", "List.getLastD.proof_1"],
  "name": "List.getLastD"},
 {"type": "Lean.Elab.Tactic.Tactic",
  "offspring":
  ["evalIntrov.introsDep",
   "GE.ge",
   "cond",
   "Array.append",
   "Array.extract",
   "Option.getD"],
  "name": "evalIntrov"},
 {"type":
  "{α : Type u_1} → (α → α → Bool) → (a : Array α) → Fin (Array.size a) → { a' // Array.size a' = Array.size a }",
  "offspring": ["WellFounded.fix"],
  "name": "BinaryHeap.heapifyDown"},
 {"type": "(a b : UInt8) → Decidable (a ≤ b)",
  "offspring": ["UInt8.decLe"],
  "name": "instDecidableLeUInt8InstLEUInt8"},
 {"type": "UInt8 → UInt8 → UInt8",
  "offspring": ["UInt8.mk"],
  "name": "UInt8.mod"},
 {"type": "∀ {c : Prop} (a b : Prop), (a ∧ b) ∧ c ↔ a ∧ b ∧ c",
  "offspring": ["And.assoc"],
  "name": "and_assoc"},
 {"type": "Bool → Bool → Bool", "offspring": [], "name": "or"},
 {"type": "∀ {m n : ℕ}, Int.subNatNat (m + n) m = Int.ofNat n",
  "offspring": [],
  "name": "Int.subNatNat_add_left"},
 {"type":
  "{α : Type u} → {m : Type u → Type v} → [inst : Monad m] → (ℕ → α → m α) → α → ℕ → m α",
  "offspring": [],
  "name": "Nat.foldM"},
 {"type":
  "Tactic.Ring.HornerExpr → Tactic.Ring.RingM (Tactic.Ring.HornerExpr × Lean.Expr)",
  "offspring": ["Tactic.Ring.HornerExpr.e"],
  "name": "Tactic.Ring.HornerExpr.reflConv"},
 {"type": "∀ {α : Sort u_1} (x y : α), x ≠ y ∨ x = y",
  "offspring": ["em'"],
  "name": "ne_or_eq"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.ExtendedBinder.binderPred.quot"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2} {r : α → α → Prop} {s : β → β → Prop} {b : β},\n  Acc s b → (∀ (a : α), Acc r a) → ∀ (a : α), Acc (PSigma.RevLex r s) { fst := a, snd := b }",
  "offspring": ["Acc.intro"],
  "name": "PSigma.revLexAccessible.proof_1"},
 {"type": "∀ (p : Prop), (False ∧ p) = False",
  "offspring": [],
  "name": "false_and"},
 {"type":
  "∀ {R : Type u} [self : Ring R] (n : ℕ) (a : R), Ring.gsmul -[1+ n] a = -Ring.gsmul (Int.ofNat (Nat.succ n)) a",
  "offspring": [],
  "name": "Ring.gsmul_neg'"},
 {"type": "∀ {α : Type u_1} (x : α), some x ≠ none",
  "offspring": [],
  "name": "Option.some_ne_none"},
 {"type": "{f : Type u → Type v} → Sort u_1 → Functor f → Functor f → Sort u_1",
  "offspring": [],
  "name": "Functor.noConfusionType"},
 {"type": "Nat.Linear.PolyCnstr → Bool",
  "offspring":
  ["cond",
   "Nat.Linear.PolyCnstr.eq",
   "or",
   "Nat.Linear.Poly.isZero",
   "Nat.Linear.PolyCnstr.lhs",
   "Nat.Linear.Poly.isNonZero",
   "Nat.Linear.PolyCnstr.rhs"],
  "name": "Nat.Linear.PolyCnstr.isUnsat"},
 {"type":
  "{α : Sort u_1} → {β : Sort u_2} → [inst : CoeSort α β] → CoeTail α β",
  "offspring": ["CoeTail.mk", "CoeSort.coe"],
  "name": "coeSortToCoeTail"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.renameArg"},
 {"type": "{α : Type u} → [self : ToString α] → α → String",
  "offspring": [],
  "name": "ToString.toString"},
 {"type": "(α : Type u) → [inst : BEq α] → Prop",
  "offspring": [],
  "name": "LawfulBEq"},
 {"type":
  "∀ {α : Type u_2} {β : Type u_1} (x : β) (f : α → β), Option.elim none x f = x",
  "offspring": [],
  "name": "Option.elim_none"},
 {"type": "∀ {n : ℕ}, n ∣ 1 → n = 1",
  "offspring": ["Nat.le_antisymm", "Nat.le_of_dvd", "Nat.pos_of_dvd_of_pos"],
  "name": "Nat.eq_one_of_dvd_one"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) {i : Fin (Array.size self.arr)},\n  (Array.get self.arr i).parent ≠ ↑i → UnionFind.rank self ↑i < UnionFind.rank self (Array.get self.arr i).parent",
  "offspring":
  ["Ne",
   "UFModel.Models.parent_eq'",
   "ne_eq",
   "UFModel.parent",
   "dite_congr",
   "Fin.isLt",
   "UFModel.Models.rank_eq",
   "Eq.mpr_prop",
   "dite_true",
   "UFModel.rank_lt",
   "UnionFind.model'"],
  "name": "UnionFind.rank_lt"},
 {"type":
  "(m : Type u → Type v) → (ε : Type u) → [inst : Monad m] → MonadExceptOf ε (ExceptT ε m)",
  "offspring":
  ["MonadExceptOf.mk", "ExceptT.mk", "Except.error", "ExceptT.tryCatch"],
  "name": "instMonadExceptOfExceptT_1"},
 {"type": "{α : Type u} → {β : Type v} → (ℕ → α → β) → ℕ → List α → List β",
  "offspring": [],
  "name": "List.mapIdxAux"},
 {"type": "∀ {a : Prop} (b : Prop), a → a ∨ b",
  "offspring": [],
  "name": "Or.intro_left"},
 {"type": "{α : Type u} → Sort u_1 → Dvd α → Dvd α → Sort u_1",
  "offspring": [],
  "name": "Dvd.noConfusionType"},
 {"type": "{n : ℕ} → Fin n → Fin n → Bool",
  "offspring": ["Decidable.decide"],
  "name": "Fin.subUnderflows?"},
 {"type": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "offspring":
  ["AddGroupWithOne.mk",
   "Ring.sub_eq_add_neg",
   "Ring.gsmul",
   "Ring.gsmul_zero'",
   "Ring.gsmul_succ'",
   "Ring.gsmul_neg'",
   "Ring.add_left_neg",
   "Ring.intCast",
   "Ring.intCast_ofNat",
   "Ring.intCast_negSucc"],
  "name": "Ring.toAddGroupWithOne"},
 {"type": "DecidableEq Bool",
  "offspring": ["instDecidableEqBool.proof_1", "instDecidableEqBool.proof_2"],
  "name": "instDecidableEqBool"},
 {"type": "Type u → Type u", "offspring": [], "name": "ShiftRight"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] {as bs : List α},\n  List.disjoint as bs → List.card (as ++ bs) = List.card as + List.card bs",
  "offspring":
  ["Subsingleton.elim", "List.nil_append", "List.card_nil", "Nat.zero_add"],
  "name": "List.card_append_disjoint"},
 {"type":
  "{α : Sort u} → {γ : outParam (α → Sort v)} → ((a : α) → γ a) → CoeFun α γ",
  "offspring": [],
  "name": "CoeFun.mk"},
 {"type":
  "{m : Type u → Type u_1} → {β ε α : Type u} → ExceptCpsT ε m α → ε → (α → m β) → (ε → m β) → m β",
  "offspring": [],
  "name": "ExceptCpsT.runK"},
 {"type": "{α : Type u} → (n : ℕ) → [self : OfNat α n] → α",
  "offspring": [],
  "name": "OfNat.ofNat"},
 {"type":
  "∀ (x : ℕ) (a : UInt32),\n  { val := Ring.gsmul (Int.ofNat (Nat.succ x)) a.val } =\n    { val := (a + (fun x a => { val := Ring.gsmul x a.val }) (Int.ofNat x) a).1 }",
  "offspring": ["SubNegMonoid.gsmul_succ'"],
  "name": "UInt32.instRingUInt32.proof_4"},
 {"type": "Mathlib.Tactic.Sat.LClause → Lean.Expr",
  "offspring": [],
  "name": "Mathlib.Tactic.Sat.LClause.expr"},
 {"type":
  "{α : Type u} →\n  {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (β → α → m β) → Array α → USize → USize → β → m β",
  "offspring": ["Array.uget", "lcProof", "Array.foldlMUnsafe.fold"],
  "name": "Array.foldlMUnsafe.fold"},
 {"type": "1 = Nat.succ 0", "offspring": [], "name": "Nat.one_eq_succ_zero"},
 {"type": "{n : ℕ} → ℕ → n > 0 → Fin n", "offspring": [], "name": "Fin.ofNat'"},
 {"type": "Semigroup UInt8",
  "offspring":
  ["Semigroup.mk", "instMulUInt8", "UInt8.instSemigroupUInt8.proof_1"],
  "name": "UInt8.instSemigroupUInt8"},
 {"type":
  "∀ {α : Type u_1} {s₁ s₂ t₁ t₂ : List α}, s₁ ++ t₁ = s₂ ++ t₂ → List.length s₁ = List.length s₂ → s₁ = s₂",
  "offspring": ["List.append_inj"],
  "name": "List.append_inj_left"},
 {"type":
  "∀ {α : Type u_1} {lt : α → α → Bool} (self : BinaryHeap α lt) (i : Fin (BinaryHeap.size self)) (x : α),\n  ↑i < Array.size (Array.set self.arr i x)",
  "offspring": ["Array.set", "Array.size_set", "Fin.isLt"],
  "name": "BinaryHeap.increaseKey.proof_1"},
 {"type":
  "∀ {α : Type u_1} (as bs : Array α), Array.size as ≤ Array.size bs → ∀ (x : ℕ), x < Array.size as → x < Array.size bs",
  "offspring": ["Nat.lt_of_lt_of_le"],
  "name": "Array.isPrefixOfAux.proof_2"},
 {"type": "∀ (a b : Bool), ((a || b) = true) = (a = true ∨ b = true)",
  "offspring": [],
  "name": "Bool.or_eq_true"},
 {"type": "∀ {x y : ℕ}, Nat.add x y = x + y",
  "offspring": [],
  "name": "Nat.add_eq"},
 {"type":
  "∀ (ctx : Nat.Linear.Context) (fuel : ℕ) (m₁ m₂ r₁ r₂ : Nat.Linear.Poly),\n  Nat.Linear.Poly.denote_eq ctx (Nat.Linear.Poly.cancelAux fuel m₁ m₂ r₁ r₂) →\n    Nat.Linear.Poly.denote_eq ctx (List.reverse r₁ ++ m₁, List.reverse r₂ ++ m₂)",
  "offspring":
  ["Nat.blt", "Nat.Linear.Poly.cancelAux", "List.append_nil", "Nat.sub_eq"],
  "name": "Nat.Linear.Poly.of_denote_eq_cancelAux"},
 {"type": "∀ {n : ℕ} (m : ℕ), 0 < n → 0 < n ^ m",
  "offspring": ["Nat.pow_le_pow_of_le_right", "Nat.zero_le"],
  "name": "Nat.pos_pow_of_pos"},
 {"type":
  "∀ (α : Lean.Expr) (univ : Lean.Level) (cs α_1 : Lean.Expr) (univ_1 : Lean.Level) (cs_1 : Lean.Expr),\n  ({ α := α, univ := univ, cs := cs } = { α := α_1, univ := univ_1, cs := cs_1 }) =\n    (α = α_1 ∧ univ = univ_1 ∧ cs = cs_1)",
  "offspring": ["Tactic.Ring.Cache", "Tactic.Ring.Cache.mk"],
  "name": "Tactic.Ring.Cache.mk.injEq"},
 {"type":
  "∀ {k : ℕ} (m : ℕ) {n : ℕ}, Nat.coprime k n → Nat.gcd (k * m) n = Nat.gcd m n",
  "offspring":
  ["Nat.dvd_antisymm",
   "Nat.dvd_gcd",
   "Nat.coprime.dvd_of_dvd_mul_left",
   "Nat.gcd_dvd_left",
   "Nat.gcd_dvd_right",
   "Nat.gcd_dvd_gcd_mul_left"],
  "name": "Nat.coprime.gcd_mul_left_cancel"},
 {"type": "Stream Std.Range ℕ",
  "offspring": ["Stream.mk"],
  "name": "instStreamRangeNat"},
 {"type": "∀ {α : Type u_1} (f : α → Set α), ¬Function.surjective f",
  "offspring": [],
  "name": "Function.cantor_surjective"},
 {"type": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "offspring": [],
  "name": "HMul"},
 {"type": "{α : Type u_1} → (α → α → Prop) → List α → Prop",
  "offspring": ["List.Chain"],
  "name": "List.Chain'"},
 {"type":
  "∀ {α : Sort u} [self : WellFoundedRelation α], WellFounded WellFoundedRelation.rel",
  "offspring": [],
  "name": "WellFoundedRelation.wf"},
 {"type":
  "{α : Type} → [inst : Inhabited α] → (α → α → Bool) → Array α → ℕ → ℕ → Array α",
  "offspring": [],
  "name": "Array.qsort.sort"},
 {"type":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (x : α) → p x → Prop},\n  (∀ (x : α) (h : p x), q x h) ↔ ∀ (x : { a // p a }), q x.val (_ : p x.val)",
  "offspring": ["Iff.symm", "Subtype.forall"],
  "name": "Subtype.forall'"},
 {"type": "{α : Type u} → [inst : ToString α] → ToString (Array α)",
  "offspring": ["ToString.mk", "Array.toList"],
  "name": "Array.instToStringArray"},
 {"type": "∀ (x x_1 : UInt32), x * x_1 = x_1 * x",
  "offspring":
  ["UInt32.eq_of_val_eq", "UInt32.mul_def", "CommSemigroup.mul_comm"],
  "name": "UInt32.instCommRingUInt32.proof_1"},
 {"type":
  "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a → q a) → (∃ a, p a) → ∃ a, q a",
  "offspring": ["exists_imp_exists"],
  "name": "Exists.imp"},
 {"type":
  "String → String → Lean.Name → Lean.MetaM (ℕ × Lean.Expr × Lean.Expr × Lean.Expr)",
  "offspring":
  ["Array.isEmpty",
   "Mathlib.Tactic.Sat.buildProof",
   "Mathlib.Tactic.Sat.buildClause",
   "Mathlib.Tactic.Sat.Parser.parseLRAT",
   "Mathlib.Tactic.Sat.buildConj",
   "Mathlib.Tactic.Sat.Parser.parseDimacs"],
  "name": "Mathlib.Tactic.Sat.fromLRATAux"},
 {"type":
  "∀ (x x_1 x_2 : UInt8), { val := (x + x_1 + x_2).1 } = { val := (x + (x_1 + x_2)).1 }",
  "offspring": ["UInt8.mk", "AddSemigroup.add_assoc"],
  "name": "UInt8.instAddSemigroupUInt8.proof_1"},
 {"type": "∀ {α : Type u_1}, Equivalence List.Perm",
  "offspring":
  ["Equivalence.mk", "List.Perm.refl", "List.Perm.symm", "List.Perm.trans"],
  "name": "List.Perm.Equivalence"},
 {"type": "Ring UInt32",
  "offspring":
  ["Ring.mk",
   "UInt32.instSemiringUInt32",
   "UInt32.instNegUInt32",
   "instSubUInt32",
   "UInt32.instRingUInt32.proof_1",
   "UInt32.mk",
   "Ring.gsmul",
   "UInt32.instRingUInt32.proof_3",
   "UInt32.instRingUInt32.proof_4",
   "UInt32.instRingUInt32.proof_5",
   "UInt32.instRingUInt32.proof_6",
   "Int.cast",
   "UInt32.instRingUInt32.proof_7",
   "UInt32.instRingUInt32.proof_8"],
  "name": "UInt32.instRingUInt32"},
 {"type":
  "{c t e : Prop} → [dC : Decidable c] → [dT : Decidable t] → [dE : Decidable e] → Decidable (if c then t else e)",
  "offspring": [],
  "name": "instDecidableIteProp"},
 {"type": "Type u → Type u", "offspring": [], "name": "Inv"},
 {"type":
  "∀ (e : Lean.Expr) (coeff : ℕ) (e_1 : Lean.Expr) (coeff_1 : ℕ),\n  (Tactic.Ring.HornerExpr.const e coeff = Tactic.Ring.HornerExpr.const e_1 coeff_1) = (e = e_1 ∧ coeff = coeff_1)",
  "offspring": ["Tactic.Ring.HornerExpr", "Tactic.Ring.HornerExpr.const"],
  "name": "Tactic.Ring.HornerExpr.const.injEq"},
 {"type": "∀ (a : UInt64), a * 1 = a",
  "offspring":
  ["UInt64.one_def",
   "UInt64.mul_def",
   "UInt64.mk",
   "mul_one",
   "UInt64.mk_val_eq"],
  "name": "UInt64.instSemiringUInt64.proof_14"},
 {"type":
  "∀ {ε : Type u} {α : Type v} {a a_1 : α}, Except.ok a = Except.ok a_1 → a = a_1",
  "offspring": [],
  "name": "Except.ok.inj"},
 {"type":
  "{ρ : Type u} → {m : Type u → Type v} → [self : MonadReaderOf ρ m] → m ρ",
  "offspring": [],
  "name": "MonadReaderOf.read"},
 {"type": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "offspring": ["HAdd.mk", "Add.add"],
  "name": "instHAdd"},
 {"type": "∀ {n : ℕ}, n ≠ 0 → ∃ k, n = Nat.succ k",
  "offspring": ["Nat.pred", "Or.resolve_left", "Nat.eq_zero_or_eq_succ_pred"],
  "name": "Nat.exists_eq_succ_of_ne_zero"},
 {"type": "Lean.Elab.Command.CommandElab",
  "offspring":
  ["cond", "Mathlib.Prelude.Rename.getRenameMap", "instToStringString"],
  "name": "Mathlib.Prelude.Rename.elabLookup3"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "precMax"},
 {"type":
  "∀ {ctx : Nat.Linear.Context} {m₁ m₂ : Nat.Linear.Poly},\n  Nat.Linear.Poly.denote_le ctx (Nat.Linear.Poly.cancel m₁ m₂) → Nat.Linear.Poly.denote_le ctx (m₁, m₂)",
  "offspring": [],
  "name": "Nat.Linear.Poly.of_denote_le_cancel"},
 {"type": "∀ (a b : ℤ), a ≤ b ∨ b ≤ a",
  "offspring":
  ["Or.imp_right",
   "Int.sub_eq_add_neg",
   "Int.neg_add",
   "neg_neg",
   "Int.add_comm",
   "Int.nonneg_or_nonneg_neg"],
  "name": "Int.le_total"},
 {"type": "LawfulBEq Char",
  "offspring": ["instLawfulBEqCharInstBEqInstDecidableEqChar.proof_1"],
  "name": "instLawfulBEqCharInstBEqInstDecidableEqChar"},
 {"type": "∀ (a b : ℕ), a * a - b * b = (a + b) * (a - b)",
  "offspring":
  ["Nat.mul_sub_left_distrib", "Nat.right_distrib", "Nat.add_sub_add_left"],
  "name": "Nat.mul_self_sub_mul_self_eq"},
 {"type":
  "{α : Type u} → {m : Type → Type w} → [inst : Monad m] → (α → m Bool) → Subarray α → m Bool",
  "offspring": ["Array.anyM", "Subarray.as", "Subarray.start", "Subarray.stop"],
  "name": "Subarray.anyM"},
 {"type": "∀ (p : Prop), (True ∧ p) = p",
  "offspring": ["trivial"],
  "name": "true_and"},
 {"type": "Type u → Type u → Type u → Type u",
  "offspring": ["EStateM.Result"],
  "name": "EStateM"},
 {"type": "∀ {α : Type u_1} {l₁ l₂ l : List α}, l₁ ⊆ l → l₂ ⊆ l → l₁ ++ l₂ ⊆ l",
  "offspring": ["Or.elim", "List.mem_append"],
  "name": "List.append_subset_of_subset_of_subset"},
 {"type": "{R : Type u} → [self : AddMonoidWithOne R] → AddMonoid R",
  "offspring": [],
  "name": "AddMonoidWithOne.toAddMonoid"},
 {"type": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "offspring": ["trivial"],
  "name": "eq_self"},
 {"type": "Lean.ParserDescr",
  "offspring": [],
  "name": "Mathlib.Tactic.«tacticOn_goal-_=>_»"},
 {"type":
  "(α : Type u) → {β : Type v} → (β → β → Prop) → (_ : α) ×' β → (_ : α) ×' β → Prop",
  "offspring": ["PSigma.RevLex", "emptyRelation"],
  "name": "PSigma.SkipLeft"},
 {"type":
  "∀ (as : FloatArray) (stop : ℕ), stop ≤ FloatArray.size as → ∀ (j : ℕ), j < stop → j < FloatArray.size as",
  "offspring": ["Nat.lt_of_lt_of_le"],
  "name": "FloatArray.foldlM.loop.proof_1"},
 {"type": "{α : Type u} → (α → α → α) → Inter α",
  "offspring": [],
  "name": "Inter.mk"},
 {"type": "∀ (a : UInt16), 1 * a = a",
  "offspring":
  ["UInt16.one_def",
   "UInt16.mul_def",
   "UInt16.mk",
   "one_mul",
   "UInt16.mk_val_eq"],
  "name": "UInt16.instSemiringUInt16.proof_13"},
 {"type": "false = true → Bool.noConfusionType False false true",
  "offspring": [],
  "name": "instDecidableEqBool.proof_1"},
 {"type": "∀ {α : Type u_1} {a : α} {b : Option α}, a ∈ b ↔ b = some a",
  "offspring": ["Iff.rfl"],
  "name": "Option.mem_iff"},
 {"type": "∀ {R : Type u} [self : Semiring R] (a : R), a * 1 = a",
  "offspring": [],
  "name": "Semiring.mul_one"},
 {"type": "UInt16 → UInt64",
  "offspring": ["Nat.toUInt64", "UInt16.toNat"],
  "name": "UInt16.toUInt64"},
 {"type": "StdGen → ℕ", "offspring": [], "name": "StdGen.s2"},
 {"type": "Inhabited FloatArray",
  "offspring": ["FloatArray.empty"],
  "name": "FloatArray.instInhabitedFloatArray"},
 {"type": "∀ (m : ℕ), Nat.lcm m 1 = m",
  "offspring": ["Nat.lcm_one_left", "Nat.lcm_comm"],
  "name": "Nat.lcm_one_right"},
 {"type":
  "∀ {α : Type u_1} {β : Type u_3} {γ : Type u_2} (h : β → γ) (g : α → β) (x : Option α),\n  Option.map (h ∘ g) x = Option.map h (Option.map g x)",
  "offspring": ["Option.map_map"],
  "name": "Option.comp_map"},
 {"type":
  "{α : Type u} → {β : Type v} → [inst : BEq α] → α → List (α × β) → Option β",
  "offspring": [],
  "name": "List.lookup"},
 {"type": "∀ (p : Prop), (False ∨ p) = p", "offspring": [], "name": "false_or"},
 {"type":
  "∀ {α σ : Type u} [inst : SizeOf α] [inst_1 : SizeOf σ] (a : σ), sizeOf (DoResultSBC.break a) = 1 + sizeOf a",
  "offspring": [],
  "name": "DoResultSBC.break.sizeOf_spec"},
 {"type": "∀ (a b : ℤ), a + (-a + b) = b",
  "offspring": ["Int.add_assoc", "Int.add_right_neg", "Int.zero_add"],
  "name": "Int.add_neg_cancel_left"},
 {"type":
  "∀ {α : Type u_1} {n : ℕ} {β : Sort u_2} {f : α → β} {arr : Array α} {m : Fin n → β},\n  UFModel.Agrees arr f m → n = Array.size arr",
  "offspring": [],
  "name": "UFModel.Agrees.size_eq"},
 {"type": "optParam ℕ 0 → StdGen",
  "offspring": ["StdGen.mk", "HDiv.hDiv"],
  "name": "mkStdGen"},
 {"type":
  "∀ {f f' : Sat.Fmla}, Sat.Fmla.subsumes f f' → ∀ (x : Sat.Clause), x ∈ f' → x ∈ f",
  "offspring": [],
  "name": "Sat.Fmla.subsumes.prop"},
 {"type":
  "∀ {α : Sort u} {r : α → α → Prop} {a b : α}, r a b → Quot.mk r a = Quot.mk r b",
  "offspring": [],
  "name": "Quot.sound"},
 {"type":
  "{R : Type u} →\n  [toNonUnitalSemiring : NonUnitalSemiring R] →\n    (∀ (a : R), 1 * a = a) →\n      (∀ (a : R), a * 1 = a) →\n        (npow : ℕ → R → R) →\n          (∀ (x : R), npow 0 x = 1) → (∀ (n : ℕ) (x : R), npow (Nat.succ n) x = x * npow n x) → Semiring R",
  "offspring": [],
  "name": "Semiring.mk"},
 {"type": "ℕ", "offspring": [], "name": "Nat.Linear.hugeFuel"},
 {"type":
  "∀ {m : Type u_1 → Type u_2} {α β : Type u_1} [inst : Monad m] [inst_1 : LawfulMonad m] (x : m α) (y : m β),\n  (SeqLeft.seqLeft x fun x => y) = do\n    let a ← x\n    let _ ← y\n    pure a",
  "offspring":
  ["LawfulApplicative.seqLeft_eq",
   "Seq.seq",
   "map_eq_pure_bind",
   "Function.const",
   "seq_eq_bind_map",
   "LawfulMonad.bind_assoc",
   "LawfulMonad.pure_bind",
   "Function.const_apply"],
  "name": "seqLeft_eq_bind"},
 {"type":
  "∀ {α : Sort u_1} {β : Sort u_2}, Nonempty (α ⊕' β) ↔ Nonempty α ∨ Nonempty β",
  "offspring": ["Nonempty", "PSum", "PSum.inl", "PSum.inr"],
  "name": "nonempty_psum"},
 {"type": "{α : Sort u} → α → PLift α", "offspring": [], "name": "PLift.up"},
 {"type":
  "{α : Sort u} →\n  {r : α → α → Prop} → {C : α → Sort v} → ((x : α) → ((y : α) → r y x → C y) → C x) → (x : α) → Acc r x → C x",
  "offspring": [],
  "name": "WellFounded.fixF"},
 {"type": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "offspring": [],
  "name": "instDecidableNot"},
 {"type":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α), List.erase [] a = []",
  "offspring": [],
  "name": "List.erase_nil"},
 {"type":
  "∀ {α : Sort u_2} {β : Sort u_3} {s₁ : Setoid α} {s₂ : Setoid β} {motive : Quotient s₁ → Quotient s₂ → Sort u_1}\n  [s : ∀ (a : α) (b : β), Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ b))] (a : α) (a_1 : β),\n  Subsingleton (motive (Quotient.mk s₁ a) (Quotient.mk s₂ a_1))",
  "offspring": [],
  "name": "Quotient.recOnSubsingleton₂.proof_2"},
 {"type":
  "{σ : outParam (Type u)} →\n  {m : Type u → Type v} → m σ → (σ → m PUnit) → ({α : Type u} → (σ → α × σ) → m α) → MonadState σ m",
  "offspring": [],
  "name": "MonadState.mk"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → (α → β → γ) → HOr α β γ",
  "offspring": [],
  "name": "HOr.mk"},
 {"type":
  "∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a = b ↔ a ≤ b ∧ b ≤ a",
  "offspring": ["le_of_eq", "le_antisymm"],
  "name": "le_antisymm_iff"},
 {"type": "(c : Prop) → [inst : Decidable c] → Prop",
  "offspring": [],
  "name": "as_true"},
 {"type":
  "∀ {α : Sort u} {β : α → Sort v} {α' : Sort w} [inst : DecidableEq α] [inst_1 : DecidableEq α'] (g : (a : α) → β a)\n  {f : α' → α},\n  Function.injective f →\n    ∀ (i : α') (a : β (f i)), (fun j => Function.update g (f i) a (f j)) = Function.update (fun i => g (f i)) i a",
  "offspring":
  ["Function.eq_update_iff",
   "Function.update_same",
   "Function.update_noteq",
   "Function.injective.ne"],
  "name": "Function.update_comp_eq_of_injective'"},
 {"type":
  "∀ (x : ℕ), { val := ↑(x + 1) } = { val := ((fun n => { val := ↑n }) x + 1).1 }",
  "offspring": ["Fin.ofNat'_succ", "USize.size"],
  "name": "USize.instSemiringUSize.proof_12"},
 {"type":
  "Lean.SimplePersistentEnvExtension Mathlib.Util.LibraryNote.LibraryNoteEntry\n  (Array Mathlib.Util.LibraryNote.LibraryNoteEntry)",
  "offspring": [],
  "name": "Mathlib.Util.LibraryNote.libraryNoteExt"},
 {"type": "{ε α : Type} → ((σ : Type) → EST ε σ α) → Except ε α",
  "offspring": ["Unit", "Except.ok", "Except.error"],
  "name": "runEST"},
 {"type": "DecidableEq System.FilePath",
  "offspring": [],
  "name": "System.instDecidableEqFilePath"},
 {"type": "∀ {α : Type u_1} {l : List α}, 0 < List.length l ↔ ∃ a, a ∈ l",
  "offspring": ["List.exists_mem_of_length_pos", "List.length_pos_of_mem"],
  "name": "List.length_pos_iff_exists_mem"},
 {"type":
  "{m : Type → Type u_1} → [inst : Monad m] → ℕ → (ℕ → m Bool) → m Bool",
  "offspring": [],
  "name": "Nat.allM"},
 {"type": "∀ (x y : Unit), x = y", "offspring": ["Unit"], "name": "PUnit.ext"},
 {"type":
  "∀ {α : Type u_1} (as : Array α), Array.size as + 0 = Array.size as + 0",
  "offspring": [],
  "name": "Array.findIdx?.proof_1"},
 {"type": "(α : Sort u) → α → Sort u", "offspring": [], "name": "optParam"},
 {"type": "LE UInt8",
  "offspring": ["LE.mk", "UInt8.le"],
  "name": "instLEUInt8"},
 {"type":
  "∀ (f : Type u_2 → Type u_1) [inst : Functor f] [inst_1 : LawfulFunctor f] {α β : Type u_2} (h : α ≃ β) (x : f β),\n  h.toFun <$> (Equiv.symm h).toFun <$> x = x",
  "offspring":
  ["Functor.map_map", "Equiv.self_comp_symm", "LawfulFunctor.id_map"],
  "name": "Functor.map_equiv.proof_2"},
 {"type":
  "{m : Type → Type} →\n  [inst : Monad m] →\n    [inst : Lean.Elab.MonadLog m] → [inst : Lean.AddMessageContext m] → Lean.Syntax → Lean.Syntax → m Unit",
  "offspring": [],
  "name": "Tactic.TryThis.addSuggestion"},
 {"type": "∀ {n m : ℕ}, n < m → Nat.succ n ≤ m",
  "offspring": [],
  "name": "Nat.succ_le_of_lt"},
 {"type": "{α : Type u} → α → EmptyCollection α",
  "offspring": [],
  "name": "EmptyCollection.mk"},
 {"type":
  "∀ {α : Sort u} {r q : α → α → Prop}, Subrelation q r → WellFounded r → WellFounded q",
  "offspring": ["Subrelation.wf.proof_1"],
  "name": "Subrelation.wf"},
 {"type": "∀ {n : ℕ} (f : Fin n), f ≤ f",
  "offspring": ["Nat.le_refl"],
  "name": "Fin.le_refl"},
 {"type": "∀ {a b : ℕ}, a ≤ b → Nat.min a b = a",
  "offspring": ["ite_true"],
  "name": "Nat.min_eq_left"},
 {"type": "∀ {p : Prop}, (¬p → False) → p",
  "offspring": ["Decidable.by_contradiction"],
  "name": "by_contra"},
 {"type": "∀ {n : ℕ} (a : Fin n), a % n = a",
  "offspring":
  ["Fin.eq_of_val_eq",
   "Fin.modn_def",
   "Nat.mod_mod",
   "Fin.size_positive",
   "Nat.mod_eq_of_lt",
   "Fin.isLt"],
  "name": "Fin.mod_eq"},
 {"type":
  "∀ {R : Type u} [self : NonUnitalNonAssocSemiring R] (a b c : R), a * (b + c) = a * b + a * c",
  "offspring": [],
  "name": "NonUnitalNonAssocSemiring.left_distrib"},
 {"type": "{ε σ α ε' : Type u} → (ε → ε') → EStateM ε σ α → EStateM ε' σ α",
  "offspring": ["EStateM.Result.error", "EStateM.Result.ok"],
  "name": "EStateM.adaptExcept"},
 {"type": "{α : Type u_1} → Set α → Set α → Set α",
  "offspring": ["setOf"],
  "name": "Set.inter"},
 {"type": "∀ {α : Sort u_1} {p : α → Prop} (P : ∃ a, p a), p (Exists.choose P)",
  "offspring": ["Classical.choose_spec"],
  "name": "Exists.choose_spec"},
 {"type":
  "∀ {α : Type u} (f : α → α → α), commutative f → associative f → left_commutative f",
  "offspring": [],
  "name": "left_comm"},
 {"type":
  "∀ (x : ℕ), (fun n => { val := ↑n }) -[1+ x] = (fun n => { val := ↑n }) -[1+ x]",
  "offspring": [],
  "name": "UInt8.instRingUInt8.proof_8"},
 {"type": "Inhabited Tactic.NormCast.Label",
  "offspring": ["Tactic.NormCast.Label.elim"],
  "name": "Tactic.NormCast.instInhabitedLabel"},
 {"type": "(n : ℕ) → n < UInt32.size → UInt32",
  "offspring": ["UInt32.mk", "UInt32.size"],
  "name": "UInt32.ofNatCore"},
 {"type": "{α : Type u} → Array α",
  "offspring": ["Array.mkEmpty"],
  "name": "Array.empty"},
 {"type":
  "∀ {α : Type u} (as : List α) (b : α) (bs : List α), as ++ b :: bs = as ++ [b] ++ bs",
  "offspring": ["List.nil_append", "List.cons_append"],
  "name": "List.append_cons"},
 {"type": "Float → Float", "offspring": [], "name": "Float.tanh"},
 {"type": "UInt32 → UInt32 → UInt32",
  "offspring": ["UInt32.mk"],
  "name": "UInt32.mul"},
 {"type": "∀ {α : Type u_1} {s t₁ t₂ : List α}, s ++ t₁ = s ++ t₂ → t₁ = t₂",
  "offspring": ["List.append_inj_right"],
  "name": "List.append_left_cancel"},
 {"type":
  "(σ : Type u) → (m : Type u → Type v) → [inst : MonadStateOf σ m] → MonadState σ m",
  "offspring":
  ["MonadState.mk", "getThe", "MonadStateOf.set", "MonadStateOf.modifyGet"],
  "name": "instMonadState"},
 {"type":
  "∀ {A : Type u} [self : AddSemigroup A] (a b c : A), a + b + c = a + (b + c)",
  "offspring": [],
  "name": "AddSemigroup.add_assoc"},
 {"type":
  "∀ {α : Type u_1} [inst : Monoid α] (l : α) (r : ℕ) (tl : α) (tr : ℕ) (t : α), l = tl → r = tr → tl ^ tr = t → l ^ r = t",
  "offspring": [],
  "name": "Tactic.Ring.subst_into_pow"},
 {"type":
  "∀ {α : Type u_1} (self : UnionFind α) (x : α),\n  ∃ n m, UFModel.Models (Array.push self.arr { parent := Array.size self.arr, value := x, rank := 0 }) m",
  "offspring":
  ["UFModel.push",
   "Nat.le_add_right",
   "UFModel.Models.push",
   "UnionFind.model'"],
  "name": "UnionFind.push.proof_1"},
 {"type": "{α : Type u} → [inst : ToString α] → α → α",
  "offspring": ["dbgTrace"],
  "name": "dbgTraceVal"},
 {"type":
  "{α : Type u} → {β : Type v} → {γ : Type w} → [self : HShiftLeft α β γ] → α → β → γ",
  "offspring": [],
  "name": "HShiftLeft.hShiftLeft"},
 {"type":
  "{α : Type u} → {β : Type v} → {m : Type v → Type w} → [inst : Monad m] → (α → β → m β) → β → Subarray α → m β",
  "offspring":
  ["Array.foldrM", "Subarray.as", "Subarray.stop", "Subarray.start"],
  "name": "Subarray.foldrM"},
 {"type":
  "{α : Type u} → (α → Bool) → List α → List α × List α → List α × List α",
  "offspring": ["List.reverse"],
  "name": "List.partitionAux"},
 {"type":
  "{m : Type u → Type v} → [inst : Monad m] → {α : Type u} → m α → OptionT m α",
  "offspring": ["OptionT.mk"],
  "name": "OptionT.lift"},
 {"type": "Lean.ParserDescr", "offspring": [], "name": "«term-_»"},
 {"type": "Ord Bool",
  "offspring":
  ["Ord.mk", "Ordering", "Ordering.lt", "Ordering.gt", "Ordering.eq"],
  "name": "instOrdBool"},
 {"type":
  "∀ {A : Type u} [inst : AddMonoid A] {a b c : A}, b + a = 0 → a + c = 0 → b = c",
  "offspring": ["zero_add", "add_assoc", "add_zero"],
  "name": "left_neg_eq_right_neg"},
 {"type":
  "{α : Type u_1} → (α → Bool) → (as : Array α) → optParam ℕ 0 → optParam ℕ (Array.size as) → Array α",
  "offspring": ["Array.foldl", "Array.push"],
  "name": "Array.filter"},
 {"type": "∀ {a b : ℤ}, a - b ≤ 0 → a ≤ b",
  "offspring": [],
  "name": "Int.le_of_sub_nonpos"},
 {"type": "Lean.Name → Array Lean.Expr → Tactic.Ring.RingM Lean.Expr",
  "offspring":
  ["MonadReader.read",
   "Tactic.Ring.Cache.univ",
   "Tactic.Ring.Cache.α",
   "Tactic.Ring.Cache.cs"],
  "name": "Tactic.Ring.mkAppCS"},
 {"type": "∀ (a b : UInt64), a + b = { val := a.val + b.val }",
  "offspring": [],
  "name": "UInt64.add_def"},
 {"type":
  "{α β σ : Type u} → Sort u_1 → DoResultPR α β σ → DoResultPR α β σ → Sort u_1",
  "offspring": [],
  "name": "DoResultPR.noConfusionType"},
 {"type": "∀ {α : Type u} (as : List α), as ++ [] = as",
  "offspring": [],
  "name": "List.append_nil"}]