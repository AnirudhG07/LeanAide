[
  {
    "docString": "If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.",
    "prompts": "[{\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (↑r * x) ↔ LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (x * ↑r) ↔ LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop}, Reflexive r → ∀ {x y : α}, (x ≠ y → r x y) → r x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a reflexive relation `r : α → α → Prop` holds over `x y : α`,\\nit suffices to show it holds when `x ≠ y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {r : 𝕜},\\n  ‖r‖ < 1 → ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `‖r‖ < 1`, then `∑' n : ℕ, n * r ^ n = r / (1 - r) ^ 2`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  ↑(Polynomial.aeval r) p = 0 → IsFractionRing.num A r ∣ Polynomial.coeff p 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 1:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the numerator of `r` divides the constant coefficient \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  ↑(Polynomial.aeval r) p = 0 → ↑(IsFractionRing.den A r) ∣ Polynomial.leadingCoeff p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 2:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the denominator of `r` divides the leading coefficient \"},\n {\"theorem\":\n  \"∀ {ξ : ℝ}, Irrational ξ → Set.Infinite {q | |ξ - ↑q| < 1 / ↑q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ξ` is an irrational real number, then there are infinitely many good\\nrational approximations to `ξ`. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, LiouvilleWith p x → r ≠ 0 → LiouvilleWith p (x * ↑r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"theorem\": \"∀ {α : Type u_1} (r : Setoid α), Setoid.ker Quotient.mk'' = r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the quotient map induced by an equivalence relation r equals r. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b ≠ 0 → EuclideanDomain.r (EuclideanDomain.remainder a b) b\",\n  \"isProp\": true,\n  \"docString\": \"The relation `r` satisfies `r (a % b) b`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜],\\n  Filter.Tendsto (fun r => r⁻¹) Filter.atTop (nhdsWithin 0 (Set.Ioi 0))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {ξ : ℝ}, Irrational ξ → ∀ (q : ℚ), ∃ q', |ξ - ↑q'| < 1 / ↑q'.den ^ 2 ∧ |ξ - ↑q'| < |ξ - ↑q|\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any rational approximation `q` to the irrational real number `ξ`, there is\\na good rational approximation `q'` such that `|ξ - q'| < |ξ - q|`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : { x // x ∈ S })\\n  (t : R) (hst : ↑s * t ∈ S), r /ₒ s = r * t /ₒ { val := ↑s * t, property := hst }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `s * t ∈ S`. \"}]\n",
    "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (↑r * x) ↔ LiouvilleWith p x) :=\n\n/-- The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (x * ↑r) ↔ LiouvilleWith p x) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem ∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- To show a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nit suffices to show it holds when `x ≠ y`. -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop}, Reflexive r → ∀ {x y : α}, (x ≠ y → r x y) → r x y :=\n\n/-- If `‖r‖ < 1`, then `∑' n : ℕ, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {r : 𝕜},\n  ‖r‖ < 1 → ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- A solution has `x ≠ 0`. -/\ntheorem ∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0 :=\n\n/-- Rational root theorem part 1:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the numerator of `r` divides the constant coefficient -/\ntheorem ∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  ↑(Polynomial.aeval r) p = 0 → IsFractionRing.num A r ∣ Polynomial.coeff p 0 :=\n\n/-- Rational root theorem part 2:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the denominator of `r` divides the leading coefficient -/\ntheorem ∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  ↑(Polynomial.aeval r) p = 0 → ↑(IsFractionRing.den A r) ∣ Polynomial.leadingCoeff p :=\n\n/-- If `ξ` is an irrational real number, then there are infinitely many good\nrational approximations to `ξ`. -/\ntheorem ∀ {ξ : ℝ}, Irrational ξ → Set.Infinite {q | |ξ - ↑q| < 1 / ↑q.den ^ 2} :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, LiouvilleWith p x → r ≠ 0 → LiouvilleWith p (x * ↑r) :=\n\n/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\ntheorem ∀ {α : Type u_1} (r : Setoid α), Setoid.ker Quotient.mk'' = r :=\n\n/-- The relation `r` satisfies `r (a % b) b`. -/\ntheorem ∀ {R : Type u} [self : EuclideanDomain R] (a : R) {b : R}, b ≠ 0 → EuclideanDomain.r (EuclideanDomain.remainder a b) b :=\n\n/-- The function `r ↦ r⁻¹` tends to `0` on the right as `r → +∞`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜],\n  Filter.Tendsto (fun r => r⁻¹) Filter.atTop (nhdsWithin 0 (Set.Ioi 0)) :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- Given any rational approximation `q` to the irrational real number `ξ`, there is\na good rational approximation `q'` such that `|ξ - q'| < |ξ - q|`. -/\ntheorem ∀ {ξ : ℝ}, Irrational ξ → ∀ (q : ℚ), ∃ q', |ξ - ↑q'| < 1 / ↑q'.den ^ 2 ∧ |ξ - ↑q'| < |ξ - ↑q| :=\n\n/-- A fraction `r /ₒ s` is equal to its expansion by an arbitrary factor `t` if `s * t ∈ S`. -/\ntheorem ∀ {R : Type u_1} [inst : Monoid R] {S : Submonoid R} [inst_1 : OreLocalization.OreSet S] (r : R) (s : { x // x ∈ S })\n  (t : R) (hst : ↑s * t ∈ S), r /ₒ s = r * t /ₒ { val := ↑s * t, property := hst } :=\n\n/-- If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational. -/\ntheorem",
    "choices": [
      "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) "
    ]
  },
  {
    "docString": "Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α},\\n  BddBelow s → BddAbove s → Set.Nonempty s → sInf s ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\\nits supremum.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : DenselyOrdered α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α]\\n  [nonem : Nonempty α] (lo hi : Finset α),\\n  (∀ (x : α), x ∈ lo → ∀ (y : α), y ∈ hi → x < y) → ∃ m, (∀ (x : α), x ∈ lo → x < m) ∧ ∀ (y : α), y ∈ hi → m < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `α` is a nonempty dense linear order without endpoints, and\\nsuppose `lo`, `hi`, are finite subsets with all of `lo` strictly\\nbefore `hi`. Then there is an element of `α` strictly between `lo`\\nand `hi`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊆ B → Finset.toColex A ≤ Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A ⊆ B`, then `A ≤ B` in the colex order. Note the converse does not hold, as `⊆` is not a\\nlinear order. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\\n  Set.OrdConnected s ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, s ⊆ t → Metric.Bounded t → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a bounded set are also bounded \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {s₁ s₂ : Set E}, s₁ ⊆ s₂ → Bornology.IsVonNBounded 𝕜 s₂ → Bornology.IsVonNBounded 𝕜 s₁\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of bounded sets are bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\":\n  \"∀ {ι : Type v} {ι' : Type v'} {f : ι → Cardinal.{w}} {f' : ι' → Cardinal.{w'}},\\n  BddAbove (Set.range f) →\\n    BddAbove (Set.range f') →\\n      ∀ {g : ι → ι'},\\n        (∀ (i : ι), Cardinal.lift (f i) ≤ Cardinal.lift (f' (g i))) → Cardinal.lift (iSup f) ≤ Cardinal.lift (iSup f')\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove an inequality between the lifts to a common universe of two different supremums,\\nit suffices to show that the lift of each cardinal from the smaller supremum\\nif bounded by the lift of some cardinal from the larger supremum.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊂ B → Finset.toColex A < Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A ⊂ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\\n`⊆` is not a linear order. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded (s ∪ t) ↔ Metric.Bounded s ∧ Metric.Bounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] ⦃s t : Set α⦄, s ⊆ t → BddBelow t → BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"If `s ⊆ t` and `t` is bounded below, then so is `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (f g : α → ENNReal),\\n  ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ ≤ ∫⁻ (a : α), f a + g a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded below.\"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {γ : Type u_1} ⦃u₁ u₂ : UniformSpace γ⦄,\\n  u₁ ≤ u₂ → ∀ ⦃𝔖₁ 𝔖₂ : Set (Set α)⦄, 𝔖₂ ⊆ 𝔖₁ → UniformOnFun.uniformSpace α γ 𝔖₁ ≤ UniformOnFun.uniformSpace α γ 𝔖₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `u₁`, `u₂` be two uniform structures on `γ` and `𝔖₁ 𝔖₂ : Set (Set α)`. If `u₁ ≤ u₂` and\\n`𝔖₂ ⊆ 𝔖₁` then `𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : OrderClosedTopology α],\\n  IsClosed {p | p.fst ≤ p.snd}\",\n  \"isProp\": true,\n  \"docString\": \"The set `{ (x, y) | x ≤ y }` is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : LocallyFiniteOrder α] {a b c : α},\\n  Finset.uIcc a c ⊆ Finset.uIcc a b ∪ Finset.uIcc b c\",\n  \"isProp\": true,\n  \"docString\": \"A sort of triangle inequality. \"}]\n",
    "prompt_cons": "/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α},\n  BddBelow s → BddAbove s → Set.Nonempty s → sInf s ≤ sSup s :=\n\n/-- Suppose `α` is a nonempty dense linear order without endpoints, and\nsuppose `lo`, `hi`, are finite subsets with all of `lo` strictly\nbefore `hi`. Then there is an element of `α` strictly between `lo`\nand `hi`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : DenselyOrdered α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α]\n  [nonem : Nonempty α] (lo hi : Finset α),\n  (∀ (x : α), x ∈ lo → ∀ (y : α), y ∈ hi → x < y) → ∃ m, (∀ (x : α), x ∈ lo → x < m) ∧ ∀ (y : α), y ∈ hi → m < y :=\n\n/-- If `A ⊆ B`, then `A ≤ B` in the colex order. Note the converse does not hold, as `⊆` is not a\nlinear order. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊆ B → Finset.toColex A ≤ Finset.toColex B :=\n\n/-- It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\n  Set.OrdConnected s ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, s ⊆ t → Metric.Bounded t → Metric.Bounded s :=\n\n/-- Subsets of bounded sets are bounded. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {s₁ s₂ : Set E}, s₁ ⊆ s₂ → Bornology.IsVonNBounded 𝕜 s₂ → Bornology.IsVonNBounded 𝕜 s₁ :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s :=\n\n/-- To prove an inequality between the lifts to a common universe of two different supremums,\nit suffices to show that the lift of each cardinal from the smaller supremum\nif bounded by the lift of some cardinal from the larger supremum. -/\ntheorem ∀ {ι : Type v} {ι' : Type v'} {f : ι → Cardinal.{w}} {f' : ι' → Cardinal.{w'}},\n  BddAbove (Set.range f) →\n    BddAbove (Set.range f') →\n      ∀ {g : ι → ι'},\n        (∀ (i : ι), Cardinal.lift (f i) ≤ Cardinal.lift (f' (g i))) → Cardinal.lift (iSup f) ≤ Cardinal.lift (iSup f') :=\n\n/-- If `A ⊂ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\n`⊆` is not a linear order. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊂ B → Finset.toColex A < Finset.toColex B :=\n\n/-- The union of two sets is bounded iff each of the sets is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded (s ∪ t) ↔ Metric.Bounded s ∧ Metric.Bounded t :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t) :=\n\n/-- If `s ⊆ t` and `t` is bounded below, then so is `s`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] ⦃s t : Set α⦄, s ⊆ t → BddBelow t → BddBelow s :=\n\n/-- The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (f g : α → ENNReal),\n  ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ ≤ ∫⁻ (a : α), f a + g a ∂μ :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u)) :=\n\n/-- The union of two sets is bounded above if and only if each of the sets is. -/\ntheorem ∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t :=\n\n/-- A finite set is bounded below. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {s : Set α}, Set.Finite s → BddBelow s :=\n\n/-- Let `u₁`, `u₂` be two uniform structures on `γ` and `𝔖₁ 𝔖₂ : Set (Set α)`. If `u₁ ≤ u₂` and\n`𝔖₂ ⊆ 𝔖₁` then `𝒱(α, γ, 𝔖₁, u₁) ≤ 𝒱(α, γ, 𝔖₂, u₂)`. -/\ntheorem ∀ {α : Type u_2} {γ : Type u_1} ⦃u₁ u₂ : UniformSpace γ⦄,\n  u₁ ≤ u₂ → ∀ ⦃𝔖₁ 𝔖₂ : Set (Set α)⦄, 𝔖₂ ⊆ 𝔖₁ → UniformOnFun.uniformSpace α γ 𝔖₁ ≤ UniformOnFun.uniformSpace α γ 𝔖₂ :=\n\n/-- The set `{ (x, y) | x ≤ y }` is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : OrderClosedTopology α],\n  IsClosed {p | p.fst ≤ p.snd} :=\n\n/-- A sort of triangle inequality. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : LocallyFiniteOrder α] {a b c : α},\n  Finset.uIcc a c ⊆ Finset.uIcc a b ∪ Finset.uIcc b c :=\n\n/-- Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : Preorder α] {E : Set α} (hE : Set.Nonempty E) (α_lb : ∀ x ∈ E, α ≤ x) (β_ub : ∀ x ∈ E, x ≤ β),\n  α ≤ β "
    ]
  },
  {
    "docString": "Prove that no order can be defined in the complex field that turns it into an ordered field.",
    "prompts": "[{\"theorem\": \"¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : LinearOrderedField β],\\n  Subsingleton (α ≃+*o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring isomorphism between an archimedean linear ordered field and a\\nlinear ordered field. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : LinearOrderedField β] [inst_2 : Archimedean β],\\n  Subsingleton (α ≃+*o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring isomorphism between a linear ordered field and an archimedean\\nlinear ordered field. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\\n  [inst : T2Space α], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible T₂ space. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : LinearOrderedField β] [inst_2 : Archimedean β],\\n  Subsingleton (α →+*o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring homomorphism from a linear ordered field to an archimedean\\nlinear ordered field. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x : L}, x ∈ S → -x ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under negation. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any conditionally complete linearly ordered field is archimedean. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} {n : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {I I' : R →+* R} [inst_3 : Nontrivial R] {B : M →ₛₗ[I] M →ₛₗ[I'] R} {v : Basis n R M},\\n  LinearMap.IsOrthoᵢ B ↑v → LinearMap.SeparatingRight B → ∀ (i : n), ¬LinearMap.IsOrtho B (↑v i) (↑v i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An orthogonal basis with respect to a right-separating bilinear form has no self-orthogonal\\nelements. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x * y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n` \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K}, x ∈ s → -x ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under negation. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : Type w}\\n  [inst_3 : Nontrivial R] {B : BilinForm R M} {v : Basis n R M},\\n  BilinForm.iIsOrtho B ↑v → BilinForm.Nondegenerate B → ∀ (i : n), ¬BilinForm.IsOrtho B (↑v i) (↑v i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An orthogonal basis with respect to a nondegenerate bilinear form has no self-orthogonal\\nelements. \"}]\n",
    "prompt_cons": "/-- The complex numbers are not countable. -/\ntheorem ¬Set.Countable Set.univ :=\n\n/-- There is at most one ordered ring isomorphism between an archimedean linear ordered field and a\nlinear ordered field. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : LinearOrderedField β],\n  Subsingleton (α ≃+*o β) :=\n\n/-- There is at most one ordered ring isomorphism between a linear ordered field and an archimedean\nlinear ordered field. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : LinearOrderedField β] [inst_2 : Archimedean β],\n  Subsingleton (α ≃+*o β) :=\n\n/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\n  [inst : T2Space α], False :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- There is at most one ordered ring homomorphism from a linear ordered field to an archimedean\nlinear ordered field. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : LinearOrderedField β] [inst_2 : Archimedean β],\n  Subsingleton (α →+*o β) :=\n\n/-- An intermediate field is closed under negation. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x : L}, x ∈ S → -x ∈ S :=\n\n/-- Any conditionally complete linearly ordered field is archimedean. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- Fields are commutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem ∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- An orthogonal basis with respect to a right-separating bilinear form has no self-orthogonal\nelements. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} {n : Type u_3} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {I I' : R →+* R} [inst_3 : Nontrivial R] {B : M →ₛₗ[I] M →ₛₗ[I'] R} {v : Basis n R M},\n  LinearMap.IsOrthoᵢ B ↑v → LinearMap.SeparatingRight B → ∀ (i : n), ¬LinearMap.IsOrtho B (↑v i) (↑v i) :=\n\n/-- An intermediate field is closed under multiplication. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x * y ∈ S :=\n\n/-- Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n` -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K :=\n\n/-- A subfield is closed under negation. -/\ntheorem ∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K}, x ∈ s → -x ∈ s :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- An orthogonal basis with respect to a nondegenerate bilinear form has no self-orthogonal\nelements. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : Type w}\n  [inst_3 : Nontrivial R] {B : BilinForm R M} {v : Basis n R M},\n  BilinForm.iIsOrtho B ↑v → BilinForm.Nondegenerate B → ∀ (i : n), ¬BilinForm.IsOrtho B (↑v i) (↑v i) :=\n\n/-- Prove that no order can be defined in the complex field that turns it into an ordered field. -/\ntheorem",
    "choices": [
      "¬∃ (r : ℂ → ℂ → Prop), OrderedField ℂ "
    ]
  },
  {
    "docString": "If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$.",
    "prompts": "[{\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S • z| < 1`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : AddCommMonoid M] {f : α → M} (p : M → Prop),\\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (i : α), p (f i)) → p (∑ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite sum, it suffices to prove that the property is\\nadditive and holds on the summands.\"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∑ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite sum, it suffices to prove that the property is\\nadditive and holds on summands.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {α : Type v} {s : Finset α} {M : Type u_1} [inst : AddCommMonoid M] (f : α → M) (p : M → Prop),\\n  (∀ (a b : M), p a → p b → p (a + b)) →\\n    Finset.Nonempty s → (∀ (x : α), x ∈ s → p (f x)) → p (Finset.sum s fun x => f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a sum, it suffices to prove that\\nthe property is additive and holds on summands.\"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : AddCommGroup α] [inst_1 : DecidableEq α] (A B C : Finset α),\\n  Finset.card (A + C) * Finset.card B ≤ Finset.card (A + B) * Finset.card (B + C)\",\n  \"isProp\": true,\n  \"docString\": \"**Ruzsa's triangle inequality**. Addition version.\"},\n {\"theorem\":\n  \"∀ {a b : ℝ},\\n  a ≤ 0 →\\n    ∀ {z : ℂ},\\n      |z.im| ≤ b →\\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Nonempty α] [inst : DecidableEq α] (s : Finset α) (f : α → ℤ) (n : ℕ),\\n  (Finset.sum s fun i => Int.natAbs (f i)) ≤ n →\\n    ∃ β x sgn g,\\n      (∀ (b : β), ¬g b ∈ s → sgn b = 0) ∧\\n        Fintype.card β = n ∧ ∀ (a : α), a ∈ s → (Finset.sum Finset.univ fun i => if g i = a then ↑(sgn i) else 0) = f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can decompose a sum of absolute value less than `n` into a sum of at most `n` signs. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a ≤ a + b` \"},\n {\"theorem\":\n  \"∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) ≤ abs z`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} [inst : MeasurableSpace α] {ι : Type u_1} [inst_1 : Countable ι] {f : ι → α → ENNReal},\\n  (∀ (i : ι), Measurable (f i)) → Measurable fun x => ∑' (i : ι), f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"note: `ℝ≥0∞` can probably be generalized in a future version of this lemma. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\": \"Cardinal.mk ↑Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a set. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : AddCommGroup α] [inst_1 : DecidableEq α] (A B C : Finset α),\\n  Finset.card (A - C) * Finset.card B ≤ Finset.card (A + B) * Finset.card (B + C)\",\n  \"isProp\": true,\n  \"docString\": \"**Ruzsa's triangle inequality**. Sub-add-add version.\"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"}]\n",
    "prompt_cons": "/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- If `1 < |z|`, then `|S • z| < 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1 :=\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on the summands. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : AddCommMonoid M] {f : α → M} (p : M → Prop),\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (i : α), p (f i)) → p (∑ᶠ (i : α), f i) :=\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on summands. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∑ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands. -/\ntheorem ∀ {α : Type v} {s : Finset α} {M : Type u_1} [inst : AddCommMonoid M] (f : α → M) (p : M → Prop),\n  (∀ (a b : M), p a → p b → p (a + b)) →\n    Finset.Nonempty s → (∀ (x : α), x ∈ s → p (f x)) → p (Finset.sum s fun x => f x) :=\n\n/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem ∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2 :=\n\n/-- **Ruzsa's triangle inequality**. Addition version. -/\ntheorem ∀ {α : Type u_1} [inst : AddCommGroup α] [inst_1 : DecidableEq α] (A B C : Finset α),\n  Finset.card (A + C) * Finset.card B ≤ Finset.card (A + B) * Finset.card (B + C) :=\n\n/-- A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem ∀ {a b : ℝ},\n  a ≤ 0 →\n    ∀ {z : ℂ},\n      |z.im| ≤ b →\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- We can decompose a sum of absolute value less than `n` into a sum of at most `n` signs. -/\ntheorem ∀ {α : Type u_1} [inst : Nonempty α] [inst : DecidableEq α] (s : Finset α) (f : α → ℤ) (n : ℕ),\n  (Finset.sum s fun i => Int.natAbs (f i)) ≤ n →\n    ∃ β x sgn g,\n      (∀ (b : β), ¬g b ∈ s → sgn b = 0) ∧\n        Fintype.card β = n ∧ ∀ (a : α), a ∈ s → (Finset.sum Finset.univ fun i => if g i = a then ↑(sgn i) else 0) = f a :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p :=\n\n/-- For any `a` and `b`, `a ≤ a + b` -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b :=\n\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) ≤ abs z`. -/\ntheorem ∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z :=\n\n/-- note: `ℝ≥0∞` can probably be generalized in a future version of this lemma. -/\ntheorem ∀ {α : Type u_2} [inst : MeasurableSpace α] {ι : Type u_1} [inst_1 : Countable ι] {f : ι → α → ENNReal},\n  (∀ (i : ι), Measurable (f i)) → Measurable fun x => ∑' (i : ι), f i x :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- The cardinality of the complex numbers, as a set. -/\ntheorem Cardinal.mk ↑Set.univ = Cardinal.continuum :=\n\n/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- **Ruzsa's triangle inequality**. Sub-add-add version. -/\ntheorem ∀ {α : Type u_1} [inst : AddCommGroup α] [inst_1 : DecidableEq α] (A B C : Finset α),\n  Finset.card (A - C) * Finset.card B ≤ Finset.card (A + B) * Finset.card (B + C) :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem ∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I) :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem ∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ} {z : Finₓ n → ℂ}, ↑Complex.abs (Finₓ.sum z) ≤ Finₓ.sum (λ i, ↑Complex.abs (z i)) "
    ]
  },
  {
    "docString": "If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.",
    "prompts": "[{\"theorem\": \"∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S • z| < 1`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [↑(starRingEnd K) z = z, ∃ r, ↑r = z, ↑(↑IsROrC.re z) = z, ↑IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℚ),\\n  Finset.card (Set.toFinset (Polynomial.rootSet p ℂ)) =\\n    Finset.card (Set.toFinset (Polynomial.rootSet p ℝ)) +\\n      Finset.card\\n        (Equiv.Perm.support\\n          (↑(Polynomial.Gal.galActionHom p ℂ)\\n            (↑(Polynomial.Gal.restrict p ℂ) (AlgEquiv.restrictScalars ℚ Complex.conjAe))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of complex roots equals the number of real roots plus\\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). \"},\n {\"theorem\": \"Cardinal.mk ↑Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a set. \"},\n {\"theorem\":\n  \"∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z →\\n    Int.gcd x y = 1 →\\n      x % 2 = 1 →\\n        0 < z →\\n          ∃ m n,\\n            x = m ^ 2 - n ^ 2 ∧\\n              y = 2 * m * n ∧\\n                z = m ^ 2 + n ^ 2 ∧ Int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"by assuming `x` is odd and `z` is positive we get a slightly more precise classification of\\nthe Pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2`\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `ζ(0) = -1 / 2`. \"},\n {\"theorem\": \"Cardinal.mk ℂ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a type. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. \"},\n {\"theorem\":\n  \"∀ (z : ℂ),\\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (↑Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"},\n {\"theorem\":\n  \"Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\": \"`Complex.exp z → 0` as `Complex.re z → -∞`.\"},\n {\"theorem\":\n  \"∀ (z : ℂ), Complex.Gamma z * Complex.Gamma (1 - z) = ↑Real.pi / Complex.sin (↑Real.pi * z)\",\n  \"isProp\": true,\n  \"docString\": \"Euler's reflection formula for the complex Gamma function. \"},\n {\"theorem\":\n  \"∀ (z w : UpperHalfPlane), dist ↑z ↑w ≤ UpperHalfPlane.im w * (rexp (dist z w) - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An upper estimate on the complex distance between two points in terms of the hyperbolic distance\\nand the imaginary part of one of the points. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Lattice α] [inst_1 : CommGroup α] (a : α), 1 ≤ a → a⁺ = a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is positive, then it is equal to its positive component `a⁺`. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ},\\n  a ≤ 0 →\\n    ∀ {z : ℂ},\\n      |z.im| ≤ b →\\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"}]\n",
    "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem ∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem ∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I) :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- If `1 < |z|`, then `|S • z| < 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem ∀ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [↑(starRingEnd K) z = z, ∃ r, ↑r = z, ↑(↑IsROrC.re z) = z, ↑IsROrC.im z = 0] :=\n\n/-- The number of complex roots equals the number of real roots plus\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem ∀ (p : Polynomial ℚ),\n  Finset.card (Set.toFinset (Polynomial.rootSet p ℂ)) =\n    Finset.card (Set.toFinset (Polynomial.rootSet p ℝ)) +\n      Finset.card\n        (Equiv.Perm.support\n          (↑(Polynomial.Gal.galActionHom p ℂ)\n            (↑(Polynomial.Gal.restrict p ℂ) (AlgEquiv.restrictScalars ℚ Complex.conjAe)))) :=\n\n/-- The cardinality of the complex numbers, as a set. -/\ntheorem Cardinal.mk ↑Set.univ = Cardinal.continuum :=\n\n/-- If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem ∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- by assuming `x` is odd and `z` is positive we get a slightly more precise classification of\nthe Pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2` -/\ntheorem ∀ {x y z : ℤ},\n  PythagoreanTriple x y z →\n    Int.gcd x y = 1 →\n      x % 2 = 1 →\n        0 < z →\n          ∃ m n,\n            x = m ^ 2 - n ^ 2 ∧\n              y = 2 * m * n ∧\n                z = m ^ 2 + n ^ 2 ∧ Int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m :=\n\n/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re :=\n\n/-- We have `ζ(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The cardinality of the complex numbers, as a type. -/\ntheorem Cardinal.mk ℂ = Cardinal.continuum :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. -/\ntheorem ∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem ∀ (z : ℂ),\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (↑Real.pi * z))) :=\n\n/-- `Complex.exp z → 0` as `Complex.re z → -∞`. -/\ntheorem Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0) :=\n\n/-- Euler's reflection formula for the complex Gamma function. -/\ntheorem ∀ (z : ℂ), Complex.Gamma z * Complex.Gamma (1 - z) = ↑Real.pi / Complex.sin (↑Real.pi * z) :=\n\n/-- An upper estimate on the complex distance between two points in terms of the hyperbolic distance\nand the imaginary part of one of the points. -/\ntheorem ∀ (z w : UpperHalfPlane), dist ↑z ↑w ≤ UpperHalfPlane.im w * (rexp (dist z w) - 1) :=\n\n/-- If `a` is positive, then it is equal to its positive component `a⁺`. -/\ntheorem ∀ {α : Type u} [inst : Lattice α] [inst_1 : CommGroup α] (a : α), 1 ≤ a → a⁺ = a :=\n\n/-- A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem ∀ {a b : ℝ},\n  a ≤ 0 →\n    ∀ {z : ℂ},\n      |z.im| ≤ b →\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$. -/\ntheorem",
    "choices": [
      "∀ (z : ℂ), Complex.normSq z = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 "
    ]
  },
  {
    "docString": "Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\\n  inner a x * inner a y + ↑(↑(Orientation.areaForm o) a) x * ↑(↑(Orientation.areaForm o) a) y = ‖a‖ ^ 2 * inner x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For vectors `a x y : E`, the identity `⟪a, x⟫ * ⟪a, y⟫ + ω a x * ω a y = ‖a‖ ^ 2 * ⟪x, y⟫`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\\n  inner a x * ↑(↑(Orientation.areaForm o) a) y - ↑(↑(Orientation.areaForm o) a) x * inner a y =\\n    ‖a‖ ^ 2 * ↑(↑(Orientation.areaForm o) x) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For vectors `a x y : E`, the identity `⟪a, x⟫ * ω a y - ω a x * ⟪a, y⟫ = ‖a‖ ^ 2 * ω x y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\\n  ‖x‖ = ‖y‖ → ‖x + y‖ = ‖x‖ + ‖y‖ → x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\\ntheir sum is equal to the sum of their norms, then they are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : CommSemiring α] (x y : α) (n : ℕ),\\n  (Finset.sum (Finset.range n) fun i => (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"$x^n-y^n = (x-y) \\\\sum x^ky^{n-1-k}$ reformulated without `-` signs. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  ‖x + y‖ = ‖x - y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the sum of two vectors equals the norm of their difference if and only if\\nthe angle between them is π/2. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\\n  (∀ (r : R),\\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (n : ZMod 2) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q n → Prop},\\n  (∀ (v : CliffordAlgebra Q) (h : v ∈ LinearMap.range (CliffordAlgebra.ι Q) ^ ZMod.val n),\\n      P v (_ : v ∈ ⨆ (i : { n_1 // ↑n_1 = n }), LinearMap.range (CliffordAlgebra.ι Q) ^ ↑i)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q n} {hy : y ∈ CliffordAlgebra.evenOdd Q n},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q n)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q n},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q n)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q n), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even or odd part, it suffices to show it is true on the\\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\\nof vectors. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\\nsuch that `r₁ • x = r₂ • y`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x - y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\\nroots. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {x y : E},\\n  SameRay ℝ x y → ‖x + y‖ = ‖x‖ + ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\\nspace. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\\n  ¬SameRay ℝ x y → ‖x + y‖ < ‖x‖ + ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a strictly convex space, if `x` and `y` are not in the same ray, then `‖x + y‖ < ‖x‖ + ‖y‖`.\\n\"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {F : Type u_2} [inst : IsROrC 𝕜] [inst_1 : AddCommGroup F] [inst_2 : Module 𝕜 F]\\n  [c : InnerProductSpace.Core 𝕜 F] (x y : F),\\n  InnerProductSpace.Core.normSq (inner x y • x - inner x x • y) =\\n    InnerProductSpace.Core.normSq x *\\n      (InnerProductSpace.Core.normSq x * InnerProductSpace.Core.normSq y - ‖inner x y‖ ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An auxiliary equality useful to prove the **Cauchy–Schwarz inequality**: the square of the norm\\nof `⟪x, y⟫ • x - ⟪x, x⟫ • y` is equal to `‖x‖ ^ 2 * (‖x‖ ^ 2 * ‖y‖ ^ 2 - ‖⟪x, y⟫‖ ^ 2)`. We use\\n`InnerProductSpace.ofCore.normSq x` etc (defeq to `is_R_or_C.re ⟪x, x⟫`) instead of `‖x‖ ^ 2`\\netc to avoid extra rewrites when applying it to an `InnerProductSpace`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  inner x y = 0 → ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, subtracting vectors, vector inner product\\nform. \"}]\n",
    "prompt_cons": "/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ⟪a, y⟫ + ω a x * ω a y = ‖a‖ ^ 2 * ⟪x, y⟫`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\n  inner a x * inner a y + ↑(↑(Orientation.areaForm o) a) x * ↑(↑(Orientation.areaForm o) a) y = ‖a‖ ^ 2 * inner x y :=\n\n/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ω a y - ω a x * ⟪a, y⟫ = ‖a‖ ^ 2 * ω x y`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\n  inner a x * ↑(↑(Orientation.areaForm o) a) y - ↑(↑(Orientation.areaForm o) a) x * inner a y =\n    ‖a‖ ^ 2 * ↑(↑(Orientation.areaForm o) x) y :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n\n/-- If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\ntheir sum is equal to the sum of their norms, then they are equal. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\n  ‖x‖ = ‖y‖ → ‖x + y‖ = ‖x‖ + ‖y‖ → x = y :=\n\n/-- $x^n-y^n = (x-y) \\sum x^ky^{n-1-k}$ reformulated without `-` signs. -/\ntheorem ∀ {α : Type u} [inst : CommSemiring α] (x y : α) (n : ℕ),\n  (Finset.sum (Finset.range n) fun i => (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- The norm of the sum of two vectors equals the norm of their difference if and only if\nthe angle between them is π/2. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n  ‖x + y‖ = ‖x - y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\n  (∀ (r : R),\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- To show a property is true on the even or odd part, it suffices to show it is true on the\nscalars or vectors (respectively), closed under addition, and under left-multiplication by a pair\nof vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (n : ZMod 2) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q n → Prop},\n  (∀ (v : CliffordAlgebra Q) (h : v ∈ LinearMap.range (CliffordAlgebra.ι Q) ^ ZMod.val n),\n      P v (_ : v ∈ ⨆ (i : { n_1 // ↑n_1 = n }), LinearMap.range (CliffordAlgebra.ι Q) ^ ↑i)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q n} {hy : y ∈ CliffordAlgebra.evenOdd Q n},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q n)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q n},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q n)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q n), P x hx :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\nsuch that `r₁ • x = r₂ • y`. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y :=\n\n/-- Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\nroots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x - y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\nspace. -/\ntheorem ∀ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {x y : E},\n  SameRay ℝ x y → ‖x + y‖ = ‖x‖ + ‖y‖ :=\n\n/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `‖x + y‖ < ‖x‖ + ‖y‖`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\n  ¬SameRay ℝ x y → ‖x + y‖ < ‖x‖ + ‖y‖ :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re :=\n\n/-- An auxiliary equality useful to prove the **Cauchy–Schwarz inequality**: the square of the norm\nof `⟪x, y⟫ • x - ⟪x, x⟫ • y` is equal to `‖x‖ ^ 2 * (‖x‖ ^ 2 * ‖y‖ ^ 2 - ‖⟪x, y⟫‖ ^ 2)`. We use\n`InnerProductSpace.ofCore.normSq x` etc (defeq to `is_R_or_C.re ⟪x, x⟫`) instead of `‖x‖ ^ 2`\netc to avoid extra rewrites when applying it to an `InnerProductSpace`. -/\ntheorem ∀ {𝕜 : Type u_1} {F : Type u_2} [inst : IsROrC 𝕜] [inst_1 : AddCommGroup F] [inst_2 : Module 𝕜 F]\n  [c : InnerProductSpace.Core 𝕜 F] (x y : F),\n  InnerProductSpace.Core.normSq (inner x y • x - inner x x • y) =\n    InnerProductSpace.Core.normSq x *\n      (InnerProductSpace.Core.normSq x * InnerProductSpace.Core.normSq y - ‖inner x y‖ ^ 2) :=\n\n/-- Pythagorean theorem, subtracting vectors, vector inner product\nform. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  inner x y = 0 → ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n\n/-- Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * ‖x‖ * ‖x‖ + 2 * ‖y‖ * ‖y‖ "
    ]
  },
  {
    "docString": "If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y ≠ 0`. \"},\n {\"theorem\":\n  \"∀ (k : ℕ) {r : ℝ}, |r| < 1 → Filter.Tendsto (fun n => ↑n ^ k * r ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection Kᗮ] {v : E}, v ∈ K → ↑(orthogonalProjection Kᗮ) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `Kᗮ` of an element of `K` is zero. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(orthogonalProjection K) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `K` of an element of `Kᗮ` is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\\n  {B : BilinForm R M}, B ≠ 0 → BilinForm.IsSymm B → ∃ x, ¬BilinForm.IsOrtho B x x\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\\n`x : M` such that `B x x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\\n  FiniteDimensional.finrank k ↑V = 1 → CategoryTheory.Simple V\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `k`-algebra module which is 1-dimensional over `k` is simple. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : RingHomIsometric σ₁₂]\\n  (f : E →SL[σ₁₂] F) (M : NNReal), (∀ (x : E), ‖x‖₊ ≠ 0 → ‖↑f x‖₊ ≤ M * ‖x‖₊) → ‖f‖₊ ≤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `‖x‖₊ ≠ 0`, then one controls the norm of `A`. \"},\n {\"theorem\": \"∀ {x k l : ℕ}, 1 < x → (x ^ k ∣ x ^ l ↔ k ≤ l)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\\nsuch that `r₁ • x = r₂ • y`. \"},\n {\"theorem\": \"∀ {a b k : ℕ}, Nat.coprime a b → k ∣ a → k ∣ b → k = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `k:ℕ` divides coprime `a` and `b` then `k = 1` \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} {x y : E}, Dense ↑K → x - y ∈ Kᗮ → x = y\",\n  \"isProp\": true,\n  \"docString\": \"If `S` is dense and `x - y ∈ Kᗮ`, then `x = y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : α → M} {s : Set α},\\n  ∑ᶠ (i : α) (_ : i ∈ s), f i ≠ 0 → ∃ x, x ∈ s ∧ f x ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the product of `f i` over `i ∈ s` is not equal to `0`, then there is some `x ∈ s`\\nsuch that `f x ≠ 0`.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α},\\n  ∏ᶠ (i : α) (_ : i ∈ s), f i ≠ 1 → ∃ x, x ∈ s ∧ f x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the product of `f i` over `i ∈ s` is not equal to `1`, then there is some `x ∈ s` such that\\n`f x ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"}]\n",
    "prompt_cons": "/-- If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. -/\ntheorem ∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0 :=\n\n/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0 :=\n\n/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem ∀ (k : ℕ) {r : ℝ}, |r| < 1 → Filter.Tendsto (fun n => ↑n ^ k * r ^ n) Filter.atTop (nhds 0) :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- The orthogonal projection onto `Kᗮ` of an element of `K` is zero. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection Kᗮ] {v : E}, v ∈ K → ↑(orthogonalProjection Kᗮ) v = 0 :=\n\n/-- The orthogonal projection onto `K` of an element of `Kᗮ` is zero. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(orthogonalProjection K) v = 0 :=\n\n/-- There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\n`x : M` such that `B x x ≠ 0`. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\n  {B : BilinForm R M}, B ≠ 0 → BilinForm.IsSymm B → ∃ x, ¬BilinForm.IsOrtho B x x :=\n\n/-- Any `k`-algebra module which is 1-dimensional over `k` is simple. -/\ntheorem ∀ {R : Type u_2} [inst : Ring R] {k : Type u_1} [inst_1 : Field k] [inst_2 : Algebra k R] {V : ModuleCat R},\n  FiniteDimensional.finrank k ↑V = 1 → CategoryTheory.Simple V :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- If one controls the norm of every `A x`, `‖x‖₊ ≠ 0`, then one controls the norm of `A`. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : RingHomIsometric σ₁₂]\n  (f : E →SL[σ₁₂] F) (M : NNReal), (∀ (x : E), ‖x‖₊ ≠ 0 → ‖↑f x‖₊ ≤ M * ‖x‖₊) → ‖f‖₊ ≤ M :=\n\n/-- If `1 < x`, then `x^k` divides `x^l` if and only if `k` is at most `l`. -/\ntheorem ∀ {x k l : ℕ}, 1 < x → (x ^ k ∣ x ^ l ↔ k ≤ l) :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\nsuch that `r₁ • x = r₂ • y`. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y :=\n\n/-- If `k:ℕ` divides coprime `a` and `b` then `k = 1` -/\ntheorem ∀ {a b k : ℕ}, Nat.coprime a b → k ∣ a → k ∣ b → k = 1 :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- If `S` is dense and `x - y ∈ Kᗮ`, then `x = y`. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} {x y : E}, Dense ↑K → x - y ∈ Kᗮ → x = y :=\n\n/-- If the product of `f i` over `i ∈ s` is not equal to `0`, then there is some `x ∈ s`\nsuch that `f x ≠ 0`. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : α → M} {s : Set α},\n  ∑ᶠ (i : α) (_ : i ∈ s), f i ≠ 0 → ∃ x, x ∈ s ∧ f x ≠ 0 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- If the product of `f i` over `i ∈ s` is not equal to `1`, then there is some `x ∈ s` such that\n`f x ≠ 1`. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α},\n  ∏ᶠ (i : α) (_ : i ∈ s), f i ≠ 1 → ∃ x, x ∈ s ∧ f x ≠ 1 :=\n\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0 :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$ -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : Nontrivial R] {x : R},\n  (∃ y : R, y ≠ 0 ∧ x * y = 0) → x = 0 "
    ]
  },
  {
    "docString": "If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.",
    "prompts": "[{\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α]\\n  [inst_3 : OpensMeasurableSpace α] {s t : Set α},\\n  MeasureTheory.AnalyticSet s → MeasureTheory.AnalyticSet t → Disjoint s t → MeasureTheory.MeasurablySeparable s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lusin separation theorem: if two analytic sets are disjoint, then they are contained in\\ndisjoint Borel sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\\n  TopologicalSpace.SeparableSpace (α × β)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\\n  CompleteSpace ((i : ι) × E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : UniformSpace α] [inst_1 : SeparatedSpace α] {s : Set α}, IsComplete s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a separated space, a complete set is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι},\\n  Set.PairwiseDisjoint a s →\\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\\n  TopologicalSpace.SeparableSpace ((i : ι) → X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] {A B : Set E},\\n  IsExposed 𝕜 A B → Set.Nonempty B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\\ndoesn't intersect `A`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\\ndisjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\\n  Metric.Bounded s → IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {f : β → α} [inst_1 : TopologicalSpace β],\\n  Inducing f → ∀ {s : Set α}, TopologicalSpace.IsSeparable s → TopologicalSpace.IsSeparable (f ⁻¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a separable set by an inducing map is separable. \"}]\n",
    "prompt_cons": "/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- The Lusin separation theorem: if two analytic sets are disjoint, then they are contained in\ndisjoint Borel sets. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α]\n  [inst_3 : OpensMeasurableSpace α] {s t : Set α},\n  MeasureTheory.AnalyticSet s → MeasureTheory.AnalyticSet t → Disjoint s t → MeasureTheory.MeasurablySeparable s t :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\n  TopologicalSpace.SeparableSpace (α × β) :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\n  CompleteSpace ((i : ι) × E i) :=\n\n/-- In a separated space, a complete set is closed. -/\ntheorem ∀ {α : Type u_1} [inst : UniformSpace α] [inst_1 : SeparatedSpace α] {s : Set α}, IsComplete s → IsClosed s :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem ∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  TopologicalSpace.SeparableSpace ((i : ι) → X i) :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V) :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] {A B : Set E},\n  IsExposed 𝕜 A B → Set.Nonempty B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x} :=\n\n/-- Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\ndisjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure) :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\n  Metric.Bounded s → IsCompact (closure s) :=\n\n/-- The preimage of a separable set by an inducing map is separable. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {f : β → α} [inst_1 : TopologicalSpace β],\n  Inducing f → ∀ {s : Set α}, TopologicalSpace.IsSeparable s → TopologicalSpace.IsSeparable (f ⁻¹' s) :=\n\n/-- If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → Separated A B "
    ]
  },
  {
    "docString": "Prove that every compact metric space $K$ has a countable base.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α},\\n  IsCompact s → ∀ {e : ℝ}, 0 < e → ∃ t, t ⊆ s ∧ Set.Finite t ∧ s ⊆ ⋃ (x : α) (_ : x ∈ t), Metric.ball x e\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any compact set in a pseudometric space can be covered by finitely many balls of a given\\npositive radius \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : ProperSpace α], TopologicalSpace.SecondCountableTopology α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A proper pseudo metric space is sigma compact, and therefore second countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\\n  Measurable f → MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  IsSeqCompact s → IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝓤 β` is countably generated, then any sequentially compact set is compact. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the topology of a space is induced by a countable family of seminorms, then the topology\\nis first countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, strongly measurable and measurable are equivalent. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {f : α → β} {x : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} [inst_1 : MeasurableSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\\n  Measurable f → MeasureTheory.AEStronglyMeasurable f μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies ae strongly measurable. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\\n  TopologicalSpace.SeparableSpace ((i : ι) → X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.FirstCountableTopology X], FrechetUrysohnSpace X\",\n  \"isProp\": true,\n  \"docString\": \"Every first-countable space is a Fréchet-Urysohn space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the type of nonempty compact subsets is second countable \"}]\n",
    "prompt_cons": "/-- In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α},\n  IsCompact s → ∀ {e : ℝ}, 0 < e → ∃ t, t ⊆ s ∧ Set.Finite t ∧ s ⊆ ⋃ (x : α) (_ : x ∈ t), Metric.ball x e :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- A proper pseudo metric space is sigma compact, and therefore second countable. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : ProperSpace α], TopologicalSpace.SecondCountableTopology α :=\n\n/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\n  Measurable f → MeasureTheory.StronglyMeasurable f :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- If `𝓤 β` is countably generated, then any sequentially compact set is compact. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  IsSeqCompact s → IsCompact s :=\n\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E :=\n\n/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f :=\n\n/-- In a space with second countable topology, measurable implies ae strongly measurable. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {f : α → β} {x : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} [inst_1 : MeasurableSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\n  Measurable f → MeasureTheory.AEStronglyMeasurable f μ :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem ∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  TopologicalSpace.SeparableSpace ((i : ι) → X i) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s)) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- Every first-countable space is a Fréchet-Urysohn space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.FirstCountableTopology X], FrechetUrysohnSpace X :=\n\n/-- In a second countable space, the type of nonempty compact subsets is second countable -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts α) :=\n\n/-- Prove that every compact metric space $K$ has a countable base. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : CompactSpace α], TopologicalSpace.SecondCountableTopology α "
    ]
  },
  {
    "docString": "Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\\n  Monotone f →\\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\\n      Set.Countable {x | ¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where a monotone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\\n  Antitone f →\\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\\n      Set.Countable {x | ¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where an antitone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι},\\n  Set.PairwiseDisjoint a s →\\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α}\\n  [inst_1 : MeasureTheory.SigmaFinite μ] {As : ι → Set α},\\n  (∀ (i : ι), MeasurableSet (As i)) → Pairwise (Disjoint on As) → Set.Countable {i | 0 < ↑↑μ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a σ-finite space, among disjoint measurable sets, only countably many can have positive\\nmeasure. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] (x : α) {s : Set α},\\n  s ∈ nhds x → Set.Finite s → IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\\n  (s : Set β),\\n  IsCompact s →\\n    ∀ (A : Set (BoundedContinuousFunction α β)),\\n      IsClosed A →\\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [inst : MetricSpace β]\\n  {μ : MeasureTheory.Measure α} [inst_1 : SemilatticeSup ι] [inst_2 : Nonempty ι] [inst_3 : Countable ι] {f : ι → α → β}\\n  {g : α → β} [inst_4 : MeasureTheory.IsFiniteMeasure μ],\\n  (∀ (n : ι), MeasureTheory.StronglyMeasurable (f n)) →\\n    MeasureTheory.StronglyMeasurable g →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\\n        ∀ {ε : ℝ}, 0 < ε → ∃ t, MeasurableSet t ∧ ↑↑μ t ≤ ENNReal.ofReal ε ∧ TendstoUniformlyOn f g Filter.atTop tᶜ\",\n  \"isProp\": true,\n  \"docString\": \"Egorov's theorem for finite measure spaces. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the type of nonempty compact subsets is second countable \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\\n      MeasureTheory.Integrable bound →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology α], Set.Countable {x | nhdsWithin x (Set.Iio x) = ⊥}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points which are isolated on the left is countable when the space is\\nsecond-countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x y : α} {s : Set α}, y ∈ s → EMetric.infEdist x s ≤ edist x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The edist to a set is bounded above by the edist to any of its points \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {L : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {F s : Set E}\\n  [inst_1 : AddCommGroup L] [inst_2 : Countable L] [inst_3 : AddAction L E] [inst_4 : MeasurableSpace L]\\n  [inst_5 : MeasurableVAdd L E] [inst_6 : MeasureTheory.VAddInvariantMeasure L E μ],\\n  MeasureTheory.IsAddFundamentalDomain L F →\\n    MeasureTheory.NullMeasurableSet s → ↑↑μ F < ↑↑μ s → ∃ x y, x ≠ y ∧ ¬Disjoint (x +ᵥ s) (y +ᵥ s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Blichfeldt's Theorem**. If the volume of the set `s` is larger than the covolume of the\\ncountable subgroup `L` of `E`, then there exist two distinct points `x, y ∈ L` such that `(x + s)`\\nand `(y + s)` are not disjoint. \"}]\n",
    "prompt_cons": "/-- In a second countable space, the set of points where a monotone function is not continuous\nis at most countable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\n  Monotone f →\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\n      Set.Countable {x | ¬ContinuousAt f x} :=\n\n/-- In a second countable space, the set of points where an antitone function is not continuous\nis at most countable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\n  Antitone f →\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\n      Set.Countable {x | ¬ContinuousAt f x} :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i) :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a :=\n\n/-- In a σ-finite space, among disjoint measurable sets, only countably many can have positive\nmeasure. -/\ntheorem ∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α}\n  [inst_1 : MeasureTheory.SigmaFinite μ] {As : ι → Set α},\n  (∀ (i : ι), MeasurableSet (As i)) → Pairwise (Disjoint on As) → Set.Countable {i | 0 < ↑↑μ (As i)} :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] (x : α) {s : Set α},\n  s ∈ nhds x → Set.Finite s → IsOpen {x} :=\n\n/-- There exists a countable dense set. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\n  (s : Set β),\n  IsCompact s →\n    ∀ (A : Set (BoundedContinuousFunction α β)),\n      IsClosed A →\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A :=\n\n/-- Egorov's theorem for finite measure spaces. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [inst : MetricSpace β]\n  {μ : MeasureTheory.Measure α} [inst_1 : SemilatticeSup ι] [inst_2 : Nonempty ι] [inst_3 : Countable ι] {f : ι → α → β}\n  {g : α → β} [inst_4 : MeasureTheory.IsFiniteMeasure μ],\n  (∀ (n : ι), MeasureTheory.StronglyMeasurable (f n)) →\n    MeasureTheory.StronglyMeasurable g →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\n        ∀ {ε : ℝ}, 0 < ε → ∃ t, MeasurableSet t ∧ ↑↑μ t ≤ ENNReal.ofReal ε ∧ TendstoUniformlyOn f g Filter.atTop tᶜ :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- In a second countable space, the type of nonempty compact subsets is second countable -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts α) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a} :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\n      MeasureTheory.Integrable bound →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f)) :=\n\n/-- The set of points which are isolated on the left is countable when the space is\nsecond-countable. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : TopologicalSpace.SecondCountableTopology α], Set.Countable {x | nhdsWithin x (Set.Iio x) = ⊥} :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- The edist to a set is bounded above by the edist to any of its points -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x y : α} {s : Set α}, y ∈ s → EMetric.infEdist x s ≤ edist x y :=\n\n/-- **Blichfeldt's Theorem**. If the volume of the set `s` is larger than the covolume of the\ncountable subgroup `L` of `E`, then there exist two distinct points `x, y ∈ L` such that `(x + s)`\nand `(y + s)` are not disjoint. -/\ntheorem ∀ {E : Type u_2} {L : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {F s : Set E}\n  [inst_1 : AddCommGroup L] [inst_2 : Countable L] [inst_3 : AddAction L E] [inst_4 : MeasurableSpace L]\n  [inst_5 : MeasurableVAdd L E] [inst_6 : MeasureTheory.VAddInvariantMeasure L E μ],\n  MeasureTheory.IsAddFundamentalDomain L F →\n    MeasureTheory.NullMeasurableSet s → ↑↑μ F < ↑↑μ s → ∃ x y, x ≠ y ∧ ¬Disjoint (x +ᵥ s) (y +ᵥ s) :=\n\n/-- Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$. -/\ntheorem",
    "choices": [
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : T2Space α],\n  ∀ (E : Set α), ¬Set.Countable E → Set.Countable (E \\ TopologicalSpace.CondensationPoints E) "
    ]
  },
  {
    "docString": "Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {As : ι → Set α},\\n  (∀ (i : ι), MeasurableSet (As i)) →\\n    Pairwise (Disjoint on As) → ↑↑μ (⋃ (i : ι), As i) ≠ ⊤ → Set.Countable {i | 0 < ↑↑μ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\ncountably many members of the union whose measure is positive. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {As : ι → Set α},\\n  (∀ (i : ι), MeasurableSet (As i)) → Pairwise (Disjoint on As) → ∑' (i : ι), ↑↑μ (As i) ≤ ↑↑μ (⋃ (i : ι), As i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of\\nthe measures of the sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {I : Set β} {s : β → Set α},\\n  Set.Finite I → (Metric.Bounded (⋃ (i : β) (_ : i ∈ I), s i) ↔ ∀ (i : β), i ∈ I → Metric.Bounded (s i))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of bounded sets is bounded \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι},\\n  Set.PairwiseDisjoint a s →\\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {ε : ENNReal},\\n  0 < ε →\\n    ∀ {As : ι → Set α},\\n      (∀ (i : ι), MeasurableSet (As i)) →\\n        Pairwise (Disjoint on As) → ↑↑μ (⋃ (i : ι), As i) ≠ ⊤ → Set.Finite {i | ε ≤ ↑↑μ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\nfinitely many members of the union whose measure exceeds any given positive number. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) →\\n    Pairwise (Disjoint on s) → (∀ (i : ι), IsOpen (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any disjoint cover by non-empty open subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) →\\n    Pairwise (Disjoint on s) →\\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : TopologicalSpace.SecondCountableTopology X],\\n  MeasureTheory.LocallyIntegrable f →\\n    ∃ u, (∀ (n : ℕ), IsOpen (u n)) ∧ ⋃ (n : ℕ), u n = Set.univ ∧ ∀ (n : ℕ), MeasureTheory.IntegrableOn f (u n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is locally integrable in a second countable topological space,\\nthen there exists a sequence of open sets covering the space on which it is integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\\n  IsClosed s →\\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"}]\n",
    "prompt_cons": "/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem ∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {As : ι → Set α},\n  (∀ (i : ι), MeasurableSet (As i)) →\n    Pairwise (Disjoint on As) → ↑↑μ (⋃ (i : ι), As i) ≠ ⊤ → Set.Countable {i | 0 < ↑↑μ (As i)} :=\n\n/-- The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of\nthe measures of the sets. -/\ntheorem ∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {As : ι → Set α},\n  (∀ (i : ι), MeasurableSet (As i)) → Pairwise (Disjoint on As) → ∑' (i : ι), ↑↑μ (As i) ≤ ↑↑μ (⋃ (i : ι), As i) :=\n\n/-- A finite union of bounded sets is bounded -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {I : Set β} {s : β → Set α},\n  Set.Finite I → (Metric.Bounded (⋃ (i : β) (_ : i ∈ I), s i) ↔ ∀ (i : β), i ∈ I → Metric.Bounded (s i)) :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\nfinitely many members of the union whose measure exceeds any given positive number. -/\ntheorem ∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {ε : ENNReal},\n  0 < ε →\n    ∀ {As : ι → Set α},\n      (∀ (i : ι), MeasurableSet (As i)) →\n        Pairwise (Disjoint on As) → ↑↑μ (⋃ (i : ι), As i) ≠ ⊤ → Set.Finite {i | ε ≤ ↑↑μ (As i)} :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- In a preconnected space, any disjoint cover by non-empty open subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) →\n    Pairwise (Disjoint on s) → (∀ (i : ι), IsOpen (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) →\n    Pairwise (Disjoint on s) →\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι :=\n\n/-- If a function is locally integrable in a second countable topological space,\nthen there exists a sequence of open sets covering the space on which it is integrable. -/\ntheorem ∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : TopologicalSpace.SecondCountableTopology X],\n  MeasureTheory.LocallyIntegrable f →\n    ∃ u, (∀ (n : ℕ), IsOpen (u n)) ∧ ⋃ (n : ℕ), u n = Set.univ ∧ ∀ (n : ℕ), MeasureTheory.IntegrableOn f (u n) :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\n  IsClosed s →\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a :=\n\n/-- Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α]\n  {s : Set α}, IsOpen s → ∃ U, (∀ (i : ℕ), IsOpen (U i)) ∧ Pairwise (Disjoint on U) ∧ s = ⋃ (i : ℕ), U i "
    ]
  },
  {
    "docString": "Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$.",
    "prompts": "[{\"theorem\":\n  \"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) → CauchySeq f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `ζ(0) = -1 / 2`. \"},\n {\"theorem\": \"Real.Gamma (1 / 2) = Real.sqrt Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"The special-value formula `Γ(1/2) = √π`, which is equivalent to the Gaussian integral. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) →\\n    ∀ {a : α}, Filter.Tendsto f Filter.atTop (nhds a) → ∀ (n : ℕ), dist (f n) a ≤ C / 2 ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\\n`f n` to the limit of `f` is bounded above by `C / 2^n`. \"},\n {\"theorem\":\n  \"∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2`  \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"∀ (n : ℕ), 512 ≤ n → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) →\\n    ∀ {a : α}, Filter.Tendsto f Filter.atTop (nhds a) → dist (f 0) a ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\\n`f 0` to the limit of `f` is bounded above by `C`. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"}]\n",
    "prompt_cons": "/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/\ntheorem ∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) → CauchySeq f :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- We have `ζ(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The special-value formula `Γ(1/2) = √π`, which is equivalent to the Gaussian integral. -/\ntheorem Real.Gamma (1 / 2) = Real.sqrt Real.pi :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f n` to the limit of `f` is bounded above by `C / 2^n`. -/\ntheorem ∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) →\n    ∀ {a : α}, Filter.Tendsto f Filter.atTop (nhds a) → ∀ (n : ℕ), dist (f n) a ≤ C / 2 ^ n :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2` -/\ntheorem ∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem ∀ (n : ℕ), 512 ≤ n → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then the distance from\n`f 0` to the limit of `f` is bounded above by `C`. -/\ntheorem ∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) →\n    ∀ {a : α}, Filter.Tendsto f Filter.atTop (nhds a) → dist (f 0) a ≤ C :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1 :=\n\n/-- Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$. -/\ntheorem",
    "choices": [
      "Filter.Tendsto (fun n => Real.sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) "
    ]
  },
  {
    "docString": "For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$.",
    "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E]\\n  {a b : ℝ} [inst_3 : Countable ι] {f : ι → C(ℝ, E)},\\n  (Summable fun i =>\\n      ‖ContinuousMap.restrict (↑{ carrier := Set.uIcc a b, isCompact' := (_ : IsCompact (Set.uIcc a b)) }) (f i)‖) →\\n    HasSum (fun i => ∫ (x : ℝ) in a..b, ↑(f i) x) (∫ (x : ℝ) in a..b, ∑' (i : ι), ↑(f i) x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Interval integrals commute with countable sums, when the supremum norms are summable (a\\nspecial case of the dominated convergence theorem). \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a ≤ a + b` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid γ]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] [inst_4 : ContinuousAdd γ] {f g : α → γ},\\n  UpperSemicontinuousAt f x → UpperSemicontinuousAt g x → UpperSemicontinuousAt (fun z => f z + g z) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\\naddition, for application to `EReal`. \"},\n {\"theorem\":\n  \"∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} [inst : MeasureTheory.IsProbabilityMeasure μ]\\n  {s : ℕ → Set Ω},\\n  (∀ (n : ℕ), MeasurableSet (s n)) →\\n    ProbabilityTheory.iIndepSet s → ∑' (n : ℕ), ↑↑μ (s n) = ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sₙ)` such that\\n`∑ n, μ sₙ = ∞`, `limsup sₙ` has measure 1. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\\n  [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α] {f : Filter β} {u : β → α} {s : Set α},\\n  Dense s →\\n    (∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a < b → ¬((∃ᶠ (n : β) in f, u n < a) ∧ ∃ᶠ (n : β) in f, b < u n)) →\\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) f u) _auto✝ →\\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≥ x_1) f u) _auto✝¹ → ∃ c, Filter.Tendsto u f (nhds c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\\nworks if `a` and `b` are restricted to a dense subset.\\n\"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid γ]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] {f g : α → γ},\\n  UpperSemicontinuousAt f x →\\n    UpperSemicontinuousAt g x →\\n      ContinuousAt (fun p => p.fst + p.snd) (f x, g x) → UpperSemicontinuousAt (fun z => f z + g z) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\\nthe lemma uses `[ContinuousAdd]`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\\n  [inst_2 : OrderTopology α] {f : Filter β} {u : β → α} {a : α} [inst_3 : Filter.NeBot f],\\n  Filter.Tendsto u f (nhds a) → Filter.limsup u f = a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a limit, then its limsup coincides with its limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_3} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : α → ℝ}\\n  {f : α → β → F},\\n  Summable u →\\n    (∀ (n : α) (x : β), ‖f n x‖ ≤ u n) →\\n      TendstoUniformly (fun t x => Finset.sum t fun n => f n x) (fun x => ∑' (n : α), f n x) Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion with general index set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : α → ℝ}\\n  {f : α → β → F},\\n  Summable u →\\n    ∀ {s : Set β},\\n      (∀ (n : α) (x : β), x ∈ s → ‖f n x‖ ≤ u n) →\\n        TendstoUniformlyOn (fun t x => Finset.sum t fun n => f n x) (fun x => ∑' (n : α), f n x) Filter.atTop s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion relative to a set, with general index set. \"},\n {\"theorem\":\n  \"∀ {v : ℕ → ℝ} {c : ℝ}, 0 < v 0 → 1 < c → (∀ (n : ℕ), c * v n ≤ v (n + 1)) → Filter.Tendsto v Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence `v` of real numbers satisfies `k * v n ≤ v (n+1)` with `1 < k`,\\nthen it goes to +∞. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal},\\n  (∀ (a : α), a ∈ s → f a ≠ ⊤) → ENNReal.toReal (Finset.sum s fun a => f a) = Finset.sum s fun a => ENNReal.toReal (f a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"seeing `ℝ≥0∞` as `Real` does not change their sum, unless one of the `ℝ≥0∞` is infinity \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(ℝ, E)},\\n  (Summable fun n => ‖ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight ↑n))‖) →\\n    MeasureTheory.Integrable ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence with `n`-th term the the sup norm of `λ x, f (x + n)` on the interval `Icc 0 1`,\\nfor `n ∈ ℤ`, is summable, then `f` is integrable on `ℝ`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : ℕ → Set α},\\n  ∑' (i : ℕ), ↑↑μ (s i) ≠ ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"One direction of the **Borel-Cantelli lemma**: if (sᵢ) is a sequence of sets such\\nthat `∑ μ sᵢ` is finite, then the limit superior of the `sᵢ` is a null set. \"}]\n",
    "prompt_cons": "/-- Interval integrals commute with countable sums, when the supremum norms are summable (a\nspecial case of the dominated convergence theorem). -/\ntheorem ∀ {ι : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E]\n  {a b : ℝ} [inst_3 : Countable ι] {f : ι → C(ℝ, E)},\n  (Summable fun i =>\n      ‖ContinuousMap.restrict (↑{ carrier := Set.uIcc a b, isCompact' := (_ : IsCompact (Set.uIcc a b)) }) (f i)‖) →\n    HasSum (fun i => ∫ (x : ℝ) in a..b, ↑(f i) x) (∫ (x : ℝ) in a..b, ∑' (i : ι), ↑(f i) x) :=\n\n/-- For any `a` and `b`, `a ≤ a + b` -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b :=\n\n/-- The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid γ]\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] [inst_4 : ContinuousAdd γ] {f g : α → γ},\n  UpperSemicontinuousAt f x → UpperSemicontinuousAt g x → UpperSemicontinuousAt (fun z => f z + g z) x :=\n\n/-- **The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sₙ)` such that\n`∑ n, μ sₙ = ∞`, `limsup sₙ` has measure 1. -/\ntheorem ∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} [inst : MeasureTheory.IsProbabilityMeasure μ]\n  {s : ℕ → Set Ω},\n  (∀ (n : ℕ), MeasurableSet (s n)) →\n    ProbabilityTheory.iIndepSet s → ∑' (n : ℕ), ↑↑μ (s n) = ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 1 :=\n\n/-- Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α] {f : Filter β} {u : β → α} {s : Set α},\n  Dense s →\n    (∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a < b → ¬((∃ᶠ (n : β) in f, u n < a) ∧ ∃ᶠ (n : β) in f, b < u n)) →\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) f u) _auto✝ →\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≥ x_1) f u) _auto✝¹ → ∃ c, Filter.Tendsto u f (nhds c) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with an\nexplicit continuity assumption on addition, for application to `EReal`. The unprimed version of\nthe lemma uses `[ContinuousAdd]`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid γ]\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] {f g : α → γ},\n  UpperSemicontinuousAt f x →\n    UpperSemicontinuousAt g x →\n      ContinuousAt (fun p => p.fst + p.snd) (f x, g x) → UpperSemicontinuousAt (fun z => f z + g z) x :=\n\n/-- If a function has a limit, then its limsup coincides with its limit. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] {f : Filter β} {u : β → α} {a : α} [inst_3 : Filter.NeBot f],\n  Filter.Tendsto u f (nhds a) → Filter.limsup u f = a :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion with general index set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_3} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : α → ℝ}\n  {f : α → β → F},\n  Summable u →\n    (∀ (n : α) (x : β), ‖f n x‖ ≤ u n) →\n      TendstoUniformly (fun t x => Finset.sum t fun n => f n x) (fun x => ∑' (n : α), f n x) Filter.atTop :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion relative to a set, with general index set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : α → ℝ}\n  {f : α → β → F},\n  Summable u →\n    ∀ {s : Set β},\n      (∀ (n : α) (x : β), x ∈ s → ‖f n x‖ ≤ u n) →\n        TendstoUniformlyOn (fun t x => Finset.sum t fun n => f n x) (fun x => ∑' (n : α), f n x) Filter.atTop s :=\n\n/-- If a sequence `v` of real numbers satisfies `k * v n ≤ v (n+1)` with `1 < k`,\nthen it goes to +∞. -/\ntheorem ∀ {v : ℕ → ℝ} {c : ℝ}, 0 < v 0 → 1 < c → (∀ (n : ℕ), c * v n ≤ v (n + 1)) → Filter.Tendsto v Filter.atTop Filter.atTop :=\n\n/-- seeing `ℝ≥0∞` as `Real` does not change their sum, unless one of the `ℝ≥0∞` is infinity -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal},\n  (∀ (a : α), a ∈ s → f a ≠ ⊤) → ENNReal.toReal (Finset.sum s fun a => f a) = Finset.sum s fun a => ENNReal.toReal (f a) :=\n\n/-- If the sequence with `n`-th term the the sup norm of `λ x, f (x + n)` on the interval `Icc 0 1`,\nfor `n ∈ ℤ`, is summable, then `f` is integrable on `ℝ`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(ℝ, E)},\n  (Summable fun n => ‖ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight ↑n))‖) →\n    MeasureTheory.Integrable ↑f :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- One direction of the **Borel-Cantelli lemma**: if (sᵢ) is a sequence of sets such\nthat `∑ μ sᵢ` is finite, then the limit superior of the `sᵢ` is a null set. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : ℕ → Set α},\n  ∑' (i : ℕ), ↑↑μ (s i) ≠ ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 0 :=\n\n/-- For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  {f g : ℕ → α},\n  Filter.limsup (fun n => f n + g n) Filter.atTop ≤ Filter.limsup f Filter.atTop + Filter.limsup g Filter.atTop "
    ]
  },
  {
    "docString": "Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$.",
    "prompts": "[{\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {a : α} {f : ℕ → α},\\n  HasSum f a → Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℕ → α` has sum `a`, then the partial sums `∑_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : AddCommGroup α] [inst_1 : UniformSpace α] [inst_2 : CompleteSpace α]\\n  {f : β → α}, Summable f ↔ CauchySeq fun s => Finset.sum s fun b => f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `𝓝 a` as `x → ∞` \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\\n      MeasureTheory.Integrable bound →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\\n  CauchySeq u →\\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop →\\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -1 ≤ a → ∀ (n : ℕ), 1 + ↑n * (a - 1) ≤ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"Bernoulli's inequality reformulated to estimate `a^n`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) (p : ℕ → ℝ),\\n  (∀ (k : ℕ), 0 ≤ p k) →\\n    ∀ {r a : ℝ},\\n      0 ≤ r →\\n        0 ≤ a →\\n          (Finset.sum (Finset.Ico 2 (n + 1)) fun k =>\\n              a ^ k *\\n                Finset.sum (Set.toFinset {c | 1 < Composition.length c}) fun c =>\\n                  r ^ Composition.length c * Finset.prod Finset.univ fun j => p (Composition.blocksFun c j)) ≤\\n            Finset.sum (Finset.Ico 2 (n + 1)) fun j => r ^ j * (Finset.sum (Finset.Ico 1 n) fun k => a ^ k * p k) ^ j\",\n  \"isProp\": true,\n  \"docString\":\n  \"First technical lemma to control the growth of coefficients of the inverse. Bound the explicit\\nexpression for `∑_{k<n+1} aᵏ Qₖ` in terms of a sum of powers of the same sum one step before,\\nin a general abstract setup. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {F : ℕ → α → ENNReal} {f : α → ENNReal}\\n  (bound : α → ENNReal),\\n  (∀ (n : ℕ), Measurable (F n)) →\\n    (∀ (n : ℕ), F n ≤ᶠ[MeasureTheory.Measure.ae μ] bound) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) Filter.atTop (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Dominated convergence theorem for nonnegative functions \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"}]\n",
    "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- If `f : ℕ → α` has sum `a`, then the partial sums `∑_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem ∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {a : α} {f : ℕ → α},\n  HasSum f a → Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi :=\n\n/-- The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommGroup α] [inst_1 : UniformSpace α] [inst_2 : CompleteSpace α]\n  {f : β → α}, Summable f ↔ CauchySeq fun s => Finset.sum s fun b => f b :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem ∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Consider a series of functions `∑' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x :=\n\n/-- proof that a monotone function tends to `𝓝 a` as `x → ∞` -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\n      MeasureTheory.Integrable bound →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f)) :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Bernoulli's inequality reformulated to estimate `a^n`. -/\ntheorem ∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -1 ≤ a → ∀ (n : ℕ), 1 + ↑n * (a - 1) ≤ a ^ n :=\n\n/-- First technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `∑_{k<n+1} aᵏ Qₖ` in terms of a sum of powers of the same sum one step before,\nin a general abstract setup. -/\ntheorem ∀ (n : ℕ) (p : ℕ → ℝ),\n  (∀ (k : ℕ), 0 ≤ p k) →\n    ∀ {r a : ℝ},\n      0 ≤ r →\n        0 ≤ a →\n          (Finset.sum (Finset.Ico 2 (n + 1)) fun k =>\n              a ^ k *\n                Finset.sum (Set.toFinset {c | 1 < Composition.length c}) fun c =>\n                  r ^ Composition.length c * Finset.prod Finset.univ fun j => p (Composition.blocksFun c j)) ≤\n            Finset.sum (Finset.Ico 2 (n + 1)) fun j => r ^ j * (Finset.sum (Finset.Ico 1 n) fun k => a ^ k * p k) ^ j :=\n\n/-- Dominated convergence theorem for nonnegative functions -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {F : ℕ → α → ENNReal} {f : α → ENNReal}\n  (bound : α → ENNReal),\n  (∀ (n : ℕ), Measurable (F n)) →\n    (∀ (n : ℕ), F n ≤ᶠ[MeasureTheory.Measure.ae μ] bound) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) Filter.atTop (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$. -/\ntheorem",
    "choices": [
      "∀ {a : ℕ → ℝ}, (∀ (n : ℕ), 0 ≤ a n) → Summable a → Summable (λ n => Real.sqrt (a n) / (n + 1)) "
    ]
  },
  {
    "docString": "Prove that the Cauchy product of two absolutely convergent series converges absolutely.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\\n  CauchySeq u →\\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop →\\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : AddCommGroup α] [inst_1 : UniformSpace α] [inst_2 : CompleteSpace α]\\n  {f : β → α}, Summable f ↔ CauchySeq fun s => Finset.sum s fun b => f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"∀ {f : ℕ → ℝ},\\n  (∀ (n : ℕ), 0 ≤ f n) → (∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) → ((Summable fun k => 2 ^ k * f (2 ^ k)) ↔ Summable f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cauchy condensation test for series of nonnegative real numbers. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner x y * inner x y ≤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchy–Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : UniformSpace α] [self : CompleteSpace α] {f : Filter α}, Cauchy f → ∃ x, f ≤ nhds x\",\n  \"isProp\": true,\n  \"docString\": \"In a complete uniform space, every Cauchy filter converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_4} {F : Type u_2} {G : Type u_3} [inst : NontriviallyNormedField 𝕜]\\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G)\\n  (p : FormalMultilinearSeries 𝕜 E F),\\n  0 < FormalMultilinearSeries.radius q →\\n    0 < FormalMultilinearSeries.radius p →\\n      ∃ r, r > 0 ∧ Summable fun i => ‖FormalMultilinearSeries.compAlongComposition q p i.snd‖₊ * r ^ i.fst\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two formal multilinear series have positive radius of convergence, then the terms appearing\\nin the definition of their composition are also summable (when multiplied by a suitable positive\\ngeometric term). \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {n : ℕ} [inst_2 : CompleteSpace E]\\n  (I : BoxIntegral.Box (Fin (n + 1))) {i : Fin (n + 1)} {f : (Fin (n + 1) → ℝ) → E} {f' : (Fin (n + 1) → ℝ) →L[ℝ] E},\\n  ContinuousOn f (↑BoxIntegral.Box.Icc I) →\\n    ∀ {x : Fin (n + 1) → ℝ},\\n      x ∈ ↑BoxIntegral.Box.Icc I →\\n        ∀ {a : E} {ε : ℝ},\\n          0 < ε →\\n            (∀ (y : Fin (n + 1) → ℝ), y ∈ ↑BoxIntegral.Box.Icc I → ‖f y - a - ↑f' (y - x)‖ ≤ ε * ‖y - x‖) →\\n              ∀ {c : NNReal},\\n                BoxIntegral.Box.distortion I ≤ c →\\n                  ‖(Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j) •\\n                          ↑f' (Pi.single i 1) -\\n                        (BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.upper I i)) BoxIntegral.BoxAdditiveMap.volume -\\n                          BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.lower I i)) BoxIntegral.BoxAdditiveMap.volume)‖ ≤\\n                    2 * ε * ↑c * Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j\",\n  \"isProp\": true,\n  \"docString\": \"Auxiliary lemma for the divergence theorem. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"}]\n",
    "prompt_cons": "/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → UniformCauchySeqOn F p s :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem ∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i :=\n\n/-- The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommGroup α] [inst_1 : UniformSpace α] [inst_2 : CompleteSpace α]\n  {f : β → α}, Summable f ↔ CauchySeq fun s => Finset.sum s fun b => f b :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b :=\n\n/-- Cauchy condensation test for series of nonnegative real numbers. -/\ntheorem ∀ {f : ℕ → ℝ},\n  (∀ (n : ℕ), 0 ≤ f n) → (∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) → ((Summable fun k => 2 ^ k * f (2 ^ k)) ↔ Summable f) :=\n\n/-- Cauchy–Schwarz inequality for real inner products. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner x y * inner x y ≤ inner x x * inner y y :=\n\n/-- In a complete uniform space, every Cauchy filter converges. -/\ntheorem ∀ {α : Type u} [inst : UniformSpace α] [self : CompleteSpace α] {f : Filter α}, Cauchy f → ∃ x, f ≤ nhds x :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- If two formal multilinear series have positive radius of convergence, then the terms appearing\nin the definition of their composition are also summable (when multiplied by a suitable positive\ngeometric term). -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_4} {F : Type u_2} {G : Type u_3} [inst : NontriviallyNormedField 𝕜]\n  [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] (q : FormalMultilinearSeries 𝕜 F G)\n  (p : FormalMultilinearSeries 𝕜 E F),\n  0 < FormalMultilinearSeries.radius q →\n    0 < FormalMultilinearSeries.radius p →\n      ∃ r, r > 0 ∧ Summable fun i => ‖FormalMultilinearSeries.compAlongComposition q p i.snd‖₊ * r ^ i.fst :=\n\n/-- Auxiliary lemma for the divergence theorem. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {n : ℕ} [inst_2 : CompleteSpace E]\n  (I : BoxIntegral.Box (Fin (n + 1))) {i : Fin (n + 1)} {f : (Fin (n + 1) → ℝ) → E} {f' : (Fin (n + 1) → ℝ) →L[ℝ] E},\n  ContinuousOn f (↑BoxIntegral.Box.Icc I) →\n    ∀ {x : Fin (n + 1) → ℝ},\n      x ∈ ↑BoxIntegral.Box.Icc I →\n        ∀ {a : E} {ε : ℝ},\n          0 < ε →\n            (∀ (y : Fin (n + 1) → ℝ), y ∈ ↑BoxIntegral.Box.Icc I → ‖f y - a - ↑f' (y - x)‖ ≤ ε * ‖y - x‖) →\n              ∀ {c : NNReal},\n                BoxIntegral.Box.distortion I ≤ c →\n                  ‖(Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j) •\n                          ↑f' (Pi.single i 1) -\n                        (BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.upper I i)) BoxIntegral.BoxAdditiveMap.volume -\n                          BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.lower I i)) BoxIntegral.BoxAdditiveMap.volume)‖ ≤\n                    2 * ε * ↑c * Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Prove that the Cauchy product of two absolutely convergent series converges absolutely. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : Ring α] [inst_1 : LinearOrderedField β] {abv : α → β} [inst_2 : IsAbsoluteValue abv]\n  {a b : ℕ → α}, Summable (λ n, abv (a n)) → Summable (λ n, abv (b n)) → Summable (λ n, abv (Finset.sum (Finset.range (n + 1)) (λ i, a i * b (n - i)))) "
    ]
  },
  {
    "docString": "If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\\n  (∀ (n : ℕ), IsClosed (s n)) →\\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\\n      (∀ (N : ℕ), Set.Nonempty (⋂ (n : ℕ) (_ : n ≤ N), s n)) →\\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, if a family of closed sets with diameter tending to `0` is such that each\\nfinite intersection is nonempty, then the total intersection is also nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.Bounded s ↔ EMetric.diam s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst : LinearOrder ι]\\n  [inst_1 : TopologicalSpace ι] [inst_2 : OrderTopology ι] [inst_3 : DenselyOrdered ι]\\n  [inst_4 : TopologicalSpace.FirstCountableTopology ι] {s : ι → Set α} {a : ι},\\n  (∀ (r : ι), r > a → MeasurableSet (s r)) →\\n    (∀ (i j : ι), a < i → i ≤ j → s i ⊆ s j) →\\n      (∃ r, r > a ∧ ↑↑μ (s r) ≠ ⊤) →\\n        Filter.Tendsto (↑↑μ ∘ s) (nhdsWithin a (Set.Ioi a)) (nhds (↑↑μ (⋂ (r : ι) (_ : r > a), s r)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of the intersection of a decreasing sequence of measurable\\nsets indexed by a linear order with first countable topology is the limit of the measures. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α},\\n  Set.Nonempty s → ∀ {C : ℝ}, (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → dist x y ≤ C) → Metric.diam s ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between any two points in a nonempty set is bounded by some constant,\\nthis constant bounds the diameter. \"},\n {\"theorem\":\n  \"∀ {t : Set GromovHausdorff.GHSpace} {C : ℝ} {u : ℕ → ℝ} {K : ℕ → ℕ},\\n  Filter.Tendsto u Filter.atTop (nhds 0) →\\n    (∀ (p : GromovHausdorff.GHSpace), p ∈ t → Metric.diam Set.univ ≤ C) →\\n      (∀ (p : GromovHausdorff.GHSpace),\\n          p ∈ t →\\n            ∀ (n : ℕ),\\n              ∃ s,\\n                Cardinal.mk ↑s ≤ ↑(K n) ∧\\n                  Set.univ ⊆ ⋃ (x : GromovHausdorff.GHSpace.Rep p) (_ : x ∈ s), Metric.ball x (u n)) →\\n        TotallyBounded t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Compactness criterion: a closed set of compact metric spaces is compact if the spaces have\\na uniformly bounded diameter, and for all `ε` the number of balls of radius `ε` required\\nto cover the spaces is uniformly bounded. This is an equivalence, but we only prove the\\ninteresting direction that these conditions imply compactness. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : UniformSpace α] {s : Set α}, TotallyBounded s → TotallyBounded (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a totally bounded set is totally bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {ι : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : Countable ι]\\n  [inst : SemilatticeSup ι] {s : ι → Set α},\\n  (∀ (n : ι), MeasurableSet (s n)) →\\n    Antitone s → (∃ i, ↑↑μ (s i) ≠ ⊤) → Filter.Tendsto (↑↑μ ∘ s) Filter.atTop (nhds (↑↑μ (⋂ (n : ι), s n)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Continuity from above: the measure of the intersection of a decreasing sequence of measurable\\nsets is the limit of the measures. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `ℕ`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : FrechetUrysohnSpace X] {s : Set X} {a : X},\\n  a ∈ closure s ↔ ∃ x, (∀ (n : ℕ), x n ∈ s) ∧ Filter.Tendsto x Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Fréchet-Urysohn space, a point belongs to the closure of a set iff it is a limit\\nof a sequence taking values in this set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {C : ℝ},\\n  0 ≤ C → (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → dist x y ≤ C) → Metric.diam s ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between any two points in a set is bounded by some non-negative constant,\\nthis constant bounds the diameter. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\\n  Metric.Bounded s → IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ↔ IsClosed M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sequential space, a set is closed iff it's sequentially closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"}]\n",
    "prompt_cons": "/-- In a complete space, if a family of closed sets with diameter tending to `0` is such that each\nfinite intersection is nonempty, then the total intersection is also nonempty. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (N : ℕ), Set.Nonempty (⋂ (n : ℕ) (_ : n ≤ N), s n)) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n) :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤ :=\n\n/-- Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.Bounded s ↔ EMetric.diam s ≠ ⊤ :=\n\n/-- The measure of the intersection of a decreasing sequence of measurable\nsets indexed by a linear order with first countable topology is the limit of the measures. -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst : LinearOrder ι]\n  [inst_1 : TopologicalSpace ι] [inst_2 : OrderTopology ι] [inst_3 : DenselyOrdered ι]\n  [inst_4 : TopologicalSpace.FirstCountableTopology ι] {s : ι → Set α} {a : ι},\n  (∀ (r : ι), r > a → MeasurableSet (s r)) →\n    (∀ (i j : ι), a < i → i ≤ j → s i ⊆ s j) →\n      (∃ r, r > a ∧ ↑↑μ (s r) ≠ ⊤) →\n        Filter.Tendsto (↑↑μ ∘ s) (nhdsWithin a (Set.Ioi a)) (nhds (↑↑μ (⋂ (r : ι) (_ : r > a), s r))) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- If the distance between any two points in a nonempty set is bounded by some constant,\nthis constant bounds the diameter. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α},\n  Set.Nonempty s → ∀ {C : ℝ}, (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → dist x y ≤ C) → Metric.diam s ≤ C :=\n\n/-- Compactness criterion: a closed set of compact metric spaces is compact if the spaces have\na uniformly bounded diameter, and for all `ε` the number of balls of radius `ε` required\nto cover the spaces is uniformly bounded. This is an equivalence, but we only prove the\ninteresting direction that these conditions imply compactness. -/\ntheorem ∀ {t : Set GromovHausdorff.GHSpace} {C : ℝ} {u : ℕ → ℝ} {K : ℕ → ℕ},\n  Filter.Tendsto u Filter.atTop (nhds 0) →\n    (∀ (p : GromovHausdorff.GHSpace), p ∈ t → Metric.diam Set.univ ≤ C) →\n      (∀ (p : GromovHausdorff.GHSpace),\n          p ∈ t →\n            ∀ (n : ℕ),\n              ∃ s,\n                Cardinal.mk ↑s ≤ ↑(K n) ∧\n                  Set.univ ⊆ ⋃ (x : GromovHausdorff.GHSpace.Rep p) (_ : x ∈ s), Metric.ball x (u n)) →\n        TotallyBounded t :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- The closure of a totally bounded set is totally bounded. -/\ntheorem ∀ {α : Type u} [inst : UniformSpace α] {s : Set α}, TotallyBounded s → TotallyBounded (closure s) :=\n\n/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable\nsets is the limit of the measures. -/\ntheorem ∀ {α : Type u_2} {ι : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : Countable ι]\n  [inst : SemilatticeSup ι] {s : ι → Set α},\n  (∀ (n : ι), MeasurableSet (s n)) →\n    Antitone s → (∃ i, ↑↑μ (s i) ≠ ⊤) → Filter.Tendsto (↑↑μ ∘ s) Filter.atTop (nhds (↑↑μ (⋂ (n : ι), s n))) :=\n\n/-- A sequentially compact set in a uniform space is totally bounded. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s) :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `ℕ`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) :=\n\n/-- In a Fréchet-Urysohn space, a point belongs to the closure of a set iff it is a limit\nof a sequence taking values in this set. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : FrechetUrysohnSpace X] {s : Set X} {a : X},\n  a ∈ closure s ↔ ∃ x, (∀ (n : ℕ), x n ∈ s) ∧ Filter.Tendsto x Filter.atTop (nhds a) :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem ∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen :=\n\n/-- If the distance between any two points in a set is bounded by some non-negative constant,\nthis constant bounds the diameter. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {C : ℝ},\n  0 ≤ C → (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → dist x y ≤ C) → Metric.diam s ≤ C :=\n\n/-- The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\n  Metric.Bounded s → IsCompact (closure s) :=\n\n/-- In a sequential space, a set is closed iff it's sequentially closed. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SequentialSpace X] {M : Set X}, IsSeqClosed M ↔ IsClosed M :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point. -/\ntheorem",
    "choices": [
      "forall {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Set.Nonempty (s n)) →\n      (∀ (n : ℕ), Metric.Bounded (s n)) →\n        (∀ (n : ℕ), s (n + 1) ⊆ s n) →\n          Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) →\n            ∃ x, ∀ n, x ∈ s n "
    ]
  },
  {
    "docString": "Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f → MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + τ f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] [inst_1 : DecidableEq ι] (i : ι),\\n  Continuous fun f => Function.update f.fst i f.snd\",\n  \"isProp\": true,\n  \"docString\": \"`Function.update f i x` is continuous in `(f, x)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\\n  Monotone f → ∀ (n : ℤ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℤ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → StrictMono (deriv f) → StrictConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly monotone on `ℝ` then `f` is strictly\\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict monotonicity of `f'`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E} {T : ℝ},\\n  Function.Periodic f T → ∀ (t s : ℝ), ∫ (x : ℝ) in t..t + T, f x = ∫ (x : ℝ) in s..s + T, f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a periodic function with period `T`, then its integral over `[t, t + T]` does not\\ndepend on `t`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\\n  (f' : ℂ → ℂ →L[ℝ] E) (z w : ℂ) (s : Set ℂ),\\n  Set.Countable s →\\n    ContinuousOn f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\\n      (∀ (x : ℂ),\\n          x ∈ Set.Ioo (min z.re w.re) (max z.re w.re) ×ℂ Set.Ioo (min z.im w.im) (max z.im w.im) \\\\ s →\\n            HasFDerivAt f (f' x) x) →\\n        MeasureTheory.IntegrableOn (fun z => Complex.I • ↑(f' z) 1 - ↑(f' z) Complex.I)\\n            (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\\n          (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) -\\n                  ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\\n                Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\\n              Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\\n            ∫ (x : ℝ) in z.re..w.re,\\n              ∫ (y : ℝ) in z.im..w.im, Complex.I • ↑(f' (↑x + ↑y * Complex.I)) 1 - ↑(f' (↑x + ↑y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\\n`z w : ℂ`, is *real* differentiable at all but countably many points of the corresponding open\\nrectangle, and $\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the\\nintegral of `f` over the boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → StrictAnti (deriv f) → StrictConcaveOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly antitone on `ℝ` then `f` is strictly\\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict antitonicity of `f'`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E} {c : ℂ},\\n  (∀ᶠ (z : ℂ) in nhdsWithin c {c}ᶜ, DifferentiableAt ℂ f z) →\\n    ((fun z => f z - f c) =o[nhdsWithin c {c}ᶜ] fun z => (z - c)⁻¹) →\\n      Filter.Tendsto f (nhdsWithin c {c}ᶜ) (nhds (limUnder (nhdsWithin c {c}ᶜ) f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem: if a function `f : ℂ → E` is complex differentiable on a\\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"∀ (f : ℕ → NNReal), Filter.Tendsto (fun i => ∑' (k : ℕ), f (k + i)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `f : ℕ → ℝ≥0`, then `∑' k, f (k + i)` tends to zero. This does not require a summability\\nassumption on `f`, as otherwise all sums are zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\\n  Monotone f → ∀ (n : ℕ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℕ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"}]\n",
    "prompt_cons": "/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem ∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f → MeasureTheory.LocallyIntegrable f :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem ∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- `Function.update f i x` is continuous in `(f, x)`. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] [inst_1 : DecidableEq ι] (i : ι),\n  Continuous fun f => Function.update f.fst i f.snd :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\n  Monotone f → ∀ (n : ℤ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℤ), f a ≠ x :=\n\n/-- If a function `f` is continuous and `f'` is strictly monotone on `ℝ` then `f` is strictly\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict monotonicity of `f'`. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → StrictMono (deriv f) → StrictConvexOn ℝ Set.univ f :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem ∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c :=\n\n/-- If `f` is a periodic function with period `T`, then its integral over `[t, t + T]` does not\ndepend on `t`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E} {T : ℝ},\n  Function.Periodic f T → ∀ (t s : ℝ), ∫ (x : ℝ) in t..t + T, f x = ∫ (x : ℝ) in s..s + T, f x :=\n\n/-- Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\n`z w : ℂ`, is *real* differentiable at all but countably many points of the corresponding open\nrectangle, and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the\nintegral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\n  (f' : ℂ → ℂ →L[ℝ] E) (z w : ℂ) (s : Set ℂ),\n  Set.Countable s →\n    ContinuousOn f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n      (∀ (x : ℂ),\n          x ∈ Set.Ioo (min z.re w.re) (max z.re w.re) ×ℂ Set.Ioo (min z.im w.im) (max z.im w.im) \\ s →\n            HasFDerivAt f (f' x) x) →\n        MeasureTheory.IntegrableOn (fun z => Complex.I • ↑(f' z) 1 - ↑(f' z) Complex.I)\n            (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n          (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) -\n                  ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\n                Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\n              Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\n            ∫ (x : ℝ) in z.re..w.re,\n              ∫ (y : ℝ) in z.im..w.im, Complex.I • ↑(f' (↑x + ↑y * Complex.I)) 1 - ↑(f' (↑x + ↑y * Complex.I)) Complex.I :=\n\n/-- If a function `f` is continuous and `f'` is strictly antitone on `ℝ` then `f` is strictly\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict antitonicity of `f'`. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → StrictAnti (deriv f) → StrictConcaveOn ℝ Set.univ f :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- **Removable singularity** theorem: if a function `f : ℂ → E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E} {c : ℂ},\n  (∀ᶠ (z : ℂ) in nhdsWithin c {c}ᶜ, DifferentiableAt ℂ f z) →\n    ((fun z => f z - f c) =o[nhdsWithin c {c}ᶜ] fun z => (z - c)⁻¹) →\n      Filter.Tendsto f (nhdsWithin c {c}ᶜ) (nhds (limUnder (nhdsWithin c {c}ᶜ) f)) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f :=\n\n/-- For `f : ℕ → ℝ≥0`, then `∑' k, f (k + i)` tends to zero. This does not require a summability\nassumption on `f`, as otherwise all sums are zero. -/\ntheorem ∀ (f : ℕ → NNReal), Filter.Tendsto (fun i => ∑' (k : ℕ), f (k + i)) Filter.atTop (nhds 0) :=\n\n/-- If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\n  Monotone f → ∀ (n : ℕ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℕ), f a ≠ x :=\n\n/-- Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous. -/\ntheorem",
    "choices": [
      "There is no theorem to prove here, as the statement is asking to show that a function with the given property does not need to be continuous. Instead, I can provide an example of such a function.\n\nConsider the function f : ℝ → ℝ defined as follows:\n\nf(x) = 0 if x is rational,\nf(x) = 1 if x is irrational.\n\nNow, let's check the property given in the statement. For any x ∈ ℝ and any sequence hₙ → 0, we have:\n\nf(x + hₙ) - f(x - hₙ) = \n  0 - 0 if x + hₙ and x - hₙ are both rational,\n  1 - 1 if x + hₙ and x - hₙ are both irrational,\n  1 - 0 if x + hₙ is irrational and x - hₙ is rational,\n  0 - 1 if x + hₙ is rational and x - hₙ is irrational.\n\nIn the last two cases, since the rationals and irrationals are dense in ℝ, we can always find a subsequence of hₙ such that one of x + hₙ or x - hₙ is rational and the other is irrational. Therefore, the limit of f(x + hₙ) - f(x - hₙ) as hₙ → 0 does not exist.\n\nHowever, the function f is not continuous, as it is discontinuous at every point in ℝ. This can be seen by considering any x ∈ ℝ and any ε > 0. Since the rationals and irrationals are dense in ℝ, there exist rational and irrational numbers in the interval (x - ε, x + ε). Thus, the function f cannot be continuous at x.\n\nSo, the function f satisfies the given property but is not continuous, providing an example that shows that the property does not imply continuity."
    ]
  },
  {
    "docString": "Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\\n  0 < r →\\n    r ≤ R →\\n      ∀ {f : ℂ → E} {s : Set ℂ},\\n        Set.Countable s →\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) →\\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s → DifferentiableAt ℂ f z) →\\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {μ : MeasureTheory.Measure α},\\n  p ≠ 0 →\\n    p ≠ ⊤ →\\n      ∀ {P : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ } → Prop},\\n        (∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : ↑↑μ s < ⊤),\\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : ↑↑μ s ≠ ⊤) c)) →\\n          (∀ ⦃f g : MeasureTheory.SimpleFunc α E⦄ (hf : MeasureTheory.Memℒp (↑f) p) (hg : MeasureTheory.Memℒp (↑g) p),\\n              Disjoint (Function.support ↑f) (Function.support ↑g) →\\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) →\\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) →\\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) →\\n            ∀ (f : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ }), P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Lp` simple function, with `0 < p < ∞`, it suffices to show\\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\\nsets and is closed under addition (of functions with disjoint support). \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] (s : Set α), Continuous fun x => Metric.infNndist x s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set (as `ℝ≥0`) is continuous in point \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Set.EqOn (↑f) 0 s ∧ Set.EqOn (↑f) 1 t ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\\nthen there exists a continuous function `f : X → ℝ` such that\\n\\n* `f` equals zero on `s`;\\n* `f` equals one on `t`;\\n* `0 ≤ f x ≤ 1` for all `x`.\\n\"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\\n  IsCompact K → ContinuousOn f K → MeasureTheory.IntegrableOn f K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` continuous on a compact set `K` is integrable on this set with respect to any\\nlocally finite measure. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] [inst_4 : StrictConvexSpace ℝ F] {f : E → F} {z : E} {r : ℝ},\\n  DiffContOnCl ℂ f (Metric.ball z r) →\\n    IsMaxOn (norm ∘ f) (Metric.ball z r) z → Set.EqOn f (Function.const E (f z)) (Metric.closedBall z r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Maximum modulus principle** on a closed ball. Suppose that a function `f : E → F` from a\\nnormed complex space to a strictly convex normed complex space has the following properties:\\n\\n- it is continuous on a closed ball `Metric.closedBall z r`,\\n- it is complex differentiable on the corresponding open ball;\\n- the norm `‖f w‖` takes its maximum value on the open ball at its center.\\n\\nThen `f` is a constant on the closed ball.  \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : TopologicalSpace β] {x₀ : β}\\n  (b : β → ℝ),\\n  Filter.Tendsto b (nhds x₀) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ᶠ (x : β) in nhds x₀, ∀ (i : ι), dist (F i x₀) (F i x) ≤ b x) → EquicontinuousAt F x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions to a (pseudo) metric spaces, a convenient way to prove\\nequicontinuity at a point is to show that all of the functions share a common *local* continuity\\nmodulus. \"}]\n",
    "prompt_cons": "/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0 :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\nequal to each other. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\n  0 < r →\n    r ≤ R →\n      ∀ {f : ℂ → E} {s : Set ℂ},\n        Set.Countable s →\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) →\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\ Metric.closedBall c r) \\ s → DifferentiableAt ℂ f z) →\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z :=\n\n/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < ∞`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {μ : MeasureTheory.Measure α},\n  p ≠ 0 →\n    p ≠ ⊤ →\n      ∀ {P : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ } → Prop},\n        (∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : ↑↑μ s < ⊤),\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : ↑↑μ s ≠ ⊤) c)) →\n          (∀ ⦃f g : MeasureTheory.SimpleFunc α E⦄ (hf : MeasureTheory.Memℒp (↑f) p) (hg : MeasureTheory.Memℒp (↑g) p),\n              Disjoint (Function.support ↑f) (Function.support ↑g) →\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) →\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) →\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) →\n            ∀ (f : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ }), P f :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0 :=\n\n/-- If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem ∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤ :=\n\n/-- The minimal distance to a set (as `ℝ≥0`) is continuous in point -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] (s : Set α), Continuous fun x => Metric.infNndist x s :=\n\n/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nthen there exists a continuous function `f : X → ℝ` such that\n\n* `f` equals zero on `s`;\n* `f` equals one on `t`;\n* `0 ≤ f x ≤ 1` for all `x`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Set.EqOn (↑f) 0 s ∧ Set.EqOn (↑f) 1 t ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 :=\n\n/-- A function `f` continuous on a compact set `K` is integrable on this set with respect to any\nlocally finite measure. -/\ntheorem ∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] {K : Set X} [inst_5 : TopologicalSpace.MetrizableSpace X],\n  IsCompact K → ContinuousOn f K → MeasureTheory.IntegrableOn f K :=\n\n/-- **Maximum modulus principle** on a closed ball. Suppose that a function `f : E → F` from a\nnormed complex space to a strictly convex normed complex space has the following properties:\n\n- it is continuous on a closed ball `Metric.closedBall z r`,\n- it is complex differentiable on the corresponding open ball;\n- the norm `‖f w‖` takes its maximum value on the open ball at its center.\n\nThen `f` is a constant on the closed ball. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] [inst_4 : StrictConvexSpace ℝ F] {f : E → F} {z : E} {r : ℝ},\n  DiffContOnCl ℂ f (Metric.ball z r) →\n    IsMaxOn (norm ∘ f) (Metric.ball z r) z → Set.EqOn f (Function.const E (f z)) (Metric.closedBall z r) :=\n\n/-- For a family of functions to a (pseudo) metric spaces, a convenient way to prove\nequicontinuity at a point is to show that all of the functions share a common *local* continuity\nmodulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : TopologicalSpace β] {x₀ : β}\n  (b : β → ℝ),\n  Filter.Tendsto b (nhds x₀) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ᶠ (x : β) in nhds x₀, ∀ (i : ι), dist (F i x₀) (F i x) ≤ b x) → EquicontinuousAt F x₀ :=\n\n/-- Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] {f : X → ℝ},\n  Continuous f → IsClosed (Function.zeroSet f) "
    ]
  },
  {
    "docString": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) →\\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) → (∀ (x : X), ∃ c, ∀ᶠ (y : X) in nhds x, c ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x ∈ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ ≤ ‖f‖ / 3 ∧ dist (BoundedContinuousFunction.compContinuous g e) f ≤ 2 / 3 * ‖f‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace β] [inst_1 : TopologicalSpace γ]\\n  [inst_2 : T2Space γ] {f : α → β}, DenseRange f → ∀ {g h : β → γ}, Continuous g → Continuous h → g ∘ f = h ∘ f → g = h\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two continuous functions to a t2-space that agree on the dense range of a function are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\\n`g ∘ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\\n  Filter.Tendsto b (nhds 0) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : C(X, ℝ)) (e : X → Y), ClosedEmbedding e → ∃ g, ↑g ∘ e = ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\\ncontinuous real-valued function `g : C(Y, ℝ)` such that `g ∘ e = f`. \"},\n {\"theorem\":\n  \"∀ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(↑s, ℝ)),\\n  IsClosed s → ∃ g, ContinuousMap.restrict s g = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\\non `s`. Then there exists a continuous real-valued function `g : C(Y, ℝ)` such that\\n`g.restrict s = f`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β] {f : X → Y}\\n  [inst : TopologicalSpace.SecondCountableTopology ↑(Set.range f)],\\n  Measurable f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable (Set.restrict (Set.range f) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X → Y` is a Borel measurable map from a Polish space to a topological space with second\\ncountable topology, then for any measurable space `β` and `g : Y → β`, the composition `g ∘ f` is\\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\\n  ContractingWith K f →\\n    ∀ (g : α → α) {x y : α},\\n      Function.IsFixedPt f x →\\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ = ‖f‖ ∧ BoundedContinuousFunction.compContinuous g e = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\\n  [inst_2 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} {f : α → γ} {g : β → γ}\\n  [inst_3 : TopologicalSpace γ] [inst_4 : TopologicalSpace.MetrizableSpace γ] [inst_5 : BorelSpace γ],\\n  ProbabilityTheory.IdentDistrib f g → MeasureTheory.AEStronglyMeasurable f μ → MeasureTheory.AEStronglyMeasurable g ν\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are identically distributed and `f` is a.e. strongly measurable, so is `g`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s →\\n    ContinuousWithinAt f s x → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then `Fₙ gₙ`\\ntends to `f x` if `f` is continuous at `x` within `s`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] [inst_4 : Nontrivial E] {f g : E → F} {U : Set E},\\n  Metric.Bounded U → DiffContOnCl ℂ f U → DiffContOnCl ℂ g U → Set.EqOn f g (frontier U) → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two complex differentiable functions `f g : E → F` are equal on the boundary of a bounded set\\n`U`, then they are equal on `U`. \"}]\n",
    "prompt_cons": "/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) →\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x ∈ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) → (∀ (x : X), ∃ c, ∀ᶠ (y : X) in nhds x, c ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ ≤ ‖f‖ / 3 ∧ dist (BoundedContinuousFunction.compContinuous g e) f ≤ 2 / 3 * ‖f‖ :=\n\n/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace β] [inst_1 : TopologicalSpace γ]\n  [inst_2 : T2Space γ] {f : α → β}, DenseRange f → ∀ {g h : β → γ}, Continuous g → Continuous h → g ∘ f = h ∘ f → g = h :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\n`g ∘ f` is measurable if and only if `g` is measurable. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\n  Filter.Tendsto b (nhds 0) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\ncontinuous real-valued function `g : C(Y, ℝ)` such that `g ∘ e = f`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : C(X, ℝ)) (e : X → Y), ClosedEmbedding e → ∃ g, ↑g ∘ e = ↑f :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed set. Let\n`s` be a closed set in a normal topological space `Y`. Let `f` be a continuous real-valued function\non `s`. Then there exists a continuous real-valued function `g : C(Y, ℝ)` such that\n`g.restrict s = f`. -/\ntheorem ∀ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {s : Set Y} (f : C(↑s, ℝ)),\n  IsClosed s → ∃ g, ContinuousMap.restrict s g = f :=\n\n/-- If `f : X → Y` is a Borel measurable map from a Polish space to a topological space with second\ncountable topology, then for any measurable space `β` and `g : Y → β`, the composition `g ∘ f` is\nmeasurable if and only if the restriction of `g` to the range of `f` is measurable. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β] {f : X → Y}\n  [inst : TopologicalSpace.SecondCountableTopology ↑(Set.range f)],\n  Measurable f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable (Set.restrict (Set.range f) g) :=\n\n/-- Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. -/\ntheorem ∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\n  ContractingWith K f →\n    ∀ (g : α → α) {x y : α},\n      Function.IsFixedPt f x →\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K) :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ = ‖f‖ ∧ BoundedContinuousFunction.compContinuous g e = f :=\n\n/-- If `f` and `g` are identically distributed and `f` is a.e. strongly measurable, so is `g`. -/\ntheorem ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n  [inst_2 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} {f : α → γ} {g : β → γ}\n  [inst_3 : TopologicalSpace γ] [inst_4 : TopologicalSpace.MetrizableSpace γ] [inst_5 : BorelSpace γ],\n  ProbabilityTheory.IdentDistrib f g → MeasureTheory.AEStronglyMeasurable f μ → MeasureTheory.AEStronglyMeasurable g ν :=\n\n/-- If `Fₙ` tends uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then `Fₙ gₙ`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s →\n    ContinuousWithinAt f s x → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If two complex differentiable functions `f g : E → F` are equal on the boundary of a bounded set\n`U`, then they are equal on `U`. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] [inst_4 : Nontrivial E] {f g : E → F} {U : Set E},\n  Metric.Bounded U → DiffContOnCl ℂ f U → DiffContOnCl ℂ g U → Set.EqOn f g (frontier U) → Set.EqOn f g U :=\n\n/-- Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f g : X → Y} {E : Set X},\n  Dense E → Continuous f → Continuous g → Set.EqOn f g E → Set.EqOn f g Set.Univ "
    ]
  },
  {
    "docString": "Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f ≥ 1` on K. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → ℝ),\\n  MeasureTheory.Integrable f →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), g x < ↑(f x)) ∧\\n            UpperSemicontinuous g ∧\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\\n                (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), EReal.toReal (g x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\\nof `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → ℝ),\\n  MeasureTheory.Integrable f →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), ↑(f x) < g x) ∧\\n            LowerSemicontinuous g ∧\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"∀ {ι : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\\n  [inst_2 : SMulWithZero ℝ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ℝ E] {s : Set X}\\n  {f : PartitionOfUnity ι X s} [inst_5 : ContinuousAdd E] {U : ι → Set X},\\n  (∀ (i : ι), IsOpen (U i)) →\\n    PartitionOfUnity.IsSubordinate f U →\\n      ∀ {g : ι → X → E}, (∀ (i : ι), ContinuousOn (g i) (U i)) → Continuous fun x => ∑ᶠ (i : ι), ↑(↑f i) x • g i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\\n`g : ι → X → E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\\n`fun x ↦ ∑ᶠ i, f i x • g i x` is a continuous function. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ]\\n  (f : MeasureTheory.SimpleFunc α NNReal),\\n  ∫⁻ (x : α), ↑(↑f x) ∂μ ≠ ⊤ →\\n    ∀ {ε : ENNReal},\\n      ε ≠ 0 → ∃ g, (∀ (x : α), g x ≤ ↑f x) ∧ UpperSemicontinuous g ∧ ∫⁻ (x : α), ↑(↑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S → Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → Set.EqOn f g S ∨ Set.EqOn f (-g) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\\n`S`. \"}]\n",
    "prompt_cons": "/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f ≥ 1` on K. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x}) :=\n\n/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → ℝ),\n  MeasureTheory.Integrable f →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), g x < ↑(f x)) ∧\n            UpperSemicontinuous g ∧\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\n                (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), EReal.toReal (g x) ∂μ + ε :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → ℝ),\n  MeasureTheory.Integrable f →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), ↑(f x) < g x) ∧\n            LowerSemicontinuous g ∧\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s :=\n\n/-- For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\nintegral. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- If `f` is a partition of unity that is subordinate to a family of open sets `U i` and\n`g : ι → X → E` is a family of functions such that each `g i` is continuous on `U i`, then the sum\n`fun x ↦ ∑ᶠ i, f i x • g i x` is a continuous function. -/\ntheorem ∀ {ι : Type u} {X : Type v} [inst : TopologicalSpace X] {E : Type u_1} [inst_1 : AddCommMonoid E]\n  [inst_2 : SMulWithZero ℝ E] [inst_3 : TopologicalSpace E] [inst_4 : ContinuousSMul ℝ E] {s : Set X}\n  {f : PartitionOfUnity ι X s} [inst_5 : ContinuousAdd E] {U : ι → Set X},\n  (∀ (i : ι), IsOpen (U i)) →\n    PartitionOfUnity.IsSubordinate f U →\n      ∀ {g : ι → X → E}, (∀ (i : ι), ContinuousOn (g i) (U i)) → Continuous fun x => ∑ᶠ (i : ι), ↑(↑f i) x • g i x :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- Given a simple function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ]\n  (f : MeasureTheory.SimpleFunc α NNReal),\n  ∫⁻ (x : α), ↑(↑f x) ∂μ ≠ ⊤ →\n    ∀ {ε : ENNReal},\n      ε ≠ 0 → ∃ g, (∀ (x : α), g x ≤ ↑f x) ∧ UpperSemicontinuous g ∧ ∫⁻ (x : α), ↑(↑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S → Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → Set.EqOn f g S ∨ Set.EqOn f (-g) S :=\n\n/-- Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$. -/\ntheorem",
    "choices": [
      "∃ (E : Set ℝ) (f : ℝ → ℝ), IsSubset E ℝ ∧ ContinuousOn f E ∧ ∀ (g : ℝ → ℝ), Continuous g → ¬ Set.EqOn g f E "
    ]
  },
  {
    "docString": "Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\\n  {f : ℂ → E} {s : Set ℂ},\\n  Set.Countable s →\\n    ContinuousOn f (Metric.closedBall c ↑R) →\\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\\\ s → DifferentiableAt ℂ f z) →\\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {R : NNReal} {f : α → ℝ},\\n  (∀ᵐ (x : α) ∂μ, |f x| ≤ ↑R) → ∀ᵐ (x : α) ∂μ, |MeasureTheory.condexp m μ f x| ≤ ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\\nexpectation. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] {ι : Type u_3}\\n  {l : Filter ι} [inst_1 : Filter.NeBot l] [_i : Fact (1 ≤ p)] {F : ι → { x // x ∈ lp E p }},\\n  Metric.Bounded (Set.range F) → ∀ {f : (a : α) → E a}, Filter.Tendsto (id fun i => ↑(F i)) l (nhds f) → Memℓp f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\\n  {f : ℂ → E}, DiffContOnCl ℂ f (Metric.ball c ↑R) → 0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is complex differentiable on an open disc of positive radius and is continuous\\non its closure, then it is analytic on the open disc with coefficients of the power series given by\\nCauchy integral formulas. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f → MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f ≥ 1` on K. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), 0 ≤ x → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), 0 ≤ x → ‖f (↑x * Complex.I)‖ ≤ C) → 0 ≤ z.re → 0 ≤ z.im → ‖f z‖ ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `c < 2`;\\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the first quadrant.\\n\\nThen `‖f z‖` is bounded from above by the same constant on the closed first quadrant. \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : ℂ → E} {s : Set ℂ},\n  Set.Countable s →\n    ContinuousOn f (Metric.closedBall c ↑R) →\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\ s → DifferentiableAt ℂ f z) →\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w :=\n\n/-- If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\nexpectation. -/\ntheorem ∀ {α : Type u_1} {m m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {R : NNReal} {f : α → ℝ},\n  (∀ᵐ (x : α) ∂μ, |f x| ≤ ↑R) → ∀ᵐ (x : α) ∂μ, |MeasureTheory.condexp m μ f x| ≤ ↑R :=\n\n/-- If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s :=\n\n/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem ∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] {ι : Type u_3}\n  {l : Filter ι} [inst_1 : Filter.NeBot l] [_i : Fact (1 ≤ p)] {F : ι → { x // x ∈ lp E p }},\n  Metric.Bounded (Set.range F) → ∀ {f : (a : α) → E a}, Filter.Tendsto (id fun i => ↑(F i)) l (nhds f) → Memℓp f p :=\n\n/-- If `f : ℂ → E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : ℂ → E}, DiffContOnCl ℂ f (Metric.ball c ↑R) → 0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f) :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem ∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f → MeasureTheory.LocallyIntegrable f :=\n\n/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f ≥ 1` on K. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x}) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\n  Continuous f → HasCompactSupport f → BddBelow (Set.range f) :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- **Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the first quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed first quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), 0 ≤ x → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), 0 ≤ x → ‖f (↑x * Complex.I)‖ ≤ C) → 0 ≤ z.re → 0 ≤ z.im → ‖f z‖ ≤ C :=\n\n/-- Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  {E : Set α} {f : α → α},\n  Metric.Bounded E → UniformContinuousOn f E → BddAbove (f '' E) ∧ BddBelow (f '' E) "
    ]
  },
  {
    "docString": "Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {x : α} {p : Filter ι}\\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s → x ∈ s → Cauchy (Filter.map (fun i => F i x) p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\\na Cauchy sequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → UniformCauchySeqOn F p s → UniformCauchySeqOn (fun n => g ∘ F n) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composing on the left by a uniformly continuous function preserves\\nuniform Cauchy sequences \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β]\\n  {γ : Type u_1} {F : β → γ → α} {s : Set γ},\\n  UniformCauchySeqOn F Filter.atTop s ↔\\n    ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → ∀ (x : γ), x ∈ s → dist (F m x) (F n x) < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\\neventually, the distance between all its elements is uniformly, arbitrarily small \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X → Y}, SeqContinuous f → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\\n  Filter.Tendsto b (nhds 0) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F ↔\\n    ∀ (ε : ℝ), ε > 0 → ∀ᶠ (xy : β × β) in uniformity β, ∀ (i : ι), dist (F i xy.fst) (F i xy.snd) < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterization of uniform equicontinuity for families of functions taking values in a\\n(pseudo) metric space. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\\n  {f' : ι → E → E →L[𝕜] G} {s : Set E},\\n  IsOpen s →\\n    IsPreconnected s →\\n      UniformCauchySeqOn f' l s →\\n        (∀ (n : ι) (y : E), y ∈ s → HasFDerivAt (f n) (f' n y) y) →\\n          ∀ {x₀ x : E},\\n            x₀ ∈ s → x ∈ s → Cauchy (Filter.map (fun n => f n x₀) l) → Cauchy (Filter.map (fun n => f n x) l)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence of functions between real or complex normed spaces are differentiable on a\\npreconnected open set, they form a Cauchy sequence _at_ `x`, and their derivatives are Cauchy\\nuniformly on the set, then the functions form a Cauchy sequence at any point in the set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β]\\n  {F : ι → β → α},\\n  UniformEquicontinuous F ↔\\n    ∀ (ε : ℝ), ε > 0 → ∃ δ, δ > 0 ∧ ∀ (x y : β), dist x y < δ → ∀ (i : ι), dist (F i x) (F i y) < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterization of uniform equicontinuity for families of functions between\\n(pseudo) metric spaces. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {s : Set α} {f : α → β},\\n  IsCompact s → ContinuousOn f s → UniformContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Heine-Cantor: a continuous function on a compact set of a uniform space is uniformly\\ncontinuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : TopologicalSpace β] {x₀ : β}\\n  (b : β → ℝ),\\n  Filter.Tendsto b (nhds x₀) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ᶠ (x : β) in nhds x₀, ∀ (i : ι), dist (F i x₀) (F i x) ≤ b x) → EquicontinuousAt F x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions to a (pseudo) metric spaces, a convenient way to prove\\nequicontinuity at a point is to show that all of the functions share a common *local* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\\n  Continuous f → UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Heine-Cantor: a continuous function on a compact uniform space is uniformly\\ncontinuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {x : α} {p : Filter ι}\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s → x ∈ s → Cauchy (Filter.map (fun i => F i x) p) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- Composing on the left by a uniformly continuous function preserves\nuniform Cauchy sequences -/\ntheorem ∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : UniformSpace γ] {g : β → γ},\n  UniformContinuous g → UniformCauchySeqOn F p s → UniformCauchySeqOn (fun n => g ∘ F n) p s :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → UniformCauchySeqOn F p s :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\neventually, the distance between all its elements is uniformly, arbitrarily small -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β]\n  {γ : Type u_1} {F : β → γ → α} {s : Set γ},\n  UniformCauchySeqOn F Filter.atTop s ↔\n    ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → ∀ (x : γ), x ∈ s → dist (F m x) (F n x) < ε :=\n\n/-- A sequentially continuous function defined on a sequential space is continuous. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\n  {f : X → Y}, SeqContinuous f → Continuous f :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformContinuous f :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\n  Filter.Tendsto b (nhds 0) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F :=\n\n/-- Characterization of uniform equicontinuity for families of functions taking values in a\n(pseudo) metric space. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F ↔\n    ∀ (ε : ℝ), ε > 0 → ∀ᶠ (xy : β × β) in uniformity β, ∀ (i : ι), dist (F i xy.fst) (F i xy.snd) < ε :=\n\n/-- If a sequence of functions between real or complex normed spaces are differentiable on a\npreconnected open set, they form a Cauchy sequence _at_ `x`, and their derivatives are Cauchy\nuniformly on the set, then the functions form a Cauchy sequence at any point in the set. -/\ntheorem ∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\n  {f' : ι → E → E →L[𝕜] G} {s : Set E},\n  IsOpen s →\n    IsPreconnected s →\n      UniformCauchySeqOn f' l s →\n        (∀ (n : ι) (y : E), y ∈ s → HasFDerivAt (f n) (f' n y) y) →\n          ∀ {x₀ x : E},\n            x₀ ∈ s → x ∈ s → Cauchy (Filter.map (fun n => f n x₀) l) → Cauchy (Filter.map (fun n => f n x) l) :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Characterization of uniform equicontinuity for families of functions between\n(pseudo) metric spaces. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β]\n  {F : ι → β → α},\n  UniformEquicontinuous F ↔\n    ∀ (ε : ℝ), ε > 0 → ∃ δ, δ > 0 ∧ ∀ (x y : β), dist x y < δ → ∀ (i : ι), dist (F i x) (F i y) < ε :=\n\n/-- Heine-Cantor: a continuous function on a compact set of a uniform space is uniformly\ncontinuous. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {s : Set α} {f : α → β},\n  IsCompact s → ContinuousOn f s → UniformContinuousOn f s :=\n\n/-- For a family of functions to a (pseudo) metric spaces, a convenient way to prove\nequicontinuity at a point is to show that all of the functions share a common *local* continuity\nmodulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : TopologicalSpace β] {x₀ : β}\n  (b : β → ℝ),\n  Filter.Tendsto b (nhds x₀) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ᶠ (x : β) in nhds x₀, ∀ (i : ι), dist (F i x₀) (F i x) ≤ b x) → EquicontinuousAt F x₀ :=\n\n/-- If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f) :=\n\n/-- Heine-Cantor: a continuous function on a compact uniform space is uniformly\ncontinuous. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → ∀ {u : ℕ → α}, CauchySeq u → CauchySeq (f ∘ u) "
    ]
  },
  {
    "docString": "Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.",
    "prompts": "[{\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] [inst_6 : DenselyOrdered β]\\n  {f : α → β}, Monotone f → Function.Surjective f → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monotone surjective function with a densely ordered codomain is continuous. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\\n  Continuous f → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function is monotone with respect to the specialization preorders on the domain and\\nthe codomain. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + τ f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\\n  (∀ (n : ℕ), Measurable (f n)) →\\n    (∀ (n : ℕ), f (Nat.succ n) ≤ᶠ[MeasureTheory.Measure.ae μ] f n) →\\n      ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤ → ∫⁻ (a : α), ⨅ (n : ℕ), f n a ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\\n  StrictMonoOn f s → MonotoneOn g s → StrictMonoOn (fun x => f x * g x) s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a strictly monotone function and a monotone function is strictly monotone. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeSup β] {f g : α → β},\\n  Antitone f → Antitone g → Antitone (f ⊔ g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pointwise supremum of two monotone functions is a monotone function. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β]\\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\\n  Monotone f → StrictMono g → StrictMono fun x => f x * g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a monotone function and a strictly monotone function is strictly monotone. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] (self : StrictSeries α), StrictMono self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"the underlying function should be strictly monotonic \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] [inst_6 : DenselyOrdered β]\\n  {f : α → β}, Monotone f → DenseRange f → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monotone function with densely ordered codomain and a dense range is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → c * a < c * b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left multiplication by a positive element is strictly monotone. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\\n  StrictMono f → StrictMono g → StrictMono fun x => f x + g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two strictly monotone functions is strictly monotone.\"},\n {\"theorem\": \"∀ {X Y : Compactum} (f : X ⟶ Y), Continuous f.f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of compacta is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\\n  StrictMonoOn f s → StrictMonoOn g s → StrictMonoOn (fun x => f x * g x) s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of two strictly monotone functions is strictly monotone. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeInf β] {f g : α → β} {s : Set α},\\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (f ⊓ g) s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pointwise infimum of two monotone functions is a monotone function. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\\n  Continuous self.invFun\",\n  \"isProp\": true,\n  \"docString\": \"The inverse map of a homeomorphism is a continuous function. \"}]\n",
    "prompt_cons": "/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- A monotone surjective function with a densely ordered codomain is continuous. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] [inst_6 : DenselyOrdered β]\n  {f : α → β}, Monotone f → Function.Surjective f → Continuous f :=\n\n/-- A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\n  Continuous f → Monotone f :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem ∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\n  (∀ (n : ℕ), Measurable (f n)) →\n    (∀ (n : ℕ), f (Nat.succ n) ≤ᶠ[MeasureTheory.Measure.ae μ] f n) →\n      ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤ → ∫⁻ (a : α), ⨅ (n : ℕ), f n a ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ :=\n\n/-- The product of a strictly monotone function and a monotone function is strictly monotone. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictMonoOn f s → MonotoneOn g s → StrictMonoOn (fun x => f x * g x) s :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- Pointwise supremum of two monotone functions is a monotone function. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeSup β] {f g : α → β},\n  Antitone f → Antitone g → Antitone (f ⊔ g) :=\n\n/-- The product of a monotone function and a strictly monotone function is strictly monotone. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β]\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x ≤ x_1] {f g : β → α},\n  Monotone f → StrictMono g → StrictMono fun x => f x * g x :=\n\n/-- the underlying function should be strictly monotonic -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] (self : StrictSeries α), StrictMono self.toFun :=\n\n/-- A monotone function with densely ordered codomain and a dense range is continuous. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] [inst_6 : DenselyOrdered β]\n  {f : α → β}, Monotone f → DenseRange f → Continuous f :=\n\n/-- Left multiplication by a positive element is strictly monotone. -/\ntheorem ∀ {α : Type u} [self : StrictOrderedSemiring α] (a b c : α), a < b → 0 < c → c * a < c * b :=\n\n/-- The sum of two strictly monotone functions is strictly monotone. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α}\n  [inst_3 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1],\n  StrictMono f → StrictMono g → StrictMono fun x => f x + g x :=\n\n/-- Any morphism of compacta is continuous. -/\ntheorem ∀ {X Y : Compactum} (f : X ⟶ Y), Continuous f.f :=\n\n/-- The product of two strictly monotone functions is strictly monotone. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Mul α] [inst_1 : Preorder α] [inst_2 : Preorder β] {f g : β → α} {s : Set β}\n  [inst_3 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1]\n  [inst_4 : CovariantClass α α (Function.swap fun x x_1 => x * x_1) fun x x_1 => x < x_1],\n  StrictMonoOn f s → StrictMonoOn g s → StrictMonoOn (fun x => f x * g x) s :=\n\n/-- Pointwise infimum of two monotone functions is a monotone function. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : SemilatticeInf β] {f g : α → β} {s : Set α},\n  MonotoneOn f s → MonotoneOn g s → MonotoneOn (f ⊓ g) s :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- An isometry is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → Continuous f :=\n\n/-- The inverse map of a homeomorphism is a continuous function. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\n  Continuous self.invFun :=\n\n/-- Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] {f : α → β},\n  Continuous f → IsOpenMap f → Monotone f "
    ]
  },
  {
    "docString": "Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$.",
    "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : MetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth σ-compact manifold with a metric. Let `K : ι → Set M` be a locally finite\\nfamily of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for all\\n`i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and `x ∈ K i`,\\nwe have `Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\\nexists a positive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`,\\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\\nexists a positive continuous function `δ : C(X, ℝ≥0∞)` such that for any `i` and `x ∈ K i`,\\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : EMetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K →\\n          ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → EMetric.closedBall x (ENNReal.ofReal (↑δ x)) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth σ-compact manifold with extended distance. Let `K : ι → Set M` be a locally\\nfinite family of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for\\nall `i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and\\n`x ∈ K i`, we have `EMetric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K →\\n          ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x (ENNReal.ofReal (↑δ x)) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\\nexists a positive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`,\\nwe have `EMetric.closedBall x (ENNReal.ofReal (δ x)) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\\n  {p : Set α → Prop} [inst_2 : MeasureTheory.Measure.OuterRegular μ],\\n  MeasureTheory.Measure.InnerRegular μ p IsOpen →\\n    p ∅ →\\n      (∀ ⦃s U : Set α⦄, p s → IsOpen U → p (s \\\\ U)) →\\n        MeasureTheory.Measure.InnerRegular μ p fun s => MeasurableSet s ∧ ↑↑μ s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a measure is inner regular (using closed or compact sets), then every measurable set of\\nfinite measure can by approximated by a (closed or compact) subset. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  (μ : MeasureTheory.Measure X), MeasureTheory.Measure.InnerRegular μ IsCompact IsClosed\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a `σ`-compact space, any closed set can be approximated by a compact subset. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\\n  ContractingWith K f →\\n    ∀ (g : α → α) {x y : α},\\n      Function.IsFixedPt f x →\\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f ≥ 1` on K. \"}]\n",
    "prompt_cons": "/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `M` be a smooth σ-compact manifold with a metric. Let `K : ι → Set M` be a locally finite\nfamily of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for all\n`i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and `x ∈ K i`,\nwe have `Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : MetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\nexists a positive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`,\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\nexists a positive continuous function `δ : C(X, ℝ≥0∞)` such that for any `i` and `x ∈ K i`,\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `M` be a smooth σ-compact manifold with extended distance. Let `K : ι → Set M` be a locally\nfinite family of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for\nall `i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and\n`x ∈ K i`, we have `EMetric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : EMetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K →\n          ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → EMetric.closedBall x (ENNReal.ofReal (↑δ x)) ⊆ U i :=\n\n/-- Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\nexists a positive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`,\nwe have `EMetric.closedBall x (ENNReal.ofReal (δ x)) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K →\n          ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x (ENNReal.ofReal (↑δ x)) ⊆ U i :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤ :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- If a measure is inner regular (using closed or compact sets), then every measurable set of\nfinite measure can by approximated by a (closed or compact) subset. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  {p : Set α → Prop} [inst_2 : MeasureTheory.Measure.OuterRegular μ],\n  MeasureTheory.Measure.InnerRegular μ p IsOpen →\n    p ∅ →\n      (∀ ⦃s U : Set α⦄, p s → IsOpen U → p (s \\ U)) →\n        MeasureTheory.Measure.InnerRegular μ p fun s => MeasurableSet s ∧ ↑↑μ s ≠ ⊤ :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem ∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- In a `σ`-compact space, any closed set can be approximated by a compact subset. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  (μ : MeasureTheory.Measure X), MeasureTheory.Measure.InnerRegular μ IsCompact IsClosed :=\n\n/-- Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. -/\ntheorem ∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\n  ContractingWith K f →\n    ∀ (g : α → α) {x y : α},\n      Function.IsFixedPt f x →\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f ≥ 1` on K. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x}) :=\n\n/-- Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      K ∩ F = ∅ →\n        ∃ δ, 0 < δ ∧ ∀ (p : X), p ∈ K → ∀ (q : X), q ∈ F → δ ≤ dist p q "
    ]
  },
  {
    "docString": "Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\\n  ContractingWith K f →\\n    ∀ (g : α → α) {x y : α},\\n      Function.IsFixedPt f x →\\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C < deriv f x) → ∀ ⦃x y : ℝ⦄, x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `C < f'`, then `f` grows faster than\\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {𝕂 : Type u_1} [inst : IsROrC 𝕂] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace 𝕂 E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace 𝕂 F'] {f : E' → F'} {x : E'},\\n  ContDiffAt 𝕂 1 f x → ∃ K t, t ∈ nhds x ∧ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ} {x a c d : ℝ} {l : Filter ℝ},\\n  l ≤ nhdsWithin x {x}ᶜ →\\n    Filter.Tendsto (fun y => (f y - d) / (y - x)) l (nhds a) →\\n      Filter.Tendsto (fun y => y + c * (y - x) ^ 2) l l →\\n        Filter.Tendsto (fun y => (f (y + c * (y - x) ^ 2) - d) / (y - x)) l (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `(f y - f x) / (y - x)` converges to a limit as `y` tends to `x`, then the same goes if\\n`y` is shifted a little bit, i.e., `f (y + (y-x)^2) - f x) / (y - x)` converges to the same limit.\\nThis lemma contains a slightly more general version of this statement (where one considers\\nconvergence along some subfilter, typically `𝓝[<] x` or `𝓝[>] x`) tailored to the application\\nto almost everywhere differentiability of monotone functions. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x < C) → ∀ ⦃x y : ℝ⦄, x < y → f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f' < C`, then `f` grows slower than\\n`C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x < y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\\n  {s : Set E} {x y : E},\\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero Fréchet derivative at every point of a convex set,\\nthen it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F'' : Type u_3} [inst : Norm E] [inst_1 : NormedAddCommGroup F''] {f : α → E}\\n  {g'' : α → F''}, f =O[Filter.cofinite] g'' → ∃ C, C > 0 ∧ ∀ ⦃x : α⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\\n`‖f x‖ ≤ C * ‖g x‖` whenever `g x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G]\\n  {f g : E → G} {s : Set E} {x : E},\\n  Convex ℝ s →\\n    DifferentiableOn 𝕜 f s →\\n      DifferentiableOn 𝕜 g s →\\n        UniqueDiffOn 𝕜 s →\\n          (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = fderivWithin 𝕜 g s x) → x ∈ s → f x = g x → Set.EqOn f g s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions have equal Fréchet derivatives at every point of a convex set, and are equal at\\none point in that set, then they are equal on that set. \"}]\n",
    "prompt_cons": "/-- Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. -/\ntheorem ∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\n  ContractingWith K f →\n    ∀ (g : α → α) {x y : α},\n      Function.IsFixedPt f x →\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K) :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `C < f'`, then `f` grows faster than\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C < deriv f x) → ∀ ⦃x y : ℝ⦄, x < y → C * (y - x) < f y - f x :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem ∀ {𝕂 : Type u_1} [inst : IsROrC 𝕂] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace 𝕂 E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace 𝕂 F'] {f : E' → F'} {x : E'},\n  ContDiffAt 𝕂 1 f x → ∃ K t, t ∈ nhds x ∧ LipschitzOnWith K f t :=\n\n/-- If `(f y - f x) / (y - x)` converges to a limit as `y` tends to `x`, then the same goes if\n`y` is shifted a little bit, i.e., `f (y + (y-x)^2) - f x) / (y - x)` converges to the same limit.\nThis lemma contains a slightly more general version of this statement (where one considers\nconvergence along some subfilter, typically `𝓝[<] x` or `𝓝[>] x`) tailored to the application\nto almost everywhere differentiability of monotone functions. -/\ntheorem ∀ {f : ℝ → ℝ} {x a c d : ℝ} {l : Filter ℝ},\n  l ≤ nhdsWithin x {x}ᶜ →\n    Filter.Tendsto (fun y => (f y - d) / (y - x)) l (nhds a) →\n      Filter.Tendsto (fun y => y + c * (y - x) ^ 2) l l →\n        Filter.Tendsto (fun y => (f (y + c * (y - x) ^ 2) - d) / (y - x)) l (nhds a) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f' < C`, then `f` grows slower than\n`C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x < y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x < C) → ∀ ⦃x y : ℝ⦄, x < y → f y - f x < C * (y - x) :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n] :=\n\n/-- If a function has zero Fréchet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\n  {s : Set E} {x y : E},\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y :=\n\n/-- If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f :=\n\n/-- If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\n`‖f x‖ ≤ C * ‖g x‖` whenever `g x ≠ 0`. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F'' : Type u_3} [inst : Norm E] [inst_1 : NormedAddCommGroup F''] {f : α → E}\n  {g'' : α → F''}, f =O[Filter.cofinite] g'' → ∃ C, C > 0 ∧ ∀ ⦃x : α⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖ :=\n\n/-- If two functions have equal Fréchet derivatives at every point of a convex set, and are equal at\none point in that set, then they are equal on that set. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G]\n  {f g : E → G} {s : Set E} {x : E},\n  Convex ℝ s →\n    DifferentiableOn 𝕜 f s →\n      DifferentiableOn 𝕜 g s →\n        UniqueDiffOn 𝕜 s →\n          (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = fderivWithin 𝕜 g s x) → x ∈ s → f x = g x → Set.EqOn f g s :=\n\n/-- Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant. -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y) ^ 2) → ∀ (x y : ℝ), f x = f y "
    ]
  },
  {
    "docString": "Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → ℝ),\\n  MeasureTheory.Integrable f →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), g x < ↑(f x)) ∧\\n            UpperSemicontinuous g ∧\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\\n                (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), EReal.toReal (g x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\\nof `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → ℝ),\\n  MeasureTheory.Integrable f →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), ↑(f x) < g x) ∧\\n            LowerSemicontinuous g ∧\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ]\\n  (f : MeasureTheory.SimpleFunc α NNReal),\\n  ∫⁻ (x : α), ↑(↑f x) ∂μ ≠ ⊤ →\\n    ∀ {ε : ENNReal},\\n      ε ≠ 0 → ∃ g, (∀ (x : α), g x ≤ ↑f x) ∧ UpperSemicontinuous g ∧ ∫⁻ (x : α), ↑(↑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {A : E →L[ℝ] E} {δ : NNReal},\\n  ApproximatesLinearOn f A s δ →\\n    MeasurableSet s →\\n      ∀ (f' : E → E →L[ℝ] E),\\n        (∀ (x : E), x ∈ s → HasFDerivWithinAt f (f' x) s x) →\\n          ∀ᵐ (x : E) ∂MeasureTheory.Measure.restrict μ s, ‖f' x - A‖₊ ≤ δ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `δ`,\\nthen at almost every `x` in `s` one has `‖f' x - A‖ ≤ δ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → NNReal),\\n  Measurable f →\\n    ∀ {ε : ENNReal},\\n      ε ≠ 0 → ∃ g, (∀ (x : α), ↑(f x) < g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a measurable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] (f : MeasureTheory.SimpleFunc α NNReal)\\n  {ε : ENNReal},\\n  ε ≠ 0 → ∃ g, (∀ (x : α), ↑f x ≤ g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(↑f x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `ℝ≥0`, there exists a lower semicontinuous\\nfunction `g ≥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → NNReal),\\n  AEMeasurable f →\\n    ∀ {ε : ENNReal},\\n      ε ≠ 0 → ∃ g, (∀ (x : α), ↑(f x) < g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an almost everywhere measurable function `f` with values in `ℝ≥0` in a sigma-finite space,\\nthere exists a lower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → NNReal),\\n  (MeasureTheory.Integrable fun x => ↑(f x)) →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), ↑(f x) < g x) ∧\\n            LowerSemicontinuous g ∧\\n              (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧\\n                (MeasureTheory.Integrable fun x => ENNReal.toReal (g x)) ∧\\n                  ∫ (x : α), ENNReal.toReal (g x) ∂μ < ∫ (x : α), ↑(f x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an integrable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `integral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : α → E} {a : α → ℝ} {t₀ : Filter α},\\n  (∀ (n : α), ‖f n‖ ≤ a n) → Filter.Tendsto a t₀ (nhds 0) → Filter.Tendsto f t₀ (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\\ntends to `0`, then `f` tends to `1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  ContinuousAt f x →\\n    Filter.Tendsto g p (nhds x) →\\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {R : NNReal} {f : α → ℝ},\\n  (∀ᵐ (x : α) ∂μ, |f x| ≤ ↑R) → ∀ᵐ (x : α) ∂μ, |MeasureTheory.condexp m μ f x| ≤ ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\\nexpectation. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\\n  ContinuousWithinAt f s x →\\n    Filter.Tendsto g p (nhdsWithin x s) →\\n      (∀ (u : Set (β × β)),\\n          u ∈ uniformity β → ∃ t, t ∈ nhdsWithin x s ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\\nwhich is continuous at `x` within `s `, and `gₙ` tends to `x` within `s`, then `Fₙ (gₙ)` tends\\nto `f x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"}]\n",
    "prompt_cons": "/-- For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\nintegral. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ :=\n\n/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → ℝ),\n  MeasureTheory.Integrable f →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), g x < ↑(f x)) ∧\n            UpperSemicontinuous g ∧\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\n                (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), EReal.toReal (g x) ∂μ + ε :=\n\n/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → ℝ),\n  MeasureTheory.Integrable f →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), ↑(f x) < g x) ∧\n            LowerSemicontinuous g ∧\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- Given a simple function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ]\n  (f : MeasureTheory.SimpleFunc α NNReal),\n  ∫⁻ (x : α), ↑(↑f x) ∂μ ≠ ⊤ →\n    ∀ {ε : ENNReal},\n      ε ≠ 0 → ∃ g, (∀ (x : α), g x ≤ ↑f x) ∧ UpperSemicontinuous g ∧ ∫⁻ (x : α), ↑(↑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε :=\n\n/-- If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `δ`,\nthen at almost every `x` in `s` one has `‖f' x - A‖ ≤ δ`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {A : E →L[ℝ] E} {δ : NNReal},\n  ApproximatesLinearOn f A s δ →\n    MeasurableSet s →\n      ∀ (f' : E → E →L[ℝ] E),\n        (∀ (x : E), x ∈ s → HasFDerivWithinAt f (f' x) s x) →\n          ∀ᵐ (x : E) ∂MeasureTheory.Measure.restrict μ s, ‖f' x - A‖₊ ≤ δ :=\n\n/-- Given a measurable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → NNReal),\n  Measurable f →\n    ∀ {ε : ENNReal},\n      ε ≠ 0 → ∃ g, (∀ (x : α), ↑(f x) < g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε :=\n\n/-- Given a simple function `f` with values in `ℝ≥0`, there exists a lower semicontinuous\nfunction `g ≥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] (f : MeasureTheory.SimpleFunc α NNReal)\n  {ε : ENNReal},\n  ε ≠ 0 → ∃ g, (∀ (x : α), ↑f x ≤ g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(↑f x) ∂μ + ε :=\n\n/-- Given an almost everywhere measurable function `f` with values in `ℝ≥0` in a sigma-finite space,\nthere exists a lower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → NNReal),\n  AEMeasurable f →\n    ∀ {ε : ENNReal},\n      ε ≠ 0 → ∃ g, (∀ (x : α), ↑(f x) < g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- Given an integrable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `integral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → NNReal),\n  (MeasureTheory.Integrable fun x => ↑(f x)) →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), ↑(f x) < g x) ∧\n            LowerSemicontinuous g ∧\n              (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧\n                (MeasureTheory.Integrable fun x => ENNReal.toReal (g x)) ∧\n                  ∫ (x : α), ENNReal.toReal (g x) ∂μ < ∫ (x : α), ↑(f x) ∂μ + ε :=\n\n/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real function `a` which\ntends to `0`, then `f` tends to `1`. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} [inst : SeminormedGroup E] {f : α → E} {a : α → ℝ} {t₀ : Filter α},\n  (∀ (n : α), ‖f n‖ ≤ a n) → Filter.Tendsto a t₀ (nhds 0) → Filter.Tendsto f t₀ (nhds 1) :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x :=\n\n/-- If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  ContinuousAt f x →\n    Filter.Tendsto g p (nhds x) →\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If the real valued function `f` is bounded almost everywhere by `R`, then so is its conditional\nexpectation. -/\ntheorem ∀ {α : Type u_1} {m m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {R : NNReal} {f : α → ℝ},\n  (∀ᵐ (x : α) ∂μ, |f x| ≤ ↑R) → ∀ᵐ (x : α) ∂μ, |MeasureTheory.condexp m μ f x| ≤ ↑R :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- If `Fₙ` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s `, and `gₙ` tends to `x` within `s`, then `Fₙ (gₙ)` tends\nto `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\n  ContinuousWithinAt f s x →\n    Filter.Tendsto g p (nhdsWithin x s) →\n      (∀ (u : Set (β × β)),\n          u ∈ uniformity β → ∃ t, t ∈ nhdsWithin x s ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousAt f x :=\n\n/-- Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough. -/\ntheorem",
    "choices": [
      "∀ {M ε : ℝ}, 0 < ε → ε * M < 1 → ∀ {g : ℝ → ℝ} {g' : ℝ → ℝ},\n  (∀ (x : ℝ), HasDerivAt g (g' x) x) →\n    (∀ (x : ℝ), abs (g' x) ≤ M) →\n      Function.Injective (λ x => x + ε * g x) "
    ]
  },
  {
    "docString": "Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$.",
    "prompts": "[{\"theorem\":\n  \"∀ {T : ℝ} {g : ℝ → ℝ},\\n  Function.Periodic g T →\\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\\n`t ↦ ∫ x in 0..t, g x` tends to `∞` as `t` tends to `∞`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {f' : E →L[𝕜] F} {x : E} {s : Set E},\\n  HasFDerivWithinAt f f' s x →\\n    ∀ {α : Type u_4} (l : Filter α) {c : α → 𝕜} {d : α → E} {v : E},\\n      (∀ᶠ (n : α) in l, x + d n ∈ s) →\\n        Filter.Tendsto (fun n => ‖c n‖) l Filter.atTop →\\n          Filter.Tendsto (fun n => c n • d n) l (nhds v) →\\n            Filter.Tendsto (fun n => c n • (f (x + d n) - f x)) l (nhds (↑f' v))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\\ntangent cone related discussions. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + τ f`. \"},\n {\"theorem\":\n  \"∀ {T : ℝ} {g : ℝ → ℝ},\\n  Function.Periodic g T →\\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atBot Filter.atBot\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\\n`t ↦ ∫ x in 0..t, g x` tends to `-∞` as `t` tends to `-∞`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {T : ℝ} {g : ℝ → ℝ},\\n  Function.Periodic g T →\\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\\n      (∀ (x : ℝ), 0 < g x) → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : ℝ → ℝ` is periodic with period `T > 0` and `∀ x, 0 < g x`, then `t ↦ ∫ x in 0..t, g x`\\ntends to `∞` as `t` tends to `∞`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s →\\n    ContinuousWithinAt f s x → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then `Fₙ gₙ`\\ntends to `f x` if `f` is continuous at `x` within `s`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {f : E → F → G} {g : E → F} {n : ℕ∞},\\n  ContDiff 𝕜 n (Function.uncurry f) → Continuous g → 1 ≤ n → Continuous fun x => fderiv 𝕜 (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x ↦ fderiv 𝕜 (f x) (g x)` is continuous. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → ∀ (y : ℝ), HasDerivAt f (g y) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is the derivative of `f` everywhere. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\\n  (∀ (Z : C) (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp f g = 0 → g = 0) → CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {T : ℝ} {g : ℝ → ℝ},\\n  Function.Periodic g T →\\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\\n      (∀ (x : ℝ), 0 < g x) → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atBot Filter.atBot\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : ℝ → ℝ` is periodic with period `T > 0` and `∀ x, 0 < g x`, then `t ↦ ∫ x in 0..t, g x`\\ntends to `-∞` as `t` tends to `-∞`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p →\\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. \"},\n {\"theorem\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\\n  (∀ (Z : C) (g : Z ⟶ X), CategoryTheory.CategoryStruct.comp g f = 0 → g = 0) → CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformlyOn F f p s →\\n    ContinuousWithinAt f s x →\\n      x ∈ s → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends locally uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then\\n`Fₙ gₙ` tends to `f x` if `f` is continuous at `x` within `s` and `x ∈ s`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\\n          (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  ContinuousAt f x →\\n    Filter.Tendsto g p (nhds x) →\\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. \"}]\n",
    "prompt_cons": "/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `∞` as `t` tends to `∞`. -/\ntheorem ∀ {T : ℝ} {g : ℝ → ℝ},\n  Function.Periodic g T →\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop :=\n\n/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\ntangent cone related discussions. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x : E} {s : Set E},\n  HasFDerivWithinAt f f' s x →\n    ∀ {α : Type u_4} (l : Filter α) {c : α → 𝕜} {d : α → E} {v : E},\n      (∀ᶠ (n : α) in l, x + d n ∈ s) →\n        Filter.Tendsto (fun n => ‖c n‖) l Filter.atTop →\n          Filter.Tendsto (fun n => c n • d n) l (nhds v) →\n            Filter.Tendsto (fun n => c n • (f (x + d n) - f x)) l (nhds (↑f' v)) :=\n\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem ∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `-∞` as `t` tends to `-∞`. -/\ntheorem ∀ {T : ℝ} {g : ℝ → ℝ},\n  Function.Periodic g T →\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atBot Filter.atBot :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `∀ x, 0 < g x`, then `t ↦ ∫ x in 0..t, g x`\ntends to `∞` as `t` tends to `∞`. -/\ntheorem ∀ {T : ℝ} {g : ℝ → ℝ},\n  Function.Periodic g T →\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n      (∀ (x : ℝ), 0 < g x) → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x :=\n\n/-- If `Fₙ` tends uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then `Fₙ gₙ`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s →\n    ContinuousWithinAt f s x → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- `x ↦ fderiv 𝕜 (f x) (g x)` is continuous. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {f : E → F → G} {g : E → F} {n : ℕ∞},\n  ContDiff 𝕜 n (Function.uncurry f) → Continuous g → 1 ≤ n → Continuous fun x => fderiv 𝕜 (f x) (g x) :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is the derivative of `f` everywhere. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → ∀ (y : ℝ), HasDerivAt f (g y) y :=\n\n/-- For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\nintegral. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ :=\n\n/-- If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\n  (∀ (Z : C) (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp f g = 0 → g = 0) → CategoryTheory.Epi f :=\n\n/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `∀ x, 0 < g x`, then `t ↦ ∫ x in 0..t, g x`\ntends to `-∞` as `t` tends to `-∞`. -/\ntheorem ∀ {T : ℝ} {g : ℝ → ℝ},\n  Function.Periodic g T →\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n      (∀ (x : ℝ), 0 < g x) → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atBot Filter.atBot :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- If `Fₙ` tends uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\n  (∀ (Z : C) (g : Z ⟶ X), CategoryTheory.CategoryStruct.comp g f = 0 → g = 0) → CategoryTheory.Mono f :=\n\n/-- If `Fₙ` tends locally uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then\n`Fₙ gₙ` tends to `f x` if `f` is continuous at `x` within `s` and `x ∈ s`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformlyOn F f p s →\n    ContinuousWithinAt f s x →\n      x ∈ s → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` -/\ntheorem ∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\n          (nhds x) :=\n\n/-- If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  ContinuousAt f x →\n    Filter.Tendsto g p (nhds x) →\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. -/\ntheorem",
    "choices": [
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E} {g : ℝ → E},\n  (∀ (x : ℝ), 0 < x → DifferentiableAt ℝ f x) →\n    Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) →\n      (∀ (x : ℝ), g x = f (x + 1) - f x) → Filter.Tendsto g Filter.atTop (nhds 0) "
    ]
  },
  {
    "docString": "Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p →\\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\\n          (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p →\\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends locally uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ} {x a c d : ℝ} {l : Filter ℝ},\\n  l ≤ nhdsWithin x {x}ᶜ →\\n    Filter.Tendsto (fun y => (f y - d) / (y - x)) l (nhds a) →\\n      Filter.Tendsto (fun y => y + c * (y - x) ^ 2) l l →\\n        Filter.Tendsto (fun y => (f (y + c * (y - x) ^ 2) - d) / (y - x)) l (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `(f y - f x) / (y - x)` converges to a limit as `y` tends to `x`, then the same goes if\\n`y` is shifted a little bit, i.e., `f (y + (y-x)^2) - f x) / (y - x)` converges to the same limit.\\nThis lemma contains a slightly more general version of this statement (where one considers\\nconvergence along some subfilter, typically `𝓝[<] x` or `𝓝[>] x`) tailored to the application\\nto almost everywhere differentiability of monotone functions. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] {s : Set X},\\n  IsPreconnected s →\\n    ∀ {a b : X},\\n      a ∈ s →\\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\\nthen for some `x ∈ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\\n  (∀ (Z : C) (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp f g = 0 → g = 0) → CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s →\\n    ContinuousWithinAt f s x → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then `Fₙ gₙ`\\ntends to `f x` if `f` is continuous at `x` within `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_3} {ι : Type u_2} {hm : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : TopologicalSpace α] [inst_1 : BorelSpace α] [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E]\\n  {g : α → E} {l : Filter ι} {x₀ : α} {s : Set α} {φ : ι → α → ℝ},\\n  MeasurableSet s →\\n    (∀ᶠ (i : ι) in l, ∀ (x : α), x ∈ s → 0 ≤ φ i x) →\\n      (∀ (u : Set α), IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \\\\ u)) →\\n        (∀ᶠ (i : ι) in l, ∫ (x : α) in s, φ i x ∂μ = 1) →\\n          MeasureTheory.IntegrableOn g s →\\n            g x₀ = 0 → ContinuousWithinAt g s x₀ → Filter.Tendsto (fun i => ∫ (x : α) in s, φ i x • g x ∂μ) l (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀`, and\\n`g` is integrable and continuous at `x₀`, then `∫ φᵢ • g` converges to `x₀`. Auxiliary lemma\\nwhere one assumes additionally `g x₀ = 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformlyOn F f p s →\\n    ContinuousWithinAt f s x →\\n      x ∈ s → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends locally uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then\\n`Fₙ gₙ` tends to `f x` if `f` is continuous at `x` within `s` and `x ∈ s`. \"},\n {\"theorem\":\n  \"∀ {f g : ℝ → ℝ} {a b : ℝ},\\n  a < b →\\n    ContinuousOn f (Set.Icc a b) →\\n      ContinuousOn g (Set.Icc a b) →\\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. \"},\n {\"theorem\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\\n  (∀ (Z : C) (g : Z ⟶ X), CategoryTheory.CategoryStruct.comp g f = 0 → g = 0) → CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  ContinuousAt f x →\\n    Filter.Tendsto g p (nhds x) →\\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}\\n  {f : X ⟶ Y}, f = 0 → ∀ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.ι f = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If we know `f = 0`,\\nit requires a little work to conclude `image.ι f = 0`,\\nbecause `f = g` only implies `image f ≅ image g`.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_3} {ι : Type u_2} {hm : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : TopologicalSpace α] [inst_1 : BorelSpace α] [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E]\\n  {g : α → E} {l : Filter ι} {x₀ : α} {s : Set α} {φ : ι → α → ℝ},\\n  MeasurableSet s →\\n    (∀ (u : Set α), IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \\\\ u)) →\\n      (∀ᶠ (i : ι) in l, ∫ (x : α) in s, φ i x ∂μ = 1) →\\n        MeasureTheory.IntegrableOn g s →\\n          ContinuousWithinAt g s x₀ → ∀ᶠ (i : ι) in l, MeasureTheory.IntegrableOn (fun x => φ i x • g x) s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀`, and\\n`g` is integrable and continuous at `x₀`, then `φᵢ • g` is eventually integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F'' : Type u_3} [inst : Norm E] [inst_1 : NormedAddCommGroup F''] {f : α → E}\\n  {g'' : α → F''}, f =O[Filter.cofinite] g'' → ∃ C, C > 0 ∧ ∀ ⦃x : α⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\\n`‖f x‖ ≤ C * ‖g x‖` whenever `g x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"}]\n",
    "prompt_cons": "/-- If `Fₙ` tends uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` -/\ntheorem ∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\n          (nhds x) :=\n\n/-- If `Fₙ` tends locally uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- If `(f y - f x) / (y - x)` converges to a limit as `y` tends to `x`, then the same goes if\n`y` is shifted a little bit, i.e., `f (y + (y-x)^2) - f x) / (y - x)` converges to the same limit.\nThis lemma contains a slightly more general version of this statement (where one considers\nconvergence along some subfilter, typically `𝓝[<] x` or `𝓝[>] x`) tailored to the application\nto almost everywhere differentiability of monotone functions. -/\ntheorem ∀ {f : ℝ → ℝ} {x a c d : ℝ} {l : Filter ℝ},\n  l ≤ nhdsWithin x {x}ᶜ →\n    Filter.Tendsto (fun y => (f y - d) / (y - x)) l (nhds a) →\n      Filter.Tendsto (fun y => y + c * (y - x) ^ 2) l l →\n        Filter.Tendsto (fun y => (f (y + c * (y - x) ^ 2) - d) / (y - x)) l (nhds a) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\nthen for some `x ∈ s` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {s : Set X},\n  IsPreconnected s →\n    ∀ {a b : X},\n      a ∈ s →\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\n  (∀ (Z : C) (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp f g = 0 → g = 0) → CategoryTheory.Epi f :=\n\n/-- If `Fₙ` tends uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then `Fₙ gₙ`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s →\n    ContinuousWithinAt f s x → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀`, and\n`g` is integrable and continuous at `x₀`, then `∫ φᵢ • g` converges to `x₀`. Auxiliary lemma\nwhere one assumes additionally `g x₀ = 0`. -/\ntheorem ∀ {α : Type u_1} {E : Type u_3} {ι : Type u_2} {hm : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : TopologicalSpace α] [inst_1 : BorelSpace α] [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E]\n  {g : α → E} {l : Filter ι} {x₀ : α} {s : Set α} {φ : ι → α → ℝ},\n  MeasurableSet s →\n    (∀ᶠ (i : ι) in l, ∀ (x : α), x ∈ s → 0 ≤ φ i x) →\n      (∀ (u : Set α), IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \\ u)) →\n        (∀ᶠ (i : ι) in l, ∫ (x : α) in s, φ i x ∂μ = 1) →\n          MeasureTheory.IntegrableOn g s →\n            g x₀ = 0 → ContinuousWithinAt g s x₀ → Filter.Tendsto (fun i => ∫ (x : α) in s, φ i x • g x ∂μ) l (nhds 0) :=\n\n/-- If `Fₙ` tends locally uniformly to `f` on a set `s`, and `gₙ` tends to `x` within `s`, then\n`Fₙ gₙ` tends to `f x` if `f` is continuous at `x` within `s` and `x ∈ s`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformlyOn F f p s →\n    ContinuousWithinAt f s x →\n      x ∈ s → Filter.Tendsto g p (nhdsWithin x s) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. -/\ntheorem ∀ {f g : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Icc a b) →\n      ContinuousOn g (Set.Icc a b) →\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x :=\n\n/-- If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\n  (∀ (Z : C) (g : Z ⟶ X), CategoryTheory.CategoryStruct.comp g f = 0 → g = 0) → CategoryTheory.Mono f :=\n\n/-- If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  ContinuousAt f x →\n    Filter.Tendsto g p (nhds x) →\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- If we know `f = 0`,\nit requires a little work to conclude `image.ι f = 0`,\nbecause `f = g` only implies `image f ≅ image g`. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}\n  {f : X ⟶ Y}, f = 0 → ∀ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.ι f = 0 :=\n\n/-- If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀`, and\n`g` is integrable and continuous at `x₀`, then `φᵢ • g` is eventually integrable. -/\ntheorem ∀ {α : Type u_1} {E : Type u_3} {ι : Type u_2} {hm : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : TopologicalSpace α] [inst_1 : BorelSpace α] [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E]\n  {g : α → E} {l : Filter ι} {x₀ : α} {s : Set α} {φ : ι → α → ℝ},\n  MeasurableSet s →\n    (∀ (u : Set α), IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \\ u)) →\n      (∀ᶠ (i : ι) in l, ∫ (x : α) in s, φ i x ∂μ = 1) →\n        MeasureTheory.IntegrableOn g s →\n          ContinuousWithinAt g s x₀ → ∀ᶠ (i : ι) in l, MeasureTheory.IntegrableOn (fun x => φ i x • g x) s :=\n\n/-- If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\n`‖f x‖ ≤ C * ‖g x‖` whenever `g x ≠ 0`. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F'' : Type u_3} [inst : Norm E] [inst_1 : NormedAddCommGroup F''] {f : α → E}\n  {g'' : α → F''}, f =O[Filter.cofinite] g'' → ∃ C, C > 0 ∧ ∀ ⦃x : α⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖ :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$ -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} [inst : NondiscreteNormedField 𝕜] {f g : 𝕜 → 𝕜} {x : 𝕜},\n  DifferentiableAt 𝕜 f x →\n    DifferentiableAt 𝕜 g x →\n      deriv g x ≠ 0 → f x = 0 → g x = 0 → Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (deriv f x / deriv g x)) "
    ]
  },
  {
    "docString": "Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  ConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → 𝕜` is concave, then for any three points `x < y < z` the slope of the secant line of\\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  StrictConcaveOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is strictly concave iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), x ≤ 0 → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → z.im ≤ 0 → ‖f z‖ ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\\n  for some `c < 2`;\\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\\n\\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  StrictConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → 𝕜` is strictly concave, then for any three points `x < y < z` the slope of the\\nsecant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f g : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      DiffContOnCl ℂ g (Set.Iio 0 ×ℂ Set.Iio 0) →\\n        (∃ c,\\n            c < 2 ∧\\n              ∃ B,\\n                g =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n                  rexp (B * ↑Complex.abs z ^ c)) →\\n          (∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) →\\n            (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = g (↑x * Complex.I)) → Set.EqOn f g {z | z.re ≤ 0 ∧ z.im ≤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f g : ℂ → E` be functions such that\\n\\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\\n  quadrant for some `A`, `B`, and `c < 2`;\\n* `f` is equal to `g` on the boundary of the third quadrant.\\n\\nThen `f` is equal to `g` on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  ConcaveOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is concave iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  StrictConvexOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is strictly convex iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), deriv^[2] f x ≤ 0) → ConcaveOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `ℝ`, and `f''` is nonpositive on `ℝ`,\\nthen `f` is concave on `ℝ`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  ConvexOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is convex iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), 0 ≤ deriv^[2] f x) → ConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `ℝ`, and `f''` is nonnegative on `ℝ`,\\nthen `f` is convex on `ℝ`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {A : E →L[ℝ] E} {δ : NNReal},\\n  ApproximatesLinearOn f A s δ →\\n    MeasurableSet s →\\n      ∀ (f' : E → E →L[ℝ] E),\\n        (∀ (x : E), x ∈ s → HasFDerivWithinAt f (f' x) s x) →\\n          ∀ᵐ (x : E) ∂MeasureTheory.Measure.restrict μ s, ‖f' x - A‖₊ ≤ δ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `δ`,\\nthen at almost every `x` in `s` one has `‖f' x - A‖ ≤ δ`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), 0 ≤ x → f ↑x = 0) →\\n        (∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | 0 ≤ z.re ∧ 0 ≤ z.im}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the first quadrant.\\n\\nThen `f` is equal to zero on the closed first quadrant. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. \"}]\n",
    "prompt_cons": "/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0} :=\n\n/-- If `f : 𝕜 → 𝕜` is concave, then for any three points `x < y < z` the slope of the secant line of\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  ConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x) :=\n\n/-- A function `f : 𝕜 → 𝕜` is strictly concave iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  StrictConcaveOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), x ≤ 0 → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → z.im ≤ 0 → ‖f z‖ ≤ C :=\n\n/-- If `f : 𝕜 → 𝕜` is strictly concave, then for any three points `x < y < z` the slope of the\nsecant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  StrictConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the third quadrant.\n\nThen `f` is equal to `g` on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f g : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      DiffContOnCl ℂ g (Set.Iio 0 ×ℂ Set.Iio 0) →\n        (∃ c,\n            c < 2 ∧\n              ∃ B,\n                g =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n                  rexp (B * ↑Complex.abs z ^ c)) →\n          (∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) →\n            (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = g (↑x * Complex.I)) → Set.EqOn f g {z | z.re ≤ 0 ∧ z.im ≤ 0} :=\n\n/-- A function `f : 𝕜 → 𝕜` is concave iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  ConcaveOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- A function `f : 𝕜 → 𝕜` is strictly convex iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  StrictConvexOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f :=\n\n/-- If a function `f` is twice differentiable on `ℝ`, and `f''` is nonpositive on `ℝ`,\nthen `f` is concave on `ℝ`. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), deriv^[2] f x ≤ 0) → ConcaveOn ℝ Set.univ f :=\n\n/-- A function `f : 𝕜 → 𝕜` is convex iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  ConvexOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y) :=\n\n/-- If a function `f` is twice differentiable on `ℝ`, and `f''` is nonnegative on `ℝ`,\nthen `f` is convex on `ℝ`. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), 0 ≤ deriv^[2] f x) → ConvexOn ℝ Set.univ f :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f :=\n\n/-- If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `δ`,\nthen at almost every `x` in `s` one has `‖f' x - A‖ ≤ δ`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {A : E →L[ℝ] E} {δ : NNReal},\n  ApproximatesLinearOn f A s δ →\n    MeasurableSet s →\n      ∀ (f' : E → E →L[ℝ] E),\n        (∀ (x : E), x ∈ s → HasFDerivWithinAt f (f' x) s x) →\n          ∀ᵐ (x : E) ∂MeasureTheory.Measure.restrict μ s, ‖f' x - A‖₊ ≤ δ :=\n\n/-- **Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), 0 ≤ x → f ↑x = 0) →\n        (∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | 0 ≤ z.re ∧ 0 ≤ z.im} :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$. -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      Differentiable ℝ (deriv^[2] f) →\n        f (-1) = 0 →\n          f 0 = 0 →\n            f 1 = 1 →\n              deriv f 0 = 0 →\n                ∃ (x : ℝ), -1 < x ∧ x < 1 ∧ 3 ≤ deriv^[3] f x "
    ]
  },
  {
    "docString": "Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [t : TopologicalSpace α], t = ⊤ → ∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ U = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\\n  TendstoUniformlyOn F f p ∅\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  ¬Continuous ↑CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P], affineSpan k ∅ = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"The span of the empty set is `⊥`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Infinite α], IrreducibleSpace (CofiniteTopology α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite type with cofinite topology is an irreducible topological space. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, Set.Nonempty s → EMetric.hausdorffEdist s ∅ = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"The Haudorff edistance to the empty set is infinite \"},\n {\"theorem\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\": \"∀ {α : Type u_1} {r : Setoid α}, ¬∅ ∈ Setoid.classes r\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is not an equivalence class. \"},\n {\"theorem\": \"∀ {α : Type u_1} (U : Set α), IsOpen U ↔ U = ∅ ∨ U = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only open sets in the indiscrete topology are the empty set and the whole space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)] [inst_2 : T0Space X],\\n  TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A T₀ uniform space with countably generated `𝓤 X` is metrizable. This is not an instance to\\navoid loops. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  ∃ f, Embedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A T₃ topological space with second countable topology can be embedded into `l^∞ = ℕ →ᵇ ℝ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] (a : α),\\n  IsClosed (Set.Ici a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"}]\n",
    "prompt_cons": "/-- If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ) :=\n\n/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem ∀ {α : Type u_1} [t : TopologicalSpace α], t = ⊤ → ∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ U = ⊤ :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\n  TendstoUniformlyOn F f p ∅ :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  ¬Continuous ↑CofiniteTopology.of.symm :=\n\n/-- The span of the empty set is `⊥`. -/\ntheorem ∀ (k : Type u_2) (V : Type u_3) (P : Type u_1) [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P], affineSpan k ∅ = ⊥ :=\n\n/-- An infinite type with cofinite topology is an irreducible topological space. -/\ntheorem ∀ {α : Type u_1} [inst : Infinite α], IrreducibleSpace (CofiniteTopology α) :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- The Haudorff edistance to the empty set is infinite -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, Set.Nonempty s → EMetric.hausdorffEdist s ∅ = ⊤ :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem ∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K) :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- The empty set is not an equivalence class. -/\ntheorem ∀ {α : Type u_1} {r : Setoid α}, ¬∅ ∈ Setoid.classes r :=\n\n/-- The only open sets in the indiscrete topology are the empty set and the whole space. -/\ntheorem ∀ {α : Type u_1} (U : Set α), IsOpen U ↔ U = ∅ ∨ U = Set.univ :=\n\n/-- A T₀ uniform space with countably generated `𝓤 X` is metrizable. This is not an instance to\navoid loops. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)] [inst_2 : T0Space X],\n  TopologicalSpace.MetrizableSpace X :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- A T₃ topological space with second countable topology can be embedded into `l^∞ = ℕ →ᵇ ℝ`. -/\ntheorem ∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  ∃ f, Embedding f :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] (a : α),\n  IsClosed (Set.Ici a) :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$. -/\ntheorem",
    "choices": [
      "∃ {X : Type u_1} [inst : TopologicalSpace X], ¬TopologicalSpace.generateFrom {U : Set X | Set.Finite (X - U) ∨ U = ∅ ∨ U = X} = inst "
    ]
  },
  {
    "docString": "If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\\nwhere `Π i, π i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning α are disjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {c : Set (Set α)}, Setoid.IsPartition c → ∀ {s : Set α}, s ∈ c → Set.Nonempty s\",\n  \"isProp\": true,\n  \"docString\": \"A partition of `α` does not contain the empty set. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  [inst_3 : Nonempty ι] [inst_4 : TopologicalSpace E] {p : SeminormFamily 𝕜 E ι},\\n  WithSeminorms p → ((∀ (x : E), x ≠ 0 → ∃ i, ↑(p i) x ≠ 0) ↔ T1Space E)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family of seminorms is separating iff it induces a T₁ topology. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  ¬Continuous ↑CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : T3Space α],\\n  NormalSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A T₃ topological space with second countable topology is a normal space.\\nThis lemma is not an instance to avoid a loop. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\\n  (F : ι → C(α, β)),\\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `α`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space ↑s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology ↑s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is T₀ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\\n  TopologicalSpace.IsTopologicalBasis s →\\n    ∀ {t : Set (Set β)},\\n      TopologicalSpace.IsTopologicalBasis t →\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  [inst_3 : Nonempty ι] [inst_4 : TopologicalSpace E] {p : SeminormFamily 𝕜 E ι},\\n  WithSeminorms p → (∀ (x : E), x ≠ 0 → ∃ i, ↑(p i) x ≠ 0) → T1Space E\",\n  \"isProp\": true,\n  \"docString\": \"A separating family of seminorms induces a T₁ topology. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\\n  {K L : Set G}, IsCompact K → IsCompact L → ∃ g, Disjoint K (g • L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two compact sets in a noncompact topological group, there is a translate of the second\\none that is disjoint from the first one. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α), (∀ (i : ι), IsClosed (Z i)) → s ∩ ⋂ (i : ι), Z i = ∅ → ∃ t, s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i = ∅\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every family of closed sets whose intersection avoids a compact set,\\nthere exists a finite subfamily whose intersection avoids this compact set. \"}]\n",
    "prompt_cons": "/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem ∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\n  Inducing fun x i => f i x :=\n\n/-- Distinct elements of a set of sets partitioning α are disjoint. -/\ntheorem ∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id :=\n\n/-- A partition of `α` does not contain the empty set. -/\ntheorem ∀ {α : Type u_1} {c : Set (Set α)}, Setoid.IsPartition c → ∀ {s : Set α}, s ∈ c → Set.Nonempty s :=\n\n/-- A family of seminorms is separating iff it induces a T₁ topology. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  [inst_3 : Nonempty ι] [inst_4 : TopologicalSpace E] {p : SeminormFamily 𝕜 E ι},\n  WithSeminorms p → ((∀ (x : E), x ≠ 0 → ∃ i, ↑(p i) x ≠ 0) ↔ T1Space E) :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  ¬Continuous ↑CofiniteTopology.of.symm :=\n\n/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- A T₃ topological space with second countable topology is a normal space.\nThis lemma is not an instance to avoid a loop. -/\ntheorem ∀ (α : Type u) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : T3Space α],\n  NormalSpace α :=\n\n/-- A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `α`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\n  (F : ι → C(α, β)),\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is T₀ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space ↑s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology ↑s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem ∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s →\n    ∀ {t : Set (Set β)},\n      TopologicalSpace.IsTopologicalBasis t →\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t) :=\n\n/-- If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ) :=\n\n/-- A separating family of seminorms induces a T₁ topology. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  [inst_3 : Nonempty ι] [inst_4 : TopologicalSpace E] {p : SeminormFamily 𝕜 E ι},\n  WithSeminorms p → (∀ (x : E), x ≠ 0 → ∃ i, ↑(p i) x ≠ 0) → T1Space E :=\n\n/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\n  {K L : Set G}, IsCompact K → IsCompact L → ∃ g, Disjoint K (g • L) :=\n\n/-- For every family of closed sets whose intersection avoids a compact set,\nthere exists a finite subfamily whose intersection avoids this compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α), (∀ (i : ι), IsClosed (Z i)) → s ∩ ⋂ (i : ι), Z i = ∅ → ∃ t, s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i = ∅ :=\n\n/-- If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$. -/\ntheorem",
    "choices": [
      "This is not a theorem, as it is a statement about a counterexample. Theorem statements in Lean should be provable statements about mathematical objects and their properties. Instead, you can provide a counterexample to show that the union of a family of topologies is not necessarily a topology."
    ]
  },
  {
    "docString": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\\nwhere `Π i, π i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the topology of a space is induced by a countable family of seminorms, then the topology\\nis first countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\\n  ContinuousMap.compactOpen =\\n    ⨅ (s : Set α) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\\n  (F : ι → C(α, β)),\\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `α`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  t = TopologicalSpace.generateFrom s →\\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space ↑s]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology ↑s], HasCountableSeparatingOn X IsOpen s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a topological space, `s` is a set in `X` such that the induced topology is T₀ and is\\nsecond countable, then there exists a countable family of open sets in `X` that separates points\\nof `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning α are disjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},\\n  t₂ ≤ t₃ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β],\\n  Inducing (↑UniformFun.ofFun ∘ FunLike.coe)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on `α →ᵇ β` is exactly the topology induced by the natural map to `α →ᵤ β`. \"}]\n",
    "prompt_cons": "/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖) :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem ∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\n  Inducing fun x i => f i x :=\n\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E :=\n\n/-- The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  ContinuousMap.compactOpen =\n    ⨅ (s : Set α) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `α`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\n  (F : ι → C(α, β)),\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s}) :=\n\n/-- If `X` is a topological space, `s` is a set in `X` such that the induced topology is T₀ and is\nsecond countable, then there exists a countable family of open sets in `X` that separates points\nof `s`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space ↑s]\n  [inst_2 : TopologicalSpace.SecondCountableTopology ↑s], HasCountableSeparatingOn X IsOpen s :=\n\n/-- Distinct elements of a set of sets partitioning α are disjoint. -/\ntheorem ∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},\n  t₂ ≤ t₃ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s :=\n\n/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t :=\n\n/-- The topology on `α →ᵇ β` is exactly the topology induced by the natural map to `α →ᵤ β`. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β],\n  Inducing (↑UniformFun.ofFun ∘ FunLike.coe) :=\n\n/-- Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃! (T' : TopologicalSpace X), ∀ (i : ι), T' ≤ T i "
    ]
  },
  {
    "docString": "Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  t = TopologicalSpace.generateFrom s →\\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → TopologicalSpace (E i)] {s : (i : ι) → Set (Set (E i))},\\n  (∀ (i : ι), TopologicalSpace.IsTopologicalBasis (s i)) →\\n    TopologicalSpace.IsTopologicalBasis (⋃ (i : ι), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\\n  TopologicalSpace.IsTopologicalBasis s →\\n    ∀ {t : Set (Set β)},\\n      TopologicalSpace.IsTopologicalBasis t →\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {P : Submodule R M} (b : Basis ι R { x // x ∈ P }) {x : M}, x ∈ P ↔ ∃ c, x = Finsupp.sum c fun i x => x • ↑(↑b i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the submodule `P` has a basis, `x ∈ P` iff it is a linear combination of basis vectors. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  (∀ (u : Set α), u ∈ s → IsOpen u) →\\n    (∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v, v ∈ s ∧ a ∈ v ∧ v ⊆ u) → TopologicalSpace.IsTopologicalBasis s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of open sets `s` is such that every open neighbourhood contains some\\nmember of `s`, then `s` is a topological basis. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {ι : Type u_2} [inst : Ring A] {B : ι → AddSubgroup A},\\n  RingSubgroupsBasis B → ∀ (x : A) (i : ι), ∃ j, ↑(B j) ⊆ (fun x_1 => x * x_1) ⁻¹' ↑(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any element `x : A` and any set `B` in the submodule basis on `A`,\\nthere is another basis element `B'` such that `B' * x` is in `B`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t → s ⊆ t → Monoid.Closure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submonoid generated by a set is contained in any submonoid that contains the set. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f g : M →* N} {s : Set M},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Submonoid.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its submonoid closure. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {ι : Type u_2} [inst : Ring A] {B : ι → AddSubgroup A},\\n  RingSubgroupsBasis B → ∀ (x : A) (i : ι), ∃ j, ↑(B j) ⊆ (fun x_1 => x_1 * x) ⁻¹' ↑(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any element `x : A` and any set `B` in the submodule basis on `A`,\\nthere is another basis element `B'` such that `x * B'` is in `B`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {ι : Type u_2} [inst : Ring A] {B : ι → AddSubgroup A},\\n  RingSubgroupsBasis B → ∀ (i : ι), ∃ j, ↑(B j) * ↑(B j) ⊆ ↑(B i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\\nthat the set-theoretic product `B' * B'` is in `B`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"}]\n",
    "prompt_cons": "/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s}) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → TopologicalSpace (E i)] {s : (i : ι) → Set (Set (E i))},\n  (∀ (i : ι), TopologicalSpace.IsTopologicalBasis (s i)) →\n    TopologicalSpace.IsTopologicalBasis (⋃ (i : ι), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem ∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s →\n    ∀ {t : Set (Set β)},\n      TopologicalSpace.IsTopologicalBasis t →\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t) :=\n\n/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t :=\n\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- If the submodule `P` has a basis, `x ∈ P` iff it is a linear combination of basis vectors. -/\ntheorem ∀ {ι : Type u_3} {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {P : Submodule R M} (b : Basis ι R { x // x ∈ P }) {x : M}, x ∈ P ↔ ∃ c, x = Finsupp.sum c fun i x => x • ↑(↑b i) :=\n\n/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  (∀ (u : Set α), u ∈ s → IsOpen u) →\n    (∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v, v ∈ s ∧ a ∈ v ∧ v ⊆ u) → TopologicalSpace.IsTopologicalBasis s :=\n\n/-- For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `B' * x` is in `B`. -/\ntheorem ∀ {A : Type u_1} {ι : Type u_2} [inst : Ring A] {B : ι → AddSubgroup A},\n  RingSubgroupsBasis B → ∀ (x : A) (i : ι), ∃ j, ↑(B j) ⊆ (fun x_1 => x * x_1) ⁻¹' ↑(B i) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- The submonoid generated by a set is contained in any submonoid that contains the set. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t → s ⊆ t → Monoid.Closure s ⊆ t :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its submonoid closure. -/\ntheorem ∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {f g : M →* N} {s : Set M},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Submonoid.closure s) :=\n\n/-- For any element `x : A` and any set `B` in the submodule basis on `A`,\nthere is another basis element `B'` such that `x * B'` is in `B`. -/\ntheorem ∀ {A : Type u_1} {ι : Type u_2} [inst : Ring A] {B : ι → AddSubgroup A},\n  RingSubgroupsBasis B → ∀ (x : A) (i : ι), ∃ j, ↑(B j) ⊆ (fun x_1 => x_1 * x) ⁻¹' ↑(B i) :=\n\n/-- For each set `B` in the submodule basis on `A`, there is another basis element `B'` such\nthat the set-theoretic product `B' * B'` is in `B`. -/\ntheorem ∀ {A : Type u_1} {ι : Type u_2} [inst : Ring A] {B : ι → AddSubgroup A},\n  RingSubgroupsBasis B → ∀ (i : ι), ∃ j, ↑(B j) * ↑(B j) ⊆ ↑(B i) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S) :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤ :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2 :=\n\n/-- Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {A : Set (Set α)},\n  TopologicalSpace.generateFrom A = ⋂₀ {t : TopologicalSpace α | A ⊆ t.istopologicalbasis} "
    ]
  },
  {
    "docString": "Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {α : Type ua} [inst : UniformSpace α], Filter.HasBasis (uniformity α) (fun V => V ∈ uniformity α ∧ IsOpen V) id\",\n  \"isProp\": true,\n  \"docString\": \"Open elements of `𝓤 α` form a basis of `𝓤 α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\\n      MeasureTheory.Integrable bound →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => ↑(I ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {Γ₀ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Γ₀] (v : Valuation R Γ₀),\\n  RingSubgroupsBasis fun γ => Valuation.ltAddSubgroup v γ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The basis of open subgroups for the topology on a ring determined by a valuation. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  t = TopologicalSpace.generateFrom s →\\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_3} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_1} [inst_4 : DecidableEq ι] [inst_5 : Fintype ι]\\n  (bS : Basis ι R S) (a : S) {y : ℤ},\\n  (∀ (k : ι), ↑abv (↑(↑bS.repr a) k) ≤ y) →\\n    ↑abv (↑(Algebra.norm R) a) ≤ ClassGroup.normBound abv bS * y ^ Fintype.card ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `R`-integral element `a : S` has coordinates `≤ y` with respect to some basis `b`,\\nits norm is less than `normBound abv b * y ^ dim S`. \"},\n {\"theorem\":\n  \"∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\\n  IsUnit (Algebra.discr K ↑b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n ≤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsNoetherianRing R], IsNoetherianRing (Polynomial R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. \"},\n {\"theorem\":\n  \"∀ {α : Type ua} [inst : UniformSpace α],\\n  Filter.HasBasis (uniformity α) (fun V => V ∈ uniformity α ∧ IsOpen V ∧ SymmetricRel V) id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Open elements `s : Set (α × α)` of `𝓤 α` such that `(x, y) ∈ s ↔ (y, x) ∈ s` form a basis\\nof `𝓤 α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (f : Filter α) [inst : Filter.IsCountablyGenerated f], ∃ x, Filter.HasAntitoneBasis f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A countably generated filter admits a basis formed by an antitone sequence of sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {f : Filter α} {a : α} {s : Set α},\\n  a ∈ s → IsOpen s → Filter.principal s ≤ f → nhds a ≤ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\\nthe principal filter of some open set `s` containing `a`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  (∀ (u : Set α), u ∈ s → IsOpen u) →\\n    (∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v, v ∈ s ∧ a ∈ v ∧ v ⊆ u) → TopologicalSpace.IsTopologicalBasis s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of open sets `s` is such that every open neighbourhood contains some\\nmember of `s`, then `s` is a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_4} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_3} [inst_4 : DecidableEq ι] [inst_5 : Fintype ι]\\n  (bS : Basis ι R S) {T : Type u_1} [inst_6 : LinearOrderedRing T] (a : S) {y : T},\\n  (∀ (k : ι), ↑(↑abv (↑(↑bS.repr a) k)) < y) →\\n    ↑(↑abv (↑(Algebra.norm R) a)) < ↑(ClassGroup.normBound abv bS) * y ^ Fintype.card ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `R`-integral element `a : S` has coordinates `< y` with respect to some basis `b`,\\nits norm is strictly less than `normBound abv b * y ^ dim S`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α] [inst_2 : OrderTopology α]\\n  [inst_3 : NoMaxOrder α] {a : α},\\n  0 < a → Filter.HasBasis (nhds a) (fun ε => 0 < ε ∧ ε ≤ a) fun ε => Set.Ioo (a - ε) (a + ε)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals \"}]\n",
    "prompt_cons": "/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- Open elements of `𝓤 α` form a basis of `𝓤 α`. -/\ntheorem ∀ {α : Type ua} [inst : UniformSpace α], Filter.HasBasis (uniformity α) (fun V => V ∈ uniformity α ∧ IsOpen V) id :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\n      MeasureTheory.Integrable bound →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f)) :=\n\n/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R), Filter.HasBasis (nhds 0) (fun _n => True) fun n => ↑(I ^ n) :=\n\n/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {Γ₀ : Type v} [inst_1 : LinearOrderedCommGroupWithZero Γ₀] (v : Valuation R Γ₀),\n  RingSubgroupsBasis fun γ => Valuation.ltAddSubgroup v γ :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s}) :=\n\n/-- If the `R`-integral element `a : S` has coordinates `≤ y` with respect to some basis `b`,\nits norm is less than `normBound abv b * y ^ dim S`. -/\ntheorem ∀ {R : Type u_2} {S : Type u_3} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_1} [inst_4 : DecidableEq ι] [inst_5 : Fintype ι]\n  (bS : Basis ι R S) (a : S) {y : ℤ},\n  (∀ (k : ι), ↑abv (↑(↑bS.repr a) k) ≤ y) →\n    ↑abv (↑(Algebra.norm R) a) ≤ ClassGroup.normBound abv bS * y ^ Fintype.card ι :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. -/\ntheorem ∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\n  IsUnit (Algebra.discr K ↑b) :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n ≤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsNoetherianRing R], IsNoetherianRing (Polynomial R) :=\n\n/-- Open elements `s : Set (α × α)` of `𝓤 α` such that `(x, y) ∈ s ↔ (y, x) ∈ s` form a basis\nof `𝓤 α`. -/\ntheorem ∀ {α : Type ua} [inst : UniformSpace α],\n  Filter.HasBasis (uniformity α) (fun V => V ∈ uniformity α ∧ IsOpen V ∧ SymmetricRel V) id :=\n\n/-- A countably generated filter admits a basis formed by an antitone sequence of sets. -/\ntheorem ∀ {α : Type u_1} (f : Filter α) [inst : Filter.IsCountablyGenerated f], ∃ x, Filter.HasAntitoneBasis f x :=\n\n/-- To show a filter is above the neighborhood filter at `a`, it suffices to show that it is above\nthe principal filter of some open set `s` containing `a`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {f : Filter α} {a : α} {s : Set α},\n  a ∈ s → IsOpen s → Filter.principal s ≤ f → nhds a ≤ f :=\n\n/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  (∀ (u : Set α), u ∈ s → IsOpen u) →\n    (∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v, v ∈ s ∧ a ∈ v ∧ v ⊆ u) → TopologicalSpace.IsTopologicalBasis s :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- If the `R`-integral element `a : S` has coordinates `< y` with respect to some basis `b`,\nits norm is strictly less than `normBound abv b * y ^ dim S`. -/\ntheorem ∀ {R : Type u_2} {S : Type u_4} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) {ι : Type u_3} [inst_4 : DecidableEq ι] [inst_5 : Fintype ι]\n  (bS : Basis ι R S) {T : Type u_1} [inst_6 : LinearOrderedRing T] (a : S) {y : T},\n  (∀ (k : ι), ↑(↑abv (↑(↑bS.repr a) k)) < y) →\n    ↑(↑abv (↑(Algebra.norm R) a)) < ↑(ClassGroup.normBound abv bS) * y ^ Fintype.card ι :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u)) :=\n\n/-- If `a` is positive we can form a basis from only nonnegative `Set.Ioo` intervals -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α] [inst_2 : OrderTopology α]\n  [inst_3 : NoMaxOrder α] {a : α},\n  0 < a → Filter.HasBasis (nhds a) (fun ε => 0 < ε ∧ ε ≤ a) fun ε => Set.Ioo (a - ε) (a + ε) :=\n\n/-- Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$. -/\ntheorem",
    "choices": [
      "Real.basis_rat : Filter.HasBasis (nhds 0) (fun i : ℚ × ℚ => i.1 < i.2) (λ q, Set.Ioo (q.1 : ℝ) q.2) "
    ]
  },
  {
    "docString": "Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\\n  {f : X → Y}, Embedding f → DiscreteTopology X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced under an inclusion `f : X → Y` from the discrete topological space `Y`\\nis the discrete topology on `X`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V},\\n  S ⊆ ↑W → W ≤ Projectivization.Subspace.span S → Projectivization.Subspace.span S = W\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of points in projective space is contained in a subspace, and that subspace is\\ncontained in the span of the set of points, then the span of the set of points is equal to\\nthe subspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `T₅` space is a `T₅` space. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 ≤ s2 ↔ ↑s1 ⊆ ↑s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `≤` order on subspaces is the same as that on the corresponding sets. \"},\n {\"theorem\":\n  \"∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\\n  (s : ι → Set (ℙ K V)),\\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Coercing a subspace to a set then taking the affine span produces the original subspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 < s2 ↔ ↑s1 ⊂ ↑s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `<` order on subspaces is the same as that on the corresponding sets. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (s : Set (Submodule 𝕜 E)), ⨅ (K : Submodule 𝕜 E) (_ : K ∈ s), Kᗮ = (sSup s)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t → s ⊆ t → Monoid.Closure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submonoid generated by a set is contained in any submonoid that contains the set. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Monotone Projectivization.Subspace.span\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of points is a subset of another set of points, then its span will be contained in the\\nspan of that set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"}]\n",
    "prompt_cons": "/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤ :=\n\n/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S) :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- The topology induced under an inclusion `f : X → Y` from the discrete topological space `Y`\nis the discrete topology on `X`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\n  {f : X → Y}, Embedding f → DiscreteTopology X :=\n\n/-- If a set of points in projective space is contained in a subspace, and that subspace is\ncontained in the span of the set of points, then the span of the set of points is equal to\nthe subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V},\n  S ⊆ ↑W → W ≤ Projectivization.Subspace.span S → Projectivization.Subspace.span S = W :=\n\n/-- A subspace of a `T₅` space is a `T₅` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x } :=\n\n/-- The `≤` order on subspaces is the same as that on the corresponding sets. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 ≤ s2 ↔ ↑s1 ⊆ ↑s2 :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem ∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Set (ℙ K V)),\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- The `<` order on subspaces is the same as that on the corresponding sets. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 < s2 ↔ ↑s1 ⊂ ↑s2 :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (s : Set (Submodule 𝕜 E)), ⨅ (K : Submodule 𝕜 E) (_ : K ∈ s), Kᗮ = (sSup s)ᗮ :=\n\n/-- The submonoid generated by a set is contained in any submonoid that contains the set. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t → s ⊆ t → Monoid.Closure s ⊆ t :=\n\n/-- If a set of points is a subset of another set of points, then its span will be contained in the\nspan of that set. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Monotone Projectivization.Subspace.span :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y} {f : Y → X},\n  Embedding f → IsOpenMap f → ∀ (s : Set A), IsOpen (f '' (coe '' s)) ↔ IsOpen (coe '' s) "
    ]
  },
  {
    "docString": "Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\": \"Cardinal.mk ↑Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the reals, as a set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\\n  IsUnit (Algebra.discr K ↑b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\\n      MeasureTheory.Integrable bound →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\\n  n ≠ 0 → ∀ {x y : α}, x < y → 0 < y → ∃ q, 0 < q ∧ x < ↑q ^ n ∧ ↑q ^ n < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_3} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommRing S] {L : Type u_1}\\n  [inst_3 : Field L] [inst_4 : Algebra R S] [inst_5 : Algebra S L] [inst_6 : Algebra R L] [inst_7 : IsScalarTower R S L]\\n  [inst_8 : IsIntegralClosure S R L],\\n  Algebra.IsAlgebraic R L → Function.Injective ↑(algebraMap R L) → ∀ (a : S) {b : S}, b ≠ 0 → ∃ c d x, d • a = b * c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fraction `(a : S) / (b : S)` can be reduced to `(c : S) / (d : R)`,\\nif `S` is the integral closure of `R` in an algebraic extension `L` of `R`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (self : Filter.CountableFilterBasis α), Set.Countable self.sets\",\n  \"isProp\": true,\n  \"docString\": \"The set of sets of the filter basis is countable. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\\n  Algebra.discr K ↑b ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b ≠ 0`. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : UniformSpace α] [inst_1 : Filter.IsCountablyGenerated (uniformity α)]\\n  [inst_2 : TopologicalSpace.SeparableSpace α], TopologicalSpace.SecondCountableTopology α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A separable uniform space with countably generated uniformity filter is second countable:\\none obtains a countable basis by taking the balls centered at points in a dense subset,\\nand with rational \\\"radii\\\" from a countable open symmetric antitone basis of `𝓤 α`. We do not\\nregister this as an instance, as there is already an instance going in the other direction\\nfrom second countable spaces to separable spaces, and we want to avoid loops. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\\n  (∀ (r : R),\\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} [inst : Fintype ι] (b : OrthonormalBasis ι ℝ ℝ), (↑b = fun x => 1) ∨ ↑b = fun x => -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An orthonormal basis of `ℝ` is made either of the vector `1`, or of the vector `-1`. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} {f f' : ℝ → ℝ},\\n  a ≤ b →\\n    (∀ (x : ℝ), x ∈ Set.Icc a b → HasDerivWithinAt f (f' x) (Set.Icc a b) x) →\\n      ∀ {m : ℝ}, f' a < m → m < f' b → m ∈ f' '' Set.Ioo a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a ≤ b` and `f' a < m < f' b`, then `f' c = m` for some\\n`c ∈ (a, b)`. \"}]\n",
    "prompt_cons": "/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- The cardinality of the reals, as a set. -/\ntheorem Cardinal.mk ↑Set.univ = Cardinal.continuum :=\n\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b` is a unit. -/\ntheorem ∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\n  IsUnit (Algebra.discr K ↑b) :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\n      MeasureTheory.Integrable bound →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f)) :=\n\n/-- There is a rational power between any two positive elements of an archimedean ordered field. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  n ≠ 0 → ∀ {x y : α}, x < y → 0 < y → ∃ q, 0 < q ∧ x < ↑q ^ n ∧ ↑q ^ n < y :=\n\n/-- A fraction `(a : S) / (b : S)` can be reduced to `(c : S) / (d : R)`,\nif `S` is the integral closure of `R` in an algebraic extension `L` of `R`. -/\ntheorem ∀ {R : Type u_2} {S : Type u_3} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommRing S] {L : Type u_1}\n  [inst_3 : Field L] [inst_4 : Algebra R S] [inst_5 : Algebra S L] [inst_6 : Algebra R L] [inst_7 : IsScalarTower R S L]\n  [inst_8 : IsIntegralClosure S R L],\n  Algebra.IsAlgebraic R L → Function.Injective ↑(algebraMap R L) → ∀ (a : S) {b : S}, b ≠ 0 → ∃ c d x, d • a = b * c :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- The set of sets of the filter basis is countable. -/\ntheorem ∀ {α : Type u_1} (self : Filter.CountableFilterBasis α), Set.Countable self.sets :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b ≠ 0`. -/\ntheorem ∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\n  Algebra.discr K ↑b ≠ 0 :=\n\n/-- A separable uniform space with countably generated uniformity filter is second countable:\none obtains a countable basis by taking the balls centered at points in a dense subset,\nand with rational \"radii\" from a countable open symmetric antitone basis of `𝓤 α`. We do not\nregister this as an instance, as there is already an instance going in the other direction\nfrom second countable spaces to separable spaces, and we want to avoid loops. -/\ntheorem ∀ (α : Type u) [inst : UniformSpace α] [inst_1 : Filter.IsCountablyGenerated (uniformity α)]\n  [inst_2 : TopologicalSpace.SeparableSpace α], TopologicalSpace.SecondCountableTopology α :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\n  (∀ (r : R),\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- An orthonormal basis of `ℝ` is made either of the vector `1`, or of the vector `-1`. -/\ntheorem ∀ {ι : Type u_1} [inst : Fintype ι] (b : OrthonormalBasis ι ℝ ℝ), (↑b = fun x => 1) ∨ ↑b = fun x => -1 :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- **Darboux's theorem**: if `a ≤ b` and `f' a < m < f' b`, then `f' c = m` for some\n`c ∈ (a, b)`. -/\ntheorem ∀ {a b : ℝ} {f f' : ℝ → ℝ},\n  a ≤ b →\n    (∀ (x : ℝ), x ∈ Set.Icc a b → HasDerivWithinAt f (f' x) (Set.Icc a b) x) →\n      ∀ {m : ℝ}, f' a < m → m < f' b → m ∈ f' '' Set.Ioo a b :=\n\n/-- Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$. -/\ntheorem",
    "choices": [
      "Real.basis_rat_rat : TopologicalSpace.IsTopologicalBasis (SetOf fun s => ∃ a b c d : ℚ, a < b ∧ c < d ∧ s = Set.Ioo (a, c) (b, d)) "
    ]
  },
  {
    "docString": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LE β] {f g : α → β} {a : α},\\n  f ≤ᶠ[nhds a] g → ∀ᶠ (y : α) in nhds a, f ≤ᶠ[nhds y] g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x ≤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\\n`f x ≤ g x` in a neighbourhood of `y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : OrderClosedTopology α],\\n  IsClosed {p | p.fst ≤ p.snd}\",\n  \"isProp\": true,\n  \"docString\": \"The set `{ (x, y) | x ≤ y }` is a closed set. \"},\n {\"theorem\":\n  \"∀ {f g : ℝ → ℝ} {a b : ℝ},\\n  a < b →\\n    ContinuousOn f (Set.Icc a b) →\\n      ContinuousOn g (Set.Icc a b) →\\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\\n  [inst_6 : OrderClosedTopology δ] {s : Set α} [hs : Set.OrdConnected s] {f : α → δ},\\n  ContinuousOn f s → ∀ {a b : α}, a ∈ s → b ∈ s → Set.SurjOn f s (Set.uIcc (f a) (f b))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone g → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n]\",\n  \"isProp\": true,\n  \"docString\": \"If `f ≤ g` and `g` is monotone, then `f^[n] ≤ g^[n]`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\\n  IsClosed s →\\n    IsClosed t →\\n      Disjoint s t →\\n        ∀ {a b : ℝ},\\n          a ≤ b →\\n            ∃ f,\\n              Set.EqOn (↑f) (Function.const X a) s ∧\\n                Set.EqOn (↑f) (Function.const X b) t ∧ ∀ (x : X), ↑f x ∈ Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\\nand `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that\\n\\n* `f` equals `a` on `s`;\\n* `f` equals `b` on `t`;\\n* `a ≤ f x ≤ b` for all `x`.\\n\"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\\n  {f : X → Y}, Embedding f → DiscreteTopology X\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced under an inclusion `f : X → Y` from the discrete topological space `Y`\\nis the discrete topology on `X`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeSup α] {β : Type u_1} [inst_1 : Preorder β] {f g : α → β},\\n  Monotone f → Antitone g → f ≤ g → ∀ (m n : α), f m ≤ g n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is monotone, `g` is antitone, and `f ≤ g`, then for all `a`, `b` we have `f a ≤ g b`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone f → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n]\",\n  \"isProp\": true,\n  \"docString\": \"If `f ≤ g` and `f` is monotone, then `f^[n] ≤ g^[n]`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] {s : Set X},\\n  IsPreconnected s →\\n    ∀ {a b : X},\\n      a ∈ s →\\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\\nthen for some `x ∈ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → NNReal),\\n  (MeasureTheory.Integrable fun x => ↑(f x)) →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), ↑(f x) < g x) ∧\\n            LowerSemicontinuous g ∧\\n              (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧\\n                (MeasureTheory.Integrable fun x => ENNReal.toReal (g x)) ∧\\n                  ∫ (x : α), ENNReal.toReal (g x) ∂μ < ∫ (x : α), ↑(f x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an integrable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `integral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → NNReal),\\n  Measurable f →\\n    ∀ {ε : ENNReal},\\n      ε ≠ 0 → ∃ g, (∀ (x : α), ↑(f x) < g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a measurable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\\nFormulation in terms of `lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {f g : ℝ → ℝ} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\\n  a ≤ b →\\n    IntervalIntegrable f μ a b →\\n      IntervalIntegrable g μ a b →\\n        f ≤ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Set.Ioc a b))] g →\\n          ↑↑(MeasureTheory.Measure.restrict μ (Set.Ioc a b)) {x | f x < g x} ≠ 0 →\\n            ∫ (x : ℝ) in a..b, f x ∂μ < ∫ (x : ℝ) in a..b, g x ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are two functions that are interval integrable on `a..b`, `a ≤ b`,\\n`f x ≤ g x` for a.e. `x ∈ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\\nof nonzero measure, then `∫ x in a..b, f x ∂μ < ∫ x in a..b, g x ∂μ`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\\n`g ∘ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ]\\n  (f : MeasureTheory.SimpleFunc α NNReal),\\n  ∫⁻ (x : α), ↑(↑f x) ∂μ ≠ ⊤ →\\n    ∀ {ε : ENNReal},\\n      ε ≠ 0 → ∃ g, (∀ (x : α), g x ≤ ↑f x) ∧ UpperSemicontinuous g ∧ ∫⁻ (x : α), ↑(↑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. \"}]\n",
    "prompt_cons": "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- If `f x ≤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x ≤ g x` in a neighbourhood of `y`. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LE β] {f g : α → β} {a : α},\n  f ≤ᶠ[nhds a] g → ∀ᶠ (y : α) in nhds a, f ≤ᶠ[nhds y] g :=\n\n/-- The set `{ (x, y) | x ≤ y }` is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : OrderClosedTopology α],\n  IsClosed {p | p.fst ≤ p.snd} :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. -/\ntheorem ∀ {f g : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Icc a b) →\n      ContinuousOn g (Set.Icc a b) →\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- **Intermediate value theorem**: if `f` is continuous on an order-connected set `s` and `a`,\n`b` are two points of this set, then `f` sends `s` to a superset of `[f x, f y]`. -/\ntheorem ∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\n  [inst_6 : OrderClosedTopology δ] {s : Set α} [hs : Set.OrdConnected s] {f : α → δ},\n  ContinuousOn f s → ∀ {a b : α}, a ∈ s → b ∈ s → Set.SurjOn f s (Set.uIcc (f a) (f b)) :=\n\n/-- If `f ≤ g` and `g` is monotone, then `f^[n] ≤ g^[n]`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone g → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n] :=\n\n/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,\nand `a ≤ b` are two real numbers, then there exists a continuous function `f : X → ℝ` such that\n\n* `f` equals `a` on `s`;\n* `f` equals `b` on `t`;\n* `a ≤ f x ≤ b` for all `x`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s →\n    IsClosed t →\n      Disjoint s t →\n        ∀ {a b : ℝ},\n          a ≤ b →\n            ∃ f,\n              Set.EqOn (↑f) (Function.const X a) s ∧\n                Set.EqOn (↑f) (Function.const X b) t ∧ ∀ (x : X), ↑f x ∈ Set.Icc a b :=\n\n/-- The topology induced under an inclusion `f : X → Y` from the discrete topological space `Y`\nis the discrete topology on `X`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [tY : TopologicalSpace Y] [inst_1 : DiscreteTopology Y]\n  {f : X → Y}, Embedding f → DiscreteTopology X :=\n\n/-- If `f` is monotone, `g` is antitone, and `f ≤ g`, then for all `a`, `b` we have `f a ≤ g b`. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeSup α] {β : Type u_1} [inst_1 : Preorder β] {f g : α → β},\n  Monotone f → Antitone g → f ≤ g → ∀ (m n : α), f m ≤ g n :=\n\n/-- If `f ≤ g` and `f` is monotone, then `f^[n] ≤ g^[n]`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone f → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n] :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\nthen for some `x ∈ s` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {s : Set X},\n  IsPreconnected s →\n    ∀ {a b : X},\n      a ∈ s →\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x :=\n\n/-- Given an integrable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `integral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → NNReal),\n  (MeasureTheory.Integrable fun x => ↑(f x)) →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), ↑(f x) < g x) ∧\n            LowerSemicontinuous g ∧\n              (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧\n                (MeasureTheory.Integrable fun x => ENNReal.toReal (g x)) ∧\n                  ∫ (x : α), ENNReal.toReal (g x) ∂μ < ∫ (x : α), ↑(f x) ∂μ + ε :=\n\n/-- Given a measurable function `f` with values in `ℝ≥0` in a sigma-finite space, there exists a\nlower semicontinuous function `g > f` with integral arbitrarily close to that of `f`.\nFormulation in terms of `lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → NNReal),\n  Measurable f →\n    ∀ {ε : ENNReal},\n      ε ≠ 0 → ∃ g, (∀ (x : α), ↑(f x) < g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), g x ∂μ ≤ ∫⁻ (x : α), ↑(f x) ∂μ + ε :=\n\n/-- If `f` and `g` are two functions that are interval integrable on `a..b`, `a ≤ b`,\n`f x ≤ g x` for a.e. `x ∈ Set.Ioc a b`, and `f x < g x` on a subset of `Set.Ioc a b`\nof nonzero measure, then `∫ x in a..b, f x ∂μ < ∫ x in a..b, g x ∂μ`. -/\ntheorem ∀ {f g : ℝ → ℝ} {a b : ℝ} {μ : MeasureTheory.Measure ℝ},\n  a ≤ b →\n    IntervalIntegrable f μ a b →\n      IntervalIntegrable g μ a b →\n        f ≤ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ (Set.Ioc a b))] g →\n          ↑↑(MeasureTheory.Measure.restrict μ (Set.Ioc a b)) {x | f x < g x} ≠ 0 →\n            ∫ (x : ℝ) in a..b, f x ∂μ < ∫ (x : ℝ) in a..b, g x ∂μ :=\n\n/-- If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\n`g ∘ f` is measurable if and only if `g` is measurable. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g :=\n\n/-- Given a simple function `f` with values in `ℝ≥0`, there exists an upper semicontinuous\nfunction `g ≤ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ]\n  (f : MeasureTheory.SimpleFunc α NNReal),\n  ∫⁻ (x : α), ↑(↑f x) ∂μ ≠ ⊤ →\n    ∀ {ε : ENNReal},\n      ε ≠ 0 → ∃ g, (∀ (x : α), g x ≤ ↑f x) ∧ UpperSemicontinuous g ∧ ∫⁻ (x : α), ↑(↑f x) ∂μ ≤ ∫⁻ (x : α), ↑(g x) ∂μ + ε :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K :=\n\n/-- Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$. -/\ntheorem",
    "choices": [
      "forall {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] [Preorder Y] [OrderClosedTopology Y]\n  {f g : X → Y}, Continuous f → Continuous g → IsClosed {x | f x ≤ g x} "
    ]
  },
  {
    "docString": "Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\\n  Function.Injective f → Continuous f → T2Space α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X → Y}\\n  {s : Set X}, HolderOnWith C r f s → 0 < r → UniformContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\": \"A Hölder continuous function is uniformly continuous \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] {K : NNReal} {f : X → Y},\\n  LipschitzWith K f → dimH (Set.range f) ≤ dimH Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the\\nHausdorff dimension of its domain. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology X] {r : NNReal} {f : X → Y},\\n  0 < r → (∀ (x : X), ∃ C s, s ∈ nhds x ∧ HolderOnWith C r f s) → dimH (Set.range f) ≤ dimH Set.univ / ↑r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X → Y` is Hölder continuous in a neighborhood of every point `x : X` with the same\\npositive exponent `r` but possibly different coefficients, then the Hausdorff dimension of the range\\nof `f` is at most the Hausdorff dimension of `X` divided by `r`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology X] {f : X → Y},\\n  (∀ (x : X), ∃ C s, s ∈ nhds x ∧ LipschitzOnWith C f s) → dimH (Set.range f) ≤ dimH Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X → Y` is Lipschitz in a neighborhood of each point `x : X`, then the Hausdorff\\ndimension of `range f` is at most the Hausdorff dimension of `X`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : RegularSpace Y]\\n  {f : X → Y} {A B : Set X},\\n  B ⊆ closure A → (∀ (x : X), x ∈ B → ∃ y, Filter.Tendsto f (nhdsWithin x A) (nhds y)) → ContinuousOn (extendFrom A f) B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function to a T₃ space `Y` which has a limit within `A` at any\\npoint of a set `B ⊆ closure A`, then `extendFrom A f` is continuous on `B`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ},\\n  s ⊆ f ⁻¹' e.source → (ContinuousOn f s ↔ ContinuousOn (↑e ∘ f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\\n`g ∘ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} {x : α} [inst_1 : TopologicalSpace α],\\n  x ∈ s →\\n    (∀ (u : Set (β × β)),\\n        u ∈ uniformity β →\\n          ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"}]\n",
    "prompt_cons": "/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\n  Function.Injective f → Continuous f → T2Space α :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X → Y}\n  {s : Set X}, HolderOnWith C r f s → 0 < r → UniformContinuousOn f s :=\n\n/-- If `f` is a Lipschitz continuous map, then the Hausdorff dimension of its range is at most the\nHausdorff dimension of its domain. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y] {K : NNReal} {f : X → Y},\n  LipschitzWith K f → dimH (Set.range f) ≤ dimH Set.univ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s)) :=\n\n/-- If `f : X → Y` is Hölder continuous in a neighborhood of every point `x : X` with the same\npositive exponent `r` but possibly different coefficients, then the Hausdorff dimension of the range\nof `f` is at most the Hausdorff dimension of `X` divided by `r`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y]\n  [inst_2 : TopologicalSpace.SecondCountableTopology X] {r : NNReal} {f : X → Y},\n  0 < r → (∀ (x : X), ∃ C s, s ∈ nhds x ∧ HolderOnWith C r f s) → dimH (Set.range f) ≤ dimH Set.univ / ↑r :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- If `f : X → Y` is Lipschitz in a neighborhood of each point `x : X`, then the Hausdorff\ndimension of `range f` is at most the Hausdorff dimension of `X`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : EMetricSpace X] [inst_1 : EMetricSpace Y]\n  [inst_2 : TopologicalSpace.SecondCountableTopology X] {f : X → Y},\n  (∀ (x : X), ∃ C s, s ∈ nhds x ∧ LipschitzOnWith C f s) → dimH (Set.range f) ≤ dimH Set.univ :=\n\n/-- If `f` is a function to a T₃ space `Y` which has a limit within `A` at any\npoint of a set `B ⊆ closure A`, then `extendFrom A f` is continuous on `B`. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : RegularSpace Y]\n  {f : X → Y} {A B : Set X},\n  B ⊆ closure A → (∀ (x : X), x ∈ B → ∃ y, Filter.Tendsto f (nhdsWithin x A) (nhds y)) → ContinuousOn (extendFrom A f) B :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ},\n  s ⊆ f ⁻¹' e.source → (ContinuousOn f s ↔ ContinuousOn (↑e ∘ f) s) :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousAt f x :=\n\n/-- If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\n`g ∘ f` is measurable if and only if `g` is measurable. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} {x : α} [inst_1 : TopologicalSpace α],\n  x ∈ s →\n    (∀ (u : Set (β × β)),\n        u ∈ uniformity β →\n          ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n      ContinuousWithinAt f s x :=\n\n/-- Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {A : Set α} {f : A → β}\n  {x : α} {y : β},\n  ContinuousWithinAt f A x →\n    ContinuousWithinAt (Function.extend A f) (Closure A) x →\n      x ∈ Closure A → (Function.extend A f x = y ↔ Set.indicator A f x = y) "
    ]
  },
  {
    "docString": "Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners ℝ E H →\\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\\n  Measurable f → MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Urysohn's metrization theorem* (Tychonoff's version): a T₃ topological space with second\\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\\nsame topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, strongly measurable and measurable are equivalent. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : Preorder α] [inst_2 : CompactIccSpace α] {s : Set α},\\n  BddAbove s → BddBelow s → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudo metric space with a conditionally complete linear order such that the order and the\\nmetric structure give the same topology, any order-bounded set is metric-bounded. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m m' : MetricSpace α}, PseudoMetricSpace.toDist = PseudoMetricSpace.toDist → m = m'\",\n  \"isProp\": true,\n  \"docString\": \"Two metric space structures with the same distance coincide. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\\n  [inst_2 : TopologicalSpace.MetrizableSpace Y] {f : X → Y}, Embedding f → TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an embedding of a topological space into a metrizable space, the source space is also\\nmetrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {f : α → β} {x : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} [inst_1 : MeasurableSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\\n  Measurable f → MeasureTheory.AEStronglyMeasurable f μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies ae strongly measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is a right-neighborhood of all of its points, then it is measurable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.Bounded s ↔ EMetric.diam s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] {Γ : Subgroup G}\\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G ⧸ Γ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a second countable topological group by a subgroup is second countable. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) (β : Type u_2) [inst : LinearOrder α] [inst_1 : LinearOrder β] [inst_2 : Encodable α]\\n  [inst_3 : DenselyOrdered α] [inst_4 : NoMinOrder α] [inst_5 : NoMaxOrder α] [inst_6 : Nonempty α]\\n  [inst_7 : Encodable β] [inst_8 : DenselyOrdered β] [inst_9 : NoMinOrder β] [inst_10 : NoMaxOrder β]\\n  [inst_11 : Nonempty β], Nonempty (α ≃o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two countable dense, nonempty linear orders without endpoints are order isomorphic. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  ∃ f, Embedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A T₃ topological space with second countable topology can be embedded into `l^∞ = ℕ →ᵇ ℝ`. \"},\n {\"theorem\": \"MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the space `ℝ × ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformInducing f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform inducing map \"}]\n",
    "prompt_cons": "/-- A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners ℝ E H →\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\n  Measurable f → MeasureTheory.StronglyMeasurable f :=\n\n/-- *Urysohn's metrization theorem* (Tychonoff's version): a T₃ topological space with second\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\nsame topology. -/\ntheorem ∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  TopologicalSpace.MetrizableSpace X :=\n\n/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f :=\n\n/-- In a pseudo metric space with a conditionally complete linear order such that the order and the\nmetric structure give the same topology, any order-bounded set is metric-bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : Preorder α] [inst_2 : CompactIccSpace α] {s : Set α},\n  BddAbove s → BddBelow s → Metric.Bounded s :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Two metric space structures with the same distance coincide. -/\ntheorem ∀ {α : Type u_1} {m m' : MetricSpace α}, PseudoMetricSpace.toDist = PseudoMetricSpace.toDist → m = m' :=\n\n/-- Given an embedding of a topological space into a metrizable space, the source space is also\nmetrizable. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : TopologicalSpace.MetrizableSpace Y] {f : X → Y}, Embedding f → TopologicalSpace.MetrizableSpace X :=\n\n/-- In a space with second countable topology, measurable implies ae strongly measurable. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {f : α → β} {x : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} [inst_1 : MeasurableSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\n  Measurable f → MeasureTheory.AEStronglyMeasurable f μ :=\n\n/-- If a set is a right-neighborhood of all of its points, then it is measurable. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : LinearOrder α] [inst_4 : OrderTopology α] [inst_5 : TopologicalSpace.SecondCountableTopology α] {s : Set α},\n  (∀ (x : α), x ∈ s → s ∈ nhdsWithin x (Set.Ioi x)) → MeasurableSet s :=\n\n/-- Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.Bounded s ↔ EMetric.diam s ≠ ⊤ :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- The quotient of a second countable topological group by a subgroup is second countable. -/\ntheorem ∀ {G : Type w} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] {Γ : Subgroup G}\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G ⧸ Γ) :=\n\n/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem ∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- Any two countable dense, nonempty linear orders without endpoints are order isomorphic. -/\ntheorem ∀ (α : Type u_1) (β : Type u_2) [inst : LinearOrder α] [inst_1 : LinearOrder β] [inst_2 : Encodable α]\n  [inst_3 : DenselyOrdered α] [inst_4 : NoMinOrder α] [inst_5 : NoMaxOrder α] [inst_6 : Nonempty α]\n  [inst_7 : Encodable β] [inst_8 : DenselyOrdered β] [inst_9 : NoMinOrder β] [inst_10 : NoMaxOrder β]\n  [inst_11 : Nonempty β], Nonempty (α ≃o β) :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- A T₃ topological space with second countable topology can be embedded into `l^∞ = ℕ →ᵇ ℝ`. -/\ntheorem ∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  ∃ f, Embedding f :=\n\n/-- In the space `ℝ × ℝ`, the Hausdorff measure coincides exactly with the Lebesgue measure. -/\ntheorem MeasureTheory.Measure.hausdorffMeasure 2 = MeasureTheory.volume :=\n\n/-- An isometry from a metric space is a uniform inducing map -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformInducing f :=\n\n/-- Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable. -/\ntheorem",
    "choices": [
      "TopologicalSpace.MetrizableSpace (ℝ × ℝ) "
    ]
  },
  {
    "docString": "Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly.",
    "prompts": "[{\"theorem\":\n  \"∀ (f : CircleDeg1Lift) (x : ℝ),\\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : ℝ` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\\n  Monotone f → ∀ (n : ℕ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℕ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}\\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace 𝕜 E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\\n  {I' : ModelWithCorners 𝕜 E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M → M'} {x : M} {n : ℕ},\\n  ContMDiffAt I I' (↑n) f x ↔ ∀ᶠ (x' : M) in nhds x, ContMDiffAt I I' (↑n) f x'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: This does not hold for `n = ∞`. `f` being `C^∞` at `x` means that for every `n`, `f` is\\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\\n  Monotone f → ∀ (n : ℤ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℤ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\\n  (∀ (n : ℕ), Measurable (f n)) →\\n    (∀ (n : ℕ), f (Nat.succ n) ≤ᶠ[MeasureTheory.Measure.ae μ] f n) →\\n      ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤ → ∫⁻ (a : α), ⨅ (n : ℕ), f n a ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\\n  Antitone f → ∀ (n : ℕ) {x : α}, f (n + 1) < x → x < f n → ∀ (a : ℕ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an antitone function from `ℕ` to a preorder such that `x` lies between `f (n + 1)` and\\n`f n`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : ℕ → X → α},\\n  (LocallyFinite fun n => {x | f (n + 1) x ≠ f n x}) → ∃ F, ∀ (x : X), ∀ᶠ (n : ℕ) in Filter.atTop, f n =ᶠ[nhds x] F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℕ → α → β` be a sequence of functions on a topological space. Suppose\\nthat the family of sets `s n = {x | f (n + 1) x ≠ f n x}` is locally finite. Then there exists a\\nfunction `F :  α → β` such that for any `x`, for sufficiently large values of `n`, we have\\n`f n =ᶠ[𝓝 x] F`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\\n  Antitone f → ∀ (n : ℤ) {x : α}, f (n + 1) < x → x < f n → ∀ (a : ℤ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an antitone function from `ℤ` to a preorder and `x` lies between `f (n + 1)` and\\n`f n`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"∀ {f : ℕ → ℕ}, Function.Injective f → Filter.Tendsto f Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective sequence `f : ℕ → ℕ` tends to infinity at infinity. \"},\n {\"theorem\":\n  \"∀ (f : C(↑unitInterval, ℝ)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Bernstein approximations\\n```\\n∑ k : Fin (n+1), f (k/n : ℝ) * n.choose k * x^k * (1-x)^(n-k)\\n```\\nfor a continuous function `f : C([0,1], ℝ)` converge uniformly to `f` as `n` tends to infinity.\\n\\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], §7D,\\nand reproduced on wikipedia.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, Monotone f → x ≤ f x → Monotone fun n => f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone map and `x ≤ f x` at some point `x`, then the iterates `f^[n] x` form\\na monotone sequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, StrictMono f → x < f x → StrictMono fun n => f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a strictly monotone map and `x < f x` at some point `x`, then the iterates `f^[n] x`\\nform a strictly monotone sequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → Differentiable 𝕜 fun y => ∑' (n : α), f n y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If all functions in the series are differentiable\\nwith a summable bound on the derivatives, then the series is differentiable.\\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\\nconvergence then the series is zero everywhere so the result still holds. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {s : Set E} {x₀ : E},\\n  Summable u →\\n    IsOpen s →\\n      IsPreconnected s →\\n        (∀ (n : α) (x : E), x ∈ s → HasFDerivAt (f n) (f' n x) x) →\\n          (∀ (n : α) (x : E), x ∈ s → ‖f' n x‖ ≤ u n) →\\n            x₀ ∈ s → (Summable fun x => f x x₀) → ∀ {x : E}, x ∈ s → Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x` on a preconnected open set. If the series converges\\nat a point, and all functions in the series are differentiable with a summable bound on the\\nderivatives, then the series converges everywhere on the set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) →\\n        (Summable fun n => f n x₀) → ∀ (x : E), HasFDerivAt (fun y => ∑' (n : α), f n y) (∑' (n : α), f' n x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series is differentiable and its derivative is the sum of the derivatives. \"},\n {\"theorem\":\n  \"∀ {α : Type u_4} {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] [inst_5 : NormedSpace 𝕜 F]\\n  {f : α → E → F} {v : ℕ → α → ℝ} {N : ℕ∞},\\n  (∀ (i : α), ContDiff 𝕜 N (f i)) →\\n    (∀ (k : ℕ), ↑k ≤ N → Summable (v k)) →\\n      (∀ (k : ℕ) (i : α) (x : E), ↑k ≤ N → ‖iteratedFDeriv 𝕜 k (f i) x‖ ≤ v k i) →\\n        ContDiff 𝕜 N fun x => ∑' (i : α), f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' i, f i x`. Assume that each individual function `f i` is of\\nclass `C^N`, and moreover there is a uniform summable upper bound on the `k`-th derivative\\nfor each `k ≤ N`. Then the series is also `C^N`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"}]\n",
    "prompt_cons": "/-- For any `x : ℝ` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem ∀ (f : CircleDeg1Lift) (x : ℝ),\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\n  Monotone f → ∀ (n : ℕ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℕ), f a ≠ x :=\n\n/-- Note: This does not hold for `n = ∞`. `f` being `C^∞` at `x` means that for every `n`, `f` is\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace 𝕜 E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\n  {I' : ModelWithCorners 𝕜 E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M → M'} {x : M} {n : ℕ},\n  ContMDiffAt I I' (↑n) f x ↔ ∀ᶠ (x' : M) in nhds x, ContMDiffAt I I' (↑n) f x' :=\n\n/-- If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\n  Monotone f → ∀ (n : ℤ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℤ), f a ≠ x :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Consider a series of functions `∑' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\n  (∀ (n : ℕ), Measurable (f n)) →\n    (∀ (n : ℕ), f (Nat.succ n) ≤ᶠ[MeasureTheory.Measure.ae μ] f n) →\n      ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤ → ∫⁻ (a : α), ⨅ (n : ℕ), f n a ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ :=\n\n/-- If `f` is an antitone function from `ℕ` to a preorder such that `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\n  Antitone f → ∀ (n : ℕ) {x : α}, f (n + 1) < x → x < f n → ∀ (a : ℕ), f a ≠ x :=\n\n/-- Let `f : ℕ → α → β` be a sequence of functions on a topological space. Suppose\nthat the family of sets `s n = {x | f (n + 1) x ≠ f n x}` is locally finite. Then there exists a\nfunction `F :  α → β` such that for any `x`, for sufficiently large values of `n`, we have\n`f n =ᶠ[𝓝 x] F`. -/\ntheorem ∀ {α : Type u_2} {X : Type u_1} [inst : TopologicalSpace X] {f : ℕ → X → α},\n  (LocallyFinite fun n => {x | f (n + 1) x ≠ f n x}) → ∃ F, ∀ (x : X), ∀ᶠ (n : ℕ) in Filter.atTop, f n =ᶠ[nhds x] F :=\n\n/-- If `f` is an antitone function from `ℤ` to a preorder and `x` lies between `f (n + 1)` and\n`f n`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\n  Antitone f → ∀ (n : ℤ) {x : α}, f (n + 1) < x → x < f n → ∀ (a : ℤ), f a ≠ x :=\n\n/-- An injective sequence `f : ℕ → ℕ` tends to infinity at infinity. -/\ntheorem ∀ {f : ℕ → ℕ}, Function.Injective f → Filter.Tendsto f Filter.atTop Filter.atTop :=\n\n/-- The Bernstein approximations\n```\n∑ k : Fin (n+1), f (k/n : ℝ) * n.choose k * x^k * (1-x)^(n-k)\n```\nfor a continuous function `f : C([0,1], ℝ)` converge uniformly to `f` as `n` tends to infinity.\n\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], §7D,\nand reproduced on wikipedia. -/\ntheorem ∀ (f : C(↑unitInterval, ℝ)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f) :=\n\n/-- If `f` is a monotone map and `x ≤ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, Monotone f → x ≤ f x → Monotone fun n => f^[n] x :=\n\n/-- If `f` is a strictly monotone map and `x < f x` at some point `x`, then the iterates `f^[n] x`\nform a strictly monotone sequence. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, StrictMono f → x < f x → StrictMono fun n => f^[n] x :=\n\n/-- If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n] :=\n\n/-- Consider a series of functions `∑' n, f n x`. If all functions in the series are differentiable\nwith a summable bound on the derivatives, then the series is differentiable.\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\nconvergence then the series is zero everywhere so the result still holds. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → Differentiable 𝕜 fun y => ∑' (n : α), f n y :=\n\n/-- Consider a series of functions `∑' n, f n x` on a preconnected open set. If the series converges\nat a point, and all functions in the series are differentiable with a summable bound on the\nderivatives, then the series converges everywhere on the set. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_3} {E : Type u_2} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {s : Set E} {x₀ : E},\n  Summable u →\n    IsOpen s →\n      IsPreconnected s →\n        (∀ (n : α) (x : E), x ∈ s → HasFDerivAt (f n) (f' n x) x) →\n          (∀ (n : α) (x : E), x ∈ s → ‖f' n x‖ ≤ u n) →\n            x₀ ∈ s → (Summable fun x => f x x₀) → ∀ {x : E}, x ∈ s → Summable fun n => f n x :=\n\n/-- Consider a series of functions `∑' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series is differentiable and its derivative is the sum of the derivatives. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) →\n        (Summable fun n => f n x₀) → ∀ (x : E), HasFDerivAt (fun y => ∑' (n : α), f n y) (∑' (n : α), f' n x) x :=\n\n/-- Consider a series of functions `∑' i, f i x`. Assume that each individual function `f i` is of\nclass `C^N`, and moreover there is a uniform summable upper bound on the `k`-th derivative\nfor each `k ≤ N`. Then the series is also `C^N`. -/\ntheorem ∀ {α : Type u_4} {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] [inst_5 : NormedSpace 𝕜 F]\n  {f : α → E → F} {v : ℕ → α → ℝ} {N : ℕ∞},\n  (∀ (i : α), ContDiff 𝕜 N (f i)) →\n    (∀ (k : ℕ), ↑k ≤ N → Summable (v k)) →\n      (∀ (k : ℕ) (i : α) (x : E), ↑k ≤ N → ‖iteratedFDeriv 𝕜 k (f i) x‖ ≤ v k i) →\n        ContDiff 𝕜 N fun x => ∑' (i : α), f i x :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly. -/\ntheorem",
    "choices": [
      "∀ (f : ℕ → C(↑unitInterval, ℝ)), (∃ ε > 0, ∀ N, ∃ n ≥ N, ∃ x ∈ unitInterval, abs (f n x - x ^ n) > ε) "
    ]
  },
  {
    "docString": "Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\\nhomotopic to `ContinuousMap.pi f₁`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f : Con.Quotient c →* P),\\n  Con.lift c (MonoidHom.comp f (Con.mk' c)) (_ : ∀ (x y : M), ↑c x y → ↑f ↑x = ↑f ↑y) = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a homomorphism `f` from the quotient of a monoid by a congruence relation, `f` equals the\\nhomomorphism on the quotient induced by `f` composed with the natural map from the monoid to\\nthe quotient. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\\n  Continuous self.invFun\",\n  \"isProp\": true,\n  \"docString\": \"The inverse map of a homeomorphism is a continuous function. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β}\\n  {f : α → β}, Set.MapsTo f s t → Continuous f → Set.MapsTo f (closure s) (closure t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f g : Con.Quotient c →* P),\\n  (∀ (a : M), ↑f ↑a = ↑g ↑a) → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\\nare equal on elements that are coercions from the monoid. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β}\\n  {f : α → β}, Set.MapsTo f s t → Continuous f → IsClosed t → Set.MapsTo f (closure s) t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\\n  CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)\",\n  \"isProp\": true,\n  \"docString\": \"The map `p : P ⟶ image f` is an epimorphism \"},\n {\"theorem\": \"∀ {α : Type u_1} (r : Setoid α), Setoid.ker Quotient.mk'' = r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the quotient map induced by an equivalence relation r equals r. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, Continuous ↑f.linear ↔ Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is continuous iff `f` is continuous. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\\n  Function.Injective ↑(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant ν],\\n  MeasureTheory.MeasurePreserving fun z => (z.fst, z.snd / z.fst)\",\n  \"isProp\": true,\n  \"docString\": \"The map `(x, y) ↦ (x, y / x)` is measure-preserving. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : C → D}\\n  [self : CategoryTheory.Functorial F] (X : C),\\n  CategoryTheory.Functorial.map' (CategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id (F X)\",\n  \"isProp\": true,\n  \"docString\": \"A functorial map preserves identities. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {I : Ideal S} {f : R →+* S},\\n  Function.Injective ↑(Ideal.quotientMap I f (_ : Ideal.comap f I ≤ Ideal.comap f I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If we take `J = I.comap f` then `QuotientMap` is injective automatically. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\nhomotopic to `ContinuousMap.pi f₁`. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁) :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Given a homomorphism `f` from the quotient of a monoid by a congruence relation, `f` equals the\nhomomorphism on the quotient induced by `f` composed with the natural map from the monoid to\nthe quotient. -/\ntheorem ∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f : Con.Quotient c →* P),\n  Con.lift c (MonoidHom.comp f (Con.mk' c)) (_ : ∀ (x y : M), ↑c x y → ↑f ↑x = ↑f ↑y) = f :=\n\n/-- The inverse map of a homeomorphism is a continuous function. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\n  Continuous self.invFun :=\n\n/-- If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f) :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem ∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c) :=\n\n/-- If a continuous map `f` maps `s` to `t`, then it maps `closure s` to `closure t`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β}\n  {f : α → β}, Set.MapsTo f s t → Continuous f → Set.MapsTo f (closure s) (closure t) :=\n\n/-- Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\nare equal on elements that are coercions from the monoid. -/\ntheorem ∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f g : Con.Quotient c →* P),\n  (∀ (a : M), ↑f ↑a = ↑g ↑a) → f = g :=\n\n/-- If a continuous map `f` maps `s` to a closed set `t`, then it maps `closure s` to `t`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β}\n  {f : α → β}, Set.MapsTo f s t → Continuous f → IsClosed t → Set.MapsTo f (closure s) t :=\n\n/-- The map `p : P ⟶ image f` is an epimorphism -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\n  CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f) :=\n\n/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\ntheorem ∀ {α : Type u_1} (r : Setoid α), Setoid.ker Quotient.mk'' = r :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- If `f` is an affine map, then its linear part is continuous iff `f` is continuous. -/\ntheorem ∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, Continuous ↑f.linear ↔ Continuous ↑f :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem ∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\n  Function.Injective ↑(Con.kerLift f) :=\n\n/-- The map `(x, y) ↦ (x, y / x)` is measure-preserving. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant ν],\n  MeasureTheory.MeasurePreserving fun z => (z.fst, z.snd / z.fst) :=\n\n/-- A functorial map preserves identities. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D] {F : C → D}\n  [self : CategoryTheory.Functorial F] (X : C),\n  CategoryTheory.Functorial.map' (CategoryTheory.CategoryStruct.id X) = CategoryTheory.CategoryStruct.id (F X) :=\n\n/-- If we take `J = I.comap f` then `QuotientMap` is injective automatically. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {I : Ideal S} {f : R →+* S},\n  Function.Injective ↑(Ideal.quotientMap I f (_ : Ideal.comap f I ≤ Ideal.comap f I)) :=\n\n/-- Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y} {f : Y → X},\n  Continuous p → Continuous f → (p ∘ f = id) → QuotientMap p "
    ]
  },
  {
    "docString": "Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : ContinuousConstSMul Γ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group action is an open\\nquotient. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\\n  [inst_3 : ContinuousConstVAdd Γ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group\\naction is an open quotient. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, IsOpenMap ↑f.linear ↔ IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E →L[𝕜] F)\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective ↑f → IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\\nopen. \"},\n {\"theorem\": \"∀ {X Y : Profinite} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of profinite spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : FiniteDimensional 𝕜 E]\\n  (f : F →ₗ[𝕜] E), Function.Surjective ↑f → IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A surjective linear map `f` with finite dimensional codomain is an open map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace E] {f : E → F} {f' : E → E ≃L[𝕜] F},\\n  (∀ (x : E), HasStrictFDerivAt f (↑(f' x)) x) → IsOpenMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has an invertible strict derivative at all points, then it is an open map. \"},\n {\"theorem\":\n  \"∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P →\\n    ∀ {X Y : AlgebraicGeometry.Scheme} (f : X ⟶ Y) (𝒰 : AlgebraicGeometry.Scheme.OpenCover Y),\\n      (∀ (i : 𝒰.J), P CategoryTheory.Limits.pullback.snd) → P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` holds for `f ∣_ U` for an open cover `U` of `Y`, then `P` holds for `f`.  \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {X Y : AlgebraicGeometry.Scheme} {f : X ⟶ Y} [self : AlgebraicGeometry.QuasiCompact f]\\n  (U : Set ↑↑Y.toPresheafedSpace), IsOpen U → IsCompact U → IsCompact (↑f.val.base ⁻¹' U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Preimage of compact open set under a quasi-compact morphism between schemes is compact. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\\n  CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)\",\n  \"isProp\": true,\n  \"docString\": \"The map `p : P ⟶ image f` is an epimorphism \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S},\\n  OpenEmbedding ↑f →\\n    OpenEmbedding ↑g →\\n      OpenEmbedding\\n        ↑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X ⟶ S`, `Y ⟶ S` are open embeddings, then so is `X ×ₛ Y ⟶ S`. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E →L[𝕜] F)\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E],\\n  Function.Surjective ↑f → ∃ C, C > 0 ∧ ∀ (y : F), ∃ x, ↑f x = y ∧ ‖x‖ ≤ C * ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Banach open mapping theorem: if a bounded linear map between Banach spaces is onto, then\\nany point has a preimage with controlled norm. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u} {V' : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V]\\n  [inst_2 : AddCommGroup V'] [inst_3 : Module K V] [inst_4 : Module K V'] {p : Submodule K V}\\n  (f : { x // x ∈ p } →ₗ[K] V'), ∃ g, LinearMap.comp g (Submodule.subtype p) = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any linear map `f : p →ₗ[K] V'` defined on a subspace `p` can be extended to the whole\\nspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {f f' : 𝕜 → 𝕜},\\n  (∀ (x : 𝕜), HasStrictDerivAt f (f' x) x) → (∀ (x : 𝕜), f' x ≠ 0) → IsOpenMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a non-zero strict derivative at all points, then it is an open map. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. -/\ntheorem ∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\n  [inst_3 : ContinuousConstSMul Γ T], IsOpenMap Quotient.mk' :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. -/\ntheorem ∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\n  [inst_3 : ContinuousConstVAdd Γ T], IsOpenMap Quotient.mk' :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem ∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, IsOpenMap ↑f.linear ↔ IsOpenMap ↑f :=\n\n/-- The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\nopen. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E →L[𝕜] F)\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective ↑f → IsOpenMap ↑f :=\n\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem ∀ {X Y : Profinite} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : FiniteDimensional 𝕜 E]\n  (f : F →ₗ[𝕜] E), Function.Surjective ↑f → IsOpenMap ↑f :=\n\n/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace E] {f : E → F} {f' : E → E ≃L[𝕜] F},\n  (∀ (x : E), HasStrictFDerivAt f (↑(f' x)) x) → IsOpenMap f :=\n\n/-- If `P` holds for `f ∣_ U` for an open cover `U` of `Y`, then `P` holds for `f`. -/\ntheorem ∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P →\n    ∀ {X Y : AlgebraicGeometry.Scheme} (f : X ⟶ Y) (𝒰 : AlgebraicGeometry.Scheme.OpenCover Y),\n      (∀ (i : 𝒰.J), P CategoryTheory.Limits.pullback.snd) → P f :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Preimage of compact open set under a quasi-compact morphism between schemes is compact. -/\ntheorem ∀ {X Y : AlgebraicGeometry.Scheme} {f : X ⟶ Y} [self : AlgebraicGeometry.QuasiCompact f]\n  (U : Set ↑↑Y.toPresheafedSpace), IsOpen U → IsCompact U → IsCompact (↑f.val.base ⁻¹' U) :=\n\n/-- The map `p : P ⟶ image f` is an epimorphism -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C] {P Q : C} (f : P ⟶ Q),\n  CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- If `X ⟶ S`, `Y ⟶ S` are open embeddings, then so is `X ×ₛ Y ⟶ S`. -/\ntheorem ∀ {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S},\n  OpenEmbedding ↑f →\n    OpenEmbedding ↑g →\n      OpenEmbedding\n        ↑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- The Banach open mapping theorem: if a bounded linear map between Banach spaces is onto, then\nany point has a preimage with controlled norm. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E →L[𝕜] F)\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E],\n  Function.Surjective ↑f → ∃ C, C > 0 ∧ ∀ (y : F), ∃ x, ↑f x = y ∧ ‖x‖ ≤ C * ‖y‖ :=\n\n/-- Any linear map `f : p →ₗ[K] V'` defined on a subspace `p` can be extended to the whole\nspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u} {V' : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V]\n  [inst_2 : AddCommGroup V'] [inst_3 : Module K V] [inst_4 : Module K V'] {p : Submodule K V}\n  (f : { x // x ∈ p } →ₗ[K] V'), ∃ g, LinearMap.comp g (Submodule.subtype p) = f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {f f' : 𝕜 → 𝕜},\n  (∀ (x : 𝕜), HasStrictDerivAt f (f' x) x) → (∀ (x : 𝕜), f' x ≠ 0) → IsOpenMap f :=\n\n/-- Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {p : X → Y} {A : Set X},\n  IsOpenMap p → IsOpen A → IsOpenMap (Set.restrict p A) "
    ]
  },
  {
    "docString": "Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) →\\n    Pairwise (Disjoint on s) →\\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning α are disjoint. \"},\n {\"theorem\":\n  \"∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\\n  (s : ι → Set (ℙ K V)),\\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) → Pairwise (Disjoint on s) → (∀ (i : ι), IsClopen (s i)) → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) →\\n    Pairwise (Disjoint on s) → (∀ (i : ι), IsOpen (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any disjoint cover by non-empty open subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] (b : ι → Set α),\\n  TopologicalSpace.IsTopologicalBasis (Set.range b) →\\n    (∀ (i : ι), IsCompact (b i)) →\\n      ∀ (U : Set α), IsCompact U ∧ IsOpen U ↔ ∃ s, Set.Finite s ∧ U = ⋃ (i : ι) (_ : i ∈ s), b i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has a basis consisting of compact opens, then an open set in `α` is compact open iff\\nit is a finite union of some elements in the basis \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\\n  TopologicalSpace.IsTopologicalBasis s →\\n    ∀ {t : Set (Set β)},\\n      TopologicalSpace.IsTopologicalBasis t →\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) →\n    Pairwise (Disjoint on s) →\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι :=\n\n/-- Distinct elements of a set of sets partitioning α are disjoint. -/\ntheorem ∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem ∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Set (ℙ K V)),\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- In a preconnected space, any disjoint family of non-empty clopen subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) → Pairwise (Disjoint on s) → (∀ (i : ι), IsClopen (s i)) → Subsingleton ι :=\n\n/-- In a preconnected space, any disjoint cover by non-empty open subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) →\n    Pairwise (Disjoint on s) → (∀ (i : ι), IsOpen (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- A nonempty convex set is connected. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → Set.Nonempty s → IsConnected s :=\n\n/-- If `α` has a basis consisting of compact opens, then an open set in `α` is compact open iff\nit is a finite union of some elements in the basis -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] (b : ι → Set α),\n  TopologicalSpace.IsTopologicalBasis (Set.range b) →\n    (∀ (i : ι), IsCompact (b i)) →\n      ∀ (U : Set α), IsCompact U ∧ IsOpen U ↔ ∃ s, Set.Finite s ∧ U = ⋃ (i : ι) (_ : i ∈ s), b i :=\n\n/-- In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem ∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s →\n    ∀ {t : Set (Set β)},\n      TopologicalSpace.IsTopologicalBasis t →\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S) :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {ι : Type v} [inst : TopologicalSpace α] {A : Set α} {C : ι → Set α},\n  IsConnected A →\n    (∀ (i : ι), IsConnected (C i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ C i)) → IsConnected (A ∪ ⋃ (i : ι), C i) "
    ]
  },
  {
    "docString": "Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] {A B : Set E},\\n  IsExposed 𝕜 A B → Set.Nonempty B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\\ndoesn't intersect `A`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] [inst_5 : Nontrivial 𝕜] {A B : Set E},\\n  IsExposed 𝕜 A B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nontrivial `𝕜`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\\nhalfspace doesn't intersect `A`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {s₁ s₂ : Set E}, s₁ ⊆ s₂ → Bornology.IsVonNBounded 𝕜 s₂ → Bornology.IsVonNBounded 𝕜 s₁\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of bounded sets are bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, s ⊆ t → Metric.Bounded t → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a bounded set are also bounded \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {s t : Set α},\\n  IsGδ s → IsGδ t → Dense s → Dense t → Dense (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: the intersection of two dense Gδ sets is dense. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"}]\n",
    "prompt_cons": "/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] {A B : Set E},\n  IsExposed 𝕜 A B → Set.Nonempty B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x} :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- For nontrivial `𝕜`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\nhalfspace doesn't intersect `A`. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] [inst_5 : Nontrivial 𝕜] {A B : Set E},\n  IsExposed 𝕜 A B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x} :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- Subsets of bounded sets are bounded. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {s₁ s₂ : Set E}, s₁ ⊆ s₂ → Bornology.IsVonNBounded 𝕜 s₂ → Bornology.IsVonNBounded 𝕜 s₁ :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, s ⊆ t → Metric.Bounded t → Metric.Bounded s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2 :=\n\n/-- Baire theorem: the intersection of two dense Gδ sets is dense. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {s t : Set α},\n  IsGδ s → IsGδ t → Dense s → Dense t → Dense (s ∩ t) :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- Affine subspaces are convex. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V) :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] {A C : Set α},\n  IsConnected C → Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (HasCompl.compl A)) → Set.Nonempty (C ∩ Frontier A) "
    ]
  },
  {
    "docString": "Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any two points of a set are contained in a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\\nhomotopic to `ContinuousMap.pi f₁`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (U : Set α),\\n  ConnectedComponents.mk ⁻¹' (ConnectedComponents.mk '' U) = ⋃ (x : α) (_ : x ∈ U), connectedComponent x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of the image of a set under the quotient map to `connectedComponents α`\\nis the union of the connected components of the elements in it. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [i : LocallyConnectedSpace β],\\n  α ≃ₜ β → LocallyConnectedSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  (∀ (t : β), IsConnected (f ⁻¹' {t})) →\\n    (∀ (T : Set β), IsClosed T ↔ IsClosed (f ⁻¹' T)) → ∀ (t : β), IsConnected (f ⁻¹' connectedComponent t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a connected component is preconnected if the function has connected fibers\\nand a subset is closed iff the preimage is. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {f : β → α} [inst_1 : TopologicalSpace β],\\n  Inducing f → ∀ {s : Set α}, TopologicalSpace.IsSeparable s → TopologicalSpace.IsSeparable (f ⁻¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a separable set by an inducing map is separable. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulRightInvariant ν],\\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.fst⁻¹)\",\n  \"isProp\": true,\n  \"docString\": \"The map `(x, y) ↦ (xy, x⁻¹)` is measure-preserving. \"},\n {\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (r : J → J → Prop),\\n  Equivalence r → (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂) → ∀ (j₁ j₂ : J), r j₁ j₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any equivalence relation containing (⟶) holds for all pairs of a connected category. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α},\\n  IsConnected s → ∀ (f : α → β), ContinuousOn f s → IsConnected (f '' s)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a connected set is connected as well. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} (x : α),\\n  (∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any point of a set is joined to a fixed point by a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {X Y Z : AlgebraicGeometry.Scheme} (𝒰 : AlgebraicGeometry.Scheme.OpenCover X) (f : X ⟶ Z) (g : Y ⟶ Z)\\n  [inst :\\n    ∀ (i : 𝒰.J),\\n      CategoryTheory.Limits.HasPullback\\n        (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.map 𝒰 i) f) g]\\n  (i : 𝒰.J),\\n  CategoryTheory.CategoryStruct.comp\\n      (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.snd\\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\\n          (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g))\\n        (_ :\\n          CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\\n              (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.map 𝒰 i) f) =\\n            CategoryTheory.CategoryStruct.comp\\n              (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\\n                (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g))\\n              g))\\n      (AlgebraicGeometry.Scheme.GlueData.ι (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g) i) =\\n    CategoryTheory.Limits.pullback.fst\",\n  \"isProp\": true,\n  \"docString\":\n  \"We show that the map `W ×[X] Uᵢ ⟶ Uᵢ ×[Z] Y ⟶ W` is the first projection, where the\\nfirst map is given by the lift of `W ×[X] Uᵢ ⟶ Uᵢ` and `W ×[X] Uᵢ ⟶ W ⟶ Y`.\\n\\nIt suffices to show that the two map agrees when restricted onto `Uⱼ ×[Z] Y`. In this case,\\nboth maps factor through `V j i` via `pullback_fst_ι_to_V` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s :=\n\n/-- If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\nhomotopic to `ContinuousMap.pi f₁`. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁) :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S) :=\n\n/-- The preimage of the image of a set under the quotient map to `connectedComponents α`\nis the union of the connected components of the elements in it. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (U : Set α),\n  ConnectedComponents.mk ⁻¹' (ConnectedComponents.mk '' U) = ⋃ (x : α) (_ : x ∈ U), connectedComponent x :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [i : LocallyConnectedSpace β],\n  α ≃ₜ β → LocallyConnectedSpace α :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s) :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- The preimage of a connected component is preconnected if the function has connected fibers\nand a subset is closed iff the preimage is. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  (∀ (t : β), IsConnected (f ⁻¹' {t})) →\n    (∀ (T : Set β), IsClosed T ↔ IsClosed (f ⁻¹' T)) → ∀ (t : β), IsConnected (f ⁻¹' connectedComponent t) :=\n\n/-- The preimage of a separable set by an inducing map is separable. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {f : β → α} [inst_1 : TopologicalSpace β],\n  Inducing f → ∀ {s : Set α}, TopologicalSpace.IsSeparable s → TopologicalSpace.IsSeparable (f ⁻¹' s) :=\n\n/-- The map `(x, y) ↦ (xy, x⁻¹)` is measure-preserving. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsMulRightInvariant ν],\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.fst⁻¹) :=\n\n/-- Any equivalence relation containing (⟶) holds for all pairs of a connected category. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] [inst_1 : CategoryTheory.IsConnected J] (r : J → J → Prop),\n  Equivalence r → (∀ {j₁ j₂ : J}, (j₁ ⟶ j₂) → r j₁ j₂) → ∀ (j₁ j₂ : J), r j₁ j₂ :=\n\n/-- The image of a connected set is connected as well. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α},\n  IsConnected s → ∀ (f : α → β), ContinuousOn f s → IsConnected (f '' s) :=\n\n/-- If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} (x : α),\n  (∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- We show that the map `W ×[X] Uᵢ ⟶ Uᵢ ×[Z] Y ⟶ W` is the first projection, where the\nfirst map is given by the lift of `W ×[X] Uᵢ ⟶ Uᵢ` and `W ×[X] Uᵢ ⟶ W ⟶ Y`.\n\nIt suffices to show that the two map agrees when restricted onto `Uⱼ ×[Z] Y`. In this case,\nboth maps factor through `V j i` via `pullback_fst_ι_to_V` -/\ntheorem ∀ {X Y Z : AlgebraicGeometry.Scheme} (𝒰 : AlgebraicGeometry.Scheme.OpenCover X) (f : X ⟶ Z) (g : Y ⟶ Z)\n  [inst :\n    ∀ (i : 𝒰.J),\n      CategoryTheory.Limits.HasPullback\n        (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.map 𝒰 i) f) g]\n  (i : 𝒰.J),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.Limits.pullback.lift CategoryTheory.Limits.pullback.snd\n        (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\n          (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g))\n        (_ :\n          CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.snd\n              (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.OpenCover.map 𝒰 i) f) =\n            CategoryTheory.CategoryStruct.comp\n              (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.pullback.fst\n                (AlgebraicGeometry.Scheme.Pullback.p2 𝒰 f g))\n              g))\n      (AlgebraicGeometry.Scheme.GlueData.ι (AlgebraicGeometry.Scheme.Pullback.gluing 𝒰 f g) i) =\n    CategoryTheory.Limits.pullback.fst :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  QuotientMap f → (∀ (y : β), IsConnected (f ⁻¹' {y})) → IsConnected β → IsConnected α "
    ]
  },
  {
    "docString": "Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.)",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] {x : α}, Continuous fun f => ↑f x\",\n  \"isProp\": true,\n  \"docString\": \"When `x` is fixed, `(f : α →ᵇ β) ↦ f x` is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α} {x y : α},\\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) → ContinuousAt f y → Function.IsFixedPt f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\\nthen `y` is a fixed point for `f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsFixedPt f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt (f ∘ g) x → Function.IsFixedPt g x → Function.IsFixedPt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + τ f`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] [inst_1 : DecidableEq ι] (i : ι),\\n  Continuous fun f => Function.update f.fst i f.snd\",\n  \"isProp\": true,\n  \"docString\": \"`Function.update f i x` is continuous in `(f, x)`. \"},\n {\"theorem\":\n  \"∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"∀ {f : Ordinal.{u} → Ordinal.{u}}, Ordinal.IsNormal f → Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The fixed point lemma for normal functions: any normal function has an unbounded set of\\nfixed points. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.IsFixedPt g x → Function.IsFixedPt (f ∘ g) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f ≥ 1` on K. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α}\\n  {x₀ : X}, EquicontinuousAt F x₀ → ∀ (i : ι), ContinuousAt (F i) x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a family equicontinuous at `x₀` is continuous at `x₀`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {l : Filter ι}\\n  [inst_2 : Filter.NeBot l] {F : ι → X → α} {f : X → α} {x₀ : X},\\n  Filter.Tendsto F l (nhds f) → EquicontinuousAt F x₀ → ContinuousAt f x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝓕 : ι → X → α` tends to `f : X → α` *pointwise* along some nontrivial filter, and if the\\nfamily `𝓕` is equicontinuous at some `x₀ : X`, then the limit is continuous at `x₀`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β} {x : α} {r : ℝ},\\n  0 < r → ∀ (K : ℝ), (∀ (y : α), dist y x < r → dist (f y) (f x) ≤ K * dist y x) → ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is locally Lipschitz around a point, then it is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (β : Type u_2) [inst : UniformSpace β] (x : α), UniformContinuous (Function.eval x ∘ ↑UniformFun.toFun)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Evaluation at a fixed point is uniformly continuous on `α →ᵤ β`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\\n  [inst_3 : Module ℝ E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  0 ∈ s → Convex ℝ s → IsOpen s → ∀ {x₀ : E}, ¬x₀ ∈ s → ∃ f, ↑f x₀ = 1 ∧ ∀ (x : E), x ∈ s → ↑f x < 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a set `s` which is a convex neighbourhood of `0` and a point `x₀` outside of it, there is\\na continuous linear functional `f` separating `x₀` and `s`, in the sense that it sends `x₀` to 1 and\\nall of `s` to values strictly below `1`. \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_1} [inst : Zero G₀] [inst_1 : Inv G₀] [inst_2 : TopologicalSpace G₀] [self : HasContinuousInv₀ G₀]\\n  ⦃x : G₀⦄, x ≠ 0 → ContinuousAt Inv.inv x\",\n  \"isProp\": true,\n  \"docString\": \"The map `fun x ↦ x⁻¹` is continuous at all nonzero points. \"}]\n",
    "prompt_cons": "/-- When `x` is fixed, `(f : α →ᵇ β) ↦ f x` is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] {x : α}, Continuous fun f => ↑f x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\nthen `y` is a fixed point for `f`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α} {x y : α},\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) → ContinuousAt f y → Function.IsFixedPt f y :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem ∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x :=\n\n/-- If `x` is a fixed point of `f`, then it is a fixed point of `f^[n]`. -/\ntheorem ∀ {α : Type u} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsFixedPt f^[n] x :=\n\n/-- If `x` is a fixed point of `f ∘ g` and `g`, then it is a fixed point of `f`. -/\ntheorem ∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt (f ∘ g) x → Function.IsFixedPt g x → Function.IsFixedPt f x :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem ∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- `Function.update f i x` is continuous in `(f, x)`. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] [inst_1 : DecidableEq ι] (i : ι),\n  Continuous fun f => Function.update f.fst i f.snd :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem ∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c :=\n\n/-- The fixed point lemma for normal functions: any normal function has an unbounded set of\nfixed points. -/\ntheorem ∀ {f : Ordinal.{u} → Ordinal.{u}}, Ordinal.IsNormal f → Set.Unbounded (fun x x_1 => x < x_1) (Function.fixedPoints f) :=\n\n/-- If `x` is a fixed point of `f` and `g`, then it is a fixed point of `f ∘ g`. -/\ntheorem ∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.IsFixedPt g x → Function.IsFixedPt (f ∘ g) x :=\n\n/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f ≥ 1` on K. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x}) :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousAt f x :=\n\n/-- Each function of a family equicontinuous at `x₀` is continuous at `x₀`. -/\ntheorem ∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α}\n  {x₀ : X}, EquicontinuousAt F x₀ → ∀ (i : ι), ContinuousAt (F i) x₀ :=\n\n/-- If `𝓕 : ι → X → α` tends to `f : X → α` *pointwise* along some nontrivial filter, and if the\nfamily `𝓕` is equicontinuous at some `x₀ : X`, then the limit is continuous at `x₀`. -/\ntheorem ∀ {ι : Type u_1} {X : Type u_2} {α : Type u_3} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {l : Filter ι}\n  [inst_2 : Filter.NeBot l] {F : ι → X → α} {f : X → α} {x₀ : X},\n  Filter.Tendsto F l (nhds f) → EquicontinuousAt F x₀ → ContinuousAt f x₀ :=\n\n/-- If a function is locally Lipschitz around a point, then it is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β} {x : α} {r : ℝ},\n  0 < r → ∀ (K : ℝ), (∀ (y : α), dist y x < r → dist (f y) (f x) ≤ K * dist y x) → ContinuousAt f x :=\n\n/-- Evaluation at a fixed point is uniformly continuous on `α →ᵤ β`. -/\ntheorem ∀ {α : Type u_1} (β : Type u_2) [inst : UniformSpace β] (x : α), UniformContinuous (Function.eval x ∘ ↑UniformFun.toFun) :=\n\n/-- Given a set `s` which is a convex neighbourhood of `0` and a point `x₀` outside of it, there is\na continuous linear functional `f` separating `x₀` and `s`, in the sense that it sends `x₀` to 1 and\nall of `s` to values strictly below `1`. -/\ntheorem ∀ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\n  [inst_3 : Module ℝ E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  0 ∈ s → Convex ℝ s → IsOpen s → ∀ {x₀ : E}, ¬x₀ ∈ s → ∃ f, ↑f x₀ = 1 ∧ ∀ (x : E), x ∈ s → ↑f x < 1 :=\n\n/-- The map `fun x ↦ x⁻¹` is continuous at all nonzero points. -/\ntheorem ∀ {G₀ : Type u_1} [inst : Zero G₀] [inst_1 : Inv G₀] [inst_2 : TopologicalSpace G₀] [self : HasContinuousInv₀ G₀]\n  ⦃x : G₀⦄, x ≠ 0 → ContinuousAt Inv.inv x :=\n\n/-- Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.) -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LinearOrder X] [inst_2 : OrderClosedTopology X] {f : X → X},\n  Continuous f → X = Set.Icc (0 : X) 1 → ∃ x, f x = x "
    ]
  },
  {
    "docString": "Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological group `G` with normal subgroup `N`, `1 : G ⧸ N` has a\\ncountable neighborhood basis. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological additive group `G` with normal additive subgroup\\n`N`, `0 : G ⧸ N` has a countable neighborhood basis.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"∀ (n : ℕ∞) {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners 𝕜 E H),\\n  ClosedUnderRestriction (contDiffGroupoid n I)\",\n  \"isProp\": true,\n  \"docString\": \"The `C^n` groupoid is closed under restriction. \"},\n {\"theorem\":\n  \"∀ (n : ℕ∞) {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_1} [inst_3 : TopologicalSpace H] (I : ModelWithCorners 𝕜 E H) {s : Set H}\\n  (hs : IsOpen s), LocalHomeomorph.ofSet s hs ∈ contDiffGroupoid n I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An identity local homeomorphism belongs to the `C^n` groupoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of `s` is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `⊥` or `⊤` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G →* H),\\n  OpenEmbedding ↑f → NonarchimedeanGroup H\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\\n  [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Γ : Subgroup G} [inst_5 : MeasurableSpace (G ⧸ Γ)]\\n  [inst_6 : BorelSpace (G ⧸ Γ)], MeasurableSMul G (G ⧸ Γ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Measurability of the action of the topological group `G` on the left-coset space `G/Γ`. \"},\n {\"theorem\":\n  \"∀ {C : Type u_3} [inst : CategoryTheory.Category C] {D : Type u_4} [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\\n  CategoryTheory.CoverPreserving (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G\",\n  \"isProp\": true,\n  \"docString\": \"`G` is cover-preserving wrt the induced topology. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] (H : Subgroup G),\\n  1 ∈ interior ↑H → IsOpen ↑H\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a subgroup of a topological group has `1` in its interior, then it is open. \"}]\n",
    "prompt_cons": "/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- In a first countable topological group `G` with normal subgroup `N`, `1 : G ⧸ N` has a\ncountable neighborhood basis. -/\ntheorem ∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- In a first countable topological additive group `G` with normal additive subgroup\n`N`, `0 : G ⧸ N` has a countable neighborhood basis. -/\ntheorem ∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1 :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t :=\n\n/-- The `C^n` groupoid is closed under restriction. -/\ntheorem ∀ (n : ℕ∞) {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners 𝕜 E H),\n  ClosedUnderRestriction (contDiffGroupoid n I) :=\n\n/-- An identity local homeomorphism belongs to the `C^n` groupoid. -/\ntheorem ∀ (n : ℕ∞) {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_1} [inst_3 : TopologicalSpace H] (I : ModelWithCorners 𝕜 E H) {s : Set H}\n  (hs : IsOpen s), LocalHomeomorph.ofSet s hs ∈ contDiffGroupoid n I :=\n\n/-- The normal closure of `s` is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s) :=\n\n/-- Any normal subgroup is either `⊥` or `⊤` -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤ :=\n\n/-- If a topological group embeds into a nonarchimedean group, then it is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {H : Type u_2}\n  [inst_3 : Group H] [inst_4 : TopologicalSpace H] [inst_5 : TopologicalGroup H] (f : G →* H),\n  OpenEmbedding ↑f → NonarchimedeanGroup H :=\n\n/-- Measurability of the action of the topological group `G` on the left-coset space `G/Γ`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\n  [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Γ : Subgroup G} [inst_5 : MeasurableSpace (G ⧸ Γ)]\n  [inst_6 : BorelSpace (G ⧸ Γ)], MeasurableSMul G (G ⧸ Γ) :=\n\n/-- `G` is cover-preserving wrt the induced topology. -/\ntheorem ∀ {C : Type u_3} [inst : CategoryTheory.Category C] {D : Type u_4} [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\n  CategoryTheory.CoverPreserving (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G :=\n\n/-- If a subgroup of a topological group has `1` in its interior, then it is open. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] (H : Subgroup G),\n  1 ∈ interior ↑H → IsOpen ↑H :=\n\n/-- Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) "
    ]
  },
  {
    "docString": "Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact.",
    "prompts": "[{\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\": \"∀ {X Y : Profinite} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of profinite spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  ClosedEmbedding f → ∀ {K : Set β}, IsCompact K → IsCompact (f ⁻¹' K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a compact set under a closed embedding is a compact set. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\": \"∀ {X Y : Compactum} (f : X ⟶ Y), Continuous f.f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of compacta is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β]\\n  (f : CocompactMap α β) ⦃s : Set β⦄, IsCompact s → IsCompact (↑f ⁻¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain is Hausdorff, preimages of compact sets are compact under a cocompact\\ncontinuous map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → Function.Injective f → ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y} {s : Set Y},\\n  IsSeqClosed s → SeqContinuous f → IsSeqClosed (f ⁻¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a sequentially closed set under a sequentially continuous map is sequentially\\nclosed. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\\n  Continuous self.invFun\",\n  \"isProp\": true,\n  \"docString\": \"The inverse map of a homeomorphism is a continuous function. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : FiniteDimensional 𝕜 E]\\n  (f : F →ₗ[𝕜] E), Function.Surjective ↑f → IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A surjective linear map `f` with finite dimensional codomain is an open map. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"}]\n",
    "prompt_cons": "/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem ∀ {X Y : Profinite} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- The preimage of a compact set under a closed embedding is a compact set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  ClosedEmbedding f → ∀ {K : Set β}, IsCompact K → IsCompact (f ⁻¹' K) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Any morphism of compacta is continuous. -/\ntheorem ∀ {X Y : Compactum} (f : X ⟶ Y), Continuous f.f :=\n\n/-- If the codomain is Hausdorff, preimages of compact sets are compact under a cocompact\ncontinuous map. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β]\n  (f : CocompactMap α β) ⦃s : Set β⦄, IsCompact s → IsCompact (↑f ⁻¹' s) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- A continuous injective map from a compact space to a Hausdorff space is a closed embedding. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → Function.Injective f → ClosedEmbedding f :=\n\n/-- The preimage of a sequentially closed set under a sequentially continuous map is sequentially\nclosed. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y} {s : Set Y},\n  IsSeqClosed s → SeqContinuous f → IsSeqClosed (f ⁻¹' s) :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- The inverse map of a homeomorphism is a continuous function. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\n  Continuous self.invFun :=\n\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : FiniteDimensional 𝕜 E]\n  (f : F →ₗ[𝕜] E), Function.Surjective ↑f → IsOpenMap ↑f :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  Continuous f → Function.Surjective f → (∀ y : β, IsCompact (f ⁻¹' {y})) → IsClosedMap f →\n  CompactSpace β → CompactSpace α "
    ]
  },
  {
    "docString": "A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X], T1Space (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a `T1Space` space is a `T1Space`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"},\n {\"theorem\":\n  \"∀ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (α : Type v) (s : α → Set X),\\n  (∀ (a : α), IsOpen (s a)) → ⋃ (a : α), s a = Set.univ → ∃ β t x x, LocallyFinite t ∧ ∀ (b : β), ∃ a, t b ⊆ s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {ι : Type u} {X : Type v} [inst : TopologicalSpace X] [inst_1 : ParacompactSpace X] {s : Set X},\\n  IsClosed s →\\n    ∀ (u : ι → Set X),\\n      (∀ (i : ι), IsOpen (u i)) →\\n        s ⊆ ⋃ (i : ι), u i →\\n          ∃ v, (∀ (i : ι), IsOpen (v i)) ∧ s ⊆ ⋃ (i : ι), v i ∧ LocallyFinite v ∧ ∀ (i : ι), v i ⊆ u i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a paracompact space, every open covering of a closed set admits a locally finite refinement\\nindexed by the same type. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {x : α} {U : Set α},\\n  IsOpen U → x ∈ U → ∃ K, IsCompact K ∧ x ∈ interior K ∧ K ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"}]\n",
    "prompt_cons": "/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U) :=\n\n/-- A compact discrete space is finite. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α :=\n\n/-- The one point compactification of a `T1Space` space is a `T1Space`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X], T1Space (OnePoint X) :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i) :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem ∀ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (α : Type v) (s : α → Set X),\n  (∀ (a : α), IsOpen (s a)) → ⋃ (a : α), s a = Set.univ → ∃ β t x x, LocallyFinite t ∧ ∀ (b : β), ∃ a, t b ⊆ s a :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V) :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- In a paracompact space, every open covering of a closed set admits a locally finite refinement\nindexed by the same type. -/\ntheorem ∀ {ι : Type u} {X : Type v} [inst : TopologicalSpace X] [inst_1 : ParacompactSpace X] {s : Set X},\n  IsClosed s →\n    ∀ (u : ι → Set X),\n      (∀ (i : ι), IsOpen (u i)) →\n        s ⊆ ⋃ (i : ι), u i →\n          ∃ v, (∀ (i : ι), IsOpen (v i)) ∧ s ⊆ ⋃ (i : ι), v i ∧ LocallyFinite v ∧ ∀ (i : ι), v i ⊆ u i :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {x : α} {U : Set α},\n  IsOpen U → x ∈ U → ∃ K, IsCompact K ∧ x ∈ interior K ∧ K ⊆ U :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T1Space α],\n  CountablyCompactSpace α ↔ LimitPointCompactSpace α "
    ]
  },
  {
    "docString": "Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism.",
    "prompts": "[{\"theorem\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Isometry ↑α\",\n  \"isProp\": true,\n  \"docString\":\n  \"The embedding of a metric space in its completion is an isometry. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformInducing f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform inducing map \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : EMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from an emetric space is injective \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\\n  Isometry f ↔ ∀ (x y : α), dist (f x) (f y) = dist x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"On pseudometric spaces, a map is an isometry if and only if it preserves distances. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {f : α → β} (h : Embedding f),\\n  Isometry f\",\n  \"isProp\": true,\n  \"docString\":\n  \"An embedding from a topological space to a metric space is an isometry with respect to the\\ninduced metric space structure on the source space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : MetricSpace β] {f : α → β} (h : UniformEmbedding f),\\n  Isometry f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform embedding from a uniform space to a metric space is an isometry with respect to the\\ninduced metric space structure on the source space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {γ : Type w} [inst : EMetricSpace α] [inst_1 : CompleteSpace α] [inst_2 : EMetricSpace γ] {f : α → γ},\\n  Isometry f → ClosedEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"An isometry from a complete emetric space is a closed embedding \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {β : Type v} {γ : Type w} [inst : MetricSpace γ] [inst_1 : MetricSpace β] {f : γ → β},\\n  UniformEmbedding f ↔\\n    (∀ (ε : ℝ), ε > 0 → ∃ δ, δ > 0 ∧ ∀ {a b : γ}, dist a b < δ → dist (f a) (f b) < ε) ∧\\n      ∀ (δ : ℝ), δ > 0 → ∃ ε, ε > 0 ∧ ∀ {a b : γ}, dist (f a) (f b) < ε → dist a b < δ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A map between metric spaces is a uniform embedding if and only if the distance between `f x`\\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : EMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → Embedding f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from an emetric space is an embedding \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : EMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformEmbedding f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from an emetric space is a uniform embedding \"},\n {\"theorem\":\n  \"∀ {E : Type u_3} {PE : Type u_1} {F : Type u_4} {PF : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : MetricSpace PE] [inst_3 : NormedAddTorsor E PE] [inst_4 : NormedAddCommGroup F] [inst_5 : NormedSpace ℝ F]\\n  [inst_6 : MetricSpace PF] [inst_7 : NormedAddTorsor F PF] (f : PE ≃ᵢ PF) (x y : PE),\\n  ↑f (midpoint ℝ x y) = midpoint ℝ (↑f x) (↑f y)\",\n  \"isProp\": true,\n  \"docString\": \"A bijective isometry sends midpoints to midpoints. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\\n  Isometry f → ∀ (s : Set α), Metric.diam (f '' s) = Metric.diam s\",\n  \"isProp\": true,\n  \"docString\": \"An isometry preserves the diameter in pseudometric spaces. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"}]\n",
    "prompt_cons": "/-- The embedding of a metric space in its completion is an isometry. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α], Isometry ↑α :=\n\n/-- An isometry from a metric space is a uniform inducing map -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformInducing f :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformContinuous f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- An isometry from an emetric space is injective -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : EMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → Function.Injective f :=\n\n/-- On pseudometric spaces, a map is an isometry if and only if it preserves distances. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  Isometry f ↔ ∀ (x y : α), dist (f x) (f y) = dist x y :=\n\n/-- An embedding from a topological space to a metric space is an isometry with respect to the\ninduced metric space structure on the source space. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {f : α → β} (h : Embedding f),\n  Isometry f :=\n\n/-- A uniform embedding from a uniform space to a metric space is an isometry with respect to the\ninduced metric space structure on the source space. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : MetricSpace β] {f : α → β} (h : UniformEmbedding f),\n  Isometry f :=\n\n/-- An isometry from a complete emetric space is a closed embedding -/\ntheorem ∀ {α : Type u} {γ : Type w} [inst : EMetricSpace α] [inst_1 : CompleteSpace α] [inst_2 : EMetricSpace γ] {f : α → γ},\n  Isometry f → ClosedEmbedding f :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- A map between metric spaces is a uniform embedding if and only if the distance between `f x`\nand `f y` is controlled in terms of the distance between `x` and `y` and conversely. -/\ntheorem ∀ {β : Type v} {γ : Type w} [inst : MetricSpace γ] [inst_1 : MetricSpace β] {f : γ → β},\n  UniformEmbedding f ↔\n    (∀ (ε : ℝ), ε > 0 → ∃ δ, δ > 0 ∧ ∀ {a b : γ}, dist a b < δ → dist (f a) (f b) < ε) ∧\n      ∀ (δ : ℝ), δ > 0 → ∃ ε, ε > 0 ∧ ∀ {a b : γ}, dist (f a) (f b) < ε → dist a b < δ :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖ :=\n\n/-- An isometry from an emetric space is an embedding -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : EMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → Embedding f :=\n\n/-- An isometry is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → Continuous f :=\n\n/-- An isometry from an emetric space is a uniform embedding -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : EMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformEmbedding f :=\n\n/-- A bijective isometry sends midpoints to midpoints. -/\ntheorem ∀ {E : Type u_3} {PE : Type u_1} {F : Type u_4} {PF : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : MetricSpace PE] [inst_3 : NormedAddTorsor E PE] [inst_4 : NormedAddCommGroup F] [inst_5 : NormedSpace ℝ F]\n  [inst_6 : MetricSpace PF] [inst_7 : NormedAddTorsor F PF] (f : PE ≃ᵢ PF) (x y : PE),\n  ↑f (midpoint ℝ x y) = midpoint ℝ (↑f x) (↑f y) :=\n\n/-- An isometry preserves the diameter in pseudometric spaces. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  Isometry f → ∀ (s : Set α), Metric.diam (f '' s) = Metric.diam s :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompactSpace X] {f : X → X},\n  Isometry f → Function.Bijective f ∧ Homeomorph X X "
    ]
  },
  {
    "docString": "Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\\n  {p : Filter ι} {F : ι → C(α, β)}, TendstoLocallyUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto F p (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Locally uniform convergence implies convergence in the compact-open topology. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\\n  ¬Continuous ↑CofiniteTopology.of.symm\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from\\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\\n  (s : Set β),\\n  IsCompact s →\\n    ∀ (A : Set (BoundedContinuousFunction α β)),\\n      IsClosed A →\\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α),\\n  Disjoint (nhds x) (Filter.cocompact α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, the filters `𝓝 x` and `cocompact α` are disjoint for all `α`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : ∀ (i : ι), CompactSpace (π i)],\\n  LocallyCompactSpace ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\\n  {K L : Set G}, IsCompact K → IsCompact L → ∃ g, Disjoint K (g • L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two compact sets in a noncompact topological group, there is a translate of the second\\none that is disjoint from the first one. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : CompactIccSpace α] {a b : α},\\n  IsCompact (Set.uIcc a b)\",\n  \"isProp\": true,\n  \"docString\": \"An unordered closed interval is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\": \"∀ {α : Type u_1} {r : Setoid α}, ¬∅ ∈ Setoid.classes r\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is not an equivalence class. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : TopologicalSpace.SecondCountableTopology E] [inst_3 : CompleteSpace E] [inst_4 : NormedAddCommGroup F]\\n  {f : ℝ → E} {g : ℝ → F} {a b c : ℝ},\\n  (∀ᶠ (x : ℝ) in nhdsWithin c {c}ᶜ, DifferentiableAt ℝ f x) →\\n    Filter.Tendsto (fun x => ‖f x‖) (nhdsWithin c {c}ᶜ) Filter.atTop →\\n      deriv f =O[nhdsWithin c {c}ᶜ] g → a ≠ b → c ∈ Set.uIcc a b → ¬IntervalIntegrable g MeasureTheory.volume a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is differentiable in a punctured neighborhood of `c`, `‖f x‖ → ∞` as `x → c` (more\\nformally, along the filter `𝓝[≠] c`), and `f' = O(g)` along `𝓝[≠] c`, where `f'` is the derivative\\nof `f`, then `g` is not interval integrable on any nontrivial interval `a..b` such that\\n`c ∈ [a, b]`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] (a : α),\\n  IsClosed (Set.Ici a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. \"}]\n",
    "prompt_cons": "/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ :=\n\n/-- If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ) :=\n\n/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem ∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\n  {p : Filter ι} {F : ι → C(α, β)}, TendstoLocallyUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto F p (nhds f) :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- If `X` is an infinite type with discrete topology (e.g., `ℕ`), then the identity map from\n`CofiniteTopology (OnePoint X)` to `OnePoint X` is not continuous. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : Infinite X] [inst_2 : DiscreteTopology X],\n  ¬Continuous ↑CofiniteTopology.of.symm :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\n  (s : Set β),\n  IsCompact s →\n    ∀ (A : Set (BoundedContinuousFunction α β)),\n      IsClosed A →\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A :=\n\n/-- In a locally compact space, the filters `𝓝 x` and `cocompact α` are disjoint for all `α`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α),\n  Disjoint (nhds x) (Filter.cocompact α) :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : ∀ (i : ι), CompactSpace (π i)],\n  LocallyCompactSpace ((i : ι) → π i) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\n  {K L : Set G}, IsCompact K → IsCompact L → ∃ g, Disjoint K (g • L) :=\n\n/-- An unordered closed interval is compact. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : CompactIccSpace α] {a b : α},\n  IsCompact (Set.uIcc a b) :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- The empty set is not an equivalence class. -/\ntheorem ∀ {α : Type u_1} {r : Setoid α}, ¬∅ ∈ Setoid.classes r :=\n\n/-- If `f` is differentiable in a punctured neighborhood of `c`, `‖f x‖ → ∞` as `x → c` (more\nformally, along the filter `𝓝[≠] c`), and `f' = O(g)` along `𝓝[≠] c`, where `f'` is the derivative\nof `f`, then `g` is not interval integrable on any nontrivial interval `a..b` such that\n`c ∈ [a, b]`. -/\ntheorem ∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : TopologicalSpace.SecondCountableTopology E] [inst_3 : CompleteSpace E] [inst_4 : NormedAddCommGroup F]\n  {f : ℝ → E} {g : ℝ → F} {a b c : ℝ},\n  (∀ᶠ (x : ℝ) in nhdsWithin c {c}ᶜ, DifferentiableAt ℝ f x) →\n    Filter.Tendsto (fun x => ‖f x‖) (nhdsWithin c {c}ᶜ) Filter.atTop →\n      deriv f =O[nhdsWithin c {c}ᶜ] g → a ≠ b → c ∈ Set.uIcc a b → ¬IntervalIntegrable g MeasureTheory.volume a b :=\n\n/-- Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] (a : α),\n  IsClosed (Set.Ici a) :=\n\n/-- Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology. -/\ntheorem",
    "choices": [
      "∀ {ι : Type u_1} [inst : TopologicalSpace ι] [inst_1 : UniformSpace ι] [inst_2 : CompactSpace ι] [inst_3 : Nonempty ι],\n  ¬LocallyCompactSpace (ι → ℝ) "
    ]
  },
  {
    "docString": "Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\\n  TopologicalSpace.SeparableSpace ((i : ι) → X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β},\\n  Dense s → Dense t → Dense (s ×ˢ t)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two dense sets is a dense set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsOpen (f s)) →\\n    Set.Countable S → (∀ (s : β), s ∈ S → Dense (f s)) → Dense (⋂ (s : β) (_ : s ∈ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] [inst_1 : Finite ι]\\n  [inst_2 : ∀ (i : ι), DiscreteTopology (π i)], DiscreteTopology ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\": \"A finite product of discrete spaces is discrete. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsClosed s) →\\n    Set.Countable S → ⋃₀ S = Set.univ → Dense (⋃ (s : Set α) (_ : s ∈ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `⋃₀`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\\n  IsOpen s → Set.Nonempty s → Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Encodable β]\\n  {f : β → Set α}, (∀ (s : β), IsClosed (f s)) → ⋃ (s : β), f s = Set.univ → Dense (⋃ (s : β), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is an encodable type. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β}\\n  {f : (x : β) → x ∈ S → Set α},\\n  (∀ (s : β) (H : s ∈ S), IsGδ (f s H)) →\\n    Set.Countable S → (∀ (s : β) (H : s ∈ S), Dense (f s H)) → Dense (⋂ (s : β) (h : s ∈ S), f s h)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the type of nonempty compact subsets is second countable \"}]\n",
    "prompt_cons": "/-- There exists a countable dense set. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s)) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem ∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  TopologicalSpace.SeparableSpace ((i : ι) → X i) :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- The product of two dense sets is a dense set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set α} {t : Set β},\n  Dense s → Dense t → Dense (s ×ˢ t) :=\n\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsOpen (f s)) →\n    Set.Countable S → (∀ (s : β), s ∈ S → Dense (f s)) → Dense (⋂ (s : β) (_ : s ∈ S), f s) :=\n\n/-- A finite product of discrete spaces is discrete. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] [inst_1 : Finite ι]\n  [inst_2 : ∀ (i : ι), DiscreteTopology (π i)], DiscreteTopology ((i : ι) → π i) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `⋃₀`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsClosed s) →\n    Set.Countable S → ⋃₀ S = Set.univ → Dense (⋃ (s : Set α) (_ : s ∈ S), interior s) :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\n  IsOpen s → Set.Nonempty s → Dense s :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is an encodable type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Encodable β]\n  {f : β → Set α}, (∀ (s : β), IsClosed (f s)) → ⋃ (s : β), f s = Set.univ → Dense (⋃ (s : β), interior (f s)) :=\n\n/-- In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β}\n  {f : (x : β) → x ∈ S → Set α},\n  (∀ (s : β) (H : s ∈ S), IsGδ (f s H)) →\n    Set.Countable S → (∀ (s : β) (H : s ∈ S), Dense (f s H)) → Dense (⋂ (s : β) (h : s ∈ S), f s h) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a :=\n\n/-- In a second countable space, the type of nonempty compact subsets is second countable -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  TopologicalSpace.SecondCountableTopology (TopologicalSpace.NonemptyCompacts α) :=\n\n/-- Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset. -/\ntheorem",
    "choices": [
      "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s "
    ]
  },
  {
    "docString": "Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\\n  x ≠ y →\\n    ∃ U₁,\\n      U₁ ∈ nhds x ∧\\n        ∃ V₁,\\n          V₁ ∈ nhds x ∧\\n            ∃ U₂,\\n              U₂ ∈ nhds y ∧\\n                ∃ V₂,\\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\\ndisjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] (x : α) {s : Set α},\\n  s ∈ nhds x → Set.Finite s → IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\\n  IsClosed s → ¬a ∈ s → Disjoint (nhdsSet s) (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\\nneighborhoods.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T5Space α] ⦃s t : Set α⦄,\\n  Disjoint (closure s) t → Disjoint s (closure t) → Disjoint (nhdsSet s) (nhdsSet t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `closure s` is disjoint with `t` and `s` is disjoint with `closure t`, then `s` and `t`\\nadmit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ closure s = closure t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two sets are at zero Hausdorff distance if and only if they have the same closures \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s (closure s) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The Hausdorff distance between a set and its closure vanish \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\\n  HasCountableSeparatingOn X IsClosed s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists a countable family of open sets separating points of `s`, then there exists\\na countable family of closed sets separating points of `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, EMetric.hausdorffEdist s (closure s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff edistance between a set and its closure vanishes \"}]\n",
    "prompt_cons": "/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds x ∧\n            ∃ U₂,\n              U₂ ∈ nhds y ∧\n                ∃ V₂,\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n\n/-- Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\ndisjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure) :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] (x : α) {s : Set α},\n  s ∈ nhds x → Set.Finite s → IsOpen {x} :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\nneighborhoods. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\n  IsClosed s → ¬a ∈ s → Disjoint (nhdsSet s) (nhds a) :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U) :=\n\n/-- If `closure s` is disjoint with `t` and `s` is disjoint with `closure t`, then `s` and `t`\nadmit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T5Space α] ⦃s t : Set α⦄,\n  Disjoint (closure s) t → Disjoint s (closure t) → Disjoint (nhdsSet s) (nhdsSet t) :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- The Hausdorff distance between two sets and their closures coincide -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t :=\n\n/-- Two sets are at zero Hausdorff distance if and only if they have the same closures -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ closure s = closure t) :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- The Hausdorff distance between a set and its closure vanish -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.hausdorffDist s (closure s) = 0 :=\n\n/-- If there exists a countable family of open sets separating points of `s`, then there exists\na countable family of closed sets separating points of `s`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [h : HasCountableSeparatingOn X IsOpen s],\n  HasCountableSeparatingOn X IsClosed s :=\n\n/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V) :=\n\n/-- The Hausdorff edistance between a set and its closure vanishes -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, EMetric.hausdorffEdist s (closure s) = 0 :=\n\n/-- Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint. -/\ntheorem",
    "choices": [
      "∀ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {x y : X},\n  x ≠ y → ∃ U V, IsOpen U ∧ IsOpen V ∧ x ∈ U ∧ y ∈ V ∧ Disjoint (closure U) (closure V) "
    ]
  },
  {
    "docString": "Show that every order topology is regular.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : LinearOrder β] [t : TopologicalSpace β]\\n  [inst_2 : OrderTopology β] {f : α → β},\\n  StrictMono f → Set.OrdConnected (Set.range f) → TopologicalSpace.induced f t = Preorder.topology α\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced by a strictly monotone function with order-connected range is the preorder\\ntopology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] {f : α → β},\\n  Inducing f → tα = TopologicalSpace.induced f tβ\",\n  \"isProp\": true,\n  \"docString\": \"The topology on the domain is equal to the induced topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) (β : Type u_2) [inst : LinearOrder α] [inst_1 : LinearOrder β] [inst_2 : Encodable α]\\n  [inst_3 : DenselyOrdered α] [inst_4 : NoMinOrder α] [inst_5 : NoMaxOrder α] [inst_6 : Nonempty α]\\n  [inst_7 : Encodable β] [inst_8 : DenselyOrdered β] [inst_9 : NoMinOrder β] [inst_10 : NoMaxOrder β]\\n  [inst_11 : Nonempty β], Nonempty (α ≃o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two countable dense, nonempty linear orders without endpoints are order isomorphic. \"},\n {\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T5Space Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is T₅. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : TopologicalSpace α] [inst : LowerTopology α], T0Space α\",\n  \"isProp\": true,\n  \"docString\": \"The lower topology on a partial order is T₀. \"},\n {\"theorem\":\n  \"∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\\n  {n k ℓ μ : ℕ},\\n  SimpleGraph.IsSRGWith G n k ℓ μ → SimpleGraph.IsSRGWith Gᶜ n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a strongly regular graph is strongly regular. \"},\n {\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is T₃. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {t : Set α}\\n  [ht : Set.OrdConnected t], OrderTopology ↑t\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the\\norder is the same as the restriction to the subset of the order topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β],\\n  ContinuousMap.compactOpen = ContinuousMap.compactConvergenceTopology\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology is equal to the compact-convergence topology. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {a : R} [inst : Monoid R] (n : ℕ), IsRegular a → IsRegular (a ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Any power of a regular element is regular. \"},\n {\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], ContinuousMul Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined makes it a topological\\nmonoid. \"},\n {\"theorem\":\n  \"∀ {α : Type ua} [hα : UniformSpace α], uniformity α = Filter.principal idRel → DiscreteTopology α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with the discrete uniformity has the discrete topology. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : Rˣ), IsSMulRegular M ↑a\",\n  \"isProp\": true,\n  \"docString\": \"Any element in `Rˣ` is `M`-regular. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the topology of a space is induced by a countable family of seminorms, then the topology\\nis first countable. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [inst_1 : CategoryTheory.RegularMono f],\\n  CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Every regular monomorphism is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a → IsSMulRegular M s → IsSMulRegular M (a • s)\",\n  \"isProp\": true,\n  \"docString\": \"The product of `M`-regular elements is `M`-regular. \"}]\n",
    "prompt_cons": "/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem ∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- The topology induced by a strictly monotone function with order-connected range is the preorder\ntopology. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : LinearOrder β] [t : TopologicalSpace β]\n  [inst_2 : OrderTopology β] {f : α → β},\n  StrictMono f → Set.OrdConnected (Set.range f) → TopologicalSpace.induced f t = Preorder.topology α :=\n\n/-- The topology on the domain is equal to the induced topology. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] {f : α → β},\n  Inducing f → tα = TopologicalSpace.induced f tβ :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Any two countable dense, nonempty linear orders without endpoints are order isomorphic. -/\ntheorem ∀ (α : Type u_1) (β : Type u_2) [inst : LinearOrder α] [inst_1 : LinearOrder β] [inst_2 : Encodable α]\n  [inst_3 : DenselyOrdered α] [inst_4 : NoMinOrder α] [inst_5 : NoMaxOrder α] [inst_6 : Nonempty α]\n  [inst_7 : Encodable β] [inst_8 : DenselyOrdered β] [inst_9 : NoMinOrder β] [inst_10 : NoMaxOrder β]\n  [inst_11 : Nonempty β], Nonempty (α ≃o β) :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is T₅. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T5Space Γ₀ :=\n\n/-- The lower topology on a partial order is T₀. -/\ntheorem ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : TopologicalSpace α] [inst : LowerTopology α], T0Space α :=\n\n/-- The complement of a strongly regular graph is strongly regular. -/\ntheorem ∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\n  {n k ℓ μ : ℕ},\n  SimpleGraph.IsSRGWith G n k ℓ μ → SimpleGraph.IsSRGWith Gᶜ n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ)) :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is T₃. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀ :=\n\n/-- On a `Set.OrdConnected` subset of a linear order, the order topology for the restriction of the\norder is the same as the restriction to the subset of the order topology. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {t : Set α}\n  [ht : Set.OrdConnected t], OrderTopology ↑t :=\n\n/-- The compact-open topology is equal to the compact-convergence topology. -/\ntheorem ∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β],\n  ContinuousMap.compactOpen = ContinuousMap.compactConvergenceTopology :=\n\n/-- Any power of a regular element is regular. -/\ntheorem ∀ {R : Type u_1} {a : R} [inst : Monoid R] (n : ℕ), IsRegular a → IsRegular (a ^ n) :=\n\n/-- The topology on a linearly ordered group with zero element adjoined makes it a topological\nmonoid. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], ContinuousMul Γ₀ :=\n\n/-- A uniform space with the discrete uniformity has the discrete topology. -/\ntheorem ∀ {α : Type ua} [hα : UniformSpace α], uniformity α = Filter.principal idRel → DiscreteTopology α :=\n\n/-- Any element in `Rˣ` is `M`-regular. -/\ntheorem ∀ {R : Type u_1} (M : Type u_2) [inst : Monoid R] [inst_1 : MulAction R M] (a : Rˣ), IsSMulRegular M ↑a :=\n\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E :=\n\n/-- Every regular monomorphism is a monomorphism. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (f : X ⟶ Y) [inst_1 : CategoryTheory.RegularMono f],\n  CategoryTheory.Mono f :=\n\n/-- The product of `M`-regular elements is `M`-regular. -/\ntheorem ∀ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a → IsSMulRegular M s → IsSMulRegular M (a • s) :=\n\n/-- Show that every order topology is regular. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α], RegularSpace α "
    ]
  },
  {
    "docString": "Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → EMetric.hausdorffEdist s t ≠ ⊤ → Set.Nonempty t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : MetricSpace α] {x y : TopologicalSpace.NonemptyCompacts α}, dist x y = Metric.hausdorffDist ↑x ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance on `NonemptyCompacts α` is the Hausdorff distance, by construction \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ∀ (j : J), Nonempty ↑(F.obj j)]\\n  [inst_3 : ∀ (j : J), CompactSpace ↑(F.obj j)] [inst_4 : ∀ (j : J), T2Space ↑(F.obj j)],\\n  Nonempty ↑(TopCat.limitCone F).pt\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning α are disjoint. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\\n  Function.Injective f → Continuous f → T2Space α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, 0 ≤ Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\": \"The Hausdorff distance is nonnegative \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Countable α], Countable (Array α)\",\n  \"isProp\": true,\n  \"docString\": \"If `α` is countable, then so is `Array α`. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Countable α], Countable (Multiset α)\",\n  \"isProp\": true,\n  \"docString\": \"If `α` is countable, then so is `Multiset α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Countable α], Countable (Finset α)\",\n  \"isProp\": true,\n  \"docString\": \"If `α` is countable, then so is `Finset α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasureTheory.SigmaFinite μ]\\n  (P : α → Prop),\\n  (∀ (s : Set α), MeasurableSet s → ↑↑μ s < ⊤ → ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ s, P x) →\\n    ∀ᵐ (x : α) ∂μ, P x\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for almost all `x` w.r.t. a σ-finite measure, it is sufficient to show that\\nthis holds almost everywhere in sets where the measure has finite value. \"}]\n",
    "prompt_cons": "/-- If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s t : Set α},\n  Set.Nonempty s → EMetric.hausdorffEdist s t ≠ ⊤ → Set.Nonempty t :=\n\n/-- The distance on `NonemptyCompacts α` is the Hausdorff distance, by construction -/\ntheorem ∀ {α : Type u} [inst : MetricSpace α] {x y : TopologicalSpace.NonemptyCompacts α}, dist x y = Metric.hausdorffDist ↑x ↑y :=\n\n/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces. -/\ntheorem ∀ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ∀ (j : J), Nonempty ↑(F.obj j)]\n  [inst_3 : ∀ (j : J), CompactSpace ↑(F.obj j)] [inst_4 : ∀ (j : J), T2Space ↑(F.obj j)],\n  Nonempty ↑(TopCat.limitCone F).pt :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- Distinct elements of a set of sets partitioning α are disjoint. -/\ntheorem ∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s } :=\n\n/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\n  Function.Injective f → Continuous f → T2Space α :=\n\n/-- The Hausdorff distance is nonnegative -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, 0 ≤ Metric.hausdorffDist s t :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- If `α` is countable, then so is `Array α`. -/\ntheorem ∀ {α : Type u_1} [inst : Countable α], Countable (Array α) :=\n\n/-- If `α` is countable, then so is `Multiset α`. -/\ntheorem ∀ {α : Type u_1} [inst : Countable α], Countable (Multiset α) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- If `α` is countable, then so is `Finset α`. -/\ntheorem ∀ {α : Type u_1} [inst : Countable α], Countable (Finset α) :=\n\n/-- To prove something for almost all `x` w.r.t. a σ-finite measure, it is sufficient to show that\nthis holds almost everywhere in sets where the measure has finite value. -/\ntheorem ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasureTheory.SigmaFinite μ]\n  (P : α → Prop),\n  (∀ (s : Set α), MeasurableSet s → ↑↑μ s < ⊤ → ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ s, P x) →\n    ∀ᵐ (x : α) ∂μ, P x :=\n\n/-- Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem",
    "choices": [
      "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : ∀ (i : ι), TopologicalSpace (α i)] [inst_1 : ∀ (i : ι), Nonempty (α i)]\n  [self : T2Space (Π (i : ι), α i)] (i : ι), T2Space (α i) "
    ]
  },
  {
    "docString": "Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has no zero divisors, then the product of two elements is nonzero iff both of them\\nare nonzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {f : Filter α} {g : Filter β} {h : Filter γ}\\n  {k : Filter δ},\\n  Filter.map (fun p => ((p.fst.fst, p.snd.fst), p.fst.snd, p.snd.snd)) ((f ×ˢ g) ×ˢ h ×ˢ k) = (f ×ˢ h) ×ˢ g ×ˢ k\",\n  \"isProp\": true,\n  \"docString\": \"A useful lemma when dealing with uniformities. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Countable α], Countable (Multiset α)\",\n  \"isProp\": true,\n  \"docString\": \"If `α` is countable, then so is `Multiset α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Mul α] [inst_2 : ContinuousMul α], ContinuousMul αᵐᵒᵖ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If multiplication is continuous in `α`, then it also is in `αᵐᵒᵖ`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) {M : ℝ},\\n  0 ≤ M → (∀ (x : E), ‖x‖ ≠ 0 → ‖↑f x‖ ≤ M * ‖x‖) → ‖f‖ ≤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `‖x‖ ≠ 0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasureTheory.SigmaFinite μ]\\n  (P : α → Prop),\\n  (∀ (s : Set α), MeasurableSet s → ↑↑μ s < ⊤ → ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ s, P x) →\\n    ∀ᵐ (x : α) ∂μ, P x\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for almost all `x` w.r.t. a σ-finite measure, it is sufficient to show that\\nthis holds almost everywhere in sets where the measure has finite value. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning α are disjoint. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : RingHomIsometric σ₁₂]\\n  (f : E →SL[σ₁₂] F) (M : NNReal), (∀ (x : E), ‖x‖₊ ≠ 0 → ‖↑f x‖₊ ≤ M * ‖x‖₊) → ‖f‖₊ ≤ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If one controls the norm of every `A x`, `‖x‖₊ ≠ 0`, then one controls the norm of `A`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {Fₗ : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fₗ]\\n  [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedSpace 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ),\\n  ‖ContinuousLinearMap.smulRight c f‖₊ = ‖c‖₊ * ‖f‖₊\",\n  \"isProp\": true,\n  \"docString\":\n  \"The non-negative norm of the tensor product of a scalar linear map and of an element of a normed\\nspace is the product of the non-negative norms. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NormedAddCommGroup α] [inst_1 : Lattice α] [inst_2 : HasSolidNorm α] (r : ℝ),\\n  LatticeOrderedAddCommGroup.IsSolid (Metric.ball 0 r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has a solid norm, then the balls centered at the origin of `α` are solid sets. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Countable α], Countable (Array α)\",\n  \"isProp\": true,\n  \"docString\": \"If `α` is countable, then so is `Array α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {p : (s : Finset α) → Finset.Nonempty s → Prop},\\n  (∀ (a : α), p {a} (_ : Finset.Nonempty {a})) →\\n    (∀ ⦃a : α⦄ (s : Finset α) (h : ¬a ∈ s) (hs : Finset.Nonempty s),\\n        p s hs → p (Finset.cons a s h) (_ : Finset.Nonempty (Finset.cons a s h))) →\\n      ∀ {s : Finset α} (hs : Finset.Nonempty s), p s hs\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a proposition about a nonempty `s : Finset α`, it suffices to show it holds for all\\nsingletons and that if it holds for nonempty `t : Finset α`, then it also holds for the `Finset`\\nobtained by inserting an element in `t`. \"}]\n",
    "prompt_cons": "/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s } :=\n\n/-- If `α` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0 :=\n\n/-- A useful lemma when dealing with uniformities. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {f : Filter α} {g : Filter β} {h : Filter γ}\n  {k : Filter δ},\n  Filter.map (fun p => ((p.fst.fst, p.snd.fst), p.fst.snd, p.snd.snd)) ((f ×ˢ g) ×ˢ h ×ˢ k) = (f ×ˢ h) ×ˢ g ×ˢ k :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- If `α` is countable, then so is `Multiset α`. -/\ntheorem ∀ {α : Type u_1} [inst : Countable α], Countable (Multiset α) :=\n\n/-- If multiplication is continuous in `α`, then it also is in `αᵐᵒᵖ`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Mul α] [inst_2 : ContinuousMul α], ContinuousMul αᵐᵒᵖ :=\n\n/-- If one controls the norm of every `A x`, `‖x‖ ≠ 0`, then one controls the norm of `A`. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F) {M : ℝ},\n  0 ≤ M → (∀ (x : E), ‖x‖ ≠ 0 → ‖↑f x‖ ≤ M * ‖x‖) → ‖f‖ ≤ M :=\n\n/-- To prove something for almost all `x` w.r.t. a σ-finite measure, it is sufficient to show that\nthis holds almost everywhere in sets where the measure has finite value. -/\ntheorem ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasureTheory.SigmaFinite μ]\n  (P : α → Prop),\n  (∀ (s : Set α), MeasurableSet s → ↑↑μ s < ⊤ → ∀ᵐ (x : α) ∂MeasureTheory.Measure.restrict μ s, P x) →\n    ∀ᵐ (x : α) ∂μ, P x :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Distinct elements of a set of sets partitioning α are disjoint. -/\ntheorem ∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id :=\n\n/-- If one controls the norm of every `A x`, `‖x‖₊ ≠ 0`, then one controls the norm of `A`. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : RingHomIsometric σ₁₂]\n  (f : E →SL[σ₁₂] F) (M : NNReal), (∀ (x : E), ‖x‖₊ ≠ 0 → ‖↑f x‖₊ ≤ M * ‖x‖₊) → ‖f‖₊ ≤ M :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u)) :=\n\n/-- The non-negative norm of the tensor product of a scalar linear map and of an element of a normed\nspace is the product of the non-negative norms. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {Fₗ : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fₗ]\n  [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedSpace 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ),\n  ‖ContinuousLinearMap.smulRight c f‖₊ = ‖c‖₊ * ‖f‖₊ :=\n\n/-- If `α` has a solid norm, then the balls centered at the origin of `α` are solid sets. -/\ntheorem ∀ {α : Type u_1} [inst : NormedAddCommGroup α] [inst_1 : Lattice α] [inst_2 : HasSolidNorm α] (r : ℝ),\n  LatticeOrderedAddCommGroup.IsSolid (Metric.ball 0 r) :=\n\n/-- If `α` is countable, then so is `Array α`. -/\ntheorem ∀ {α : Type u_1} [inst : Countable α], Countable (Array α) :=\n\n/-- To prove a proposition about a nonempty `s : Finset α`, it suffices to show it holds for all\nsingletons and that if it holds for nonempty `t : Finset α`, then it also holds for the `Finset`\nobtained by inserting an element in `t`. -/\ntheorem ∀ {α : Type u_1} {p : (s : Finset α) → Finset.Nonempty s → Prop},\n  (∀ (a : α), p {a} (_ : Finset.Nonempty {a})) →\n    (∀ ⦃a : α⦄ (s : Finset α) (h : ¬a ∈ s) (hs : Finset.Nonempty s),\n        p s hs → p (Finset.cons a s h) (_ : Finset.Nonempty (Finset.cons a s h))) →\n      ∀ {s : Finset α} (hs : Finset.Nonempty s), p s hs :=\n\n/-- Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] [inst_3 : T2Space β]\n  [inst_4 : Nonempty α] [inst_5 : Nonempty β] {f : α → β} {g : β → α},\n  Continuous f → Continuous g → (∀ (x : α), g (f x) = x) → (∀ (y : β), f (g y) = y) →\n    T2Space (α × β) → T2Space α "
    ]
  },
  {
    "docString": "Show that every locally compact Hausdorff space is completely regular.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α],\\n  TotallyDisconnectedSpace α ↔ TotallySeparatedSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\\nis also true for locally compact spaces. \"},\n {\"theorem\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"theorem\": \"CompleteSpace GromovHausdorff.GHSpace\",\n  \"isProp\": true,\n  \"docString\": \"The Gromov-Hausdorff space is complete. \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  [inst_3 : BorelSpace X] (μ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ],\\n  MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any locally finite measure on a `σ`-compact (e)metric space is regular. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (α : Type v) (s : α → Set X),\\n  (∀ (a : α), IsOpen (s a)) → ⋃ (a : α), s a = Set.univ → ∃ β t x x, LocallyFinite t ∧ ∀ (b : β), ∃ a, t b ⊆ s a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"theorem\":\n  \"∀ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ∀ (j : J), Nonempty ↑(F.obj j)]\\n  [inst_3 : ∀ (j : J), CompactSpace ↑(F.obj j)] [inst_4 : ∀ (j : J), T2Space ↑(F.obj j)],\\n  Nonempty ↑(TopCat.limitCone F).pt\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces.\\n\"}]\n",
    "prompt_cons": "/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α :=\n\n/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure μ) :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem ∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- A compact Hausdorff space is totally disconnected if and only if it is totally separated, this\nis also true for locally compact spaces. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α],\n  TotallyDisconnectedSpace α ↔ TotallySeparatedSpace α :=\n\n/-- A locally compact Hausdorff space is totally disconnected\nif and only if it is totally separated. -/\ntheorem ∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\n  TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H :=\n\n/-- The Gromov-Hausdorff space is complete. -/\ntheorem CompleteSpace GromovHausdorff.GHSpace :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- Any locally finite measure on a `σ`-compact (e)metric space is regular. -/\ntheorem ∀ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  [inst_3 : BorelSpace X] (μ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ],\n  MeasureTheory.Measure.Regular μ :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- A sequentially compact set in a uniform space is totally bounded. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- Every open cover of a paracompact space assumes a locally finite refinement. -/\ntheorem ∀ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (α : Type v) (s : α → Set X),\n  (∀ (a : α), IsOpen (s a)) → ⋃ (a : α), s a = Set.univ → ∃ β t x x, LocallyFinite t ∧ ∀ (b : β), ∃ a, t b ⊆ s a :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α) :=\n\n/-- Cofiltered limits of nonempty compact Hausdorff spaces are nonempty topological spaces. -/\ntheorem ∀ {J : Type u} [inst : CategoryTheory.SmallCategory J] (F : CategoryTheory.Functor J TopCatMax)\n  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J] [inst_2 : ∀ (j : J), Nonempty ↑(F.obj j)]\n  [inst_3 : ∀ (j : J), CompactSpace ↑(F.obj j)] [inst_4 : ∀ (j : J), T2Space ↑(F.obj j)],\n  Nonempty ↑(TopCat.limitCone F).pt :=\n\n/-- Show that every locally compact Hausdorff space is completely regular. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  CompletelyRegularSpace α "
    ]
  },
  {
    "docString": "Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners ℝ E H →\\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α × β)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Urysohn's metrization theorem* (Tychonoff's version): a T₃ topological space with second\\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\\nsame topology. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\\n  CompleteSpace ((i : ι) × E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α], BaireSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second theorem states that locally compact spaces are Baire. \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m m' : MetricSpace α}, PseudoMetricSpace.toDist = PseudoMetricSpace.toDist → m = m'\",\n  \"isProp\": true,\n  \"docString\": \"Two metric space structures with the same distance coincide. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\\n  TopologicalSpace.SeparableSpace (α × β)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, strongly measurable and measurable are equivalent. \"}]\n",
    "prompt_cons": "/-- A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners ℝ E H →\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α × β) :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- *Urysohn's metrization theorem* (Tychonoff's version): a T₃ topological space with second\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\nsame topology. -/\ntheorem ∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  TopologicalSpace.MetrizableSpace X :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\n  CompleteSpace ((i : ι) × E i) :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V) :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s :=\n\n/-- The second theorem states that locally compact spaces are Baire. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α], BaireSpace α :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- The **Heine–Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- Two metric space structures with the same distance coincide. -/\ntheorem ∀ {α : Type u_1} {m m' : MetricSpace α}, PseudoMetricSpace.toDist = PseudoMetricSpace.toDist → m = m' :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\n  TopologicalSpace.SeparableSpace (α × β) :=\n\n/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f :=\n\n/-- Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  {X₁ X₂ : Set X} [inst_3 : TopologicalSpace.MetrizableSpace (↥X₁)] [inst_4 : TopologicalSpace.MetrizableSpace (↥X₂)],\n  IsClosed X₁ → IsClosed X₂ → X = X₁ ∪ X₂ → TopologicalSpace.MetrizableSpace X "
    ]
  },
  {
    "docString": "Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\\n  Filter.Tendsto b (nhds 0) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\\n  CompleteSpace ((i : ι) × E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : CompleteSpace β],\\n  CompleteSpace (BoundedContinuousFunction α β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Bounded continuous functions taking values in a complete space form a complete space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\\n`g ∘ f` is measurable if and only if `g` is measurable. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β]\\n  {F : ι → β → α},\\n  UniformEquicontinuous F ↔\\n    ∀ (ε : ℝ), ε > 0 → ∃ δ, δ > 0 ∧ ∀ (x y : β), dist x y < δ → ∀ (i : ι), dist (F i x) (F i y) < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterization of uniform equicontinuity for families of functions between\\n(pseudo) metric spaces. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} {x : α} [inst_1 : TopologicalSpace α],\\n  x ∈ s →\\n    (∀ (u : Set (β × β)),\\n        u ∈ uniformity β →\\n          ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n      ContinuousWithinAt f s x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\nwithin a set at a point is continuous within this set at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F ↔\\n    ∀ (ε : ℝ), ε > 0 → ∀ᶠ (xy : β × β) in uniformity β, ∀ (i : ι), dist (F i xy.fst) (F i xy.snd) < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterization of uniform equicontinuity for families of functions taking values in a\\n(pseudo) metric space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) →\\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\\nexists a positive continuous function `δ : C(X, ℝ≥0∞)` such that for any `i` and `x ∈ K i`,\\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\n  Filter.Tendsto b (nhds 0) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\n  CompleteSpace ((i : ι) × E i) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- Bounded continuous functions taking values in a complete space form a complete space. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] [inst_2 : CompleteSpace β],\n  CompleteSpace (BoundedContinuousFunction α β) :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformContinuous f :=\n\n/-- If `f : X → Y` is a surjective Borel measurable map from a Polish space to a topological space\nwith second countable topology, then for any measurable space `α` and `g : Y → α`, the composition\n`g ∘ f` is measurable if and only if `g` is measurable. -/\ntheorem ∀ {X : Type u_2} {Y : Type u_1} {β : Type u_3} [inst : TopologicalSpace X] [inst_1 : PolishSpace X]\n  [inst_2 : MeasurableSpace X] [inst : BorelSpace X] [inst : TopologicalSpace Y] [inst_3 : T2Space Y]\n  [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y] [inst_6 : MeasurableSpace β]\n  [inst : TopologicalSpace.SecondCountableTopology Y] {f : X → Y},\n  Measurable f → Function.Surjective f → ∀ {g : Y → β}, Measurable (g ∘ f) ↔ Measurable g :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Characterization of uniform equicontinuity for families of functions between\n(pseudo) metric spaces. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β]\n  {F : ι → β → α},\n  UniformEquicontinuous F ↔\n    ∀ (ε : ℝ), ε > 0 → ∃ δ, δ > 0 ∧ ∀ (x y : β), dist x y < δ → ∀ (i : ι), dist (F i x) (F i y) < ε :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousAt f x :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} {x : α} [inst_1 : TopologicalSpace α],\n  x ∈ s →\n    (∀ (u : Set (β × β)),\n        u ∈ uniformity β →\n          ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n      ContinuousWithinAt f s x :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- Characterization of uniform equicontinuity for families of functions taking values in a\n(pseudo) metric space. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F ↔\n    ∀ (ε : ℝ), ε > 0 → ∀ᶠ (xy : β × β) in uniformity β, ∀ (i : ι), dist (F i xy.fst) (F i xy.snd) < ε :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) →\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f) :=\n\n/-- Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\nexists a positive continuous function `δ : C(X, ℝ≥0∞)` such that for any `i` and `x ∈ K i`,\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y] {A : Set X} {f : A → Y},\n  UniformContinuousOn f A →\n    ∃! g : Closure A → Y,\n      Continuous g ∧ UniformContinuousOn g (Closure A) ∧ ∀ (x : X), x ∈ A → g ⟨x, subset_closure⟩ = f x "
    ]
  },
  {
    "docString": "Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1).",
    "prompts": "[{\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 3` is `√3 / 2`. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `π / 6` is `√3 / 2`. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\": \"Real.cos (Real.pi / 3) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `π / 3` is `1 / 2`. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) ^ 2 = 3 / 4\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the\\nresult for cosine itself). \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `ζ(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ≠ 0 → discrim a b c = 0 → ∀ (x : K), a * x * x + b * x + c = 0 ↔ x = -b / (2 * a)\",\n  \"isProp\": true,\n  \"docString\": \"Root of a quadratic when its discriminant equals zero \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ≠ 0 →\\n    ∀ {s : K},\\n      discrim a b c = s * s → ∀ (x : K), a * x * x + b * x + c = 0 ↔ x = (-b + s) / (2 * a) ∨ x = (-b - s) / (2 * a)\",\n  \"isProp\": true,\n  \"docString\": \"Roots of a quadratic equation. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℚ),\\n  Finset.card (Set.toFinset (Polynomial.rootSet p ℂ)) =\\n    Finset.card (Set.toFinset (Polynomial.rootSet p ℝ)) +\\n      Finset.card\\n        (Equiv.Perm.support\\n          (↑(Polynomial.Gal.galActionHom p ℂ)\\n            (↑(Polynomial.Gal.restrict p ℂ) (AlgEquiv.restrictScalars ℚ Complex.conjAe))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of complex roots equals the number of real roots plus\\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) ^ 2 = 3 / 4\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the\\nresult for cosine itself). \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 → R),\\n  Matrix.dotProduct (↑(↑crossProduct u) v) (↑(↑crossProduct w) x) =\\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w\",\n  \"isProp\": true,\n  \"docString\":\n  \"The scalar quadruple product identity, related to the Binet-Cauchy identity. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (x y : M ⧸ S), ‖x + y‖ ≤ ‖x‖ + ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"The quotient norm satisfies the triangle inequality. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ≠ 0 → (∃ s, discrim a b c = s * s) → ∃ x, a * x * x + b * x + c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ (x : ℝ),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"}]\n",
    "prompt_cons": "/-- The sine of `π / 3` is `√3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- The cosine of `π / 6` is `√3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- The cosine of `π / 3` is `1 / 2`. -/\ntheorem Real.cos (Real.pi / 3) = 1 / 2 :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1 :=\n\n/-- The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the\nresult for cosine itself). -/\ntheorem Real.sin (Real.pi / 3) ^ 2 = 3 / 4 :=\n\n/-- We have `ζ(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- Root of a quadratic when its discriminant equals zero -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a ≠ 0 → discrim a b c = 0 → ∀ (x : K), a * x * x + b * x + c = 0 ↔ x = -b / (2 * a) :=\n\n/-- Roots of a quadratic equation. -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a ≠ 0 →\n    ∀ {s : K},\n      discrim a b c = s * s → ∀ (x : K), a * x * x + b * x + c = 0 ↔ x = (-b + s) / (2 * a) ∨ x = (-b - s) / (2 * a) :=\n\n/-- The number of complex roots equals the number of real roots plus\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem ∀ (p : Polynomial ℚ),\n  Finset.card (Set.toFinset (Polynomial.rootSet p ℂ)) =\n    Finset.card (Set.toFinset (Polynomial.rootSet p ℝ)) +\n      Finset.card\n        (Equiv.Perm.support\n          (↑(Polynomial.Gal.galActionHom p ℂ)\n            (↑(Polynomial.Gal.restrict p ℂ) (AlgEquiv.restrictScalars ℚ Complex.conjAe)))) :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the\nresult for cosine itself). -/\ntheorem Real.cos (Real.pi / 6) ^ 2 = 3 / 4 :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- The scalar quadruple product identity, related to the Binet-Cauchy identity. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 → R),\n  Matrix.dotProduct (↑(↑crossProduct u) v) (↑(↑crossProduct w) x) =\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w :=\n\n/-- The quotient norm satisfies the triangle inequality. -/\ntheorem ∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (x y : M ⧸ S), ‖x + y‖ ≤ ‖x‖ + ‖y‖ :=\n\n/-- A quadratic has roots if its discriminant has square roots -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a ≠ 0 → (∃ s, discrim a b c = s * s) → ∃ x, a * x * x + b * x + c = 0 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem ∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem ∀ (x : ℝ),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1). -/\ntheorem",
    "choices": [
      "Complex.exp (Complex.I * (Real.pi / 3)) ^ 3 = 1 "
    ]
  },
  {
    "docString": "Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  ↑(quadraticChar F) a = 0 ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The value of the quadratic character on `a` is zero iff `a = 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The `v`-adic valuation of `0 : R` equals 0. \"},\n {\"theorem\":\n  \"∀ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},\\n  Matrix.Nondegenerate M → ∀ {v : m → R}, (∀ (w : m → R), Matrix.dotProduct v (Matrix.mulVec M w) = 0) → v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `M` is nondegenerate and `w ⬝ M ⬝ v = 0` for all `w`, then `v = 0`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Γ₀]\\n  [inst_2 : Nontrivial Γ₀] (v : AddValuation K Γ₀) {x : K}, ↑v x = ⊤ ↔ x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is an additive valuation on a division ring then `v(x) = ⊤` iff `x = 0`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, 0 = a * b ↔ a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has no zero divisors, then the product of two elements equals zero iff one of them\\nequals zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_4} (self : AlternatingMap R M N ι) (v : ι → M) (i j : ι),\\n  v i = v j → i ≠ j → MultilinearMap.toFun (↑self) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map is alternating: if `v` has two equal coordinates, then `f v = 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : α → M} {s : Set α},\\n  Set.EqOn f 0 s → ∑ᶠ (i : α) (_ : i ∈ s), f i = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` equals `0` on a set `s`, then the product of `f i` over `i ∈ s`\\nequals `0`.\"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → (IsSquare a ↔ a ^ (Fintype.card F / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (x : M), 0 • x = 0\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by zero gives zero. \"},\n {\"theorem\": \"∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] (s : Set α), ∑ᶠ (i : α) (_ : i ∈ s), 0 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of the constant function `0` over any set equals `0`.\"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (b : A j), GradedMonoid.GMul.mul 0 b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Multiplication from the left with any graded component's zero vanishes. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (a : A i), GradedMonoid.GMul.mul a 0 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Multiplication from the right with any graded component's zero vanishes. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMul R M] [self : NoZeroSMulDivisors R M]\\n  {c : R} {x : M}, c • x = 0 → c = 0 ∨ x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If scalar multiplication yields zero, either the scalar or the vector was zero. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → (Polynomial.coeff (minpoly A x) 0 = 0 ↔ x = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. \"}]\n",
    "prompt_cons": "/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem ∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0 :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  ↑(quadraticChar F) a = 0 ↔ a = 0 :=\n\n/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0 :=\n\n/-- If `M` is nondegenerate and `w ⬝ M ⬝ v = 0` for all `w`, then `v = 0`. -/\ntheorem ∀ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},\n  Matrix.Nondegenerate M → ∀ {v : m → R}, (∀ (w : m → R), Matrix.dotProduct v (Matrix.mulVec M w) = 0) → v = 0 :=\n\n/-- If `v` is an additive valuation on a division ring then `v(x) = ⊤` iff `x = 0`. -/\ntheorem ∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Γ₀]\n  [inst_2 : Nontrivial Γ₀] (v : AddValuation K Γ₀) {x : K}, ↑v x = ⊤ ↔ x = 0 :=\n\n/-- If `α` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, 0 = a * b ↔ a = 0 ∨ b = 0 :=\n\n/-- The map is alternating: if `v` has two equal coordinates, then `f v = 0`. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_4} (self : AlternatingMap R M N ι) (v : ι → M) (i j : ι),\n  v i = v j → i ≠ j → MultilinearMap.toFun (↑self) v = 0 :=\n\n/-- If a function `f` equals `0` on a set `s`, then the product of `f i` over `i ∈ s`\nequals `0`. -/\ntheorem ∀ {α : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] {f : α → M} {s : Set α},\n  Set.EqOn f 0 s → ∑ᶠ (i : α) (_ : i ∈ s), f i = 0 :=\n\n/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → (IsSquare a ↔ a ^ (Fintype.card F / 2) = 1) :=\n\n/-- Scalar multiplication by zero gives zero. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [self : Module R M] (x : M), 0 • x = 0 :=\n\n/-- `a ^ 0 = 1` -/\ntheorem ∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem ∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0 :=\n\n/-- The product of the constant function `0` over any set equals `0`. -/\ntheorem ∀ {α : Type u_1} {M : Type u_2} [inst : AddCommMonoid M] (s : Set α), ∑ᶠ (i : α) (_ : i ∈ s), 0 = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Multiplication from the left with any graded component's zero vanishes. -/\ntheorem ∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (b : A j), GradedMonoid.GMul.mul 0 b = 0 :=\n\n/-- Multiplication from the right with any graded component's zero vanishes. -/\ntheorem ∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (a : A i), GradedMonoid.GMul.mul a 0 = 0 :=\n\n/-- If scalar multiplication yields zero, either the scalar or the vector was zero. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMul R M] [self : NoZeroSMulDivisors R M]\n  {c : R} {x : M}, c • x = 0 → c = 0 ∨ x = 0 :=\n\n/-- The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → (Polynomial.coeff (minpoly A x) 0 = 0 ↔ x = 0) :=\n\n/-- Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a • v = 0 → a = 0 ∨ v = 0 "
    ]
  },
  {
    "docString": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subsemiring is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under addition. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x - y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under subtraction \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\\n  x ≠ y →\\n    ∃ U₁,\\n      U₁ ∈ nhds x ∧\\n        ∃ V₁,\\n          V₁ ∈ nhds x ∧\\n            ∃ U₂,\\n              U₂ ∈ nhds y ∧\\n                ∃ V₂,\\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"A submonoid is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] (S : Subsemigroup M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"A subsemigroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {y : L}, y ∈ S → ∀ {x : K}, x • y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under scalar multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : SMul R M] (self : SubMulAction R M) (c : R) {x : M},\\n  x ∈ self.carrier → c • x ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The carrier set is closed under scalar multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subsemiring is closed under addition. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U ∈ nhds 1 → ∃ V, IsOpen V ∧ 1 ∈ V ∧ V * V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV ⊆ U`. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 1 ∧ K * V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V ⊆ U`. \"}]\n",
    "prompt_cons": "/-- A non-unital subring is closed under multiplication. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- A subsemiring is closed under multiplication. -/\ntheorem ∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- A non-unital subring is closed under addition. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- A non-unital subring is closed under subtraction -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x - y ∈ s :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- A subfield is closed under multiplication. -/\ntheorem ∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds x ∧\n            ∃ U₂,\n              U₂ ∈ nhds y ∧\n                ∃ V₂,\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- A submonoid is closed under multiplication. -/\ntheorem ∀ {M : Type u_1} [inst : MulOneClass M] (S : Submonoid M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- A subsemigroup is closed under multiplication. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] (S : Subsemigroup M) {x y : M}, x ∈ S → y ∈ S → x * y ∈ S :=\n\n/-- An intermediate field is closed under scalar multiplication. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {y : L}, y ∈ S → ∀ {x : K}, x • y ∈ S :=\n\n/-- The carrier set is closed under scalar multiplication. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : SMul R M] (self : SubMulAction R M) (c : R) {x : M},\n  x ∈ self.carrier → c • x ∈ self.carrier :=\n\n/-- A subsemiring is closed under addition. -/\ntheorem ∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U ∈ nhds 1 → ∃ V, IsOpen V ∧ 1 ∈ V ∧ V * V ⊆ U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 1 ∧ K * V ⊆ U :=\n\n/-- Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$. -/\ntheorem",
    "choices": [
      "example : ∃ (U : Set (ℝ × ℝ)), (∀ (c : ℝ) (x : ℝ × ℝ), x ∈ U → c • x ∈ U) ∧ ¬(∀ (x y : ℝ × ℝ), x ∈ U → y ∈ U → x + y ∈ U) "
    ]
  },
  {
    "docString": "Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 ≤ s2 ↔ ∀ (p : P), p ∈ s1 → p ∈ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is less than or equal to another if and only if all its points are in the second\\nsubspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  (u : ℙ K V), u ∈ Projectivization.Subspace.span S ↔ ∀ (W : Projectivization.Subspace K V), S ⊆ ↑W → u ∈ W\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point in a projective space is contained in the span of a set of points if and only if the\\npoint is contained in all subspaces of the projective space which contain the set of points. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (p : P) (s1 s2 : AffineSubspace k P), p ∈ s1 ⊓ s2 ↔ p ∈ s1 ∧ p ∈ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point is in the inf of two affine subspaces if and only if it is in both of them. \"},\n {\"theorem\":\n  \"∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\\n  (s : ι → Set (ℙ K V)),\\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V},\\n  S ⊆ ↑W → W ≤ Projectivization.Subspace.span S → Projectivization.Subspace.span S = W\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set of points in projective space is contained in a subspace, and that subspace is\\ncontained in the span of the set of points, then the span of the set of points is equal to\\nthe subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {p₁ p₂ : P} {s : AffineSubspace k P}, p₁ ∈ s → p₂ ∈ s → affineSpan k {p₁, p₂} ≤ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of two points that lie in an affine subspace is contained in that subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {s₁ s₂ : AffineSubspace k P},\\n  AffineSubspace.direction s₁ = AffineSubspace.direction s₂ → Set.Nonempty ↑s₁ → s₁ ≤ s₂ → s₁ = s₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an affine subspace is nonempty and contained in another with the same direction, they are\\nequal. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 < s2 ↔ s1 ≤ s2 ∧ ∃ p, p ∈ s2 ∧ ¬p ∈ s1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is less than another if and only if it is less than or equal to the second subspace\\nand there is a point only in the second. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t → s ⊆ t → Monoid.Closure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The submonoid generated by a set is contained in any submonoid that contains the set. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (K₁ K₂ : Submodule 𝕜 E), K₁ᗮ ⊓ K₂ᗮ = (K₁ ⊔ K₂)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of two orthogonal subspaces equals the subspace orthogonal\\nto the sup. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s₁ s₂ : AffineSubspace ℝ P} [inst_4 : Nonempty { x // x ∈ s₁ }]\\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s₁)],\\n  s₁ ≤ s₂ → ∀ {p : P}, p ∈ s₂ → ↑(EuclideanGeometry.reflection s₁) p ∈ s₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reflection of a point in a subspace is contained in any larger\\nsubspace containing both the point and the subspace reflected in. \"}]\n",
    "prompt_cons": "/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- One subspace is less than or equal to another if and only if all its points are in the second\nsubspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 ≤ s2 ↔ ∀ (p : P), p ∈ s1 → p ∈ s2 :=\n\n/-- A point in a projective space is contained in the span of a set of points if and only if the\npoint is contained in all subspaces of the projective space which contain the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  (u : ℙ K V), u ∈ Projectivization.Subspace.span S ↔ ∀ (W : Projectivization.Subspace K V), S ⊆ ↑W → u ∈ W :=\n\n/-- A point is in the inf of two affine subspaces if and only if it is in both of them. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (p : P) (s1 s2 : AffineSubspace k P), p ∈ s1 ⊓ s2 ↔ p ∈ s1 ∧ p ∈ s2 :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem ∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Set (ℙ K V)),\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i) :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- If a set of points in projective space is contained in a subspace, and that subspace is\ncontained in the span of the set of points, then the span of the set of points is equal to\nthe subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V},\n  S ⊆ ↑W → W ≤ Projectivization.Subspace.span S → Projectivization.Subspace.span S = W :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2 :=\n\n/-- The span of two points that lie in an affine subspace is contained in that subspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p₁ p₂ : P} {s : AffineSubspace k P}, p₁ ∈ s → p₂ ∈ s → affineSpan k {p₁, p₂} ≤ s :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- If an affine subspace is nonempty and contained in another with the same direction, they are\nequal. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s₁ s₂ : AffineSubspace k P},\n  AffineSubspace.direction s₁ = AffineSubspace.direction s₂ → Set.Nonempty ↑s₁ → s₁ ≤ s₂ → s₁ = s₂ :=\n\n/-- A subspace is less than another if and only if it is less than or equal to the second subspace\nand there is a point only in the second. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 < s2 ↔ s1 ≤ s2 ∧ ∃ p, p ∈ s2 ∧ ¬p ∈ s1 :=\n\n/-- The submonoid generated by a set is contained in any submonoid that contains the set. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {s t : Set M}, IsSubmonoid t → s ⊆ t → Monoid.Closure s ⊆ t :=\n\n/-- The inf of two orthogonal subspaces equals the subspace orthogonal\nto the sup. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (K₁ K₂ : Submodule 𝕜 E), K₁ᗮ ⊓ K₂ᗮ = (K₁ ⊔ K₂)ᗮ :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem ∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- Affine subspaces are convex. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- The reflection of a point in a subspace is contained in any larger\nsubspace containing both the point and the subspace reflected in. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s₁ s₂ : AffineSubspace ℝ P} [inst_4 : Nonempty { x // x ∈ s₁ }]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s₁)],\n  s₁ ≤ s₂ → ∀ {p : P}, p ∈ s₂ → ↑(EuclideanGeometry.reflection s₁) p ∈ s₂ :=\n\n/-- Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other. -/\ntheorem",
    "choices": [
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W₁ W₂ : Submodule K V), IsSubmodule (W₁ ∪ W₂) ↔ W₁ ≤ W₂ ∨ W₂ ≤ W₁ "
    ]
  },
  {
    "docString": "Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `T₅` space is a `T₅` space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\\n  U ⟂ V → ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from an orthogonal submodule `V` is the zero map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\\n  MeasurableSet u →\\n    MeasurableSet v →\\n      MeasurableSet w →\\n        MeasureTheory.VectorMeasure.restrict 0 u ≤ MeasureTheory.VectorMeasure.restrict s u →\\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\\n  MeasurableSet u →\\n    MeasurableSet v →\\n      MeasurableSet w →\\n        MeasureTheory.VectorMeasure.restrict s u ≤ MeasureTheory.VectorMeasure.restrict 0 u →\\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (S₁ S₂ : Submodule K V) [h₁ : FiniteDimensional K { x // x ∈ S₁ }] [h₂ : FiniteDimensional K { x // x ∈ S₂ }],\\n  FiniteDimensional K { x // x ∈ S₁ ⊔ S₂ }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sup of two finite-dimensional submodules is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 ↔ U ⟂ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    ↑(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ℝ V] [inst_9 : ContinuousSMul ℝ V]\\n  [inst_10 : FiniteDimensional ℝ V] (μ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure μ],\\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-↑w v))) • f v ∂μ)\\n    (Filter.cocompact (V →L[ℝ] ℝ)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\\ndual space. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- A subspace of a `T₅` space is a `T₅` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x } :=\n\n/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\n  U ⟂ V → ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\n  MeasurableSet u →\n    MeasurableSet v →\n      MeasurableSet w →\n        MeasureTheory.VectorMeasure.restrict 0 u ≤ MeasureTheory.VectorMeasure.restrict s u →\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0 :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\n  MeasurableSet u →\n    MeasurableSet v →\n      MeasurableSet w →\n        MeasureTheory.VectorMeasure.restrict s u ≤ MeasureTheory.VectorMeasure.restrict 0 u →\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0 :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S) :=\n\n/-- The sup of two finite-dimensional submodules is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (S₁ S₂ : Submodule K V) [h₁ : FiniteDimensional K { x // x ∈ S₁ }] [h₂ : FiniteDimensional K { x // x ∈ S₂ }],\n  FiniteDimensional K { x // x ∈ S₁ ⊔ S₂ } :=\n\n/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 ↔ U ⟂ V :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem ∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    ↑(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\n  AffineIndependent k f → Set.Finite s :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S) :=\n\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem ∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ℝ V] [inst_9 : ContinuousSMul ℝ V]\n  [inst_10 : FiniteDimensional ℝ V] (μ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure μ],\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-↑w v))) • f v ∂μ)\n    (Filter.cocompact (V →L[ℝ] ℝ)) (nhds 0) :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} {W : Type w} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : AddCommGroup W] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : V →ₗ[K] W),\n  ∃ (U : Submodule K V), U ⊓ T.ker = ⊥ ∧ T.range = LinearMap.rangeRestrict T U "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `T₅` space is a `T₅` space. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsAddLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under addition. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h + g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsAddRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under addition. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\\n  (s : ι → Set (ℙ K V)),\\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (s : Set (Submodule 𝕜 E)), ⨅ (K : Submodule 𝕜 E) (_ : K ∈ s), Kᗮ = (sSup s)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {σ : R →+* R}\\n  [inst_3 : RingHomSurjective σ] {ι : Sort u_2} (f : M →ₛₗ[σ] M) {p : ι → Submodule R M},\\n  (∀ (i : ι) (v : M), v ∈ p i → ↑f v ∈ p i) → ∀ (v : M), v ∈ iInf p → ↑f v ∈ iInf p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of a family of invariant submodule of an endomorphism is also an invariant\\nsubmodule. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {p : Submodule R M} (hfp : ∀ (x : M), x ∈ p → ↑f x ∈ p) {μ : R},\\n  Disjoint (Module.End.eigenspace f μ) p → Module.End.eigenspace (LinearMap.restrict f hfp) μ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an invariant subspace `p` of an endomorphism `f` is disjoint from the `μ`-eigenspace of `f`,\\nthen the restriction of `f` to `p` has trivial `μ`-eigenspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ K + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V ⊆ U`.\"}]\n",
    "prompt_cons": "/-- A subspace of a `T₅` space is a `T₅` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x } :=\n\n/-- An alternative way to prove that `μ` is left invariant under addition. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsAddLeftInvariant μ :=\n\n/-- An alternative way to prove that `μ` is right invariant under addition. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h + g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsAddRightInvariant μ :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem ∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Set (ℙ K V)),\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i) :=\n\n/-- Affine subspaces are convex. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (s : Set (Submodule 𝕜 E)), ⨅ (K : Submodule 𝕜 E) (_ : K ∈ s), Kᗮ = (sSup s)ᗮ :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ :=\n\n/-- The infimum of a family of invariant submodule of an endomorphism is also an invariant\nsubmodule. -/\ntheorem ∀ {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {σ : R →+* R}\n  [inst_3 : RingHomSurjective σ] {ι : Sort u_2} (f : M →ₛₗ[σ] M) {p : ι → Submodule R M},\n  (∀ (i : ι) (v : M), v ∈ p i → ↑f v ∈ p i) → ∀ (v : M), v ∈ iInf p → ↑f v ∈ iInf p :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S) :=\n\n/-- If an invariant subspace `p` of an endomorphism `f` is disjoint from the `μ`-eigenspace of `f`,\nthen the restriction of `f` to `p` has trivial `μ`-eigenspace. -/\ntheorem ∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {p : Submodule R M} (hfp : ∀ (x : M), x ∈ p → ↑f x ∈ p) {μ : R},\n  Disjoint (Module.End.eigenspace f μ) p → Module.End.eigenspace (LinearMap.restrict f hfp) μ = ⊥ :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U :=\n\n/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulLeftInvariant μ :=\n\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulRightInvariant μ :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ K + V ⊆ U :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V →ₗ[K] V}\n  {U : ℕ → Submodule K V} (hT : ∀ (i : ℕ) (x : V), x ∈ U i → T x ∈ U i),\n  ∀ (x : V), x ∈ (⨆ (i : ℕ), U i) → T x ∈ (⨆ (i : ℕ), U i) "
    ]
  },
  {
    "docString": "Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  (v : E) (μ : Module.End.Eigenvalues T),\\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U ≤ V → ∀ (x : E), ↑(orthogonalProjection U) ↑(↑(orthogonalProjection V) x) = ↑(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U ≤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (S T : V →ₗ[ℂ] V),\\n  (∀ (x : V), inner (↑S x) x = inner (↑T x) x) ↔ S = T\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear maps `S` and `T` are equal, if and only if the identity `⟪S x, x⟫_ℂ = ⟪T x, x⟫_ℂ` holds\\nfor all `x`.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T0Space α] ⦃x y : α⦄, Inseparable x y → x = y\",\n  \"isProp\": true,\n  \"docString\": \"Two inseparable points in a T₀ space are equal. \"},\n {\"theorem\":\n  \"∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {μ : R} {k : ℕ}, Module.End.HasGeneralizedEigenvalue f μ k → Module.End.HasEigenvalue f μ\",\n  \"isProp\": true,\n  \"docString\": \"All generalized eigenvalues are eigenvalues. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  (b : Basis ι R M) {R₁ : Type u_2} [inst_3 : Semiring R₁] {σ : R →+* R₁} {σ' : R₁ →+* R} [inst_4 : RingHomInvPair σ σ']\\n  [inst_5 : RingHomInvPair σ' σ] {M₁ : Type u_4} [inst_6 : AddCommMonoid M₁] [inst_7 : Module R₁ M₁]\\n  {f₁ f₂ : M ≃ₛₗ[σ] M₁}, (∀ (i : ι), ↑f₁ (↑b i) = ↑f₂ (↑b i)) → f₁ = f₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linear equivs are equal if they are equal on basis vectors. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (μ : K) {k : ℕ},\\n  FiniteDimensional.finrank K V ≤ k →\\n    ↑(Module.End.generalizedEigenspace f μ) k = ↑(Module.End.generalizedEigenspace f μ) (FiniteDimensional.finrank K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. \"},\n {\"theorem\":\n  \"∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\\n  {μ : R} {k : ℕ}, 0 < k → Module.End.HasEigenvalue f μ → Module.End.HasGeneralizedEigenvalue f μ k\",\n  \"isProp\": true,\n  \"docString\": \"All eigenvalues are generalized eigenvalues. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every linear operator on a vector space over an algebraically closed field has\\nan eigenvalue. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {ι : Type u_2} (ι' : Finset ι) (s l : ι → S),\\n  (Finset.sum ι' fun i => l i * s i) = 1 →\\n    (∀ (i : ι), s i ∈ S') → (∀ (i : ι), l i ∈ S') → ∀ (x : S), (∀ (i : ι), ∃ n, s i ^ n • x ∈ S') → x ∈ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sᵢ ^ n • x ∈ S'` for some `n` for each `sᵢ`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\\n  (∀ (r : R),\\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T\",\n  \"isProp\": true,\n  \"docString\": \"Two subsemigroups are equal if they have the same elements. \"},\n {\"theorem\": \"RingHom.LocalizationPreserves @RingHom.Finite\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\":\n  \"∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x ∈ Submodule.span R' s → ∃ t, t • x ∈ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\\nthen `t • x ∈ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `σ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T ≤ S →\\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\\n      [inst_5 : Fintype (M ⧸ T)],\\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"}]\n",
    "prompt_cons": "/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  (v : E) (μ : Module.End.Eigenvalues T),\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ :=\n\n/-- If `U ≤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U ≤ V → ∀ (x : E), ↑(orthogonalProjection U) ↑(↑(orthogonalProjection V) x) = ↑(orthogonalProjection U) x :=\n\n/-- Two linear maps `S` and `T` are equal, if and only if the identity `⟪S x, x⟫_ℂ = ⟪T x, x⟫_ℂ` holds\nfor all `x`. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (S T : V →ₗ[ℂ] V),\n  (∀ (x : V), inner (↑S x) x = inner (↑T x) x) ↔ S = T :=\n\n/-- Two inseparable points in a T₀ space are equal. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T0Space α] ⦃x y : α⦄, Inseparable x y → x = y :=\n\n/-- All generalized eigenvalues are eigenvalues. -/\ntheorem ∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {μ : R} {k : ℕ}, Module.End.HasGeneralizedEigenvalue f μ k → Module.End.HasEigenvalue f μ :=\n\n/-- Two linear equivs are equal if they are equal on basis vectors. -/\ntheorem ∀ {ι : Type u_5} {R : Type u_1} {M : Type u_3} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (b : Basis ι R M) {R₁ : Type u_2} [inst_3 : Semiring R₁] {σ : R →+* R₁} {σ' : R₁ →+* R} [inst_4 : RingHomInvPair σ σ']\n  [inst_5 : RingHomInvPair σ' σ] {M₁ : Type u_4} [inst_6 : AddCommMonoid M₁] [inst_7 : Module R₁ M₁]\n  {f₁ f₂ : M ≃ₛₗ[σ] M₁}, (∀ (i : ι), ↑f₁ (↑b i) = ↑f₂ (↑b i)) → f₁ = f₂ :=\n\n/-- Generalized eigenspaces for exponents at least `finrank K V` are equal to each other. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (f : Module.End K V) (μ : K) {k : ℕ},\n  FiniteDimensional.finrank K V ≤ k →\n    ↑(Module.End.generalizedEigenspace f μ) k = ↑(Module.End.generalizedEigenspace f μ) (FiniteDimensional.finrank K V) :=\n\n/-- All eigenvalues are generalized eigenvalues. -/\ntheorem ∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {f : Module.End R M}\n  {μ : R} {k : ℕ}, 0 < k → Module.End.HasEigenvalue f μ → Module.End.HasGeneralizedEigenvalue f μ k :=\n\n/-- Every linear operator on a vector space over an algebraically closed field has\nan eigenvalue. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c :=\n\n/-- Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\n`sᵢ ^ n • x ∈ S'` for some `n` for each `sᵢ`. -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {ι : Type u_2} (ι' : Finset ι) (s l : ι → S),\n  (Finset.sum ι' fun i => l i * s i) = 1 →\n    (∀ (i : ι), s i ∈ S') → (∀ (i : ι), l i ∈ S') → ∀ (x : S), (∀ (i : ι), ∃ n, s i ^ n • x ∈ S') → x ∈ S' :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\n  (∀ (r : R),\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- Two subsemigroups are equal if they have the same elements. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T :=\n\n/-- If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. -/\ntheorem RingHom.LocalizationPreserves @RingHom.Finite :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x :=\n\n/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\nthen `t • x ∈ span R s` for some `t : M`. -/\ntheorem ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x ∈ Submodule.span R' s → ∃ t, t • x ∈ Submodule.span R s :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- If two `σ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T ≤ S →\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\n      [inst_5 : Fintype (M ⧸ T)],\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T) :=\n\n/-- Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues. -/\ntheorem",
    "choices": [
      "∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Module.End K V),\n  Module.End.eigenvalues S T = Module.End.eigenvalues T S "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace 𝕜 V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\\n    fun p => p.fst • p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V ≤ 1 ↔ ∃ v₀, ∀ (v : V), ∃ r, r • v₀ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 • x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (a b : M),\\n  ↑(CliffordAlgebra.ι Q) a * ↑(CliffordAlgebra.ι Q) b + ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\\n    ↑(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (↑Q) a b)\",\n  \"isProp\": true,\n  \"docString\": \"The symmetric product of vectors is a scalar \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `T₅` space is a `T₅` space. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (i : ι) (c : R) (x : M i),\\n  ↑(DirectSum.of M i) (c • x) = c • ↑(DirectSum.of M i) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Scalar multiplication commutes with the inclusion of each component into the direct sum. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x : F) (r : ℝ),\\n  inner x (r • x) = r * (‖x‖ * ‖x‖)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product of a vector with a multiple of itself. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\\n  [inst_3 : Fintype ι] {b : ι → V}, LinearIndependent K b ↔ Fintype.card ι = Set.finrank K (Set.range b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite family of vectors is linearly independent if and only if\\nits cardinality equals the dimension of its span. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : InnerProductSpace 𝕜 E'] (f : E →ₗᵢ[𝕜] E') (x y : E),\\n  inner (↑f x) (↑f y) = inner x y\",\n  \"isProp\": true,\n  \"docString\": \"A linear isometry preserves the inner product. \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace 𝕜 V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\n    fun p => p.fst • p.snd :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem ∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V ≤ 1 ↔ ∃ v₀, ∀ (v : V), ∃ r, r • v₀ = v :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 • x = x :=\n\n/-- The symmetric product of vectors is a scalar -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (a b : M),\n  ↑(CliffordAlgebra.ι Q) a * ↑(CliffordAlgebra.ι Q) b + ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\n    ↑(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (↑Q) a b) :=\n\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulRightInvariant μ :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- A subspace of a `T₅` space is a `T₅` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x } :=\n\n/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulLeftInvariant μ :=\n\n/-- Scalar multiplication commutes with the inclusion of each component into the direct sum. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (i : ι) (c : R) (x : M i),\n  ↑(DirectSum.of M i) (c • x) = c • ↑(DirectSum.of M i) x :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem ∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The inner product of a vector with a multiple of itself. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x : F) (r : ℝ),\n  inner x (r • x) = r * (‖x‖ * ‖x‖) :=\n\n/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  [inst_3 : Fintype ι] {b : ι → V}, LinearIndependent K b ↔ Fintype.card ι = Set.finrank K (Set.range b) :=\n\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂ :=\n\n/-- A linear isometry preserves the inner product. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {E' : Type u_3} [inst_3 : NormedAddCommGroup E'] [inst_4 : InnerProductSpace 𝕜 E'] (f : E →ₗᵢ[𝕜] E') (x y : E),\n  inner (↑f x) (↑f y) = inner x y :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V]\n  (T : Module.End K V),\n  (∀ (W : Submodule K V), FiniteDimensional.finrank K { x // x ∈ W } = FiniteDimensional.finrank K V - 1 → W ≤ T.ker → W = T.ker) →\n  ∃ (c : K), T = c • LinearMap.id "
    ]
  },
  {
    "docString": "Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"The dimension of a finite dimensional space is preserved under linear equivalence. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `T₅` space is a `T₅` space. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if and only if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\\n  FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F → Nonempty (E ≃L[𝕜] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ℝ V] [inst_9 : ContinuousSMul ℝ V]\\n  [inst_10 : FiniteDimensional ℝ V] (μ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure μ],\\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-↑w v))) • f v ∂μ)\\n    (Filter.cocompact (V →L[ℝ] ℝ)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\\ndual space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'],\\n  (M ≃ₗ[R] M') → Cardinal.lift (Module.rank R M) = Cardinal.lift (Module.rank R M')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension, a version with different\\nuniverses. \"},\n {\"theorem\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"}]\n",
    "prompt_cons": "/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem ∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The dimension of a finite dimensional space is preserved under linear equivalence. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]\n  [inst_3 : Module R M] [inst_4 : Module R M₂],\n  (M ≃ₗ[R] M₂) → FiniteDimensional.finrank R M = FiniteDimensional.finrank R M₂ :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- A subspace of a `T₅` space is a `T₅` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x } :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F :=\n\n/-- Affine subspaces are convex. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if they have the same (finite) dimension. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\n  FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F → Nonempty (E ≃L[𝕜] F) :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem ∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ℝ V] [inst_9 : ContinuousSMul ℝ V]\n  [inst_10 : FiniteDimensional ℝ V] (μ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure μ],\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-↑w v))) • f v ∂μ)\n    (Filter.cocompact (V →L[ℝ] ℝ)) (nhds 0) :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- Two linearly equivalent vector spaces have the same dimension, a version with different\nuniverses. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M' : Type v'}\n  [inst_3 : AddCommGroup M'] [inst_4 : Module R M'],\n  (M ≃ₗ[R] M') → Cardinal.lift (Module.rank R M) = Cardinal.lift (Module.rank R M') :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W) :=\n\n/-- Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension. -/\ntheorem",
    "choices": [
      "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : Module.End ℝ V),\n  (∀ (λ : ℝ), ¬Module.End.HasEigenvalue T λ) →\n    ∀ (W : Submodule ℝ V), (∀ (w : V), w ∈ W → T w ∈ W) → Even (FiniteDimensional.finrank ℝ { x // x ∈ W }) "
    ]
  },
  {
    "docString": "Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] (a b : α), a ≤ a * b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a ≤ a * b` \"},\n {\"theorem\":\n  \"∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : AddCommMonoid M] (a b : ℕ) (f : ℕ → ℕ → M),\\n  (Finset.sum (Finset.Ico a b) fun i => Finset.sum (Finset.Ico i b) fun j => f i j) =\\n    Finset.sum (Finset.Ico a b) fun j => Finset.sum (Finset.Ico a (j + 1)) fun i => f i j\",\n  \"isProp\": true,\n  \"docString\":\n  \"The two ways of summing over `(i,j)` in the range `a<=i<=j<b` are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a ≤ a + b` \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner x y * inner x y ≤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchy–Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {α : Type u_1} [inst : LinearOrderedRing α] {s : Finset ι} {f : ι → α},\\n  (Finset.sum s fun i => f i) ^ 2 ≤ ↑(Finset.card s) * Finset.sum s fun i => f i ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of **Chebyshev's Sum Inequality** or the **Cauchy-Schwarz Inequality**: The square\\nof the sum is less than the size of the set times the sum of the squares. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] {a b : α}, a ≤ b → ∃ c, b = a * c\",\n  \"isProp\": true,\n  \"docString\": \"For `a ≤ b`, there is a `c` so `b = a * c`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_3} (x : E) {v : ι → E}, Orthonormal 𝕜 v → ∑' (i : ι), ‖inner (v i) x‖ ^ 2 ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -1 ≤ a → ∀ (n : ℕ), 1 + ↑n * (a - 1) ≤ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"Bernoulli's inequality reformulated to estimate `a^n`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (x y : M ⧸ S), ‖x + y‖ ≤ ‖x‖ + ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"The quotient norm satisfies the triangle inequality. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : LocallyFiniteOrder α] {a b c : α},\\n  Finset.uIcc a c ⊆ Finset.uIcc a b ∪ Finset.uIcc b c\",\n  \"isProp\": true,\n  \"docString\": \"A sort of triangle inequality. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\\nPicard-Lindelöf/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -2 ≤ a → ∀ (n : ℕ), 1 + ↑n * a ≤ (1 + a) ^ n\",\n  \"isProp\": true,\n  \"docString\": \"Bernoulli's inequality for `n : ℕ`, `-2 ≤ a`. \"},\n {\"theorem\":\n  \"∀ (N : ℕ) {j : ℝ},\\n  0 < j →\\n    ∀ {c : ℝ},\\n      1 < c →\\n        (Finset.sum (Finset.filter (fun x => j < ↑⌊c ^ x⌋₊) (Finset.range N)) fun i => 1 / ↑⌊c ^ i⌋₊ ^ 2) ≤\\n          c ^ 5 * (c - 1)⁻¹ ^ 3 / j ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of `1/⌊c^i⌋₊^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\\nconstant. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) (p : ℕ → ℝ),\\n  (∀ (k : ℕ), 0 ≤ p k) →\\n    ∀ {r a : ℝ},\\n      0 ≤ r →\\n        0 ≤ a →\\n          (Finset.sum (Finset.Ico 2 (n + 1)) fun k =>\\n              a ^ k *\\n                Finset.sum (Set.toFinset {c | 1 < Composition.length c}) fun c =>\\n                  r ^ Composition.length c * Finset.prod Finset.univ fun j => p (Composition.blocksFun c j)) ≤\\n            Finset.sum (Finset.Ico 2 (n + 1)) fun j => r ^ j * (Finset.sum (Finset.Ico 1 n) fun k => a ^ k * p k) ^ j\",\n  \"isProp\": true,\n  \"docString\":\n  \"First technical lemma to control the growth of coefficients of the inverse. Bound the explicit\\nexpression for `∑_{k<n+1} aᵏ Qₖ` in terms of a sum of powers of the same sum one step before,\\nin a general abstract setup. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_3} (x : E) {v : ι → E}, Orthonormal 𝕜 v → Summable fun i => ‖inner (v i) x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"The sum defined in Bessel's inequality is summable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an ordered semiring, we can multiply an inequality `a ≤ b` on the right\\nby a non-negative element `0 ≤ c` to obtain `a * c ≤ b * c`. \"}]\n",
    "prompt_cons": "/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- For any `a` and `b`, `a ≤ a * b` -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] (a b : α), a ≤ a * b :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem ∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- The two ways of summing over `(i,j)` in the range `a<=i<=j<b` are equal. -/\ntheorem ∀ {M : Type u_1} [inst : AddCommMonoid M] (a b : ℕ) (f : ℕ → ℕ → M),\n  (Finset.sum (Finset.Ico a b) fun i => Finset.sum (Finset.Ico i b) fun j => f i j) =\n    Finset.sum (Finset.Ico a b) fun j => Finset.sum (Finset.Ico a (j + 1)) fun i => f i j :=\n\n/-- For any `a` and `b`, `a ≤ a + b` -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b :=\n\n/-- Cauchy–Schwarz inequality for real inner products. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner x y * inner x y ≤ inner x x * inner y y :=\n\n/-- Special case of **Chebyshev's Sum Inequality** or the **Cauchy-Schwarz Inequality**: The square\nof the sum is less than the size of the set times the sum of the squares. -/\ntheorem ∀ {ι : Type u_2} {α : Type u_1} [inst : LinearOrderedRing α] {s : Finset ι} {f : ι → α},\n  (Finset.sum s fun i => f i) ^ 2 ≤ ↑(Finset.card s) * Finset.sum s fun i => f i ^ 2 :=\n\n/-- For `a ≤ b`, there is a `c` so `b = a * c`. -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] {a b : α}, a ≤ b → ∃ c, b = a * c :=\n\n/-- Bessel's inequality. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} (x : E) {v : ι → E}, Orthonormal 𝕜 v → ∑' (i : ι), ‖inner (v i) x‖ ^ 2 ≤ ‖x‖ ^ 2 :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Bernoulli's inequality reformulated to estimate `a^n`. -/\ntheorem ∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -1 ≤ a → ∀ (n : ℕ), 1 + ↑n * (a - 1) ≤ a ^ n :=\n\n/-- The quotient norm satisfies the triangle inequality. -/\ntheorem ∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M) (x y : M ⧸ S), ‖x + y‖ ≤ ‖x‖ + ‖y‖ :=\n\n/-- A sort of triangle inequality. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : LocallyFiniteOrder α] {a b c : α},\n  Finset.uIcc a c ⊆ Finset.uIcc a b ∪ Finset.uIcc b c :=\n\n/-- Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\nPicard-Lindelöf/Cauchy-Lipschitz theorem. -/\ntheorem ∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1) :=\n\n/-- Bernoulli's inequality for `n : ℕ`, `-2 ≤ a`. -/\ntheorem ∀ {R : Type u₁} [inst : LinearOrderedRing R] {a : R}, -2 ≤ a → ∀ (n : ℕ), 1 + ↑n * a ≤ (1 + a) ^ n :=\n\n/-- The sum of `1/⌊c^i⌋₊^2` above a threshold `j` is comparable to `1/j^2`, up to a multiplicative\nconstant. -/\ntheorem ∀ (N : ℕ) {j : ℝ},\n  0 < j →\n    ∀ {c : ℝ},\n      1 < c →\n        (Finset.sum (Finset.filter (fun x => j < ↑⌊c ^ x⌋₊) (Finset.range N)) fun i => 1 / ↑⌊c ^ i⌋₊ ^ 2) ≤\n          c ^ 5 * (c - 1)⁻¹ ^ 3 / j ^ 2 :=\n\n/-- First technical lemma to control the growth of coefficients of the inverse. Bound the explicit\nexpression for `∑_{k<n+1} aᵏ Qₖ` in terms of a sum of powers of the same sum one step before,\nin a general abstract setup. -/\ntheorem ∀ (n : ℕ) (p : ℕ → ℝ),\n  (∀ (k : ℕ), 0 ≤ p k) →\n    ∀ {r a : ℝ},\n      0 ≤ r →\n        0 ≤ a →\n          (Finset.sum (Finset.Ico 2 (n + 1)) fun k =>\n              a ^ k *\n                Finset.sum (Set.toFinset {c | 1 < Composition.length c}) fun c =>\n                  r ^ Composition.length c * Finset.prod Finset.univ fun j => p (Composition.blocksFun c j)) ≤\n            Finset.sum (Finset.Ico 2 (n + 1)) fun j => r ^ j * (Finset.sum (Finset.Ico 1 n) fun k => a ^ k * p k) ^ j :=\n\n/-- The sum defined in Bessel's inequality is summable. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} (x : E) {v : ι → E}, Orthonormal 𝕜 v → Summable fun i => ‖inner (v i) x‖ ^ 2 :=\n\n/-- In an ordered semiring, we can multiply an inequality `a ≤ b` on the right\nby a non-negative element `0 ≤ c` to obtain `a * c ≤ b * c`. -/\ntheorem ∀ {α : Type u} [self : OrderedSemiring α] (a b c : α), a ≤ b → 0 ≤ c → a * c ≤ b * c :=\n\n/-- Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ} {a b : ℕ → ℝ},\n  (Finset.sum (Finset.range (n + 1)) fun j => a j * b j) ^ 2 ≤\n    (Finset.sum (Finset.range (n + 1)) fun j => ↑j * a j ^ 2) *\n      (Finset.sum (Finset.range (n + 1)) fun j => b j ^ 2 / ↑j) "
    ]
  },
  {
    "docString": "Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {s : Set E},\\n  Orthonormal 𝕜 Subtype.val →\\n    ∃ w _hw, Orthonormal 𝕜 Subtype.val ∧ ∀ (u : Set E), u ⊇ w → Orthonormal 𝕜 Subtype.val → u = w\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\\ncontaining it. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner (x + y) (x - y) = 0 ↔ ‖x‖ = ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum and difference of two vectors are orthogonal if and only\\nif they have the same norm. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_3} {v : ι → E}, Orthonormal 𝕜 v → LinearIndependent 𝕜 v\",\n  \"isProp\": true,\n  \"docString\": \"An orthonormal set is linearly independent. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedSpace ℝ E] [inst_4 : LinearMap.CompatibleSMul E E 𝕜 ℝ],\\n  StrictConvex 𝕜 (Metric.closedBall 0 1) → StrictConvexSpace 𝕜 E\",\n  \"isProp\": true,\n  \"docString\":\n  \"A real normed vector space is strictly convex provided that the unit ball is strictly convex. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\\n  x ≠ 0 → y ≠ 0 → (‖x + y‖ = ‖x‖ + ‖y‖ ↔ InnerProductGeometry.angle x y = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the sum of two non-zero vectors equals the sum of their norms\\nif and only the angle between the two vectors is 0. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] {x : E},\\n  x ≠ 0 → ‖(↑‖x‖)⁻¹ • x‖ = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lemma to normalize a vector in a normed space `E` over either `ℂ` or `ℝ` to unit length. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} [inst_3 : Fintype ι] {v : ι → E},\\n  Orthonormal 𝕜 v → ∀ (l : ι → 𝕜) (i : ι), inner (v i) (Finset.sum Finset.univ fun i => l i • v i) = l i\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of a linear combination of a set of orthonormal vectors with one of those\\nvectors picks out the coefficient of that vector. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] {n : ℕ}\\n  [_i : Fact (FiniteDimensional.finrank ℝ E = n)] (o : Orientation ℝ E (Fin n)) {v : Fin n → E},\\n  (Pairwise fun i j => inner (v i) (v j) = 0) → |↑(Orientation.volumeForm o) v| = Finset.prod Finset.univ fun i => ‖v i‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\\nsign, the product of the norms of the vectors `v i`. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\\n  x ≠ 0 → y ≠ 0 → (inner x y = ‖x‖ * ‖y‖ ↔ InnerProductGeometry.angle x y = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two non-zero vectors equals the product of their norms\\nif and only if the angle between the two vectors is 0. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_3} {v : ι → E},\\n  Orthonormal 𝕜 v →\\n    ∀ {s : Set ι} {i : ι},\\n      ¬i ∈ s → ∀ {l : ι →₀ 𝕜}, l ∈ Finsupp.supported 𝕜 𝕜 s → inner (↑(Finsupp.total ι E 𝕜 v) l) (v i) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear combination of some subset of an orthonormal set is orthogonal to other members of the\\nset. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\\n  ‖x‖ = ‖y‖ → (x = y ↔ Orientation.oangle o x y = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vectors with equal norms are equal if and only if they have zero angle between them. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  ‖x + y‖ = ‖x - y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the sum of two vectors equals the norm of their difference if and only if\\nthe angle between them is π/2. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-only-if vector inner product form. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\\n  [inst_3 : Fintype ι] {b : ι → V}, LinearIndependent K b ↔ Fintype.card ι = Set.finrank K (Set.range b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite family of vectors is linearly independent if and only if\\nits cardinality equals the dimension of its span. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} [inst_3 : Fintype ι] {V : ι → Submodule 𝕜 E} [inst_4 : ∀ (i : ι), CompleteSpace { x // x ∈ V i }],\\n  (OrthogonalFamily 𝕜 (fun i => { x // x ∈ V i }) fun i => Submodule.subtypeₗᵢ (V i)) →\\n    ∀ (x : E), x ∈ iSup V → (Finset.sum Finset.univ fun i => ↑(↑(orthogonalProjection (V i)) x)) = x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` lies within an orthogonal family `v`, it can be expressed as a sum of projections. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  |inner x y / (‖x‖ * ‖y‖)| = 1 ↔ x ≠ 0 ∧ ∃ r, r ≠ 0 ∧ y = r • x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two vectors, divided by the product of their\\nnorms, has absolute value 1 if and only if they are nonzero and one is\\na multiple of the other. One form of equality case for Cauchy-Schwarz. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner x y / (‖x‖ * ‖y‖) = 1 ↔ x ≠ 0 ∧ ∃ r, 0 < r ∧ y = r • x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two vectors, divided by the product of their\\nnorms, has value 1 if and only if they are nonzero and one is\\na positive multiple of the other. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_3} {v w : ι → E}, Orthonormal 𝕜 v → (∀ (i : ι), w i = v i ∨ w i = -v i) → Orthonormal 𝕜 w\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an orthonormal family, a second family of vectors is orthonormal if every vector equals\\nthe corresponding vector in the original family or its negation. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V),\\n  x = y ↔ ‖x‖ = ‖y‖ ∧ Orientation.oangle o x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vectors are equal if and only if they have equal norms and zero angle between them. \"}]\n",
    "prompt_cons": "/-- Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\ncontaining it. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {s : Set E},\n  Orthonormal 𝕜 Subtype.val →\n    ∃ w _hw, Orthonormal 𝕜 Subtype.val ∧ ∀ (u : Set E), u ⊇ w → Orthonormal 𝕜 Subtype.val → u = w :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- The sum and difference of two vectors are orthogonal if and only\nif they have the same norm. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner (x + y) (x - y) = 0 ↔ ‖x‖ = ‖y‖ :=\n\n/-- An orthonormal set is linearly independent. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E}, Orthonormal 𝕜 v → LinearIndependent 𝕜 v :=\n\n/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem ∀ (𝕜 : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedSpace ℝ E] [inst_4 : LinearMap.CompatibleSMul E E 𝕜 ℝ],\n  StrictConvex 𝕜 (Metric.closedBall 0 1) → StrictConvexSpace 𝕜 E :=\n\n/-- The norm of the sum of two non-zero vectors equals the sum of their norms\nif and only the angle between the two vectors is 0. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  x ≠ 0 → y ≠ 0 → (‖x + y‖ = ‖x‖ + ‖y‖ ↔ InnerProductGeometry.angle x y = 0) :=\n\n/-- Lemma to normalize a vector in a normed space `E` over either `ℂ` or `ℝ` to unit length. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] {x : E},\n  x ≠ 0 → ‖(↑‖x‖)⁻¹ • x‖ = 1 :=\n\n/-- The inner product of a linear combination of a set of orthonormal vectors with one of those\nvectors picks out the coefficient of that vector. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} [inst_3 : Fintype ι] {v : ι → E},\n  Orthonormal 𝕜 v → ∀ (l : ι → 𝕜) (i : ι), inner (v i) (Finset.sum Finset.univ fun i => l i • v i) = l i :=\n\n/-- Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\nsign, the product of the norms of the vectors `v i`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] {n : ℕ}\n  [_i : Fact (FiniteDimensional.finrank ℝ E = n)] (o : Orientation ℝ E (Fin n)) {v : Fin n → E},\n  (Pairwise fun i j => inner (v i) (v j) = 0) → |↑(Orientation.volumeForm o) v| = Finset.prod Finset.univ fun i => ‖v i‖ :=\n\n/-- The inner product of two non-zero vectors equals the product of their norms\nif and only if the angle between the two vectors is 0. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  x ≠ 0 → y ≠ 0 → (inner x y = ‖x‖ * ‖y‖ ↔ InnerProductGeometry.angle x y = 0) :=\n\n/-- A linear combination of some subset of an orthonormal set is orthogonal to other members of the\nset. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E},\n  Orthonormal 𝕜 v →\n    ∀ {s : Set ι} {i : ι},\n      ¬i ∈ s → ∀ {l : ι →₀ 𝕜}, l ∈ Finsupp.supported 𝕜 𝕜 s → inner (↑(Finsupp.total ι E 𝕜 v) l) (v i) = 0 :=\n\n/-- Two vectors with equal norms are equal if and only if they have zero angle between them. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  ‖x‖ = ‖y‖ → (x = y ↔ Orientation.oangle o x y = 0) :=\n\n/-- The norm of the sum of two vectors equals the norm of their difference if and only if\nthe angle between them is π/2. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n  ‖x + y‖ = ‖x - y‖ ↔ InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- Pythagorean theorem, if-and-only-if vector inner product form. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ ↔ inner x y = 0 :=\n\n/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  [inst_3 : Fintype ι] {b : ι → V}, LinearIndependent K b ↔ Fintype.card ι = Set.finrank K (Set.range b) :=\n\n/-- If `x` lies within an orthogonal family `v`, it can be expressed as a sum of projections. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} [inst_3 : Fintype ι] {V : ι → Submodule 𝕜 E} [inst_4 : ∀ (i : ι), CompleteSpace { x // x ∈ V i }],\n  (OrthogonalFamily 𝕜 (fun i => { x // x ∈ V i }) fun i => Submodule.subtypeₗᵢ (V i)) →\n    ∀ (x : E), x ∈ iSup V → (Finset.sum Finset.univ fun i => ↑(↑(orthogonalProjection (V i)) x)) = x :=\n\n/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  |inner x y / (‖x‖ * ‖y‖)| = 1 ↔ x ≠ 0 ∧ ∃ r, r ≠ 0 ∧ y = r • x :=\n\n/-- The inner product of two vectors, divided by the product of their\nnorms, has value 1 if and only if they are nonzero and one is\na positive multiple of the other. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner x y / (‖x‖ * ‖y‖) = 1 ↔ x ≠ 0 ∧ ∃ r, 0 < r ∧ y = r • x :=\n\n/-- Given an orthonormal family, a second family of vectors is orthonormal if every vector equals\nthe corresponding vector in the original family or its negation. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v w : ι → E}, Orthonormal 𝕜 v → (∀ (i : ι), w i = v i ∨ w i = -v i) → Orthonormal 𝕜 w :=\n\n/-- Two vectors are equal if and only if they have equal norms and zero angle between them. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V),\n  x = y ↔ ‖x‖ = ‖y‖ ∧ Orientation.oangle o x y = 0 :=\n\n/-- Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace 𝕜 V]\n  {m : ℕ} {v : V} {e : Finₓ m → V}, Orthonormal 𝕜 e →\n  (‖v‖ * ‖v‖ = Finset.sum Finset.univ (λ i, abs (inner v (e i)) * abs (inner v (e i))) ↔\n   v ∈ Submodule.span 𝕜 (Set.range e)) "
    ]
  },
  {
    "docString": "Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), ¬s1 ≤ s2 ↔ ∃ p, p ∈ s1 ∧ ¬p ∈ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is not less than or equal to another if and only if it has a point not in the\\nsecond subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F)\\n  [inst_6 : RingHomIsometric σ₁₂], ‖f‖ = 0 ↔ f = 0\",\n  \"isProp\": true,\n  \"docString\": \"An operator is zero iff its norm vanishes. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\\n  [inst_5 : NormedSpace 𝕜 G] (f g : ContinuousMultilinearMap 𝕜 E G), ‖f + g‖ ≤ ‖f‖ + ‖g‖\",\n  \"isProp\": true,\n  \"docString\": \"The operator norm satisfies the triangle inequality. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M),\\n  ↑(AddSubgroup.topologicalClosure S) ≠ Set.univ → ‖AddSubgroup.normedMk S‖ = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The operator norm of the projection is `1` if the subspace is not dense. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) (μ : 𝕜),\\n  Module.End.eigenspace\\n      (LinearMap.restrict T\\n        (_ : ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ))\\n      μ =\\n    ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space has no eigenvalues. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : ∀ (i : ι), CompactSpace (π i)],\\n  LocallyCompactSpace ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\\n  [inst : T2Space α], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible T₂ space. \"},\n {\"theorem\":\n  \"∀ {V₁ : Type u_1} {V₂ : Type u_2} [inst : NormedAddCommGroup V₁] [inst_1 : NormedAddCommGroup V₂]\\n  {f : NormedAddGroupHom V₁ V₂}, ‖f‖ = 0 ↔ f = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For normed groups, an operator is zero iff its norm vanishes. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace ℝ P} [inst_4 : Nonempty { x // x ∈ s }]\\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\\n  ¬p ∈ s → dist p ↑(↑(EuclideanGeometry.orthogonalProjection s) p) ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance between a point and its orthogonal projection is\\nnonzero if it does not lie in the subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_6} {E : Type u_3} {F : Type u_4} {G : Type u_5}\\n  [inst : SeminormedAddCommGroup E] [inst_1 : SeminormedAddCommGroup F] [inst_2 : SeminormedAddCommGroup G]\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NontriviallyNormedField 𝕜₂] [inst_5 : NontriviallyNormedField 𝕜₃]\\n  [inst_6 : NormedSpace 𝕜 E] [inst_7 : NormedSpace 𝕜₂ F] [inst_8 : NormedSpace 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃}\\n  {σ₁₃ : 𝕜 →+* 𝕜₃} [inst_9 : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [inst_10 : RingHomIsometric σ₁₂]\\n  [inst_11 : RingHomIsometric σ₂₃] (h : F →SL[σ₂₃] G) (f : E →SL[σ₁₂] F), ‖ContinuousLinearMap.comp h f‖ ≤ ‖h‖ * ‖f‖\",\n  \"isProp\": true,\n  \"docString\": \"The operator norm is submultiplicative. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\\n  IsClosed s → ∀ [inst_2 : DiscreteTopology ↑s], Cardinal.continuum ≤ Cardinal.mk ↑s → ¬NormalSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\\nhas cardinality at least continuum, then the ambient space is not a normal space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\\n  [inst_4 : NoZeroSMulDivisors K V], 0 < FiniteDimensional.finrank K V → Nontrivial V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite dimensional space is nontrivial if it has positive `finrank`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : CompleteSpace E]\\n  [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ℝ F] [inst_5 : CompleteSpace F] {f : E → F} {φ : E → ℝ} {x₀ : E}\\n  {f' : E →L[ℝ] F} {φ' : E →L[ℝ] ℝ},\\n  IsLocalExtrOn φ {x | f x = f x₀} x₀ →\\n    HasStrictFDerivAt f f' x₀ → HasStrictFDerivAt φ φ' x₀ → LinearMap.range (ContinuousLinearMap.prod f' φ') ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lagrange multipliers theorem: if `φ : E → ℝ` has a local extremum on the set `{x | f x = f x₀}`\\nat `x₀`, both `f : E → F` and `φ` are strictly differentiable at `x₀`, and the codomain of `f` is\\na complete space, then the linear map `x ↦ (f' x, φ' x)` is not surjective. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if and only if they have the same (finite) dimension. \"}]\n",
    "prompt_cons": "/-- One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), ¬s1 ≤ s2 ↔ ∃ p, p ∈ s1 ∧ ¬p ∈ s2 :=\n\n/-- An operator is zero iff its norm vanishes. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F)\n  [inst_6 : RingHomIsometric σ₁₂], ‖f‖ = 0 ↔ f = 0 :=\n\n/-- The operator norm satisfies the triangle inequality. -/\ntheorem ∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace 𝕜 G] (f g : ContinuousMultilinearMap 𝕜 E G), ‖f + g‖ ≤ ‖f‖ + ‖g‖ :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- The operator norm of the projection is `1` if the subspace is not dense. -/\ntheorem ∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M),\n  ↑(AddSubgroup.topologicalClosure S) ≠ Set.univ → ‖AddSubgroup.normedMk S‖ = 1 :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) (μ : 𝕜),\n  Module.End.eigenspace\n      (LinearMap.restrict T\n        (_ : ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ))\n      μ =\n    ⊥ :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : ∀ (i : ι), CompactSpace (π i)],\n  LocallyCompactSpace ((i : ι) → π i) :=\n\n/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\n  [inst : T2Space α], False :=\n\n/-- For normed groups, an operator is zero iff its norm vanishes. -/\ntheorem ∀ {V₁ : Type u_1} {V₂ : Type u_2} [inst : NormedAddCommGroup V₁] [inst_1 : NormedAddCommGroup V₂]\n  {f : NormedAddGroupHom V₁ V₂}, ‖f‖ = 0 ↔ f = 0 :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- The distance between a point and its orthogonal projection is\nnonzero if it does not lie in the subspace. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace ℝ P} [inst_4 : Nonempty { x // x ∈ s }]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\n  ¬p ∈ s → dist p ↑(↑(EuclideanGeometry.orthogonalProjection s) p) ≠ 0 :=\n\n/-- The operator norm is submultiplicative. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {𝕜₃ : Type u_6} {E : Type u_3} {F : Type u_4} {G : Type u_5}\n  [inst : SeminormedAddCommGroup E] [inst_1 : SeminormedAddCommGroup F] [inst_2 : SeminormedAddCommGroup G]\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NontriviallyNormedField 𝕜₂] [inst_5 : NontriviallyNormedField 𝕜₃]\n  [inst_6 : NormedSpace 𝕜 E] [inst_7 : NormedSpace 𝕜₂ F] [inst_8 : NormedSpace 𝕜₃ G] {σ₁₂ : 𝕜 →+* 𝕜₂} {σ₂₃ : 𝕜₂ →+* 𝕜₃}\n  {σ₁₃ : 𝕜 →+* 𝕜₃} [inst_9 : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] [inst_10 : RingHomIsometric σ₁₂]\n  [inst_11 : RingHomIsometric σ₂₃] (h : F →SL[σ₂₃] G) (f : E →SL[σ₁₂] F), ‖ContinuousLinearMap.comp h f‖ ≤ ‖h‖ * ‖f‖ :=\n\n/-- Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\nhas cardinality at least continuum, then the ambient space is not a normal space. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\n  IsClosed s → ∀ [inst_2 : DiscreteTopology ↑s], Cardinal.continuum ≤ Cardinal.mk ↑s → ¬NormalSpace X :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u)) :=\n\n/-- A finite dimensional space is nontrivial if it has positive `finrank`. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : Nontrivial K]\n  [inst_4 : NoZeroSMulDivisors K V], 0 < FiniteDimensional.finrank K V → Nontrivial V :=\n\n/-- Lagrange multipliers theorem: if `φ : E → ℝ` has a local extremum on the set `{x | f x = f x₀}`\nat `x₀`, both `f : E → F` and `φ` are strictly differentiable at `x₀`, and the codomain of `f` is\na complete space, then the linear map `x ↦ (f' x, φ' x)` is not surjective. -/\ntheorem ∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : CompleteSpace E]\n  [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ℝ F] [inst_5 : CompleteSpace F] {f : E → F} {φ : E → ℝ} {x₀ : E}\n  {f' : E →L[ℝ] F} {φ' : E →L[ℝ] ℝ},\n  IsLocalExtrOn φ {x | f x = f x₀} x₀ →\n    HasStrictFDerivAt f f' x₀ → HasStrictFDerivAt φ φ' x₀ → LinearMap.range (ContinuousLinearMap.prod f' φ') ≠ ⊤ :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F :=\n\n/-- Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V], 2 ≤ FiniteDimensional.finrank 𝕜 V →\n  ¬IsSubspace 𝕜 (SetOf (LinearMap.IsNormal : (V →ₗ[𝕜] V) → Prop)) "
    ]
  },
  {
    "docString": "Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E] {A : E →ₗ[𝕜] E}, IsSelfAdjoint A ↔ ↑LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] (a : { x // x ∈ selfAdjoint A }) {z : ℂ},\\n  z ∈ spectrum ℂ ↑a → z = ↑z.re\",\n  \"isProp\": true,\n  \"docString\": \"Any element of the spectrum of a selfadjoint is real. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ [inst_3 : FiniteDimensional 𝕜 E], (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] {a : A},\\n  IsSelfAdjoint a → spectrum ℂ a = Complex.ofReal' ∘ Complex.re '' spectrum ℂ a\",\n  \"isProp\": true,\n  \"docString\": \"The spectrum of a selfadjoint is real \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) (μ : 𝕜),\\n  Module.End.eigenspace\\n      (LinearMap.restrict T\\n        (_ : ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ))\\n      μ =\\n    ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space has no eigenvalues. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] (U : Submodule 𝕜 E) [inst_4 : CompleteSpace { x // x ∈ U }],\\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U))\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection is self-adjoint. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`⟪T v, v⟫_ℂ` is real for all v.\"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : IsROrC α] [inst_1 : Fintype n] [inst_2 : DecidableEq n] {A : Matrix n n α},\\n  Matrix.IsHermitian A ↔ LinearMap.IsSymmetric (↑Matrix.toEuclideanLin A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A matrix is hermitian iff the corresponding linear map is self adjoint. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Star R] [inst_1 : TrivialStar R] (r : R), IsSelfAdjoint r\",\n  \"isProp\": true,\n  \"docString\": \"All elements are self-adjoint when `star` is trivial. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    ∀ [inst_3 : FiniteDimensional 𝕜 E], DirectSum.IsInternal fun μ => Module.End.eigenspace T (↑T μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives\\nan internal direct sum decomposition of `E`. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every linear operator on a vector space over an algebraically closed field has\\nan eigenvalue. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (T : E →ₗ[𝕜] E), LinearMap.IsSymmetric T ↔ LinearMap.IsSelfAdjoint sesqFormOfInner T\",\n  \"isProp\": true,\n  \"docString\":\n  \"An operator `T` on an inner product space is symmetric if and only if it is\\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"}]\n",
    "prompt_cons": "/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E] {A : E →ₗ[𝕜] E}, IsSelfAdjoint A ↔ ↑LinearMap.adjoint A = A :=\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem ∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] (a : { x // x ∈ selfAdjoint A }) {z : ℂ},\n  z ∈ spectrum ℂ ↑a → z = ↑z.re :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ [inst_3 : FiniteDimensional 𝕜 E], (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ = ⊥ :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ :=\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem ∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] {a : A},\n  IsSelfAdjoint a → spectrum ℂ a = Complex.ofReal' ∘ Complex.re '' spectrum ℂ a :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) (μ : 𝕜),\n  Module.End.eigenspace\n      (LinearMap.restrict T\n        (_ : ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ))\n      μ =\n    ⊥ :=\n\n/-- The orthogonal projection is self-adjoint. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] (U : Submodule 𝕜 E) [inst_4 : CompleteSpace { x // x ∈ U }],\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U)) :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`⟪T v, v⟫_ℂ` is real for all v. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v :=\n\n/-- A matrix is hermitian iff the corresponding linear map is self adjoint. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : IsROrC α] [inst_1 : Fintype n] [inst_2 : DecidableEq n] {A : Matrix n n α},\n  Matrix.IsHermitian A ↔ LinearMap.IsSymmetric (↑Matrix.toEuclideanLin A) :=\n\n/-- All elements are self-adjoint when `star` is trivial. -/\ntheorem ∀ {R : Type u_1} [inst : Star R] [inst_1 : TrivialStar R] (r : R), IsSelfAdjoint r :=\n\n/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives\nan internal direct sum decomposition of `E`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    ∀ [inst_3 : FiniteDimensional 𝕜 E], DirectSum.IsInternal fun μ => Module.End.eigenspace T (↑T μ) :=\n\n/-- Every linear operator on a vector space over an algebraically closed field has\nan eigenvalue. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c :=\n\n/-- An operator `T` on an inner product space is symmetric if and only if it is\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (T : E →ₗ[𝕜] E), LinearMap.IsSymmetric T ↔ LinearMap.IsSelfAdjoint sesqFormOfInner T :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsNormal T →\n    (∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ↔ LinearMap.IsSymmetric T "
    ]
  },
  {
    "docString": "Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.)",
    "prompts": "[{\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`⟪T v, v⟫_ℂ` is real for all v.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {Fₗ : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fₗ]\\n  [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedSpace 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ),\\n  ‖ContinuousLinearMap.smulRight c f‖ = ‖c‖ * ‖f‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"The norm of the tensor product of a scalar linear map and of an element of a normed space\\nis the product of the norms. \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x - y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\\nroots. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  (v : E) (μ : Module.End.Eigenvalues T),\\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner x y * inner x y ≤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchy–Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [self : InnerProductSpace 𝕜 E]\\n  (x : E), ‖x‖ ^ 2 = ↑IsROrC.re (inner x x)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product induces the norm. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E] [_i : Nontrivial E] {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    Module.End.HasEigenvalue T ↑(⨆ (x : { x // x ≠ 0 }), ↑IsROrC.re (inner (↑T ↑x) ↑x) / ‖↑x‖ ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (f : V ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x y : V), Orientation.oangle o x y = ↑(Complex.arg (↑(starRingEnd ℂ) (↑f x) * ↑f y))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\\nterms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) (f : V ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x : V), ↑f (↑(Orientation.rotation o θ) x) = ↑(Real.Angle.expMapCircle θ) * ↑f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\\ncomplex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  |inner x y / (‖x‖ * ‖y‖)| = 1 ↔ x ≠ 0 ∧ ∃ r, r ≠ 0 ∧ y = r • x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product of two vectors, divided by the product of their\\nnorms, has absolute value 1 if and only if they are nonzero and one is\\na multiple of the other. One form of equality case for Cauchy-Schwarz. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedSpace ℝ E] [inst_4 : LinearMap.CompatibleSMul E E 𝕜 ℝ],\\n  StrictConvex 𝕜 (Metric.closedBall 0 1) → StrictConvexSpace 𝕜 E\",\n  \"isProp\": true,\n  \"docString\":\n  \"A real normed vector space is strictly convex provided that the unit ball is strictly convex. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every linear operator on a vector space over an algebraically closed field has\\nan eigenvalue. \"}]\n",
    "prompt_cons": "/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`⟪T v, v⟫_ℂ` is real for all v. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im :=\n\n/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {Fₗ : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup Fₗ]\n  [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedSpace 𝕜 Fₗ] (c : E →L[𝕜] 𝕜) (f : Fₗ),\n  ‖ContinuousLinearMap.smulRight c f‖ = ‖c‖ * ‖f‖ :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- Pythagorean theorem, subtracting vectors, if-and-if vector inner product form using square\nroots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x - y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  (v : E) (μ : Module.End.Eigenvalues T),\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ :=\n\n/-- Cauchy–Schwarz inequality for real inner products. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner x y * inner x y ≤ inner x x * inner y y :=\n\n/-- The inner product induces the norm. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [self : InnerProductSpace 𝕜 E]\n  (x : E), ‖x‖ ^ 2 = ↑IsROrC.re (inner x x) :=\n\n/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E] [_i : Nontrivial E] {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    Module.End.HasEigenvalue T ↑(⨆ (x : { x // x ≠ 0 }), ↑IsROrC.re (inner (↑T ↑x) ↑x) / ‖↑x‖ ^ 2) :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ :=\n\n/-- The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\nterms of a complex-number representation of the space. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (f : V ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x y : V), Orientation.oangle o x y = ↑(Complex.arg (↑(starRingEnd ℂ) (↑f x) * ↑f y)) :=\n\n/-- Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\ncomplex-number representation of the space. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) (f : V ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x : V), ↑f (↑(Orientation.rotation o θ) x) = ↑(Real.Angle.expMapCircle θ) * ↑f x :=\n\n/-- The inner product of two vectors, divided by the product of their\nnorms, has absolute value 1 if and only if they are nonzero and one is\na multiple of the other. One form of equality case for Cauchy-Schwarz. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  |inner x y / (‖x‖ * ‖y‖)| = 1 ↔ x ≠ 0 ∧ ∃ r, r ≠ 0 ∧ y = r • x :=\n\n/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem ∀ (𝕜 : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedSpace ℝ E] [inst_4 : LinearMap.CompatibleSMul E E 𝕜 ℝ],\n  StrictConvex 𝕜 (Metric.closedBall 0 1) → StrictConvexSpace 𝕜 E :=\n\n/-- Every linear operator on a vector space over an algebraically closed field has\nan eigenvalue. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c :=\n\n/-- Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.) -/\ntheorem",
    "choices": [
      "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ S : V →ₗ[ℂ] V, S * S = T "
    ]
  },
  {
    "docString": "Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\\n    1 ≤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\":\n  \"∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\": \"¬Summable fun n => 1 / ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  0 ≤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n\",\n  \"isProp\": true,\n  \"docString\": \"Shows that all denominators are nonnegative. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\":\n  \"∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\": \"∀ (self : ℚ), self.den ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The denominator is nonzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\": \"¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `π / 2`, the first and third points are not equal. \"},\n {\"theorem\": \"∀ {n : ℤ}, n % 4 = 3 → ↑ZMod.χ₄ ↑n = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `χ₄ n = -1`. \"}]\n",
    "prompt_cons": "/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\n    1 ≤ b :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem ∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem ∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0 :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem ¬Summable fun n => 1 / ↑n :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x :=\n\n/-- Shows that all denominators are nonnegative. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 ≤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1 :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem ∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- The denominator is nonzero. -/\ntheorem ∀ (self : ℚ), self.den ≠ 0 :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- The complex numbers are not countable. -/\ntheorem ¬Set.Countable Set.univ :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤ :=\n\n/-- If the angle between three points is `π / 2`, the first and third points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₃ :=\n\n/-- If `n % 4 = 3`, then `χ₄ n = -1`. -/\ntheorem ∀ {n : ℤ}, n % 4 = 3 → ↑ZMod.χ₄ ↑n = -1 :=\n\n/-- Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer. -/\ntheorem",
    "choices": [
      "∀ (n : ℕ), n > 1 → ¬∃ k : ℕ, (Finset.sum (Finset.range (n + 1)) fun i => if i = 0 then 0 else 1 / ↑i) = ↑k "
    ]
  },
  {
    "docString": "If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even.",
    "prompts": "[{\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\": \"∀ {n : ℕ}, orderOf (QuaternionGroup.a 1) = 2 * n\",\n  \"isProp\": true,\n  \"docString\": \"If `0 < n`, then `a 1` has order `2 * n`.\\n\"},\n {\"theorem\": \"∀ {m n : ℕ}, Even (m ^ n) ↔ Even m ∧ n ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m` and `n` are natural numbers, then the natural number `m^n` is even\\nif and only if `m` is even and `n` is positive. \"},\n {\"theorem\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd m → Odd n → qrSign m n ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `m` and `n` are odd, then the square of `qrSign m n` is `1`. \"},\n {\"theorem\": \"∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (a : R) (n : ℕ),\\n  Polynomial.rootMultiplicity a ((Polynomial.X - ↑Polynomial.C a) ^ n) = n\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of `a` as root of `(X - a) ^ n` is `n`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n)\",\n  \"isProp\": true,\n  \"docString\": \"If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` \"},\n {\"theorem\": \"∀ {n a : ℕ}, Even a → (Even (n % a) ↔ Even n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is even iff `n % a` is even. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1 :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0 :=\n\n/-- If `0 < n`, then `a 1` has order `2 * n`. -/\ntheorem ∀ {n : ℕ}, orderOf (QuaternionGroup.a 1) = 2 * n :=\n\n/-- If `m` and `n` are natural numbers, then the natural number `m^n` is even\nif and only if `m` is even and `n` is positive. -/\ntheorem ∀ {m n : ℕ}, Even (m ^ n) ↔ Even m ∧ n ≠ 0 :=\n\n/-- If `a` is even, then `n` is odd iff `n % a` is odd. -/\ntheorem ∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n) :=\n\n/-- When `m` and `n` are odd, then the square of `qrSign m n` is `1`. -/\ntheorem ∀ {m n : ℕ}, Odd m → Odd n → qrSign m n ^ 2 = 1 :=\n\n/-- `a ^ 0 = 1` -/\ntheorem ∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- The multiplicity of `a` as root of `(X - a) ^ n` is `n`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (a : R) (n : ℕ),\n  Polynomial.rootMultiplicity a ((Polynomial.X - ↑Polynomial.C a) ^ n) = n :=\n\n/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n) :=\n\n/-- If `a` is even, then `n` is even iff `n % a` is even. -/\ntheorem ∀ {n a : ℕ}, Even a → (Even (n % a) ↔ Even n) :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 :=\n\n/-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\ntheorem ∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even. -/\ntheorem",
    "choices": [
      "∀ {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = if Even a then 2 else 1 "
    ]
  },
  {
    "docString": "Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, 512 ≤ n → n * (2 * n) ^ Nat.sqrt (2 * n) * 4 ^ (2 * n / 3) ≤ 4 ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inequality which contradicts Bertrand's postulate, for large enough `n`.\\n\"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\\n    1 ≤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] {r : ℝ}, 1 < r → Nat.cast =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\": \"For a real `r > 1` we have `n = o(r ^ n)` as `n → ∞`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {n : ℕ} [inst_2 : CompleteSpace E]\\n  (I : BoxIntegral.Box (Fin (n + 1))) {i : Fin (n + 1)} {f : (Fin (n + 1) → ℝ) → E} {f' : (Fin (n + 1) → ℝ) →L[ℝ] E},\\n  ContinuousOn f (↑BoxIntegral.Box.Icc I) →\\n    ∀ {x : Fin (n + 1) → ℝ},\\n      x ∈ ↑BoxIntegral.Box.Icc I →\\n        ∀ {a : E} {ε : ℝ},\\n          0 < ε →\\n            (∀ (y : Fin (n + 1) → ℝ), y ∈ ↑BoxIntegral.Box.Icc I → ‖f y - a - ↑f' (y - x)‖ ≤ ε * ‖y - x‖) →\\n              ∀ {c : NNReal},\\n                BoxIntegral.Box.distortion I ≤ c →\\n                  ‖(Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j) •\\n                          ↑f' (Pi.single i 1) -\\n                        (BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.upper I i)) BoxIntegral.BoxAdditiveMap.volume -\\n                          BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.lower I i)) BoxIntegral.BoxAdditiveMap.volume)‖ ≤\\n                    2 * ε * ↑c * Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j\",\n  \"isProp\": true,\n  \"docString\": \"Auxiliary lemma for the divergence theorem. \"},\n {\"theorem\":\n  \"∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] {a : α → ENNReal},\\n  Measurable a →\\n    ∀ {c : ENNReal},\\n      ∑' (i : α), a i ≤ c → ∀ {ε : ENNReal}, ε ≠ 0 → ε ≠ ⊤ → ↑↑MeasureTheory.Measure.count {i | ε ≤ a i} ≤ c / ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Markov's inequality for the counting measure with hypothesis using `tsum` in `ℝ≥0∞`. \"},\n {\"theorem\":\n  \"∀ {p n k : ℕ}, n < p ^ 2 → ↑(Nat.factorization (Nat.choose n k)) p ≤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `sqrt n` appear only to multiplicity 0 or 1\\nin the binomial coefficient. \"},\n {\"theorem\":\n  \"∀ {p n r b : ℕ},\\n  Nat.Prime p → Nat.log p n < b → (p ^ r ∣ Nat.factorial n ↔ r ≤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\": \"¬Summable fun n => 1 / ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  0 ≤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n\",\n  \"isProp\": true,\n  \"docString\": \"Shows that all denominators are nonnegative. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {α : Type u_1} [inst : LinearOrderedRing α] {s : Finset ι} {f : ι → α},\\n  (Finset.sum s fun i => f i) ^ 2 ≤ ↑(Finset.card s) * Finset.sum s fun i => f i ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of **Chebyshev's Sum Inequality** or the **Cauchy-Schwarz Inequality**: The square\\nof the sum is less than the size of the set times the sum of the squares. \"}]\n",
    "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- The inequality which contradicts Bertrand's postulate, for large enough `n`. -/\ntheorem ∀ {n : ℕ}, 512 ≤ n → n * (2 * n) ^ Nat.sqrt (2 * n) * 4 ^ (2 * n / 3) ≤ 4 ^ n :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\n    1 ≤ b :=\n\n/-- The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem ∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n → ∞`. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] {r : ℝ}, 1 < r → Nat.cast =o[Filter.atTop] fun n => r ^ n :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- Auxiliary lemma for the divergence theorem. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {n : ℕ} [inst_2 : CompleteSpace E]\n  (I : BoxIntegral.Box (Fin (n + 1))) {i : Fin (n + 1)} {f : (Fin (n + 1) → ℝ) → E} {f' : (Fin (n + 1) → ℝ) →L[ℝ] E},\n  ContinuousOn f (↑BoxIntegral.Box.Icc I) →\n    ∀ {x : Fin (n + 1) → ℝ},\n      x ∈ ↑BoxIntegral.Box.Icc I →\n        ∀ {a : E} {ε : ℝ},\n          0 < ε →\n            (∀ (y : Fin (n + 1) → ℝ), y ∈ ↑BoxIntegral.Box.Icc I → ‖f y - a - ↑f' (y - x)‖ ≤ ε * ‖y - x‖) →\n              ∀ {c : NNReal},\n                BoxIntegral.Box.distortion I ≤ c →\n                  ‖(Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j) •\n                          ↑f' (Pi.single i 1) -\n                        (BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.upper I i)) BoxIntegral.BoxAdditiveMap.volume -\n                          BoxIntegral.integral (BoxIntegral.Box.face I i) ⊥\n                            (f ∘ Fin.insertNth i (BoxIntegral.Box.lower I i)) BoxIntegral.BoxAdditiveMap.volume)‖ ≤\n                    2 * ε * ↑c * Finset.prod Finset.univ fun j => BoxIntegral.Box.upper I j - BoxIntegral.Box.lower I j :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem ∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- Markov's inequality for the counting measure with hypothesis using `tsum` in `ℝ≥0∞`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] {a : α → ENNReal},\n  Measurable a →\n    ∀ {c : ENNReal},\n      ∑' (i : α), a i ≤ c → ∀ {ε : ENNReal}, ε ≠ 0 → ε ≠ ⊤ → ↑↑MeasureTheory.Measure.count {i | ε ≤ a i} ≤ c / ε :=\n\n/-- Primes greater than about `sqrt n` appear only to multiplicity 0 or 1\nin the binomial coefficient. -/\ntheorem ∀ {p n k : ℕ}, n < p ^ 2 → ↑(Nat.factorization (Nat.choose n k)) p ≤ 1 :=\n\n/-- A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` -/\ntheorem ∀ {p n r b : ℕ},\n  Nat.Prime p → Nat.log p n < b → (p ^ r ∣ Nat.factorial n ↔ r ≤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i) :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem ¬Summable fun n => 1 / ↑n :=\n\n/-- Shows that all denominators are nonnegative. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  0 ≤ GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤ :=\n\n/-- Special case of **Chebyshev's Sum Inequality** or the **Cauchy-Schwarz Inequality**: The square\nof the sum is less than the size of the set times the sum of the squares. -/\ntheorem ∀ {ι : Type u_2} {α : Type u_1} [inst : LinearOrderedRing α] {s : Finset ι} {f : ι → α},\n  (Finset.sum s fun i => f i) ^ 2 ≤ ↑(Finset.card s) * Finset.sum s fun i => f i ^ 2 :=\n\n/-- Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] {a : α → ℕ},\n  Measurable a →\n    ∀ {c : ℝ},\n      0 < c →\n        (∀ (n : ℕ), 0 < n → ∑' (i : α), ↑(a i) / ↑n ≤ c) →\n          ∀ {ε : ℝ}, 0 < ε → ↑↑MeasureTheory.Measure.count {i | ε ≤ ↑(a i)} ≤ c / ε "
    ]
  },
  {
    "docString": "Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers.",
    "prompts": "[{\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\": \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"theorem\": \"∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ a, a ≠ 1 ∧ a ≠ -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a nontrivial solution\\nto the Pell equation `x^2 - d*y^2 = 1`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\": \"PythagoreanTriple 0 0 0\",\n  \"isProp\": true,\n  \"docString\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ x y, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there is a nontrivial solution\\nto the Pell equation `x^2 - d*y^2 = 1`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 = 1 + d * Pell.Solution₁.y a ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative form of the equation, suitable for rewriting `x^2`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ≠ 0 →\\n    ∀ {s : K},\\n      discrim a b c = s * s → ∀ (x : K), a * x * x + b * x + c = 0 ↔ x = (-b + s) / (2 * a) ∨ x = (-b - s) / (2 * a)\",\n  \"isProp\": true,\n  \"docString\": \"Roots of a quadratic equation. \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ a, 1 < Pell.Solution₁.x a ∧ 0 < Pell.Solution₁.y a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a solution\\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `π / 2`, the first and third points are not equal. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\\n  legendreSym p a = -1 → ∀ {x y : ZMod p}, x ^ 2 - ↑a * y ^ 2 = 0 → x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `legendreSym p a = -1`, then the only solution of `x^2 - a*y^2 = 0` in `ℤ/pℤ`\\nis the trivial one. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\\n  a ≠ 0 → (∃ s, discrim a b c = s * s) → ∃ x, a * x * x + b * x + c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A quadratic has roots if its discriminant has square roots \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] {a b c : K}, (∀ (x : K), 0 ≤ a * x * x + b * x + c) → discrim a b c ≤ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a polynomial of degree 2 is always nonnegative, then its discriminant is nonpositive \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- A solution has `x ≠ 0`. -/\ntheorem ∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0 :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1 :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem ∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem ∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ a, a ≠ 1 ∧ a ≠ -1 :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem PythagoreanTriple 0 0 0 :=\n\n/-- If `d` is a positive integer that is not a square, then there is a nontrivial solution\nto the Pell equation `x^2 - d*y^2 = 1`. -/\ntheorem ∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ x y, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0 :=\n\n/-- An alternative form of the equation, suitable for rewriting `x^2`. -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 = 1 + d * Pell.Solution₁.y a ^ 2 :=\n\n/-- Roots of a quadratic equation. -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a ≠ 0 →\n    ∀ {s : K},\n      discrim a b c = s * s → ∀ (x : K), a * x * x + b * x + c = 0 ↔ x = (-b + s) / (2 * a) ∨ x = (-b - s) / (2 * a) :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a solution\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. -/\ntheorem ∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ a, 1 < Pell.Solution₁.x a ∧ 0 < Pell.Solution₁.y a :=\n\n/-- If the angle between three points is `π / 2`, the first and third points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₃ :=\n\n/-- If `legendreSym p a = -1`, then the only solution of `x^2 - a*y^2 = 0` in `ℤ/pℤ`\nis the trivial one. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\n  legendreSym p a = -1 → ∀ {x y : ZMod p}, x ^ 2 - ↑a * y ^ 2 = 0 → x = 0 ∧ y = 0 :=\n\n/-- A quadratic has roots if its discriminant has square roots -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst_1 : NeZero 2] {a b c : K},\n  a ≠ 0 → (∃ s, discrim a b c = s * s) → ∃ x, a * x * x + b * x + c = 0 :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- If a polynomial of degree 2 is always nonnegative, then its discriminant is nonpositive -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] {a b c : K}, (∀ (x : K), 0 ≤ a * x * x + b * x + c) → discrim a b c ≤ 0 :=\n\n/-- Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers. -/\ntheorem",
    "choices": [
      "∀ (x y : ℤ), 3 * x ^ 2 + 2 ≠ y ^ 2 "
    ]
  },
  {
    "docString": "If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$.",
    "prompts": "[{\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → ↑ZMod.χ₄ ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `χ₄ n = 1`. \"},\n {\"theorem\": \"∀ {n : ℤ}, n % 4 = 3 → ↑ZMod.χ₄ ↑n = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `χ₄ n = -1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, Squarefree n → (IsSquare (-1) ↔ ∀ {q : ℕ}, Nat.Prime q → q ∣ n → q % 4 ≠ 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\\n`n` is not divisible by a prime `q` such that `q % 4 = 3`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, Squarefree n → (IsSquare (-1) ↔ ∀ {q : ℕ}, q ∣ n → q % 4 ≠ 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\\n`n` has no divisor `q` that is `≡ 3 mod 4`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"theorem\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"}]\n",
    "prompt_cons": "/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1 :=\n\n/-- If `n % 4 = 1`, then `χ₄ n = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → ↑ZMod.χ₄ ↑n = 1 :=\n\n/-- If `n % 4 = 3`, then `χ₄ n = -1`. -/\ntheorem ∀ {n : ℤ}, n % 4 = 3 → ↑ZMod.χ₄ ↑n = -1 :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem ∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0 :=\n\n/-- If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` is not divisible by a prime `q` such that `q % 4 = 3`. -/\ntheorem ∀ {n : ℕ}, Squarefree n → (IsSquare (-1) ↔ ∀ {q : ℕ}, Nat.Prime q → q ∣ n → q % 4 ≠ 3) :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- If `n` is a squarefree natural number, then `-1` is a square modulo `n` if and only if\n`n` has no divisor `q` that is `≡ 3 mod 4`. -/\ntheorem ∀ {n : ℕ}, Squarefree n → (IsSquare (-1) ↔ ∀ {q : ℕ}, q ∣ n → q % 4 ≠ 3) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- If `n` is odd and `a` is even, then `n % a` is odd. -/\ntheorem ∀ {n a : ℕ}, Odd n → Even a → Odd (n % a) :=\n\n/-- If `a` is even, then `n` is odd iff `n % a` is odd. -/\ntheorem ∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n) :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ}, ¬Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 "
    ]
  },
  {
    "docString": "Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$.",
    "prompts": "[{\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 ↔ ¬IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {n : ℕ}, jacobiSym a n = -1 → ∃ p x, p ∣ n ∧ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p ≠ 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\\n  jacobiSym a p = -1 → ∀ {x y : ℤ}, ↑p ∣ x ^ 2 - a * y ^ 2 → ↑p ∣ x ∧ ↑p ∣ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"}]\n",
    "prompt_cons": "/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 ↔ ¬IsSquare ↑a :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem ∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem ∀ {a : ℤ} {n : ℕ}, jacobiSym a n = -1 → ∃ p x, p ∣ n ∧ jacobiSym a p = -1 :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p ≠ 1`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0 :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\n  jacobiSym a p = -1 → ∀ {x y : ℤ}, ↑p ∣ x ^ 2 - a * y ^ 2 → ↑p ∣ x ∧ ↑p ∣ y :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0 :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℕ}, p % 4 = 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p "
    ]
  },
  {
    "docString": "If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"∀ {n p k : ℕ}, n ≠ 0 → Nat.factorization n = Finsupp.single p k → n = p ^ k\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the factorization of `n` contains just one number `p` then `n` is a power of `p` \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {n : ℕ} [inst_1 : IsDomain R],\\n  0 < n → ∀ {μ : R}, IsPrimitiveRoot μ n → Polynomial.IsRoot (Polynomial.cyclotomic n R) μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `n`-th primitive root of unity is a root of `cyclotomic n R`.\"},\n {\"theorem\":\n  \"∀ {p n : ℕ}, 2 * n < p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` has positive multiplicity in the `n`th central binomial coefficient,\\n`p` is no more than `2 * n` \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\\nand of `μ ^ p` are the same. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : CommRing R], Polynomial.IsPrimitive (Polynomial.cyclotomic n R)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n` is primitive. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R} {n : ℕ},\\n  IsPrimitiveRoot ζ n → Polynomial.degree (Polynomial.cyclotomic' n R) = ↑(Nat.totient n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"}]\n",
    "prompt_cons": "/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- If the factorization of `n` contains just one number `p` then `n` is a power of `p` -/\ntheorem ∀ {n p k : ℕ}, n ≠ 0 → Nat.factorization n = Finsupp.single p k → n = p ^ k :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Any `n`-th primitive root of unity is a root of `cyclotomic n R`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {n : ℕ} [inst_1 : IsDomain R],\n  0 < n → ∀ {μ : R}, IsPrimitiveRoot μ n → Polynomial.IsRoot (Polynomial.cyclotomic n R) μ :=\n\n/-- If a prime `p` has positive multiplicity in the `n`th central binomial coefficient,\n`p` is no more than `2 * n` -/\ntheorem ∀ {p n : ℕ}, 2 * n < p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ p` are the same. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p) :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b :=\n\n/-- `cyclotomic n` is primitive. -/\ntheorem ∀ (n : ℕ) (R : Type u_1) [inst : CommRing R], Polynomial.IsPrimitive (Polynomial.cyclotomic n R) :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1 :=\n\n/-- The degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R} {n : ℕ},\n  IsPrimitiveRoot ζ n → Polynomial.degree (Polynomial.cyclotomic' n R) = ↑(Nat.totient n) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$. -/\ntheorem",
    "choices": [
      "∀ {n p : ℕ}, Nat.Prime p → p = 2 ^ n + 1 → IsPrimitiveRoot 3 p "
    ]
  },
  {
    "docString": "Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"∀ {p k : ℕ}, k ≠ 0 → Nat.Prime p → List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {p n : ℕ},\\n  Nat.Prime p → Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p ^ k` is a prime power, then\\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. \"},\n {\"theorem\":\n  \"∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k]\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\\n`p ≡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"∀ (k : ℕ) {r : ℝ}, |r| < 1 → Filter.Tendsto (fun n => ↑n ^ k * r ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. \"},\n {\"theorem\":\n  \"∀ {p k : ℕ}, Nat.Prime p → Nat.factorization (p ^ k) = Finsupp.single p k\",\n  \"isProp\": true,\n  \"docString\":\n  \"For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"∀ {p : ℕ}, padicValNat p 1 = 0\",\n  \"isProp\": true,\n  \"docString\": \"`padicValNat p 1` is `0` for any `p`. \"},\n {\"theorem\":\n  \"∀ {a p k : ℕ}, Nat.Prime p → ¬a ∣ p ^ k → a ∣ p ^ (k + 1) → a = p ^ (k + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime,\\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\\nthen `a = p^(k+1)`.\\n\"},\n {\"theorem\":\n  \"∀ (p : ℕ → Prop) [inst : DecidablePred p] (n : ℕ), Nat.count p n = Fintype.card { k // k < n ∧ p k }\",\n  \"isProp\": true,\n  \"docString\":\n  \"`count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"}]\n",
    "prompt_cons": "/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1 :=\n\n/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem ∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem ∀ {p k : ℕ}, k ≠ 0 → Nat.Prime p → List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. -/\ntheorem ∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0 :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {p n : ℕ},\n  Nat.Prime p → Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i :=\n\n/-- For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\n`p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k] :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem ∀ (k : ℕ) {r : ℝ}, |r| < 1 → Filter.Tendsto (fun n => ↑n ^ k * r ^ n) Filter.atTop (nhds 0) :=\n\n/-- For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` -/\ntheorem ∀ {p k : ℕ}, Nat.Prime p → Nat.factorization (p ^ k) = Finsupp.single p k :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- `padicValNat p 1` is `0` for any `p`. -/\ntheorem ∀ {p : ℕ}, padicValNat p 1 = 0 :=\n\n/-- If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`. -/\ntheorem ∀ {a p k : ℕ}, Nat.Prime p → ¬a ∣ p ^ k → a ∣ p ^ (k + 1) → a = p ^ (k + 1) :=\n\n/-- `count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. -/\ntheorem ∀ (p : ℕ → Prop) [inst : DecidablePred p] (n : ℕ), Nat.count p n = Fintype.card { k // k < n ∧ p k } :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$. -/\ntheorem",
    "choices": [
      "∀ {p k : ℕ} [inst : Fact (Nat.Prime p)], (p - 1) ∣ k → (Finset.sum (Finset.range p) fun i => i ^ k) ≡ -1 [MOD p] "
    ]
  },
  {
    "docString": "Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p ∤ a`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"}]\n",
    "prompt_cons": "/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- The square of the symbol is 1 if `p ∤ a`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1 :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p (a ^ 2) = 1 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1) :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 :=\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0 :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c :=\n\n/-- Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → (Exists (λ x, x ^ 4 ≡ 2 [MOD p]) ↔ ∃ A B, p = A ^ 2 + 64 * B ^ 2) "
    ]
  },
  {
    "docString": "Show that $\\sin (\\pi / 12)$ is an algebraic number.",
    "prompts": "[{\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 6` is `1 / 2`. \"},\n {\"theorem\":\n  \"∀ (x : ℝ),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 3` is `√3 / 2`. \"},\n {\"theorem\":\n  \"∀ (z : ℂ),\\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (↑Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `π / 6` is `√3 / 2`. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P},\\n  Real.sin (EuclideanGeometry.angle p₁ p₂ p₃) = 1 ↔ EuclideanGeometry.angle p₁ p₂ p₃ = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sine of the angle between three points is 1 if and only if the angle is π / 2. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\\n  Real.sin (InnerProductGeometry.angle x y) = 1 ↔ InnerProductGeometry.angle x y = Real.pi / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sine of the angle between two vectors is 1 if and only if the angle is π / 2. \"},\n {\"theorem\": \"Real.cos (Real.pi / 3) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `π / 3` is `1 / 2`. \"},\n {\"theorem\":\n  \"∀ (r : ℝ), HasSum (fun n => (-1) ^ n * r ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Real.sin r)\",\n  \"isProp\": true,\n  \"docString\": \"The power series expansion of `Real.sin`. \"},\n {\"theorem\":\n  \"∀ (R : Type u) {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] [inst_3 : Nontrivial R]\\n  {x : A}, IsIntegral R x → IsAlgebraic R x\",\n  \"isProp\": true,\n  \"docString\": \"An integral element of an algebra is algebraic.\"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\": \"Function.Injective Real.sinh\",\n  \"isProp\": true,\n  \"docString\": \"`sinh` is injective, `∀ a b, sinh a = sinh b → a = b`. \"},\n {\"theorem\": \"Function.Surjective Real.sinh\",\n  \"isProp\": true,\n  \"docString\":\n  \"`sinh` is surjective, `∀ b, ∃ a, sinh a = b`. In this case, we use `a = arsinh b`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialNumerators (GeneralizedContinuedFraction.of v)) n = some a →\\n    a = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that the partial numerators `aᵢ` are equal to one. \"},\n {\"theorem\": \"Function.Bijective Real.sinh\",\n  \"isProp\": true,\n  \"docString\": \"`sinh` is bijective, both injective and surjective. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P},\\n  EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) →\\n    Real.Angle.sin (EuclideanGeometry.oangle p₂ p₃ p₁) = dist p₁ p₂ / dist p₁ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sine of an angle in a right-angled triangle as a ratio of sides. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) ^ 2 = 3 / 4\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the\\nresult for cosine itself). \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `ζ(0) = -1 / 2`. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) ^ 2 = 3 / 4\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the\\nresult for cosine itself). \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P},\\n  Real.sin (EuclideanGeometry.angle p₁ p₂ p₃) = 0 ↔\\n    EuclideanGeometry.angle p₁ p₂ p₃ = 0 ∨ EuclideanGeometry.angle p₁ p₂ p₃ = Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sine of the angle between three points is 0 if and only if the angle is 0 or π. \"}]\n",
    "prompt_cons": "/-- The sine of `π / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem ∀ (x : ℝ),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- The sine of `π / 3` is `√3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem ∀ (z : ℂ),\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (↑Real.pi * z))) :=\n\n/-- The cosine of `π / 6` is `√3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- The sine of the angle between three points is 1 if and only if the angle is π / 2. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P},\n  Real.sin (EuclideanGeometry.angle p₁ p₂ p₃) = 1 ↔ EuclideanGeometry.angle p₁ p₂ p₃ = Real.pi / 2 :=\n\n/-- The sine of the angle between two vectors is 1 if and only if the angle is π / 2. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  Real.sin (InnerProductGeometry.angle x y) = 1 ↔ InnerProductGeometry.angle x y = Real.pi / 2 :=\n\n/-- The cosine of `π / 3` is `1 / 2`. -/\ntheorem Real.cos (Real.pi / 3) = 1 / 2 :=\n\n/-- The power series expansion of `Real.sin`. -/\ntheorem ∀ (r : ℝ), HasSum (fun n => (-1) ^ n * r ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Real.sin r) :=\n\n/-- An integral element of an algebra is algebraic. -/\ntheorem ∀ (R : Type u) {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] [inst_3 : Nontrivial R]\n  {x : A}, IsIntegral R x → IsAlgebraic R x :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1 :=\n\n/-- `sinh` is injective, `∀ a b, sinh a = sinh b → a = b`. -/\ntheorem Function.Injective Real.sinh :=\n\n/-- `sinh` is surjective, `∀ b, ∃ a, sinh a = b`. In this case, we use `a = arsinh b`. -/\ntheorem Function.Surjective Real.sinh :=\n\n/-- Shows that the partial numerators `aᵢ` are equal to one. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialNumerators (GeneralizedContinuedFraction.of v)) n = some a →\n    a = 1 :=\n\n/-- `sinh` is bijective, both injective and surjective. -/\ntheorem Function.Bijective Real.sinh :=\n\n/-- The sine of an angle in a right-angled triangle as a ratio of sides. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P},\n  EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) →\n    Real.Angle.sin (EuclideanGeometry.oangle p₂ p₃ p₁) = dist p₁ p₂ / dist p₁ p₃ :=\n\n/-- The square of the cosine of `π / 6` is `3 / 4` (this is sometimes more convenient than the\nresult for cosine itself). -/\ntheorem Real.cos (Real.pi / 6) ^ 2 = 3 / 4 :=\n\n/-- We have `ζ(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- The square of the sine of `π / 3` is `3 / 4` (this is sometimes more convenient than the\nresult for cosine itself). -/\ntheorem Real.sin (Real.pi / 3) ^ 2 = 3 / 4 :=\n\n/-- The sine of the angle between three points is 0 if and only if the angle is 0 or π. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P},\n  Real.sin (EuclideanGeometry.angle p₁ p₂ p₃) = 0 ↔\n    EuclideanGeometry.angle p₁ p₂ p₃ = 0 ∨ EuclideanGeometry.angle p₁ p₂ p₃ = Real.pi :=\n\n/-- Show that $\\sin (\\pi / 12)$ is an algebraic number. -/\ntheorem",
    "choices": [
      "IsAlgebraic ℚ (Real.sin (Real.pi / 12)) "
    ]
  },
  {
    "docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\\n  AnalyticOn ℂ g U →\\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `ℂ`). \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∃ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f ≡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\\n  {s : Set E} {x y : E},\\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero Fréchet derivative at every point of a convex set,\\nthen it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {g : E → ℂ} {z₀ : E},\\n  AnalyticAt ℂ g z₀ → (∀ᶠ (z : E) in nhds z₀, g z = g z₀) ∨ nhds (g z₀) ≤ Filter.map g (nhds z₀)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, local version: is a function `g : E → ℂ`\\nis analytic at a point `z₀`, then either it is constant in a neighborhood of `z₀`, or it maps every\\nneighborhood of `z₀` to a neighborhood of `z₀`. For the particular case of a holomorphic function on\\n`ℂ`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : NormedAddCommGroup β]\\n  {p : ENNReal} {f : α → β},\\n  MeasureTheory.Memℒp f p →\\n    MeasureTheory.StronglyMeasurable f →\\n      ∀ {ε : ℝ}, 0 < ε → ∃ M, 0 < M ∧ MeasureTheory.snorm (Set.indicator {x | M ≤ ↑‖f x‖₊} f) p μ ≤ ENNReal.ofReal ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"This lemma implies that a single function is uniformly integrable (in the probability sense). \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}\\n  {f : X ⟶ Y}, f = 0 → ∀ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.ι f = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If we know `f = 0`,\\nit requires a little work to conclude `image.ι f = 0`,\\nbecause `f = g` only implies `image f ≅ image g`.\\n\"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f → MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"}]\n",
    "prompt_cons": "/-- If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `ℂ`). -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\n  AnalyticOn ℂ g U →\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s) :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f ≡ v`,\nfor some value `v`. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∃ v, f = Function.const M v :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c :=\n\n/-- If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem ∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- If a function has zero Fréchet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\n  {s : Set E} {x y : E},\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y :=\n\n/-- The *open mapping theorem* for holomorphic functions, local version: is a function `g : E → ℂ`\nis analytic at a point `z₀`, then either it is constant in a neighborhood of `z₀`, or it maps every\nneighborhood of `z₀` to a neighborhood of `z₀`. For the particular case of a holomorphic function on\n`ℂ`, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds_aux`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {g : E → ℂ} {z₀ : E},\n  AnalyticAt ℂ g z₀ → (∀ᶠ (z : E) in nhds z₀, g z = g z₀) ∨ nhds (g z₀) ≤ Filter.map g (nhds z₀) :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : NormedAddCommGroup β]\n  {p : ENNReal} {f : α → β},\n  MeasureTheory.Memℒp f p →\n    MeasureTheory.StronglyMeasurable f →\n      ∀ {ε : ℝ}, 0 < ε → ∃ M, 0 < M ∧ MeasureTheory.snorm (Set.indicator {x | M ≤ ↑‖f x‖₊} f) p μ ≤ ENNReal.ofReal ε :=\n\n/-- If we know `f = 0`,\nit requires a little work to conclude `image.ι f = 0`,\nbecause `f = g` only implies `image f ≅ image g`. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}\n  {f : X ⟶ Y}, f = 0 → ∀ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.ι f = 0 :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem ∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f → MeasureTheory.LocallyIntegrable f :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant. -/\ntheorem",
    "choices": [
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → ℂ} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ ℂ) f U →\n    IsOpen U → (∀ (x : M), x ∈ U → (f x).im = 0) → ∀ (x y : M), x ∈ U → y ∈ U → f x = f y "
    ]
  },
  {
    "docString": "Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle.",
    "prompts": "[{\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\": \"¬Summable fun n => 1 / ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"},\n {\"theorem\":\n  \"∀ {f : ℕ → ℝ},\\n  (∀ (n : ℕ), 0 ≤ f n) → (∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) → ((Summable fun k => 2 ^ k * f (2 ^ k)) ↔ Summable f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cauchy condensation test for series of nonnegative real numbers. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"},\n {\"theorem\": \"∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {φ : PowerSeries R} (h : (PowerSeries.order φ).Dom),\\n  ↑(PowerSeries.coeff R (Part.get (PowerSeries.order φ) h)) φ ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the order of a formal power series is finite,\\nthen the coefficient indexed by the order is nonzero.\"},\n {\"theorem\":\n  \"∀ {t : ℝ}, 0 < t → Summable fun n => rexp (-Real.pi * t * (↑n + 1) ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"The sum defining `zetaKernel₁` is convergent. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  (p q : FormalMultilinearSeries 𝕜 E F),\\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) ≤ FormalMultilinearSeries.radius (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The radius of the sum of two formal series is at least the minimum of their two radii. \"},\n {\"theorem\":\n  \"∀ {n : ℤ} {c w : ℂ} {R : ℝ}, n < 0 → w ∈ Metric.sphere c |R| → (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\\ncenter `c` and radius `|R|`, so the integral `∮ z in C(c, R), (z - w) ^ n` is equal to zero. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {φ ψ : PowerSeries R} {n : ℕ},\\n  ↑n < PowerSeries.order ψ → ↑(PowerSeries.coeff R n) (φ * ψ) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is strictly smaller than the order of `ψ`, then the `n`th coefficient of its product\\nwith any other power series is `0`. \"},\n {\"theorem\": \"¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {F : ℕ → α → ENNReal} {f : α → ENNReal}\\n  (bound : α → ENNReal),\\n  (∀ (n : ℕ), Measurable (F n)) →\\n    (∀ (n : ℕ), F n ≤ᶠ[MeasureTheory.Measure.ae μ] bound) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) Filter.atTop (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Dominated convergence theorem for nonnegative functions \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\\n  (p : FormalMultilinearSeries 𝕜 E F),\\n  0 < FormalMultilinearSeries.radius p →\\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the sum of a converging power series `p` admits `p` as a power series.\\nThis is not totally obvious as we need to check the convergence of the series. \"},\n {\"theorem\":\n  \"∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"}]\n",
    "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem ¬Summable fun n => 1 / ↑n :=\n\n/-- Cauchy condensation test for series of nonnegative real numbers. -/\ntheorem ∀ {f : ℕ → ℝ},\n  (∀ (n : ℕ), 0 ≤ f n) → (∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) → ((Summable fun k => 2 ^ k * f (2 ^ k)) ↔ Summable f) :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤ :=\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {φ : PowerSeries R} (h : (PowerSeries.order φ).Dom),\n  ↑(PowerSeries.coeff R (Part.get (PowerSeries.order φ) h)) φ ≠ 0 :=\n\n/-- The sum defining `zetaKernel₁` is convergent. -/\ntheorem ∀ {t : ℝ}, 0 < t → Summable fun n => rexp (-Real.pi * t * (↑n + 1) ^ 2) :=\n\n/-- The radius of the sum of two formal series is at least the minimum of their two radii. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p q : FormalMultilinearSeries 𝕜 E F),\n  min (FormalMultilinearSeries.radius p) (FormalMultilinearSeries.radius q) ≤ FormalMultilinearSeries.radius (p + q) :=\n\n/-- If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\ncenter `c` and radius `|R|`, so the integral `∮ z in C(c, R), (z - w) ^ n` is equal to zero. -/\ntheorem ∀ {n : ℤ} {c w : ℂ} {R : ℝ}, n < 0 → w ∈ Metric.sphere c |R| → (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r) :=\n\n/-- If `n` is strictly smaller than the order of `ψ`, then the `n`th coefficient of its product\nwith any other power series is `0`. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {φ ψ : PowerSeries R} {n : ℕ},\n  ↑n < PowerSeries.order ψ → ↑(PowerSeries.coeff R n) (φ * ψ) = 0 :=\n\n/-- The complex numbers are not countable. -/\ntheorem ¬Set.Countable Set.univ :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem ∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- Dominated convergence theorem for nonnegative functions -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {F : ℕ → α → ENNReal} {f : α → ENNReal}\n  (bound : α → ENNReal),\n  (∀ (n : ℕ), Measurable (F n)) →\n    (∀ (n : ℕ), F n ≤ᶠ[MeasureTheory.Measure.ae μ] bound) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) Filter.atTop (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) Filter.atTop (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\n  (p : FormalMultilinearSeries 𝕜 E F),\n  0 < FormalMultilinearSeries.radius p →\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p) :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem ∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i :=\n\n/-- Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle. -/\ntheorem",
    "choices": [
      "∀ (z : ℂ), Complex.abs z = 1 → ¬Summable (λ n => ↑n * z ^ n) "
    ]
  },
  {
    "docString": "Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$.",
    "prompts": "[{\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {t : ℝ}, 0 < t → Summable fun n => rexp (-Real.pi * t * (↑n + 1) ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"The sum defining `zetaKernel₁` is convergent. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"},\n {\"theorem\":\n  \"∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r →\\n    ↑r' < r →\\n      ∃ a,\\n        a ∈ Set.Ioo 0 1 ∧\\n          ∃ C,\\n            C > 0 ∧\\n              ∀ (y : E),\\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\": \"∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"The order of the `0` power series is infinite.\"},\n {\"theorem\":\n  \"∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\": \"∀ (n : ℕ), riemannZeta (-2 * (↑n + 1)) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The trivial zeroes of the zeta function. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {φ ψ : PowerSeries R} {n : ℕ},\\n  ↑n < PowerSeries.order ψ → ↑(PowerSeries.coeff R n) (φ * ψ) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is strictly smaller than the order of `ψ`, then the `n`th coefficient of its product\\nwith any other power series is `0`. \"},\n {\"theorem\":\n  \"∀ {f : ℕ → ℝ},\\n  (∀ (n : ℕ), 0 ≤ f n) → (∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) → ((Summable fun k => 2 ^ k * f (2 ^ k)) ↔ Summable f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cauchy condensation test for series of nonnegative real numbers. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {φ : PowerSeries R} (n : ℕ),\\n  ↑n < PowerSeries.order φ → ↑(PowerSeries.coeff R n) φ = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `n`th coefficient of a formal power series is `0` if `n` is strictly\\nsmaller than the order of the power series.\"}]\n",
    "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- The sum defining `zetaKernel₁` is convergent. -/\ntheorem ∀ {t : ℝ}, 0 < t → Summable fun n => rexp (-Real.pi * t * (↑n + 1) ^ 2) :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem ∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Consider a series of functions `∑' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r →\n    ↑r' < r →\n      ∃ a,\n        a ∈ Set.Ioo 0 1 ∧\n          ∃ C,\n            C > 0 ∧\n              ∀ (y : E),\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n :=\n\n/-- The order of the `0` power series is infinite. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R], PowerSeries.order 0 = ⊤ :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem ∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i :=\n\n/-- The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- The trivial zeroes of the zeta function. -/\ntheorem ∀ (n : ℕ), riemannZeta (-2 * (↑n + 1)) = 0 :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- If `n` is strictly smaller than the order of `ψ`, then the `n`th coefficient of its product\nwith any other power series is `0`. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {φ ψ : PowerSeries R} {n : ℕ},\n  ↑n < PowerSeries.order ψ → ↑(PowerSeries.coeff R n) (φ * ψ) = 0 :=\n\n/-- Cauchy condensation test for series of nonnegative real numbers. -/\ntheorem ∀ {f : ℕ → ℝ},\n  (∀ (n : ℕ), 0 ≤ f n) → (∀ ⦃m n : ℕ⦄, 0 < m → m ≤ n → f n ≤ f m) → ((Summable fun k => 2 ^ k * f (2 ^ k)) ↔ Summable f) :=\n\n/-- The `n`th coefficient of a formal power series is `0` if `n` is strictly\nsmaller than the order of the power series. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {φ : PowerSeries R} (n : ℕ),\n  ↑n < PowerSeries.order φ → ↑(PowerSeries.coeff R n) φ = 0 :=\n\n/-- Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {z : 𝕜}, HasMem.Mem z (Metric.Sphere 0 1) → z ≠ 1 → Summable (λ n => z ^ n / ↑n) "
    ]
  },
  {
    "docString": "Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$.",
    "prompts": "[{\"theorem\":\n  \"∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\":\n  \"∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. \"},\n {\"theorem\": \"∀ {x : ℝ}, 0 < x → Real.sin x < x\",\n  \"isProp\": true,\n  \"docString\": \"For 0 < x, we have sin x < x. \"},\n {\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 6` is `1 / 2`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ),\\n  ∫ (x : ℝ) in a..b, Real.sin x ^ (n + 2) =\\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (↑n + 2) +\\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `sin x ^ n` for any natural `n ≥ 2`. \"},\n {\"theorem\":\n  \"∀ (x : ℝ),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\": \"Real.Gamma (1 / 2) = Real.sqrt Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"The special-value formula `Γ(1/2) = √π`, which is equivalent to the Gaussian integral. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 3` is `√3 / 2`. \"},\n {\"theorem\":\n  \"∀ (z : ℂ),\\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (↑Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"},\n {\"theorem\": \"Real.cos (Real.pi / 3) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `π / 3` is `1 / 2`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : V → E}\\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\\n  [inst_6 : FiniteDimensional ℝ V] {w : V},\\n  w ≠ 0 →\\n    MeasureTheory.Integrable f →\\n      ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v =\\n        (1 / 2) •\\n          ∫ (v : V),\\n            ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) •\\n              (f v - f (v + (fun w => (1 / (2 * ‖w‖ ^ 2)) • w) w))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rewrite the Fourier integral in a form that allows us to use uniform continuity. \"},\n {\"theorem\":\n  \"Filter.Tendsto\\n  (fun k => Finset.prod (Finset.range k) fun i => (2 * ↑i + 2) / (2 * ↑i + 1) * ((2 * ↑i + 2) / (2 * ↑i + 3)))\\n  Filter.atTop (nhds (Real.pi / 2))\",\n  \"isProp\": true,\n  \"docString\": \"Wallis' product formula for `π / 2`. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `π / 6` is `√3 / 2`. \"},\n {\"theorem\": \"∀ {x : ℝ}, 0 < x → x < Real.pi / 2 → x < Real.tan x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `0 < x < π/2` we have `x < tan x`.\\n\\nThis is proved by checking that the function `tan x - x` vanishes\\nat zero and has non-negative derivative. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ),\\n  ∫ (x : ℝ) in a..b, Real.cos x ^ (n + 2) =\\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (↑n + 2) +\\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.cos x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `cos x ^ n` for any natural `n ≥ 2`. \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"}]\n",
    "prompt_cons": "/-- Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem ∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. -/\ntheorem ∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I :=\n\n/-- For 0 < x, we have sin x < x. -/\ntheorem ∀ {x : ℝ}, 0 < x → Real.sin x < x :=\n\n/-- The sine of `π / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- The reduction formula for the integral of `sin x ^ n` for any natural `n ≥ 2`. -/\ntheorem ∀ {a b : ℝ} (n : ℕ),\n  ∫ (x : ℝ) in a..b, Real.sin x ^ (n + 2) =\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (↑n + 2) +\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.sin x ^ n :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem ∀ (x : ℝ),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- The special-value formula `Γ(1/2) = √π`, which is equivalent to the Gaussian integral. -/\ntheorem Real.Gamma (1 / 2) = Real.sqrt Real.pi :=\n\n/-- The sine of `π / 3` is `√3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem ∀ (z : ℂ),\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (↑Real.pi * z))) :=\n\n/-- The cosine of `π / 3` is `1 / 2`. -/\ntheorem Real.cos (Real.pi / 3) = 1 / 2 :=\n\n/-- If two functions are equal in the relevant interval, their interval integrals are also equal. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ :=\n\n/-- Rewrite the Fourier integral in a form that allows us to use uniform continuity. -/\ntheorem ∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : V → E}\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\n  [inst_6 : FiniteDimensional ℝ V] {w : V},\n  w ≠ 0 →\n    MeasureTheory.Integrable f →\n      ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v =\n        (1 / 2) •\n          ∫ (v : V),\n            ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) •\n              (f v - f (v + (fun w => (1 / (2 * ‖w‖ ^ 2)) • w) w)) :=\n\n/-- Wallis' product formula for `π / 2`. -/\ntheorem Filter.Tendsto\n  (fun k => Finset.prod (Finset.range k) fun i => (2 * ↑i + 2) / (2 * ↑i + 1) * ((2 * ↑i + 2) / (2 * ↑i + 3)))\n  Filter.atTop (nhds (Real.pi / 2)) :=\n\n/-- The cosine of `π / 6` is `√3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- For all `0 < x < π/2` we have `x < tan x`.\n\nThis is proved by checking that the function `tan x - x` vanishes\nat zero and has non-negative derivative. -/\ntheorem ∀ {x : ℝ}, 0 < x → x < Real.pi / 2 → x < Real.tan x :=\n\n/-- The reduction formula for the integral of `cos x ^ n` for any natural `n ≥ 2`. -/\ntheorem ∀ {a b : ℝ} (n : ℕ),\n  ∫ (x : ℝ) in a..b, Real.cos x ^ (n + 2) =\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (↑n + 2) +\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.cos x ^ n :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$. -/\ntheorem",
    "choices": [
      "∀ (ε : ℝ), 0 < ε →\n  ∃ (a b : ℝ),\n    0 < a ∧ 0 < b ∧\n      (∫ (x : ℝ) in 0..a, Real.sin x / x) < Real.pi / 2 + ε ∧\n        (∫ (x : ℝ) in 0..b, Real.sin x / x) > Real.pi / 2 - ε "
    ]
  },
  {
    "docString": "Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E} {z₀ : 𝕜},\\n  AnalyticAt 𝕜 f z₀ → (∀ᶠ (z : 𝕜) in nhds z₀, f z = 0) ∨ ∀ᶠ (z : 𝕜) in nhdsWithin z₀ {z₀}ᶜ, f z ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *principle of isolated zeros* for an analytic function, local version: if a function is\\nanalytic at `z₀`, then either it is identically zero in a neighborhood of `z₀`, or it does not\\nvanish in a punctured neighborhood of `z₀`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\\n  {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → y ∈ EMetric.ball x r → AnalyticAt 𝕜 f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\\nit is analytic at every point of this ball. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {h : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R → WittVector p R}\\n  {f g : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R} [hh : WittVector.IsPoly₂ p h]\\n  [hf : WittVector.IsPoly p f] [hg : WittVector.IsPoly p g], WittVector.IsPoly₂ p fun R _Rcr x y => h (f x) (g y)\",\n  \"isProp\": true,\n  \"docString\": \"The composition of polynomial functions is polynomial. \"},\n {\"theorem\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"∀ {f : ℂ → ℂ} {z₀ : ℂ}, AnalyticAt ℂ f z₀ → (∀ᶠ (z : ℂ) in nhds z₀, f z = f z₀) ∨ nhds (f z₀) ≤ Filter.map f (nhds z₀)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : ℂ → ℂ` which is analytic at a point `z₀` is either constant in a neighborhood\\nof `z₀`, or behaves locally like an open function (in the sense that the image of every neighborhood\\nof `z₀` is a neighborhood of `f z₀`, as in `isOpenMap_iff_nhds_le`). For a function `f : E → ℂ`\\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], WittVector.IsPoly p fun x x_1 x_2 => 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function that is constantly zero on Witt vectors is a polynomial function. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {s : Set E} [inst_5 : CompleteSpace F], AnalyticOn 𝕜 f s → ∀ {n : ℕ∞}, ContDiffOn 𝕜 n f s\",\n  \"isProp\": true,\n  \"docString\": \"An analytic function is infinitely differentiable. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ (z : ℂ), AnalyticAt ℂ f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is analytic at every point. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {p : FormalMultilinearSeries 𝕜 𝕜 E} {f : 𝕜 → E} {x : 𝕜},\\n  HasFPowerSeriesAt f p x → f =ᶠ[nhds x] 0 → p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A one-dimensional formal multilinear series representing a locally zero function is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {σ : Type u_3} [inst_1 : AddCommMonoid M] (w : σ → M) (r : R),\\n  MvPolynomial.IsWeightedHomogeneous w (↑MvPolynomial.C r) 0\",\n  \"isProp\": true,\n  \"docString\": \"Constant polynomials are weighted homogeneous of degree 0. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : ℝ → E) (s : Set ℝ) (x₀ x : ℝ),\\n  taylorWithinEval f 0 s x₀ x = f x₀\",\n  \"isProp\": true,\n  \"docString\": \"The Taylor polynomial of order zero evaluates to `f x`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {U : Set E}, AnalyticOn 𝕜 f U → IsPreconnected U → ∀ {z₀ : E}, z₀ ∈ U → f =ᶠ[nhds z₀] 0 → Set.EqOn f 0 U\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *identity principle* for analytic functions: If an analytic function vanishes in a whole\\nneighborhood of a point `z₀`, then it is uniformly zero along a connected set. For a one-dimensional\\nversion assuming only that the function vanishes at some points arbitrarily close to `z₀`, see\\n`eqOn_zero_of_preconnected_of_frequently_eq_zero`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : ℝ → E) (n : ℕ) (s : Set ℝ) (x₀ : ℝ),\\n  taylorWithinEval f n s x₀ x₀ = f x₀\",\n  \"isProp\": true,\n  \"docString\": \"Evaluating the Taylor polynomial at `x = x₀` yields `f x`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r →\\n    ↑r' < r →\\n      ∃ a,\\n        a ∈ Set.Ioo 0 1 ∧\\n          ∃ C,\\n            C > 0 ∧\\n              ∀ (y : E),\\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {p : FormalMultilinearSeries 𝕜 𝕜 E} {x : 𝕜}, HasFPowerSeriesAt 0 p x → p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A one-dimensional formal multilinear series representing the zero function is zero. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {f : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R → WittVector p R}\\n  [hf : WittVector.IsPoly₂ p f], WittVector.IsPoly p fun R _Rcr x => f x x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The diagonal `λ x, f x x` of a polynomial function `f` is polynomial. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] (I : Ideal (MvPolynomial σ R)) (p : MvPolynomial σ R),\\n  (∀ (m : σ →₀ ℕ), MvPolynomial.coeff m p ∈ Ideal.comap MvPolynomial.C I) → p ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\\nmultivariate version. \"}]\n",
    "prompt_cons": "/-- The *principle of isolated zeros* for an analytic function, local version: if a function is\nanalytic at `z₀`, then either it is identically zero in a neighborhood of `z₀`, or it does not\nvanish in a punctured neighborhood of `z₀`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E} {z₀ : 𝕜},\n  AnalyticAt 𝕜 f z₀ → (∀ᶠ (z : 𝕜) in nhds z₀, f z = 0) ∨ ∀ᶠ (z : 𝕜) in nhdsWithin z₀ {z₀}ᶜ, f z ≠ 0 :=\n\n/-- If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\n  {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → y ∈ EMetric.ball x r → AnalyticAt 𝕜 f y :=\n\n/-- The composition of polynomial functions is polynomial. -/\ntheorem ∀ {p : ℕ} {h : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R → WittVector p R}\n  {f g : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R} [hh : WittVector.IsPoly₂ p h]\n  [hf : WittVector.IsPoly p f] [hg : WittVector.IsPoly p g], WittVector.IsPoly₂ p fun R _Rcr x y => h (f x) (g y) :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem ∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q :=\n\n/-- A function `f : ℂ → ℂ` which is analytic at a point `z₀` is either constant in a neighborhood\nof `z₀`, or behaves locally like an open function (in the sense that the image of every neighborhood\nof `z₀` is a neighborhood of `f z₀`, as in `isOpenMap_iff_nhds_le`). For a function `f : E → ℂ`\nthe same result holds, see `AnalyticAt.eventually_constant_or_nhds_le_map_nhds`. -/\ntheorem ∀ {f : ℂ → ℂ} {z₀ : ℂ}, AnalyticAt ℂ f z₀ → (∀ᶠ (z : ℂ) in nhds z₀, f z = f z₀) ∨ nhds (f z₀) ≤ Filter.map f (nhds z₀) :=\n\n/-- The function that is constantly zero on Witt vectors is a polynomial function. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], WittVector.IsPoly p fun x x_1 x_2 => 0 :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r) :=\n\n/-- An analytic function is infinitely differentiable. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {s : Set E} [inst_5 : CompleteSpace F], AnalyticOn 𝕜 f s → ∀ {n : ℕ∞}, ContDiffOn 𝕜 n f s :=\n\n/-- A complex differentiable function `f : ℂ → E` is analytic at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ (z : ℂ), AnalyticAt ℂ f z :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p :=\n\n/-- A one-dimensional formal multilinear series representing a locally zero function is zero. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {p : FormalMultilinearSeries 𝕜 𝕜 E} {f : 𝕜 → E} {x : 𝕜},\n  HasFPowerSeriesAt f p x → f =ᶠ[nhds x] 0 → p = 0 :=\n\n/-- Constant polynomials are weighted homogeneous of degree 0. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {σ : Type u_3} [inst_1 : AddCommMonoid M] (w : σ → M) (r : R),\n  MvPolynomial.IsWeightedHomogeneous w (↑MvPolynomial.C r) 0 :=\n\n/-- The Taylor polynomial of order zero evaluates to `f x`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : ℝ → E) (s : Set ℝ) (x₀ x : ℝ),\n  taylorWithinEval f 0 s x₀ x = f x₀ :=\n\n/-- The *identity principle* for analytic functions: If an analytic function vanishes in a whole\nneighborhood of a point `z₀`, then it is uniformly zero along a connected set. For a one-dimensional\nversion assuming only that the function vanishes at some points arbitrarily close to `z₀`, see\n`eqOn_zero_of_preconnected_of_frequently_eq_zero`. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {U : Set E}, AnalyticOn 𝕜 f U → IsPreconnected U → ∀ {z₀ : E}, z₀ ∈ U → f =ᶠ[nhds z₀] 0 → Set.EqOn f 0 U :=\n\n/-- Evaluating the Taylor polynomial at `x = x₀` yields `f x`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : ℝ → E) (n : ℕ) (s : Set ℝ) (x₀ : ℝ),\n  taylorWithinEval f n s x₀ x₀ = f x₀ :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r →\n    ↑r' < r →\n      ∃ a,\n        a ∈ Set.Ioo 0 1 ∧\n          ∃ C,\n            C > 0 ∧\n              ∀ (y : E),\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n :=\n\n/-- A one-dimensional formal multilinear series representing the zero function is zero. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {p : FormalMultilinearSeries 𝕜 𝕜 E} {x : 𝕜}, HasFPowerSeriesAt 0 p x → p = 0 :=\n\n/-- The diagonal `λ x, f x x` of a polynomial function `f` is polynomial. -/\ntheorem ∀ {p : ℕ} {f : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R → WittVector p R}\n  [hf : WittVector.IsPoly₂ p f], WittVector.IsPoly p fun R _Rcr x => f x x :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself,\nmultivariate version. -/\ntheorem ∀ {R : Type u} {σ : Type v} [inst : CommRing R] (I : Ideal (MvPolynomial σ R)) (p : MvPolynomial σ R),\n  (∀ (m : σ →₀ ℕ), MvPolynomial.coeff m p ∈ Ideal.comap MvPolynomial.C I) → p ∈ I :=\n\n/-- Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F},\n  Analytic 𝕜 f → (∀ (z₀ : E), ∃ n, (FormalMultilinearSeries 𝕜 E F).coeff (fPowerSeries 𝕜 f z₀) n = 0) → IsPoly 𝕜 f "
    ]
  },
  {
    "docString": "Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"∀ (a : ℝ) {b : ℝ}, 0 < b → MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\": \"`exp (-b * x)` is integrable on `(a, ∞)`. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\\nPicard-Lindelöf/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {a : ℝ}, a < -1 → ∀ {c : ℝ}, 0 < c → MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `0 < c`, then `(λ t : ℝ, t ^ a)` is integrable on `(c, ∞)` for all `a < -1`. \"},\n {\"theorem\": \"∀ (a : ℝ), Cardinal.mk ↑(Set.Iic a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-∞, a]. \"},\n {\"theorem\": \"∀ (a : ℝ), Cardinal.mk ↑(Set.Iio a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-∞, a). \"},\n {\"theorem\":\n  \"∀ (x : ℝ),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ},\\n  a ≤ 0 →\\n    ∀ {z : ℂ},\\n      |z.im| ≤ b →\\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"},\n {\"theorem\":\n  \"∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. \"},\n {\"theorem\":\n  \"∀ {a : ℝ}, 0 < a → ∀ (b : ℝ), (fun x => rexp (-a * x)) =o[Filter.atTop] fun x => x ^ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"`exp (-a * x) = o(x ^ s)` as `x → ∞`, for any positive `a` and real `s`. \"},\n {\"theorem\":\n  \"∀ (z : ℂ),\\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (↑Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\":\n  \"∀ {α : Type u_4} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {𝕜 : Type u_1} [inst_1 : IsROrC 𝕜]\\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E] [inst_4 : NormedSpace 𝕜 E]\\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace 𝕜 H] {F : H → α → E}\\n  {F' : α → H →L[𝕜] E} {x₀ : H} {bound : α → ℝ} {ε : ℝ},\\n  0 < ε →\\n    (∀ᶠ (x : H) in nhds x₀, MeasureTheory.AEStronglyMeasurable (F x) μ) →\\n      MeasureTheory.Integrable (F x₀) →\\n        MeasureTheory.AEStronglyMeasurable F' μ →\\n          (∀ᵐ (a : α) ∂μ, LipschitzOnWith (↑Real.nnabs (bound a)) (fun x => F x a) (Metric.ball x₀ ε)) →\\n            MeasureTheory.Integrable bound →\\n              (∀ᵐ (a : α) ∂μ, HasFDerivAt (fun x => F x a) (F' a) x₀) →\\n                MeasureTheory.Integrable F' ∧ HasFDerivAt (fun x => ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"Differentiation under integral of `x ↦ ∫ F x a` at a given point `x₀`, assuming\\n`F x₀` is integrable, `x ↦ F x a` is locally Lipschitz on a ball around `x₀` for ae `a`\\n(with a ball radius independent of `a`) with integrable Lipschitz bound, and `F x` is ae-measurable\\nfor `x` in a possibly smaller neighborhood of `x₀`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_4} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {𝕜 : Type u_1} [inst_1 : IsROrC 𝕜]\\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E] [inst_4 : NormedSpace 𝕜 E]\\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace 𝕜 H] {F : H → α → E}\\n  {F' : H → α → H →L[𝕜] E} {x₀ : H} {bound : α → ℝ} {ε : ℝ},\\n  0 < ε →\\n    (∀ᶠ (x : H) in nhds x₀, MeasureTheory.AEStronglyMeasurable (F x) μ) →\\n      MeasureTheory.Integrable (F x₀) →\\n        MeasureTheory.AEStronglyMeasurable (F' x₀) μ →\\n          (∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ Metric.ball x₀ ε → ‖F' x a‖ ≤ bound a) →\\n            MeasureTheory.Integrable bound →\\n              (∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ Metric.ball x₀ ε → HasFDerivAt (fun x => F x a) (F' x a) x) →\\n                HasFDerivAt (fun x => ∫ (a : α), F x a ∂μ) (∫ (a : α), F' x₀ a ∂μ) x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"Differentiation under integral of `x ↦ ∫ F x a` at a given point `x₀`, assuming\\n`F x₀` is integrable, `x ↦ F x a` is differentiable on a ball around `x₀` for ae `a` with\\nderivative norm uniformly bounded by an integrable function (the ball radius is independent of `a`),\\nand `F x` is ae-measurable for `x` in a possibly smaller neighborhood of `x₀`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\\n  [inst_6 : FiniteDimensional ℝ V],\\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v)\\n    (Filter.cocompact V) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 as `w → ∞`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\\n  [inst_3 : DenselyOrdered α] (a : α) [inst_4 : NoMinOrder α], closure (Set.Iio a) = Set.Iic a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The closure of the interval `(-∞, a)` is the interval `(-∞, a]`. \"}]\n",
    "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- `exp (-b * x)` is integrable on `(a, ∞)`. -/\ntheorem ∀ (a : ℝ) {b : ℝ}, 0 < b → MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a) :=\n\n/-- Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\nPicard-Lindelöf/Cauchy-Lipschitz theorem. -/\ntheorem ∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If `0 < c`, then `(λ t : ℝ, t ^ a)` is integrable on `(c, ∞)` for all `a < -1`. -/\ntheorem ∀ {a : ℝ}, a < -1 → ∀ {c : ℝ}, 0 < c → MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c) :=\n\n/-- The cardinality of the interval (-∞, a]. -/\ntheorem ∀ (a : ℝ), Cardinal.mk ↑(Set.Iic a) = Cardinal.continuum :=\n\n/-- The cardinality of the interval (-∞, a). -/\ntheorem ∀ (a : ℝ), Cardinal.mk ↑(Set.Iio a) = Cardinal.continuum :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem ∀ (x : ℝ),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem ∀ {a b : ℝ},\n  a ≤ 0 →\n    ∀ {z : ℂ},\n      |z.im| ≤ b →\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. -/\ntheorem ∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I :=\n\n/-- `exp (-a * x) = o(x ^ s)` as `x → ∞`, for any positive `a` and real `s`. -/\ntheorem ∀ {a : ℝ}, 0 < a → ∀ (b : ℝ), (fun x => rexp (-a * x)) =o[Filter.atTop] fun x => x ^ b :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem ∀ (z : ℂ),\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (↑Real.pi * z))) :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a :=\n\n/-- Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem ∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- Differentiation under integral of `x ↦ ∫ F x a` at a given point `x₀`, assuming\n`F x₀` is integrable, `x ↦ F x a` is locally Lipschitz on a ball around `x₀` for ae `a`\n(with a ball radius independent of `a`) with integrable Lipschitz bound, and `F x` is ae-measurable\nfor `x` in a possibly smaller neighborhood of `x₀`. -/\ntheorem ∀ {α : Type u_4} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {𝕜 : Type u_1} [inst_1 : IsROrC 𝕜]\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E] [inst_4 : NormedSpace 𝕜 E]\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace 𝕜 H] {F : H → α → E}\n  {F' : α → H →L[𝕜] E} {x₀ : H} {bound : α → ℝ} {ε : ℝ},\n  0 < ε →\n    (∀ᶠ (x : H) in nhds x₀, MeasureTheory.AEStronglyMeasurable (F x) μ) →\n      MeasureTheory.Integrable (F x₀) →\n        MeasureTheory.AEStronglyMeasurable F' μ →\n          (∀ᵐ (a : α) ∂μ, LipschitzOnWith (↑Real.nnabs (bound a)) (fun x => F x a) (Metric.ball x₀ ε)) →\n            MeasureTheory.Integrable bound →\n              (∀ᵐ (a : α) ∂μ, HasFDerivAt (fun x => F x a) (F' a) x₀) →\n                MeasureTheory.Integrable F' ∧ HasFDerivAt (fun x => ∫ (a : α), F x a ∂μ) (∫ (a : α), F' a ∂μ) x₀ :=\n\n/-- Differentiation under integral of `x ↦ ∫ F x a` at a given point `x₀`, assuming\n`F x₀` is integrable, `x ↦ F x a` is differentiable on a ball around `x₀` for ae `a` with\nderivative norm uniformly bounded by an integrable function (the ball radius is independent of `a`),\nand `F x` is ae-measurable for `x` in a possibly smaller neighborhood of `x₀`. -/\ntheorem ∀ {α : Type u_4} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {𝕜 : Type u_1} [inst_1 : IsROrC 𝕜]\n  {E : Type u_3} [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ℝ E] [inst_4 : NormedSpace 𝕜 E]\n  [inst_5 : CompleteSpace E] {H : Type u_2} [inst_6 : NormedAddCommGroup H] [inst_7 : NormedSpace 𝕜 H] {F : H → α → E}\n  {F' : H → α → H →L[𝕜] E} {x₀ : H} {bound : α → ℝ} {ε : ℝ},\n  0 < ε →\n    (∀ᶠ (x : H) in nhds x₀, MeasureTheory.AEStronglyMeasurable (F x) μ) →\n      MeasureTheory.Integrable (F x₀) →\n        MeasureTheory.AEStronglyMeasurable (F' x₀) μ →\n          (∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ Metric.ball x₀ ε → ‖F' x a‖ ≤ bound a) →\n            MeasureTheory.Integrable bound →\n              (∀ᵐ (a : α) ∂μ, ∀ (x : H), x ∈ Metric.ball x₀ ε → HasFDerivAt (fun x => F x a) (F' x a) x) →\n                HasFDerivAt (fun x => ∫ (a : α), F x a ∂μ) (∫ (a : α), F' x₀ a ∂μ) x₀ :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi :=\n\n/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 as `w → ∞`. -/\ntheorem ∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\n  [inst_6 : FiniteDimensional ℝ V],\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v)\n    (Filter.cocompact V) (nhds 0) :=\n\n/-- The closure of the interval `(-∞, a)` is the interval `(-∞, a]`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] (a : α) [inst_4 : NoMinOrder α], closure (Set.Iio a) = Set.Iic a :=\n\n/-- Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$. -/\ntheorem",
    "choices": [
      "∀ {a : ℝ}, 0 < a → ∫ (x : ℝ) in -∞ ..∞, (x * Real.sin x) / (x ^ 2 + a ^ 2) = Real.pi * Real.exp (-a) "
    ]
  },
  {
    "docString": "Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) [inst : IsTrichotomous α r] [inst : IsIrrefl β s]\\n  (f : α → β), (∀ {x y : α}, r x y → s (f x) (f y)) → Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"An increasing function is injective \"},\n {\"theorem\":\n  \"∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EmbeddingLike F α β] (f : F),\\n  Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\": \"The coercion to functions must produce injective functions. \"},\n {\"theorem\":\n  \"∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e g : E),\\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g\",\n  \"isProp\": true,\n  \"docString\": \"The two coercions to functions are jointly injective. \"},\n {\"theorem\":\n  \"∀ {α : Sort u_3} {β : Sort u_1} {γ : Sort u_2} {g : β → γ},\\n  Function.Injective g → Function.Injective ((fun x x_1 => x ∘ x_1) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition by an injective function on the left is itself injective. \"},\n {\"theorem\":\n  \"∀ {c : ℝ}, 0 < c → c < 1 / 2 → Function.Injective (Cardinal.cantorFunction c)\",\n  \"isProp\": true,\n  \"docString\": \"`cantorFunction c` is injective if `0 < c < 1/2`. \"},\n {\"theorem\":\n  \"∀ {γ : Type u_2} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] {β : Type u_1} [inst : TopologicalSpace β]\\n  [inst_1 : T2Space β] [inst_2 : MeasurableSpace β] [inst_3 : BorelSpace β] {f : γ → β},\\n  Continuous f → Function.Injective f → MeasurableSet (Set.range f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\\nspace is Borel-measurable. \"},\n {\"theorem\":\n  \"∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (α → Sort u_3)} [self : FunLike F α β],\\n  Function.Injective FunLike.coe\",\n  \"isProp\": true,\n  \"docString\": \"The coercion to functions must be injective. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {n : ℕ}, 0 < n → Function.Injective ↑(Polynomial.expand R n)\",\n  \"isProp\": true,\n  \"docString\": \"Expansion is injective. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ↑(algebraMap R A) → ∀ [inst : CharZero R], CharZero A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"theorem\":\n  \"∀ {γ : Type u_1} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] [inst : MeasurableSpace γ] [hγb : BorelSpace γ]\\n  {β : Type u_2} [tβ : TopologicalSpace β] [inst_1 : T2Space β] [inst_2 : MeasurableSpace β] [inst_3 : BorelSpace β]\\n  {f : γ → β}, Continuous f → Function.Injective f → MeasurableEmbedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective continuous function on a Polish space is a measurable embedding. \"},\n {\"theorem\":\n  \"∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\\n  Function.Injective2 f → ∀ (b : β), Function.Injective fun a => f a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A binary injective function is injective when only the left argument varies. \"},\n {\"theorem\":\n  \"∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\\n  Function.Injective2 f → ∀ (a : α), Function.Injective (f a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A binary injective function is injective when only the right argument varies. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Injective f ↔ Setoid.ker f = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function from α to β is injective iff its kernel is the bottom element of the complete lattice\\nof equivalence relations on α. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : NormedAddCommGroup β]\\n  {p : ENNReal} {f : α → β},\\n  MeasureTheory.Memℒp f p →\\n    MeasureTheory.StronglyMeasurable f →\\n      ∀ {ε : ℝ}, 0 < ε → ∃ M, 0 < M ∧ MeasureTheory.snorm (Set.indicator {x | M ≤ ↑‖f x‖₊} f) p μ ≤ ENNReal.ofReal ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"This lemma implies that a single function is uniformly integrable (in the probability sense). \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] (f : V →ₗ[K] V₂),\\n  Function.Injective ↑f → ∀ [inst_5 : FiniteDimensional K V₂], FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective linear map is finite dimensional, the domain must be as well. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\\n  Function.Injective f → Continuous f → T2Space α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : Type u_2} {n : Type u_3} {R : Type u_4} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace α]\\n  {f : α → Matrix m n R}, (∀ (i : m) (j : n), Continuous fun a => f a i j) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a function into matrices is continuous it suffices to show the coefficients of the\\nresulting matrix are continuous \"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"}]\n",
    "prompt_cons": "/-- An increasing function is injective -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) [inst : IsTrichotomous α r] [inst : IsIrrefl β s]\n  (f : α → β), (∀ {x y : α}, r x y → s (f x) (f y)) → Function.Injective f :=\n\n/-- The coercion to functions must produce injective functions. -/\ntheorem ∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EmbeddingLike F α β] (f : F),\n  Function.Injective ↑f :=\n\n/-- The two coercions to functions are jointly injective. -/\ntheorem ∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g :=\n\n/-- Composition by an injective function on the left is itself injective. -/\ntheorem ∀ {α : Sort u_3} {β : Sort u_1} {γ : Sort u_2} {g : β → γ},\n  Function.Injective g → Function.Injective ((fun x x_1 => x ∘ x_1) g) :=\n\n/-- `cantorFunction c` is injective if `0 < c < 1/2`. -/\ntheorem ∀ {c : ℝ}, 0 < c → c < 1 / 2 → Function.Injective (Cardinal.cantorFunction c) :=\n\n/-- The Lusin-Souslin theorem: the range of a continuous injective function defined on a Polish\nspace is Borel-measurable. -/\ntheorem ∀ {γ : Type u_2} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] {β : Type u_1} [inst : TopologicalSpace β]\n  [inst_1 : T2Space β] [inst_2 : MeasurableSpace β] [inst_3 : BorelSpace β] {f : γ → β},\n  Continuous f → Function.Injective f → MeasurableSet (Set.range f) :=\n\n/-- The coercion to functions must be injective. -/\ntheorem ∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (α → Sort u_3)} [self : FunLike F α β],\n  Function.Injective FunLike.coe :=\n\n/-- Expansion is injective. -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {n : ℕ}, 0 < n → Function.Injective ↑(Polynomial.expand R n) :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. -/\ntheorem ∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Function.Injective ↑(algebraMap R A) → ∀ [inst : CharZero R], CharZero A :=\n\n/-- An injective continuous function on a Polish space is a measurable embedding. -/\ntheorem ∀ {γ : Type u_1} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] [inst : MeasurableSpace γ] [hγb : BorelSpace γ]\n  {β : Type u_2} [tβ : TopologicalSpace β] [inst_1 : T2Space β] [inst_2 : MeasurableSpace β] [inst_3 : BorelSpace β]\n  {f : γ → β}, Continuous f → Function.Injective f → MeasurableEmbedding f :=\n\n/-- A binary injective function is injective when only the left argument varies. -/\ntheorem ∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\n  Function.Injective2 f → ∀ (b : β), Function.Injective fun a => f a b :=\n\n/-- A binary injective function is injective when only the right argument varies. -/\ntheorem ∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\n  Function.Injective2 f → ∀ (a : α), Function.Injective (f a) :=\n\n/-- A function from α to β is injective iff its kernel is the bottom element of the complete lattice\nof equivalence relations on α. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} (f : α → β), Function.Injective f ↔ Setoid.ker f = ⊥ :=\n\n/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : NormedAddCommGroup β]\n  {p : ENNReal} {f : α → β},\n  MeasureTheory.Memℒp f p →\n    MeasureTheory.StronglyMeasurable f →\n      ∀ {ε : ℝ}, 0 < ε → ∃ M, 0 < M ∧ MeasureTheory.snorm (Set.indicator {x | M ≤ ↑‖f x‖₊} f) p μ ≤ ENNReal.ofReal ε :=\n\n/-- If the codomain of an injective linear map is finite dimensional, the domain must be as well. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] (f : V →ₗ[K] V₂),\n  Function.Injective ↑f → ∀ [inst_5 : FiniteDimensional K V₂], FiniteDimensional K V :=\n\n/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\n  Function.Injective f → Continuous f → T2Space α :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem ∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f) :=\n\n/-- To show a function into matrices is continuous it suffices to show the coefficients of the\nresulting matrix are continuous -/\ntheorem ∀ {α : Type u_1} {m : Type u_2} {n : Type u_3} {R : Type u_4} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace α]\n  {f : α → Matrix m n R}, (∀ (i : m) (j : n), Continuous fun a => f a i j) → Continuous f :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem ∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f :=\n\n/-- Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$. -/\ntheorem",
    "choices": [
      "∀ {ℂ : Type u} [inst : IsROrC ℂ] {f : ℂ → ℂ},\n  Function.Injective f → DifferentiableAt ℂ f → ∀ z, f' z ≠ 0 → ∃ a b, a ≠ 0 ∧ ∀ z, f z = a * z + b "
    ]
  },
  {
    "docString": "Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$.",
    "prompts": "[{\"theorem\":\n  \"∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) ≤ abs z`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\\n  0 ≤ R →\\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\\n      Set.Countable s →\\n        ContinuousOn f (Metric.closedBall c R) →\\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\\\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {p q : ℝ},\\n  Real.IsConjugateExponent p q →\\n    ∀ {f g : α → ENNReal},\\n      AEMeasurable f →\\n        ∫⁻ (a : α), f a ^ p ∂μ ≠ ⊤ →\\n          ∫⁻ (a : α), g a ^ q ∂μ ≠ ⊤ →\\n            ∫⁻ (a : α), f a ^ p ∂μ ≠ 0 →\\n              ∫⁻ (a : α), g a ^ q ∂μ ≠ 0 →\\n                ∫⁻ (a : α), (f * g) a ∂μ ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), g a ^ q ∂μ) ^ (1 / q)\",\n  \"isProp\": true,\n  \"docString\": \"Hölder's inequality in case of finite non-zero integrals \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E} {c : ℂ},\\n  (∀ᶠ (z : ℂ) in nhdsWithin c {c}ᶜ, DifferentiableAt ℂ f z) →\\n    ((fun z => f z - f c) =o[nhdsWithin c {c}ᶜ] fun z => (z - c)⁻¹) →\\n      Filter.Tendsto f (nhdsWithin c {c}ᶜ) (nhds (limUnder (nhdsWithin c {c}ᶜ) f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Removable singularity** theorem: if a function `f : ℂ → E` is complex differentiable on a\\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. \"},\n {\"theorem\":\n  \"∀ {f : ℂ → ℂ} {c : ℂ} {R : ℝ},\\n  DifferentiableOn ℂ f (Metric.ball c R) →\\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) → f c = c → 0 < R → ↑Complex.abs (deriv f c) ≤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk of positive radius to itself and the\\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\\nthis disk is at most `1`. \"},\n {\"theorem\":\n  \"∀ {f : ℂ → ℂ} {z₀ : ℂ} {ε r : ℝ},\\n  DiffContOnCl ℂ f (Metric.ball z₀ r) →\\n    0 < r →\\n      (∀ (z : ℂ), z ∈ Metric.sphere z₀ r → ε ≤ ‖f z - f z₀‖) →\\n        (∃ᶠ (z : ℂ) in nhds z₀, f z ≠ f z₀) → Metric.ball (f z₀) (ε / 2) ⊆ f '' Metric.closedBall z₀ r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the modulus of a holomorphic function `f` is bounded below by `ε` on a circle, then its range\\ncontains a disk of radius `ε / 2`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E} {z₀ : 𝕜},\\n  AnalyticAt 𝕜 f z₀ → (∀ᶠ (z : 𝕜) in nhds z₀, f z = 0) ∨ ∀ᶠ (z : 𝕜) in nhdsWithin z₀ {z₀}ᶜ, f z ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *principle of isolated zeros* for an analytic function, local version: if a function is\\nanalytic at `z₀`, then either it is identically zero in a neighborhood of `z₀`, or it does not\\nvanish in a punctured neighborhood of `z₀`. \"},\n {\"theorem\":\n  \"∀ {f : ℂ → ℂ} {c z : ℂ} {R : ℝ},\\n  DifferentiableOn ℂ f (Metric.ball c R) →\\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) → f c = c → z ∈ Metric.ball c R → dist (f z) c ≤ dist z c\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk to itself and the center `c` of this\\ndisk to itself, then for any point `z` of this disk we have `dist (f z) c ≤ dist z c`. \"},\n {\"theorem\":\n  \"∀ {u : ℕ → ℝ} (h : Subadditive u),\\n  BddBelow (Set.range fun n => u n / ↑n) → Filter.Tendsto (fun n => u n / ↑n) Filter.atTop (nhds (Subadditive.lim h))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fekete's lemma: a subadditive sequence which is bounded below converges. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → Differentiable 𝕜 fun y => ∑' (n : α), f n y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If all functions in the series are differentiable\\nwith a summable bound on the derivatives, then the series is differentiable.\\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\\nconvergence then the series is zero everywhere so the result still holds. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\\n  [inst_6 : FiniteDimensional ℝ V],\\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v)\\n    (Filter.cocompact V) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 as `w → ∞`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\\n  0 < r →\\n    r ≤ R →\\n      ∀ {f : ℂ → E} {s : Set ℂ},\\n        Set.Countable s →\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) →\\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s → DifferentiableAt ℂ f z) →\\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\\nequal to each other. \"}]\n",
    "prompt_cons": "/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) ≤ abs z`. -/\ntheorem ∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\n  0 ≤ R →\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\n      Set.Countable s →\n        ContinuousOn f (Metric.closedBall c R) →\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0 :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Hölder's inequality in case of finite non-zero integrals -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {p q : ℝ},\n  Real.IsConjugateExponent p q →\n    ∀ {f g : α → ENNReal},\n      AEMeasurable f →\n        ∫⁻ (a : α), f a ^ p ∂μ ≠ ⊤ →\n          ∫⁻ (a : α), g a ^ q ∂μ ≠ ⊤ →\n            ∫⁻ (a : α), f a ^ p ∂μ ≠ 0 →\n              ∫⁻ (a : α), g a ^ q ∂μ ≠ 0 →\n                ∫⁻ (a : α), (f * g) a ∂μ ≤ (∫⁻ (a : α), f a ^ p ∂μ) ^ (1 / p) * (∫⁻ (a : α), g a ^ q ∂μ) ^ (1 / q) :=\n\n/-- **Removable singularity** theorem: if a function `f : ℂ → E` is complex differentiable on a\npunctured neighborhood of `c` and $f(z) - f(c)=o((z-c)^{-1})$, then `f` has a limit at `c`. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E} {c : ℂ},\n  (∀ᶠ (z : ℂ) in nhdsWithin c {c}ᶜ, DifferentiableAt ℂ f z) →\n    ((fun z => f z - f c) =o[nhdsWithin c {c}ᶜ] fun z => (z - c)⁻¹) →\n      Filter.Tendsto f (nhdsWithin c {c}ᶜ) (nhds (limUnder (nhdsWithin c {c}ᶜ) f)) :=\n\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk of positive radius to itself and the\ncenter of this disk to itself, then the absolute value of the derivative of `f` at the center of\nthis disk is at most `1`. -/\ntheorem ∀ {f : ℂ → ℂ} {c : ℂ} {R : ℝ},\n  DifferentiableOn ℂ f (Metric.ball c R) →\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) → f c = c → 0 < R → ↑Complex.abs (deriv f c) ≤ 1 :=\n\n/-- If the modulus of a holomorphic function `f` is bounded below by `ε` on a circle, then its range\ncontains a disk of radius `ε / 2`. -/\ntheorem ∀ {f : ℂ → ℂ} {z₀ : ℂ} {ε r : ℝ},\n  DiffContOnCl ℂ f (Metric.ball z₀ r) →\n    0 < r →\n      (∀ (z : ℂ), z ∈ Metric.sphere z₀ r → ε ≤ ‖f z - f z₀‖) →\n        (∃ᶠ (z : ℂ) in nhds z₀, f z ≠ f z₀) → Metric.ball (f z₀) (ε / 2) ⊆ f '' Metric.closedBall z₀ r :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r) :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- The *principle of isolated zeros* for an analytic function, local version: if a function is\nanalytic at `z₀`, then either it is identically zero in a neighborhood of `z₀`, or it does not\nvanish in a punctured neighborhood of `z₀`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E} {z₀ : 𝕜},\n  AnalyticAt 𝕜 f z₀ → (∀ᶠ (z : 𝕜) in nhds z₀, f z = 0) ∨ ∀ᶠ (z : 𝕜) in nhdsWithin z₀ {z₀}ᶜ, f z ≠ 0 :=\n\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk to itself and the center `c` of this\ndisk to itself, then for any point `z` of this disk we have `dist (f z) c ≤ dist z c`. -/\ntheorem ∀ {f : ℂ → ℂ} {c z : ℂ} {R : ℝ},\n  DifferentiableOn ℂ f (Metric.ball c R) →\n    Set.MapsTo f (Metric.ball c R) (Metric.ball c R) → f c = c → z ∈ Metric.ball c R → dist (f z) c ≤ dist z c :=\n\n/-- Fekete's lemma: a subadditive sequence which is bounded below converges. -/\ntheorem ∀ {u : ℕ → ℝ} (h : Subadditive u),\n  BddBelow (Set.range fun n => u n / ↑n) → Filter.Tendsto (fun n => u n / ↑n) Filter.atTop (nhds (Subadditive.lim h)) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Consider a series of functions `∑' n, f n x`. If all functions in the series are differentiable\nwith a summable bound on the derivatives, then the series is differentiable.\nNote that our assumptions do not ensure the pointwise convergence, but if there is no pointwise\nconvergence then the series is zero everywhere so the result still holds. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → Differentiable 𝕜 fun y => ∑' (n : α), f n y :=\n\n/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 as `w → ∞`. -/\ntheorem ∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\n  [inst_6 : FiniteDimensional ℝ V],\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v)\n    (Filter.cocompact V) (nhds 0) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\nequal to each other. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\n  0 < r →\n    r ≤ R →\n      ∀ {f : ℂ → E} {s : Set ℂ},\n        Set.Countable s →\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) →\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\ Metric.closedBall c r) \\ s → DifferentiableAt ℂ f z) →\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z :=\n\n/-- Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$. -/\ntheorem",
    "choices": [
      "∀ {f : ℂ → ℂ} {z : ℕ → ℂ},\n  DifferentiableOn ℂ f (Metric.ball 0 1) →\n    Bounded (Set.range f) →\n      (∀ (n : ℕ), f (z n) = 0) →\n        (∀ (n : ℕ), ↑Complex.abs (z n) < 1) → Summable (λ n => 1 - ↑Complex.abs (z n)) "
    ]
  },
  {
    "docString": "Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {x y : α}, 0 < x → y < 1 → ∃ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ} {x : ℝ} {n : ℕ},\\n  ConvexOn ℝ (Set.Ioi 0) f →\\n    (∀ {y : ℝ}, 0 < y → f (y + 1) = f y + Real.log y) → 2 ≤ n → 0 < x → f ↑n + x * Real.log (↑n - 1) ≤ f (↑n + x)\",\n  \"isProp\": true,\n  \"docString\": \"Linear lower bound for `f (x + n)` on unit interval \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {n : ℕ∞}, ContDiff 𝕜 n f → 1 ≤ n → Differentiable 𝕜 f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` with `n ≥ 1`, then it is differentiable. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {x : E} {n : ℕ∞}, ContDiffAt 𝕜 n f x → 1 ≤ n → DifferentiableAt 𝕜 f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : Preorder α] {f : Fin (n + 1) → α},\\n  Monotone f ↔ ∀ (i : Fin n), f (Fin.castSucc i) ≤ f (Fin.succ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` on `Fin (n + 1)` is monotone if and only if `f i ≤ f (i + 1)` for all `i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f ≥ 1` on K. \"},\n {\"theorem\":\n  \"∀ {n : ℕ∞} {𝕂 : Type u_1} [inst : IsROrC 𝕂] {F' : Type u_2} [inst_1 : NormedAddCommGroup F'] [inst_2 : NormedSpace 𝕂 F']\\n  {f : 𝕂 → F'} {x : 𝕂}, ContDiff 𝕂 n f → 1 ≤ n → HasStrictDerivAt f (deriv f x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` with `1 ≤ n`, then the derivative of `f` is also a strict derivative. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : Preorder α] {f : Fin (n + 1) → α},\\n  StrictMono f ↔ ∀ (i : Fin n), f (Fin.castSucc i) < f (Fin.succ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` on `Fin (n + 1)` is strictly monotone if and only if `f i < f (i + 1)`\\nfor all `i`. \"},\n {\"theorem\":\n  \"∀ {x : ℝ}, Liouville x → ∀ (n : ℕ), ∃ᶠ (b : ℕ) in Filter.atTop, ∃ a, x ≠ ↑a / ↑b ∧ |x - ↑a / ↑b| < 1 / ↑b ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\\nexists a numerator `a` such that `x ≠ a / b` and `|x - a / b| < 1 / b ^ n`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {s : Set E}\\n  {f : E → F} {n : ℕ∞}, ContDiffOn 𝕜 n f s → 1 ≤ n → DifferentiableOn 𝕜 f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift) (P : ℝ → Prop), (∀ (x : ℝ), x ∈ Set.Icc 0 1 → P (↑f x - x)) → ∀ (x : ℝ), P (↑f x - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a predicate depends only on `f x - x` and holds for all `0 ≤ x ≤ 1`,\\nthen it holds for all `x`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), deriv f x ≤ 0) → Antitone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonpositive, then\\n`f` is an antitone function. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] (f : MeasureTheory.SimpleFunc α NNReal)\\n  {ε : ENNReal},\\n  ε ≠ 0 → ∃ g, (∀ (x : α), ↑f x ≤ g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(↑f x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a simple function `f` with values in `ℝ≥0`, there exists a lower semicontinuous\\nfunction `g ≥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\\n`lintegral`.\\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : Preorder α] {f : Fin (n + 1) → α},\\n  Antitone f ↔ ∀ (i : Fin n), f (Fin.succ i) ≤ f (Fin.castSucc i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f` on `Fin (n + 1)` is antitone if and only if `f (i + 1) ≤ f i` for all `i`. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift) (x : ℝ),\\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : ℝ` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone f → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n]\",\n  \"isProp\": true,\n  \"docString\": \"If `f ≤ g` and `f` is monotone, then `f^[n] ≤ g^[n]`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ} {x : ℝ} {n : ℕ},\\n  ConvexOn ℝ (Set.Ioi 0) f →\\n    (∀ {y : ℝ}, 0 < y → f (y + 1) = f y + Real.log y) → n ≠ 0 → 0 < x → x ≤ 1 → f (↑n + x) ≤ f ↑n + x * Real.log ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Linear upper bound for `f (x + n)` on unit interval \"}]\n",
    "prompt_cons": "/-- If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n] :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {x y : α}, 0 < x → y < 1 → ∃ n, y ^ n < x :=\n\n/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem ∀ {f : ℝ → ℝ} {x : ℝ} {n : ℕ},\n  ConvexOn ℝ (Set.Ioi 0) f →\n    (∀ {y : ℝ}, 0 < y → f (y + 1) = f y + Real.log y) → 2 ≤ n → 0 < x → f ↑n + x * Real.log (↑n - 1) ≤ f (↑n + x) :=\n\n/-- If a function is `C^n` with `n ≥ 1`, then it is differentiable. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {n : ℕ∞}, ContDiff 𝕜 n f → 1 ≤ n → Differentiable 𝕜 f :=\n\n/-- If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {x : E} {n : ℕ∞}, ContDiffAt 𝕜 n f x → 1 ≤ n → DifferentiableAt 𝕜 f x :=\n\n/-- A function `f` on `Fin (n + 1)` is monotone if and only if `f i ≤ f (i + 1)` for all `i`. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : Preorder α] {f : Fin (n + 1) → α},\n  Monotone f ↔ ∀ (i : Fin n), f (Fin.castSucc i) ≤ f (Fin.succ i) :=\n\n/-- For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\nintegral. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f :=\n\n/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f ≥ 1` on K. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x}) :=\n\n/-- If a function is `C^n` with `1 ≤ n`, then the derivative of `f` is also a strict derivative. -/\ntheorem ∀ {n : ℕ∞} {𝕂 : Type u_1} [inst : IsROrC 𝕂] {F' : Type u_2} [inst_1 : NormedAddCommGroup F'] [inst_2 : NormedSpace 𝕂 F']\n  {f : 𝕂 → F'} {x : 𝕂}, ContDiff 𝕂 n f → 1 ≤ n → HasStrictDerivAt f (deriv f x) x :=\n\n/-- A function `f` on `Fin (n + 1)` is strictly monotone if and only if `f i < f (i + 1)`\nfor all `i`. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : Preorder α] {f : Fin (n + 1) → α},\n  StrictMono f ↔ ∀ (i : Fin n), f (Fin.castSucc i) < f (Fin.succ i) :=\n\n/-- If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\nexists a numerator `a` such that `x ≠ a / b` and `|x - a / b| < 1 / b ^ n`. -/\ntheorem ∀ {x : ℝ}, Liouville x → ∀ (n : ℕ), ∃ᶠ (b : ℕ) in Filter.atTop, ∃ a, x ≠ ↑a / ↑b ∧ |x - ↑a / ↑b| < 1 / ↑b ^ n :=\n\n/-- If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {s : Set E}\n  {f : E → F} {n : ℕ∞}, ContDiffOn 𝕜 n f s → 1 ≤ n → DifferentiableOn 𝕜 f s :=\n\n/-- If a predicate depends only on `f x - x` and holds for all `0 ≤ x ≤ 1`,\nthen it holds for all `x`. -/\ntheorem ∀ (f : CircleDeg1Lift) (P : ℝ → Prop), (∀ (x : ℝ), x ∈ Set.Icc 0 1 → P (↑f x - x)) → ∀ (x : ℝ), P (↑f x - x) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonpositive, then\n`f` is an antitone function. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), deriv f x ≤ 0) → Antitone f :=\n\n/-- Given a simple function `f` with values in `ℝ≥0`, there exists a lower semicontinuous\nfunction `g ≥ f` with integral arbitrarily close to that of `f`. Formulation in terms of\n`lintegral`.\nAuxiliary lemma for Vitali-Carathéodory theorem `exists_lt_lower_semicontinuous_integral_lt`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] (f : MeasureTheory.SimpleFunc α NNReal)\n  {ε : ENNReal},\n  ε ≠ 0 → ∃ g, (∀ (x : α), ↑f x ≤ g x) ∧ LowerSemicontinuous g ∧ ∫⁻ (x : α), ↑(g x) ∂μ ≤ ∫⁻ (x : α), ↑(↑f x) ∂μ + ε :=\n\n/-- A function `f` on `Fin (n + 1)` is antitone if and only if `f (i + 1) ≤ f i` for all `i`. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : Preorder α] {f : Fin (n + 1) → α},\n  Antitone f ↔ ∀ (i : Fin n), f (Fin.succ i) ≤ f (Fin.castSucc i) :=\n\n/-- For any `x : ℝ` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem ∀ (f : CircleDeg1Lift) (x : ℝ),\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- If `f ≤ g` and `f` is monotone, then `f^[n] ≤ g^[n]`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f g : α → α}, Monotone f → f ≤ g → ∀ (n : ℕ), f^[n] ≤ g^[n] :=\n\n/-- Linear upper bound for `f (x + n)` on unit interval -/\ntheorem ∀ {f : ℝ → ℝ} {x : ℝ} {n : ℕ},\n  ConvexOn ℝ (Set.Ioi 0) f →\n    (∀ {y : ℝ}, 0 < y → f (y + 1) = f y + Real.log y) → n ≠ 0 → 0 < x → x ≤ 1 → f (↑n + x) ≤ f ↑n + x * Real.log ↑n :=\n\n/-- Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$. -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ} [inst : ∀ (n : ℕ), Differentiable ℝ^n f] (hf₀ : f 0 = 0) (hf₁ : f 1 = 1) (hf_pos : ∀ x, 0 ≤ f x),\n  ∃ (n : ℕ) (x : ℝ), n > 0 ∧ f^[n] x < 0 "
    ]
  },
  {
    "docString": "Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic.",
    "prompts": "[{\"theorem\": \"∀ {n : ℕ}, orderOf (QuaternionGroup.a 1) = 2 * n\",\n  \"isProp\": true,\n  \"docString\": \"If `0 < n`, then `a 1` has order `2 * n`.\\n\"},\n {\"theorem\": \"∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialNumerators (GeneralizedContinuedFraction.of v)) n = some a →\\n    a = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that the partial numerators `aᵢ` are equal to one. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] (a : R) {n : ℕ}, n ≠ 0 → Polynomial.Monic (Polynomial.X ^ n - ↑Polynomial.C a)\",\n  \"isProp\": true,\n  \"docString\": \"`X ^ n - a` is monic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRightRegular (a ^ n) ↔ IsRightRegular a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `a` is right-regular if and only if a positive power of `a` is right-regular. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"∀ (n a : ℕ) (p : ℕ → Prop) [inst : DecidablePred p],\\n  Function.Periodic p a → Finset.card (Finset.filter p (Finset.Ico n (n + a))) = Nat.count p a\",\n  \"isProp\": true,\n  \"docString\":\n  \"An interval of length `a` filtered over a periodic predicate of period `a` has cardinality\\nequal to the number naturals below `a` for which `p a` is true. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRegular (a ^ n) ↔ IsRegular a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `a` is regular if and only if a positive power of `a` is regular. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\\n  Function.Periodic f c → 0 < c → ∀ (x a : α), ∃ y, y ∈ Set.Ico a (a + c) ∧ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ∈ Ico a (a + c)` such that `f x = f y`. \"},\n {\"theorem\":\n  \"∀ {x : ℝ}, Liouville x → ∀ (n : ℕ), ∃ᶠ (b : ℕ) in Filter.atTop, ∃ a, x ≠ ↑a / ↑b ∧ |x - ↑a / ↑b| < 1 / ↑b ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\\nexists a numerator `a` such that `x ≠ a / b` and `|x - a / b| < 1 / b ^ n`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\\n  Function.Periodic f c → 0 < c → ∀ (x : α), ∃ y, y ∈ Set.Ico 0 c ∧ f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\\n`y ∈ Ico 0 c` such that `f x = f y`. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {n : ℕ} [inst : NeZero n] (i : ZMod (2 * n)), orderOf (QuaternionGroup.a i) = 2 * n / Nat.gcd (2 * n) (ZMod.val i)\",\n  \"isProp\": true,\n  \"docString\": \"If `0 < n`, then `a i` has order `(2 * n) / gcd (2 * n) i`.\\n\"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {𝕜 : Type u_2} {𝔸 : Type u_3} [inst : NormedField 𝕜] [inst_1 : NormedAddCommGroup 𝔸]\\n  [inst_2 : NormedSpace 𝕜 𝔸] {l : Filter ι} {ε : ι → 𝕜} {f : ι → 𝔸},\\n  Filter.Tendsto ε l (nhds 0) →\\n    Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) l (norm ∘ f) → Filter.Tendsto (ε • f) l (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The (scalar) product of a sequence that tends to zero with a bounded one also tends to zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence on the natural numbers is bounded. \"}]\n",
    "prompt_cons": "/-- If `0 < n`, then `a 1` has order `2 * n`. -/\ntheorem ∀ {n : ℕ}, orderOf (QuaternionGroup.a 1) = 2 * n :=\n\n/-- `a ^ 0 = 1` -/\ntheorem ∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem ∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x :=\n\n/-- Shows that the partial numerators `aᵢ` are equal to one. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialNumerators (GeneralizedContinuedFraction.of v)) n = some a →\n    a = 1 :=\n\n/-- `X ^ n - a` is monic. -/\ntheorem ∀ {R : Type u} [inst : Ring R] (a : R) {n : ℕ}, n ≠ 0 → Polynomial.Monic (Polynomial.X ^ n - ↑Polynomial.C a) :=\n\n/-- An element `a` is right-regular if and only if a positive power of `a` is right-regular. -/\ntheorem ∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRightRegular (a ^ n) ↔ IsRightRegular a) :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f) :=\n\n/-- An interval of length `a` filtered over a periodic predicate of period `a` has cardinality\nequal to the number naturals below `a` for which `p a` is true. -/\ntheorem ∀ (n a : ℕ) (p : ℕ → Prop) [inst : DecidablePred p],\n  Function.Periodic p a → Finset.card (Finset.filter p (Finset.Ico n (n + a))) = Nat.count p a :=\n\n/-- An element `a` is regular if and only if a positive power of `a` is regular. -/\ntheorem ∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRegular (a ^ n) ↔ IsRegular a) :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ∈ Ico a (a + c)` such that `f x = f y`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  Function.Periodic f c → 0 < c → ∀ (x a : α), ∃ y, y ∈ Set.Ico a (a + c) ∧ f x = f y :=\n\n/-- If `x` is a Liouville number, then for any `n`, for infinitely many denominators `b` there\nexists a numerator `a` such that `x ≠ a / b` and `|x - a / b| < 1 / b ^ n`. -/\ntheorem ∀ {x : ℝ}, Liouville x → ∀ (n : ℕ), ∃ᶠ (b : ℕ) in Filter.atTop, ∃ a, x ≠ ↑a / ↑b ∧ |x - ↑a / ↑b| < 1 / ↑b ^ n :=\n\n/-- If a function `f` is `periodic` with positive period `c`, then for all `x` there exists some\n`y ∈ Ico 0 c` such that `f x = f y`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {c : α} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  Function.Periodic f c → 0 < c → ∀ (x : α), ∃ y, y ∈ Set.Ico 0 c ∧ f x = f y :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- If `0 < n`, then `a i` has order `(2 * n) / gcd (2 * n) i`. -/\ntheorem ∀ {n : ℕ} [inst : NeZero n] (i : ZMod (2 * n)), orderOf (QuaternionGroup.a i) = 2 * n / Nat.gcd (2 * n) (ZMod.val i) :=\n\n/-- The (scalar) product of a sequence that tends to zero with a bounded one also tends to zero. -/\ntheorem ∀ {ι : Type u_1} {𝕜 : Type u_2} {𝔸 : Type u_3} [inst : NormedField 𝕜] [inst_1 : NormedAddCommGroup 𝔸]\n  [inst_2 : NormedSpace 𝕜 𝔸] {l : Filter ι} {ε : ι → 𝕜} {f : ι → 𝔸},\n  Filter.Tendsto ε l (nhds 0) →\n    Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) l (norm ∘ f) → Filter.Tendsto (ε • f) l (nhds 0) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- A Cauchy sequence on the natural numbers is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {u : ℕ → α}, CauchySeq u → ∃ R, R > 0 ∧ ∀ (m n : ℕ), dist (u m) (u n) < R :=\n\n/-- Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic. -/\ntheorem",
    "choices": [
      "∀ {a : ℝ} (x : ℕ → ℝ), x 0 = 1 → x 1 = a → x 2 = a → (∃ n, x n = 0) → Function.Periodic x (2 * n) "
    ]
  },
  {
    "docString": "Let",
    "prompts": "[{\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\\n  CategoryTheory.CategoryStruct.comp self.g₁ self.f₁ = CategoryTheory.CategoryStruct.comp self.g₂ self.f₂\",\n  \"isProp\": true,\n  \"docString\": \"The relation itself. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] (s : Finset α), BddBelow ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finset is bounded below. \"},\n {\"theorem\":\n  \"∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The ideal is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (o : Part α), { Dom := o.Dom, get := fun h => Part.get o h } = o\",\n  \"isProp\": true,\n  \"docString\": \"`Part` eta expansion \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}\\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C → D}\\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] (X : C),\\n  (CategoryTheory.MonoidalCategory.leftUnitor (F X)).hom =\\n    CategoryTheory.CategoryStruct.comp\\n      (CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.LaxMonoidal.ε (CategoryTheory.CategoryStruct.id (F X)))\\n      (CategoryTheory.CategoryStruct.comp\\n        (CategoryTheory.LaxMonoidal.μ (CategoryTheory.MonoidalCategory.tensorUnit C) X)\\n        (CategoryTheory.map F (CategoryTheory.MonoidalCategory.leftUnitor X).hom))\",\n  \"isProp\": true,\n  \"docString\": \"left unitality \"},\n {\"theorem\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsProper I], ↑I ≠ Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"This ideal is not the whole set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {o p : Part α}, (o.Dom ↔ p.Dom) → (∀ (h₁ : o.Dom) (h₂ : p.Dom), Part.get o h₁ = Part.get p h₂) → o = p\",\n  \"isProp\": true,\n  \"docString\": \"`Part` extensionality \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] (self : ClosureOperator α) (x : α), x ≤ ↑self.toOrderHom x\",\n  \"isProp\": true,\n  \"docString\": \"An element is less than or equal its closure \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}\\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C → D}\\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] {X Y X' Y' : C} (f : X ⟶ Y)\\n  (g : X' ⟶ Y'),\\n  CategoryTheory.CategoryStruct.comp\\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.map F f) (CategoryTheory.map F g))\\n      (CategoryTheory.LaxMonoidal.μ Y Y') =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.LaxMonoidal.μ X X')\\n      (CategoryTheory.map F (CategoryTheory.MonoidalCategory.tensorHom f g))\",\n  \"isProp\": true,\n  \"docString\": \"naturality \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\\n  Nonempty (CategoryTheory.SplitEpi f)\",\n  \"isProp\": true,\n  \"docString\": \"There is a splitting \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  ‖x - y‖ ^ 2 = ‖x‖ ^ 2 - 2 * inner x y + ‖y‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Expand the square \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\\n  (∀ (n : ℕ), Measurable (f n)) →\\n    ∫⁻ (a : α), Filter.liminf (fun n => f n a) Filter.atTop ∂μ ≤\\n      Filter.liminf (fun n => ∫⁻ (a : α), f n a ∂μ) Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"Known as Fatou's lemma \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : ι → Set X} {s : Set X}\\n  (self : ShrinkingLemma.PartialRefinement u s), s ⊆ ⋃ (i : ι), ShrinkingLemma.PartialRefinement.toFun self i\",\n  \"isProp\": true,\n  \"docString\": \"The partially refined family still covers the set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : Nonempty α] (s : Finset α), BddAbove ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finset is bounded above. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [self : InvolutiveStar R], Function.Involutive star\",\n  \"isProp\": true,\n  \"docString\": \"Involutive condition. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (self : Projectivization.Subspace K V) (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) (hvw : v + w ≠ 0),\\n  Projectivization.mk K v hv ∈ self.carrier →\\n    Projectivization.mk K w hw ∈ self.carrier → Projectivization.mk K (v + w) hvw ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The addition rule. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ : List (α × Bool)} {x : α × Bool}, FreeGroup.Red [x] L₁ ↔ L₁ = [x]\",\n  \"isProp\": true,\n  \"docString\": \"A letter only reduces to itself. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  quadraticCharFun F a = 0 ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\": \"Some basic API lemmas \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : ι → Set X} {s : Set X}\\n  (self : ShrinkingLemma.PartialRefinement u s) (i : ι), IsOpen (ShrinkingLemma.PartialRefinement.toFun self i)\",\n  \"isProp\": true,\n  \"docString\": \"Each set from the partially refined family is open. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] (x : 𝕜) {𝕜' : Type u_1} [inst_1 : NontriviallyNormedField 𝕜']\\n  [inst_2 : NormedAlgebra 𝕜 𝕜'] {h : 𝕜 → 𝕜'} {h₂ : 𝕜' → 𝕜'} {h' h₂' : 𝕜'},\\n  HasDerivAt h₂ h₂' (h x) → HasDerivAt h h' x → HasDerivAt (h₂ ∘ h) (h₂' * h') x\",\n  \"isProp\": true,\n  \"docString\": \"The chain rule. \"}]\n",
    "prompt_cons": "/-- The relation itself. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.CategoryStruct.comp self.g₁ self.f₁ = CategoryTheory.CategoryStruct.comp self.g₂ self.f₂ :=\n\n/-- A finset is bounded below. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] (s : Finset α), BddBelow ↑s :=\n\n/-- The ideal is nonempty. -/\ntheorem ∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier :=\n\n/-- `Part` eta expansion -/\ntheorem ∀ {α : Type u_1} (o : Part α), { Dom := o.Dom, get := fun h => Part.get o h } = o :=\n\n/-- left unitality -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C → D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] (X : C),\n  (CategoryTheory.MonoidalCategory.leftUnitor (F X)).hom =\n    CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom CategoryTheory.LaxMonoidal.ε (CategoryTheory.CategoryStruct.id (F X)))\n      (CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.LaxMonoidal.μ (CategoryTheory.MonoidalCategory.tensorUnit C) X)\n        (CategoryTheory.map F (CategoryTheory.MonoidalCategory.leftUnitor X).hom)) :=\n\n/-- This ideal is not the whole set. -/\ntheorem ∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsProper I], ↑I ≠ Set.univ :=\n\n/-- `Part` extensionality -/\ntheorem ∀ {α : Type u_1} {o p : Part α}, (o.Dom ↔ p.Dom) → (∀ (h₁ : o.Dom) (h₂ : p.Dom), Part.get o h₁ = Part.get p h₂) → o = p :=\n\n/-- An element is less than or equal its closure -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] (self : ClosureOperator α) (x : α), x ≤ ↑self.toOrderHom x :=\n\n/-- naturality -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}\n  [inst_2 : CategoryTheory.Category D] [inst_3 : CategoryTheory.MonoidalCategory D] {F : C → D}\n  [inst_4 : CategoryTheory.Functorial F] [self : CategoryTheory.LaxMonoidal F] {X Y X' Y' : C} (f : X ⟶ Y)\n  (g : X' ⟶ Y'),\n  CategoryTheory.CategoryStruct.comp\n      (CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.map F f) (CategoryTheory.map F g))\n      (CategoryTheory.LaxMonoidal.μ Y Y') =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.LaxMonoidal.μ X X')\n      (CategoryTheory.map F (CategoryTheory.MonoidalCategory.tensorHom f g)) :=\n\n/-- There is a splitting -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} [self : CategoryTheory.IsSplitEpi f],\n  Nonempty (CategoryTheory.SplitEpi f) :=\n\n/-- Expand the square -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  ‖x - y‖ ^ 2 = ‖x‖ ^ 2 - 2 * inner x y + ‖y‖ ^ 2 :=\n\n/-- Known as Fatou's lemma -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\n  (∀ (n : ℕ), Measurable (f n)) →\n    ∫⁻ (a : α), Filter.liminf (fun n => f n a) Filter.atTop ∂μ ≤\n      Filter.liminf (fun n => ∫⁻ (a : α), f n a ∂μ) Filter.atTop :=\n\n/-- The partially refined family still covers the set. -/\ntheorem ∀ {ι : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : ι → Set X} {s : Set X}\n  (self : ShrinkingLemma.PartialRefinement u s), s ⊆ ⋃ (i : ι), ShrinkingLemma.PartialRefinement.toFun self i :=\n\n/-- A finset is bounded above. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : Nonempty α] (s : Finset α), BddAbove ↑s :=\n\n/-- Involutive condition. -/\ntheorem ∀ {R : Type u} [self : InvolutiveStar R], Function.Involutive star :=\n\n/-- The addition rule. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (self : Projectivization.Subspace K V) (v w : V) (hv : v ≠ 0) (hw : w ≠ 0) (hvw : v + w ≠ 0),\n  Projectivization.mk K v hv ∈ self.carrier →\n    Projectivization.mk K w hw ∈ self.carrier → Projectivization.mk K (v + w) hvw ∈ self.carrier :=\n\n/-- A letter only reduces to itself. -/\ntheorem ∀ {α : Type u} {L₁ : List (α × Bool)} {x : α × Bool}, FreeGroup.Red [x] L₁ ↔ L₁ = [x] :=\n\n/-- Some basic API lemmas -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  quadraticCharFun F a = 0 ↔ a = 0 :=\n\n/-- Each set from the partially refined family is open. -/\ntheorem ∀ {ι : Type u_1} {X : Type u_2} [inst : TopologicalSpace X] {u : ι → Set X} {s : Set X}\n  (self : ShrinkingLemma.PartialRefinement u s) (i : ι), IsOpen (ShrinkingLemma.PartialRefinement.toFun self i) :=\n\n/-- The chain rule. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] (x : 𝕜) {𝕜' : Type u_1} [inst_1 : NontriviallyNormedField 𝕜']\n  [inst_2 : NormedAlgebra 𝕜 𝕜'] {h : 𝕜 → 𝕜'} {h₂ : 𝕜' → 𝕜'} {h' h₂' : 𝕜'},\n  HasDerivAt h₂ h₂' (h x) → HasDerivAt h h' x → HasDerivAt (h₂ ∘ h) (h₂' * h') x :=\n\n/-- Let -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {f : α → β} {g : β → γ} {a : α} {b : β} {c : γ},\n  f a = b → g b = c → (g ∘ f) a = c "
    ]
  },
  {
    "docString": "Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {b : ℕ} {l : List ℕ}, (∀ (x : ℕ), x ∈ l → x < b + 2) → Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b + 2 is less than (b + 2)^n \"},\n {\"theorem\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, Pell.IsFundamental a → StrictMono fun n => Pell.Solution₁.y (a ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The map sending an integer `n` to the `y`-coordinate of `a^n` for a fundamental\\nsolution `a` is stritcly increasing. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` \"},\n {\"theorem\":\n  \"∀ {n : ℕ} (q : ℕ) {p : ℕ},\\n  Nat.Prime p →\\n    p ≤ 2 * q → (n < q → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n) → n < p → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\\ndescending list of primes, each no more than twice the next, such that the list contains a witness\\nfor each number ≤ n.\\n\"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b ≥ 2 \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\\n    1 ≤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (a : R) (n : ℕ),\\n  Polynomial.rootMultiplicity a ((Polynomial.X - ↑Polynomial.C a) ^ n) = n\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of `a` as root of `(X - a) ^ n` is `n`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem ∀ {b : ℕ} {l : List ℕ}, (∀ (x : ℕ), x ∈ l → x < b + 2) → Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem ∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- The map sending an integer `n` to the `y`-coordinate of `a^n` for a fundamental\nsolution `a` is stritcly increasing. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, Pell.IsFundamental a → StrictMono fun n => Pell.Solution₁.y (a ^ n) :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹ :=\n\n/-- Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\ndescending list of primes, each no more than twice the next, such that the list contains a witness\nfor each number ≤ n. -/\ntheorem ∀ {n : ℕ} (q : ℕ) {p : ℕ},\n  Nat.Prime p →\n    p ≤ 2 * q → (n < q → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n) → n < p → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The digits in the base b expansion of n are all less than b, if b ≥ 2 -/\ntheorem ∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\n    1 ≤ b :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- The multiplicity of `a` as root of `(X - a) ^ n` is `n`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (a : R) (n : ℕ),\n  Polynomial.rootMultiplicity a ((Polynomial.X - ↑Polynomial.C a) ^ n) = n :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1 :=\n\n/-- Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$. -/\ntheorem",
    "choices": [
      "∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 "
    ]
  },
  {
    "docString": "Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$.",
    "prompts": "[{\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), deriv^[2] f x < 0) → StrictConcaveOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `ℝ`, and `f''` is strictly negative on `ℝ`,\\nthen `f` is strictly concave on `ℝ`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly negative, except at at most one point. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), 0 < deriv^[2] f x) → StrictConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `ℝ`, and `f''` is strictly positive on `ℝ`,\\nthen `f` is strictly convex on `ℝ`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly positive, except at at most one point. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), deriv^[2] f x ≤ 0) → ConcaveOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `ℝ`, and `f''` is nonpositive on `ℝ`,\\nthen `f` is concave on `ℝ`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C < deriv f x) → ∀ ⦃x y : ℝ⦄, x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `C < f'`, then `f` grows faster than\\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  StrictConcaveOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is strictly concave iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  ConcaveOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is concave iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), 0 ≤ deriv^[2] f x) → ConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `ℝ`, and `f''` is nonnegative on `ℝ`,\\nthen `f` is convex on `ℝ`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D → ∀ {f : ℝ → ℝ}, ContinuousOn f D → (∀ (x : ℝ), x ∈ D → 0 < deriv^[2] f x) → StrictConvexOn ℝ D f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on a convex set `D ⊆ ℝ` and `f''` is strictly positive on `D`,\\nthen `f` is strictly convex on `D`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly positive, except at at most one point. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  ConvexOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is convex iff for any three points `x < y < z` the slope of the secant\\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  StrictConvexOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is strictly convex iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  ConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → 𝕜` is concave, then for any three points `x < y < z` the slope of the secant line of\\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\": \"∀ {f : ℝ → ℝ}, (∀ (x : ℝ), 0 < deriv f x) → StrictMono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f'` is positive, then\\n`f` is a strictly monotone function.\\nNote that we don't require differentiability explicitly as it already implied by the derivative\\nbeing strictly positive. \"}]\n",
    "prompt_cons": "/-- If a function `f` is continuous on `ℝ`, and `f''` is strictly negative on `ℝ`,\nthen `f` is strictly concave on `ℝ`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly negative, except at at most one point. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), deriv^[2] f x < 0) → StrictConcaveOn ℝ Set.univ f :=\n\n/-- If a function `f` is continuous on `ℝ`, and `f''` is strictly positive on `ℝ`,\nthen `f` is strictly convex on `ℝ`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly positive, except at at most one point. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), 0 < deriv^[2] f x) → StrictConvexOn ℝ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- If a function `f` is twice differentiable on `ℝ`, and `f''` is nonpositive on `ℝ`,\nthen `f` is concave on `ℝ`. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), deriv^[2] f x ≤ 0) → ConcaveOn ℝ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `C < f'`, then `f` grows faster than\n`C * x`, i.e., `C * (y - x) < f y - f x` whenever `x < y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C < deriv f x) → ∀ ⦃x y : ℝ⦄, x < y → C * (y - x) < f y - f x :=\n\n/-- A function `f : 𝕜 → 𝕜` is strictly concave iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  StrictConcaveOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f :=\n\n/-- A function `f : 𝕜 → 𝕜` is concave iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  ConcaveOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x) :=\n\n/-- If a function `f` is twice differentiable on `ℝ`, and `f''` is nonnegative on `ℝ`,\nthen `f` is convex on `ℝ`. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), 0 ≤ deriv^[2] f x) → ConvexOn ℝ Set.univ f :=\n\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0} :=\n\n/-- If a function `f` is continuous on a convex set `D ⊆ ℝ` and `f''` is strictly positive on `D`,\nthen `f` is strictly convex on `D`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly positive, except at at most one point. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D → ∀ {f : ℝ → ℝ}, ContinuousOn f D → (∀ (x : ℝ), x ∈ D → 0 < deriv^[2] f x) → StrictConvexOn ℝ D f :=\n\n/-- A function `f : 𝕜 → 𝕜` is convex iff for any three points `x < y < z` the slope of the secant\nline of `f` on `[x, y]` is less than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  ConvexOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) ≤ (f z - f y) / (z - y) :=\n\n/-- A function `f : 𝕜 → 𝕜` is strictly convex iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly less than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  StrictConvexOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f y - f x) / (y - x) < (f z - f y) / (z - y) :=\n\n/-- If `f : 𝕜 → 𝕜` is concave, then for any three points `x < y < z` the slope of the secant line of\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  ConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f'` is positive, then\n`f` is a strictly monotone function.\nNote that we don't require differentiability explicitly as it already implied by the derivative\nbeing strictly positive. -/\ntheorem ∀ {f : ℝ → ℝ}, (∀ (x : ℝ), 0 < deriv f x) → StrictMono f :=\n\n/-- Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$. -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ},\n  Continuous f →\n  Continuous (deriv f) →\n  Continuous (deriv^[2] f) →\n  (∀ (x : ℝ), 0 < f x) →\n  (∀ (x : ℝ), 0 < deriv f x) →\n  (∀ (x : ℝ), 0 < deriv^[2] f x) →\n  (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n  (∀ (x : ℝ), deriv f x < 2 * f x) "
    ]
  },
  {
    "docString": "Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer.",
    "prompts": "[{\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal a b (-c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `π`, the first and third points are not equal. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₁ ≠ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first and third points are not\\nequal. \"},\n {\"theorem\": \"∀ (n a b : ℕ), n < a ∨ b ≤ n ∨ n ∈ List.Ico a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural numbers n, a, and b, one of the following holds:\\n1. n < a\\n2. n ≥ b\\n3. n ∈ Ico a b\\n\"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `π / 2`, the first and third points are not equal. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\": \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ ≠ 0 → p₁ ≠ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is nonzero, the first and third points are not equal. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `π`, the first two points are not equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"}]\n",
    "prompt_cons": "/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal a b (-c) :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem ∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0 :=\n\n/-- If the angle between three points is `π`, the first and third points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₃ :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- If the sign of the angle between three points is positive, the first and third points are not\nequal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₁ ≠ p₃ :=\n\n/-- For any natural numbers n, a, and b, one of the following holds:\n1. n < a\n2. n ≥ b\n3. n ∈ Ico a b -/\ntheorem ∀ (n a b : ℕ), n < a ∨ b ≤ n ∨ n ∈ List.Ico a b :=\n\n/-- If the angle between three points is `π / 2`, the first and third points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₃ :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem ∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1) :=\n\n/-- If the angle between three points is nonzero, the first and third points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ ≠ 0 → p₁ ≠ p₃ :=\n\n/-- If the angle between three points is `π`, the first two points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₂ :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c :=\n\n/-- Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer. -/\ntheorem",
    "choices": [
      "∀ (a b c : ℤ), ∃ (n : ℕ), ¬∃ (m : ℕ), Real.sqrt (↑n ^ 3 + a * ↑n ^ 2 + b * ↑n + c) = ↑m "
    ]
  },
  {
    "docString": "Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U Z : Set α},\\n  IsPreirreducible Z → Set.Nonempty U → IsOpen U → U ⊆ S → S ⊆ Z → IsIrreducible S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `∅ ≠ U ⊆ S ⊆ Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\\n  U ∈ ⨆ (x : α) (_ : x ∈ s), nhds x → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsOpen t → IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] ⦃U : Set α⦄,\\n  IsOpen U →\\n    ∀ (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.Measure.Regular μ],\\n      ↑↑μ U = ⨆ (K : Set α) (_ : K ⊆ U) (_ : IsCompact K), ↑↑μ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of an open set is the supremum of the measures of compact sets it contains. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\\n  IsOpen s → Set.Nonempty s → Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ K + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 1 ∧ K * V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `K * V ⊆ U`. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ V + K ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `V + K ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\\n  [inst_2 : MeasureTheory.Measure.Regular μ] ⦃U : Set α⦄,\\n  IsOpen U → ∀ {r : ENNReal}, r < ↑↑μ U → ∃ K, K ⊆ U ∧ IsCompact K ∧ r < ↑↑μ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `μ` is a regular measure, then any open set can be approximated by a compact subset. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 1 ∧ V * K ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\\nsuch that `V * K ⊆ U`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\\n  [inst_2 : MeasureTheory.Measure.WeaklyRegular μ] ⦃U : Set α⦄,\\n  IsOpen U → ∀ {r : ENNReal}, r < ↑↑μ U → ∃ F, F ⊆ U ∧ IsClosed F ∧ r < ↑↑μ F\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `μ` is a weakly regular measure, then any open set can be approximated by a closed subset. \"}]\n",
    "prompt_cons": "/-- If `∅ ≠ U ⊆ S ⊆ Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U Z : Set α},\n  IsPreirreducible Z → Set.Nonempty U → IsOpen U → U ⊆ S → S ⊆ Z → IsIrreducible S :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\n  U ∈ ⨆ (x : α) (_ : x ∈ s), nhds x → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsOpen t → IsCompact (s \\ t) :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s) :=\n\n/-- The measure of an open set is the supremum of the measures of compact sets it contains. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] ⦃U : Set α⦄,\n  IsOpen U →\n    ∀ (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.Measure.Regular μ],\n      ↑↑μ U = ⨆ (K : Set α) (_ : K ⊆ U) (_ : IsCompact K), ↑↑μ K :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\n  IsOpen s → Set.Nonempty s → Dense s :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ K + V ⊆ U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `K * V ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 1 ∧ K * V ⊆ U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `V + K ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ V + K ⊆ U :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n\n/-- If `μ` is a regular measure, then any open set can be approximated by a compact subset. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  [inst_2 : MeasureTheory.Measure.Regular μ] ⦃U : Set α⦄,\n  IsOpen U → ∀ {r : ENNReal}, r < ↑↑μ U → ∃ K, K ⊆ U ∧ IsCompact K ∧ r < ↑↑μ K :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of `1`\nsuch that `V * K ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : MulOneClass G] [inst_2 : ContinuousMul G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 1 ∧ V * K ⊆ U :=\n\n/-- If `μ` is a weakly regular measure, then any open set can be approximated by a closed subset. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  [inst_2 : MeasureTheory.Measure.WeaklyRegular μ] ⦃U : Set α⦄,\n  IsOpen U → ∀ {r : ENNReal}, r < ↑↑μ U → ∃ F, F ⊆ U ∧ IsClosed F ∧ r < ↑↑μ F :=\n\n/-- Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ ∀ (x : α), x ∈ U → ¬(∀ V ∈ nhds x, Set.Nonempty (V ∩ Uᶜ)) "
    ]
  },
  {
    "docString": "Show that every subset of $\\mathbb{N}$ is clopen.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (self : DiscreteQuotient X) (x : X),\\n  IsOpen (setOf (Setoid.Rel self.toSetoid x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every point `x`, the set `{ y | Rel x y }` is a clopen set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"∀ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {α : Type u₁}\\n  {β : Type u_1} {s : Set (β → M)},\\n  Set.Definable A L s → ∀ (f : α → β) [inst_1 : Finite α] [inst_2 : Finite β], Set.Definable A L ((fun g => g ∘ f) '' s)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that definability is closed under finite projections. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z : Set α}, IsClopen Z → ⋃ (x : α) (_ : x ∈ Z), connectedComponent x = Z\",\n  \"isProp\": true,\n  \"docString\": \"A clopen set is the union of its connected components. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {s₁ s₂ : Set E}, s₁ ⊆ s₂ → Bornology.IsVonNBounded 𝕜 s₂ → Bornology.IsVonNBounded 𝕜 s₁\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of bounded sets are bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] [inst_5 : T2Space E] {s : Set E},\\n  Set.Finite s → IsClosed (↑(convexHull ℝ) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsPreconnected s → IsClopen t → Disjoint s t ∨ s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Preconnected sets are either contained in or disjoint to any given clopen set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\\n  IsClosed s →\\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, s ⊆ t → Metric.Bounded t → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a bounded set are also bounded \"}]\n",
    "prompt_cons": "/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a} :=\n\n/-- For every point `x`, the set `{ y | Rel x y }` is a clopen set. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (self : DiscreteQuotient X) (x : X),\n  IsOpen (setOf (Setoid.Rel self.toSetoid x)) :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U :=\n\n/-- Shows that definability is closed under finite projections. -/\ntheorem ∀ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {α : Type u₁}\n  {β : Type u_1} {s : Set (β → M)},\n  Set.Definable A L s → ∀ (f : α → β) [inst_1 : Finite α] [inst_2 : Finite β], Set.Definable A L ((fun g => g ∘ f) '' s) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- A clopen set is the union of its connected components. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z : Set α}, IsClopen Z → ⋃ (x : α) (_ : x ∈ Z), connectedComponent x = Z :=\n\n/-- Subsets of bounded sets are bounded. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\n  [inst_3 : TopologicalSpace E] {s₁ s₂ : Set E}, s₁ ⊆ s₂ → Bornology.IsVonNBounded 𝕜 s₂ → Bornology.IsVonNBounded 𝕜 s₁ :=\n\n/-- The set of finite subsets of a countable set is countable. -/\ntheorem ∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s} :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n\n/-- Convex hull of a finite set is closed. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] [inst_5 : T2Space E] {s : Set E},\n  Set.Finite s → IsClosed (↑(convexHull ℝ) s) :=\n\n/-- Preconnected sets are either contained in or disjoint to any given clopen set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsPreconnected s → IsClopen t → Disjoint s t ∨ s ⊆ t :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\n  IsClosed s →\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S :=\n\n/-- Subsets of a bounded set are also bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, s ⊆ t → Metric.Bounded t → Metric.Bounded s :=\n\n/-- Show that every subset of $\\mathbb{N}$ is clopen. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α] {s : Set α}, IsClopen s "
    ]
  },
  {
    "docString": "Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Add G] [self : UniqueSums G] {A B : Finset G},\\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueAdd A B a0 b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\\n`UniqueAdd A B a0 b0` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Mul G] [self : UniqueProds G] {A B : Finset G},\\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueMul A B a0 b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\\n`UniqueMul A B a0 b0` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m0 : MeasurableSpace α} [inst : TopologicalSpace α] {μ : MeasureTheory.Measure α}\\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts μ] ⦃K : Set α⦄, IsCompact K → ↑↑μ K < ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact subset has finite measure for a measure which is finite on compacts. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded below \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, IsCompact s → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded \"},\n {\"theorem\":\n  \"∀ (f : StieltjesFunction) {a b : ℝ} {c d : ℕ → ℝ},\\n  Set.Icc a b ⊆ ⋃ (i : ℕ), Set.Ioo (c i) (d i) →\\n    ENNReal.ofReal (↑f b - ↑f a) ≤ ∑' (i : ℕ), ENNReal.ofReal (↑f (d i) - ↑f (c i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact interval `[a, b]` is covered by a union of open interval `(c i, d i)`, then\\n`f b - f a ≤ ∑ f (d i) - f (c i)`. This is an auxiliary technical statement to prove the same\\nstatement for half-open intervals, the point of the current statement being that one can use\\ncompactness to reduce it to a finite sum, and argue by induction on the size of the covering set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\\n  {K L : Set G}, IsCompact K → IsCompact L → ∃ g, Disjoint K (g • L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two compact sets in a noncompact topological group, there is a translate of the second\\none that is disjoint from the first one. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a ≤ a + b` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded above \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"}]\n",
    "prompt_cons": "/-- For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\n`UniqueAdd A B a0 b0` -/\ntheorem ∀ {G : Type u_1} [inst : Add G] [self : UniqueSums G] {A B : Finset G},\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueAdd A B a0 b0 :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\n`UniqueMul A B a0 b0` -/\ntheorem ∀ {G : Type u_1} [inst : Mul G] [self : UniqueProds G] {A B : Finset G},\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueMul A B a0 b0 :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem ∀ {α : Type u_1} {m0 : MeasurableSpace α} [inst : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts μ] ⦃K : Set α⦄, IsCompact K → ↑↑μ K < ⊤ :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤ :=\n\n/-- A compact set is bounded below -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddBelow s :=\n\n/-- A compact set is bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, IsCompact s → Metric.Bounded s :=\n\n/-- If a compact interval `[a, b]` is covered by a union of open interval `(c i, d i)`, then\n`f b - f a ≤ ∑ f (d i) - f (c i)`. This is an auxiliary technical statement to prove the same\nstatement for half-open intervals, the point of the current statement being that one can use\ncompactness to reduce it to a finite sum, and argue by induction on the size of the covering set. -/\ntheorem ∀ (f : StieltjesFunction) {a b : ℝ} {c d : ℕ → ℝ},\n  Set.Icc a b ⊆ ⋃ (i : ℕ), Set.Ioo (c i) (d i) →\n    ENNReal.ofReal (↑f b - ↑f a) ≤ ∑' (i : ℕ), ENNReal.ofReal (↑f (d i) - ↑f (c i)) :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- Given two compact sets in a noncompact topological group, there is a translate of the second\none that is disjoint from the first one. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]\n  {K L : Set G}, IsCompact K → IsCompact L → ∃ g, Disjoint K (g • L) :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- For any `a` and `b`, `a ≤ a + b` -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K :=\n\n/-- The Hausdorff distance between two sets and their closures coincide -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t :=\n\n/-- A compact set is bounded above -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddAbove s :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n\n/-- Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {A B : Set α},\n  IsCompact A → IsCompact B → Set.Nonempty A → Set.Nonempty B → Disjoint A B →\n  ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, Metric.dist a0 b0 ≤ Metric.dist a b "
    ]
  },
  {
    "docString": "Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `ℕ`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s)\",\n  \"isProp\": true,\n  \"docString\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v} [hι : Nonempty ι],\\n  IsCompact s →\\n    ∀ (U : ι → Set α), (∀ (i : ι), IsOpen (U i)) → s ⊆ ⋃ (i : ι), U i → Directed (fun x x_1 => x ⊆ x_1) U → ∃ i, s ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open directed cover of a compact set, there exists a single element of the\\ncover which itself includes the set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α]\\n  [inst_3 : Encodable β] {f : β → Set α},\\n  (∀ (s : β), IsClosed (f s)) → ⋃ (s : β), f s = Set.univ → ∃ s, Set.Nonempty (interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"One of the most useful consequences of Baire theorem: if a countable union of closed sets\\ncovers the space, then one of the sets has nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Set.Finite s → IsCompact (↑(convexHull ℝ) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] {K V : Set G},\\n  IsCompact K → Set.Nonempty (interior V) → ∃ t, K ⊆ ⋃ (g : G) (_ : g ∈ t), (fun h => g + h) ⁻¹' V\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set is covered by finitely many left additive translates of a set\\nwith non-empty interior.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) →\\n    Pairwise (Disjoint on s) →\\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"}]\n",
    "prompt_cons": "/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `ℕ`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- The intrinsic interior of a nonempty convex set is nonempty. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s) :=\n\n/-- For every open directed cover of a compact set, there exists a single element of the\ncover which itself includes the set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v} [hι : Nonempty ι],\n  IsCompact s →\n    ∀ (U : ι → Set α), (∀ (i : ι), IsOpen (U i)) → s ⊆ ⋃ (i : ι), U i → Directed (fun x x_1 => x ⊆ x_1) U → ∃ i, s ⊆ U i :=\n\n/-- If a compact set is covered by two open sets, then we can cover it by two compact subsets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {K U V : Set α},\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂ :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α]\n  [inst_3 : Encodable β] {f : β → Set α},\n  (∀ (s : β), IsClosed (f s)) → ⋃ (s : β), f s = Set.univ → ∃ s, Set.Nonempty (interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Convex hull of a finite set is compact. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Set.Finite s → IsCompact (↑(convexHull ℝ) s) :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s) :=\n\n/-- A compact set is covered by finitely many left additive translates of a set\nwith non-empty interior. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] {K V : Set G},\n  IsCompact K → Set.Nonempty (interior V) → ∃ t, K ⊆ ⋃ (g : G) (_ : g ∈ t), (fun h => g + h) ⁻¹' V :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) →\n    Pairwise (Disjoint on s) →\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α) :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) "
    ]
  },
  {
    "docString": "Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {𝕂 : Type u_1} [inst : IsROrC 𝕂] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace 𝕂 E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace 𝕂 F'] {f : E' → F'} {x : E'},\\n  ContDiffAt 𝕂 1 f x → ∃ K t, t ∈ nhds x ∧ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\\n  {s : Set E} {x y : E},\\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero Fréchet derivative at every point of a convex set,\\nthen it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\\n  (C : ENNReal) {f : α → ENNReal},\\n  AEMeasurable f → (∀ (s : Set α), MeasurableSet s → ↑↑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) → ∫⁻ (x : α), f x ∂μ ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the Lebesgue integral of a function is bounded by some constant on all sets with finite\\nmeasure and the measure is σ-finite, then the integral over the whole space is bounded by that same\\nconstant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\\n  ContractingWith K f →\\n    ∀ (g : α → α) {x y : α},\\n      Function.IsFixedPt f x →\\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F'' : Type u_3} [inst : Norm E] [inst_1 : NormedAddCommGroup F''] {f : α → E}\\n  {g'' : α → F''}, f =O[Filter.cofinite] g'' → ∃ C, C > 0 ∧ ∀ ⦃x : α⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\\n`‖f x‖ ≤ C * ‖g x‖` whenever `g x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\\n`x < y`. \"}]\n",
    "prompt_cons": "/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem ∀ {𝕂 : Type u_1} [inst : IsROrC 𝕂] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace 𝕂 E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace 𝕂 F'] {f : E' → F'} {x : E'},\n  ContDiffAt 𝕂 1 f x → ∃ K t, t ∈ nhds x ∧ LipschitzOnWith K f t :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- If a function has zero Fréchet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\n  {s : Set E} {x y : E},\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y :=\n\n/-- If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n] :=\n\n/-- If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem ∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f :=\n\n/-- If the Lebesgue integral of a function is bounded by some constant on all sets with finite\nmeasure and the measure is σ-finite, then the integral over the whole space is bounded by that same\nconstant. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\n  (C : ENNReal) {f : α → ENNReal},\n  AEMeasurable f → (∀ (s : Set α), MeasurableSet s → ↑↑μ s ≠ ⊤ → ∫⁻ (x : α) in s, f x ∂μ ≤ C) → ∫⁻ (x : α), f x ∂μ ≤ C :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- Let `f` be a contracting map with constant `K`; let `g` be another map uniformly\n`C`-close to `f`. If `x` and `y` are their fixed points, then `dist x y ≤ C / (1 - K)`. -/\ntheorem ∀ {α : Type u_1} [inst : MetricSpace α] {K : NNReal} {f : α → α},\n  ContractingWith K f →\n    ∀ (g : α → α) {x y : α},\n      Function.IsFixedPt f x →\n        Function.IsFixedPt g y → ∀ {C : ℝ}, (∀ (z : α), dist (f z) (g z) ≤ C) → dist x y ≤ C / (1 - ↑K) :=\n\n/-- If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f :=\n\n/-- If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that\n`‖f x‖ ≤ C * ‖g x‖` whenever `g x ≠ 0`. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F'' : Type u_3} [inst : Norm E] [inst_1 : NormedAddCommGroup F''] {f : α → E}\n  {g'' : α → F''}, f =O[Filter.cofinite] g'' → ∃ C, C > 0 ∧ ∀ ⦃x : α⦄, g'' x ≠ 0 → ‖f x‖ ≤ C * ‖g'' x‖ :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x) :=\n\n/-- Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant. -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ}, (∀ (t x : ℝ), abs (f t - f x) ≤ abs (t - x) ^ 2) → ∀ (x y : ℝ), f x = f y "
    ]
  },
  {
    "docString": "Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$.",
    "prompts": "[{\"theorem\": \"∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\": \"∀ {p : ℝ}, (Summable fun n => (↑n ^ p)⁻¹) ↔ 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"∀ {x : ℝ}, |x| < 1 → HasSum (fun n => x ^ (n + 1) / (↑n + 1)) (-Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\": \"Power series expansion of the logarithm around `1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\": \"∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p\",\n  \"isProp\": true,\n  \"docString\": \"Summability of the `p`-series over `ℤ`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ → Prop) [inst : DecidablePred p] (n : ℕ), Nat.count p n = Fintype.card { k // k < n ∧ p k }\",\n  \"isProp\": true,\n  \"docString\":\n  \"`count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. \"},\n {\"theorem\":\n  \"∀ {x y : ℤ} {n : ℕ},\\n  2 ∣ x - y →\\n    ¬2 ∣ x →\\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\\n  (p : FormalMultilinearSeries 𝕜 E F),\\n  0 < FormalMultilinearSeries.radius p →\\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the sum of a converging power series `p` admits `p` as a power series.\\nThis is not totally obvious as we need to check the convergence of the series. \"},\n {\"theorem\":\n  \"∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\\n      MeasureTheory.Integrable bound →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. \"},\n {\"theorem\": \"∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2`  \"},\n {\"theorem\":\n  \"∀ (n p : ℕ),\\n  (Finset.sum (Finset.range n) fun k => ↑k ^ p) =\\n    Finset.sum (Finset.range (p + 1)) fun i => bernoulli i * ↑(Nat.choose (p + 1) i) * ↑n ^ (p + 1 - i) / (↑p + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Faulhaber's theorem** relating the **sum of of p-th powers** to the Bernoulli numbers:\\n$$\\\\sum_{k=0}^{n-1} k^p = \\\\sum_{i=0}^p B_i\\\\binom{p+1}{i}\\\\frac{n^{p+1-i}}{p+1}.$$\\nSee https://proofwiki.org/wiki/Faulhaber%27s_Formula and [orosi2018faulhaber] for\\nthe proof provided here. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {a : ℝ}, 0 < a → HasSum (fun k => 2 * (1 / (2 * ↑k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + a⁻¹))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Expansion of `log (1 + a⁻¹)` as a series in powers of `1 / (2 * a + 1)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\\n  {μ : MeasureTheory.Measure α},\\n  p ≠ 0 →\\n    p ≠ ⊤ →\\n      ∀ {P : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ } → Prop},\\n        (∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : ↑↑μ s < ⊤),\\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : ↑↑μ s ≠ ⊤) c)) →\\n          (∀ ⦃f g : MeasureTheory.SimpleFunc α E⦄ (hf : MeasureTheory.Memℒp (↑f) p) (hg : MeasureTheory.Memℒp (↑g) p),\\n              Disjoint (Function.support ↑f) (Function.support ↑g) →\\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) →\\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) →\\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) →\\n            ∀ (f : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ }), P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary `Lp` simple function, with `0 < p < ∞`, it suffices to show\\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\\nsets and is closed under addition (of functions with disjoint support). \"}]\n",
    "prompt_cons": "/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem ∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\nif and only if `1 < p`. -/\ntheorem ∀ {p : ℝ}, (Summable fun n => (↑n ^ p)⁻¹) ↔ 1 < p :=\n\n/-- Power series expansion of the logarithm around `1`. -/\ntheorem ∀ {x : ℝ}, |x| < 1 → HasSum (fun n => x ^ (n + 1) / (↑n + 1)) (-Real.log (1 - x)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- Summability of the `p`-series over `ℤ`. -/\ntheorem ∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p :=\n\n/-- `count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. -/\ntheorem ∀ (p : ℕ → Prop) [inst : DecidablePred p] (n : ℕ), Nat.count p n = Fintype.card { k // k < n ∧ p k } :=\n\n/-- If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. -/\ntheorem ∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0 :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem ∀ {x y : ℤ} {n : ℕ},\n  2 ∣ x - y →\n    ¬2 ∣ x →\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n :=\n\n/-- In a complete space, the sum of a converging power series `p` admits `p` as a power series.\nThis is not totally obvious as we need to check the convergence of the series. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\n  (p : FormalMultilinearSeries 𝕜 E F),\n  0 < FormalMultilinearSeries.radius p →\n    HasFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 (FormalMultilinearSeries.radius p) :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem ∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\n      MeasureTheory.Integrable bound →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f)) :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem ∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2` -/\ntheorem ∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c :=\n\n/-- **Faulhaber's theorem** relating the **sum of of p-th powers** to the Bernoulli numbers:\n$$\\sum_{k=0}^{n-1} k^p = \\sum_{i=0}^p B_i\\binom{p+1}{i}\\frac{n^{p+1-i}}{p+1}.$$\nSee https://proofwiki.org/wiki/Faulhaber%27s_Formula and [orosi2018faulhaber] for\nthe proof provided here. -/\ntheorem ∀ (n p : ℕ),\n  (Finset.sum (Finset.range n) fun k => ↑k ^ p) =\n    Finset.sum (Finset.range (p + 1)) fun i => bernoulli i * ↑(Nat.choose (p + 1) i) * ↑n ^ (p + 1 - i) / (↑p + 1) :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Expansion of `log (1 + a⁻¹)` as a series in powers of `1 / (2 * a + 1)`. -/\ntheorem ∀ {a : ℝ}, 0 < a → HasSum (fun k => 2 * (1 / (2 * ↑k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1)) (Real.log (1 + a⁻¹)) :=\n\n/-- To prove something for an arbitrary `Lp` simple function, with `0 < p < ∞`, it suffices to show\nthat the property holds for (multiples of) characteristic functions of finite-measure measurable\nsets and is closed under addition (of functions with disjoint support). -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {p : ENNReal}\n  {μ : MeasureTheory.Measure α},\n  p ≠ 0 →\n    p ≠ ⊤ →\n      ∀ {P : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ } → Prop},\n        (∀ (c : E) {s : Set α} (hs : MeasurableSet s) (hμs : ↑↑μ s < ⊤),\n            P (MeasureTheory.Lp.simpleFunc.indicatorConst p hs (_ : ↑↑μ s ≠ ⊤) c)) →\n          (∀ ⦃f g : MeasureTheory.SimpleFunc α E⦄ (hf : MeasureTheory.Memℒp (↑f) p) (hg : MeasureTheory.Memℒp (↑g) p),\n              Disjoint (Function.support ↑f) (Function.support ↑g) →\n                P (MeasureTheory.Lp.simpleFunc.toLp f hf) →\n                  P (MeasureTheory.Lp.simpleFunc.toLp g hg) →\n                    P (MeasureTheory.Lp.simpleFunc.toLp f hf + MeasureTheory.Lp.simpleFunc.toLp g hg)) →\n            ∀ (f : { x // x ∈ MeasureTheory.Lp.simpleFunc E p μ }), P f :=\n\n/-- Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$. -/\ntheorem",
    "choices": [
      "∀ {p : ℝ}, 1 < p → Summable (λ k => 1 / (↑k * Real.log (↑k) ^ p)) "
    ]
  },
  {
    "docString": "A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous, periodic function is bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : MeasurableSpace β] [inst_4 : TopologicalSpace β] [inst_5 : BorelSpace β]\\n  {f : α → β} {s : Set α} {μ : MeasureTheory.Measure α}, ContinuousOn f s → MeasurableSet s → AEMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which is continuous on a set `s` is almost everywhere measurable with respect to\\n`μ.restrict s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformlyOn F f p s →\\n    (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit on a set of functions which are continuous on this set is itself\\ncontinuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform limit on a set of functions which are continuous on this set is itself continuous\\non this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\\n  Filter.Tendsto b (nhds 0) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace β] [inst_4 : TopologicalSpace.PseudoMetrizableSpace β]\\n  {f : α → β} {s : Set α} {μ : MeasureTheory.Measure α},\\n  ContinuousOn f s →\\n    IsCompact s → MeasurableSet s → MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.restrict μ s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which is continuous on a compact set `s` is almost everywhere strongly measurable\\nwith respect to `μ.restrict s`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X → Y}\\n  {s : Set X}, HolderOnWith C r f s → 0 < r → UniformContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\": \"A Hölder continuous function is uniformly continuous \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\\n  Filter.Tendsto b (nhds 0) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → Equicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nequicontinuity is to show that all of the functions share a common *global* continuity modulus. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\\n  Continuous f → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function is monotone with respect to the specialization preorders on the domain and\\nthe codomain. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous, periodic function is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\n  Function.Periodic f c → c ≠ 0 → Continuous f → Metric.Bounded (Set.range f) :=\n\n/-- A function which is continuous on a set `s` is almost everywhere measurable with respect to\n`μ.restrict s`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : MeasurableSpace β] [inst_4 : TopologicalSpace β] [inst_5 : BorelSpace β]\n  {f : α → β} {s : Set α} {μ : MeasureTheory.Measure α}, ContinuousOn f s → MeasurableSet s → AEMeasurable f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformlyOn F f p s →\n    (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformlyOn F f p s → (∀ᶠ (n : ι) in p, ContinuousOn (F n) s) → ∀ [inst_2 : Filter.NeBot p], ContinuousOn f s :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\n  Filter.Tendsto b (nhds 0) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A function which is continuous on a compact set `s` is almost everywhere strongly measurable\nwith respect to `μ.restrict s`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : TopologicalSpace β] [inst_4 : TopologicalSpace.PseudoMetrizableSpace β]\n  {f : α → β} {s : Set α} {μ : MeasureTheory.Measure α},\n  ContinuousOn f s →\n    IsCompact s → MeasurableSet s → MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.restrict μ s) :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X → Y}\n  {s : Set X}, HolderOnWith C r f s → 0 < r → UniformContinuousOn f s :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nequicontinuity is to show that all of the functions share a common *global* continuity modulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\n  Filter.Tendsto b (nhds 0) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → Equicontinuous F :=\n\n/-- A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\n  Continuous f → Monotone f :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousAt f x :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : PseudoMetricSpace β] {f : α → β} {a b : α},\n  (∀ (s t : α), a ≤ s → s ≤ t → t ≤ b → dist (f s) (f t) ≤ (λ x, x) (dist s t)) ↔ UniformContinuousOn f (Set.Icc a b) "
    ]
  },
  {
    "docString": "If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {a b : R}, a * b = 1 → IsRightRegular a\",\n  \"isProp\": true,\n  \"docString\": \"An element admitting a right inverse is right-regular. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 → IsLeftRegular a\",\n  \"isProp\": true,\n  \"docString\": \"An element admitting a left inverse is left-regular. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"}]\n",
    "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹ :=\n\n/-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\ntheorem ∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0 :=\n\n/-- An element admitting a right inverse is right-regular. -/\ntheorem ∀ {R : Type u_1} [inst : Monoid R] {a b : R}, a * b = 1 → IsRightRegular a :=\n\n/-- `G` is closed under inverses -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier :=\n\n/-- An element admitting a left inverse is left-regular. -/\ntheorem ∀ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 → IsLeftRegular a :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ a : G, a ≠ 1 ∧ a * a = 1 "
    ]
  },
  {
    "docString": "If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$.",
    "prompts": "[{\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\": \"∀ {n : ℕ}, Fin n → 0 < n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If you actually have an element of `Fin n`, then the `n` is always positive \"},\n {\"theorem\":\n  \"∀ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRightRegular (a ^ n) ↔ IsRightRegular a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `a` is right-regular if and only if a positive power of `a` is right-regular. \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1 :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- If you actually have an element of `Fin n`, then the `n` is always positive -/\ntheorem ∀ {n : ℕ}, Fin n → 0 < n :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem ∀ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem ∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- An element `a` is right-regular if and only if a positive power of `a` is right-regular. -/\ntheorem ∀ {R : Type u_1} {a : R} [inst : Monoid R] {n : ℕ}, 0 < n → (IsRightRegular (a ^ n) ↔ IsRightRegular a) :=\n\n/-- If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n : ℕ, 0 < n ∧ a ^ n = 1 "
    ]
  },
  {
    "docString": "If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.numerators g n = ppredA →\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.continuants g n = ppred →\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.denominators g n = ppredB →\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"}]\n",
    "prompt_cons": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.numerators g n = ppredA →\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c) :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.continuants g n = ppred →\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.denominators g n = ppredB →\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥ :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant μ :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  (∀ i ∈ [1, 2, 3], (a * b) ^ i = a ^ i * b ^ i) → Commute a b "
    ]
  },
  {
    "docString": "Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a | b^e) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\\n  Nat.card { x // x ∈ commutator G } ∣\\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card ↑(commutatorSet G) + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` has `n` commutators `[g₁, g₂]`, then `|G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\\nwhere `G'` denotes the commutator of `G`. \"}]\n",
    "prompt_cons": "/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹ :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1 :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem ∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹ :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If `G` has `n` commutators `[g₁, g₂]`, then `|G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\nwhere `G'` denotes the commutator of `G`. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\n  Nat.card { x // x ∈ commutator G } ∣\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card ↑(commutatorSet G) + 1) :=\n\n/-- Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (n : ℕ) (h : ∀ a b : G, (a * b) ^ n = a ^ n * b ^ n),\n  1 < n → ∀ a b : G, (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 "
    ]
  },
  {
    "docString": "If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\\n  IsUnit ↑p ↔ ¬p ∣ ringChar R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a finite commutative ring `R`\\niff it does not divide the characteristic. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A p-group is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G :=\n\n/-- A prime `p` is a unit in a finite commutative ring `R`\niff it does not divide the characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\n  IsUnit ↑p ↔ ¬p ∣ ringChar R :=\n\n/-- If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ (H : Subgroup G), H = ⊥ ∨ H = ⊤) → Fintype.card G = p → IsCyclic G "
    ]
  },
  {
    "docString": "Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\": \"∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a | b^e) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b)\",\n  \"isProp\": true,\n  \"docString\": \"$a^{-1}ba$ is a vector. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `⊥` or `⊤` \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformFun α G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. \"},\n {\"theorem\":\n  \"∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ),\\n  (∀ (p : ℕ) (pp : Nat.Prime p), p ≠ 2 → legendreSym p a = ↑χ ↑p) → ∀ {b : ℕ}, Odd b → jacobiSym a b = ↑χ ↑b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `χ` is a multiplicative function such that `J(a | p) = χ p` for all odd primes `p`,\\nthen `J(a | b)` equals `χ b` for all odd natural numbers `b`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"}]\n",
    "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e :=\n\n/-- $a^{-1}ba$ is a vector. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b) :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Any normal subgroup is either `⊥` or `⊤` -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤ :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant μ :=\n\n/-- If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. -/\ntheorem ∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun α G) :=\n\n/-- If `χ` is a multiplicative function such that `J(a | p) = χ p` for all odd primes `p`,\nthen `J(a | b)` equals `χ b` for all odd natural numbers `b`. -/\ntheorem ∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ),\n  (∀ (p : ℕ) (pp : Nat.Prime p), p ≠ 2 → legendreSym p a = ↑χ ↑p) → ∀ {b : ℕ}, Odd b → jacobiSym a b = ↑χ ↑b :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H : NormalizerCondition G) (a b : G),\n  ∃ (j : ℤ), b * a = a ^ j * b "
    ]
  },
  {
    "docString": "Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] {P : Prop},\\n  (∀ (p : ℕ), p > 0 → MixedCharZero R p → P) ↔ ∀ (p : ℕ), Nat.Prime p → MixedCharZero R p → P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\\ncan always assume that `p` is prime.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\\n  p ≠ 0 → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- Reduction to `p` prime: When proving any statement `P` about mixed characteristic rings we\ncan always assume that `p` is prime. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] {P : Prop},\n  (∀ (p : ℕ), p > 0 → MixedCharZero R p → P) ↔ ∀ (p : ℕ), Nat.Prime p → MixedCharZero R p → P :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R) :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\n  p ≠ 0 → Nat.Prime p :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {p n m : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m → ¬p ∣ m →\n    ∀ {H : AddSubgroup G}, Fintype.card { x // x ∈ H } = p ^ n → AddSubgroup.IsCharSubgroup H "
    ]
  },
  {
    "docString": "Prove that a group of order 9 must be abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasStrongEpiMonoFactorisations C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has strong epi-mono factorisations. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category is idempotent complete. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {C : Type u}, Quiver.IsThin (CategoryTheory.FreeMonoidalCategory C)\",\n  \"isProp\": true,\n  \"docString\": \"The monoidal coherence theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"}]\n",
    "prompt_cons": "/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem ∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant μ :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- An abelian category has strong epi-mono factorisations. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasStrongEpiMonoFactorisations C :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- An abelian category is idempotent complete. -/\ntheorem ∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\n  CategoryTheory.IsIdempotentComplete D :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- The monoidal coherence theorem. -/\ntheorem ∀ {C : Type u}, Quiver.IsThin (CategoryTheory.FreeMonoidalCategory C) :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- Prove that a group of order 9 must be abelian. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Fintype.card α = 9 → IsLieAbelian α "
    ]
  },
  {
    "docString": "Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] [inst_2 : FiniteDimensional ℝ F] {n : ℕ}\\n  (φ : F ≃ₗᵢ[ℝ] F),\\n  FiniteDimensional.finrank ℝ\\n        { x // x ∈ (LinearMap.ker (ContinuousLinearMap.id ℝ F - ↑(ContinuousLinearEquiv.mk φ.toLinearEquiv)))ᗮ } ≤\\n      n →\\n    ∃ l, List.length l ≤ n ∧ φ = List.prod (List.map (fun v => reflection (Submodule.span ℝ {v})ᗮ) l)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `φ` of the orthogonal group of `F` can be factored as a product of reflections, and\\nspecifically at most as many reflections as the dimension of the complement of the fixed subspace\\nof `φ`. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inversion is a group homomorphism if the group is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\\n  ↑h (x / y) = ↑h x / ↑h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\\n  AddSubgroup.Characteristic H → ∀ (ϕ : A ≃+ A), AddSubgroup.comap (AddEquiv.toAddMonoidHom ϕ) H = H\",\n  \"isProp\": true,\n  \"docString\": \"`H` is fixed by all automorphisms \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n",
    "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant μ :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹ :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- An element `φ` of the orthogonal group of `F` can be factored as a product of reflections, and\nspecifically at most as many reflections as the dimension of the complement of the fixed subspace\nof `φ`. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] [inst_2 : FiniteDimensional ℝ F] {n : ℕ}\n  (φ : F ≃ₗᵢ[ℝ] F),\n  FiniteDimensional.finrank ℝ\n        { x // x ∈ (LinearMap.ker (ContinuousLinearMap.id ℝ F - ↑(ContinuousLinearEquiv.mk φ.toLinearEquiv)))ᗮ } ≤\n      n →\n    ∃ l, List.length l ≤ n ∧ φ = List.prod (List.map (fun v => reflection (Submodule.span ℝ {v})ᗮ) l) :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem ∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹ :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\n  ↑h (x / y) = ↑h x / ↑h y :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- `H` is fixed by all automorphisms -/\ntheorem ∀ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\n  AddSubgroup.Characteristic H → ∀ (ϕ : A ≃+ A), AddSubgroup.comap (AddEquiv.toAddMonoidHom ϕ) H = H :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (ϕ : G ≃* G), ∀ (x : G), ϕ x = x⁻¹ ∧ Fintype.card { x // ϕ x = x⁻¹ } > (3 * Fintype.card G) / 4) →\n    ∀ (y : G), ∃ (ϕ : G ≃* G), ϕ y = y⁻¹ ∧ ∀ (x : G), ϕ x = x⁻¹ "
    ]
  },
  {
    "docString": "If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\\na homomorphism from the whole of `G` to `F`. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"∀ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Equiv L M N) {n : ℕ}\\n  (f : FirstOrder.Language.Functions L n) (x : Fin n → M),\\n  Equiv.toFun self.toEquiv (FirstOrder.Language.Structure.funMap f x) =\\n    FirstOrder.Language.Structure.funMap f (self.toFun ∘ x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The homomorphism commutes with the interpretations of the function symbols \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map one to one. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {G : Type u_4} {V : Type u_2} {W : Type u_3} [inst : CommSemiring k] [inst_1 : Group G]\\n  [inst_2 : AddCommMonoid V] [inst_3 : Module k V] [inst_4 : AddCommMonoid W] [inst_5 : Module k W]\\n  (ρV : Representation k G V) (ρW : Representation k G W) (g : G),\\n  LinearMap.comp (dualTensorHom k V W) (TensorProduct.map (↑(Representation.dual ρV) g) (↑ρW g)) =\\n    LinearMap.comp (↑(Representation.linHom ρV ρW) g) (dualTensorHom k V W)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given $k$-modules $V, W$, there is a homomorphism $φ : V^* ⊗ W → Hom_k(V, W)$\\n(implemented by `LinearAlgebra.Contraction.dualTensorHom`).\\nGiven representations of $G$ on $V$ and $W$,there are representations of $G$ on $V^* ⊗ W$ and on\\n$Hom_k(V, W)$.\\nThis lemma says that $φ$ is $G$-linear.\\n\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f g : Con.Quotient c →* P),\\n  (∀ (a : M), ↑f ↑a = ↑g ↑a) → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\\nare equal on elements that are coercions from the monoid. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x y : α),\\n  ↑f (x - y) = ↑f x - ↑f y\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve subtraction. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : α → β},\\n  IsGroupHom f → IsGroupHom fun a => (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\\n  IsMonoidHom f → ∀ (x y : α), f (x * y) = f x * f y\",\n  \"isProp\": true,\n  \"docString\": \"A monoid homomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : HeytingAlgebra α]\\n  [inst_1 : HeytingAlgebra β] [self : HeytingHomClass F α β] (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proposition that a Heyting homomorphism preserves the Heyting implication.\"}]\n",
    "prompt_cons": "/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem ∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c) :=\n\n/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem ∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F) :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖ :=\n\n/-- The homomorphism commutes with the interpretations of the function symbols -/\ntheorem ∀ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : FirstOrder.Language.Structure L M]\n  [inst_1 : FirstOrder.Language.Structure L N] (self : FirstOrder.Language.Equiv L M N) {n : ℕ}\n  (f : FirstOrder.Language.Functions L n) (x : Fin n → M),\n  Equiv.toFun self.toEquiv (FirstOrder.Language.Structure.funMap f x) =\n    FirstOrder.Language.Structure.funMap f (self.toFun ∘ x) :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- Ring homomorphisms map one to one. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1 :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹ :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1 :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s) :=\n\n/-- Given $k$-modules $V, W$, there is a homomorphism $φ : V^* ⊗ W → Hom_k(V, W)$\n(implemented by `LinearAlgebra.Contraction.dualTensorHom`).\nGiven representations of $G$ on $V$ and $W$,there are representations of $G$ on $V^* ⊗ W$ and on\n$Hom_k(V, W)$.\nThis lemma says that $φ$ is $G$-linear. -/\ntheorem ∀ {k : Type u_1} {G : Type u_4} {V : Type u_2} {W : Type u_3} [inst : CommSemiring k] [inst_1 : Group G]\n  [inst_2 : AddCommMonoid V] [inst_3 : Module k V] [inst_4 : AddCommMonoid W] [inst_5 : Module k W]\n  (ρV : Representation k G V) (ρW : Representation k G W) (g : G),\n  LinearMap.comp (dualTensorHom k V W) (TensorProduct.map (↑(Representation.dual ρV) g) (↑ρW g)) =\n    LinearMap.comp (↑(Representation.linHom ρV ρW) g) (dualTensorHom k V W) :=\n\n/-- Homomorphisms on the quotient of a monoid by a congruence relation are equal if they\nare equal on elements that are coercions from the monoid. -/\ntheorem ∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] {c : Con M} (f g : Con.Quotient c →* P),\n  (∀ (a : M), ↑f ↑a = ↑g ↑a) → f = g :=\n\n/-- Ring homomorphisms preserve subtraction. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x y : α),\n  ↑f (x - y) = ↑f x - ↑f y :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : α → β},\n  IsGroupHom f → IsGroupHom fun a => (f a)⁻¹ :=\n\n/-- A monoid homomorphism preserves multiplication. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\n  IsMonoidHom f → ∀ (x y : α), f (x * y) = f x * f y :=\n\n/-- The proposition that a Heyting homomorphism preserves the Heyting implication. -/\ntheorem ∀ {F : Type u_1} {α : outParam (Type u_2)} {β : outParam (Type u_3)} [inst : HeytingAlgebra α]\n  [inst_1 : HeytingAlgebra β] [self : HeytingHomClass F α β] (f : F) (a b : α), ↑f (a ⇨ b) = ↑f a ⇨ ↑f b :=\n\n/-- If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {N : Subgroup G} (ϕ : G →* G') (hϕ : Function.Surjective ↑ϕ)\n  (hN : Subgroup.Normal N), Subgroup.Normal (Subgroup.map ϕ N) "
    ]
  },
  {
    "docString": "Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`- and `q`-primary components are disjoint for `p ≠ q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\\n  p + q ≠ 0 →\\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) ≤ Polynomial.rootMultiplicity a (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p + q` is at least the minimum of the multiplicities. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"}]\n",
    "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem ∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem ∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem ∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\n  p + q ≠ 0 →\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) ≤ Polynomial.rootMultiplicity a (p + q) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic. -/\ntheorem",
    "choices": [
      "∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p > q → q ∣ p - 1 →\n    ∀ (G : Type u_1) [inst_2 : Group G] [inst_3 : Fintype G] (H : Type u_2) [inst_4 : Group H] [inst_5 : Fintype H],\n      Fintype.card G = p * q → Nonabelian G →\n        Fintype.card H = p * q → Nonabelian H →\n          Nonempty (G ≃* H) "
    ]
  },
  {
    "docString": "Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"}]\n",
    "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t :=\n\n/-- Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {A : Subgroup G} [inst_1 : Subgroup.Normal A] {b : G} {p : ℕ} [hp : Fact (Nat.Prime p)],\n  orderOf b = p → b ∉ A → A ⊓ Subgroup.zpowers b = ⊥ "
    ]
  },
  {
    "docString": "If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) ⊔ N = G`. \"},\n {\"theorem\":\n  \"∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\\n  AlgebraicGeometry.PropertyIsLocalAtTarget P → CategoryTheory.MorphismProperty.RespectsIso P\",\n  \"isProp\": true,\n  \"docString\": \"`P` respects isomorphisms. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] {P : Submodule R M → Prop},\\n  (∀ (I : Submodule R M), (∀ (J : Submodule R M), J > I → P J) → P I) → ∀ (I : Submodule R M), P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤ :=\n\n/-- `P` respects isomorphisms. -/\ntheorem ∀ {P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme},\n  AlgebraicGeometry.PropertyIsLocalAtTarget P → CategoryTheory.MorphismProperty.RespectsIso P :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- A p-group is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `∀ I > J, P I` implies `P J`, then `P` holds for all submodules. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] {P : Submodule R M → Prop},\n  (∀ (I : Submodule R M), (∀ (J : Submodule R M), J > I → P J) → P I) → ∀ (I : Submodule R M), P I :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Sylow p G} [inst_1 : Subgroup.Normal (↑P)],\n  ∀ (ϕ : G ≃* G), Subgroup.map (MulEquiv.toMonoidHom ϕ) (↑P) = ↑P "
    ]
  },
  {
    "docString": "If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {f g : Equiv.Perm α} {x : α} [inst : DecidableEq α] [inst_1 : Fintype α],\\n  Equiv.Perm.IsCycle f →\\n    Equiv.Perm.IsCycle g →\\n      (∀ (x : α), x ∈ Equiv.Perm.support f ∩ Equiv.Perm.support g → ↑f x = ↑g x) →\\n        ↑f x = ↑g x → x ∈ Equiv.Perm.support f → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two cyclic permutations agree on all terms in their intersection,\\nand that intersection is not empty, then the two cyclic permutations must be equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},\\n  s =ᶠ[MeasureTheory.Measure.ae μ] t → ↑↑μ s = ↑↑μ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are equal modulo a set of measure zero, then `μ s = μ t`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : PartialOrder α] {f : Fin n → α} {σ τ : Equiv.Perm (Fin n)},\\n  Monotone (f ∘ ↑σ) → Monotone (f ∘ ↑τ) → f ∘ ↑σ = f ∘ ↑τ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two permutations of a tuple `f` are both monotone, then they are equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `σ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α], Function.Injective Equiv.Perm.cycleFactorsFinset\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two permutations `f g : perm α` have the same cycle factors iff they are the same. \"},\n {\"theorem\":\n  \"∀ {α : Type u} (e p : Equiv.Perm α), ↑(Equiv.permCongr e) p = e * p * e⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `e` is also a permutation, we can write `permCongr`\\ncompletely in terms of the group structure. \"},\n {\"theorem\":\n  \"∀ {α : Sort u_2} [inst : DecidableEq α] {β : Sort u_1} {v : α → β} {i j : α},\\n  v i = v j → ∀ (k : α), v (↑(Equiv.swap i j) k) = v k\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is invariant to a swap if it is equal at both elements \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : CommSemiring R] {M : Type v} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (g : M →ₗ[R] M)\\n  (f : (M →ₗ[R] M)ˣ), ↑(LinearMap.trace R M) (↑f * g * ↑f⁻¹) = ↑(LinearMap.trace R M) g\",\n  \"isProp\": true,\n  \"docString\": \"The trace of an endomorphism is invariant under conjugation \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {S T : NonUnitalSubsemiring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two non-unital subsemirings are equal if they have the same elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},\\n  s ≤ᶠ[MeasureTheory.Measure.ae μ] t → ↑↑μ s ≤ ↑↑μ t\",\n  \"isProp\": true,\n  \"docString\": \"If `s ⊆ t` modulo a set of measure `0`, then `μ s ≤ μ t`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T\",\n  \"isProp\": true,\n  \"docString\": \"Two subsemigroups are equal if they have the same elements. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : LinearOrder α] {f : Fin n → α} {σ : Equiv.Perm (Fin n)},\\n  f ∘ ↑σ ≠ f ∘ ↑(Tuple.sort f) → ∃ i j, i < j ∧ (f ∘ ↑σ) j < (f ∘ ↑σ) i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a permutation `f ∘ σ` of the tuple `f` is not the same as `f ∘ sort f`, then `f ∘ σ`\\nhas a pair of strictly decreasing entries. \"},\n {\"theorem\": \"∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a | b^e) = J(a | b)^e`. \"}]\n",
    "prompt_cons": "/-- If two cyclic permutations agree on all terms in their intersection,\nand that intersection is not empty, then the two cyclic permutations must be equal. -/\ntheorem ∀ {α : Type u_1} {f g : Equiv.Perm α} {x : α} [inst : DecidableEq α] [inst_1 : Fintype α],\n  Equiv.Perm.IsCycle f →\n    Equiv.Perm.IsCycle g →\n      (∀ (x : α), x ∈ Equiv.Perm.support f ∩ Equiv.Perm.support g → ↑f x = ↑g x) →\n        ↑f x = ↑g x → x ∈ Equiv.Perm.support f → f = g :=\n\n/-- If two sets are equal modulo a set of measure zero, then `μ s = μ t`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},\n  s =ᶠ[MeasureTheory.Measure.ae μ] t → ↑↑μ s = ↑↑μ t :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- If two permutations of a tuple `f` are both monotone, then they are equal. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : PartialOrder α] {f : Fin n → α} {σ τ : Equiv.Perm (Fin n)},\n  Monotone (f ∘ ↑σ) → Monotone (f ∘ ↑τ) → f ∘ ↑σ = f ∘ ↑τ :=\n\n/-- If two `σ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g :=\n\n/-- Two permutations `f g : perm α` have the same cycle factors iff they are the same. -/\ntheorem ∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α], Function.Injective Equiv.Perm.cycleFactorsFinset :=\n\n/-- If `e` is also a permutation, we can write `permCongr`\ncompletely in terms of the group structure. -/\ntheorem ∀ {α : Type u} (e p : Equiv.Perm α), ↑(Equiv.permCongr e) p = e * p * e⁻¹ :=\n\n/-- A function is invariant to a swap if it is equal at both elements -/\ntheorem ∀ {α : Sort u_2} [inst : DecidableEq α] {β : Sort u_1} {v : α → β} {i j : α},\n  v i = v j → ∀ (k : α), v (↑(Equiv.swap i j) k) = v k :=\n\n/-- The trace of an endomorphism is invariant under conjugation -/\ntheorem ∀ (R : Type u) [inst : CommSemiring R] {M : Type v} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (g : M →ₗ[R] M)\n  (f : (M →ₗ[R] M)ˣ), ↑(LinearMap.trace R M) (↑f * g * ↑f⁻¹) = ↑(LinearMap.trace R M) g :=\n\n/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulLeftInvariant μ :=\n\n/-- Two non-unital subsemirings are equal if they have the same elements. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocSemiring R] {S T : NonUnitalSubsemiring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T :=\n\n/-- If `s ⊆ t` modulo a set of measure `0`, then `μ s ≤ μ t`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},\n  s ≤ᶠ[MeasureTheory.Measure.ae μ] t → ↑↑μ s ≤ ↑↑μ t :=\n\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulRightInvariant μ :=\n\n/-- Two subsemigroups are equal if they have the same elements. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {S T : Subsemigroup M}, (∀ (x : M), x ∈ S ↔ x ∈ T) → S = T :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- If a permutation `f ∘ σ` of the tuple `f` is not the same as `f ∘ sort f`, then `f ∘ σ`\nhas a pair of strictly decreasing entries. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : LinearOrder α] {f : Fin n → α} {σ : Equiv.Perm (Fin n)},\n  f ∘ ↑σ ≠ f ∘ ↑(Tuple.sort f) → ∃ i j, i < j ∧ (f ∘ ↑σ) j < (f ∘ ↑σ) i :=\n\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e :=\n\n/-- If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Disjoint (Equiv.Perm.support σ) (Equiv.Perm.support τ) → σ * τ = Equiv.Perm.refl α → σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α "
    ]
  },
  {
    "docString": "Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3.",
    "prompts": "[{\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is T₃. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T ≤ S →\\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\\n      [inst_5 : Fintype (M ⧸ T)],\\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T5Space Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is T₅. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a surjective torsion group homomorphism is torsion. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C ℤ]\\n  {T₁ T₂ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂),\\n  CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor C 1).map self.hom₁) =\\n    CategoryTheory.CategoryStruct.comp self.hom₃ T₂.mor₃\",\n  \"isProp\": true,\n  \"docString\": \"the third commutative square of a triangle morphism \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 3) (Fin 3) R),\\n  Matrix.det A =\\n    A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 +\\n        A 0 2 * A 1 0 * A 2 1 -\\n      A 0 2 * A 1 1 * A 2 0\",\n  \"isProp\": true,\n  \"docString\": \"Determinant of 3x3 matrix \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α], NormalSpace α\",\n  \"isProp\": true,\n  \"docString\": \"A `T₅` space is a `T₄` space. \"},\n {\"theorem\":\n  \"∀ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 2) (Fin 2) R), Matrix.det A = A 0 0 * A 1 1 - A 0 1 * A 1 0\",\n  \"isProp\": true,\n  \"docString\": \"Determinant of 2x2 matrix \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\\n  [inst_2 : CategoryTheory.HasShift C ℤ] [inst_3 : CategoryTheory.Preadditive C]\\n  [self : CategoryTheory.Pretriangulated C] (T₁ : CategoryTheory.Pretriangulated.Triangle C),\\n  T₁ ∈ CategoryTheory.Pretriangulated.distinguishedTriangles →\\n    ∀ (T₂ : CategoryTheory.Pretriangulated.Triangle C),\\n      (T₂ ≅ T₁) → T₂ ∈ CategoryTheory.Pretriangulated.distinguishedTriangles\",\n  \"isProp\": true,\n  \"docString\":\n  \"a triangle that is isomorphic to a distinguished triangle is distinguished \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C ℤ]\\n  {T₁ T₂ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂),\\n  CategoryTheory.CategoryStruct.comp T₁.mor₂ self.hom₃ = CategoryTheory.CategoryStruct.comp self.hom₂ T₂.mor₂\",\n  \"isProp\": true,\n  \"docString\": \"the second commutative square of a triangle morphism \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\\n  [inst : T2Space α], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible T₂ space. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"}]\n",
    "prompt_cons": "/-- The topology on a linearly ordered group with zero element adjoined is T₃. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀ :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T ≤ S →\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\n      [inst_5 : Fintype (M ⧸ T)],\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T) :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is T₅. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T5Space Γ₀ :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- The image of a surjective torsion group homomorphism is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] {f : G →* H},\n  Function.Surjective ↑f → Monoid.IsTorsion G → Monoid.IsTorsion H :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- the third commutative square of a triangle morphism -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C ℤ]\n  {T₁ T₂ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂),\n  CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor C 1).map self.hom₁) =\n    CategoryTheory.CategoryStruct.comp self.hom₃ T₂.mor₃ :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Determinant of 3x3 matrix -/\ntheorem ∀ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 3) (Fin 3) R),\n  Matrix.det A =\n    A 0 0 * A 1 1 * A 2 2 - A 0 0 * A 1 2 * A 2 1 - A 0 1 * A 1 0 * A 2 2 + A 0 1 * A 1 2 * A 2 0 +\n        A 0 2 * A 1 0 * A 2 1 -\n      A 0 2 * A 1 1 * A 2 0 :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- A `T₅` space is a `T₄` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α], NormalSpace α :=\n\n/-- Determinant of 2x2 matrix -/\ntheorem ∀ {R : Type v} [inst : CommRing R] (A : Matrix (Fin 2) (Fin 2) R), Matrix.det A = A 0 0 * A 1 1 - A 0 1 * A 1 0 :=\n\n/-- a triangle that is isomorphic to a distinguished triangle is distinguished -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroObject C]\n  [inst_2 : CategoryTheory.HasShift C ℤ] [inst_3 : CategoryTheory.Preadditive C]\n  [self : CategoryTheory.Pretriangulated C] (T₁ : CategoryTheory.Pretriangulated.Triangle C),\n  T₁ ∈ CategoryTheory.Pretriangulated.distinguishedTriangles →\n    ∀ (T₂ : CategoryTheory.Pretriangulated.Triangle C),\n      (T₂ ≅ T₁) → T₂ ∈ CategoryTheory.Pretriangulated.distinguishedTriangles :=\n\n/-- the second commutative square of a triangle morphism -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.HasShift C ℤ]\n  {T₁ T₂ : CategoryTheory.Pretriangulated.Triangle C} (self : CategoryTheory.Pretriangulated.TriangleMorphism T₁ T₂),\n  CategoryTheory.CategoryStruct.comp T₁.mor₂ self.hom₃ = CategoryTheory.CategoryStruct.comp self.hom₂ T₂.mor₂ :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\n  [inst : T2Space α], False :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥ :=\n\n/-- Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α] [inst_2 : Field α] (h : Fintype.card α = 2),\n  Matrix.SpecialLinearGroup (Fin 2) α ≃* SymmetricGroup (Fin 3) "
    ]
  },
  {
    "docString": "If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$.",
    "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\": \"∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  ↑(quadraticChar F) a = 0 ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The value of the quadratic character on `a` is zero iff `a = 0`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\\n  Function.Injective ↑(algebraMap R A) → ∀ [inst : CharZero R], CharZero A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (r : R) (a : A), ↑f (r • a) = r • ↑f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ⋆-algebra equivalence commutes with the action of scalars. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b)\",\n  \"isProp\": true,\n  \"docString\": \"$a^{-1}ba$ is a vector. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {X : Type u_2} [inst : CommSemiring R] [inst_1 : CharZero R], CharZero (FreeAlgebra R X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` has characteristic `0`, then so does `FreeAlgebra R X`. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (x : M), SemiconjBy (↑u) x (↑u * x * ↑u⁻¹)\",\n  \"isProp\": true,\n  \"docString\": \"`a` semiconjugates `x` to `a * x * a⁻¹`. \"}]\n",
    "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- `a ^ 0 = 1` -/\ntheorem ∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem ∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0 :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c) :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem ∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  ↑(quadraticChar F) a = 0 ↔ a = 0 :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- If the algebra map `R →+* A` is injective and `R` has characteristic zero then so does `A`. -/\ntheorem ∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  Function.Injective ↑(algebraMap R A) → ∀ [inst : CharZero R], CharZero A :=\n\n/-- A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. -/\ntheorem ∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- By definition, a ⋆-algebra equivalence commutes with the action of scalars. -/\ntheorem ∀ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (r : R) (a : A), ↑f (r • a) = r • ↑f a :=\n\n/-- $a^{-1}ba$ is a vector. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b) :=\n\n/-- If `R` has characteristic `0`, then so does `FreeAlgebra R X`. -/\ntheorem ∀ {R : Type u_1} {X : Type u_2} [inst : CommSemiring R] [inst_1 : CharZero R], CharZero (FreeAlgebra R X) :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- `a` semiconjugates `x` to `a * x * a⁻¹`. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (x : M), SemiconjBy (↑u) x (↑u * x * ↑u⁻¹) :=\n\n/-- If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 → Commute (a * x + x * a) a "
    ]
  },
  {
    "docString": "If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` has characteristic `0`, then so does `FractionRing R`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  ↑Polynomial.C x ∈\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {X : Type u_2} [inst : CommSemiring R] [inst_1 : CharZero R], CharZero (FreeAlgebra R X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` has characteristic `0`, then so does `FreeAlgebra R X`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), |a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For an element `a` of a linear ordered ring, either `abs a = a` and `0 ≤ a`,\\nor `abs a = -a` and `a < 0`.\\nUse cases on this lemma to automate linarith in inequalities \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ≃+* S), ↑f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (p : ℕ) [inst_1 : CharP R p] (I : Ideal R),\\n  (∀ (x : ℕ), ↑x ∈ I → ↑x = 0) → CharP (R ⧸ I) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\\ninherits the characteristic of the underlying ring. \"}]\n",
    "prompt_cons": "/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem ∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0 :=\n\n/-- A ring is a `ℚ`-algebra iff it has equal characteristic zero. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I) :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem ∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- If `R` has characteristic `0`, then so does `FractionRing R`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R) :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P) :=\n\n/-- A non-unital subring contains the ring's 0. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R), 0 ∈ s :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  ↑Polynomial.C x ∈\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\n    x = 0 :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥ :=\n\n/-- If `R` has characteristic `0`, then so does `FreeAlgebra R X`. -/\ntheorem ∀ {R : Type u_1} {X : Type u_2} [inst : CommSemiring R] [inst_1 : CharZero R], CharZero (FreeAlgebra R X) :=\n\n/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b :=\n\n/-- For an element `a` of a linear ordered ring, either `abs a = a` and `0 ≤ a`,\nor `abs a = -a` and `a < 0`.\nUse cases on this lemma to automate linarith in inequalities -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), |a| = a ∧ 0 ≤ a ∨ |a| = -a ∧ a < 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ≃+* S), ↑f 0 = 0 :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥ :=\n\n/-- A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. -/\ntheorem ∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (p : ℕ) [inst_1 : CharP R p] (I : Ideal R),\n  (∀ (x : ℕ), ↑x ∈ I → ↑x = 0) → CharP (R ⧸ I) p :=\n\n/-- If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal (SetOf (λ x, x * a = 0)) "
    ]
  },
  {
    "docString": "Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : ℤ), ↑(legendreSym p a) = ↑a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a ≡ a ^ (p / 2) mod p`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\\n  p ≠ 2 →\\n    ↑a ≠ 0 →\\n      legendreSym p a =\\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (↑a * ↑x)) (Finset.Ico 1 (Nat.succ (p / 2))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\\nthan `p/2` such that `(a * x) % p > p / 2`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (a : ZMod p),\\n  a ≠ 0 →\\n    Multiset.map (fun x => Int.natAbs (ZMod.valMinAbs (a * ↑x))) (Finset.Ico 1 (Nat.succ (p / 2))).val =\\n      Multiset.map (fun a => a) (Finset.Ico 1 (Nat.succ (p / 2))).val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of the map sending a nonzero natural number `x ≤ p / 2` to the absolute value\\nof the integer in `(-p/2, p/2]` that is congruent to `a * x mod p` is the set\\nof nonzero natural numbers `x` such that `x ≤ p / 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"}]\n",
    "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- We have the congruence `legendreSym p a ≡ a ^ (p / 2) mod p`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : ℤ), ↑(legendreSym p a) = ↑a ^ (p / 2) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1) :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\nthan `p/2` such that `(a * x) % p > p / 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\n  p ≠ 2 →\n    ↑a ≠ 0 →\n      legendreSym p a =\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (↑a * ↑x)) (Finset.Ico 1 (Nat.succ (p / 2)))) :=\n\n/-- The image of the map sending a nonzero natural number `x ≤ p / 2` to the absolute value\nof the integer in `(-p/2, p/2]` that is congruent to `a * x mod p` is the set\nof nonzero natural numbers `x` such that `x ≤ p / 2`. -/\ntheorem ∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (a : ZMod p),\n  a ≠ 0 →\n    Multiset.map (fun x => Int.natAbs (ZMod.valMinAbs (a * ↑x))) (Finset.Ico 1 (Nat.succ (p / 2))).val =\n      Multiset.map (fun a => a) (Finset.Ico 1 (Nat.succ (p / 2))).val :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 →\n  (Finset.card (Finset.filter (fun x => IsSquare (↑x : ZMod p)) (Finset.Ico 1 p)) = (p - 1) / 2) ∧\n  (Finset.card (Finset.filter (fun x => ¬IsSquare (↑x : ZMod p)) (Finset.Ico 1 p)) = (p - 1) / 2) "
    ]
  },
  {
    "docString": "Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\\n  Polynomial.Monic g₁ →\\n    Polynomial.Monic g₂ →\\n      IsCoprime g₁ g₂ →\\n        ∃ q r₁ r₂,\\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\\ndeg(r₂) < deg(g₂).\\n\"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\\n      n ≠ 0 → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic p R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {f : Polynomial ℚ} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of `ℚ[X]` by the ideal generated by an irreducible polynomial of `ℚ[X]`\\nis a number field. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\\n  Ideal.IsPrime P →\\n    ¬Polynomial.leadingCoeff f ∈ P →\\n      (∀ (n : ℕ), ↑n < Polynomial.degree f → Polynomial.coeff f n ∈ P) →\\n        0 < Polynomial.degree f → ¬Polynomial.coeff f 0 ∈ P ^ 2 → Polynomial.IsPrimitive f → Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\\nirreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\ndeg(r₂) < deg(g₂). -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\n  Polynomial.Monic g₁ →\n    Polynomial.Monic g₂ →\n      IsCoprime g₁ g₂ →\n        ∃ q r₁ r₂,\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂ :=\n\n/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\n      n ≠ 0 → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic p R) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- The quotient of `ℚ[X]` by the ideal generated by an irreducible polynomial of `ℚ[X]`\nis a number field. -/\ntheorem ∀ {f : Polynomial ℚ} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\n  Ideal.IsPrime P →\n    ¬Polynomial.leadingCoeff f ∈ P →\n      (∀ (n : ℕ), ↑n < Polynomial.degree f → Polynomial.coeff f n ∈ P) →\n        0 < Polynomial.degree f → ¬Polynomial.coeff f 0 ∈ P ^ 2 → Polynomial.IsPrimitive f → Irreducible f :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F 7],\n  let p "
    ]
  },
  {
    "docString": "Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\\n  Ideal.IsPrime P →\\n    ¬Polynomial.leadingCoeff f ∈ P →\\n      (∀ (n : ℕ), ↑n < Polynomial.degree f → Polynomial.coeff f n ∈ P) →\\n        0 < Polynomial.degree f → ¬Polynomial.coeff f 0 ∈ P ^ 2 → Polynomial.IsPrimitive f → Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\\nirreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] (f : LaurentPolynomial R) {Q : LaurentPolynomial R → Prop},\\n  (∀ (f : Polynomial R), Q (↑Polynomial.toLaurent f)) →\\n    (∀ (f : LaurentPolynomial R), Q (f * LaurentPolynomial.T 1) → Q f) → Q f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that `Q` is a statement about Laurent polynomials such that\\n* `Q` is true on *ordinary* polynomials;\\n* `Q (f * T)` implies `Q f`;\\nit follow that `Q` is true on all Laurent polynomials. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\\n  Polynomial.Monic g₁ →\\n    Polynomial.Monic g₂ →\\n      IsCoprime g₁ g₂ →\\n        ∃ q r₁ r₂,\\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\\ndeg(r₂) < deg(g₂).\\n\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\n  Ideal.IsPrime P →\n    ¬Polynomial.leadingCoeff f ∈ P →\n      (∀ (n : ℕ), ↑n < Polynomial.degree f → Polynomial.coeff f n ∈ P) →\n        0 < Polynomial.degree f → ¬Polynomial.coeff f 0 ∈ P ^ 2 → Polynomial.IsPrimitive f → Irreducible f :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Suppose that `Q` is a statement about Laurent polynomials such that\n* `Q` is true on *ordinary* polynomials;\n* `Q (f * T)` implies `Q f`;\nit follow that `Q` is true on all Laurent polynomials. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] (f : LaurentPolynomial R) {Q : LaurentPolynomial R → Prop},\n  (∀ (f : Polynomial R), Q (↑Polynomial.toLaurent f)) →\n    (∀ (f : LaurentPolynomial R), Q (f * LaurentPolynomial.T 1) → Q f) → Q f :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\ndeg(r₂) < deg(g₂). -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\n  Polynomial.Monic g₁ →\n    Polynomial.Monic g₂ →\n      IsCoprime g₁ g₂ →\n        ∃ q r₁ r₂,\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂ :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem ∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C :=\n\n/-- Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$. -/\ntheorem",
    "choices": [
      "irreducible_fx : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) "
    ]
  },
  {
    "docString": "If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → a ^ (Fintype.card F / 2) = 1 ∨ a ^ (Fintype.card F / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ {R' : Type v} [inst : CommRing R'] {F : Type u} [inst_1 : Field F] {ψ : AddChar F R'},\\n  AddChar.IsNontrivial ψ → AddChar.IsPrimitive ψ\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `R` is a field `F`, then a nontrivial additive character is primitive \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K]\\n  [inst_3 : FiniteDimensional F K] [inst_4 : CharZero F], IsSeparable F K\",\n  \"isProp\": true,\n  \"docString\": \"A finite field extension in characteristic 0 is separable. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) {p m : ℕ} [inst : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\\n  ¬p ∣ m → ∀ {k : ℕ}, 0 < k → Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is of characteristic `p` and `¬p ∣ m`, then\\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {a b : ℕ}, a ≠ 0 → b ≠ 0 → Nat.factorization (a * b) = Nat.factorization a + Nat.factorization b\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) {p n : ℕ} [hp : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\\n  p ∣ n → Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is of characteristic `p` and `p ∣ n`, then\\n`cyclotomic (n * p) R = (cyclotomic n R) ^ p`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Fintype F] [inst_1 : Field F],\\n  ringChar F ≠ 2 → 2 ^ (Fintype.card F / 2) = ↑(↑ZMod.χ₈ ↑(Fintype.card F))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite field `F` of odd characteristic, we have `2^(#F/2) = χ₈#F` in `F`. \"},\n {\"theorem\":\n  \"∀ {F : Type u} [inst : Field F] {n : ℕ} (a : F),\\n  ↑n ≠ 0 → a ≠ 0 → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ 0` in `F`, then ` X ^ n - a` is separable for any `a ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N) (a b : M),\\n  ↑f (a + b) = ↑f a + ↑f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an additive monoid homomorphism then `f (a + b) = f a + f b`. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : IsDomain R']\\n  {χ : MulChar R R'}, MulChar.IsNontrivial χ → (Finset.sum Finset.univ fun a => ↑χ a) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum over all values of a nontrivial multiplicative character on a finite ring is zero\\n(when the target is a domain). \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M : Submodule R A)\\n  {C : A → Prop},\\n  (∀ (r : R), C (↑(algebraMap R A) r)) →\\n    (∀ (x y : A), C x → C y → C (x + y)) →\\n      (∀ (x : A), C x → ∀ (m : A), m ∈ M → C (x * m)) → ∀ {x : A} {n : ℕ}, x ∈ M ^ n → C x\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\\nis closed under addition, and holds for `x * m` where `m ∈ M` and it holds for `x` \"}]\n",
    "prompt_cons": "/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → a ^ (Fintype.card F / 2) = 1 ∨ a ^ (Fintype.card F / 2) = -1 :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- When `R` is a field `F`, then a nontrivial additive character is primitive -/\ntheorem ∀ {R' : Type v} [inst : CommRing R'] {F : Type u} [inst_1 : Field F] {ψ : AddChar F R'},\n  AddChar.IsNontrivial ψ → AddChar.IsPrimitive ψ :=\n\n/-- A finite field extension in characteristic 0 is separable. -/\ntheorem ∀ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K]\n  [inst_3 : FiniteDimensional F K] [inst_4 : CharZero F], IsSeparable F K :=\n\n/-- If `R` is of characteristic `p` and `¬p ∣ m`, then\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. -/\ntheorem ∀ (R : Type u_1) {p m : ℕ} [inst : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\n  ¬p ∣ m → ∀ {k : ℕ}, 0 < k → Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1)) :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- For nonzero `a` and `b`, the power of `p` in `a * b` is the sum of the powers in `a` and `b` -/\ntheorem ∀ {a b : ℕ}, a ≠ 0 → b ≠ 0 → Nat.factorization (a * b) = Nat.factorization a + Nat.factorization b :=\n\n/-- If `R` is of characteristic `p` and `p ∣ n`, then\n`cyclotomic (n * p) R = (cyclotomic n R) ^ p`. -/\ntheorem ∀ (R : Type u_1) {p n : ℕ} [hp : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\n  p ∣ n → Polynomial.cyclotomic (n * p) R = Polynomial.cyclotomic n R ^ p :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- For every finite field `F` of odd characteristic, we have `2^(#F/2) = χ₈#F` in `F`. -/\ntheorem ∀ {F : Type u_1} [inst : Fintype F] [inst_1 : Field F],\n  ringChar F ≠ 2 → 2 ^ (Fintype.card F / 2) = ↑(↑ZMod.χ₈ ↑(Fintype.card F)) :=\n\n/-- If `n ≠ 0` in `F`, then ` X ^ n - a` is separable for any `a ≠ 0`. -/\ntheorem ∀ {F : Type u} [inst : Field F] {n : ℕ} (a : F),\n  ↑n ≠ 0 → a ≠ 0 → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C a) :=\n\n/-- If `f` is an additive monoid homomorphism then `f (a + b) = f a + f b`. -/\ntheorem ∀ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] (f : M →+ N) (a b : M),\n  ↑f (a + b) = ↑f a + ↑f b :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem ∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R) :=\n\n/-- The sum over all values of a nontrivial multiplicative character on a finite ring is zero\n(when the target is a domain). -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : IsDomain R']\n  {χ : MulChar R R'}, MulChar.IsNontrivial χ → (Finset.sum Finset.univ fun a => ↑χ a) = 0 :=\n\n/-- To show a property on elements of `M ^ n` holds, it suffices to show that it holds for scalars,\nis closed under addition, and holds for `x * m` where `m ∈ M` and it holds for `x` -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {A : Type v} [inst_1 : Semiring A] [inst_2 : Algebra R A] (M : Submodule R A)\n  {C : A → Prop},\n  (∀ (r : R), C (↑(algebraMap R A) r)) →\n    (∀ (x y : A), C x → C y → C (x + y)) →\n      (∀ (x : A), C x → ∀ (m : A), m ∈ M → C (x * m)) → ∀ {x : A} {n : ℕ}, x ∈ M ^ n → C x :=\n\n/-- If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] (p : ℕ) [inst_2 : Fact (Nat.Prime p)] {a b : F} {n : ℕ},\n  0 < n → (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) "
    ]
  },
  {
    "docString": "If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} {L : Type u_2} {A : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\\n  Algebra.IsAlgebraic K L → Algebra.IsAlgebraic L A → Algebra.IsAlgebraic K A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If L is an algebraic field extension of K and A is an algebraic algebra over L,\\nthen A is algebraic over K. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\\n  Algebra.IsAlgebraic K A → Algebra.IsAlgebraic L A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A] {x : A},\\n  IsAlgebraic K x → IsAlgebraic L x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x is algebraic over K, then x is algebraic over L when L is an extension of K \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (A : Subalgebra K L),\\n  Algebra.IsAlgebraic K L → IsField { x // x ∈ A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an algebraic extension L/K, an intermediate subalgebra is a field. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A],\\n  Algebra.IsAlgebraic R A ↔ Subalgebra.IsAlgebraic ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebra is algebraic if and only if it is algebraic as a subalgebra. \"},\n {\"theorem\":\n  \"∀ (R : Type u_2) [inst : CommRing R] (S : Type u_3) [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_1)\\n  [inst_3 : Field K] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : Algebra R K] [inst_7 : Algebra S K]\\n  [inst_8 : NoZeroSMulDivisors R K] [inst_9 : IsFractionRing S K] [inst_10 : IsScalarTower R S K],\\n  Algebra.IsAlgebraic R S ↔ Algebra.IsAlgebraic R K\",\n  \"isProp\": true,\n  \"docString\":\n  \"`S` is algebraic over `R` iff a fraction ring of `S` is algebraic over `R` \"},\n {\"theorem\":\n  \"∀ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] (S : Subalgebra R A),\\n  Subalgebra.IsAlgebraic S ↔ Algebra.IsAlgebraic R { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subalgebra is algebraic if and only if it is algebraic as an algebra. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_4} {R : Type u_2} {A : Type u_3} {x : ι → A} [inst : CommRing R] [inst_1 : CommRing A]\\n  [inst_2 : Algebra R A] {K : Type u_1} [inst_3 : CommRing K] [inst_4 : Algebra R K] [inst_5 : Algebra K A]\\n  [inst_6 : IsScalarTower R K A],\\n  Function.Injective ↑(algebraMap R K) → AlgebraicIndependent K x → AlgebraicIndependent R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set of algebraically independent elements in an algebra `A` over a ring `K` is also\\nalgebraically independent over a subring `R` of `K`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {K : Type u_2} (A : Type u_3) [inst : Field F] [inst_1 : Field K] [inst_2 : Field A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : Algebra F K],\\n  Algebra.IsAlgebraic F K →\\n    ∀ [inst_5 : Algebra F A] (x : K), (Set.range fun ψ => ↑ψ x) = Polynomial.rootSet (minpoly F x) A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `A` be an algebraically closed field and let `x ∈ K`, with `K/F` an algebraic extension\\nof fields. Then the images of `x` by the `F`-algebra morphisms from `K` to `A` are exactly\\nthe roots in `A` of the minimal polynomial of `x` over `F`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → (IsSquare a ↔ a ^ (Fintype.card F / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R →\\n    ∀ (ps : ι → MvPolynomial ι R),\\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (J : Type u_2) (L : Type v) [inst : Field K] [inst_1 : Field J] [inst_2 : Field L]\\n  [inst_3 : Algebra K J] [inst_4 : Algebra J L] [inst_5 : IsAlgClosure J L] [inst_6 : Algebra K L]\\n  [inst_7 : IsScalarTower K J L], Algebra.IsAlgebraic K J → IsAlgClosure K L\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J` is an algebraic extension of `K` and `L` is an algebraic closure of `J`, then it is\\nalso an algebraic closure of `K`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing A]\\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A],\\n  Function.Injective ↑(algebraMap R S) → Algebra.IsAlgebraic R A → Algebra.IsAlgebraic S A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an algebraic algebra over R, then A is algebraic over S when S is an extension of R,\\nand the map from `R` to `S` is injective. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {A : Type v} [inst : Field K] [inst_1 : Ring A] [inst_2 : Algebra K A] {x : A},\\n  IsAlgebraic K x ↔ IsIntegral K x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of an algebra over a field is algebraic if and only if it is integral.\"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\\n  Algebra.discr K ↑b ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} {R : Type u_2} [inst : CommSemiring S] [inst_1 : Semiring R] [inst_2 : Algebra S R]\\n  (p : Submodule S R), SetLike.GradedMonoid fun i => p ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A direct sum of powers of a submodule of an algebra has a multiplicative structure. \"}]\n",
    "prompt_cons": "/-- If L is an algebraic field extension of K and A is an algebraic algebra over L,\nthen A is algebraic over K. -/\ntheorem ∀ {K : Type u_1} {L : Type u_2} {A : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\n  Algebra.IsAlgebraic K L → Algebra.IsAlgebraic L A → Algebra.IsAlgebraic K A :=\n\n/-- If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K -/\ntheorem ∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\n  Algebra.IsAlgebraic K A → Algebra.IsAlgebraic L A :=\n\n/-- If x is algebraic over K, then x is algebraic over L when L is an extension of K -/\ntheorem ∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A] {x : A},\n  IsAlgebraic K x → IsAlgebraic L x :=\n\n/-- In an algebraic extension L/K, an intermediate subalgebra is a field. -/\ntheorem ∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (A : Subalgebra K L),\n  Algebra.IsAlgebraic K L → IsField { x // x ∈ A } :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- An algebra is algebraic if and only if it is algebraic as a subalgebra. -/\ntheorem ∀ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A],\n  Algebra.IsAlgebraic R A ↔ Subalgebra.IsAlgebraic ⊤ :=\n\n/-- `S` is algebraic over `R` iff a fraction ring of `S` is algebraic over `R` -/\ntheorem ∀ (R : Type u_2) [inst : CommRing R] (S : Type u_3) [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_1)\n  [inst_3 : Field K] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : Algebra R K] [inst_7 : Algebra S K]\n  [inst_8 : NoZeroSMulDivisors R K] [inst_9 : IsFractionRing S K] [inst_10 : IsScalarTower R S K],\n  Algebra.IsAlgebraic R S ↔ Algebra.IsAlgebraic R K :=\n\n/-- A subalgebra is algebraic if and only if it is algebraic as an algebra. -/\ntheorem ∀ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] (S : Subalgebra R A),\n  Subalgebra.IsAlgebraic S ↔ Algebra.IsAlgebraic R { x // x ∈ S } :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 :=\n\n/-- A set of algebraically independent elements in an algebra `A` over a ring `K` is also\nalgebraically independent over a subring `R` of `K`. -/\ntheorem ∀ {ι : Type u_4} {R : Type u_2} {A : Type u_3} {x : ι → A} [inst : CommRing R] [inst_1 : CommRing A]\n  [inst_2 : Algebra R A] {K : Type u_1} [inst_3 : CommRing K] [inst_4 : Algebra R K] [inst_5 : Algebra K A]\n  [inst_6 : IsScalarTower R K A],\n  Function.Injective ↑(algebraMap R K) → AlgebraicIndependent K x → AlgebraicIndependent R x :=\n\n/-- Let `A` be an algebraically closed field and let `x ∈ K`, with `K/F` an algebraic extension\nof fields. Then the images of `x` by the `F`-algebra morphisms from `K` to `A` are exactly\nthe roots in `A` of the minimal polynomial of `x` over `F`. -/\ntheorem ∀ {F : Type u_1} {K : Type u_2} (A : Type u_3) [inst : Field F] [inst_1 : Field K] [inst_2 : Field A]\n  [inst_3 : IsAlgClosed A] [inst_4 : Algebra F K],\n  Algebra.IsAlgebraic F K →\n    ∀ [inst_5 : Algebra F A] (x : K), (Set.range fun ψ => ↑ψ x) = Polynomial.rootSet (minpoly F x) A :=\n\n/-- A non-zero `a : F` is a square if and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → (IsSquare a ↔ a ^ (Fintype.card F / 2) = 1) :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R →\n    ∀ (ps : ι → MvPolynomial ι R),\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i) :=\n\n/-- If `J` is an algebraic extension of `K` and `L` is an algebraic closure of `J`, then it is\nalso an algebraic closure of `K`. -/\ntheorem ∀ (K : Type u_1) (J : Type u_2) (L : Type v) [inst : Field K] [inst_1 : Field J] [inst_2 : Field L]\n  [inst_3 : Algebra K J] [inst_4 : Algebra J L] [inst_5 : IsAlgClosure J L] [inst_6 : Algebra K L]\n  [inst_7 : IsScalarTower K J L], Algebra.IsAlgebraic K J → IsAlgClosure K L :=\n\n/-- If A is an algebraic algebra over R, then A is algebraic over S when S is an extension of R,\nand the map from `R` to `S` is injective. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A],\n  Function.Injective ↑(algebraMap R S) → Algebra.IsAlgebraic R A → Algebra.IsAlgebraic S A :=\n\n/-- An element of an algebra over a field is algebraic if and only if it is integral. -/\ntheorem ∀ {K : Type u} {A : Type v} [inst : Field K] [inst_1 : Ring A] [inst_2 : Algebra K A] {x : A},\n  IsAlgebraic K x ↔ IsIntegral K x :=\n\n/-- A subfield is closed under multiplication. -/\ntheorem ∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b ≠ 0`. -/\ntheorem ∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\n  Algebra.discr K ↑b ≠ 0 :=\n\n/-- A direct sum of powers of a submodule of an algebra has a multiplicative structure. -/\ntheorem ∀ {S : Type u_1} {R : Type u_2} [inst : CommSemiring S] [inst_1 : Semiring R] [inst_2 : Algebra S R]\n  (p : Submodule S R), SetLike.GradedMonoid fun i => p ^ i :=\n\n/-- If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) → IsAlgebraic F a "
    ]
  },
  {
    "docString": "If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)],\\n  p ≠ 2 → ∀ (a : ℤ), ↑(Finset.card (Set.toFinset {x | x ^ 2 = ↑a})) = legendreSym p a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of square roots of `a` modulo `p` is determined by the Legendre symbol. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p ∤ a`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\\n  ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p →\\n    ↑Polynomial.C (Polynomial.leadingCoeff p) *\\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - ↑Polynomial.C a) (Polynomial.roots p)) =\\n      p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial `p` that has as many roots as its degree\\ncan be written `p = p.leadingCoeff * ∏(X - a)`, for `a` in `p.roots`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ},\\n  0 < n →\\n    ∀ {p : ℕ} [hprime : Fact (Nat.Prime p)] {a : ℕ},\\n      Polynomial.IsRoot (Polynomial.cyclotomic n (ZMod p)) (↑(Nat.castRingHom (ZMod p)) a) → Nat.coprime a p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `(a : ℕ)` is a root of `cyclotomic n (ZMod p)`, where `p` is a prime, then `a` and `p` are\\ncoprime. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\\n  Polynomial.Monic p →\\n    ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p →\\n      Multiset.prod (Multiset.map (fun a => Polynomial.X - ↑Polynomial.C a) (Polynomial.roots p)) = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monic polynomial `p` that has as many roots as its degree\\ncan be written `p = ∏(X - a)`, for `a` in `p.roots`. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (p : Polynomial R),\\n  Multiset.prod (Multiset.map (fun a => Polynomial.X - ↑Polynomial.C a) (Polynomial.roots p)) ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `∏ (X - a)` for `a` inside the multiset `p.roots` divides `p`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  ↑(quadraticChar F) a = 0 ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The value of the quadratic character on `a` is zero iff `a = 0`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] {a : ℤ}, multiplicity.Finite (↑p) a ↔ a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"}]\n",
    "prompt_cons": "/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p :=\n\n/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)],\n  p ≠ 2 → ∀ (a : ℤ), ↑(Finset.card (Set.toFinset {x | x ^ 2 = ↑a})) = legendreSym p a + 1 :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p (a ^ 2) = 1 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1) :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1 :=\n\n/-- The square of the symbol is 1 if `p ∤ a`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- A polynomial `p` that has as many roots as its degree\ncan be written `p = p.leadingCoeff * ∏(X - a)`, for `a` in `p.roots`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p →\n    ↑Polynomial.C (Polynomial.leadingCoeff p) *\n        Multiset.prod (Multiset.map (fun a => Polynomial.X - ↑Polynomial.C a) (Polynomial.roots p)) =\n      p :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- If `(a : ℕ)` is a root of `cyclotomic n (ZMod p)`, where `p` is a prime, then `a` and `p` are\ncoprime. -/\ntheorem ∀ {n : ℕ},\n  0 < n →\n    ∀ {p : ℕ} [hprime : Fact (Nat.Prime p)] {a : ℕ},\n      Polynomial.IsRoot (Polynomial.cyclotomic n (ZMod p)) (↑(Nat.castRingHom (ZMod p)) a) → Nat.coprime a p :=\n\n/-- A monic polynomial `p` that has as many roots as its degree\ncan be written `p = ∏(X - a)`, for `a` in `p.roots`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.Monic p →\n    ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p →\n      Multiset.prod (Multiset.map (fun a => Polynomial.X - ↑Polynomial.C a) (Polynomial.roots p)) = p :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- The product `∏ (X - a)` for `a` inside the multiset `p.roots` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (p : Polynomial R),\n  Multiset.prod (Multiset.map (fun a => Polynomial.X - ↑Polynomial.C a) (Polynomial.roots p)) ∣ p :=\n\n/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  ↑(quadraticChar F) a = 0 ↔ a = 0 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`. -/\ntheorem ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] {a : ℤ}, multiplicity.Finite (↑p) a ↔ a ≠ 0 :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a :=\n\n/-- If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80. -/\ntheorem",
    "choices": [
      "∀ {C : Type u_1} [inst : Field C] {a : C},\n  a ^ 5 + (2 ^ (1 / 2)) * a ^ 3 + (5 ^ (1 / 2)) * a ^ 2 + (7 ^ (1 / 2)) * a + (11 ^ (1 / 2)) = 0 →\n    IsAlgebraic (Rational) a ∧ Polynomial.degree (minpoly (Rational) a) ≤ 80 "
    ]
  },
  {
    "docString": "If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℕ), padicNorm p ↑m = 1 ↔ ¬p ∣ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℤ), padicNorm p ↑m = 1 ↔ ¬↑p ∣ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\\nand of `μ ^ p` are the same. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\\n  p ≠ 0 → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\\n    Finset.card\\n        (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p)) \\\\ Multiset.toFinset (Polynomial.roots p)) +\\n      1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial `p` is at most the number of roots of its derivative\\nthat are not roots of `p` plus one. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\\n  IsUnit ↑p ↔ ¬p ∣ ringChar R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a finite commutative ring `R`\\niff it does not divide the characteristic. \"},\n {\"theorem\":\n  \"∀ {F : Type u} [inst : Field F] {n : ℕ} (a : F),\\n  ↑n ≠ 0 → a ≠ 0 → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ 0` in `F`, then ` X ^ n - a` is separable for any `a ≠ 0`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] [inst_1 : CharZero R], IsEmpty (Algebra ℚ R) ↔ ∃ p, p > 0 ∧ MixedCharZero R p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring of characteristic zero is not a `ℚ`-algebra iff it has mixed characteristic for some `p`.\\n\"},\n {\"theorem\":\n  \"∀ (R : Type u_1) {p m : ℕ} [inst : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\\n  ¬p ∣ m → ∀ {k : ℕ}, 0 < k → Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is of characteristic `p` and `¬p ∣ m`, then\\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {m k p : ℕ} {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [hp : Fact (Nat.Prime p)] [hchar : CharP R p]\\n  {μ : R} [inst_2 : NeZero ↑m], Polynomial.IsRoot (Polynomial.cyclotomic (p ^ k * m) R) μ ↔ IsPrimitiveRoot μ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is of characteristic `p` and `¬p ∣ m`, then `ζ` is a root of `cyclotomic (p ^ k * m) R`\\nif and only if it is a primitive `m`-th root of unity. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K]\\n  [inst_3 : FiniteDimensional F K] [inst_4 : CharZero F], IsSeparable F K\",\n  \"isProp\": true,\n  \"docString\": \"A finite field extension in characteristic 0 is separable. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"}]\n",
    "prompt_cons": "/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p :=\n\n/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℕ), padicNorm p ↑m = 1 ↔ ¬p ∣ m :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R) :=\n\n/-- The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. -/\ntheorem ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℤ), padicNorm p ↑m = 1 ↔ ¬↑p ∣ m :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ p` are the same. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\n  p ≠ 0 → Nat.Prime p :=\n\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0 :=\n\n/-- The number of roots of a real polynomial `p` is at most the number of roots of its derivative\nthat are not roots of `p` plus one. -/\ntheorem ∀ (p : Polynomial ℝ),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\n    Finset.card\n        (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p)) \\ Multiset.toFinset (Polynomial.roots p)) +\n      1 :=\n\n/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1 :=\n\n/-- A prime `p` is a unit in a finite commutative ring `R`\niff it does not divide the characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\n  IsUnit ↑p ↔ ¬p ∣ ringChar R :=\n\n/-- If `n ≠ 0` in `F`, then ` X ^ n - a` is separable for any `a ≠ 0`. -/\ntheorem ∀ {F : Type u} [inst : Field F] {n : ℕ} (a : F),\n  ↑n ≠ 0 → a ≠ 0 → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C a) :=\n\n/-- A ring of characteristic zero is not a `ℚ`-algebra iff it has mixed characteristic for some `p`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] [inst_1 : CharZero R], IsEmpty (Algebra ℚ R) ↔ ∃ p, p > 0 ∧ MixedCharZero R p :=\n\n/-- If `R` is of characteristic `p` and `¬p ∣ m`, then\n`cyclotomic (p ^ k * m) R = (cyclotomic m R) ^ (p ^ k - p ^ (k - 1))`. -/\ntheorem ∀ (R : Type u_1) {p m : ℕ} [inst : Fact (Nat.Prime p)] [inst : Ring R] [inst_1 : CharP R p],\n  ¬p ∣ m → ∀ {k : ℕ}, 0 < k → Polynomial.cyclotomic (p ^ k * m) R = Polynomial.cyclotomic m R ^ (p ^ k - p ^ (k - 1)) :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- If `R` is of characteristic `p` and `¬p ∣ m`, then `ζ` is a root of `cyclotomic (p ^ k * m) R`\nif and only if it is a primitive `m`-th root of unity. -/\ntheorem ∀ {m k p : ℕ} {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [hp : Fact (Nat.Prime p)] [hchar : CharP R p]\n  {μ : R} [inst_2 : NeZero ↑m], Polynomial.IsRoot (Polynomial.cyclotomic (p ^ k * m) R) μ ↔ IsPrimitiveRoot μ m :=\n\n/-- A finite field extension in characteristic 0 is separable. -/\ntheorem ∀ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K]\n  [inst_3 : FiniteDimensional F K] [inst_4 : CharZero F], IsSeparable F K :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : Field F] {p : ℕ} [hp : Fact (Nat.Prime p)] [hchar : CharP F p] {n : ℕ},\n  Polynomial.nodup_roots (Polynomial.map (algebraMap ℕ F) (Polynomial.x ^ (p ^ n) - Polynomial.x)) "
    ]
  },
  {
    "docString": "Prove that the products $a b$ and $b a$ are conjugate elements in a group.",
    "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ∃ c, SemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\\nis transitive. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\\nare regular. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S], Transitive fun a b => ∃ c, AddSemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation “there exists an element that semiconjugates `a` to `b`” on an additive\\nsemigroup is transitive.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z → SemiconjBy b x y → SemiconjBy (a * b) x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\\nsemiconjugates `x` to `z`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b)\",\n  \"isProp\": true,\n  \"docString\": \"$a^{-1}ba$ is a vector. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.continuants g n = ppred →\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.denominators g n = ppredB →\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M], Reflexive fun a b => ∃ c, SemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation “there exists an element that semiconjugates `a` to `b`” on a monoid (or, more\\ngenerally, on `MulOneClass` type) is reflexive. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.numerators g n = ppredA →\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. \"}]\n",
    "prompt_cons": "/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\nis transitive. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ∃ c, SemiconjBy c a b :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\ntheorem ∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b :=\n\n/-- The relation “there exists an element that semiconjugates `a` to `b`” on an additive\nsemigroup is transitive. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S], Transitive fun a b => ∃ c, AddSemiconjBy c a b :=\n\n/-- If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a * b`\nsemiconjugates `x` to `z`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b x y z : S}, SemiconjBy a y z → SemiconjBy b x y → SemiconjBy (a * b) x z :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K :=\n\n/-- $a^{-1}ba$ is a vector. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b) :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.continuants g n = ppred →\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.denominators g n = ppredB →\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- The relation “there exists an element that semiconjugates `a` to `b`” on a monoid (or, more\ngenerally, on `MulOneClass` type) is reflexive. -/\ntheorem ∀ {M : Type u_1} [inst : MulOneClass M], Reflexive fun a b => ∃ c, SemiconjBy c a b :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.numerators g n = ppredA →\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- Prove that the products $a b$ and $b a$ are conjugate elements in a group. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {a b : G}, ∃ c, SemiconjBy c (a * b) (b * a) "
    ]
  },
  {
    "docString": "Prove that the center of the product of two groups is the product of their centers.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalNonAssocSemiring α] (self : CentroidHom α) (a b : α),\\n  ZeroHom.toFun (↑self.toAddMonoidHom) (a * b) = ZeroHom.toFun (↑self.toAddMonoidHom) a * b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of centroid homomorphims with right multiplication. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {α : outParam (Type u_2)} [inst : NonUnitalNonAssocSemiring α] [self : CentroidHomClass F α] (f : F)\\n  (a b : α), ↑f (a * b) = a * ↑f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of centroid homomorphims with left multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R], SMulCommClass R { x // x ∈ Subring.center R } R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The center of a semiring acts commutatively on that semiring. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂)\",\n  \"isProp\": true,\n  \"docString\": \"Products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)] [inst_1 : Finite η]\\n  [inst_2 : ∀ (i : η), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"n-ary products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\\n  NonarchimedeanAddGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\\n  ↑h (x / y) = ↑h x / ↑h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] (a b : α),\\n  Associated (gcd a b * lcm a b) (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of two elements is `Associated` with the product of their GCD and LCM. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} [inst : Finite η] {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)]\\n  (H K : (i : η) → Subgroup (Gs i)),\\n  ⁅Subgroup.pi Set.univ H, Subgroup.pi Set.univ K⁆ = Subgroup.pi Set.univ fun i => ⁅H i, K i⁆\",\n  \"isProp\": true,\n  \"docString\":\n  \"The commutator of a finite direct product is contained in the direct product of the commutators.\\n\"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem ∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M :=\n\n/-- Commutativity of centroid homomorphims with right multiplication. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalNonAssocSemiring α] (self : CentroidHom α) (a b : α),\n  ZeroHom.toFun (↑self.toAddMonoidHom) (a * b) = ZeroHom.toFun (↑self.toAddMonoidHom) a * b :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- Commutativity of centroid homomorphims with left multiplication. -/\ntheorem ∀ {F : Type u_1} {α : outParam (Type u_2)} [inst : NonUnitalNonAssocSemiring α] [self : CentroidHomClass F α] (f : F)\n  (a b : α), ↑f (a * b) = a * ↑f b :=\n\n/-- The center of a semiring acts commutatively on that semiring. -/\ntheorem ∀ {R : Type u} [inst : Ring R], SMulCommClass R { x // x ∈ Subring.center R } R :=\n\n/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G) :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K) :=\n\n/-- Products of nilpotent groups are nilpotent -/\ntheorem ∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂) :=\n\n/-- n-ary products of nilpotent groups are nilpotent -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)] [inst_1 : Finite η]\n  [inst_2 : ∀ (i : η), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : η) → Gs i) :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f) :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G × K) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\n  ↑h (x / y) = ↑h x / ↑h y :=\n\n/-- The product of two elements is `Associated` with the product of their GCD and LCM. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] (a b : α),\n  Associated (gcd a b * lcm a b) (a * b) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- The commutator of a finite direct product is contained in the direct product of the commutators. -/\ntheorem ∀ {η : Type u_1} [inst : Finite η] {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)]\n  (H K : (i : η) → Subgroup (Gs i)),\n  ⁅Subgroup.pi Set.univ H, Subgroup.pi Set.univ K⁆ = Subgroup.pi Set.univ fun i => ⁅H i, K i⁆ :=\n\n/-- Prove that the center of the product of two groups is the product of their centers. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) "
    ]
  },
  {
    "docString": "Prove that every homomorphism of fields is injective.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R →\\n    ∀ (ps : ι → MvPolynomial ι R),\\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β},\\n  IsAddGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 0 → a = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_3} {M₂ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R₂]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\\n  {f : M →ₛₗ[τ₁₂] M₂},\\n  (∀ (u v : { x // x ∈ LinearMap.ker f } →ₗ[R] M), LinearMap.comp f u = LinearMap.comp f v → u = v) →\\n    LinearMap.ker f = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"A monomorphism is injective. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ↑f → Ideal.IsMaximal (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {χ : MulChar R R'},\\n  MulChar.IsNontrivial χ → ∀ {f : R' →+* R''}, Function.Injective ↑f → MulChar.IsNontrivial (MulChar.ringHomComp χ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition with an injective ring homomorphism preserves nontriviality. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\\n  [inst_4 : Algebra R S], Algebra.IsIntegral R S → Function.Injective ↑(algebraMap R S) → IsField S → IsField R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\\n  Function.Injective ↑(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Bijective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms map one to one. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_5} {M₂ : Type u_2} [inst_5 : AddCommMonoid M₂]\\n  [inst_6 : Module R M₂] (f : M₂ →ₗ[R] M),\\n  Function.Surjective ↑f → Function.Injective fun g => AlternatingMap.compLinearMap g f\",\n  \"isProp\": true,\n  \"docString\": \"Composing with a surjective linear map is injective. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S),\\n  Function.Injective ↑(RingHom.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The induced map from the quotient by the kernel is injective. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C} (f : X ⟶ Y),\\n  Function.Injective ↑f → CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In any concrete category, injective morphisms are monomorphisms. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"}]\n",
    "prompt_cons": "/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1) :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem ∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R →\n    ∀ (ps : ι → MvPolynomial ι R),\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i) :=\n\n/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f :=\n\n/-- The induced algebra morphism from the quotient by the kernel is injective. -/\ntheorem ∀ {R₁ : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ↑(Ideal.kerLiftAlg f) :=\n\n/-- An additive group homomorphism is injective if its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β},\n  IsAddGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 0 → a = 0) :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f :=\n\n/-- A monomorphism is injective. -/\ntheorem ∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_3} {M₂ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\n  {f : M →ₛₗ[τ₁₂] M₂},\n  (∀ (u v : { x // x ∈ LinearMap.ker f } →ₗ[R] M), LinearMap.comp f u = LinearMap.comp f v → u = v) →\n    LinearMap.ker f = ⊥ :=\n\n/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem ∀ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\n  Function.Surjective ↑f → Ideal.IsMaximal (RingHom.ker f) :=\n\n/-- Composition with an injective ring homomorphism preserves nontriviality. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {χ : MulChar R R'},\n  MulChar.IsNontrivial χ → ∀ {f : R' →+* R''}, Function.Injective ↑f → MulChar.IsNontrivial (MulChar.ringHomComp χ f) :=\n\n/-- If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\n  [inst_4 : Algebra R S], Algebra.IsIntegral R S → Function.Injective ↑(algebraMap R S) → IsField S → IsField R :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem ∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\n  Function.Injective ↑(Con.kerLift f) :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Any injective endomorphism of an Artinian module is bijective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Bijective ↑f :=\n\n/-- Ring homomorphisms map one to one. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β), ↑f 1 = 1 :=\n\n/-- Composing with a surjective linear map is injective. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {M : Type u_3} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_4}\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_5} {M₂ : Type u_2} [inst_5 : AddCommMonoid M₂]\n  [inst_6 : Module R M₂] (f : M₂ →ₗ[R] M),\n  Function.Surjective ↑f → Function.Injective fun g => AlternatingMap.compLinearMap g f :=\n\n/-- The induced map from the quotient by the kernel is injective. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S),\n  Function.Injective ↑(RingHom.kerLift f) :=\n\n/-- In any concrete category, injective morphisms are monomorphisms. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C} (f : X ⟶ Y),\n  Function.Injective ↑f → CategoryTheory.Mono f :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹ :=\n\n/-- Prove that every homomorphism of fields is injective. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K →+* L), Function.Injective ↑f "
    ]
  },
  {
    "docString": "Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces.",
    "prompts": "[{\"theorem\":\n  \"∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] (E : Type v) [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : ProperSpace 𝕜] [inst : FiniteDimensional 𝕜 E], ProperSpace E\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any finite-dimensional vector space over a proper field is proper.\\nWe do not register this as an instance to avoid an instance loop when trying to prove the\\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\\nexplicitly when needed. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\\n    ∀ (f : V'' →ₗ[R] V),\\n      Function.Injective ↑f →\\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\\n * the function `f' : V'' → V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), ¬s1 ≤ s2 ↔ ∃ p, p ∈ s1 ∧ ¬p ∈ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is not less than or equal to another if and only if it has a point not in the\\nsecond subspace. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I ≠ 0 → Set.Finite (Function.mulSupport fun v => IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\\n`v^(val_v(I))` is not the unit ideal. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {β : Type v} {π : β → Type u_1} [inst : Fintype β] [inst_1 : (b : β) → PseudoMetricSpace (π b)]\\n  [h : ∀ (b : β), ProperSpace (π b)], ProperSpace ((b : β) → π b)\",\n  \"isProp\": true,\n  \"docString\": \"A finite product of proper spaces is proper. \"},\n {\"theorem\":\n  \"∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    ↑(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (p : Submodule K V), p < ⊤ → ∃ f, f ≠ 0 ∧ p ≤ LinearMap.ker f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p < ⊤` is a subspace of a vector space `V`, then there exists a nonzero linear map\\n`f : V →ₗ[K] K` such that `p ≤ ker f`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {K : Type u_2}\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] {I : Ideal R},\\n  I ≠ 0 →\\n    Set.Finite\\n      (Function.mulSupport fun v =>\\n        ↑v.asIdeal ^ (-↑(Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\\n`v^-(val_v(I))` is not the unit ideal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\\n  IsClosed s →\\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\\n  [inst : T2Space α], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible T₂ space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) →\\n    Pairwise (Disjoint on s) →\\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"}]\n",
    "prompt_cons": "/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem ∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] (E : Type v) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : ProperSpace 𝕜] [inst : FiniteDimensional 𝕜 E], ProperSpace E :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\n * the function `f' : V'' → V'` doesn't need to be injective -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\n    ∀ (f : V'' →ₗ[R] V),\n      Function.Injective ↑f →\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\n  AffineIndependent k f → Set.Finite s :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i) :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), ¬s1 ≤ s2 ↔ ∃ p, p ∈ s1 ∧ ¬p ∈ s2 :=\n\n/-- For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\n`v^(val_v(I))` is not the unit ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I ≠ 0 → Set.Finite (Function.mulSupport fun v => IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I) :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- A finite product of proper spaces is proper. -/\ntheorem ∀ {β : Type v} {π : β → Type u_1} [inst : Fintype β] [inst_1 : (b : β) → PseudoMetricSpace (π b)]\n  [h : ∀ (b : β), ProperSpace (π b)], ProperSpace ((b : β) → π b) :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem ∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    ↑(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- If `p < ⊤` is a subspace of a vector space `V`, then there exists a nonzero linear map\n`f : V →ₗ[K] K` such that `p ≤ ker f`. -/\ntheorem ∀ {K : Type u_1} {V : Type u} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (p : Submodule K V), p < ⊤ → ∃ f, f ≠ 0 ∧ p ≤ LinearMap.ker f :=\n\n/-- For every nonzero ideal `I` of `v`, there are finitely many maximal ideals `v` such that\n`v^-(val_v(I))` is not the unit ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {K : Type u_2}\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] {I : Ideal R},\n  I ≠ 0 →\n    Set.Finite\n      (Function.mulSupport fun v =>\n        ↑v.asIdeal ^ (-↑(Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I))))) :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\n  IsClosed s →\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S :=\n\n/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\n  [inst : T2Space α], False :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) →\n    Pairwise (Disjoint on s) →\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι :=\n\n/-- Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces. -/\ntheorem",
    "choices": [
      "∀ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  ¬∃ (ι : Type u_1) (s : ι → Submodule F V) [inst_4 : Finite ι], V = ⋃ (i : ι), ↑(s i) "
    ]
  },
  {
    "docString": "Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`- and `q`-primary components are disjoint for `p ≠ q`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddCommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\\n  p ≠ p' → Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\": \"The `p`- and `q`-primary components are disjoint for `p ≠ q`.\"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\\n  p + q ≠ 0 →\\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) ≤ Polynomial.rootMultiplicity a (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p + q` is at least the minimum of the multiplicities. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)] [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ → ∀ (H₁ H₂ : Subgroup G), IsPGroup p₁ { x // x ∈ H₁ } → IsPGroup p₂ { x // x ∈ H₂ } → Disjoint H₁ H₂\",\n  \"isProp\": true,\n  \"docString\": \"p-groups with different p are disjoint \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\ntheorem ∀ {G : Type u_1} [inst : AddCommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\n  p ≠ p' → Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p') :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem ∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem ∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\n  p + q ≠ 0 →\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) ≤ Polynomial.rootMultiplicity a (p + q) :=\n\n/-- p-groups with different p are disjoint -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)] [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ → ∀ (H₁ H₂ : Subgroup G), IsPGroup p₁ { x // x ∈ H₁ } → IsPGroup p₂ { x // x ∈ H₂ } → Disjoint H₁ H₂ :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card α = p * q → ¬IsSimpleGroup α "
    ]
  },
  {
    "docString": "Prove that no group of order 224 is simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x ∈ ↑(LieAlgebra.radical R L) }\",\n  \"isProp\": true,\n  \"docString\": \"The radical of a Noetherian Lie algebra is solvable. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"}]\n",
    "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- The radical of a Noetherian Lie algebra is solvable. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x ∈ ↑(LieAlgebra.radical R L) } :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- Prove that no group of order 224 is simple. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α "
    ]
  },
  {
    "docString": "An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] {x : R}, ‖x‖ < 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a normed ring, the powers of an element x with `‖x‖ < 1` tend to zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\\nnilpotent, except its constant term which is a unit. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G ⧸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"theorem\":\n  \"∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂)\",\n  \"isProp\": true,\n  \"docString\": \"Products of nilpotent groups are nilpotent \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)] [inst_1 : Finite η]\\n  [inst_2 : ∀ (i : η), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"n-ary products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] {I : LieIdeal R L},\\n  I ≤ LieAlgebra.center R L → LieAlgebra.IsNilpotent R (L ⧸ I) → LieAlgebra.IsNilpotent R L\",\n  \"isProp\": true,\n  \"docString\": \"A central extension of nilpotent Lie algebras is nilpotent. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type v) [inst : IsROrC 𝕜] {E : Type u} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] (x : E),\\n  x ≠ 0 → ∃ g, ‖g‖ = 1 ∧ ↑g x = ↑‖x‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of Hahn-Banach. Given a nonzero element `x` of a normed space, there exists an\\nelement of the dual space, of norm `1`, whose value on `x` is `‖x‖`. \"},\n {\"theorem\":\n  \"∀ {η : Type u_2} {Gs : η → Type u_1} [inst : (i : η) → Group (Gs i)] [inst_1 : ∀ (i : η), Group.IsNilpotent (Gs i)]\\n  (n : ℕ), (∀ (i : η), Group.nilpotencyClass (Gs i) ≤ n) → Group.IsNilpotent ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"products of nilpotent groups are nilpotent if their nilpotency class is bounded \"},\n {\"theorem\": \"∀ {M : Type u_1} [inst : Monoid M] {x : M}, 1 ∈ powers x\",\n  \"isProp\": true,\n  \"docString\":\n  \"1 is in the set of natural number powers of an element of a monoid. \"}]\n",
    "prompt_cons": "/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- In a normed ring, the powers of an element x with `‖x‖ < 1` tend to zero. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] {x : R}, ‖x‖ < 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) :=\n\n/-- Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\nnilpotent, except its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G ⧸ H) :=\n\n/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤ :=\n\n/-- Products of nilpotent groups are nilpotent -/\ntheorem ∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- n-ary products of nilpotent groups are nilpotent -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)] [inst_1 : Finite η]\n  [inst_2 : ∀ (i : η), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : η) → Gs i) :=\n\n/-- A subgroup of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x ∈ H } :=\n\n/-- A central extension of nilpotent Lie algebras is nilpotent. -/\ntheorem ∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] {I : LieIdeal R L},\n  I ≤ LieAlgebra.center R L → LieAlgebra.IsNilpotent R (L ⧸ I) → LieAlgebra.IsNilpotent R L :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- Corollary of Hahn-Banach. Given a nonzero element `x` of a normed space, there exists an\nelement of the dual space, of norm `1`, whose value on `x` is `‖x‖`. -/\ntheorem ∀ (𝕜 : Type v) [inst : IsROrC 𝕜] {E : Type u} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] (x : E),\n  x ≠ 0 → ∃ g, ‖g‖ = 1 ∧ ↑g x = ↑‖x‖ :=\n\n/-- products of nilpotent groups are nilpotent if their nilpotency class is bounded -/\ntheorem ∀ {η : Type u_2} {Gs : η → Type u_1} [inst : (i : η) → Group (Gs i)] [inst_1 : ∀ (i : η), Group.IsNilpotent (Gs i)]\n  (n : ℕ), (∀ (i : η), Group.nilpotencyClass (Gs i) ≤ n) → Group.IsNilpotent ((i : η) → Gs i) :=\n\n/-- 1 is in the set of natural number powers of an element of a monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {x : M}, 1 ∈ powers x :=\n\n/-- An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x → IsUnit (1 + x) "
    ]
  },
  {
    "docString": "Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\":\n  \"∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\\n  ¬IsField A →\\n    ∀ {I : Ideal A},\\n      I ≠ ⊥ →\\n        ∃ Z,\\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) (I : { x // x ∈ nonZeroDivisors (Ideal S) }),\\n  ∃ b, b ∈ ↑I ∧ b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ↑abv (↑(Algebra.norm R) c) < ↑abv (↑(Algebra.norm R) b) → c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : Field K] [inst_2 : IsDomain A] [inst_3 : Algebra A K]\\n  [inst_4 : IsFractionRing A K] [h : IsDedekindDomain A] (I : Ideal A), I ≠ ⊥ → ↑I * (↑I)⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Nonzero integral ideals in a Dedekind domain are invertible.\\n\\nWe will use this to show that nonzero fractional ideals are invertible,\\nand finally conclude that fractional ideals in a Dedekind domain form a group with zero.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (p : ℕ) [inst_1 : CharP R p] (I : Ideal R),\\n  (∀ (x : ℕ), ↑x ∈ I → ↑x = 0) → CharP (R ⧸ I) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\\ninherits the characteristic of the underlying ring. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} [inst : CommRing R₁] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R₁ K]\\n  [frac : IsFractionRing R₁ K] [inst_3 : IsDomain R₁] [inst_4 : IsNoetherianRing R₁]\\n  (I : FractionalIdeal (nonZeroDivisors R₁) K), IsNoetherian R₁ { x // x ∈ ↑I }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every fractional ideal of a noetherian integral domain is noetherian. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ↔ ∀ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"theorem\":\n  \"∀ (A : Type u_1) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A] (P : Ideal A)\\n  [inst_3 : Ideal.IsPrime P] (Aₘ : Type u_2) [inst_4 : CommRing Aₘ] [inst_5 : IsDomain Aₘ] [inst_6 : Algebra A Aₘ]\\n  [inst : IsLocalization.AtPrime Aₘ P], IsDedekindDomain Aₘ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of a Dedekind domain at every nonzero prime ideal is a Dedekind domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsNoetherianRing R], IsNoetherianRing (Polynomial R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\\n  I ≠ 0 →\\n    ¬v.asIdeal ^ (Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) + 1) ∣\\n        ∏ᶠ (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every nonzero ideal `I` of `v`, `v^(val_v(I) + 1)` does not divide `∏_v v^(val_v(I))`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ (S : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite ↑S] [inst_6 : IsCyclotomicExtension S A B],\\n  Algebra.IsIntegral A B\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite cyclotomic extension of an integral noetherian domain is integral \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"}]\n",
    "prompt_cons": "/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I :=\n\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) -/\ntheorem ∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\n  ¬IsField A →\n    ∀ {I : Ideal A},\n      I ≠ ⊥ →\n        ∃ Z,\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥ :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) (I : { x // x ∈ nonZeroDivisors (Ideal S) }),\n  ∃ b, b ∈ ↑I ∧ b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ↑abv (↑(Algebra.norm R) c) < ↑abv (↑(Algebra.norm R) b) → c = 0 :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem ∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- Nonzero integral ideals in a Dedekind domain are invertible.\n\nWe will use this to show that nonzero fractional ideals are invertible,\nand finally conclude that fractional ideals in a Dedekind domain form a group with zero. -/\ntheorem ∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : Field K] [inst_2 : IsDomain A] [inst_3 : Algebra A K]\n  [inst_4 : IsFractionRing A K] [h : IsDedekindDomain A] (I : Ideal A), I ≠ ⊥ → ↑I * (↑I)⁻¹ = 1 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M :=\n\n/-- If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (p : ℕ) [inst_1 : CharP R p] (I : Ideal R),\n  (∀ (x : ℕ), ↑x ∈ I → ↑x = 0) → CharP (R ⧸ I) p :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥ :=\n\n/-- Every fractional ideal of a noetherian integral domain is noetherian. -/\ntheorem ∀ {R₁ : Type u_1} [inst : CommRing R₁] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R₁ K]\n  [frac : IsFractionRing R₁ K] [inst_3 : IsDomain R₁] [inst_4 : IsNoetherianRing R₁]\n  (I : FractionalIdeal (nonZeroDivisors R₁) K), IsNoetherian R₁ { x // x ∈ ↑I } :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0 :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I} :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem ∀ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ↔ ∀ (I : Ideal R), Ideal.FG I :=\n\n/-- The localization of a Dedekind domain at every nonzero prime ideal is a Dedekind domain. -/\ntheorem ∀ (A : Type u_1) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A] (P : Ideal A)\n  [inst_3 : Ideal.IsPrime P] (Aₘ : Type u_2) [inst_4 : CommRing Aₘ] [inst_5 : IsDomain Aₘ] [inst_6 : Algebra A Aₘ]\n  [inst : IsLocalization.AtPrime Aₘ P], IsDedekindDomain Aₘ :=\n\n/-- Hilbert basis theorem: a polynomial ring over a noetherian ring is a noetherian ring. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsNoetherianRing R], IsNoetherianRing (Polynomial R) :=\n\n/-- For every nonzero ideal `I` of `v`, `v^(val_v(I) + 1)` does not divide `∏_v v^(val_v(I))`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\n  I ≠ 0 →\n    ¬v.asIdeal ^ (Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) + 1) ∣\n        ∏ᶠ (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- A finite cyclotomic extension of an integral noetherian domain is integral -/\ntheorem ∀ (S : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite ↑S] [inst_6 : IsCyclotomicExtension S A B],\n  Algebra.IsIntegral A B :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I "
    ]
  },
  {
    "docString": "Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (∀ (P : Ideal R) (x : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\\n    I = J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\\nthe localization of `J` at `P`, then `I = J`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (∀ (P : Ideal R) (hP : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I ≤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\\n    I ≤ J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\\nthe localization of `J` at `P`, then `I ≤ J`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\\n  Ideal.comap (algebraMap R S) (conductor R x) ⊔ I = ⊤ →\\n    Function.Injective ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) →\\n      Ideal.comap (algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\\n        Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R}\\n  {p : R} {z : S},\\n  p ∈ Ideal.comap (algebraMap R S) (conductor R x) →\\n    z ∈ Ideal.map (algebraMap R S) I →\\n      ↑(algebraMap R S) p * z ∈\\n        ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) ''\\n          ↑(Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"This technical lemma tell us that if `C` is the conductor of `R<x>` and `I` is an ideal of `R`\\nthen `p * (I * S) ⊆ I * R<x>` for any `p` in `C ∩ R` \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  ↑Polynomial.C x ∈\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\\n  IsNilpotent I →\\n    ∀ {P : ⦃S : Type u_1⦄ → [inst : CommRing S] → Ideal S → Prop},\\n      (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I : Ideal S), I ^ 2 = ⊥ → P I) →\\n        (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I J : Ideal S),\\n            I ≤ J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J) →\\n          P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\\n`P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\\n  Function.Injective\\n    ↑(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n        (_ :\\n          P ≤\\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be an ideal in `R[x]`.  The map\\n`R[x]/P → (R / (P ∩ R))[x] / (P / (P ∩ R))`\\nis injective.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R) (s : Set R),\\n  ↑(Ideal.Quotient.mk I) ⁻¹' (↑(Ideal.Quotient.mk I) '' s) = ⋃ (x : { x // x ∈ I }), (fun y => ↑x + y) '' s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `I` is an ideal of a commutative ring `R`, if `q : R → R/I` is the quotient map, and if\\n`s ⊆ R` is a subset, then `q⁻¹(q(s)) = ⋃ᵢ(i + s)`, the union running over all `i ∈ I`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (I : Ideal (R × S)),\\n  I = Ideal.prod (Ideal.map (RingHom.fst R S) I) (Ideal.map (RingHom.snd R S) I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every ideal of the product ring is of the form `I × J`, where `I` and `J` can be explicitly\\ngiven as the image under the projection maps. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I : Ideal R},\\n  Ideal.radical I = Ideal.jacobson I ↔ Ideal.radical ⊥ = Ideal.jacobson ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` that is `I`-adically complete is Henselian at `I`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R ↔\\n    ∀ {I : Ideal R}, Ideal.IsPrime I → ∃ M, (∀ (J : Ideal R), J ∈ M → Ideal.IsMaximal J ∨ J = ⊤) ∧ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"}]\n",
    "prompt_cons": "/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (∀ (P : Ideal R) (x : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\n    I = J :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I ≤ J`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (∀ (P : Ideal R) (hP : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I ≤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\n    I ≤ J :=\n\n/-- A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\n  Ideal.comap (algebraMap R S) (conductor R x) ⊔ I = ⊤ →\n    Function.Injective ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) →\n      Ideal.comap (algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\n        Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥ :=\n\n/-- This technical lemma tell us that if `C` is the conductor of `R<x>` and `I` is an ideal of `R`\nthen `p * (I * S) ⊆ I * R<x>` for any `p` in `C ∩ R` -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R}\n  {p : R} {z : S},\n  p ∈ Ideal.comap (algebraMap R S) (conductor R x) →\n    z ∈ Ideal.map (algebraMap R S) I →\n      ↑(algebraMap R S) p * z ∈\n        ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) ''\n          ↑(Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I) :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  ↑Polynomial.C x ∈\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\n    x = 0 :=\n\n/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I →\n    ∀ {P : ⦃S : Type u_1⦄ → [inst : CommRing S] → Ideal S → Prop},\n      (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I : Ideal S), I ^ 2 = ⊥ → P I) →\n        (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I J : Ideal S),\n            I ≤ J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J) →\n          P I :=\n\n/-- Let `P` be an ideal in `R[x]`.  The map\n`R[x]/P → (R / (P ∩ R))[x] / (P / (P ∩ R))`\nis injective. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\n  Function.Injective\n    ↑(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n        (_ :\n          P ≤\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P))) :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P) :=\n\n/-- If `I` is an ideal of a commutative ring `R`, if `q : R → R/I` is the quotient map, and if\n`s ⊆ R` is a subset, then `q⁻¹(q(s)) = ⋃ᵢ(i + s)`, the union running over all `i ∈ I`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R) (s : Set R),\n  ↑(Ideal.Quotient.mk I) ⁻¹' (↑(Ideal.Quotient.mk I) '' s) = ⋃ (x : { x // x ∈ I }), (fun y => ↑x + y) '' s :=\n\n/-- Every ideal of the product ring is of the form `I × J`, where `I` and `J` can be explicitly\ngiven as the image under the projection maps. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (I : Ideal (R × S)),\n  I = Ideal.prod (Ideal.map (RingHom.fst R S) I) (Ideal.map (RingHom.snd R S) I) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem ∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I : Ideal R},\n  Ideal.radical I = Ideal.jacobson I ↔ Ideal.radical ⊥ = Ideal.jacobson ⊥ :=\n\n/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R ↔\n    ∀ {I : Ideal R}, Ideal.IsPrime I → ∃ M, (∀ (J : Ideal R), J ∈ M → Ideal.IsMaximal J ∨ J = ⊤) ∧ I = sInf M :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s) :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y :=\n\n/-- Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I ⊔ J = ⊤ → I * J = I ⊓ J "
    ]
  },
  {
    "docString": "If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$.",
    "prompts": "[{\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → (a ∣ b + c ↔ a ∣ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\\nelement `c` iff `a` divides `c`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ c → (a ∣ b + c ↔ a ∣ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\\n`b` with `c` iff `a` divides `b`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → (a ∣ b - c ↔ a ∣ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `b` in a ring, `a` divides the difference of `b` and\\nanother element `c` iff `a` divides `c`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ c → (a ∣ b - c ↔ a ∣ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `c` in a ring, `a` divides the difference of another\\nelement `b` with `c` iff `a` divides `b`. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ b + a ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element a divides the sum b + a if and only if a divides b.\"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ a + b ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element a divides the sum a + b if and only if a divides b.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p ≠ 1`. \"},\n {\"theorem\": \"∀ {a b k : ℕ}, Nat.coprime a b → k ∣ a → k ∣ b → k = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `k:ℕ` divides coprime `a` and `b` then `k = 1` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {a b : α} {u : αˣ}, a * ↑u ∣ b ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid, an element `a` divides an element `b` iff all associates of `a` divide `b`. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, a % b = c → b ∣ a - c\",\n  \"isProp\": true,\n  \"docString\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {a b u : α}, IsUnit u → (a * u ∣ b ↔ a ∣ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid, an element a divides an element b iff all associates of `a` divide `b`.\"},\n {\"theorem\":\n  \"∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A ≃+* B → NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ b - a ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `a` divides the difference `b - a` if and only if `a` divides `b`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {a b : α} {u : αˣ}, a ∣ b * ↑u ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid, an element `a` divides an element `b` iff `a` divides all\\nassociates of `b`. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ a - b ↔ a ∣ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element `a` divides the difference `a - b` if and only if `a` divides `b`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\": \"∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer with larger absolute value divides an integer, it is\\nzero. \"}]\n",
    "prompt_cons": "/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0 :=\n\n/-- If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\nelement `c` iff `a` divides `c`. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → (a ∣ b + c ↔ a ∣ c) :=\n\n/-- If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\n`b` with `c` iff `a` divides `b`. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ c → (a ∣ b + c ↔ a ∣ b) :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0 :=\n\n/-- If an element `a` divides another element `b` in a ring, `a` divides the difference of `b` and\nanother element `c` iff `a` divides `c`. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → (a ∣ b - c ↔ a ∣ c) :=\n\n/-- If an element `a` divides another element `c` in a ring, `a` divides the difference of another\nelement `b` with `c` iff `a` divides `b`. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ c → (a ∣ b - c ↔ a ∣ b) :=\n\n/-- An element a divides the sum b + a if and only if a divides b. -/\ntheorem ∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ b + a ↔ a ∣ b :=\n\n/-- An element a divides the sum a + b if and only if a divides b. -/\ntheorem ∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ a + b ↔ a ∣ b :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p ≠ 1`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1 :=\n\n/-- If `k:ℕ` divides coprime `a` and `b` then `k = 1` -/\ntheorem ∀ {a b k : ℕ}, Nat.coprime a b → k ∣ a → k ∣ b → k = 1 :=\n\n/-- In a monoid, an element `a` divides an element `b` iff all associates of `a` divide `b`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {a b : α} {u : αˣ}, a * ↑u ∣ b ↔ a ∣ b :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → b ∣ a - c :=\n\n/-- In a monoid, an element a divides an element b iff all associates of `a` divide `b`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {a b u : α}, IsUnit u → (a * u ∣ b ↔ a ∣ b) :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem ∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A ≃+* B → NoZeroDivisors A :=\n\n/-- An element `a` divides the difference `b - a` if and only if `a` divides `b`. -/\ntheorem ∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ b - a ↔ a ∣ b :=\n\n/-- In a monoid, an element `a` divides an element `b` iff `a` divides all\nassociates of `b`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {a b : α} {u : αˣ}, a ∣ b * ↑u ↔ a ∣ b :=\n\n/-- An element `a` divides the difference `a - b` if and only if `a` divides `b`. -/\ntheorem ∀ {α : Type u_1} [inst : Ring α] {a b : α}, a ∣ a - b ↔ a ∣ b :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- If an integer with larger absolute value divides an integer, it is\nzero. -/\ntheorem ∀ {a b : ℤ}, a ∣ b → Int.natAbs b < Int.natAbs a → b = 0 :=\n\n/-- If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$. -/\ntheorem",
    "choices": [
      "∀ {a b : ℤ}, a ∣ b → a ∣ b "
    ]
  },
  {
    "docString": "Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n` \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a ≠ 0 → ↑(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n` -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a ≠ 0 → ↑(quadraticChar F) a ^ 2 = 1 :=\n\n/-- Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$. -/\ntheorem",
    "choices": [
      "irreducible_X_pow_add_one : ∀ {F : Type u_1} [inst : Field F], ringChar F = 2 → Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1) "
    ]
  },
  {
    "docString": "Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n j : ℕ),\\n  j < p ^ n →\\n    p ^ (n - WittVector.pnat_multiplicity p { val := j + 1, property := (_ : 0 < Nat.succ j) }) ∣\\n      Nat.choose (p ^ n) (j + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key divisibility fact for the proof of `WittVector.map_frobeniusPoly`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] (q : ℕ) [hF : ExpChar F q] (f : Polynomial F),\\n  Irreducible f → Polynomial.HasSeparableContraction q f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every irreducible polynomial can be contracted to a separable polynomial.\\nhttps://stacks.math.columbia.edu/tag/09H0 \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem ∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1 :=\n\n/-- A key divisibility fact for the proof of `WittVector.map_frobeniusPoly`. -/\ntheorem ∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n j : ℕ),\n  j < p ^ n →\n    p ^ (n - WittVector.pnat_multiplicity p { val := j + 1, property := (_ : 0 < Nat.succ j) }) ∣\n      Nat.choose (p ^ n) (j + 1) :=\n\n/-- Every irreducible polynomial can be contracted to a separable polynomial.\nhttps://stacks.math.columbia.edu/tag/09H0 -/\ntheorem ∀ {F : Type u_1} [inst : Field F] (q : ℕ) [hF : ExpChar F q] (f : Polynomial F),\n  Irreducible f → Polynomial.HasSeparableContraction q f :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ :=\n\n/-- Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_sub_C_of_prime_pow_not_dvd {p : ℕ} [hp : Fact (Nat.Prime p)] (n : ℕ) (hn : ¬p ^ 2 ∣ n) :\n  Irreducible (Polynomial.x ^ 3 - Polynomial.C (9 : (Zmod p)[X])) "
    ]
  },
  {
    "docString": "Prove that there are infinitely many primes congruent to $-1$ (modulo $4$).",
    "prompts": "[{\"theorem\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"∀ {m n : ℕ+}, PNat.factorMultiset m ≤ PNat.factorMultiset n ↔ m ∣ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"We now have four different results that all encode the\\nidea that inequality of multisets corresponds to divisibility\\nof positive integers. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k]\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\\n`p ≡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → ↑ZMod.χ₄ ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `χ₄ n = 1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"}]\n",
    "prompt_cons": "/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. -/\ntheorem ∀ {m n : ℕ+}, PNat.factorMultiset m ≤ PNat.factorMultiset n ↔ m ∣ n :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\n`p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k] :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If `n % 4 = 1`, then `χ₄ n = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → ↑ZMod.χ₄ ↑n = 1 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1 :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem ∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- Prove that there are infinitely many primes congruent to $-1$ (modulo $4$). -/\ntheorem",
    "choices": [
      "∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD k]} "
    ]
  },
  {
    "docString": "Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ K → ↑(reflection Kᗮ) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `Kᗮ` of an element of `K` is its negation. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\\n  a ≠ 0 → a * b = a * c → b = c\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication by a nonzero element is left cancellative. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(reflection K) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `K` of an element of `Kᗮ` is its negation. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsRightCancelMulZero M₀] {a b c : M₀},\\n  b ≠ 0 → a * b = c * b → a = c\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicatin by a nonzero element is right cancellative. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection Kᗮ] {v : E}, v ∈ K → ↑(orthogonalProjection Kᗮ) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `Kᗮ` of an element of `K` is zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedRing α] (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b\",\n  \"isProp\": true,\n  \"docString\": \"The product of non-negative elements is non-negative. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero elements have multiplicative inverses. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(orthogonalProjection K) v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The orthogonal projection onto `K` of an element of `Kᗮ` is zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) (m : Multiset K), (∀ (a : K), a ∈ m → a ∈ s) → Multiset.prod m ∈ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a multiset of elements in a subfield is in the subfield. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] [inst_2 : CharZero K] {ζ : K} {n : ℕ+},\\n  IsPrimitiveRoot ζ ↑n → ∃! P, Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' (↑n) K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (b : A j), GradedMonoid.GMul.mul 0 b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Multiplication from the left with any graded component's zero vanishes. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (a : A i), GradedMonoid.GMul.mul a 0 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Multiplication from the right with any graded component's zero vanishes. \"}]\n",
    "prompt_cons": "/-- The reflection in `Kᗮ` of an element of `K` is its negation. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ K → ↑(reflection Kᗮ) v = -v :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- Multiplication by a nonzero element is left cancellative. -/\ntheorem ∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\n  a ≠ 0 → a * b = a * c → b = c :=\n\n/-- The reflection in `K` of an element of `Kᗮ` is its negation. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(reflection K) v = -v :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- Multiplicatin by a nonzero element is right cancellative. -/\ntheorem ∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsRightCancelMulZero M₀] {a b c : M₀},\n  b ≠ 0 → a * b = c * b → a = c :=\n\n/-- The orthogonal projection onto `Kᗮ` of an element of `K` is zero. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection Kᗮ] {v : E}, v ∈ K → ↑(orthogonalProjection Kᗮ) v = 0 :=\n\n/-- Algebraically closed fields are infinite since `Xⁿ⁺¹ - 1` is separable when `#K = n` -/\ntheorem ∀ {K : Type u_1} [inst : Field K] [inst : IsAlgClosed K], Infinite K :=\n\n/-- The product of non-negative elements is non-negative. -/\ntheorem ∀ {α : Type u} [self : OrderedRing α] (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0 :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- Nonzero elements have multiplicative inverses. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1 :=\n\n/-- The orthogonal projection onto `K` of an element of `Kᗮ` is zero. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(orthogonalProjection K) v = 0 :=\n\n/-- Product of a multiset of elements in a subfield is in the subfield. -/\ntheorem ∀ {K : Type u} [inst : Field K] (s : Subfield K) (m : Multiset K), (∀ (a : K), a ∈ m → a ∈ s) → Multiset.prod m ∈ s :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- If `K` is of characteristic `0` and there is a primitive `n`-th root of unity in `K`,\nthen `cyclotomic n K` comes from a unique polynomial with integer coefficients. -/\ntheorem ∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] [inst_2 : CharZero K] {ζ : K} {n : ℕ+},\n  IsPrimitiveRoot ζ ↑n → ∃! P, Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' (↑n) K :=\n\n/-- Multiplication from the left with any graded component's zero vanishes. -/\ntheorem ∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (b : A j), GradedMonoid.GMul.mul 0 b = 0 :=\n\n/-- Multiplication from the right with any graded component's zero vanishes. -/\ntheorem ∀ {ι : Type u_1} {A : ι → Type u_2} [inst : Add ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GNonUnitalNonAssocSemiring A] {i j : ι} (a : A i), GradedMonoid.GMul.mul a 0 = 0 :=\n\n/-- Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$. -/\ntheorem",
    "choices": [
      "∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (1 : K)], ∏ᶠ (x : K), x ≠ 0 → x = -1 "
    ]
  },
  {
    "docString": "Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PartialOrder α] {f : β → β → α},\\n  (∀ (a b : β), f a b ≤ f b a) → ∀ (a b : β), f a b = f b a\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove commutativity of a binary operation `○`, we only to check `a ○ b ≤ b ○ a` for all `a`,\\n`b`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊓ a \\\\ b = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"For any `a`, `b`, `(a ⊓ b) ⊓ (a / b) = ⊥` \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.denominators g n = ppredB →\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.numerators g n = ppredA →\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.continuants g n = ppred →\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Monoid R] [inst_1 : NonUnitalNonAssocSemiring A]\\n  [inst_2 : DistribMulAction R A] [inst_3 : Star A] [inst_4 : NonUnitalNonAssocSemiring B]\\n  [inst_5 : DistribMulAction R B] [inst_6 : Star B] (self : A →⋆ₙₐ[R] B) (a : A),\\n  MulActionHom.toFun self.toMulActionHom (star a) = star (MulActionHom.toFun self.toMulActionHom a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a non-unital ⋆-algebra homomorphism preserves the `star` operation. \"},\n {\"theorem\": \"∀ {a : ℤ} {b : ℕ}, jacobiSym a b = -1 → ¬IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\": \"If `J(a | b)` is `-1`, then `a` is not a square modulo `b`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {l m n : ℕ} {α : Type u_1} [inst : Mul α] [inst_1 : AddCommMonoid α] (A : Matrix (Fin l) (Fin m) α)\\n  (B : Matrix (Fin m) (Fin n) α), Matrix.mulᵣ A B = Matrix.mul A B\",\n  \"isProp\": true,\n  \"docString\":\n  \"This can be used to prove\\n```lean\\nexample [AddCommMonoid α] [Mul α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : α) :\\n  !![a₁₁, a₁₂;\\n     a₂₁, a₂₂] ⬝ !![b₁₁, b₁₂;\\n                    b₂₁, b₂₂] =\\n  !![a₁₁*b₁₁ + a₁₂*b₂₁, a₁₁*b₁₂ + a₁₂*b₂₂;\\n     a₂₁*b₁₁ + a₂₂*b₂₁, a₂₁*b₁₂ + a₂₂*b₂₂] :=\\n(mulᵣ_eq _ _).symm\\n```\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊔ a \\\\ b = a\",\n  \"isProp\": true,\n  \"docString\": \"For any `a`, `b`, `(a ⊓ b) ⊔ (a / b) = a` \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddCommMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\": \"∀ {a : ℤ} {b : ℕ}, jacobiSym a b = 0 ↔ b ≠ 0 ∧ Int.gcd a ↑b ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The symbol `J(a | b)` vanishes if and only if `b ≠ 0` and `a` and `b` are not coprime. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PartialOrder α] {f : α → α → α},\\n  Commutative f → (∀ (a b c : α), f (f a b) c ≤ f a (f b c)) → Associative f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove associativity of a commutative binary operation `○`, we only to check\\n`(a ○ b) ○ c ≤ a ○ (b ○ c)` for all `a`, `b`, `c`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {x y : R},\\n  Commute x y →\\n    ∀ (n : ℕ), (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun m => x ^ m * y ^ (n - m) * ↑(Nat.choose n m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of the **binomial theorem** for commuting elements in noncommutative semirings. \"},\n {\"theorem\":\n  \"∀ (R : Type u) {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]\\n  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]\\n  [inst_7 : StarModule R A] (s : Set A), star (NonUnitalAlgebra.adjoin R s) = NonUnitalAlgebra.adjoin R (star s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The star operation on `NonUnitalSubalgebra` commutes with `NonUnitalAlgebra.adjoin`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (a : A), ↑f (star a) = star (↑f a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, a ⋆-algebra equivalence preserves the `star` operation. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\\n  a ≠ 0 → a * b = a * c → b = c\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication by a nonzero element is left cancellative. \"}]\n",
    "prompt_cons": "/-- To prove commutativity of a binary operation `○`, we only to check `a ○ b ≤ b ○ a` for all `a`,\n`b`. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PartialOrder α] {f : β → β → α},\n  (∀ (a b : β), f a b ≤ f b a) → ∀ (a b : β), f a b = f b a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- For any `a`, `b`, `(a ⊓ b) ⊓ (a / b) = ⊥` -/\ntheorem ∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊓ a \\ b = ⊥ :=\n\n/-- Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.denominators g n = ppredB →\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.numerators g n = ppredA →\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.continuants g n = ppred →\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- By definition, a non-unital ⋆-algebra homomorphism preserves the `star` operation. -/\ntheorem ∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : Monoid R] [inst_1 : NonUnitalNonAssocSemiring A]\n  [inst_2 : DistribMulAction R A] [inst_3 : Star A] [inst_4 : NonUnitalNonAssocSemiring B]\n  [inst_5 : DistribMulAction R B] [inst_6 : Star B] (self : A →⋆ₙₐ[R] B) (a : A),\n  MulActionHom.toFun self.toMulActionHom (star a) = star (MulActionHom.toFun self.toMulActionHom a) :=\n\n/-- If `J(a | b)` is `-1`, then `a` is not a square modulo `b`. -/\ntheorem ∀ {a : ℤ} {b : ℕ}, jacobiSym a b = -1 → ¬IsSquare ↑a :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- This can be used to prove\n```lean\nexample [AddCommMonoid α] [Mul α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : α) :\n  !![a₁₁, a₁₂;\n     a₂₁, a₂₂] ⬝ !![b₁₁, b₁₂;\n                    b₂₁, b₂₂] =\n  !![a₁₁*b₁₁ + a₁₂*b₂₁, a₁₁*b₁₂ + a₁₂*b₂₂;\n     a₂₁*b₁₁ + a₂₂*b₂₁, a₂₁*b₁₂ + a₂₂*b₂₂] :=\n(mulᵣ_eq _ _).symm\n``` -/\ntheorem ∀ {l m n : ℕ} {α : Type u_1} [inst : Mul α] [inst_1 : AddCommMonoid α] (A : Matrix (Fin l) (Fin m) α)\n  (B : Matrix (Fin m) (Fin n) α), Matrix.mulᵣ A B = Matrix.mul A B :=\n\n/-- For any `a`, `b`, `(a ⊓ b) ⊔ (a / b) = a` -/\ntheorem ∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊔ a \\ b = a :=\n\n/-- Multiplication is commutative -/\ntheorem ∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddCommMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a :=\n\n/-- Multiplication is commutative. -/\ntheorem ∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x :=\n\n/-- The symbol `J(a | b)` vanishes if and only if `b ≠ 0` and `a` and `b` are not coprime. -/\ntheorem ∀ {a : ℤ} {b : ℕ}, jacobiSym a b = 0 ↔ b ≠ 0 ∧ Int.gcd a ↑b ≠ 1 :=\n\n/-- To prove associativity of a commutative binary operation `○`, we only to check\n`(a ○ b) ○ c ≤ a ○ (b ○ c)` for all `a`, `b`, `c`. -/\ntheorem ∀ {α : Type u} [inst : PartialOrder α] {f : α → α → α},\n  Commutative f → (∀ (a b c : α), f (f a b) c ≤ f a (f b c)) → Associative f :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A version of the **binomial theorem** for commuting elements in noncommutative semirings. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {x y : R},\n  Commute x y →\n    ∀ (n : ℕ), (x + y) ^ n = Finset.sum (Finset.range (n + 1)) fun m => x ^ m * y ^ (n - m) * ↑(Nat.choose n m) :=\n\n/-- The star operation on `NonUnitalSubalgebra` commutes with `NonUnitalAlgebra.adjoin`. -/\ntheorem ∀ (R : Type u) {A : Type v} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : NonUnitalSemiring A]\n  [inst_3 : StarRing A] [inst_4 : Module R A] [inst_5 : IsScalarTower R A A] [inst_6 : SMulCommClass R A A]\n  [inst_7 : StarModule R A] (s : Set A), star (NonUnitalAlgebra.adjoin R s) = NonUnitalAlgebra.adjoin R (star s) :=\n\n/-- By definition, a ⋆-algebra equivalence preserves the `star` operation. -/\ntheorem ∀ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : Add A]\n  [inst_1 : Mul A] [inst_2 : SMul R A] [inst_3 : Star A] [inst_4 : Add B] [inst_5 : Mul B] [inst_6 : SMul R B]\n  [inst_7 : Star B] [self : StarAlgEquivClass F R A B] (f : F) (a : A), ↑f (star a) = star (↑f a) :=\n\n/-- Multiplication by a nonzero element is left cancellative. -/\ntheorem ∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\n  a ≠ 0 → a * b = a * c → b = c :=\n\n/-- Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative. -/\ntheorem",
    "choices": [
      "not_star_comm : ¬(∀ (a b : ℤ), a - b = b - a) "
    ]
  },
  {
    "docString": "Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is associative \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w * y) (x * z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\\n  ↑f (a * b) = ↑f a * ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve multiplication. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddCommMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : ℕ) {w x : M}, ↑c w x → ↑c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\\n  IsMonoidHom f → ∀ (x y : α), f (x * y) = f x * f y\",\n  \"isProp\": true,\n  \"docString\": \"A monoid homomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => y * x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Right multiplication in a ring is an additive monoid morphism. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Group M] (c : Con M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w / y) (x / z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve division. \"},\n {\"theorem\":\n  \"∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of monoid homomorphisms is associative. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} (self : CategoryTheory.Monad.Algebra T),\\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.app (CategoryTheory.Monad.μ T) self.A) self.a =\\n    CategoryTheory.CategoryStruct.comp (T.map self.a) self.a\",\n  \"isProp\": true,\n  \"docString\": \"The associativity axiom associated to an algebra. \"}]\n",
    "prompt_cons": "/-- Multiplication is associative -/\ntheorem ∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c) :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y :=\n\n/-- Multiplicative congruence relations preserve multiplication. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w * y) (x * z) :=\n\n/-- Multiplication is commutative. -/\ntheorem ∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x :=\n\n/-- Ring homomorphisms preserve multiplication. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\n  ↑f (a * b) = ↑f a * ↑f b :=\n\n/-- Multiplication is commutative -/\ntheorem ∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddCommMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem ∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y :=\n\n/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulLeftInvariant μ :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : ℕ) {w x : M}, ↑c w x → ↑c (w ^ n) (x ^ n) :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x :=\n\n/-- A monoid homomorphism preserves multiplication. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\n  IsMonoidHom f → ∀ (x y : α), f (x * y) = f x * f y :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- Right multiplication in a ring is an additive monoid morphism. -/\ntheorem ∀ {γ : Type u_1} [inst : NonUnitalNonAssocSemiring γ] (x : γ), IsAddMonoidHom fun y => y * x :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- Multiplicative congruence relations preserve division. -/\ntheorem ∀ {M : Type u_1} [inst : Group M] (c : Con M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w / y) (x / z) :=\n\n/-- Composition of monoid homomorphisms is associative. -/\ntheorem ∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : One M] [inst_1 : One N] [inst_2 : One P]\n  [inst_3 : One Q] (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q),\n  OneHom.comp (OneHom.comp h g) f = OneHom.comp h (OneHom.comp g f) :=\n\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulRightInvariant μ :=\n\n/-- The associativity axiom associated to an algebra. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {T : CategoryTheory.Monad C} (self : CategoryTheory.Monad.Algebra T),\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.app (CategoryTheory.Monad.μ T) self.A) self.a =\n    CategoryTheory.CategoryStruct.comp (T.map self.a) self.a :=\n\n/-- Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) "
    ]
  },
  {
    "docString": "Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Ring α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is invertible and `a = b`, then `⅟a = ⅟b`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) → G) (j : Fin (n + 1)) (k : Fin n),\\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))⁻¹ *\\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\\n    Fin.contractNth j (fun x x_1 => x * x_1) g k\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\\nThen if `k < j`, this says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ = gₖ`.\\nIf `k = j`, it says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ₊₁ = gₖgₖ₊₁`.\\nIf `k > j`, it says `(g₀g₁...gₖ)⁻¹ * g₀g₁...gₖ₊₁ = gₖ₊₁.`\\nUseful for defining group cohomology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a⁻¹ * a * a = a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Multiplying `a⁻¹` by `a` twice results in `a` (whether or not `a`\\nis zero). \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {a : α} {p : α → Prop} {h : ¬a ∈ s},\\n  (∀ (x : α), x ∈ Finset.cons a s h → p x) → ∀ (x : α), x ∈ s → p x\",\n  \"isProp\": true,\n  \"docString\": \"Useful in proofs by induction. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b)\",\n  \"isProp\": true,\n  \"docString\": \"$a^{-1}ba$ is a vector. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inversion is a group homomorphism if the group is commutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {n : ℕ∞} {R : Type u_1} [inst_1 : NormedRing R]\\n  [inst_2 : NormedAlgebra 𝕜 R] [inst_3 : CompleteSpace R] (x : Rˣ), ContDiffAt 𝕜 n Ring.inverse ↑x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\\ninvertible element.  The proof is by induction, bootstrapping using an identity expressing the\\nderivative of inversion as a bilinear map of inversion itself. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. \"}]\n",
    "prompt_cons": "/-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹ :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Proof of right inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If `a` is invertible and `a = b`, then `⅟a = ⅟b`. -/\ntheorem ∀ {α : Type u} [inst : Ring α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\nThen if `k < j`, this says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ = gₖ`.\nIf `k = j`, it says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ₊₁ = gₖgₖ₊₁`.\nIf `k > j`, it says `(g₀g₁...gₖ)⁻¹ * g₀g₁...gₖ₊₁ = gₖ₊₁.`\nUseful for defining group cohomology. -/\ntheorem ∀ {n : ℕ} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) → G) (j : Fin (n + 1)) (k : Fin n),\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))⁻¹ *\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\n    Fin.contractNth j (fun x x_1 => x * x_1) g k :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹ :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- For a nonzero `a`, `a⁻¹` is a right multiplicative inverse. -/\ntheorem ∀ {K : Type u} [self : DivisionRing K] (a : K), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- `G` is closed under inverses -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier :=\n\n/-- Multiplying `a⁻¹` by `a` twice results in `a` (whether or not `a`\nis zero). -/\ntheorem ∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] (a : G₀), a⁻¹ * a * a = a :=\n\n/-- Useful in proofs by induction. -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {a : α} {p : α → Prop} {h : ¬a ∈ s},\n  (∀ (x : α), x ∈ Finset.cons a s h → p x) → ∀ (x : α), x ∈ s → p x :=\n\n/-- $a^{-1}ba$ is a vector. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) (a b : M) [inst_3 : Invertible (↑(CliffordAlgebra.ι Q) a)] [inst_4 : Invertible (↑Q a)],\n  ⅟(↑(CliffordAlgebra.ι Q) a) * ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\n    ↑(CliffordAlgebra.ι Q) ((⅟(↑Q a) * QuadraticForm.polar (↑Q) a b) • a - b) :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem ∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv :=\n\n/-- If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem ∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\ninvertible element.  The proof is by induction, bootstrapping using an identity expressing the\nderivative of inversion as a bilinear map of inversion itself. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {n : ℕ∞} {R : Type u_1} [inst_1 : NormedRing R]\n  [inst_2 : NormedAlgebra 𝕜 R] [inst_3 : CompleteSpace R] (x : Rˣ), ContDiffAt 𝕜 n Ring.inverse ↑x :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. -/\ntheorem ∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (n : ℕ) (a : Fin n → G),\n  (Fin.partialProd a n)⁻¹ = Fin.partialProd (fun i => (a (Fin.reverse i))⁻¹) n "
    ]
  },
  {
    "docString": "Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x ≠ 0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n)\",\n  \"isProp\": true,\n  \"docString\": \"If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 → IsLeftRegular a\",\n  \"isProp\": true,\n  \"docString\": \"An element admitting a left inverse is left-regular. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {x y : α}, 0 < x → y < 1 → ∃ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (x : M₀), ¬IsUnit x → Ring.inverse x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"By definition, if `x` is not invertible then `inverse x = 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\\n      (PowerSeries.exp A - 1) =\\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : UniqueFactorizationMonoid α]\\n  [inst_2 : NormalizationMonoid α] [inst_3 : DecidableEq α] {x : α} {n : ℕ}, factorization (x ^ n) = n • factorization x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `x^n` is `n` times the power in `x` \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {n : ℕ∞} {R : Type u_1} [inst_1 : NormedRing R]\\n  [inst_2 : NormedAlgebra 𝕜 R] [inst_3 : CompleteSpace R] (x : Rˣ), ContDiffAt 𝕜 n Ring.inverse ↑x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\\ninvertible element.  The proof is by induction, bootstrapping using an identity expressing the\\nderivative of inversion as a bilinear map of inversion itself. \"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- By definition, if `x` is invertible then `inverse x = x⁻¹`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹ :=\n\n/-- If `n * x = 0`, but `n/p * x ≠ 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n :=\n\n/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n) :=\n\n/-- If `n` is positive, then `(χ ^ n) a = (χ a) ^ n`. -/\ntheorem ∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommMonoidWithZero R'] (χ : MulChar R R') {n : ℕ},\n  0 < n → ∀ (a : R), ↑(χ ^ n) a = ↑χ a ^ n :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹ :=\n\n/-- Proof of right inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- An element admitting a left inverse is left-regular. -/\ntheorem ∀ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 → IsLeftRegular a :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {x y : α}, 0 < x → y < 1 → ∃ n, y ^ n < x :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- `G` is closed under inverses -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- By definition, if `x` is not invertible then `inverse x = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (x : M₀), ¬IsUnit x → Ring.inverse x = 0 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- The theorem that $(e^X - 1) * ∑ Bₙ(t)* X^n/n! = Xe^{tX}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (t : A),\n  (PowerSeries.mk fun n => ↑(Polynomial.aeval t) ((1 / ↑(Nat.factorial n)) • Polynomial.bernoulli n)) *\n      (PowerSeries.exp A - 1) =\n    PowerSeries.X * ↑(PowerSeries.rescale t) (PowerSeries.exp A) :=\n\n/-- For any `p`, the power of `p` in `x^n` is `n` times the power in `x` -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : UniqueFactorizationMonoid α]\n  [inst_2 : NormalizationMonoid α] [inst_3 : DecidableEq α] {x : α} {n : ℕ}, factorization (x ^ n) = n • factorization x :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\ninvertible element.  The proof is by induction, bootstrapping using an identity expressing the\nderivative of inversion as a bilinear map of inversion itself. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : NontriviallyNormedField 𝕜] {n : ℕ∞} {R : Type u_1} [inst_1 : NormedRing R]\n  [inst_2 : NormedAlgebra 𝕜 R] [inst_3 : CompleteSpace R] (x : Rˣ), ContDiffAt 𝕜 n Ring.inverse ↑x :=\n\n/-- Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) "
    ]
  },
  {
    "docString": "For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x ≠ 0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 → IsLeftRegular a\",\n  \"isProp\": true,\n  \"docString\": \"An element admitting a left inverse is left-regular. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y →\\n    IsOfFinAddOrder y →\\n      (∀ (p : ℕ), Nat.Prime p → p ∣ addOrderOf x → p * addOrderOf x ∣ addOrderOf y) → addOrderOf (x + y) = addOrderOf y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each prime factor of\\n`addOrderOf x` has higher multiplicity in `addOrderOf y`, and `x` commutes with `y`,\\nthen `x + y` has the same order as `y`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {a b : R}, a * b = 1 → IsRightRegular a\",\n  \"isProp\": true,\n  \"docString\": \"An element admitting a right inverse is right-regular. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commuting elements of finite order are closed under multiplication. \"}]\n",
    "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x) :=\n\n/-- Inverses of elements of finite additive order\nhave finite additive order. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x :=\n\n/-- If `n * x = 0`, but `n/p * x ≠ 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- By definition, if `x` is invertible then `inverse x = x⁻¹`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹ :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- An element admitting a left inverse is left-regular. -/\ntheorem ∀ {R : Type u_1} [inst : Monoid R] {a b : R}, b * a = 1 → IsLeftRegular a :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- If each prime factor of\n`addOrderOf x` has higher multiplicity in `addOrderOf y`, and `x` commutes with `y`,\nthen `x + y` has the same order as `y`. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x y : G},\n  AddCommute x y →\n    IsOfFinAddOrder y →\n      (∀ (p : ℕ), Nat.Prime p → p ∣ addOrderOf x → p * addOrderOf x ∣ addOrderOf y) → addOrderOf (x + y) = addOrderOf y :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x :=\n\n/-- `G` is closed under inverses -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- An element admitting a right inverse is right-regular. -/\ntheorem ∀ {R : Type u_1} [inst : Monoid R] {a b : R}, a * b = 1 → IsRightRegular a :=\n\n/-- Commuting elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ "
    ]
  },
  {
    "docString": "Deduce that $|a b|=|b a|$ for all $a, b \\in G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\": \"∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a | b^e) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {C : Type u_3} [inst : CategoryTheory.Category C] {D : Type u_4} [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\\n  CategoryTheory.CoverPreserving (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G\",\n  \"isProp\": true,\n  \"docString\": \"`G` is cover-preserving wrt the induced topology. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Ring α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is invertible and `a = b`, then `⅟a = ⅟b`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\\n  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F ⊣ G) (B : D),\\n  CategoryTheory.IsReflexivePair (F.map (G.map (CategoryTheory.NatTrans.app adj.counit B)))\\n    (CategoryTheory.NatTrans.app adj.counit (F.obj (G.obj B)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For an adjunction `F ⊣ G` with counit `ε`, the pair `(FGε_B, ε_FGB)` is reflexive. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : PartialOrder β] {l : α → β} {u : β → α},\\n  GaloisConnection l u → ∀ (b : β), (∃ a, b = l a) ↔ b = l (u b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there exists an `a` such that `b = l a`, then `a = u b` is one such element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\\na homomorphism from the whole of `G` to `F`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {D : Type u_3} [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\\n  CategoryTheory.CoverLifting (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G\",\n  \"isProp\": true,\n  \"docString\": \"`G` is cover-lifting wrt the induced topology. \"}]\n",
    "prompt_cons": "/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (b e : ℕ), jacobiSym a (b ^ e) = jacobiSym a b ^ e :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- `G` is cover-preserving wrt the induced topology. -/\ntheorem ∀ {C : Type u_3} [inst : CategoryTheory.Category C] {D : Type u_4} [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\n  CategoryTheory.CoverPreserving (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If `a` is invertible and `a = b`, then `⅟a = ⅟b`. -/\ntheorem ∀ {α : Type u} [inst : Ring α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their sum. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c) :=\n\n/-- For an adjunction `F ⊣ G` with counit `ε`, the pair `(FGε_B, ε_FGB)` is reflexive. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\n  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F ⊣ G) (B : D),\n  CategoryTheory.IsReflexivePair (F.map (G.map (CategoryTheory.NatTrans.app adj.counit B)))\n    (CategoryTheory.NatTrans.app adj.counit (F.obj (G.obj B))) :=\n\n/-- If there exists an `a` such that `b = l a`, then `a = u b` is one such element. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : PartialOrder β] {l : α → β} {u : β → α},\n  GaloisConnection l u → ∀ (b : β), (∃ a, b = l a) ↔ b = l (u b) :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K :=\n\n/-- `G` is closed under inverses -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem ∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F) :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c :=\n\n/-- `G` is cover-lifting wrt the induced topology. -/\ntheorem ∀ {C : Type u_1} [inst : CategoryTheory.Category C] {D : Type u_3} [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\n  CategoryTheory.CoverLifting (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G :=\n\n/-- Deduce that $|a b|=|b a|$ for all $a, b \\in G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) "
    ]
  },
  {
    "docString": "Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A → Algebra.IsIntegral A B → Algebra.IsIntegral R B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand B is an A-algebra all of whose elements are integral over A,\\nthen all elements of B are integral over R.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\\nare regular. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A],\\n  Algebra.IsAlgebraic R A ↔ Subalgebra.IsAlgebraic ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebra is algebraic if and only if it is algebraic as a subalgebra. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\\n  (∀ (r : R),\\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"}]\n",
    "prompt_cons": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand B is an A-algebra all of whose elements are integral over A,\nthen all elements of B are integral over R. -/\ntheorem ∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A → Algebra.IsIntegral A B → Algebra.IsIntegral R B :=\n\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\ntheorem ∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- An algebra is algebraic if and only if it is algebraic as a subalgebra. -/\ntheorem ∀ {R : Type u} {A : Type v} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A],\n  Algebra.IsAlgebraic R A ↔ Subalgebra.IsAlgebraic ⊤ :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\n  (∀ (r : R),\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian. -/\ntheorem",
    "choices": [
      "∀ {A : Type u_1} {B : Type u_2} [inst : AddGroup A] [inst_1 : AddGroup B],\n  AddCommGroup (A × B) ↔ AddCommGroup A ∧ AddCommGroup B "
    ]
  },
  {
    "docString": "Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : ℕ → Set α},\\n  ∑' (i : ℕ), ↑↑μ (s i) ≠ ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"One direction of the **Borel-Cantelli lemma**: if (sᵢ) is a sequence of sets such\\nthat `∑ μ sᵢ` is finite, then the limit superior of the `sᵢ` is a null set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {a : α} {p : α → Prop} {h : ¬a ∈ s},\\n  (∀ (x : α), x ∈ Finset.cons a s h → p x) → ∀ (x : α), x ∈ s → p x\",\n  \"isProp\": true,\n  \"docString\": \"Useful in proofs by induction. \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {p : Finset α → Prop} [inst : DecidableEq α] (S : Finset α),\\n  p ∅ → (∀ {a : α} {s : Finset α}, a ∈ S → s ⊆ S → ¬a ∈ s → p s → p (insert a s)) → p S\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a proposition about `S : Finset α`,\\nit suffices to prove it for the empty `Finset`,\\nand to show that if it holds for some `Finset α ⊆ S`,\\nthen it holds for the `Finset` obtained by inserting a new element of `S`.\\n\"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} [inst : MeasureTheory.IsProbabilityMeasure μ]\\n  {s : ℕ → Set Ω},\\n  (∀ (n : ℕ), MeasurableSet (s n)) →\\n    ProbabilityTheory.iIndepSet s → ∑' (n : ℕ), ↑↑μ (s n) = ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sₙ)` such that\\n`∑ n, μ sₙ = ∞`, `limsup sₙ` has measure 1. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {_m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ],\\n  MeasureTheory.SigmaFinite μ\",\n  \"isProp\": true,\n  \"docString\": \"Every finite measure is σ-finite. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G\",\n  \"isProp\": true,\n  \"docString\": \"The group exponent exists for any bounded torsion group. \"},\n {\"theorem\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t)\",\n  \"isProp\": true,\n  \"docString\": \"Finite product of finite sets is finite \"}]\n",
    "prompt_cons": "/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x ∈ H } :=\n\n/-- One direction of the **Borel-Cantelli lemma**: if (sᵢ) is a sequence of sets such\nthat `∑ μ sᵢ` is finite, then the limit superior of the `sᵢ` is a null set. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : ℕ → Set α},\n  ∑' (i : ℕ), ↑↑μ (s i) ≠ ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 0 :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a} :=\n\n/-- The subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0 :=\n\n/-- Useful in proofs by induction. -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {a : α} {p : α → Prop} {h : ¬a ∈ s},\n  (∀ (x : α), x ∈ Finset.cons a s h → p x) → ∀ (x : α), x ∈ s → p x :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- To prove a proposition about `S : Finset α`,\nit suffices to prove it for the empty `Finset`,\nand to show that if it holds for some `Finset α ⊆ S`,\nthen it holds for the `Finset` obtained by inserting a new element of `S`. -/\ntheorem ∀ {α : Type u_1} {p : Finset α → Prop} [inst : DecidableEq α] (S : Finset α),\n  p ∅ → (∀ {a : α} {s : Finset α}, a ∈ S → s ⊆ S → ¬a ∈ s → p s → p (insert a s)) → p S :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- **The second Borel-Cantelli lemma**: Given a sequence of independent sets `(sₙ)` such that\n`∑ n, μ sₙ = ∞`, `limsup sₙ` has measure 1. -/\ntheorem ∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} [inst : MeasureTheory.IsProbabilityMeasure μ]\n  {s : ℕ → Set Ω},\n  (∀ (n : ℕ), MeasurableSet (s n)) →\n    ProbabilityTheory.iIndepSet s → ∑' (n : ℕ), ↑↑μ (s n) = ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 1 :=\n\n/-- Every finite measure is σ-finite. -/\ntheorem ∀ {α : Type u_1} {_m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ],\n  MeasureTheory.SigmaFinite μ :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- The group exponent exists for any bounded torsion group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G],\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G :=\n\n/-- Finite product of finite sets is finite -/\ntheorem ∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t) :=\n\n/-- Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Infinite α], Infinite (Permutation α) "
    ]
  },
  {
    "docString": "Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$.",
    "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.continuants g n = ppred →\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\\n  ↑h (x / y) = ↑h x / ↑h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication commutes with direct sums. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"}]\n",
    "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.continuants g n = ppred →\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹ :=\n\n/-- Multiplication is commutative in a commutative semigroup. -/\ntheorem ∀ {α : Type u_1} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\n  ↑h (x / y) = ↑h x / ↑h y :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Scalar multiplication commutes with direct sums. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] {ι : Type v} [dec_ι : DecidableEq ι] {M : ι → Type w}\n  [inst_1 : (i : ι) → AddCommMonoid (M i)] [inst_2 : (i : ι) → Module R (M i)] (s : Finset ι) (c : R)\n  (x : (i : ↑↑s) → M ↑i), ↑(DirectSum.mk M s) (c • x) = c • ↑(DirectSum.mk M s) x :=\n\n/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$. -/\ntheorem",
    "choices": [
      "∀ {A : Type u_1} {B : Type u_2} [inst : Group A] [inst_1 : Group B],\n  MulEquiv (A × B) (B × A) "
    ]
  },
  {
    "docString": "Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `σ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformFun α G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {G : Type u_2} [inst : AddGroup G] [inst_1 : UniformSpace G] [inst_2 : UniformAddGroup G],\\n  UniformAddGroup (UniformFun α G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform additive group,\\nthen `α →ᵤ G` is a uniform additive group as well.\"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4}\\n  [inst_3 : (i : ι) → NormedAddCommGroup (G i)] [inst_4 : (i : ι) → InnerProductSpace 𝕜 (G i)]\\n  {V : (i : ι) → G i →ₗᵢ[𝕜] E} (self : IsHilbertSum 𝕜 G V),\\n  Function.Surjective ↑(OrthogonalFamily.linearIsometry (_ : OrthogonalFamily 𝕜 G V))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The isometry `lp G 2 → E` induced by the orthogonal family is surjective. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Group α], IsGroupHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity is a group homomorphism. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : AddMonoid A] {f g : ℤ →+ A}, ↑f 1 = ↑g 1 → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two additive monoid homomorphisms `f`, `g` from `ℤ` to an additive monoid are equal\\nif `f 1 = g 1`. \"},\n {\"theorem\":\n  \"∀ (A : Type u_1) [inst : NormedCommRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A], Function.Bijective ↑(WeakDual.gelfandTransform ℂ A)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Gelfand transform is bijective when the algebra is a C⋆-algebra over `ℂ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\\n  AddSubgroup.Characteristic H → ∀ (ϕ : A ≃+ A), AddSubgroup.comap (AddEquiv.toAddMonoidHom ϕ) H = H\",\n  \"isProp\": true,\n  \"docString\": \"`H` is fixed by all automorphisms \"}]\n",
    "prompt_cons": "/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- If two `σ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. -/\ntheorem ∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun α G) :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1 :=\n\n/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- If `G` is a uniform additive group,\nthen `α →ᵤ G` is a uniform additive group as well. -/\ntheorem ∀ {α : Type u_1} {G : Type u_2} [inst : AddGroup G] [inst_1 : UniformSpace G] [inst_2 : UniformAddGroup G],\n  UniformAddGroup (UniformFun α G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1) :=\n\n/-- The isometry `lp G 2 → E` induced by the orthogonal family is surjective. -/\ntheorem ∀ {ι : Type u_1} {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] [cplt : CompleteSpace E] {G : ι → Type u_4}\n  [inst_3 : (i : ι) → NormedAddCommGroup (G i)] [inst_4 : (i : ι) → InnerProductSpace 𝕜 (G i)]\n  {V : (i : ι) → G i →ₗᵢ[𝕜] E} (self : IsHilbertSum 𝕜 G V),\n  Function.Surjective ↑(OrthogonalFamily.linearIsometry (_ : OrthogonalFamily 𝕜 G V)) :=\n\n/-- The identity is a group homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Group α], IsGroupHom id :=\n\n/-- A group is finitely generated if and only if it is finitely generated as a monoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Group.FG G ↔ Monoid.FG G :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant μ :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s) :=\n\n/-- Two additive monoid homomorphisms `f`, `g` from `ℤ` to an additive monoid are equal\nif `f 1 = g 1`. -/\ntheorem ∀ {A : Type u_1} [inst : AddMonoid A] {f g : ℤ →+ A}, ↑f 1 = ↑g 1 → f = g :=\n\n/-- The Gelfand transform is bijective when the algebra is a C⋆-algebra over `ℂ`. -/\ntheorem ∀ (A : Type u_1) [inst : NormedCommRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A], Function.Bijective ↑(WeakDual.gelfandTransform ℂ A) :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f) :=\n\n/-- `H` is fixed by all automorphisms -/\ntheorem ∀ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\n  AddSubgroup.Characteristic H → ∀ (ϕ : A ≃+ A), AddSubgroup.comap (AddEquiv.toAddMonoidHom ϕ) H = H :=\n\n/-- Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {σ : Aut G},\n  (∀ (g : G), σ.to_fun g = g ↔ g = 1) → σ.to_fun ∘ σ.to_fun = id → ∀ (a b : G), a * b = b * a "
    ]
  },
  {
    "docString": "Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G), Subsingleton (G ⧸ H) → H = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an additive subgroup gives a singleton then the additive subgroup\\nis the whole additive group.\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R), 0 ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"An additive submonoid contains `0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\\n  ↑h (x / y) = ↑h x / ↑h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}\\n  (P : (α → E) → Prop),\\n  (∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → ↑↑μ s < ⊤ → P (Set.indicator s fun x => c)) →\\n    (∀ ⦃f g : α → E⦄,\\n        Disjoint (Function.support f) (Function.support g) →\\n          MeasureTheory.Integrable f → MeasureTheory.Integrable g → P f → P g → P (f + g)) →\\n      IsClosed {f | P ↑↑f} →\\n        (∀ ⦃f g : α → E⦄, f =ᶠ[MeasureTheory.Measure.ae μ] g → MeasureTheory.Integrable f → P f → P g) →\\n          ∀ ⦃f : α → E⦄, MeasureTheory.Integrable f → P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary integrable function in a normed group,\\nit suffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in the `L¹` space for which the property holds is closed.\\n* the property is closed under the almost-everywhere equal relation.\\n\\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\\na simple function with a multiple of a characteristic function and that the intersection\\nof their images is a subset of `{0}`).\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : AddMonoidWithOne R] [self : CharZero R], Function.Injective Nat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive monoid with one has characteristic zero if the canonical map `ℕ → R` is\\ninjective. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G ⧸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : AddGroup A] [self : IsSimpleAddGroup A] (H : AddSubgroup A),\\n  AddSubgroup.Normal H → H = ⊥ ∨ H = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal additive subgroup is either `⊥` or `⊤` \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M), ‖0‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"The quotient norm of `0` is `0`. \"}]\n",
    "prompt_cons": "/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem ∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤ :=\n\n/-- If the quotient by an additive subgroup gives a singleton then the additive subgroup\nis the whole additive group. -/\ntheorem ∀ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G), Subsingleton (G ⧸ H) → H = ⊤ :=\n\n/-- An additive submonoid contains `0`. -/\ntheorem ∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R), 0 ∈ self.carrier :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0 :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G) :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- A subgroup is closed under division. -/\ntheorem ∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H :=\n\n/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0 :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\n  ↑h (x / y) = ↑h x / ↑h y :=\n\n/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `L¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`). -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}\n  (P : (α → E) → Prop),\n  (∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → ↑↑μ s < ⊤ → P (Set.indicator s fun x => c)) →\n    (∀ ⦃f g : α → E⦄,\n        Disjoint (Function.support f) (Function.support g) →\n          MeasureTheory.Integrable f → MeasureTheory.Integrable g → P f → P g → P (f + g)) →\n      IsClosed {f | P ↑↑f} →\n        (∀ ⦃f g : α → E⦄, f =ᶠ[MeasureTheory.Measure.ae μ] g → MeasureTheory.Integrable f → P f → P g) →\n          ∀ ⦃f : α → E⦄, MeasureTheory.Integrable f → P f :=\n\n/-- An additive monoid with one has characteristic zero if the canonical map `ℕ → R` is\ninjective. -/\ntheorem ∀ {R : Type u_1} [inst : AddMonoidWithOne R] [self : CharZero R], Function.Injective Nat.cast :=\n\n/-- The additive subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G ⧸ H) :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1 :=\n\n/-- Any normal additive subgroup is either `⊥` or `⊤` -/\ntheorem ∀ {A : Type u_1} [inst : AddGroup A] [self : IsSimpleAddGroup A] (H : AddSubgroup A),\n  AddSubgroup.Normal H → H = ⊥ ∨ H = ⊤ :=\n\n/-- The quotient norm of `0` is `0`. -/\ntheorem ∀ {M : Type u_1} [inst : SeminormedAddCommGroup M] (S : AddSubgroup M), ‖0‖ = 0 :=\n\n/-- Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "∀ {H : AddSubgroup ℚ}, (∀ x : ℚ, x ≠ 0 → x⁻¹ ∈ H) → H = ⊥ ∨ H = ⊤ "
    ]
  },
  {
    "docString": "A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A word and its maximal reduction correspond to the same element of the free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (P : AddSubgroup G), AddSubgroup.FG P ↔ AddSubmonoid.FG P.toAddSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive subgroup is finitely generated if\\nand only if it is finitely generated as an additive submonoid.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S ≠ ⊥ → (¬∃ a, IsLeast {g | g ∈ S ∧ 0 < g} a) → Dense ↑S\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\\nelement, then `S` is dense `G`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeGroup.mk L₁ = FreeGroup.mk L₂ → FreeGroup.reduce L₁ = FreeGroup.reduce L₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends\\nan element of the free group to its maximal reduction is well-defined. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\\n      Nonempty\\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\\n  FreeAddGroup.mk L₁ = FreeAddGroup.mk L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two words correspond to the same element in the additive free group, then they\\nhave a common maximal reduction. This is the proof that the function that sends an element of the\\nfree group to its maximal reduction is well-defined.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1 :=\n\n/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0 :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- A word and its maximal reduction correspond to the same element of the free group. -/\ntheorem ∀ {α : Type u} {L : List (α × Bool)} [inst : DecidableEq α], FreeGroup.mk (FreeGroup.reduce L) = FreeGroup.mk L :=\n\n/-- An additive subgroup is finitely generated if\nand only if it is finitely generated as an additive submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (P : AddSubgroup G), AddSubgroup.FG P ↔ AddSubmonoid.FG P.toAddSubmonoid :=\n\n/-- A subgroup is closed under division. -/\ntheorem ∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k) :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\nelement, then `S` is dense `G`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S ≠ ⊥ → (¬∃ a, IsLeast {g | g ∈ S ∧ 0 < g} a) → Dense ↑S :=\n\n/-- If two words correspond to the same element in the free group, then they\nhave a common maximal reduction. This is the proof that the function that sends\nan element of the free group to its maximal reduction is well-defined. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeGroup.mk L₁ = FreeGroup.mk L₂ → FreeGroup.reduce L₁ = FreeGroup.reduce L₂ :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\n      Nonempty\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)] :=\n\n/-- If two words correspond to the same element in the additive free group, then they\nhave a common maximal reduction. This is the proof that the function that sends an element of the\nfree group to its maximal reduction is well-defined. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} [inst : DecidableEq α],\n  FreeAddGroup.mk L₁ = FreeAddGroup.mk L₂ → FreeAddGroup.reduce L₁ = FreeAddGroup.reduce L₂ :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H ≠ ⊤ → ∃ M, IsCoatom M ∧ H ≤ M "
    ]
  },
  {
    "docString": "Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\\n  Nat.card { x // x ∈ commutator G } ≤ Subgroup.cardCommutatorBound (Nat.card ↑(commutatorSet G))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\\ncommutators. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\ncommutators. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\n  Nat.card { x // x ∈ commutator G } ≤ Subgroup.cardCommutatorBound (Nat.card ↑(commutatorSet G)) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M :=\n\n/-- Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : IsCyclic G) (hn : Fintype.card G = n) (H : Subgroup G),\n  IsCoatom H ↔ ∃ p [_hp : Fact (Nat.Prime p)], p ∣ n ∧ H = Subgroup.closure {x ^ p} "
    ]
  },
  {
    "docString": "Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {P Q : Subgroup M},\\n  MulAction.fixedPoints { x // x ∈ P ⊔ Q } α =\\n    MulAction.fixedPoints { x // x ∈ P } α ∩ MulAction.fixedPoints { x // x ∈ Q } α\",\n  \"isProp\": true,\n  \"docString\": \"Fixed points of sup of subgroups is intersection \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N} {s : Set M},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemigroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ (M : Type u_2) (α : Type u_1) [inst : Group M] [inst_1 : MulAction M α] {s t : Set α},\\n  fixingSubgroup M (s ∪ t) = fixingSubgroup M s ⊓ fixingSubgroup M t\",\n  \"isProp\": true,\n  \"docString\": \"Fixing subgroup of union is intersection \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"}]\n",
    "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s) :=\n\n/-- Fixed points of sup of subgroups is intersection -/\ntheorem ∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {P Q : Subgroup M},\n  MulAction.fixedPoints { x // x ∈ P ⊔ Q } α =\n    MulAction.fixedPoints { x // x ∈ P } α ∩ MulAction.fixedPoints { x // x ∈ Q } α :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥ :=\n\n/-- If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. -/\ntheorem ∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N} {s : Set M},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemigroup.closure s) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Fixing subgroup of union is intersection -/\ntheorem ∀ (M : Type u_2) (α : Type u_1) [inst : Group M] [inst_1 : MulAction M α] {s t : Set α},\n  fixingSubgroup M (s ∪ t) = fixingSubgroup M s ⊓ fixingSubgroup M t :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G) [inst_1 : Subgroup.Normal H] [inst_2 : Subgroup.Normal K],\n  Subgroup.Normal (H ⊓ K) "
    ]
  },
  {
    "docString": "Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {P Q : Subgroup M},\\n  MulAction.fixedPoints { x // x ∈ P ⊔ Q } α =\\n    MulAction.fixedPoints { x // x ∈ P } α ∩ MulAction.fixedPoints { x // x ∈ Q } α\",\n  \"isProp\": true,\n  \"docString\": \"Fixed points of sup of subgroups is intersection \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N} {s : Set M},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemigroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s) :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Fixed points of sup of subgroups is intersection -/\ntheorem ∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {P Q : Subgroup M},\n  MulAction.fixedPoints { x // x ∈ P ⊔ Q } α =\n    MulAction.fixedPoints { x // x ∈ P } α ∩ MulAction.fixedPoints { x // x ∈ Q } α :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- If two mul homomorphisms are equal on a set, then they are equal on its subsemigroup closure. -/\ntheorem ∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] {f g : M →ₙ* N} {s : Set M},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemigroup.closure s) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s) :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G) [inst_1 : Fintype { x // x ∈ H }] [inst_2 : Fintype { x // x ∈ K }],\n  Nat.coprime (Fintype.card { x // x ∈ H }) (Fintype.card { x // x ∈ K }) → H ⊓ K = ⊥ "
    ]
  },
  {
    "docString": "Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : ℤ), ↑(legendreSym p a) = ↑a ^ (p / 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have the congruence `legendreSym p a ≡ a ^ (p / 2) mod p`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\\n  p ≠ 2 →\\n    ↑a ≠ 0 →\\n      legendreSym p a =\\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (↑a * ↑x)) (Finset.Ico 1 (Nat.succ (p / 2))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\\nthan `p/2` such that `(a * x) % p > p / 2`. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)],\\n  p ≠ 2 → ∀ (a : ℤ), ↑(Finset.card (Set.toFinset {x | x ^ 2 = ↑a})) = legendreSym p a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of square roots of `a` modulo `p` is determined by the Legendre symbol. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : Fintype α] (s : AddSubgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\\nambient additive group.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"}]\n",
    "prompt_cons": "/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem ∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p :=\n\n/-- We have the congruence `legendreSym p a ≡ a ^ (p / 2) mod p`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : ℤ), ↑(legendreSym p a) = ↑a ^ (p / 2) :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0 :=\n\n/-- Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\nthan `p/2` such that `(a * x) % p > p / 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\n  p ≠ 2 →\n    ↑a ≠ 0 →\n      legendreSym p a =\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (↑a * ↑x)) (Finset.Ico 1 (Nat.succ (p / 2)))) :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)],\n  p ≠ 2 → ∀ (a : ℤ), ↑(Finset.card (Set.toFinset {x | x ^ 2 = ↑a})) = legendreSym p a + 1 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0 :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- **Lagrange's Theorem**: The order of an additive subgroup divides the order of its\nambient additive group. -/\ntheorem ∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : Fintype α] (s : AddSubgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p ≠ 1`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1 :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] "
    ]
  },
  {
    "docString": "Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b * a ∈ H) (b ∈ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) ⊔ N = G`. \"}]\n",
    "prompt_cons": "/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b * a ∈ H) (b ∈ H) :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤ :=\n\n/-- Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G} [inst_2 : Subgroup.Normal H],\n  Subgroup.index H = p → ∀ (K : Subgroup G), K ≤ H ∨ (H * K = ⊤ ∧ Subgroup.index (K ⊓ H) = p) "
    ]
  },
  {
    "docString": "Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {a : α} {p : α → Prop} {h : ¬a ∈ s},\\n  (∀ (x : α), x ∈ Finset.cons a s h → p x) → ∀ (x : α), x ∈ s → p x\",\n  \"isProp\": true,\n  \"docString\": \"Useful in proofs by induction. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\\n  Nat.card { x // x ∈ commutator G } ≤ Subgroup.cardCommutatorBound (Nat.card ↑(commutatorSet G))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\\ncommutators. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c → Prop} (q : Con.Quotient c), (∀ (x : M), C ↑x) → C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about the elements of a quotient by a\\ncongruence relation. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : Fintype α] (s : AddSubgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\\nambient additive group.\"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"}]\n",
    "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- Useful in proofs by induction. -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {a : α} {p : α → Prop} {h : ¬a ∈ s},\n  (∀ (x : α), x ∈ Finset.cons a s h → p x) → ∀ (x : α), x ∈ s → p x :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\ncommutators. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\n  Nat.card { x // x ∈ commutator G } ≤ Subgroup.cardCommutatorBound (Nat.card ↑(commutatorSet G)) :=\n\n/-- The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c → Prop} (q : Con.Quotient c), (∀ (x : M), C ↑x) → C q :=\n\n/-- **Lagrange's Theorem**: The order of an additive subgroup divides the order of its\nambient additive group. -/\ntheorem ∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : Fintype α] (s : AddSubgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- Elements of finite order are of finite order in submonoids. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] (H : AddSubmonoid G) (x : { x // x ∈ H }), IsOfFinAddOrder x ↔ IsOfFinAddOrder ↑x :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card { x // x ∈ H } = n "
    ]
  },
  {
    "docString": "Prove that quotient groups of a solvable group are solvable.",
    "prompts": "[{\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\\n  ↑h (x / y) = ↑h x / ↑h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G ⧸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : ContinuousConstSMul Γ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group action is an open\\nquotient. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ↑f →\\n    N = MonoidHom.ker f → Monoid.IsTorsion { x // x ∈ N } → (Monoid.IsTorsion H ↔ Monoid.IsTorsion G)\",\n  \"isProp\": true,\n  \"docString\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\\n  [inst_3 : ContinuousConstVAdd Γ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group\\naction is an open quotient. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] {Γ : Subgroup G}\\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G ⧸ Γ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a second countable topological group by a subgroup is second countable. \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x ∈ ↑(LieAlgebra.radical R L) }\",\n  \"isProp\": true,\n  \"docString\": \"The radical of a Noetherian Lie algebra is solvable. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c → Prop} (q : Con.Quotient c), (∀ (x : M), C ↑x) → C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about the elements of a quotient by a\\ncongruence relation. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSolvable G], ∃ n, derivedSeries G n = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group `G` is solvable if its derived series is eventually trivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  Function.Surjective ↑f →\\n    N = AddMonoidHom.ker f → AddMonoid.IsTorsion { x // x ∈ N } → (AddMonoid.IsTorsion H ↔ AddMonoid.IsTorsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a quotient is additively torsion iff the group is torsion.\"}]\n",
    "prompt_cons": "/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\n  ↑h (x / y) = ↑h x / ↑h y :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G ⧸ H) :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem ∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I) :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. -/\ntheorem ∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\n  [inst_3 : ContinuousConstSMul Γ T], IsOpenMap Quotient.mk' :=\n\n/-- Quotienting a group by its additive torsion subgroup yields an additive torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G) :=\n\n/-- The image of a quotient is torsion iff the group is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\n  Function.Surjective ↑f →\n    N = MonoidHom.ker f → Monoid.IsTorsion { x // x ∈ N } → (Monoid.IsTorsion H ↔ Monoid.IsTorsion G) :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. -/\ntheorem ∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\n  [inst_3 : ContinuousConstVAdd Γ T], IsOpenMap Quotient.mk' :=\n\n/-- The quotient of a second countable topological group by a subgroup is second countable. -/\ntheorem ∀ {G : Type w} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousMul G] {Γ : Subgroup G}\n  [inst_3 : TopologicalSpace.SecondCountableTopology G], TopologicalSpace.SecondCountableTopology (G ⧸ Γ) :=\n\n/-- The radical of a Noetherian Lie algebra is solvable. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x ∈ ↑(LieAlgebra.radical R L) } :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c → Prop} (q : Con.Quotient c), (∀ (x : M), C ↑x) → C q :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- A group `G` is solvable if its derived series is eventually trivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [self : IsSolvable G], ∃ n, derivedSeries G n = ⊥ :=\n\n/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem ∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤ :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- The image of a quotient is additively torsion iff the group is torsion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\n  Function.Surjective ↑f →\n    N = AddMonoidHom.ker f → AddMonoid.IsTorsion { x // x ∈ N } → (AddMonoid.IsTorsion H ↔ AddMonoid.IsTorsion G) :=\n\n/-- Prove that quotient groups of a solvable group are solvable. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) "
    ]
  },
  {
    "docString": "Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b * a ∈ H) (b ∈ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\\n  Nat.card { x // x ∈ commutator G } ≤ Subgroup.cardCommutatorBound (Nat.card ↑(commutatorSet G))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\\ncommutators. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- The subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0 :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x ∈ H } :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H :=\n\n/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b * a ∈ H) (b ∈ H) :=\n\n/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of\ncommutators. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\n  Nat.card { x // x ∈ commutator G } ≤ Subgroup.cardCommutatorBound (Nat.card ↑(commutatorSet G)) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- The additive subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0 :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.FiniteIndex H],\n  ∃ K : Subgroup G, K ≤ H ∧ Subgroup.index K ∣ Nat.factorial (Subgroup.index H) "
    ]
  },
  {
    "docString": "Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_2} [inst : Group G],\\n  IsPGroup p G →\\n    ∀ [hp : Fact (Nat.Prime p)] (α : Type u_1) [inst_1 : MulAction G α] [inst_2 : Fintype α]\\n      [inst_3 : Fintype ↑(MulAction.fixedPoints G α)],\\n      Fintype.card α ≡ Fintype.card ↑(MulAction.fixedPoints G α) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a `p`-group acting on a finite set `α`, then the number of fixed points\\nof the action is congruent mod `p` to the cardinality of `α` \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) ⊔ N = G`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n",
    "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- If `G` is a `p`-group acting on a finite set `α`, then the number of fixed points\nof the action is congruent mod `p` to the cardinality of `α` -/\ntheorem ∀ {p : ℕ} {G : Type u_2} [inst : Group G],\n  IsPGroup p G →\n    ∀ [hp : Fact (Nat.Prime p)] (α : Type u_1) [inst_1 : MulAction G α] [inst_2 : Fintype α]\n      [inst_3 : Fintype ↑(MulAction.fixedPoints G α)],\n      Fintype.card α ≡ Fintype.card ↑(MulAction.fixedPoints G α) [MOD p] :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤ :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} {α : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ α →\n    ∀ (H : Subgroup G), Subgroup.index H = p → Subgroup.Normal H "
    ]
  },
  {
    "docString": "Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`- and `q`-primary components are disjoint for `p ≠ q`. \"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [hα : Archimedean α] {p : α} (hp : 0 < p) {a b c : α},\\n  toIcoMod hp c a = toIcoMod hp c b ↔ a ≡ b [PMOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddCommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\\n  p ≠ p' → Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\": \"The `p`- and `q`-primary components are disjoint for `p ≠ q`.\"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"}]\n",
    "prompt_cons": "/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- If `a` and `b` fall within the same cycle WRT `c`, then they are congruent modulo `p`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [hα : Archimedean α] {p : α} (hp : 0 < p) {a b c : α},\n  toIcoMod hp c a = toIcoMod hp c b ↔ a ≡ b [PMOD p] :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\ntheorem ∀ {G : Type u_1} [inst : AddCommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\n  p ≠ p' → Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p') :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem ∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem ∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p :=\n\n/-- Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : AddCommGroup G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G "
    ]
  },
  {
    "docString": "Prove that there exists a normal subgroup that is not characteristic.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a nonzero element.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\\n  p ≠ 0 → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `⊥` or `⊤` \"},\n {\"theorem\":\n  \"∀ {k : Type u} [inst : Field k] {G : GroupCat} [inst_1 : IsAlgClosed k] [inst_2 : Fintype ↑G]\\n  [inst_3 : Invertible ↑(Fintype.card ↑G)] (V W : FdRep k ↑G) [inst_4 : CategoryTheory.Simple V]\\n  [inst_5 : CategoryTheory.Simple W],\\n  (⅟↑(Fintype.card ↑G) • Finset.sum Finset.univ fun g => FdRep.character V g * FdRep.character W g⁻¹) =\\n    if Nonempty (V ≅ W) then 1 else 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Orthogonality of characters for irreducible representations of finite group over an\\nalgebraically closed field whose characteristic doesn't divide the order of the group. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\\n  Group.nilpotencyClass G = Group.nilpotencyClass (G ⧸ Subgroup.center G) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The nilpotency class of a non-trivial group is one more than its quotient by the center \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"}]\n",
    "prompt_cons": "/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1 :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- A subgroup is either the trivial subgroup or contains a nonzero element. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 0 :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\n  p ≠ 0 → Nat.Prime p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Any normal subgroup is either `⊥` or `⊤` -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤ :=\n\n/-- Orthogonality of characters for irreducible representations of finite group over an\nalgebraically closed field whose characteristic doesn't divide the order of the group. -/\ntheorem ∀ {k : Type u} [inst : Field k] {G : GroupCat} [inst_1 : IsAlgClosed k] [inst_2 : Fintype ↑G]\n  [inst_3 : Invertible ↑(Fintype.card ↑G)] (V W : FdRep k ↑G) [inst_4 : CategoryTheory.Simple V]\n  [inst_5 : CategoryTheory.Simple W],\n  (⅟↑(Fintype.card ↑G) • Finset.sum Finset.univ fun g => FdRep.character V g * FdRep.character W g⁻¹) =\n    if Nonempty (V ≅ W) then 1 else 0 :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\n  Group.nilpotencyClass G = Group.nilpotencyClass (G ⧸ Subgroup.center G) + 1 :=\n\n/-- A subgroup of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x ∈ H } :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K) :=\n\n/-- Prove that there exists a normal subgroup that is not characteristic. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ H : Subgroup G, Subgroup.Normal H ∧ ¬Subgroup.Characteristic H "
    ]
  },
  {
    "docString": "Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (right) complement of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {L : Type u_2} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  {H K : LieSubalgebra R L} (h₁ : H ≤ K),\\n  K ≤ LieSubalgebra.normalizer H → ∃ I, ↑R { x // x ∈ K } I = LieSubalgebra.ofLe h₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"A Lie subalgebra `H` is an ideal of any Lie subalgebra `K` containing `H` and contained in the\\nnormalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}\\n  (P : (α → E) → Prop),\\n  (∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → ↑↑μ s < ⊤ → P (Set.indicator s fun x => c)) →\\n    (∀ ⦃f g : α → E⦄,\\n        Disjoint (Function.support f) (Function.support g) →\\n          MeasureTheory.Integrable f → MeasureTheory.Integrable g → P f → P g → P (f + g)) →\\n      IsClosed {f | P ↑↑f} →\\n        (∀ ⦃f g : α → E⦄, f =ᶠ[MeasureTheory.Measure.ae μ] g → MeasureTheory.Integrable f → P f → P g) →\\n          ∀ ⦃f : α → E⦄, MeasureTheory.Integrable f → P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary integrable function in a normed group,\\nit suffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in the `L¹` space for which the property holds is closed.\\n* the property is closed under the almost-everywhere equal relation.\\n\\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\\na simple function with a multiple of a characteristic function and that the intersection\\nof their images is a subset of `{0}`).\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} (K : Type u_2) [inst : CommRing R] [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] {P : ClassGroup R → Prop},\\n  (∀ (I : (FractionalIdeal (nonZeroDivisors R) K)ˣ), P (↑ClassGroup.mk I)) → ∀ (x : ClassGroup R), P x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Induction principle for the class group: to show something holds for all `x : ClassGroup R`,\\nwe can choose a fraction field `K` and show it holds for the equivalence class of each\\n`I : FractionalIdeal R⁰ K`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) ⊔ N = G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (right) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N],\n  Nat.coprime (Nat.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' N H :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- A Lie subalgebra `H` is an ideal of any Lie subalgebra `K` containing `H` and contained in the\nnormalizer of `H`. -/\ntheorem ∀ {R : Type u_1} {L : Type u_2} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  {H K : LieSubalgebra R L} (h₁ : H ≤ K),\n  K ≤ LieSubalgebra.normalizer H → ∃ I, ↑R { x // x ∈ K } I = LieSubalgebra.ofLe h₁ :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `L¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`). -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}\n  (P : (α → E) → Prop),\n  (∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → ↑↑μ s < ⊤ → P (Set.indicator s fun x => c)) →\n    (∀ ⦃f g : α → E⦄,\n        Disjoint (Function.support f) (Function.support g) →\n          MeasureTheory.Integrable f → MeasureTheory.Integrable g → P f → P g → P (f + g)) →\n      IsClosed {f | P ↑↑f} →\n        (∀ ⦃f g : α → E⦄, f =ᶠ[MeasureTheory.Measure.ae μ] g → MeasureTheory.Integrable f → P f → P g) →\n          ∀ ⦃f : α → E⦄, MeasureTheory.Integrable f → P f :=\n\n/-- Induction principle for the class group: to show something holds for all `x : ClassGroup R`,\nwe can choose a fraction field `K` and show it holds for the equivalence class of each\n`I : FractionalIdeal R⁰ K`. -/\ntheorem ∀ {R : Type u_1} (K : Type u_2) [inst : CommRing R] [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] {P : ClassGroup R → Prop},\n  (∀ (I : (FractionalIdeal (nonZeroDivisors R) K)ˣ), P (↑ClassGroup.mk I)) → ∀ (x : ClassGroup R), P x :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤ :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsCharSubgroup H K → Subgroup.Normal K → Subgroup.Normal H "
    ]
  },
  {
    "docString": "Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"}]\n",
    "prompt_cons": "/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A p-group is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t :=\n\n/-- Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 56 → ∃ p, Fact (Nat.Prime p) ∧ ∃ P : Sylow p G, IsNormalSubgroup ↑P "
    ]
  },
  {
    "docString": "Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A p-group is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 → ∃ p, Fact (Nat.Prime p) ∧ ∃ P : Sylow p G, IsNormalSubgroup (Subgroup.normalizer P) "
    ]
  },
  {
    "docString": "Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\\n      Nonempty\\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 ∈ alternatingGroup (Fin 5)) }} =\\n  ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\\n\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := finRotate 5, property := (_ : finRotate (bit1 2) ∈ alternatingGroup (Fin (bit1 2))) }} =\\n  ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any 5-cycle within $A_5$ is the whole group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) ⊔ N = G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `⊥` or `⊤` \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\n      Nonempty\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 ∈ alternatingGroup (Fin 5)) }} =\n  ⊤ :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\nused to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := finRotate 5, property := (_ : finRotate (bit1 2) ∈ alternatingGroup (Fin (bit1 2))) }} =\n  ⊤ :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤ :=\n\n/-- Any normal subgroup is either `⊥` or `⊤` -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤ :=\n\n/-- Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (N5 : Sylow 5 G), Subgroup.Normal ↑N5) ∧ (∃ (N7 : Sylow 7 G), Subgroup.Normal ↑N7) "
    ]
  },
  {
    "docString": "Prove that if $|G|=6545$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), Set.Nontrivial (f '' s) → Set.Nontrivial s\",\n  \"isProp\": true,\n  \"docString\": \"If the image of a set is nontrivial, the set is nontrivial. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → -1 ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (χ : MulChar R R'),\\n  MulChar.IsNontrivial χ ↔ χ ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A multiplicative character is nontrivial iff it is not the trivial character. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.IsAcyclic G\",\n  \"isProp\": true,\n  \"docString\": \"Graph is acyclic. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\":\n  \"∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between three points is `π`, the first two points are not equal. \"},\n {\"theorem\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {D : Type u_3} [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\\n  CategoryTheory.CoverLifting (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G\",\n  \"isProp\": true,\n  \"docString\": \"`G` is cover-lifting wrt the induced topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {s : Set β},\\n  Set.Nontrivial s → ∀ {f : α → β}, Function.Surjective f → Set.Nontrivial (f ⁻¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a nontrivial set under a surjective map is nontrivial. \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), Set.Nontrivial (f '' s) → Set.Nontrivial s :=\n\n/-- Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → -1 ≠ 1 :=\n\n/-- A multiplicative character is nontrivial iff it is not the trivial character. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (χ : MulChar R R'),\n  MulChar.IsNontrivial χ ↔ χ ≠ 1 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- Graph is acyclic. -/\ntheorem ∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.IsAcyclic G :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a :=\n\n/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem ∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- If the angle between three points is `π`, the first two points are not equal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₂ :=\n\n/-- `G` is cover-lifting wrt the induced topology. -/\ntheorem ∀ {C : Type u_1} [inst : CategoryTheory.Category C] {D : Type u_3} [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\n  CategoryTheory.CoverLifting (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G :=\n\n/-- The preimage of a nontrivial set under a surjective map is nontrivial. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {s : Set β},\n  Set.Nontrivial s → ∀ {f : α → β}, Function.Surjective f → Set.Nontrivial (f ⁻¹' s) :=\n\n/-- Prove that if $|G|=6545$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 6545 → ¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that if $|G|=2907$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {R₁ : Type u_3} {R₂ : Type u_4} (M₁ : Type u_1) (M₂ : Type u_5) [inst : CommSemiring R]\\n  [inst_1 : CommSemiring R₁] [inst_2 : AddCommMonoid M₁] [inst_3 : Module R₁ M₁] [inst_4 : CommSemiring R₂]\\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₂ M₂] (I₁ : R₁ →+* R) (I₂ : R₂ →+* R) [inst_7 : Nontrivial M₁],\\n  ¬LinearMap.SeparatingLeft 0\",\n  \"isProp\": true,\n  \"docString\": \"In a non-trivial module, zero is not non-degenerate. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (χ : MulChar R R'),\\n  MulChar.IsNontrivial χ ↔ χ ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A multiplicative character is nontrivial iff it is not the trivial character. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), Set.Nontrivial (f '' s) → Set.Nontrivial s\",\n  \"isProp\": true,\n  \"docString\": \"If the image of a set is nontrivial, the set is nontrivial. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M],\\n  ¬IsSMulRegular M 0 ↔ Nontrivial M\",\n  \"isProp\": true,\n  \"docString\": \"The `0` element is not `M`-regular, on a non-trivial module. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.IsAcyclic G\",\n  \"isProp\": true,\n  \"docString\": \"Graph is acyclic. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem ∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- In a non-trivial module, zero is not non-degenerate. -/\ntheorem ∀ {R : Type u_2} {R₁ : Type u_3} {R₂ : Type u_4} (M₁ : Type u_1) (M₂ : Type u_5) [inst : CommSemiring R]\n  [inst_1 : CommSemiring R₁] [inst_2 : AddCommMonoid M₁] [inst_3 : Module R₁ M₁] [inst_4 : CommSemiring R₂]\n  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₂ M₂] (I₁ : R₁ →+* R) (I₂ : R₂ →+* R) [inst_7 : Nontrivial M₁],\n  ¬LinearMap.SeparatingLeft 0 :=\n\n/-- A multiplicative character is nontrivial iff it is not the trivial character. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (χ : MulChar R R'),\n  MulChar.IsNontrivial χ ↔ χ ≠ 1 :=\n\n/-- If the image of a set is nontrivial, the set is nontrivial. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s : Set α), Set.Nontrivial (f '' s) → Set.Nontrivial s :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem ∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- The `0` element is not `M`-regular, on a non-trivial module. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : MonoidWithZero R] [inst_1 : Zero M] [inst_2 : MulActionWithZero R M],\n  ¬IsSMulRegular M 0 ↔ Nontrivial M :=\n\n/-- Graph is acyclic. -/\ntheorem ∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.IsAcyclic G :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- Prove that if $|G|=2907$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 → ¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that if $|G|=462$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.IsAcyclic G\",\n  \"isProp\": true,\n  \"docString\": \"Graph is acyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s →\\n    ∀ (f : G → ENNReal), Measurable f → ↑↑μ s * ∫⁻ (y : G), f y ∂ν = ∫⁻ (x : G), ↑↑ν ((fun z => z * x) ⁻¹' s) * f x⁻¹ ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"This is the computation performed in the proof of [Halmos, §60 Th. A]. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\\n  [inst : T2Space α], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible T₂ space. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {D : Type u_3} [inst_1 : CategoryTheory.Category D]\\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\\n  CategoryTheory.CoverLifting (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G\",\n  \"isProp\": true,\n  \"docString\": \"`G` is cover-lifting wrt the induced topology. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → -1 ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K} (b c : K),\\n  Int.fract a ≠ 0 → (↑⌊a⌋ * b + c) / Int.fract a + b = (b * a + c) / Int.fract a\",\n  \"isProp\": true,\n  \"docString\": \"Just a computational lemma we need for the next main proof. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Semiring R₃]\\n  {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [inst_3 : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]\\n  [inst_4 : RingHomSurjective σ₁₂] [inst_5 : RingHomSurjective σ₂₃], RingHomSurjective σ₁₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"This cannot be an instance as there is no way to infer `σ₁₂` and `σ₂₃`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- Graph is acyclic. -/\ntheorem ∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.IsAcyclic G :=\n\n/-- This is the computation performed in the proof of [Halmos, §60 Th. A]. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\n  MeasurableSet s →\n    ∀ (f : G → ENNReal), Measurable f → ↑↑μ s * ∫⁻ (y : G), f y ∂ν = ∫⁻ (x : G), ↑↑ν ((fun z => z * x) ⁻¹' s) * f x⁻¹ ∂μ :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\n  [inst : T2Space α], False :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- `G` is cover-lifting wrt the induced topology. -/\ntheorem ∀ {C : Type u_1} [inst : CategoryTheory.Category C] {D : Type u_3} [inst_1 : CategoryTheory.Category D]\n  {G : CategoryTheory.Functor C D} {K : CategoryTheory.GrothendieckTopology D} [inst_2 : CategoryTheory.Full G]\n  [inst_3 : CategoryTheory.Faithful G] (Hld : CategoryTheory.LocallyCoverDense K G),\n  CategoryTheory.CoverLifting (CategoryTheory.LocallyCoverDense.inducedTopology Hld) K G :=\n\n/-- Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → -1 ≠ 1 :=\n\n/-- Just a computational lemma we need for the next main proof. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {a : K} (b c : K),\n  Int.fract a ≠ 0 → (↑⌊a⌋ * b + c) / Int.fract a + b = (b * a + c) / Int.fract a :=\n\n/-- This cannot be an instance as there is no way to infer `σ₁₂` and `σ₂₃`. -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} {R₃ : Type u_3} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Semiring R₃]\n  {σ₁₂ : R₁ →+* R₂} {σ₂₃ : R₂ →+* R₃} {σ₁₃ : R₁ →+* R₃} [inst_3 : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃]\n  [inst_4 : RingHomSurjective σ₁₂] [inst_5 : RingHomSurjective σ₂₃], RingHomSurjective σ₁₃ :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- Prove that if $|G|=462$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 462 → ¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\\nof `N`, then `N_G(P) ⊔ N = G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- **Frattini's Argument**: If `N` is a normal subgroup of `G`, and if `P` is a Sylow `p`-subgroup\nof `N`, then `N_G(P) ⊔ N = G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  [inst_3 : Finite (Sylow p { x // x ∈ N })] (P : Sylow p G), ↑P ≤ N → Subgroup.normalizer ↑P ⊔ N = ⊤ :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Sylow p G} [inst_1 : Subgroup.Normal (↑P)] (H : Subgroup G),\n  ∃! Q : Sylow p { x // x ∈ H }, ↑Q = ↑P ⊓ H "
    ]
  },
  {
    "docString": "Prove that if $u$ is a unit in $R$ then so is $-u$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {n : ℕ} (u : Rˣ),\\n  IsUnit ↑n → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C ↑u)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `IsUnit n` in a `CommRing R`, then `X ^ n - u` is separable for any unit `u`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (u : Rˣ), ↑u < 0 → ∀ (v : Module.Ray R M), u • v = -v\",\n  \"isProp\": true,\n  \"docString\": \"Scaling by a negative unit is negation. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : AddMonoid M] {a : AddUnits M} {x y : M}, AddSemiconjBy (↑a) x y → AddSemiconjBy (↑(-a)) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\\n`x`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\\n  {L : CategoryTheory.Functor C D} {R : CategoryTheory.Functor D C} (h : L ⊣ R) {X : D}\\n  [inst_2 : CategoryTheory.IsIso (CategoryTheory.NatTrans.app h.counit X)],\\n  CategoryTheory.inv (R.map (CategoryTheory.NatTrans.app h.counit X)) = CategoryTheory.NatTrans.app h.unit (R.obj X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the counit of an adjunction is an isomorphism, then its inverse on the image of R is given\\nby R whiskered with the unit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonAssocRing α] [inst_2 : ContinuousMul α], ContinuousNeg α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\\nis just multiplication with `-1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : AddMonoid M] {a : M} {x y : AddUnits M}, AddSemiconjBy a ↑x ↑y → AddSemiconjBy a ↑(-x) ↑(-y)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\\nsemiconjugates `-x` to `-y`.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {a : Mˣ} {x y : M}, SemiconjBy (↑a) x y → SemiconjBy (↑a⁻¹) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. \"},\n {\"theorem\":\n  \"∀ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a b : B} (f : a ⟶ b),\\n  CategoryTheory.Bicategory.rightUnitor f =\\n    CategoryTheory.eqToIso (_ : CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b) = f)\",\n  \"isProp\": true,\n  \"docString\": \"The right unitors are given by equalities \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {a : M} {x y : Mˣ}, SemiconjBy a ↑x ↑y → SemiconjBy a ↑x⁻¹ ↑y⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `x⁻¹` to `y⁻¹`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsAddLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under addition. \"},\n {\"theorem\":\n  \"∀ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a b : B} (f : a ⟶ b),\\n  CategoryTheory.Bicategory.leftUnitor f =\\n    CategoryTheory.eqToIso (_ : CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id a) f = f)\",\n  \"isProp\": true,\n  \"docString\": \"The left unitors are given by equalities \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (s : MeasureTheory.SignedMeasure α) (μ : MeasureTheory.Measure α)\\n  [inst : MeasureTheory.SigmaFinite μ],\\n  MeasureTheory.VectorMeasure.AbsolutelyContinuous s (MeasureTheory.Measure.toENNRealVectorMeasure μ) ↔\\n    MeasureTheory.Measure.withDensityᵥ μ (MeasureTheory.SignedMeasure.rnDeriv s μ) = s\",\n  \"isProp\": true,\n  \"docString\": \"The Radon-Nikodym theorem for signed measures. \"},\n {\"theorem\":\n  \"∀ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : Rˣ), u⁻¹ = u ↔ u = 1 ∨ u = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\\none's additive inverse. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (a : M), IsUnit (↑u * a) ↔ IsUnit a\",\n  \"isProp\": true,\n  \"docString\":\n  \"Multiplication by a `u : Mˣ` on the left doesn't affect `IsUnit`. \"}]\n",
    "prompt_cons": "/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b :=\n\n/-- If `IsUnit n` in a `CommRing R`, then `X ^ n - u` is separable for any unit `u`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {n : ℕ} (u : Rˣ),\n  IsUnit ↑n → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C ↑u) :=\n\n/-- Scaling by a negative unit is negation. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (u : Rˣ), ↑u < 0 → ∀ (v : Module.Ray R M), u • v = -v :=\n\n/-- If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`. -/\ntheorem ∀ {M : Type u_1} [inst : AddMonoid M] {a : AddUnits M} {x y : M}, AddSemiconjBy (↑a) x y → AddSemiconjBy (↑(-a)) y x :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If the counit of an adjunction is an isomorphism, then its inverse on the image of R is given\nby R whiskered with the unit. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\n  {L : CategoryTheory.Functor C D} {R : CategoryTheory.Functor D C} (h : L ⊣ R) {X : D}\n  [inst_2 : CategoryTheory.IsIso (CategoryTheory.NatTrans.app h.counit X)],\n  CategoryTheory.inv (R.map (CategoryTheory.NatTrans.app h.counit X)) = CategoryTheory.NatTrans.app h.unit (R.obj X) :=\n\n/-- If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\nis just multiplication with `-1`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonAssocRing α] [inst_2 : ContinuousMul α], ContinuousNeg α :=\n\n/-- Proof of right inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P :=\n\n/-- If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`. -/\ntheorem ∀ {M : Type u_1} [inst : AddMonoid M] {a : M} {x y : AddUnits M}, AddSemiconjBy a ↑x ↑y → AddSemiconjBy a ↑(-x) ↑(-y) :=\n\n/-- If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {a : Mˣ} {x y : M}, SemiconjBy (↑a) x y → SemiconjBy (↑a⁻¹) y x :=\n\n/-- The right unitors are given by equalities -/\ntheorem ∀ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a b : B} (f : a ⟶ b),\n  CategoryTheory.Bicategory.rightUnitor f =\n    CategoryTheory.eqToIso (_ : CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id b) = f) :=\n\n/-- If `a` semiconjugates a unit `x` to a unit `y`, then it semiconjugates `x⁻¹` to `y⁻¹`. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {a : M} {x y : Mˣ}, SemiconjBy a ↑x ↑y → SemiconjBy a ↑x⁻¹ ↑y⁻¹ :=\n\n/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulLeftInvariant μ :=\n\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulRightInvariant μ :=\n\n/-- An alternative way to prove that `μ` is left invariant under addition. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsAddLeftInvariant μ :=\n\n/-- The left unitors are given by equalities -/\ntheorem ∀ {B : Type u} [inst : CategoryTheory.Bicategory B] [self : CategoryTheory.Bicategory.Strict B] {a b : B} (f : a ⟶ b),\n  CategoryTheory.Bicategory.leftUnitor f =\n    CategoryTheory.eqToIso (_ : CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id a) f = f) :=\n\n/-- The Radon-Nikodym theorem for signed measures. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} (s : MeasureTheory.SignedMeasure α) (μ : MeasureTheory.Measure α)\n  [inst : MeasureTheory.SigmaFinite μ],\n  MeasureTheory.VectorMeasure.AbsolutelyContinuous s (MeasureTheory.Measure.toENNRealVectorMeasure μ) ↔\n    MeasureTheory.Measure.withDensityᵥ μ (MeasureTheory.SignedMeasure.rnDeriv s μ) = s :=\n\n/-- In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\none's additive inverse. -/\ntheorem ∀ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : Rˣ), u⁻¹ = u ↔ u = 1 ∨ u = -1 :=\n\n/-- Multiplication by a `u : Mˣ` on the left doesn't affect `IsUnit`. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (a : M), IsUnit (↑u * a) ↔ IsUnit a :=\n\n/-- Prove that if $u$ is a unit in $R$ then so is $-u$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : Ring R] (u : Rˣ), IsUnit (-↑u) "
    ]
  },
  {
    "docString": "Prove that any subring of a field which contains the identity is an integral domain.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K],\\n  ⨅ (v : PrimeSpectrum R),\\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\\n    ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An integral domain is equal to the intersection of its localizations at all its prime ideals\\nviewed as subalgebras of its field of fractions. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ (S : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite ↑S] [inst_6 : IsCyclotomicExtension S A B],\\n  Algebra.IsIntegral A B\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite cyclotomic extension of an integral noetherian domain is integral \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\": \"A subring of a domain is a domain. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} [inst : CommRing R₁] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R₁ K]\\n  [frac : IsFractionRing R₁ K] [inst_3 : IsDomain R₁] [inst_4 : IsNoetherianRing R₁]\\n  (I : FractionalIdeal (nonZeroDivisors R₁) K), IsNoetherian R₁ { x // x ∈ ↑I }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every fractional ideal of a noetherian integral domain is noetherian. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K],\\n  ⨅ (v : MaximalSpectrum R),\\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\\n    ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An integral domain is equal to the intersection of its localizations at all its maximal ideals\\nviewed as subalgebras of its field of fractions. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\\n  [inst_4 : Algebra R S], Algebra.IsIntegral R S → Function.Injective ↑(algebraMap R S) → IsField S → IsField R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K →+* L) (s : Set K),\\n  Subfield.map f (Subfield.closure s) = Subfield.closure (↑f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subfield generated by a set equals\\nthe subfield generated by the image of the set. \"},\n {\"theorem\":\n  \"∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\\n  ¬IsField A →\\n    ∀ {I : Ideal A},\\n      I ≠ ⊥ →\\n        ∃ Z,\\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"∀ {n : Type u_2} [inst : Fintype n] {K : Type u_1} [inst_1 : DecidableEq n] [inst_2 : Field K] {M : Matrix n n K},\\n  (∃ v x, Matrix.mulVec M v = 0) ↔ Matrix.det M = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"This holds for all integral domains (see `Matrix.exists_mulVec_eq_zero_iff`),\\nnot just fields, but it's easier to prove it for the field of fractions first. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] {P : Ideal A} (x : Ideal.IsPrime P),\\n  IsDomain (Localization.AtPrime P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of an integral domain at the complement of a prime ideal is an integral domain.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring is closed under addition. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : Nontrivial R] (s : Subring R), Nontrivial { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\": \"A subring of a non-trivial ring is non-trivial. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) [inst : CommRing A] [inst_1 : IsDomain A] (K : Type u_1) [inst_2 : Field K] [inst_3 : Algebra A K]\\n  [inst_4 : IsFractionRing A K],\\n  IsDedekindDomain A ↔\\n    IsNoetherianRing A ∧ Ring.DimensionLEOne A ∧ ∀ {x : K}, IsIntegral A x → ∃ y, ↑(algebraMap A K) y = x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An integral domain is a Dedekind domain iff and only if it is\\nNoetherian, has dimension ≤ 1, and is integrally closed in a given fraction field.\\nIn particular, this definition does not depend on the choice of this fraction field. \"}]\n",
    "prompt_cons": "/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem ∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- An integral domain is equal to the intersection of its localizations at all its prime ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K],\n  ⨅ (v : PrimeSpectrum R),\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\n    ⊥ :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- A finite cyclotomic extension of an integral noetherian domain is integral -/\ntheorem ∀ (S : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite ↑S] [inst_6 : IsCyclotomicExtension S A B],\n  Algebra.IsIntegral A B :=\n\n/-- A subring of a domain is a domain. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x ∈ s } :=\n\n/-- Every fractional ideal of a noetherian integral domain is noetherian. -/\ntheorem ∀ {R₁ : Type u_1} [inst : CommRing R₁] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R₁ K]\n  [frac : IsFractionRing R₁ K] [inst_3 : IsDomain R₁] [inst_4 : IsNoetherianRing R₁]\n  (I : FractionalIdeal (nonZeroDivisors R₁) K), IsNoetherian R₁ { x // x ∈ ↑I } :=\n\n/-- An integral domain is equal to the intersection of its localizations at all its maximal ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K],\n  ⨅ (v : MaximalSpectrum R),\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\n    ⊥ :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P) :=\n\n/-- A subring is closed under multiplication. -/\ntheorem ∀ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\n  [inst_4 : Algebra R S], Algebra.IsIntegral R S → Function.Injective ↑(algebraMap R S) → IsField S → IsField R :=\n\n/-- The image under a ring homomorphism of the subfield generated by a set equals\nthe subfield generated by the image of the set. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K →+* L) (s : Set K),\n  Subfield.map f (Subfield.closure s) = Subfield.closure (↑f '' s) :=\n\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) -/\ntheorem ∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\n  ¬IsField A →\n    ∀ {I : Ideal A},\n      I ≠ ⊥ →\n        ∃ Z,\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥ :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s) :=\n\n/-- This holds for all integral domains (see `Matrix.exists_mulVec_eq_zero_iff`),\nnot just fields, but it's easier to prove it for the field of fractions first. -/\ntheorem ∀ {n : Type u_2} [inst : Fintype n] {K : Type u_1} [inst_1 : DecidableEq n] [inst_2 : Field K] {M : Matrix n n K},\n  (∃ v x, Matrix.mulVec M v = 0) ↔ Matrix.det M = 0 :=\n\n/-- The localization of an integral domain at the complement of a prime ideal is an integral domain. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] {P : Ideal A} (x : Ideal.IsPrime P),\n  IsDomain (Localization.AtPrime P) :=\n\n/-- A subring is closed under addition. -/\ntheorem ∀ {R : Type u} [inst : Ring R] (s : Subring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s :=\n\n/-- A subring of a non-trivial ring is non-trivial. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : Nontrivial R] (s : Subring R), Nontrivial { x // x ∈ s } :=\n\n/-- An integral domain is a Dedekind domain iff and only if it is\nNoetherian, has dimension ≤ 1, and is integrally closed in a given fraction field.\nIn particular, this definition does not depend on the choice of this fraction field. -/\ntheorem ∀ (A : Type u_2) [inst : CommRing A] [inst_1 : IsDomain A] (K : Type u_1) [inst_2 : Field K] [inst_3 : Algebra A K]\n  [inst_4 : IsFractionRing A K],\n  IsDedekindDomain A ↔\n    IsNoetherianRing A ∧ Ring.DimensionLEOne A ∧ ∀ {x : K}, IsIntegral A x → ∃ y, ↑(algebraMap A K) y = x :=\n\n/-- Prove that any subring of a field which contains the identity is an integral domain. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} [inst : Field K] (s : Subring K), (1 : K) ∈ s → IsDomain { x // x ∈ s } "
    ]
  },
  {
    "docString": "Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\\n  P ≠ ⊥ →\\n    (∀ (x : R), ↑Polynomial.C x ∈ P → x = 0) →\\n      ∃ p, p ∈ P ∧ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"This technical lemma asserts the existence of a polynomial `p` in an ideal `P ⊂ R[x]`\\nthat is non-zero in the quotient `R / (P ∩ R) [x]`.  The assumptions are equivalent to\\n`P ≠ 0` and `P ∩ R = (0)`.\\n\"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → (Polynomial.coeff (minpoly A x) 0 = 0 ↔ x = 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ {σ : Type u_1} (n : ℕ) (φ : MvPolynomial σ ℤ),\\n  ↑MvPolynomial.C ↑n ∣ φ ↔ ↑(MvPolynomial.map (Int.castRingHom (ZMod n))) φ = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial over the integers is divisible by `n : ℕ`\\nif and only if it is zero over `ZMod n`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ b * a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is\\n`b * a`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CancelCommMonoidWithZero R] {x y a p : R} {n : ℕ},\\n  Prime p → x * y = a * p ^ n → ∃ i j b c, i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j\",\n  \"isProp\": true,\n  \"docString\":\n  \"If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written\\nas the product of a power of `p` and a divisor of `a`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, 0 = a * b ↔ a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has no zero divisors, then the product of two elements equals zero iff one of them\\nequals zero. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] {a : ℤ}, multiplicity.Finite (↑p) a ↔ a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ b * a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is\\n`b * a`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\\n  IsUnit ↑p ↔ ¬p ∣ ringChar R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a finite commutative ring `R`\\niff it does not divide the characteristic. \"}]\n",
    "prompt_cons": "/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0 :=\n\n/-- This technical lemma asserts the existence of a polynomial `p` in an ideal `P ⊂ R[x]`\nthat is non-zero in the quotient `R / (P ∩ R) [x]`.  The assumptions are equivalent to\n`P ≠ 0` and `P ∩ R = (0)`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\n  P ≠ ⊥ →\n    (∀ (x : R), ↑Polynomial.C x ∈ P → x = 0) →\n      ∃ p, p ∈ P ∧ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p ≠ 0 :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p ≠ 1`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1 :=\n\n/-- The constant coefficient of the minimal polynomial of `x` is `0` if and only if `x = 0`. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → (Polynomial.coeff (minpoly A x) 0 = 0 ↔ x = 0) :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- A polynomial over the integers is divisible by `n : ℕ`\nif and only if it is zero over `ZMod n`. -/\ntheorem ∀ {σ : Type u_1} (n : ℕ) (φ : MvPolynomial σ ℤ),\n  ↑MvPolynomial.C ↑n ∣ φ ↔ ↑(MvPolynomial.map (Int.castRingHom (ZMod n))) φ = 0 :=\n\n/-- If `α` has no zero divisors, then for elements `a, b : α`, `a * b` equals zero iff so is\n`b * a`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ b * a = 0 :=\n\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0 :=\n\n/-- If ` x * y = a * p ^ n` where `p` is prime, then `x` and `y` can both be written\nas the product of a power of `p` and a divisor of `a`. -/\ntheorem ∀ {R : Type u_1} [inst : CancelCommMonoidWithZero R] {x y a p : R} {n : ℕ},\n  Prime p → x * y = a * p ^ n → ∃ i j b c, i + j = n ∧ a = b * c ∧ x = b * p ^ i ∧ y = c * p ^ j :=\n\n/-- If `α` has no zero divisors, then the product of two elements equals zero iff one of them\nequals zero. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, 0 = a * b ↔ a = 0 ∨ b = 0 :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R) :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- The multiplicity of `p : ℕ` in `a : ℤ` is finite exactly when `a ≠ 0`. -/\ntheorem ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] {a : ℤ}, multiplicity.Finite (↑p) a ↔ a ≠ 0 :=\n\n/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem ∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1) :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- If `α` has no zero divisors, then for elements `a, b : α`, `a * b` is nonzero iff so is\n`b * a`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ b * a ≠ 0 :=\n\n/-- A prime `p` is a unit in a finite commutative ring `R`\niff it does not divide the characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] [inst_2 : Finite R],\n  IsUnit ↑p ↔ ¬p ∣ ringChar R :=\n\n/-- Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  (∃ (b : R), b ≠ 0 ∧ b • p = 0) ↔ p * Polynomial.X ≠ 0 ∧ p ≠ 0 "
    ]
  },
  {
    "docString": "Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S),\\n  Function.Surjective ↑f → IsLocalRingHom f → Function.Surjective ↑(Units.map ↑f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : R →+* S` is a surjective local ring hom, then the induced units map is surjective. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (↑f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subsemiring generated by a set equals\\nthe subsemiring generated by the image of the set. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) (s : Set R),\\n  Subring.map f (Subring.closure s) = Subring.closure (↑f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subring generated by a set equals\\nthe subring generated by the image of the set. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\\n  {Rₘ : Type u_3} {Sₘ : Type u_4} [inst_3 : CommRing Rₘ] [inst_4 : CommRing Sₘ] [inst_5 : Algebra R Rₘ]\\n  [inst_6 : IsLocalization M Rₘ] [inst_7 : Algebra S Sₘ] [inst_8 : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ],\\n  Algebra.IsIntegral R S →\\n    RingHom.IsIntegral\\n      (IsLocalization.map Sₘ (algebraMap R S)\\n        (_ : M ≤ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R → S` is an integral extension, `M` is a submonoid of `R`,\\n`Rₘ` is the localization of `R` at `M`,\\nand `Sₘ` is the localization of `S` at the image of `M` under the extension map,\\nthen the induced map `Rₘ → Sₘ` is also an integral extension \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemiring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. \"},\n {\"theorem\":\n  \"∀ (K : Subfield ℂ) {ψ : { x // x ∈ K } →+* ℂ},\\n  UniformContinuous ↑ψ → ψ.toFun = ↑(Subfield.subtype K) ∨ ψ.toFun = ↑(starRingEnd ℂ) ∘ ↑(Subfield.subtype K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `K` a subfield of `ℂ` and let `ψ : K →+* ℂ` a ring homomorphism. Assume that `ψ` is uniform\\ncontinuous, then `ψ` is either the inclusion map or the composition of the inclusion map with the\\ncomplex conjugation. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K →+* L) (s : Set K),\\n  Subfield.map f (Subfield.closure s) = Subfield.closure (↑f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subfield generated by a set equals\\nthe subfield generated by the image of the set. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} [self : IsLocalRingHom f] (a : R),\\n  IsUnit (↑f a) → IsUnit a\",\n  \"isProp\": true,\n  \"docString\":\n  \"A local ring homomorphism `f : R ⟶ S` will send nonunits of `R` to nonunits of `S`. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\\n  [inst_4 : Algebra R S], Algebra.IsIntegral R S → Function.Injective ↑(algebraMap R S) → IsField S → IsField R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α → β}, IsRingHom f → IsSemiringHom f\",\n  \"isProp\": true,\n  \"docString\": \"A ring homomorphism is also a semiring homomorphism. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R →+* S),\\n  Function.Surjective ↑f → IsPrincipalIdealRing S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] (self : RingInvo R) (x : R),\\n  MulOpposite.unop (Equiv.toFun self.toEquiv (MulOpposite.unop (Equiv.toFun self.toEquiv x))) = x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The requirement that the ring homomorphism is its own inverse \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommSemiring R] [inst_1 : CommSemiring S] [H : LocalRing S] (f : R →+* S)\\n  [inst_2 : IsLocalRingHom f], LocalRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : R →+* S` is a local ring hom, then `R` is a local ring if `S` is. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) (s : Set G),\\n  Subgroup.map f (Subgroup.closure s) = Subgroup.closure (↑f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup\\ngenerated by the image of the set. \"}]\n",
    "prompt_cons": "/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- If `f : R →+* S` is a surjective local ring hom, then the induced units map is surjective. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S),\n  Function.Surjective ↑f → IsLocalRingHom f → Function.Surjective ↑(Units.map ↑f) :=\n\n/-- The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (↑f '' s) :=\n\n/-- The image under a ring homomorphism of the subring generated by a set equals\nthe subring generated by the image of the set. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) (s : Set R),\n  Subring.map f (Subring.closure s) = Subring.closure (↑f '' s) :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖ :=\n\n/-- If `R → S` is an integral extension, `M` is a submonoid of `R`,\n`Rₘ` is the localization of `R` at `M`,\nand `Sₘ` is the localization of `S` at the image of `M` under the extension map,\nthen the induced map `Rₘ → Sₘ` is also an integral extension -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  {Rₘ : Type u_3} {Sₘ : Type u_4} [inst_3 : CommRing Rₘ] [inst_4 : CommRing Sₘ] [inst_5 : Algebra R Rₘ]\n  [inst_6 : IsLocalization M Rₘ] [inst_7 : Algebra S Sₘ] [inst_8 : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₘ],\n  Algebra.IsIntegral R S →\n    RingHom.IsIntegral\n      (IsLocalization.map Sₘ (algebraMap R S)\n        (_ : M ≤ Submonoid.comap (algebraMap R S) (Algebra.algebraMapSubmonoid S M))) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subsemiring.closure s) :=\n\n/-- Let `K` a subfield of `ℂ` and let `ψ : K →+* ℂ` a ring homomorphism. Assume that `ψ` is uniform\ncontinuous, then `ψ` is either the inclusion map or the composition of the inclusion map with the\ncomplex conjugation. -/\ntheorem ∀ (K : Subfield ℂ) {ψ : { x // x ∈ K } →+* ℂ},\n  UniformContinuous ↑ψ → ψ.toFun = ↑(Subfield.subtype K) ∨ ψ.toFun = ↑(starRingEnd ℂ) ∘ ↑(Subfield.subtype K) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s) :=\n\n/-- The image under a ring homomorphism of the subfield generated by a set equals\nthe subfield generated by the image of the set. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] (f : K →+* L) (s : Set K),\n  Subfield.map f (Subfield.closure s) = Subfield.closure (↑f '' s) :=\n\n/-- A local ring homomorphism `f : R ⟶ S` will send nonunits of `R` to nonunits of `S`. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} [self : IsLocalRingHom f] (a : R),\n  IsUnit (↑f a) → IsUnit a :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s) :=\n\n/-- If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\n  [inst_4 : Algebra R S], Algebra.IsIntegral R S → Function.Injective ↑(algebraMap R S) → IsField S → IsField R :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem ∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c) :=\n\n/-- A ring homomorphism is also a semiring homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α → β}, IsRingHom f → IsSemiringHom f :=\n\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem ∀ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R →+* S),\n  Function.Surjective ↑f → IsPrincipalIdealRing S :=\n\n/-- The requirement that the ring homomorphism is its own inverse -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] (self : RingInvo R) (x : R),\n  MulOpposite.unop (Equiv.toFun self.toEquiv (MulOpposite.unop (Equiv.toFun self.toEquiv x))) = x :=\n\n/-- If `f : R →+* S` is a local ring hom, then `R` is a local ring if `S` is. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommSemiring R] [inst_1 : CommSemiring S] [H : LocalRing S] (f : R →+* S)\n  [inst_2 : IsLocalRingHom f], LocalRing R :=\n\n/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {M : Type u_2} [inst_1 : Monoid M] {f g : G →* M} {s : Set G},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subgroup.closure s) :=\n\n/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup\ngenerated by the image of the set. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) (s : Set G),\n  Subgroup.map f (Subgroup.closure s) = Subgroup.closure (↑f '' s) :=\n\n/-- Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (ϕ : R →+* S),\n  Function.Surjective ↑ϕ → Subring.center R ≤ Subring.comap ϕ (Subring.center S) "
    ]
  },
  {
    "docString": "Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\\nnilpotent, except its constant term which is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G ⧸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Ring α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is invertible and `a = b`, then `⅟a = ⅟b`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card R → ¬IsUnit ↑p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime that does not divide the cardinality of a finite commutative ring `R`\\nis a unit in `R`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\\n  IsUnit p ↔ ∃ r, IsUnit r ∧ ↑Polynomial.C r = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterization of a unit of a polynomial ring over an integral domain `R`.\\nSee `Polynomial.isUnit_iff_coeff_isUnit_isNilpotent` when `R` is a commutative ring. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonAssocRing α] [inst_2 : ContinuousMul α], ContinuousNeg α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\\nis just multiplication with `-1`. \"},\n {\"theorem\":\n  \"∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂)\",\n  \"isProp\": true,\n  \"docString\": \"Products of nilpotent groups are nilpotent \"},\n {\"theorem\": \"∀ {α : Type u} [self : OrderedRing α], 0 ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"`0 ≤ 1` in any ordered ring. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), -1 * a = -a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The additive inverse of one multiplied by an element of a ring is the element's additive\\ninverse. \"}]\n",
    "prompt_cons": "/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b :=\n\n/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\nnilpotent, except its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- An ideal which contains an element within `1` of `1 : R` is the unit ideal. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤ :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G ⧸ H) :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem ∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0 :=\n\n/-- If `a` is invertible and `a = b`, then `⅟a = ⅟b`. -/\ntheorem ∀ {α : Type u} [inst : Ring α] (a b : α) [inst_1 : Invertible a] [inst_2 : Invertible b], a = b → ⅟a = ⅟b :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem ∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- A prime that does not divide the cardinality of a finite commutative ring `R`\nis a unit in `R`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\n  p ∣ Fintype.card R → ¬IsUnit ↑p :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- Characterization of a unit of a polynomial ring over an integral domain `R`.\nSee `Polynomial.isUnit_iff_coeff_isUnit_isNilpotent` when `R` is a commutative ring. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [inst_1 : NoZeroDivisors R] {p : Polynomial R},\n  IsUnit p ↔ ∃ r, IsUnit r ∧ ↑Polynomial.C r = p :=\n\n/-- If `R` is a ring with a continuous multiplication, then negation is continuous as well since it\nis just multiplication with `-1`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : NonAssocRing α] [inst_2 : ContinuousMul α], ContinuousNeg α :=\n\n/-- Products of nilpotent groups are nilpotent -/\ntheorem ∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂) :=\n\n/-- `0 ≤ 1` in any ordered ring. -/\ntheorem ∀ {α : Type u} [self : OrderedRing α], 0 ≤ 1 :=\n\n/-- The additive inverse of one multiplied by an element of a ring is the element's additive\ninverse. -/\ntheorem ∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), -1 * a = -a :=\n\n/-- Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R] {a b : R}, IsNilpotent a → IsUnit (1 - a * b) "
    ]
  },
  {
    "docString": "Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R], UniqueFactorizationMonoid R\",\n  \"isProp\": true,\n  \"docString\": \"A principal ideal domain has unique factorization \"},\n {\"theorem\":\n  \"∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\\n  ¬IsField A →\\n    ∀ {I : Ideal A},\\n      I ≠ ⊥ →\\n        ∃ Z,\\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R],\\n  Fintype.card (ClassGroup R) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The class number of a principal ideal domain is `1`. \"},\n {\"theorem\":\n  \"∀ (A : Type u_1) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A] {P : Ideal A},\\n  P ≠ ⊥ →\\n    ∀ [pP : Ideal.IsPrime P] (Aₘ : Type u_2) [inst_3 : CommRing Aₘ] [inst_4 : IsDomain Aₘ] [inst_5 : Algebra A Aₘ]\\n      [inst : IsLocalization.AtPrime Aₘ P], DiscreteValuationRing Aₘ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Dedekind domain, the localization at every nonzero prime ideal is a DVR. \"},\n {\"theorem\":\n  \"∀ (A : Type u_1) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A] (P : Ideal A)\\n  [inst_3 : Ideal.IsPrime P] (Aₘ : Type u_2) [inst_4 : CommRing Aₘ] [inst_5 : IsDomain Aₘ] [inst_6 : Algebra A Aₘ]\\n  [inst : IsLocalization.AtPrime Aₘ P], IsDedekindDomain Aₘ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of a Dedekind domain at every nonzero prime ideal is a Dedekind domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f)\",\n  \"isProp\": true,\n  \"docString\": \"The kernel of a homomorphism to a domain is a prime ideal. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K],\\n  ⨅ (v : PrimeSpectrum R),\\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\\n    ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An integral domain is equal to the intersection of its localizations at all its prime ideals\\nviewed as subalgebras of its field of fractions. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Ideal.IsPrime (Ideal.span {PowerSeries.X})\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ideal spanned by the variable in the power series ring\\nover an integral domain is a prime ideal.\"},\n {\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\\n  Polynomial.Monic g₁ →\\n    Polynomial.Monic g₂ →\\n      IsCoprime g₁ g₂ →\\n        ∃ q r₁ r₂,\\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\\ndeg(r₂) < deg(g₂).\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"}]\n",
    "prompt_cons": "/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P) :=\n\n/-- A principal ideal domain has unique factorization -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R], UniqueFactorizationMonoid R :=\n\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) -/\ntheorem ∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\n  ¬IsField A →\n    ∀ {I : Ideal A},\n      I ≠ ⊥ →\n        ∃ Z,\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥ :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥ :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I} :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- The class number of a principal ideal domain is `1`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R],\n  Fintype.card (ClassGroup R) = 1 :=\n\n/-- In a Dedekind domain, the localization at every nonzero prime ideal is a DVR. -/\ntheorem ∀ (A : Type u_1) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A] {P : Ideal A},\n  P ≠ ⊥ →\n    ∀ [pP : Ideal.IsPrime P] (Aₘ : Type u_2) [inst_3 : CommRing Aₘ] [inst_4 : IsDomain Aₘ] [inst_5 : Algebra A Aₘ]\n      [inst : IsLocalization.AtPrime Aₘ P], DiscreteValuationRing Aₘ :=\n\n/-- The localization of a Dedekind domain at every nonzero prime ideal is a Dedekind domain. -/\ntheorem ∀ (A : Type u_1) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsDedekindDomain A] (P : Ideal A)\n  [inst_3 : Ideal.IsPrime P] (Aₘ : Type u_2) [inst_4 : CommRing Aₘ] [inst_5 : IsDomain Aₘ] [inst_6 : Algebra A Aₘ]\n  [inst : IsLocalization.AtPrime Aₘ P], IsDedekindDomain Aₘ :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R :=\n\n/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem ∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsDomain S]\n  [inst_3 : RingHomClass F R S] (f : F), Ideal.IsPrime (RingHom.ker f) :=\n\n/-- An integral domain is equal to the intersection of its localizations at all its prime ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K],\n  ⨅ (v : PrimeSpectrum R),\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\n    ⊥ :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I :=\n\n/-- The ideal spanned by the variable in the power series ring\nover an integral domain is a prime ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Ideal.IsPrime (Ideal.span {PowerSeries.X}) :=\n\n/-- Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\ndeg(r₂) < deg(g₂). -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\n  Polynomial.Monic g₁ →\n    Polynomial.Monic g₂ →\n      IsCoprime g₁ g₂ →\n        ∃ q r₁ r₂,\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂ :=\n\n/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem ∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R) :=\n\n/-- Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ (a b : R), a ≠ 0 → b ≠ 0 → ∃ r s, IsGcd a b (r * a + s * b)) →\n  (∀ (a : ℕ → R), (∀ i, a (i + 1) ∣ a i) → ∃ N, ∀ n, n ≥ N → IsUnit (a n / a N)) →\n    IsPrincipalIdealRing R "
    ]
  },
  {
    "docString": "Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$.",
    "prompts": "[{\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {n : ℕ} [inst_1 : IsDomain R],\\n  0 < n → ∀ {μ : R}, IsPrimitiveRoot μ n → Polynomial.IsRoot (Polynomial.cyclotomic n R) μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any `n`-th primitive root of unity is a root of `cyclotomic n R`.\"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\": \"∀ {n x y : ℤ}, n = x ^ 2 + y ^ 2 → IsCoprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the integer `n` is a sum of two squares of coprime integers,\\nthen `-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R} {n : ℕ},\\n  IsPrimitiveRoot ζ n → Polynomial.degree (Polynomial.cyclotomic' n R) = ↑(Nat.totient n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\\n      n ≠ 0 → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic p R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"∀ {m n : ℕ}, Nat.coprime m n → IsSquare (-1) → IsSquare (-1) → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\\na square modulo `m*n`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"}]\n",
    "prompt_cons": "/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- The roots of `cyclotomic' n R` are the primitive `n`-th roots of unity. -/\ntheorem ∀ (n : ℕ) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R],\n  Polynomial.roots (Polynomial.cyclotomic' n R) = (primitiveRoots n R).val :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- Any `n`-th primitive root of unity is a root of `cyclotomic n R`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {n : ℕ} [inst_1 : IsDomain R],\n  0 < n → ∀ {μ : R}, IsPrimitiveRoot μ n → Polynomial.IsRoot (Polynomial.cyclotomic n R) μ :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- If the integer `n` is a sum of two squares of coprime integers,\nthen `-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℤ}, n = x ^ 2 + y ^ 2 → IsCoprime x y → IsSquare (-1) :=\n\n/-- The degree of `cyclotomic' n R` is `totient n` if there is a primitive root of unity in `R`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R} {n : ℕ},\n  IsPrimitiveRoot ζ n → Polynomial.degree (Polynomial.cyclotomic' n R) = ↑(Nat.totient n) :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `Irreducible (cyclotomic (p ^ n) R)` then `Irreducible (cyclotomic p R).` -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\n      n ≠ 0 → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic p R) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b :=\n\n/-- If `-1` is a square modulo coprime natural numbers `m` and `n`, then `-1` is also\na square modulo `m*n`. -/\ntheorem ∀ {m n : ℕ}, Nat.coprime m n → IsSquare (-1) → IsSquare (-1) → IsSquare (-1) :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1) :=\n\n/-- Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ} [inst : Fact (Nat.Prime n)] [inst_1 : Fact (Nat.succ (Nat.succ (Nat.succ n)) ≤ n)],\n  Irreducible (2 : ℤ[sqrt (-↑n)]) ∧\n  Irreducible (sqrt (-↑n) : ℤ[sqrt (-↑n)]) ∧\n  Irreducible (1 + sqrt (-↑n) : ℤ[sqrt (-↑n)]) "
    ]
  },
  {
    "docString": "Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements.",
    "prompts": "[{\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c → Prop} (q : Con.Quotient c), (∀ (x : M), C ↑x) → C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about the elements of a quotient by a\\ncongruence relation. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {ι : Type u_1} {g : ι → Polynomial R} {s : Finset ι},\\n  (∀ (i : ι), i ∈ s → Polynomial.Monic (g i)) →\\n    (Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) →\\n      ∃ q r,\\n        (∀ (i : ι), i ∈ s → Polynomial.degree (r i) < Polynomial.degree (g i)) ∧\\n          (↑f / Finset.prod s fun i => ↑(g i)) = ↑q + Finset.sum s fun i => ↑(r i) / ↑(g i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\": \"∀ {q : ℕ+}, Fintype.card (LucasLehmer.X q) = ↑q ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of `X` is `q^2`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"∀ {f : Polynomial ℚ} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of `ℚ[X]` by the ideal generated by an irreducible polynomial of `ℚ[X]`\\nis a number field. \"}]\n",
    "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- The inductive principle used to prove propositions about the elements of a quotient by a\ncongruence relation. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} {C : Con.Quotient c → Prop} (q : Con.Quotient c), (∀ (x : M), C ↑x) → C q :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime. -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {ι : Type u_1} {g : ι → Polynomial R} {s : Finset ι},\n  (∀ (i : ι), i ∈ s → Polynomial.Monic (g i)) →\n    (Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) →\n      ∃ q r,\n        (∀ (i : ι), i ∈ s → Polynomial.degree (r i) < Polynomial.degree (g i)) ∧\n          (↑f / Finset.prod s fun i => ↑(g i)) = ↑q + Finset.sum s fun i => ↑(r i) / ↑(g i) :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- The cardinality of `X` is `q^2`. -/\ntheorem ∀ {q : ℕ+}, Fintype.card (LucasLehmer.X q) = ↑q ^ 2 :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- The quotient of `ℚ[X]` by the ideal generated by an irreducible polynomial of `ℚ[X]`\nis a number field. -/\ntheorem ∀ {f : Polynomial ℚ} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f) :=\n\n/-- Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements. -/\ntheorem",
    "choices": [
      "∀ (q : ℕ) [inst : Fact (Nat.Prime q)], q % 4 = 3 → IsField (ℤ[i] ⧸ Ideal.span {↑q}) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span {↑q}) = q ^ 2 "
    ]
  },
  {
    "docString": "Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals.",
    "prompts": "[{\"theorem\":\n  \"∀ (R : Type w₁) [inst : CommRing R] (ι : Type u_2) [inst_1 : Finite ι], Algebra.FinitePresentation R (MvPolynomial ι R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of polynomials in finitely many variables is finitely presented. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ↔ ∀ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\\n  [inst_3 : IsLocalization S A],\\n  S ≤ nonZeroDivisors R →\\n    Set.Finite {I | Ideal.IsMaximal I} → ∀ (I I' : FractionalIdeal S A), I * I' = 1 → Submodule.IsPrincipal ↑I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R →+* S),\\n  Function.Surjective ↑f → IsPrincipalIdealRing S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The surjective image of a principal ideal ring is again a principal ideal ring. \"},\n {\"theorem\":\n  \"∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  ↑Polynomial.C x ∈\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R],\\n  Set.Finite {I | Ideal.IsMaximal I} → ∀ {I : Ideal R}, IsUnit ↑I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\\n\\nhttps://math.stackexchange.com/a/95857 \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  ∃ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, § 3.3, Lemma 3])\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\",\n  \"isProp\": true,\n  \"docString\": \"Any finitely generated ideal is principal. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R ↔\\n    ∀ {I : Ideal R}, Ideal.IsPrime I → ∃ M, (∀ (J : Ideal R), J ∈ M → Ideal.IsMaximal J ∨ J = ⊤) ∧ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"}]\n",
    "prompt_cons": "/-- The ring of polynomials in finitely many variables is finitely presented. -/\ntheorem ∀ (R : Type w₁) [inst : CommRing R] (ι : Type u_2) [inst_1 : Finite ι], Algebra.FinitePresentation R (MvPolynomial ι R) :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem ∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem ∀ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ↔ ∀ (I : Ideal R), Ideal.FG I :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I} :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- An invertible fractional ideal of a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ∀ {R : Type u_2} [inst : CommRing R] {A : Type u_1} [inst_1 : CommRing A] [inst_2 : Algebra R A] {S : Submonoid R}\n  [inst_3 : IsLocalization S A],\n  S ≤ nonZeroDivisors R →\n    Set.Finite {I | Ideal.IsMaximal I} → ∀ (I I' : FractionalIdeal S A), I * I' = 1 → Submodule.IsPrincipal ↑I :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M :=\n\n/-- The surjective image of a principal ideal ring is again a principal ideal ring. -/\ntheorem ∀ {R : Type u} {S : Type u_1} [inst : Ring R] [inst_1 : Ring S] [inst_2 : IsPrincipalIdealRing R] (f : R →+* S),\n  Function.Surjective ↑f → IsPrincipalIdealRing S :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem ∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  ↑Polynomial.C x ∈\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\n    x = 0 :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- An invertible ideal in a commutative ring with finitely many maximal ideals is principal.\n\nhttps://math.stackexchange.com/a/95857 -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R],\n  Set.Finite {I | Ideal.IsMaximal I} → ∀ {I : Ideal R}, IsUnit ↑I → Submodule.IsPrincipal I :=\n\n/-- In a noetherian ring, every ideal contains a product of prime ideals\n([samuel, § 3.3, Lemma 3]) -/\ntheorem ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\n  ∃ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I :=\n\n/-- Any finitely generated ideal is principal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R ↔\n    ∀ {I : Ideal R}, Ideal.IsPrime I → ∃ M, (∀ (J : Ideal R), J ∈ M → Ideal.IsMaximal J ∨ J = ⊤) ∧ I = sInf M :=\n\n/-- Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals. -/\ntheorem",
    "choices": [
      "∃ (f : ℕ → Ideal (Polynomial ℤ)),\n  (∀ (n : ℕ), Ideal.IsPrime (f n)) ∧\n    ∀ (n₁ n₂ : ℕ), n₁ ≠ n₂ → Disjoint (f n₁) (f n₂) ∧ ∀ (x : ℕ), ¬f x ≤ f n₁ ∧ f x ≠ ⊤ "
    ]
  },
  {
    "docString": "Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem ∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ :=\n\n/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_sub_C_pow (4 : ℕ) (6 : ℤ) (3 : ℕ) (by norm_num) (by norm_num) "
    ]
  },
  {
    "docString": "Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem ∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_four_add_four_x_pow_three_add_six_x_pow_two_add_two_x_add_one : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) "
    ]
  },
  {
    "docString": "Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : ℕ},\\n  IsPrimitiveRoot ζ (2 ^ k) →\\n    2 ≤ k →\\n      ∀ [H : IsCyclotomicExtension {2 ^ k} K L],\\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (ζ - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\\nthen the norm of `ζ - 1` is `2`. \"},\n {\"theorem\":\n  \"∀ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : ℕ},\\n  2 ≤ k →\\n    ∀ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  ↑(Polynomial.aeval r) p = 0 → IsFractionRing.num A r ∣ Polynomial.coeff p 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 1:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the numerator of `r` divides the constant coefficient \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] {a b c : K}, (∀ (x : K), 0 ≤ a * x * x + b * x + c) → discrim a b c ≤ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a polynomial of degree 2 is always nonnegative, then its discriminant is nonpositive \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\\n  ↑(Polynomial.aeval r) p = 0 → ↑(IsFractionRing.den A r) ∣ Polynomial.leadingCoeff p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational root theorem part 2:\\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\\nthen the denominator of `r` divides the leading coefficient \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1 :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\nthen the norm of `ζ - 1` is `2`. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : ℕ},\n  IsPrimitiveRoot ζ (2 ^ k) →\n    2 ≤ k →\n      ∀ [H : IsCyclotomicExtension {2 ^ k} K L],\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (ζ - 1) = 2 :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. -/\ntheorem ∀ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : ℕ},\n  2 ≤ k →\n    ∀ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2 :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- Rational root theorem part 1:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the numerator of `r` divides the constant coefficient -/\ntheorem ∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  ↑(Polynomial.aeval r) p = 0 → IsFractionRing.num A r ∣ Polynomial.coeff p 0 :=\n\n/-- If a polynomial of degree 2 is always nonnegative, then its discriminant is nonpositive -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] {a b c : K}, (∀ (x : K), 0 ≤ a * x * x + b * x + c) → discrim a b c ≤ 0 :=\n\n/-- Rational root theorem part 2:\nif `r : f.codomain` is a root of a polynomial over the ufd `A`,\nthen the denominator of `r` divides the leading coefficient -/\ntheorem ∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A} {r : K},\n  ↑(Polynomial.aeval r) p = 0 → ↑(IsFractionRing.den A r) ∣ Polynomial.leadingCoeff p :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R] {p : Polynomial R},\n  p = Polynomial.x ^ 2 - C (sqrt 2) → Irreducible p "
    ]
  },
  {
    "docString": "Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if and only if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\\n  FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F → Nonempty (E ≃L[𝕜] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : ContinuousSMul ℝ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module ℝ F]\\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul ℝ F] [inst_8 : T2Space F] {G : Type u_1}\\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous ↑f → ∀ (c : ℝ) (x : E), ↑f (c • x) = c • ↑f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous additive map between two vector spaces over `ℝ` is `ℝ`-linear. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ℝ V] [inst_9 : ContinuousSMul ℝ V]\\n  [inst_10 : FiniteDimensional ℝ V] (μ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure μ],\\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-↑w v))) • f v ∂μ)\\n    (Filter.cocompact (V →L[ℝ] ℝ)) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\\ndual space. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"},\n {\"theorem\":\n  \"∀ (K : Type u) [inst : Ring K] [inst_1 : StrongRankCondition K] {n : ℕ}, FiniteDimensional.finrank K (Fin n → K) = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The vector space of functions on `Fin n` has finrank equal to `n`. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quotient of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (r : ℚ) (x : E), ↑r • x = ↑r • x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\\nagree on rational numbers in `R` and `S`. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedSpace ℝ E] [inst_4 : LinearMap.CompatibleSMul E E 𝕜 ℝ],\\n  StrictConvex 𝕜 (Metric.closedBall 0 1) → StrictConvexSpace 𝕜 E\",\n  \"isProp\": true,\n  \"docString\":\n  \"A real normed vector space is strictly convex provided that the unit ball is strictly convex. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] {r : ℝ},\\n  0 < r → IsCompact (Metric.closedBall 0 r) → FiniteDimensional 𝕜 E\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector\\nspace, then the space is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] {r : ℝ},\\n  0 < r → ∀ {c : E}, IsCompact (Metric.closedBall c r) → FiniteDimensional 𝕜 E\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Riesz's theorem**: if a closed ball of positive radius is compact in a vector space, then the\\nspace is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ℤ) (x : E), (↑n)⁻¹ • x = (↑n)⁻¹ • x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\\nagree on inverses of integer numbers in `R` and `S`. \"},\n {\"theorem\":\n  \"∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\\nquotient add up to the dimension of the space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommMonoid E] [inst_1 : DivisionSemiring R]\\n  [inst_2 : DivisionSemiring S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ℕ) (x : E), (↑n)⁻¹ • x = (↑n)⁻¹ • x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a vector space over two division semirings `R` and `S`, then scalar multiplications\\nagree on inverses of natural numbers in `R` and `S`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\\n  (∀ (r : R),\\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"}]\n",
    "prompt_cons": "/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if they have the same (finite) dimension. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\n  FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F → Nonempty (E ≃L[𝕜] F) :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- A continuous additive map between two vector spaces over `ℝ` is `ℝ`-linear. -/\ntheorem ∀ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : ContinuousSMul ℝ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module ℝ F]\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul ℝ F] [inst_8 : T2Space F] {G : Type u_1}\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous ↑f → ∀ (c : ℝ) (x : E), ↑f (c • x) = c • ↑f x :=\n\n/-- Riemann-Lebesgue lemma for functions on a finite-dimensional real vector space, formulated via\ndual space. -/\ntheorem ∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\n  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]\n  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ℝ V] [inst_9 : ContinuousSMul ℝ V]\n  [inst_10 : FiniteDimensional ℝ V] (μ : MeasureTheory.Measure V) [inst_11 : MeasureTheory.Measure.IsAddHaarMeasure μ],\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-↑w v))) • f v ∂μ)\n    (Filter.cocompact (V →L[ℝ] ℝ)) (nhds 0) :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem ∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- The vector space of functions on `Fin n` has finrank equal to `n`. -/\ntheorem ∀ (K : Type u) [inst : Ring K] [inst_1 : StrongRankCondition K] {n : ℕ}, FiniteDimensional.finrank K (Fin n → K) = n :=\n\n/-- A quotient of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K (V ⧸ S) :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on rational numbers in `R` and `S`. -/\ntheorem ∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (r : ℚ) (x : E), ↑r • x = ↑r • x :=\n\n/-- A real normed vector space is strictly convex provided that the unit ball is strictly convex. -/\ntheorem ∀ (𝕜 : Type u_2) {E : Type u_1} [inst : NormedLinearOrderedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedSpace ℝ E] [inst_4 : LinearMap.CompatibleSMul E E 𝕜 ℝ],\n  StrictConvex 𝕜 (Metric.closedBall 0 1) → StrictConvexSpace 𝕜 E :=\n\n/-- **Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector\nspace, then the space is finite-dimensional. -/\ntheorem ∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] {r : ℝ},\n  0 < r → IsCompact (Metric.closedBall 0 r) → FiniteDimensional 𝕜 E :=\n\n/-- **Riesz's theorem**: if a closed ball of positive radius is compact in a vector space, then the\nspace is finite-dimensional. -/\ntheorem ∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] {r : ℝ},\n  0 < r → ∀ {c : E}, IsCompact (Metric.closedBall c r) → FiniteDimensional 𝕜 E :=\n\n/-- If `E` is a vector space over two division rings `R` and `S`, then scalar multiplications\nagree on inverses of integer numbers in `R` and `S`. -/\ntheorem ∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommGroup E] [inst_1 : DivisionRing R]\n  [inst_2 : DivisionRing S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ℤ) (x : E), (↑n)⁻¹ • x = (↑n)⁻¹ • x :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem ∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- In a finite-dimensional vector space, the dimensions of a submodule and of the corresponding\nquotient add up to the dimension of the space. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (s : Submodule K V),\n  FiniteDimensional.finrank K (V ⧸ s) + FiniteDimensional.finrank K { x // x ∈ s } = FiniteDimensional.finrank K V :=\n\n/-- If `E` is a vector space over two division semirings `R` and `S`, then scalar multiplications\nagree on inverses of natural numbers in `R` and `S`. -/\ntheorem ∀ {E : Type u_1} (R : Type u_2) (S : Type u_3) [inst : AddCommMonoid E] [inst_1 : DivisionSemiring R]\n  [inst_2 : DivisionSemiring S] [inst_3 : Module R E] [inst_4 : Module S E] (n : ℕ) (x : E), (↑n)⁻¹ • x = (↑n)⁻¹ • x :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\n  (∀ (r : R),\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$. -/\ntheorem",
    "choices": [
      "∀ (n : ℕ), Nonempty ((Fin n → ℝ) ≃ₗ[ℚ] ℝ) "
    ]
  }
]