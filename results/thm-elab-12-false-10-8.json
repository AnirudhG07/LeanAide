{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 12,
 "include-fixed": false,
 "failures":
 ["If every proper closed set of a topological space is compact, then the space itself is compact.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
  "A group whose automorphism group is cyclic is Abelian.",
  "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
  "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
  "Every free group is torsion free.",
  "Every surjective homomorphism from a finitely generated free group to itself is injective.",
  "Every matrix satisfies its own characteristic polynomial.",
  "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
  "Every non-identity element of a free group is of infinite order.",
  "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2)",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2)",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], (p % 4 = 1) → ∃ x y, p = x ^ 2 + y ^ 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → ∃ x y, p = x ^ 2 + y ^ 2"]},
  {"theorem":
   "∀ {α : Type u} [inst : LinearOrderedRing α] {a b : α} {c d x y z w : α},\n  (∃ a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄, a = a₁ * a₁ + a₂ * a₂ + a₃ * a₃ + a₄ * a₄ ∧ b = b₁ * b₁ + b₂ * b₂ + b₃ * b₃ + b₄ * b₄) →\n    ∃ r₁ r₂ r₃ r₄, a * b = r₁ * r₁ + r₂",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a b c d e f g h : ℤ),\n  (∃ (x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℤ), a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 ∧ b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2) →\n    ∃ (r₁ s₁ t₁ u₁ r₂ s₂ t₂ u₂ : ℤ), a * b = r₁ ^ 2 + s₁ ^ 2 + t₁ ^ 2 + u₁ ^ 2 + r₂ ^ 2",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {a b c d e f g h : α},\n  (∃ (x₁ y₁ z₁ w₁ : α), a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2) →\n    (∃ (x₂ y₂ z₂ w₂ : α), b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2) →\n      ∃ (x y z w : α), e = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ f = x",
    "∀ (a b c d e f g h : ℕ),\n  ∃ (p q r s : ℕ),\n    a = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ∧\n    b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 →\n    ∃ (x y z w : ℕ),\n      e = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧\n      f = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n      ∃ (m n o r : ℕ),\n        c = m ^ 2",
    "∀ {α : Type u} [inst : LinearOrderedRing α] {a b c d x y z w : α},\n  (∃ (a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : α),\n      a = a₁ * a₁ + a₂ * a₂ + a₃ * a₃ + a₄ * a₄ ∧\n      b = b₁ * b₁ + b₂ * b₂ + b₃ * b₃ + b₄ * b₄) →\n    ∃ (r₁ r₂ r₃ r₄ : α),\n      a * b = r₁ * r₁ + r₂",
    "∀ {α : Type} [inst : LinearOrderedRing α] {a b c d e f g h : α},\n  ∃ (w x y z : α),\n    a = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ∧\n    b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ∧\n    (c * e - d * f - g * h) = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ∧\n    (c * f + d * e + g * z - h * y) = w ^ 2 + x ^ 2"]},
  {"theorem":
   "{R : Type u} → [inst : Ring R] → (∀ (a : R), IsIdempotentElem a) → CommRing R",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], (∀ (a : R), a * a = a) → CommRing R",
    "∀ {R : Type u} [inst : Ring R],\n  (∀ (x : R), x * x = x) → CommRing R",
    "∀ {R : Type u} [inst : Ring R], (∀ (x : R), x * x = x) → CommRing R",
    "∀ {R : Type u_1} [inst : Ring R], (∀ (x : R), x * x = x) → CommRing R",
    "∀ {R : Type u} [inst : Ring R], (∀ (x : R), IsIdempotentElem x) → CommRing R",
    "∀ {R : Type u} [inst : Ring R], (∀ (a : R), IsIdempotentElem a) → CommRing R"]},
  {"theorem":
   "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p - q = 2 ∧ p > n ∧ q > n",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p → Nat.Prime (p + 2)",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p - q = 2 ∧ p ≥ n ∧ q ≥ n",
    "∃ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p ∧ Nat.Prime (p + 2)",
    "∀ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p → (Nat.Prime (p + 2) ∨ Nat.Prime (p - 2))",
    "∀ (n : ℕ), ∃ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p ∧ Nat.Prime (p + 2)",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p - q = 2 ∧ p > n ∧ q > n"]},
  {"theorem": "{K : Type u} → [inst : DivisionRing K] → Fintype K → Field K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u} [inst : DivisionRing K], Fintype K → Field K"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Function.Bijective f",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u₁} {β : Type u₂} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Function.Bijective f",
    "∀ {α β : Type u} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∃ h : α ≃ β, ∀ x : α, f x = h x ∧ g (h x) = x",
    "∀ {α : Type u₁} {β : Type u₂} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h",
    "∀ {α : Type u₁} {β : Type u₂} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∀ (x : α), g (f x) = x → ∀ (y : β), f (g y) = y → Function.Bijective f",
    "∀ {α : Type u₁} {β : Type u₂},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → ∃ (h : α ≃ β), Function.Bijective h",
    "∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Function.Bijective f"]},
  {"theorem":
   "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! n, SimpleGraph.Adj G v n ∧ SimpleGraph.Adj G w n) →\n    ∃ v, ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (n : V), SimpleGraph.Adj G v n ∧ SimpleGraph.Adj G w n) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (h : ∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃),\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj], (∀ (v w : V), v ≠ w → ∃! (n : V), SimpleGraph.Adj G v n ∧ SimpleGraph.Adj G w n) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj]\n  (h : ∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃),\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj]\n  (h : ∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃),\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v : V), SimpleGraph.Adj G v₁ v ∧ SimpleGraph.Adj G v₂ v) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), G.Adj v₁ v₃ ∧ G.Adj v₂ v₃) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → G.Adj v u",
    "∀ {V : Type u} {G : SimpleGraph V} [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]},
  {"theorem":
   "∀ (f : ℝ → ℝ),\n  (∃ x, 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n    ∀ (n : ℕ), 0 < n → ∃ y, 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), x ∈ [0, 1] ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), ∃ (y : ℝ), y ∈ [0, 1] ∧ Function.IsPeriodicPt f n y",
    "∀ (f : ℝ → ℝ), (∀ (x : ℝ), x ∈ Set.Icc 0 1 → f x ∈ Set.Icc 0 1) →\n  (∃ (x : ℝ), x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), n > 0 → (∃ (y : ℝ), y ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n y)",
    "∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y",
    "∀ (f : ℝ → ℝ),\n  (∀ (x : ℝ), 0 ≤ x ∧ x ≤ 1 → f x ∈ [0, 1]) →\n  (∃ (x : ℝ), 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), n > 0 → ∃ (y : ℝ), 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y",
    "∀ {f : ℝ → ℝ},\n  (∃ x : ℝ, 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ {n : ℕ}, 0 < n → (∃ y : ℝ, 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y)",
    "∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), 0 < x ∧ x < 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), 0 < y ∧ y < 1 ∧ Function.IsPeriodicPt f n y",
    "∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), y ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n y",
    "∀ (f : ℝ → ℝ),\n  (∃ x : ℝ, x ∈ set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ y : ℝ, y ∈ set.Icc 0 1 ∧ Function.IsPeriodicPt f n y"]},
  {"theorem":
   "∀ {C : Type u} [inst : CategoryTheory.Category C] (X Y : C),\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (X ≅ Y))",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {C : Type u} [inst : CategoryTheory.Category C],\n  ∀ (X Y : C), CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (CategoryTheory.Iso X Y))",
    "∀ {C : Type u} [inst : CategoryTheory.Category C],\n  ∀ (X Y : C), CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (X ≅ Y))",
    "∀ {C : Type u} [inst : CategoryTheory.Category C], ∀ (X Y : C),\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (CategoryTheory.Iso X Y))",
    "∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (X ≅ Y))",
    "∀ {C : Type u} [inst : CategoryTheory.Category C],\n  ∀ {X Y : C}, CategoryTheory.Limits.IsTerminal X →\n  CategoryTheory.Limits.IsTerminal Y → Nonempty (CategoryTheory.Iso X Y)"]},
  {"theorem": "∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "correct": null,
   "comments": "",
   "all-elabs": ["∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]},
  {"theorem": "∀ (a b : ℕ), ℕ → a > 0 → b > 0 → ¬∃ d, a ^ 3 + b ^ 3 = d ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a b c : ℕ),\n  a > 0 → b > 0 → (∀ (x : ℕ), a ^ 3 + b ^ 3 ≠ x ^ 3)",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → c > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ (a b c : ℕ), a > 0 → b > 0 → c > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → (a ^ 3 + b ^ 3 ≠ c ^ 3)",
    "∀ {a b c : ℕ}, a > 0 ∧ b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ (a b c : ℕ), a > 0 → b > 0 → ¬ (∃ (d : ℕ), a ^ 3 + b ^ 3 = d ^ 3)",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → ¬ (∃ (x : ℕ), a ^ 3 + b ^ 3 = x ^ 3)"]},
  {"theorem": "∀ {n : ℕ}, Even (n * (n + 1))",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "correct": null,
   "comments": "",
   "all-elabs": ["∀ {n : ℕ}, Even (n * (n + 1))"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.FiniteIndex H → Subgroup.index H = 2 → Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.FiniteIndex H → Subgroup.index H = 2 → Subgroup.Normal H"]},
  {"theorem": "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number. ",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), 1 < n → (∃ (p : ℕ), Nat.Prime p ∧ p ∣ n)"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → IsEmpty G",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → IsEmpty G"]},
  {"theorem": "{K : Type u} → [inst : DivisionRing K] → Fintype K → Field K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u} [inst : DivisionRing K], Fintype K → Field K"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "theorem finite_topological_space_is_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α "]},
  {"theorem":
   "∀ {n : ℕ}, Even n → n > 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even n → n > 2 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ}, Even n → n > 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ (n : ℕ), Even n → n > 2 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ}, Even n → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ (n : ℕ), Even n → n > 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ},\n  Even n →\n    n > 0 →\n      ∃ (p q : ℕ),\n        Nat.Prime p ∧\n          Nat.Prime q ∧\n            p + q = n",
    "∀ {n : ℕ}, n > 0 → Even n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]},
  {"theorem": "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)"]},
  {"theorem": "∀ {n : ℕ}, Even (n * n) → Even n",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even (n ^ 2) → Even n", "∀ {n : ℕ}, Even (n * n) → Even n"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (u : Set α), IsOpen u ∧ x ∈ u) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (u : Set α), IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s"]},
  {"theorem":
   "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ?m.12642589 R x = 0",
   "some-correct": null,
   "prompt":
   "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(IsDedekindDomain.HeightOneSpectrum.valuation (DiscreteValuationRing.spectrum R)) x = 0",
    "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(DiscreteValuationRing.valuation inst) x = 0"]},
  {"theorem": "{K : Type u} → [inst : Field K] → Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {F : Type u} [inst : Field F], Ring F",
    "∀ {K : Type u_1} [inst : Field K], Ring K",
    "∀ (F : Type u) [inst : Field F], Ring F",
    "∀ {K : Type u} [inst : Field K], Ring K"]},
  {"theorem": "{R : Type u_1} → [inst : Semiring R] → Group Rˣ",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["def Units (R : Type) [Ring R] : Type ",
    "∀ {R : Type u} [inst : Ring R], Group (Units R)",
    "∀ {R : Type u_1} [inst : Ring R], Group {x : R | IsUnit x}",
    "∀ {R : Type u_1} [inst : Semiring R], Group (Units R)"]},
  {"theorem":
   "∀ {G H : Type u_1} [instG : Group G] [instH : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G H : Type u_1} [instG : Group G] [instH : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G1 G2 : Type u_1} [inst1 : Group G1] [inst2 : Group G2],\n  Monoid.IsTorsionFree (G1 × G2) → Monoid.IsTorsionFree G1 ∧ Monoid.IsTorsionFree G2",
    "∀ {G1 G2 : Type u_1} [inst1 : Group G1] [inst2 : Group G2],\n  Monoid.IsTorsionFree (G1 × G2) → (Monoid.IsTorsionFree G1 ∧ Monoid.IsTorsionFree G2)",
    "∀ {G H : Type u_1} [instG : Group G] [instH : Group H],\n  Monoid.IsTorsionFree (G × H) → (Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H)",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → (Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂)"]}],
 "elaborated": 28}