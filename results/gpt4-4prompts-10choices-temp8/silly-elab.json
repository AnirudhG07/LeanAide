{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["Every set is Lebesgue measurable.",
  "There is no field of order `10`.",
  "All connected components of a topological space are connected.",
  "The ring of integers has a maximal ideal.",
  "The numbers `3`, `4` and `5` form a Pythagorean triple.",
  "A vector space with the empty set as basis is trivial."],
 "elaborated-prompts":
 [{"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p "]},
  {"theorem": "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1",
     "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1",
     "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1",
     "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1",
     "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1",
     "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1",
     "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1",
     "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1",
     "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1",
     "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
    "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
    "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
    "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
    "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
    "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
    "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
    "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
    "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
    "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 "]},
  {"theorem": "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3",
     "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3",
     "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3",
     "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3"],
    ["ℕ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["smallest_odd_prime : Fact (Nat.Prime 3) ∧ ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
    "smallest_odd_prime : Nat.Prime 3 ∧ ∀ (p : ℕ), Nat.Prime p → p % 2 = 1 → p = 3 ",
    "smallest_odd_prime : ℕ ",
    "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
    "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
    "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
    "smallest_odd_prime_is_3 : Fact (Nat.Prime 3) ",
    "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
    "smallest_odd_prime : Fact (Nat.Prime 3) ∧ ∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p % 2 = 1 → 3 ≤ p ",
    "smallest_odd_prime : ∃ p : ℕ, Nat.Prime p ∧ p % 2 = 1 ∧ ∀ q : ℕ, Nat.Prime q ∧ q % 2 = 1 → p ≤ q "]},
  {"theorem": "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
     "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
     "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
     "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
     "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
     "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}"],
    ["Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ ¬Even p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    "Set.Infinite {p | Nat.Prime p ∧ ¬even p} ",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} "]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K"],
    ["{K : Type u_1} → [inst : Field K] → DivisionRing K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K ",
    "∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    "∀ (K : Type u) [inst : Field K], DivisionRing K "]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → Basis ι K V → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι] (h_card : Fintype.card ι = 2), FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), Basis ι K V → FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V "]},
  {"theorem": "∀ (n : ℕ), ∃ s, s = n + 1",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ s, s = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ s, s = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, Nat.succ n = m",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ s, s = n + 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ s, s = n + 1 ",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
    "∀ (n : ℕ), ∃ (s : ℕ), s = n + 1 ",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
    "∀ (n : ℕ), ∃ m, m = n + 1 ",
    "∀ (n : ℕ), ∃ m, n.succ = m ",
    "∀ (n : ℕ), ∃ m, m = n + 1 ",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
    "∀ (n : ℕ), ∃ s, s = n + 1 "]},
  {"theorem": "∀ (n : ℕ), n < Nat.succ n",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ {n : ℕ}, n < Nat.succ n",
     "∀ (n : ℕ), n < n + 1",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ {n : ℕ}, n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n < n.succ ",
    "∀ (n : ℕ), n < n.succ ",
    "∀ (n : ℕ), n < n.succ ",
    "∀ {n : ℕ}, n < n.succ ",
    "∀ (n : ℕ), n < n + 1 ",
    "∀ (n : ℕ), n < n.succ ",
    "∀ {n : ℕ}, n < n.succ ",
    "∀ (n : ℕ), n < n.succ ",
    "∀ (n : ℕ), n < n.succ ",
    "∀ (n : ℕ), n < n.succ "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : MeasureTheory.MeasureSpace α]\n  [inst_3 : BorelSpace α] {A : Set α}, ↑↑MeasureTheory.volume A = 0 → MeasurableSet A",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : MeasureTheory.MeasureSpace α]\n  [inst_3 : BorelSpace α] {A : Set α}, ↑↑MeasureTheory.volume A = 0 → MeasurableSet A"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : MeasureTheory.MeasureSpace α] [inst_3 : BorelSpace α]\n  {A : Set α}, MeasureTheory.volume A = 0 → MeasurableSet A ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α] [inst_3 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_4 : MeasureTheory.Measure.OuterRegular μ] {s : Set α},\n  ↑↑μ s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α]\n  [inst_3 : BorelSpace α] (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ",
    "forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α] \n  [S : MeasurableSpace α] [inst_3 : BorelSpace α] (s : Set α) (μ : MeasureTheory.Measure α),\n  ↑↑μ s = 0 → MeasurableSet s "]},
  {"theorem": "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p"],
    ["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
    "∀ {p : ℕ}, prime p → ¬∃ t, t * t = p "]},
  {"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≠ 2 ∧ p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≠ 2 ∧ p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 "]},
  {"theorem":
   "∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t m, a * b = r ^ 2 + s ^ 2 + t ^ 2 + m ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t m, a * b = r ^ 2 + s ^ 2 + t ^ 2 + m ^ 2",
     "∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
     "∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
     "∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2",
     "∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["∀ {a b x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℕ},\n  a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 →\n    b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
     "∀ {a b x y z w u v t r : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + t ^ 2 + r ^ 2 → ∃ p q s t, a * b = p ^ 2 + q ^ 2 + s ^ 2 + t ^ 2",
     "∀ {a b : ℕ} {c d : ℕ} {x y z w r s t u : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2"],
    ["∀ {a b c d x y z w : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = c ^ 2 + d ^ 2 + x ^ 2 + y ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t m, a * b = r ^ 2 + s ^ 2 + t ^ 2 + m ^ 2 ",
    "∀ {a b x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℕ}, a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 → b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ",
    "∀ {a b x y z w u v t r : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + r ^ 2 → ∃ p q s t, a * b = p ^ 2 + q ^ 2 + s ^ 2 + t ^ 2 ",
    "∀ {a b c d x y z w r s t u : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 →\n  ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ",
    "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 ",
    "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 ",
    "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ",
    "∀ {a b c d x y z w : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = c ^ 2 + d ^ 2 + x ^ 2 + y ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
    "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f "]},
  {"theorem": "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
     "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
     "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
     "∀ {x y : ℕ}, Prime x → Prime y → x ≠ y → x + y ≠ 6",
     "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
     "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
     "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
     "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
     "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6"],
    ["∀ {p q : ℕ}, Prime p → Prime q → p + q = 6 → p = q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
    "∀ {x y : ℕ}, Prime x → Prime y → x ≠ y → x + y ≠ 6 ",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
    "∀ {p q : ℕ}, Prime p → Prime q → p + q = 6 → p = q ",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 "]},
  {"theorem": "∀ (n : ℤ), ¬Irrational ↑n",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ {n : ℤ}, ¬Irrational ↑n",
     "∀ (n : ℤ), Irrational ↑n → False",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ {z : ℤ}, ¬Irrational ↑z",
     "∀ (n : ℤ), ¬Irrational ↑n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℤ), ¬Irrational (↑n : ℝ) ",
    "∀ (n : ℤ), ¬Irrational ↑n ",
    "∀ (z : ℤ), ¬Irrational (↑z : ℝ) ",
    "∀ (z : ℤ), ¬Irrational (↑z) ",
    "∀ {n : ℤ}, ¬Irrational (↑n : ℝ) ",
    "∀ (n : ℤ), Irrational (↑n) → False ",
    "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ",
    "∀ (n : ℤ), ¬Irrational n ",
    "∀ {z : ℤ}, ¬Irrational (↑z) ",
    "∀ (n : ℤ), ¬Irrational (↑n : ℝ) "]},
  {"theorem": "∀ {R : Type u} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {α : Type u} [inst : Ring α], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {α : Type u} [inst : Ring α], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {α : Type u} [inst : Ring α], IsUnit (1 : α) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {α : Type u} [inst : Ring α], IsUnit (1 : α) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) "]},
  {"theorem":
   "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group H "]},
  {"theorem": "∀ (m n : ℕ), ∃ k, m + n = k",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["∀ (m n : ℕ), ∃ k, m + n = k",
     "∀ (m n : ℕ), ∃ a, m + n = a",
     "∀ {m n : ℕ}, ∃ a, m + n = a",
     "∀ (m n : ℕ), ∃ k, m + n = k",
     "∀ {m n : ℕ}, ∃ k, m + n = k",
     "∀ (m n : ℕ), ∃ k, m + n = k",
     "∀ (m n : ℕ), ∃ k, m + n = k",
     "∀ (m n : ℕ), ∃ k, m + n = k",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (m n : ℕ), ∃ k, m + n = k"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
    "∀ (m n : ℕ), ∃ (a : ℕ), m + n = a ",
    "∀ {m n : ℕ}, ∃ (a : ℕ), m + n = a ",
    "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
    "∀ {m n : ℕ}, ∃ (k : ℕ), m + n = k ",
    "∀ (m n : ℕ), ∃ k, m + n = k ",
    "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
    "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
    "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c ",
    "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k "]},
  {"theorem": "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) "]},
  {"theorem": "Fact (Nat.Prime 7)",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups":
   [["Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Fact.prime_7 : Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "inst : Fact (Nat.Prime 7) ",
    "Fact (Nat.Prime 7) ",
    "prime_seven : Fact (Nat.Prime 7) ",
    "Fact.seven_prime : Fact (Nat.Prime 7) ",
    "Fact_7_prime : Fact (Nat.Prime 7) ",
    "Fact.seven.prime : Fact (Nat.Prime 7) ",
    "inst : Fact (Nat.Prime 7) "]},
  {"theorem":
   "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
   "some-correct": null,
   "prompt": "There are `3` prime numbers below `8`.",
   "groups":
   [["List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "∃ n, n = 3 ∧ ∀ (p : ℕ), Nat.Prime p ∧ p < 8 → p = 2 ∨ p = 3 ∨ p = 5",
     "Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3"],
    ["Nat.card ↑{p | p ∈ Finset.range 8 ∧ Nat.Prime p} = 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Nat.primes_3_under_8 : (List.filter Nat.Prime (List.range 8)).length = 3 ",
    "∃ (n : ℕ), n = 3 ∧ ∀ p, Nat.Prime p ∧ p < 8 → p = 2 ∨ p = 3 ∨ p = 5 ",
    "Nat.card {p ∈ Finset.range 8 | Nat.Prime p} = 3 ",
    "prime_count_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 "]},
  {"theorem": "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s "]},
  {"theorem":
   "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s "]},
  {"theorem": "{α : Type u} → [inst : CommRing α] → Monoid α",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{α : Type u} → [inst : CommRing α] → Monoid α",
     "{α : Type u} → [inst : CommRing α] → Monoid α",
     "{α : Type u} → [inst : CommRing α] → Monoid α",
     "{α : Type u} → [inst : CommRing α] → Monoid α",
     "{α : Type u} → [inst : CommRing α] → Monoid α"],
    ["{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R"],
    ["{α : Type u_1} → [inst : CommRing α] → Monoid α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : CommRing α], Monoid α ",
    "∀ {α : Type u_1} [inst : CommRing α], Monoid α ",
    "∀ {α : Type u} [inst : CommRing α], Monoid α ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {α : Type u} [inst : CommRing α], Monoid α ",
    "∀ {α : Type u} [inst : CommRing α], Monoid α ",
    "∀ {α : Type u} [inst : CommRing α], Monoid α ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R ",
    "∀ {R : Type u} [inst : CommRing R], Monoid R "]},
  {"theorem": "∀ {n : ℕ}, n % 2 = 1 → ∃ x y, x ≠ y ∧ n = x + y",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ {n : ℕ}, n % 2 = 1 → ∃ x y, x ≠ y ∧ n = x + y",
     "∀ {n : ℕ}, n % 2 = 1 → ∃ x y, x ≠ y ∧ n = x + y",
     "∀ (n : ℕ), n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {a : ℕ}, a % 2 = 1 → ∃ x y, x ≠ y ∧ a = x + y",
     "∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b"],
    ["∀ (n : ℕ), n % 2 = 1 → ∃ a b, n = a + b ∧ a ≠ b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, n % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ n = x + y ",
    "∀ {n : ℕ}, n % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ n = x + y ",
    "∀ (n : ℕ), n % 2 = 1 → ∃ (a b : ℕ), a ≠ b ∧ n = a + b ",
    "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ {a : ℕ}, a % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ a = x + y ",
    "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    "∀ (n : ℕ), n % 2 = 1 → ∃ a b : ℕ, n = a + b ∧ a ≠ b "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] {x : G}, IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [h : Subsingleton G] (x : G), IsOfFinOrder x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [Subsingleton G] {x : G}, IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] [h : Subsingleton G] (x : G), IsOfFinOrder x "]},
  {"theorem": "∀ {n : ℕ}, Even (n * n) ↔ Even n",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups": [["∀ {n : ℕ}, Even (n * n) ↔ Even n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
    "∀ {n : ℕ}, Even (n * n) ↔ Even n ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
    "∀ {n : ℕ}, even n → even (n ^ 2) ",
    "∀ (n : ℕ), Even (n ^ 2) ↔ Even n ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
    "∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ",
    "∀ {n : ℕ}, Even n → Even (n ^ 2) "]},
  {"theorem": "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R",
     "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R",
     "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R"],
    ["∀ {K : Type u} [inst : CommRing K] [divisionRing : DivisionRing K], IsField K",
     "∀ {K : Type u} [inst : CommRing K] [h : DivisionRing K], IsField K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : CommRing K] [divisionRing : DivisionRing K], IsField K ",
    "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R ",
    "∀ {K : Type u} [inst : CommRing K] [h : DivisionRing K], IsField K ",
    "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R ",
    "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R "]},
  {"theorem": "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
     "∀ {α : Type u} [inst : One α], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1 ",
    "∀ {α : Type u} [inst : One α], id 1 = 1 "]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x"],
    ["∀ {α : Type u} (x : α), x ∈ Function.fixedPoints id"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ",
    "∀ {α : Type u} (x : α), x ∈ Function.fixedPoints (id : α → α) ",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x "]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : MetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : MetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "diam_singleton {α : Type u} [inst : PseudoMetricSpace α] {x : α} : Metric.diam {x} = 0 ",
    "forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 "]},
  {"theorem": "∀ {G : Type u} [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G ",
    "∀ {G : Type u} [inst : Group G], Nonempty G "]}],
 "elaborated": 34}