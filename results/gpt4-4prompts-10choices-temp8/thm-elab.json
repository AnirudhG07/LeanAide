{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["If every proper closed subset of a topological space is compact, then the space itself is compact.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian.",
  "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≡ 1 [MOD 4] → ∃ x y, x ^ 2 + y ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≡ 1 [MOD 4] → ∃ x y, x ^ 2 + y ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p "]},
  {"theorem":
   "∀ {u v x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  u = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    v = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ r₁ r₂ r₃ r₄, u * v = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {u v x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  u = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    v = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ r₁ r₂ r₃ r₄, u * v = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
     "∀ {a b x y z w u v s t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2",
     "∀ {a b x y z w u v s t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
     "∀ {a b x y z w u v s t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
     "∀ {a b x y z w u v t s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
     "∀ {a b x y z w u v s t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2",
     "∀ {a b x y z w u v t s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2"],
    ["∀ {a b x y u v m n : ℕ},\n  a = x ^ 2 + y ^ 2 + m ^ 2 + n ^ 2 →\n    b = u ^ 2 + v ^ 2 + m ^ 2 + n ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2",
     "∀ {a b x y u v p q : ℕ},\n  a = x ^ 2 + y ^ 2 + p ^ 2 + q ^ 2 →\n    b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"],
    ["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {u v x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ}, u = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 → v = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ r₁ r₂ r₃ r₄, u * v = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ",
    "∀ {a b x y u v m n : ℕ}, a = x ^ 2 + y ^ 2 + m ^ 2 + n ^ 2 → b = u ^ 2 + v ^ 2 + m ^ 2 + n ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ",
    "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ",
    "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ",
    "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ",
    "∀ {a b x y z w u v t s : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ",
    "∀ {a b x y u v p q : ℕ}, a = x ^ 2 + y ^ 2 + p ^ 2 + q ^ 2 → b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ",
    "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ",
    "∀ {a b x y z w u v t s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 "]},
  {"theorem":
   "{α : Type u_1} → [self : Semiring α] → (∀ (a : α), a * a = a) → CommSemiring α",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "groups":
   [["{α : Type u_1} → [self : Semiring α] → (∀ (a : α), a * a = a) → CommSemiring α"],
    ["{α : Type u_1} → [inst : Semiring α] → (∀ (x : α), x * x = x) → CommRing α"],
    ["{α : Type u_1} → [self : Ring α] → (∀ (a : α), a * a = a) → CommRing α"],
    ["∀ {α : Type u_1} [inst : Mul α] [inst_1 : Add α] [inst_2 : Zero α] [inst_3 : One α] (a b : α),\n  (∀ (c : α), c * c = c) → a * b = b * a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : Semiring α] (H : ∀ (x : α), x * x = x), CommRing α ",
    "∀ {α : Type u_1} [self : Ring α] (h : ∀ (a : α), a * a = a), CommRing α ",
    "∀ {α : Type u_1} [inst : Mul α] [inst_1 : Add α] [inst_2 : Zero α] [inst_3 : One α] (a b : α) (h : ∀ (c : α), c * c = c), a * b = b * a ",
    "∀ {α : Type u_1} [self : Semiring α] (H : ∀ (a : α), a * a = a), CommSemiring α "]},
  {"theorem": "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p - q = 2 ∧ p > n",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "groups":
   [["∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p - q = 2 ∧ p > n"],
    ["∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p < q → p + 2 = q → ∃ k a b, a ≠ b ∧ Nat.Prime a ∧ Nat.Prime b ∧ a + 2 = b ∧ a > p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ (f : ℕ → ℕ), (∀ n, Nat.Prime (f n)) ∧ (∀ n, f (n + 1) - f n = 2) ",
    "∃ f : ℕ → ℕ, ∀ n, ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ q - p = 2 ∧ f n = q ",
    "∃ (f : ℕ → ℕ × ℕ), (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ Function.Injective f ",
    "∃ (f : ℕ → ℕ × ℕ), ∀ (n : ℕ), ∃ (m : ℕ) (H : m > n), Nat.Prime (f m).fst ∧ Nat.Prime (f m).snd ∧ (f m).snd - (f m).fst = 2 ",
    "∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p < q → p + 2 = q → ∃ k : ℕ, ∃ a b : ℕ, a ≠ b ∧ Nat.Prime a ∧ Nat.Prime b ∧ a + 2 = b ∧ a > p ",
    "ExistsInfinitelyManyPairsOfPrimesWithDiff2 : ∃ p q, p ≠ q ∧ (p - q = 2 ∨ q - p = 2) ∧ Nat.Prime p ∧ Nat.Prime q ",
    "∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 2 = 1 ∧ q % 2 = 1 → ∃ n, ∀ m ≥ n, ∃ p₁ q₁, Fact (Nat.Prime p₁) ∧ Fact (Nat.Prime q₁) ∧ p₁ % 2 = 1 ∧ q₁ % 2 = 1 ∧ p₁ + 2 = q₁ ∧ p₁ > m ",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p - q = 2 ∧ p > n "]},
  {"theorem":
   "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
     "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
     "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
     "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R"],
    ["(D : Type u) → [inst : Fintype D] → [inst_1 : DivisionRing D] → Field D",
     "(D : Type u) → [inst : Fintype D] → [inst_1 : DivisionRing D] → Field D"],
    ["{α : Type u_1} → [inst : Fintype α] → [inst_1 : DivisionRing α] → Field α"],
    ["{D : Type u_1} → [inst : Fintype D] → [inst_1 : DivisionRing D] → Field D"],
    ["{R : Type u_1} → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R"],
    ["(R : Type u_1) → [inst : Ring R] → [inst_1 : Fintype R] → [inst_2 : Nontrivial R] → [inst_3 : DivisionRing R] → Field R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
    "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ {D : Type u_1} [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
    "∀ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
    "∀ (R : Type u_1) [inst : Ring R] [inst_1 : Fintype R] [inst_2 : Nontrivial R] [inst_3 : DivisionRing R], Field R ",
    "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DivisionRing α], Field α ",
    "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R "]},
  {"theorem":
   "∀ {α : Type u} {β : Type v}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "groups":
   [["∀ {α : Type u} {β : Type v}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)",
     "∀ {α : Type u} {β : Type v}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)",
     "∀ {α : Type u} {β : Type v}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)"],
    ["∀ {α β : Type u}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)"],
    ["∀ {α : Type u} {β : Type v}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → ∃ h, True"],
    ["∀ {X Y : Type u}, Nonempty (X ↪ Y) ∧ Nonempty (Y ↪ X) → Nonempty (X ≃ Y)"],
    ["∀ {α : Type u_1} {β : Type u_2}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)"],
    ["∀ {α : Type u} {β : Type u'} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"],
    ["∀ {α : Type u} {β : Type v}, (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) ",
    "∀ {α : Type u} {β : Type v}, \n  (∃ (f : α → β), Function.Injective f) → \n  (∃ (g : β → α), Function.Injective g) → \n  (∃ (h : α ≃ β), True) ",
    "∀ {X Y : Type u},\n  (Nonempty (Function.Embedding X Y) ∧ Nonempty (Function.Embedding Y X)) →\n  Nonempty (X ≃ Y) ",
    "∀ {α : Type u} {β : Type v},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → Nonempty (α ≃ β) ",
    "∀ {α : Type u} {β : Type v}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) ",
    "∀ {α : Type u} {β : Type u'} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ",
    "∀ {α : Type u} {β : Type v} (f : α ↪ β) (g : β ↪ α),\n  Nonempty (α ≃ β) ",
    "∀ {α β : Type u}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → Nonempty (α ≃ β) ",
    "∀ {α : Type u} {β : Type v}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) "]},
  {"theorem":
   "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! z, SimpleGraph.Adj G v z ∧ SimpleGraph.Adj G w z) →\n    ∃ x, ∀ (y : V), y ≠ x → SimpleGraph.Adj G x y",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "groups":
   [["∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! z, SimpleGraph.Adj G v z ∧ SimpleGraph.Adj G w z) →\n    ∃ x, ∀ (y : V), y ≠ x → SimpleGraph.Adj G x y",
     "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x) →\n    ∃ x, ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → ∃! w, SimpleGraph.Adj G u w ∧ SimpleGraph.Adj G v w) →\n    ∃ x, ∀ (y : V), x ≠ y → SimpleGraph.Adj G x y"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → ∃! w, SimpleGraph.Adj G u w ∧ SimpleGraph.Adj G v w) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n    ∃ x, ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v"],
    ["∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → ∃! w, SimpleGraph.Adj G u w ∧ SimpleGraph.Adj G v w) →\n    ∃ y, ∀ (x : V), x ≠ y → SimpleGraph.Adj G x y"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → ∃! (w : V), SimpleGraph.Adj G u w ∧ SimpleGraph.Adj G v w) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj], (∀ (v w : V), v ≠ w → ∃! (z : V), SimpleGraph.Adj G v z ∧ SimpleGraph.Adj G w z) → ∃ (x : V), ∀ (y : V), y ≠ x → SimpleGraph.Adj G x y ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n  ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v ",
    "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (x : V), SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x) →\n  ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v ",
    "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → ∃! (w : V), G.Adj u w ∧ G.Adj v w) → ∃ (y : V), ∀ (x : V), x ≠ y → SimpleGraph.Adj G x y ",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → (∃! w, G.Adj u w ∧ G.Adj v w)) → ∃ x, ∀ y, x ≠ y → G.Adj x y "]},
  {"theorem":
   "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m",
   "some-correct": null,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "groups":
   [["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m "]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],
    ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],
    ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1",
     "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1",
     "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1",
     "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1",
     "∀ {α : Type u} [t : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t_1 : Set α),\n      IsClosed s →\n        IsClosed t_1 → Disjoint s t_1 → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t_1 → f x = 1",
     "∀ {α : Type u} [t : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t_1 : Set α),\n      IsClosed s →\n        IsClosed t_1 → Disjoint s t_1 → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t_1 → f x = 1",
     "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1",
     "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ ∀ (x : α), x ∈ t → f x = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ \n  (∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1)) ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ",
    "forall {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ",
    "∀ {α : Type u} [t : TopologicalSpace α], NormalSpace α ↔\n  (∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1)) ",
    "∀ {α : Type u} [t : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ (∀ x : α, x ∈ s → f x = 0) ∧ (∀ x : α, x ∈ t → f x = 1) ",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {f : α → α},\n  Continuous f →\n    f 0 = 0 →\n      f 1 = 1 →\n        (∃ x, x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n          ∀ (n : ℕ), n > 0 → ∃ x, x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n x",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "groups":
   [["∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {f : α → α},\n  Continuous f →\n    f 0 = 0 →\n      f 1 = 1 →\n        (∃ x, x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n          ∀ (n : ℕ), n > 0 → ∃ x, x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n x"],
    ["∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] {_inst_2 : TopologicalSpace α} {_inst_3 : OrderTopology α}\n  (f : α → α),\n  Continuous f →\n    (∀ (x : α), x ∈ Set.Icc 0 1 → f x ∈ Set.Icc 0 1) →\n      ∀ (x : α), Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), n > 0 → ∃ y, Function.IsPeriodicPt f n y"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [Preorder α] [_inst_1 : TopologicalSpace α] [_inst_2 : OrderTopology α] {f : α → α} (hf : Continuous f)\n  (h₀ : ∀ x, x ≤ f x) (h₁ : ∀ x, f x ≤ 1) {x₀ : α}, Function.IsPeriodicPt f 3 x₀ → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x ",
    "∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] {_inst_2 : TopologicalSpace α} {_inst_3 : OrderTopology α}\n  (f : α → α) (hf₀ : Continuous f) (hf₁ : ∀ x, x ∈ set.Icc (0 : α) 1 → f x ∈ set.Icc (0 : α) 1) (x : α),\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), n > 0 → ∃ y, Function.IsPeriodicPt f n y ",
    "∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] [inst : TopologicalSpace α] [inst_2 : OrderTopology α]\n  (f : (α × α) → α × α), (∀ x : α × α, x ∈ Set.Icc (0, 0) (1, 1) → f x ∈ Set.Icc (0, 0) (1, 1)) →\n  (∃ x : α × α, Function.IsPeriodicPt f 3 x) → ∀ n : ℕ, n > 0 → ∃ x : α × α, Function.IsPeriodicPt f n x ",
    "∀ {α : Type u_1} [inst : LinearOrderedField α] {f : α → α} (h₀ : ∀ x, 0 ≤ x → x ≤ 1 → 0 ≤ f x → f x ≤ 1)\n  (h₁ : ∃ x, Function.IsPeriodicPt f 3 x), ∀ n, ∃ x, Function.IsPeriodicPt f (n + 1) x ",
    "∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] [_inst_2 : TopologicalSpace α] [_inst_3 : OrderTopology α] {f : α → α},\n  Continuous f → (∀ x : α, 0 ≤ x → x ≤ 1 → f x ∈ Set.Icc 0 1) → (∃ x : α, Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), n > 0 → ∃ x : α, Function.IsPeriodicPt f n x ",
    "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {f : α → α},\n  Continuous f → f 0 = 0 → f 1 = 1 →\n  (∃ x : α, x ∈ set.Icc (0 : α) 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ n : ℕ, n > 0 → ∃ x : α, x ∈ set.Icc (0 : α) 1 ∧ Function.IsPeriodicPt f n x "]},
  {"theorem":
   "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.19745028, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "groups":
   [["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.19745028, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)",
     "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.19745028, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)",
     "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.19745028, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)",
     "{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.19745028, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.19748266, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.19746237, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n    CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X)\n  (hY : CategoryTheory.Limits.IsTerminal Y), Unique (X ≅ Y) "]},
  {"theorem": "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "groups":
   [["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"],
    ["∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ",
     "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ "]},
  {"theorem":
   "∀ {x y z : ℕ}, x > 0 → y > 0 → x * x * x + y * y * y ≠ z * z * z",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "groups":
   [["∀ {x y z : ℕ}, x > 0 → y > 0 → x * x * x + y * y * y ≠ z * z * z",
     "∀ {n m k : ℕ}, n > 0 → m > 0 → n * n * n + m * m * m ≠ k * k * k",
     "∀ {n m k : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ k * k * k",
     "∀ {m n k : ℕ}, 0 < m → 0 < n → m * m * m + n * n * n ≠ k * k * k",
     "∀ {m n k : ℕ}, 0 < m → 0 < n → m * m * m + n * n * n ≠ k * k * k",
     "∀ {n m k : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ k * k * k",
     "∀ {n m k : ℕ}, n > 0 → m > 0 → n * n * n + m * m * m ≠ k * k * k",
     "∀ {x y z : ℕ}, x > 0 → y > 0 → x * x * x + y * y * y ≠ z * z * z",
     "∀ {n m l : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ l * l * l"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {x y z : ℕ}, x > 0 → y > 0 → x * x * x + y * y * y ≠ z * z * z ",
    "∀ {m n k : ℕ}, 0 < m → 0 < n → m^3 + n^3 ≠ k^3 ",
    "∀ {n m k : ℕ}, n > 0 → m > 0 → n * n * n + m * m * m ≠ k * k * k ",
    "∀ {n m k : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ k * k * k ",
    "∀ {m n k : ℕ}, 0 < m → 0 < n → m * m * m + n * n * n ≠ k * k * k ",
    "∀ {m n k : ℕ}, 0 < m → 0 < n → m * m * m + n * n * n ≠ k * k * k ",
    "∀ {n m k : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ k * k * k ",
    "∀ {n m k : ℕ}, n > 0 → m > 0 → n * n * n + m * m * m ≠ k * k * k ",
    "∀ {x y z : ℕ}, x > 0 → y > 0 → x * x * x + y * y * y ≠ z * z * z ",
    "∀ {n m l : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ l * l * l "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], (∀ (a : G), a * a = 1) → ∀ (x y : G), Commute x y",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], (∀ (a : G), a * a = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (a : G), a * a = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x ^ 2 = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b ",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y "]},
  {"theorem": "∀ (n : ℕ), Even (n * (n + 1))",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "groups":
   [["∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))"],
    ["∀ (n : ℕ), 2 ∣ n * (n + 1)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), even (n * (n + 1)) ",
    "∀ (n : ℕ), 2 ∣ (n * (n + 1)) "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} (cond : Subgroup.index H = 2), Subgroup.Normal H "]},
  {"theorem":
   "∀ {α : Type u_1} {G : Type u_2} [inst : Group G], (α → G) → Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "groups":
   [["∀ {α : Type u_1} {G : Type u_2} [inst : Group G], (α → G) → Monoid.IsTorsionFree G"],
    ["∀ {G : Type u_1} [inst : Group G] [inst2 : IsFreeGroup G], Monoid.IsTorsionFree G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {G : Type u_1} [inst : Group G] [inst2 : IsFreeGroup G], Monoid.IsTorsionFree G ",
    "∀ {α : Type u_1} {G : Type u_2} [inst : Group G],\n  (α → G) → Monoid.IsTorsionFree G "]},
  {"theorem": "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "groups":
   [["∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "]},
  {"theorem":
   "{G : Type u_1} → [inst : Group G] → [inst_1 : Finite G] → Monoid.IsTorsionFree G → G ≃ Unit",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → [inst_1 : Finite G] → Monoid.IsTorsionFree G → G ≃ Unit",
     "{G : Type u_1} → [inst : Group G] → [inst_1 : Finite G] → Monoid.IsTorsionFree G → G ≃ Unit"],
    ["{G : Type u_1} → [inst : Group G] → [inst_1 : Fintype G] → Monoid.IsTorsionFree G → G ≃ Unit"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → G ≃ Unit ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → G ≃ Unit ",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → G ≃ Unit "]},
  {"theorem":
   "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
     "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
     "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R",
     "(R : Type u_1) → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R"],
    ["(D : Type u) → [inst : Fintype D] → [inst_1 : DivisionRing D] → Field D",
     "(D : Type u) → [inst : Fintype D] → [inst_1 : DivisionRing D] → Field D"],
    ["{α : Type u_1} → [inst : Fintype α] → [inst_1 : DivisionRing α] → Field α"],
    ["{D : Type u_1} → [inst : Fintype D] → [inst_1 : DivisionRing D] → Field D"],
    ["{R : Type u_1} → [inst : Fintype R] → [inst_1 : DivisionRing R] → Field R"],
    ["(R : Type u_1) → [inst : Ring R] → [inst_1 : Fintype R] → [inst_2 : Nontrivial R] → [inst_3 : DivisionRing R] → Field R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
    "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ {D : Type u_1} [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
    "∀ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ",
    "∀ (R : Type u_1) [inst : Ring R] [inst_1 : Fintype R] [inst_2 : Nontrivial R] [inst_3 : DivisionRing R], Field R ",
    "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DivisionRing α], Field α ",
    "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ",
    "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α "]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f",
   "some-correct": null,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "groups":
   [["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f "]},
  {"theorem":
   "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "groups":
   [["∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ {n : ℕ}, n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ {n : ℕ}, n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
     "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, n = p + q ∧ Nat.Prime p ∧ Nat.Prime q"],
    ["∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ {n : ℕ}, n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), n = p + q ∧ Nat.Prime p ∧ Nat.Prime q ",
    "∀ {n : ℕ}, n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "Goldbach's_conjecture : ∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ",
    "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q "]},
  {"theorem":
   "∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [inst_6 : Fintype ι]\n  (b : Basis ι R M), Polynomial.eval (?m.25705241 f b) (Matrix.charpoly (?m.25705245 f b)) = 0",
   "some-correct": null,
   "prompt": "Every matrix satisfies its own characteristic polynomial.",
   "groups":
   [["∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [inst_6 : Fintype ι]\n  (b : Basis ι R M), Polynomial.eval (?m.25705241 f b) (Matrix.charpoly (?m.25705245 f b)) = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [inst_6 : Fintype ι]\n  (b : Basis ι R M), (Matrix.charpoly (↑(LinearMap.toMatrix b b) f)).eval (↑(LinearMap.toMatrix b b) f) = 0 "]},
  {"theorem": "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "groups":
   [["∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {a : ℝ}, Irrational a → Irrational (Real.sqrt a)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ",
    "∀ {a : ℝ}, Irrational a → Irrational (Real.sqrt a) "]},
  {"theorem": "∀ {n : ℕ}, n * n % 2 = 0 → n % 2 = 0",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "groups": [["∀ {n : ℕ}, n * n % 2 = 0 → n % 2 = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs": ["∀ {n : ℕ}, n * n % 2 = 0 → n % 2 = 0 "]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [Finsupp : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [hf : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [Finsupp : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ",
    "∀ {R : Type u} [inst : CommRing R] [Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ",
    "∀ {R : Type u} [inst : CommRing R] [hf : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ s) → IsOpen s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ t) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, x ∈ U ∧ IsOpen U ∧ U ⊆ s) → IsOpen s "]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], FreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], FreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (g : α), g ≠ 1 → ¬IsOfFinOrder g",
     "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (a : α), a ≠ 1 → ¬IsOfFinOrder a"],
    ["∀ {α : Type u_1} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {α : Type u_1} [inst : Monoid α] {f : FreeGroup α} (x : α), x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {α : Type u_1} [inst : SemigroupWithZero α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G], FreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (g : α), g ≠ 1 → ¬IsOfFinOrder g ",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u_1} [inst : Monoid α] {f : FreeGroup α} (x : α), x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u_1} [inst : Group α] [IsFreeGroup α] (a : α), a ≠ 1 → ¬IsOfFinOrder a ",
    "∀ {α : Type u_1} [inst : SemigroupWithZero α], ∀ x : FreeGroup α, x ≠ 1 → ¬IsOfFinOrder x ",
    "∀ {α : Type u_1} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x "]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {Γ₀ : Type u_2}\n  [inst_3 : LinearOrderedCommMonoidWithZero Γ₀] [inst_4 : Nontrivial Γ₀] (v : Valuation R Γ₀) {x : R},\n  IsUnit x ↔ ?m.34700264 v = 0",
   "some-correct": null,
   "prompt":
   "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {Γ₀ : Type u_2}\n  [inst_3 : LinearOrderedCommMonoidWithZero Γ₀] [inst_4 : Nontrivial Γ₀] (v : Valuation R Γ₀) {x : R},\n  IsUnit x ↔ ?m.34700264 v = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  {Γ₀ : Type u_2} [inst_3 : LinearOrderedCommMonoidWithZero Γ₀] [inst_4 : Nontrivial Γ₀] (v : Valuation R Γ₀)\n  {x : R}, IsUnit x ↔ ↑v x = 0 "]},
  {"theorem":
   "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
   "some-correct": null,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "groups":
   [["∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y"],
    ["∀ {a b N : ℕ}, Nat.gcd a b = 1 → a ≠ 0 → b ≠ 0 → N ≥ a * b - a - b → ∃ x y, N = a * x + b * y"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "forall {a b N : ℕ}, Nat.gcd a b = 1 → a ≠ 0 → b ≠ 0 → N ≥ a * b - a - b → ∃ x y : ℕ, N = a * x + b * y ",
    "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ",
    "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y "]},
  {"theorem": "(K : Type u) → [inst : Field K] → Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K ",
    "∀ (K : Type u) [inst : Field K], Ring K "]},
  {"theorem": "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "groups":
   [["{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ"],
    ["{R : Type u_1} → [inst : Monoid R] → Group Rˣ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {R : Type u_1} [inst : Monoid R], Group (Units R) ",
    "∀ {R : Type u_1} [inst : Ring R], Group (Rˣ) ",
    "∀ {R : Type u_1} [inst : Ring R], Group (Rˣ) ",
    "∀ {R : Type u_1} [inst : Monoid R], Group {x | IsUnit x} ",
    "∀ {R : Type u_1} [inst : Ring R], Group (Rˣ) "]},
  {"theorem":
   "∀ {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "groups":
   [["∀ {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
     "∀ {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂"],
    ["∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  Monoid.IsTorsionFree ((i : η) → Gs i) → ∀ (i : η), Monoid.IsTorsionFree (Gs i)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["forall {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ",
    "∀ {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ",
    "∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  Monoid.IsTorsionFree ((i : η) → Gs i) → ∀ (i : η), Monoid.IsTorsionFree (Gs i) ",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ",
    "forall {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ "]}],
 "elaborated": 36}