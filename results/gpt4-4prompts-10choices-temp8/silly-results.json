[
  {
    "docString": "Every prime number is `2` or odd.",
    "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"}]\n",
    "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- Every prime number is `2` or odd. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p "
    ]
  },
  {
    "docString": "There are infinitely many odd natural numbers.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- There are infinitely many odd natural numbers. -/\ntheorem",
    "choices": [
      "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
      "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
      "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
      "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
      "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
      "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ",
      "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
      "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
      "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ",
      "∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 "
    ]
  },
  {
    "docString": "The smallest odd prime is `3`.",
    "prompts": "[{\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\",\n  \"isProp\": true,\n  \"docString\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"}]\n",
    "prompt_cons": "/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- A natural number is odd iff it has residue `1` or `3` mod `4` -/\ntheorem ∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- The smallest odd prime is `3`. -/\ntheorem",
    "choices": [
      "smallest_odd_prime : Fact (Nat.Prime 3) ∧ ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
      "smallest_odd_prime : Nat.Prime 3 ∧ ∀ (p : ℕ), Nat.Prime p → p % 2 = 1 → p = 3 ",
      "smallest_odd_prime : ℕ ",
      "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
      "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
      "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
      "smallest_odd_prime_is_3 : Fact (Nat.Prime 3) ",
      "smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ",
      "smallest_odd_prime : Fact (Nat.Prime 3) ∧ ∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p % 2 = 1 → 3 ≤ p ",
      "smallest_odd_prime : ∃ p : ℕ, Nat.Prime p ∧ p % 2 = 1 ∧ ∀ q : ℕ, Nat.Prime q ∧ q % 2 = 1 → p ≤ q "
    ]
  },
  {
    "docString": "There are infinitely many odd prime numbers.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\",\n  \"isProp\": true,\n  \"docString\": \"The only divisors of prime powers are prime powers. \"},\n {\"theorem\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"theorem\": \"∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The only divisors of prime powers are prime powers. -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\n  Irreducible p →\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n) :=\n\n/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem ∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p :=\n\n/-- There are infinitely many odd prime numbers. -/\ntheorem",
    "choices": [
      "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
      "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
      "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
      "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
      "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
      "Set.Infinite {p | Nat.Prime p ∧ ¬even p} ",
      "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
      "Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
      "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
      "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} "
    ]
  },
  {
    "docString": "If a vector space has dimension `2` then it is finite dimensional.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. \"}]\n",
    "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι) :=\n\n/-- If a vector space has a finite dimension, the index set of `Basis.ofVectorSpace` is finite. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V < Cardinal.aleph0 → Set.Finite (Basis.ofVectorSpaceIndex K V) :=\n\n/-- If a vector space has dimension `2` then it is finite dimensional. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
      "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "
    ]
  },
  {
    "docString": "Every field is a division ring.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\",\n  \"isProp\": true,\n  \"docString\": \"A valued division ring is separated. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"}]\n",
    "prompt_cons": "/-- A valued division ring is separated. -/\ntheorem ∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\n  [inst_2 : Valued K Γ₀], SeparatedSpace K :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ∈ S :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ∈ S :=\n\n/-- Every field is a division ring. -/\ntheorem",
    "choices": [
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K ",
      "∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
      "∀ (K : Type u) [inst : Field K], DivisionRing K "
    ]
  },
  {
    "docString": "If a space has dimension `2` then it is finite dimensional.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\",\n  \"isProp\": true,\n  \"docString\": \"All hom spaces are finite dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"}]\n",
    "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- All hom spaces are finite dimensional. -/\ntheorem ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- If a space has dimension `2` then it is finite dimensional. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι] (h_card : Fintype.card ι = 2), FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), Basis ι K V → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  (h : Fintype.card ι = 2), Basis ι K V → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [_ : Cardinal.mk ι = 2], Basis ι K V → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Unique (Fin 2) ι], Basis ι K V → FiniteDimensional K V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  (h_dim : Fintype.card ι = 2), Basis ι K V → FiniteDimensional K V "
    ]
  },
  {
    "docString": "Every natural number has a successor.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\",\n  \"isProp\": true,\n  \"docString\": \"Every ordinal has a fundamental sequence. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Every ordinal has a fundamental sequence. -/\ntheorem ∀ (a : Ordinal.{u}), ∃ f, Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f :=\n\n/-- Every natural number has a successor. -/\ntheorem",
    "choices": [
      "∀ (n : ℕ), ∃ s, s = n + 1 ",
      "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
      "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
      "∀ (n : ℕ), ∃ (s : ℕ), s = n + 1 ",
      "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
      "∀ (n : ℕ), ∃ m, m = n + 1 ",
      "∀ (n : ℕ), ∃ m, n.succ = m ",
      "∀ (n : ℕ), ∃ m, m = n + 1 ",
      "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ",
      "∀ (n : ℕ), ∃ s, s = n + 1 "
    ]
  },
  {
    "docString": "Every natural number is less than its successor.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\": \"∀ {α : Type u_1} [self : CompleteLattice α] (x : α), x ≤ ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any element is less than the top one. \"},\n {\"theorem\": \"∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b ≥ 2 \"}]\n",
    "prompt_cons": "/-- Any element of a set is less than the set supremum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s :=\n\n/-- Any element is less than the top one. -/\ntheorem ∀ {α : Type u_1} [self : CompleteLattice α] (x : α), x ≤ ⊤ :=\n\n/-- The digits in the base b expansion of n are all less than b, if b ≥ 2 -/\ntheorem ∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b :=\n\n/-- Every natural number is less than its successor. -/\ntheorem",
    "choices": [
      "∀ (n : ℕ), n < n.succ ",
      "∀ (n : ℕ), n < n.succ ",
      "∀ (n : ℕ), n < n.succ ",
      "∀ {n : ℕ}, n < n.succ ",
      "∀ (n : ℕ), n < n + 1 ",
      "∀ (n : ℕ), n < n.succ ",
      "∀ {n : ℕ}, n < n.succ ",
      "∀ (n : ℕ), n < n.succ ",
      "∀ (n : ℕ), n < n.succ ",
      "∀ (n : ℕ), n < n.succ "
    ]
  },
  {
    "docString": "Every set is Lebesgue measurable.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every set there exists a measurable superset of the same measure. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\\n  OpensMeasurableSpace α\",\n  \"isProp\": true,\n  \"docString\": \"In a `BorelSpace` all open sets are measurable. \"}]\n",
    "prompt_cons": "/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ) :=\n\n/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For every set there exists a measurable superset of the same measure. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s :=\n\n/-- In a `BorelSpace` all open sets are measurable. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  OpensMeasurableSpace α :=\n\n/-- Every set is Lebesgue measurable. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α], EverySetMeasurable α ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α], MeasurableSet s ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.Measure.IsLebesgue α],\n  ∃ t, MeasurableSet t ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α], \n  CompleteSpace α ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.Measure α] [inst_2 : MeasureTheory.MeasureSpace α], \n  CompleteSpace α ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α], CompleteSpace α ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  [inst_3 : MeasureTheory.MeasureSpace α], MeasureTheory.Measure.ae_measurable Set.Univ ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.Measure α] [inst_2 : BorelSpace α]\n  (s : Set α), MeasurableSet s ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.Measure α], LebesgueMeasurable ⊤ ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.Measure α] [inst_2 : MeasureTheory.Measure.Space α],\n  Complete α "
    ]
  },
  {
    "docString": "Every set of Borel measure zero is Lebesgue measurable.",
    "prompts": "[{\"theorem\": \"↑↑MeasureTheory.volume {x | Liouville x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The set of Liouville numbers has Lebesgue measure zero. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For the outer measure coming from a content, all Borel sets are measurable. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left invariant Borel measures on a measurable group are unique (up to a scalar). \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. \"}]\n",
    "prompt_cons": "/-- The set of Liouville numbers has Lebesgue measure zero. -/\ntheorem ↑↑MeasureTheory.volume {x | Liouville x} = 0 :=\n\n/-- For the outer measure coming from a content, all Borel sets are measurable. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G], S ≤ MeasureTheory.OuterMeasure.caratheodory (MeasureTheory.Content.outerMeasure μ) :=\n\n/-- Left invariant Borel measures on a measurable group are unique (up to a scalar). -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  {s : Set G} [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulLeftInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsMulLeftInvariant ν],\n  MeasurableSet s → ↑↑ν s ≠ 0 → ↑↑ν s ≠ ⊤ → μ = (↑↑μ s / ↑↑ν s) • ν :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- Every set of Borel measure zero is Lebesgue measurable. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : MeasureTheory.MeasureSpace α] [inst_3 : BorelSpace α]\n  {A : Set α}, MeasureTheory.volume A = 0 → MeasurableSet A ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α] [inst_3 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_4 : MeasureTheory.Measure.OuterRegular μ] {s : Set α},\n  ↑↑μ s = 0 → MeasurableSet s ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α]\n  [inst_3 : BorelSpace α] (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ",
      "∀ {α : Type u_1} [inst : EmetricSpace α] [S : MeasurableSpace α] [inst_1 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.Measure.OuterRegular μ] {s : Set α},\n  ↑↑μ s = 0 → MeasurableSet s ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ",
      "∀ {X : Type u_1} [inst : EmetricSpace X] [inst_1 : MeasurableSpace X] [inst_2 : BorelSpace X] {s : Set X},\n  ↑↑MeasureTheory.volume s = 0 → MeasurableSet s ",
      "forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α] \n  [S : MeasurableSpace α] [inst_3 : BorelSpace α] (s : Set α) (μ : MeasureTheory.Measure α),\n  ↑↑μ s = 0 → MeasurableSet s ",
      "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.Measure α],\n  ∀ {s : Set α}, ↑↑MeasureTheory.volume s = 0 → MeasurableSet s ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : MeasurableSpace X] [inst_2 : BorelSpace X]\n  (μ : MeasureTheory.Measure X) [inst_3 : MeasureTheory.Measure.IsLebesgueMeasure μ] {s : Set X},\n  MeasurableSet s → ↑↑μ s = 0 → MeasureTheory.LeBesgueDecomposition.MeasurableLeEval ν μ s = 0 "
    ]
  },
  {
    "docString": "No prime number is a perfect square.",
    "prompts": "[{\"theorem\": \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"}]\n",
    "prompt_cons": "/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem ∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n :=\n\n/-- In a finite field of odd characteristic, not every element is a square. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- No prime number is a perfect square. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ",
      "∀ {p : ℕ}, prime p → ¬∃ t, t * t = p "
    ]
  },
  {
    "docString": "Every odd prime number is greater than `2`.",
    "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"}]\n",
    "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- Every odd prime number is greater than `2`. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≠ 2 ∧ p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 "
    ]
  },
  {
    "docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
    "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ∀ (a b c d x y z w : ℕ),\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem",
    "choices": [
      "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t m, a * b = r ^ 2 + s ^ 2 + t ^ 2 + m ^ 2 ",
      "∀ {a b c d x y z w : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = c ^ 2 + d ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ",
      "∀ {a b x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℕ}, a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 → b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ",
      "∀ {a b x y z w u v t r : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + r ^ 2 → ∃ p q s t, a * b = p ^ 2 + q ^ 2 + s ^ 2 + t ^ 2 ",
      "∀ {a b c d x y z w r s t u : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 →\n  ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ",
      "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 ",
      "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 ",
      "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ",
      "∀ {a b c d x y z w : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = c ^ 2 + d ^ 2 + x ^ 2 + y ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
      "∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 "
    ]
  },
  {
    "docString": "Every compact topological space is locally compact.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"}]\n",
    "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- Every compact topological space is locally compact. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α "
    ]
  },
  {
    "docString": "Every continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"}]\n",
    "prompt_cons": "/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- Every continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f "
    ]
  },
  {
    "docString": "`6` is not the sum of two distinct prime numbers.",
    "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"`2` is not a factor of an odd natural number. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → Monoid (M i)] (self : FreeProduct.Word M),\\n  List.Chain' (fun l l' => l.fst ≠ l'.fst) self.toList\",\n  \"isProp\": true,\n  \"docString\": \"Adjacent letters are not from the same summand. \"},\n {\"theorem\":\n  \"∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\\n`centralBinom n`. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"}]\n",
    "prompt_cons": "/-- `2` is not a factor of an odd natural number. -/\ntheorem ∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2 :=\n\n/-- Adjacent letters are not from the same summand. -/\ntheorem ∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → Monoid (M i)] (self : FreeProduct.Word M),\n  List.Chain' (fun l l' => l.fst ≠ l'.fst) self.toList :=\n\n/-- Primes greater than about `2 * n / 3` and less than `n` do not appear in the factorization of\n`centralBinom n`. -/\ntheorem ∀ {p n : ℕ}, 2 < n → p ≤ n → 2 * n < 3 * p → ↑(Nat.factorization (Nat.centralBinom n)) p = 0 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- `6` is not the sum of two distinct prime numbers. -/\ntheorem",
    "choices": [
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
      "∀ {x y : ℕ}, Prime x → Prime y → x ≠ y → x + y ≠ 6 ",
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
      "∀ {p q : ℕ}, Prime p → Prime q → p + q = 6 → p = q ",
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ",
      "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 "
    ]
  },
  {
    "docString": "No integer is irrational.",
    "prompts": "[{\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\",\n  \"isProp\": true,\n  \"docString\": \"Every finite convergent corresponds to a rational number. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"}]\n",
    "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- Every finite convergent corresponds to a rational number. -/\ntheorem ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q :=\n\n/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem ∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2} :=\n\n/-- No integer is irrational. -/\ntheorem",
    "choices": [
      "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ",
      "∀ (n : ℤ), ¬Irrational ↑n ",
      "∀ (z : ℤ), ¬Irrational (↑z : ℝ) ",
      "∀ (z : ℤ), ¬Irrational (↑z) ",
      "∀ {n : ℤ}, ¬Irrational (↑n : ℝ) ",
      "∀ (n : ℤ), Irrational (↑n) → False ",
      "∀ (n : ℤ), ¬Irrational (↑n : ℝ) ",
      "∀ (n : ℤ), ¬Irrational n ",
      "∀ {z : ℤ}, ¬Irrational (↑z) ",
      "∀ (n : ℤ), ¬Irrational (↑n : ℝ) "
    ]
  },
  {
    "docString": "The identity element in a ring is a unit.",
    "prompts": "[{\"theorem\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subring contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\",\n  \"isProp\": true,\n  \"docString\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"}]\n",
    "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Ring α], IsRingHom id :=\n\n/-- A subring contains the ring's 1. -/\ntheorem ∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s :=\n\n/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- An element of a ring multiplied by the additive inverse of one is the element's additive\ninverse. -/\ntheorem ∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a :=\n\n/-- The identity element in a ring is a unit. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
      "∀ {α : Type u} [inst : Ring α], IsUnit (1 : α) ",
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
      "∀ {α : Type u} [inst : Ring α], IsUnit (1 : α) ",
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ",
      "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) "
    ]
  },
  {
    "docString": "Every subgroup of a group is a group.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup contains the group's 1. \"}]\n",
    "prompt_cons": "/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- A subgroup is closed under division. -/\ntheorem ∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k) :=\n\n/-- A subgroup contains the group's 1. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H :=\n\n/-- Every subgroup of a group is a group. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), IsGroup (coe H) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), is_group (↥H) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group (coe H) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), is_group (coe H) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group (coe H) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group (coe H) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group (coe H) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), is_group_subgroup H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group (coe H) "
    ]
  },
  {
    "docString": "The sum of two natural numbers is a natural number.",
    "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of finite numbers is still finite \"}]\n",
    "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- A sum of finite numbers is still finite -/\ntheorem ∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.sum s fun a => f a) < ⊤ :=\n\n/-- The sum of two natural numbers is a natural number. -/\ntheorem",
    "choices": [
      "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
      "∀ (m n : ℕ), ∃ (a : ℕ), m + n = a ",
      "∀ {m n : ℕ}, ∃ (a : ℕ), m + n = a ",
      "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
      "∀ {m n : ℕ}, ∃ (k : ℕ), m + n = k ",
      "∀ (m n : ℕ), ∃ k, m + n = k ",
      "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
      "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ",
      "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c ",
      "∀ (m n : ℕ), ∃ (k : ℕ), m + n = k "
    ]
  },
  {
    "docString": "The identity element of a group has finite order.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of an element of finite additive order has finite additive order.\"}]\n",
    "prompt_cons": "/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- A group element has finite additive order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x :=\n\n/-- The image of an element of finite additive order has finite additive order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\n  IsOfFinAddOrder x → IsOfFinAddOrder (↑f x) :=\n\n/-- The identity element of a group has finite order. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ",
      "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) "
    ]
  },
  {
    "docString": "`7` is a prime number.",
    "prompts": "[{\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1\",\n  \"isProp\": true,\n  \"docString\": \"The exponential characteristic is a prime number or one. \"}]\n",
    "prompt_cons": "/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- The exponential characteristic is a prime number or one. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] (q : ℕ) [hq : ExpChar R q], Nat.Prime q ∨ q = 1 :=\n\n/-- `7` is a prime number. -/\ntheorem",
    "choices": [
      "Fact.prime_7 : Fact (Nat.Prime 7) ",
      "Fact (Nat.Prime 7) ",
      "Fact (Nat.Prime 7) ",
      "inst : Fact (Nat.Prime 7) ",
      "Fact (Nat.Prime 7) ",
      "prime_seven : Fact (Nat.Prime 7) ",
      "Fact.seven_prime : Fact (Nat.Prime 7) ",
      "Fact_7_prime : Fact (Nat.Prime 7) ",
      "Fact.seven.prime : Fact (Nat.Prime 7) ",
      "inst : Fact (Nat.Prime 7) "
    ]
  },
  {
    "docString": "There are `3` prime numbers below `8`.",
    "prompts": "[{\"theorem\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"}]\n",
    "prompt_cons": "/-- The only numbers with empty prime factorization are `0` and `1` -/\ntheorem ∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1 :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- There are `3` prime numbers below `8`. -/\ntheorem",
    "choices": [
      "Nat.primes_3_under_8 : (List.filter Nat.Prime (List.range 8)).length = 3 ",
      "Nat.card_prime_lt 8 = 3 ",
      "∃ (n : ℕ), n = 3 ∧ ∀ p, Nat.Prime p ∧ p < 8 → p = 2 ∨ p = 3 ∨ p = 5 ",
      "Finset.card (Nat.FilterPrime (Finset.range 8)) = 3 ",
      "Nat.card_prime_lt 8 = 3 ",
      "Nat.card {p ∈ Finset.range 8 | Nat.Prime p} = 3 ",
      "Exists (λ (s : Finset ℕ), Finset.card s = 3 ∧ ∀ (p : ℕ), p ∈ s ↔ Nat.Prime p ∧ p < 8) ",
      "prime_count_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ",
      "Exists.intro 3 (Nat.Prime.filter_lt_count 8) ",
      "Nat.Prime.count_le 8 = 3 "
    ]
  },
  {
    "docString": "The empty set is contained in every finite set.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic ∅\",\n  \"isProp\": true,\n  \"docString\": \"The empty set is concyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"}]\n",
    "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem ∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s} :=\n\n/-- The empty set is concyclic. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P], EuclideanGeometry.Concyclic ∅ :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- The empty set is contained in every finite set. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
      "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s "
    ]
  },
  {
    "docString": "Every infinite set contains a finite set.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"The set of finite subsets of a countable set is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a))\",\n  \"isProp\": true,\n  \"docString\": \"A finite union of finsets is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a}\",\n  \"isProp\": true,\n  \"docString\": \"There are finitely many subsets of a given finite set \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A finite set is bounded \"}]\n",
    "prompt_cons": "/-- The set of finite subsets of a countable set is countable. -/\ntheorem ∀ {α : Type u} {s : Set α}, Set.Countable s → Set.Countable {t | Set.Finite t ∧ t ⊆ s} :=\n\n/-- A finite union of finsets is finite. -/\ntheorem ∀ {α : Type u} {β : Type v} (f : α → Finset β), Set.Finite (Set.range f) → Set.Finite (⋃ (a : α), ↑(f a)) :=\n\n/-- There are finitely many subsets of a given finite set -/\ntheorem ∀ {α : Type u} {a : Set α}, Set.Finite a → Set.Finite {b | b ⊆ a} :=\n\n/-- A finite set is bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Set.Finite s → Metric.Bounded s :=\n\n/-- Every infinite set contains a finite set. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ",
      "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s "
    ]
  },
  {
    "docString": "Every commutative ring is a monoid.",
    "prompts": "[{\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M\",\n  \"isProp\": true,\n  \"docString\": \"The center of a monoid acts commutatively on that monoid. \"},\n {\"theorem\": \"∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"A monoid is a submonoid of itself. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\\n  IsMonoidHom f → ∀ {γ : Type u_1} [inst_2 : MulOneClass γ] {g : β → γ}, IsMonoidHom g → IsMonoidHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composite of two monoid homomorphisms is a monoid homomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"}]\n",
    "prompt_cons": "/-- The center of a monoid acts commutatively on that monoid. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], SMulCommClass M { x // x ∈ Submonoid.center M } M :=\n\n/-- A monoid is a submonoid of itself. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M], IsSubmonoid Set.univ :=\n\n/-- The composite of two monoid homomorphisms is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : MulOneClass α] [inst_1 : MulOneClass β] {f : α → β},\n  IsMonoidHom f → ∀ {γ : Type u_1} [inst_2 : MulOneClass γ] {g : β → γ}, IsMonoidHom g → IsMonoidHom (g ∘ f) :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f :=\n\n/-- Every commutative ring is a monoid. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : CommRing α], Monoid α ",
      "∀ {α : Type u_1} [inst : CommRing α], Monoid α ",
      "∀ {α : Type u} [inst : CommRing α], Monoid α ",
      "∀ {R : Type u} [inst : CommRing R], Monoid R ",
      "∀ {α : Type u} [inst : CommRing α], Monoid α ",
      "∀ {α : Type u} [inst : CommRing α], Monoid α ",
      "∀ {α : Type u} [inst : CommRing α], Monoid α ",
      "∀ {R : Type u} [inst : CommRing R], Monoid R ",
      "∀ {R : Type u} [inst : CommRing R], Monoid R ",
      "∀ {R : Type u} [inst : CommRing R], Monoid R "
    ]
  },
  {
    "docString": "There is no field of order `10`.",
    "prompts": "[{\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b}\",\n  \"isProp\": true,\n  \"docString\": \"Ordinals that are cardinals are unbounded. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b}\",\n  \"isProp\": true,\n  \"docString\": \"Infinite ordinals that are cardinals are unbounded. \"}]\n",
    "prompt_cons": "/-- The ring of integers of a number field is not a field. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- Ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b} :=\n\n/-- Fields are commutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x :=\n\n/-- Infinite ordinals that are cardinals are unbounded. -/\ntheorem Set.Unbounded (fun x x_1 => x < x_1) {b | Cardinal.ord (Ordinal.card b) = b ∧ Ordinal.omega ≤ b} :=\n\n/-- There is no field of order `10`. -/\ntheorem",
    "choices": [
      "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ",
      "¬∃ (K : Type u) [hk : Field K], Fintype.card K = 10 ",
      "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ",
      "∀ F : Type u [inst : Field F], Fintype.card F ≠ 10 ",
      "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ",
      "¬∃ (K : Type u) [inst : Field K], Fintype.card K = 10 ",
      "∀ (K : Type u_1) [inst : Field K], Fintype.card K ≠ 10 ",
      "¬∃ (K : Type u) [inst : Field K], Fintype.card K = 10 ",
      "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 ",
      "¬∃ (K : Type u_1) [inst : Field K], Fintype.card K = 10 "
    ]
  },
  {
    "docString": "Every odd natural number is the sum of two distinct natural numbers.",
    "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"}]\n",
    "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- Every odd natural number is the sum of two distinct natural numbers. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ}, n % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ n = x + y ",
      "∀ {n : ℕ}, n % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ n = x + y ",
      "∀ (n : ℕ), n % 2 = 1 → ∃ (a b : ℕ), a ≠ b ∧ n = a + b ",
      "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
      "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
      "∀ {a : ℕ}, a % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ a = x + y ",
      "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
      "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
      "∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
      "∀ (n : ℕ), n % 2 = 1 → ∃ a b : ℕ, n = a + b ∧ a ≠ b "
    ]
  },
  {
    "docString": "Every element in the trivial group has finite order.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"}]\n",
    "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- Every element in the trivial group has finite order. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [Subsingleton G] {x : G}, IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Unique G], IsOfFinOrder (default G) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ",
      "∀ {G : Type u_1} [inst : Group G] [h : Subsingleton G] (x : G), IsOfFinOrder x "
    ]
  },
  {
    "docString": "The square of an even number is even.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"}]\n",
    "prompt_cons": "/-- The convolution of two even functions is also even. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- The square of an even number is even. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ",
      "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
      "∀ {n : ℕ}, Even (n * n) ↔ Even n ",
      "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
      "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
      "∀ {n : ℕ}, even n → even (n ^ 2) ",
      "∀ (n : ℕ), Even (n ^ 2) ↔ Even n ",
      "∀ {n : ℕ}, Even n → Even (n ^ 2) ",
      "∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ",
      "∀ {n : ℕ}, Even n → Even (n ^ 2) "
    ]
  },
  {
    "docString": "Every commutative division ring is a field.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Fields are commutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\",\n  \"isProp\": true,\n  \"docString\": \"The category of commutative rings has all limits. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"}]\n",
    "prompt_cons": "/-- Fields are commutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- The category of commutative rings has all limits. -/\ntheorem CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- Every commutative division ring is a field. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R], IsDivisionRing R → IsField R ",
      "∀ {K : Type u} [inst : CommRing K] [divisionRing : DivisionRing K], IsField K ",
      "∀ (R : Type u) [inst : CommRing R], CommDivisionRing R → IsField R ",
      "∀ (R : Type u) [inst : CommRing R], IsDivRing R → IsField R ",
      "∀ {R : Type u} [inst : CommRing R], CommRing.DivisionRing R → IsField R ",
      "∀ {R : Type u} [inst : CommRing R], IsDivisionRing R → IsField R ",
      "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R ",
      "∀ {K : Type u} [inst : CommRing K] [h : DivisionRing K], IsField K ",
      "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R ",
      "∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R "
    ]
  },
  {
    "docString": "The image of the identity element under the identity map is the identity element.",
    "prompts": "[{\"theorem\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a ring homomorphism. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a monoid homomorphism. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Mul α], IsMulHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map preserves multiplication. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Semiring α], IsSemiringHom id\",\n  \"isProp\": true,\n  \"docString\": \"The identity map is a semiring homomorphism. \"}]\n",
    "prompt_cons": "/-- The identity map is a ring homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Ring α], IsRingHom id :=\n\n/-- The identity map is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} [inst : MulOneClass α], IsMonoidHom id :=\n\n/-- The identity map preserves multiplication. -/\ntheorem ∀ {α : Type u} [inst : Mul α], IsMulHom id :=\n\n/-- The identity map is a semiring homomorphism. -/\ntheorem ∀ {α : Type u} [inst : Semiring α], IsSemiringHom id :=\n\n/-- The image of the identity element under the identity map is the identity element. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1 ",
      "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ",
      "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ",
      "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ",
      "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ",
      "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ",
      "∀ {α : Type u} [inst : HasOne α], id 1 = 1 ",
      "∀ {α : Type u} [inst : One α], id 1 = 1 ",
      "forall {α : Type u} [inst : HasOne α], id (1 : α) = 1 ",
      "∀ {α : Type u} [inst : HasOne α], id 1 = 1 "
    ]
  },
  {
    "docString": "Every point is a fixed point of the identity function on a space.",
    "prompts": "[{\"theorem\": \"∀ {α : Type u} (x : α), Function.IsFixedPt id x\",\n  \"isProp\": true,\n  \"docString\": \"Every point is a fixed point of `id`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : ι → P},\\n  AffineIndependent k p → Finite ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent family of points in a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] {p₁ p₂ : P}, p₁ ∈ affineSpan k {p₂} ↔ p₁ = p₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point is in the affine span of a single point if and only if they are equal. \"}]\n",
    "prompt_cons": "/-- Every point is a fixed point of `id`. -/\ntheorem ∀ {α : Type u} (x : α), Function.IsFixedPt id x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} {ι : Type u_4} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {p : ι → P},\n  AffineIndependent k p → Finite ι :=\n\n/-- A point is in the affine span of a single point if and only if they are equal. -/\ntheorem ∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {p₁ p₂ : P}, p₁ ∈ affineSpan k {p₂} ↔ p₁ = p₂ :=\n\n/-- Every point is a fixed point of the identity function on a space. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt (λ x, x) x ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ",
      "∀ {α : Type u} (x : α), x ∈ Function.fixedPoints (id : α → α) ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt (λ a : α, a) x ",
      "∀ {α : Type u} (x : α), Function.IsFixedPt id x "
    ]
  },
  {
    "docString": "The diameter of a singleton space is `0`.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"A singleton has zero diameter \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of a singleton vanishes \"},\n {\"theorem\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0\",\n  \"isProp\": true,\n  \"docString\": \"The empty set has zero diameter \"},\n {\"theorem\": \"∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0\",\n  \"isProp\": true,\n  \"docString\": \"The diameter of the empty set vanishes \"}]\n",
    "prompt_cons": "/-- A singleton has zero diameter -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 :=\n\n/-- The diameter of a singleton vanishes -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0 :=\n\n/-- The empty set has zero diameter -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α], Metric.diam ∅ = 0 :=\n\n/-- The diameter of the empty set vanishes -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α], EMetric.diam ∅ = 0 :=\n\n/-- The diameter of a singleton space is `0`. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "∀ {α : Type u} [inst : MetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "diam_singleton {α : Type u} [inst : PseudoMetricSpace α] {x : α} : Metric.diam {x} = 0 ",
      "forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 "
    ]
  },
  {
    "docString": "Every group is non-empty.",
    "prompts": "[{\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  Nonempty (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is nonempty. \"},\n {\"theorem\":\n  \"∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The ideal is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ {a b : Ordinal.{u_1}}, b ≠ 0 → Set.Nonempty {o | a < b * Order.succ o}\",\n  \"isProp\": true,\n  \"docString\": \"The set in the definition of division is nonempty. \"}]\n",
    "prompt_cons": "/-- Each connected component of the category is nonempty. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  Nonempty (CategoryTheory.Component j) :=\n\n/-- The ideal is nonempty. -/\ntheorem ∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier :=\n\n/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- The set in the definition of division is nonempty. -/\ntheorem ∀ {a b : Ordinal.{u_1}}, b ≠ 0 → Set.Nonempty {o | a < b * Order.succ o} :=\n\n/-- Every group is non-empty. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G ",
      "∀ {G : Type u} [inst : Group G], Nonempty G "
    ]
  },
  {
    "docString": "All connected components of a topological space are connected.",
    "prompts": "[{\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\\n  CategoryTheory.IsConnected (CategoryTheory.Component j)\",\n  \"isProp\": true,\n  \"docString\": \"Each connected component of the category is connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"}]\n",
    "prompt_cons": "/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- Each connected component of the category is connected. -/\ntheorem ∀ {J : Type u₁} [inst : CategoryTheory.Category J] (j : CategoryTheory.ConnectedComponents J),\n  CategoryTheory.IsConnected (CategoryTheory.Component j) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- All connected components of a topological space are connected. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] (i : Set.ConnectedComponents α),\n  ConnectedSpace (Subtype.mk i _) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (self : TopologicalSpace.ConnectedComponents α),\n  ConnectedSpace (TopologicalSpace.Component self) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α) [self : IsConnected s], ConnectedSpace s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (self : ConnectedComponents α),\n  ConnectedSpace (coe self) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (C : Set α) [self : IsConnected C],\n  ConnectedSpace (Subtype C) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (self : TopologicalSpace.ConnectedComponents α),\n  ConnectedSpace (TopologicalSpace.Component self) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (j : Set α) [self : IsConnected j], ConnectedSpace j ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (self : TopologicalSpace.ConnectedComponents α),\n  ConnectedSpace (TopologicalSpace.Component self) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (j : ConnectedComponents α),\n  ConnectedSpace (Component j) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (self : ConnectedComponents α),\n  ConnectedSpace (Subtype (Quotientₓ.exact' self)) "
    ]
  },
  {
    "docString": "The ring of integers has a maximal ideal.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"}]\n",
    "prompt_cons": "/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ :=\n\n/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I :=\n\n/-- The ring of integers has a maximal ideal. -/\ntheorem",
    "choices": [
      "∀ (α : Type u) [inst : Ring α] [inst_1 : Nontrivial α] [IsRingOfIntegers α], ∃ M, Ideal.IsMaximal M ",
      "∀ {α : Type u} [inst : Ring α] [inst_1 : Ring.IsDedekindDomain α], α → Ideal.IsMaximal ",
      "∀ (O : Type u) [inst : CommRing O] [inst_1 : IsDomain O] [inst_2 : IsDedekindDomain O], ∃ M, Ideal.IsMaximal M ",
      "∀ {α : Type u} [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M ",
      "∀ {α : Type u} [inst : CommRing α] [inst_1 : Algebra ℤ α], ∃ M, Ideal.IsMaximal M ",
      "∀ (R : Type u) [inst : CommRing R], ∃ M, Ideal.IsMaximal M ",
      "∀ (α : Type u) [inst : CommRing α] [inst_1: IsDomain α] [inst_2 : IsWellOrder α] [inst_3 : Archimedean α], ∃ M, Ideal.IsMaximal M ",
      "∀ {R : Type u} [inst : CommRing R], ∃ M : Ideal ℤ, Ideal.IsMaximal M ",
      "∀ (R : Type u) [inst : CommRing R] [inst_1 : Nontrivial R], ∃ I, Ideal.IsMaximal I ",
      "∀ {R : Type u}, [inst : IntegralDomain R] [inst_1 : Nontrivial R], ∃ M, Ideal.IsMaximal M "
    ]
  },
  {
    "docString": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
    "prompts": "[{\"theorem\":\n  \"∀ {x y z : ℤ},\\n  PythagoreanTriple x y z →\\n    (PythagoreanTriple x y z ↔\\n      ∃ k m n,\\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2)))\",\n  \"isProp\": true,\n  \"docString\": \"**Formula for Pythagorean Triples** \"},\n {\"theorem\": \"PythagoreanTriple 0 0 0\",\n  \"isProp\": true,\n  \"docString\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"theorem\": \"∀ {x y z : ℤ}, PythagoreanTriple x y z ↔ PythagoreanTriple y x z\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\\nThis comes from additive commutativity. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector angle form. \"}]\n",
    "prompt_cons": "/-- **Formula for Pythagorean Triples** -/\ntheorem ∀ {x y z : ℤ},\n  PythagoreanTriple x y z →\n    (PythagoreanTriple x y z ↔\n      ∃ k m n,\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨ x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2))) :=\n\n/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem PythagoreanTriple 0 0 0 :=\n\n/-- Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\nThis comes from additive commutativity. -/\ntheorem ∀ {x y z : ℤ}, PythagoreanTriple x y z ↔ PythagoreanTriple y x z :=\n\n/-- Pythagorean theorem, vector angle form. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n  InnerProductGeometry.angle x y = Real.pi / 2 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n\n/-- The numbers `3`, `4` and `5` form a Pythagorean triple. -/\ntheorem",
    "choices": [
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 ",
      "PythagoreanTriple 3 4 5 "
    ]
  },
  {
    "docString": "A vector space with the empty set as basis is trivial.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\\ncardinality of the basis. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"}]\n",
    "prompt_cons": "/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem ∀ {R : Type u} [inst : Ring R] [inst_1 : StrongRankCondition R] {M : Type v} [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] {ι : Type w} [inst_4 : Fintype ι], Basis ι R M → Module.rank R M = ↑(Fintype.card ι) :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- A vector space with the empty set as basis is trivial. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V ≃ₗ[K] 0 ",
      "∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M],\n  Basis ∅ R M → M = Trivial R M ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V ≃ₗ[K] 0 ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → V = TrivialModule.zero ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι K V → V = Trivialₓ V ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  (h : IsEmpty ι), Basis ι K V → (V → K) → V → V =",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Basis ∅ K V → V = {0} ",
      "∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι R M → M ≃ₗ[R] R ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V ≃ₗ[K] 0 ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → V = Trivial.LieSubalgebra K "
    ]
  }
]