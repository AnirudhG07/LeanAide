{"docString": "If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.", "prompts": "[{\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (↑r * x) ↔ LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (x * ↑r) ↔ LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"}]\n", "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (↑r * x) ↔ LiouvilleWith p x) :=\n\n/-- The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (x * ↑r) ↔ LiouvilleWith p x) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem ∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y :=\n\n/-- If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational. -/\ntheorem", "choices": ["∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) ", "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r * x) "]}
{"docString": "Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α},\\n  BddBelow s → BddAbove s → Set.Nonempty s → sInf s ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\\nits supremum.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : DenselyOrdered α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α]\\n  [nonem : Nonempty α] (lo hi : Finset α),\\n  (∀ (x : α), x ∈ lo → ∀ (y : α), y ∈ hi → x < y) → ∃ m, (∀ (x : α), x ∈ lo → x < m) ∧ ∀ (y : α), y ∈ hi → m < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `α` is a nonempty dense linear order without endpoints, and\\nsuppose `lo`, `hi`, are finite subsets with all of `lo` strictly\\nbefore `hi`. Then there is an element of `α` strictly between `lo`\\nand `hi`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊆ B → Finset.toColex A ≤ Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A ⊆ B`, then `A ≤ B` in the colex order. Note the converse does not hold, as `⊆` is not a\\nlinear order. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\\n  Set.OrdConnected s ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. \"}]\n", "prompt_cons": "/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α},\n  BddBelow s → BddAbove s → Set.Nonempty s → sInf s ≤ sSup s :=\n\n/-- Suppose `α` is a nonempty dense linear order without endpoints, and\nsuppose `lo`, `hi`, are finite subsets with all of `lo` strictly\nbefore `hi`. Then there is an element of `α` strictly between `lo`\nand `hi`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : DenselyOrdered α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α]\n  [nonem : Nonempty α] (lo hi : Finset α),\n  (∀ (x : α), x ∈ lo → ∀ (y : α), y ∈ hi → x < y) → ∃ m, (∀ (x : α), x ∈ lo → x < m) ∧ ∀ (y : α), y ∈ hi → m < y :=\n\n/-- If `A ⊆ B`, then `A ≤ B` in the colex order. Note the converse does not hold, as `⊆` is not a\nlinear order. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊆ B → Finset.toColex A ≤ Finset.toColex B :=\n\n/-- It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\n  Set.OrdConnected s ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s :=\n\n/-- Let $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and $\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : Preorder α] {E : Set α},\n  Set.Nonempty E → (∃ α, ∀ x, x ∈ E → α ≤ x) → (∃ β, ∀ x, x ∈ E → x ≤ β) → α ≤ β ", "∀ {α : Type u_1} [inst : Preorder α] {E : Set α} (α β : α),\n  α ∈ LowerBounds E → β ∈ UpperBounds E → Set.Nonempty E → α ≤ β ", "∀ {α : Type u_1} [inst : Preorder α] {E : Set α} (α β : α),\n  α ∈ LowerBounds E → β ∈ UpperBounds E → Set.Nonempty E → α ≤ β ", "∀ {α : Type u_1} [inst : Preorder α] {E : Set α} (α β : α),\n  α ∈ LowerBounds E → β ∈ UpperBounds E → Set.Nonempty E → α ≤ β ", "∀ {α : Type u_1} [inst : Preorder α] {E : Set α} (αβ : α),\n  (∀ (x : α), x ∈ E → α≤ x) → (∀ (x : α), x ∈ E → x ≤ αβ) → Set.Nonempty E → α≤ αβ ", "∀ {α : Type u_1} [inst : Preorder α] {E : Set α},\n  BddBelow E → BddAbove E → Set.Nonempty E → ∀ (α : α), IsLb E α → ∀ (β : α), IsUb E β → α ≤ β ", "∀ {α : Type u_1} [inst : Preorder α] {s : Set α} {a b : α},\n  s ≠ ∅ → is_lub s b → is_glb s a → a ≤ b ", "∀ {α : Type u_1} [inst : Preorder α] {E : Set α},\n  Set.Nonempty E → (∃ a, ∀ x, x ∈ E → a ≤ x) → (∃ b, ∀ x, x ∈ E → x ≤ b) → ∀ α β, α ≤ β ", "forall {α : Type u_1} [inst : Preorder α] {E : Set α} (α β : α),\n  Set.Nonempty E → α ≤ E.lub → E.glb ≤ β → α ≤ β ", "∀ {α : Type u_1} [inst : Preorder α] {E : Set α}, Set.Nonempty E →\n  (∃ α_lb, ∀ (x : α), x ∈ E → α_lb ≤ x) → (∃ β_ub, ∀ (x : α), x ∈ E → x ≤ β_ub) → α_lb ≤ β_ub "]}
{"docString": "Prove that no order can be defined in the complex field that turns it into an ordered field.", "prompts": "[{\"theorem\": \"¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : LinearOrderedField β],\\n  Subsingleton (α ≃+*o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring isomorphism between an archimedean linear ordered field and a\\nlinear ordered field. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : LinearOrderedField β] [inst_2 : Archimedean β],\\n  Subsingleton (α ≃+*o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is at most one ordered ring isomorphism between a linear ordered field and an archimedean\\nlinear ordered field. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\\n  [inst : T2Space α], False\",\n  \"isProp\": true,\n  \"docString\": \"There does not exist a nontrivial preirreducible T₂ space. \"}]\n", "prompt_cons": "/-- The complex numbers are not countable. -/\ntheorem ¬Set.Countable Set.univ :=\n\n/-- There is at most one ordered ring isomorphism between an archimedean linear ordered field and a\nlinear ordered field. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : LinearOrderedField β],\n  Subsingleton (α ≃+*o β) :=\n\n/-- There is at most one ordered ring isomorphism between a linear ordered field and an archimedean\nlinear ordered field. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : LinearOrderedField β] [inst_2 : Archimedean β],\n  Subsingleton (α ≃+*o β) :=\n\n/-- There does not exist a nontrivial preirreducible T₂ space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] [inst_2 : Nontrivial α]\n  [inst : T2Space α], False :=\n\n/-- Prove that no order can be defined in the complex field that turns it into an ordered field. -/\ntheorem", "choices": ["¬∃ (r : ℂ → ℂ → Prop), OrderedField ℂ ", "¬∃ (r : ℂ → ℂ → Prop), OrderedField ℂ ", "¬∃ (r : ℂ → ℂ → Prop), @OrderedField ℂ _ _ r ", "¬∃ (r : ℂ → ℂ → Prop) [is_order : IsOrder ℂ r], OrderedField ℂ ", "¬(∃ (r : ℂ → ℂ → Prop), OrderedField ℂ) ", "¬∃ (r : ℂ → ℂ → Prop), OrderedField ℂ ", "¬∃ (r : ℂ → ℂ → Prop), OrderedRing ℂ ", "¬∃ (r : ℂ → ℂ → Prop), OrderedField.toOrder (<) ", "¬∃ (r : ℂ → ℂ → Prop), OrderedRing ℂ ", "¬∃ (r : ℂ → ℂ → Prop), @OrderedField ℂ _ r "]}
{"docString": "If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$.", "prompts": "[{\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S • z| < 1`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : AddCommMonoid M] {f : α → M} (p : M → Prop),\\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (i : α), p (f i)) → p (∑ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite sum, it suffices to prove that the property is\\nadditive and holds on the summands.\"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∑ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite sum, it suffices to prove that the property is\\nadditive and holds on summands.\"}]\n", "prompt_cons": "/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- If `1 < |z|`, then `|S • z| < 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1 :=\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on the summands. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : AddCommMonoid M] {f : α → M} (p : M → Prop),\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (i : α), p (f i)) → p (∑ᶠ (i : α), f i) :=\n\n/-- To prove a property of a finite sum, it suffices to prove that the property is\nadditive and holds on summands. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 0 → (∀ (x y : M), p x → p y → p (x + y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∑ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- If $z_1, \\ldots, z_n$ are complex, prove that $|z_1 + z_2 + \\ldots + z_n| \\leq |z_1| + |z_2| + \\cdots + |z_n|$. -/\ntheorem", "choices": ["∀ {z : List ℂ}, ↑Complex.normSq ↑(List.sum z) ≤ ↑(List.sum (List.map Complex.normSq z)) ", "∀ {n : ℕ} {z : Finₓ n → ℂ}, ∥(∑ i, z i)∥ ≤ ∑ i, ∥z i∥ ", "∀ {z : List ℂ}, (∀ (i : ℂ), i ∈ z → Complex.abs i ≤ Complex.abs i) → Complex.abs (List.sum z) ≤ List.sum (List.map Complex.abs z) ", "forall {n : ℕ} {z : Finₓ (n + 1) → ℂ},\n  ↑Complex.normSq ↑(finsum z) ≤ ↑Complex.normSq ↑(finsum (λ i, Complex.abs (z i))) ", "∀ {z : List ℂ}, ↑Complex.normSq ↑(List.sum z) ≤ ↑(List.sum (List.map Complex.normSq z)) ", "∀ {n : ℕ} {z : ℕ → ℂ}, ↑Complex.normSq ↑(∑ (i : ℕ) in Finset.range n, z i) ≤ (∑ (i : ℕ) in Finset.range n, ↑Complex.normSq ↑(z i)) ", "∀ (z : ℕ → ℂ), ↑Complex.normSq (↑∑ᶠ (i : ℕ), z i) ≤ ∑ᶠ (i : ℕ), ↑Complex.normSq (z i) ", "∀ {z : List ℂ}, ↑Complex.normSq ↑(List.sum z) ≤ ↑(List.sum (List.map Complex.normSq z)) ", "∀ {z : List ℂ}, ↑Complex.normSq ↑(List.sum z) ≤ ↑(List.sum (List.map Complex.normSq z)) ", "∀ {z : List ℂ}, ↑Complex.abs ↑(List.foldl Complex.add 0 z) ≤ ↑(List.foldl (λ x y, x + Complex.abs y) 0 z) "]}
{"docString": "If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.", "prompts": "[{\"theorem\": \"∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S • z| < 1`. \"}]\n", "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem ∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem ∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I) :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- If `1 < |z|`, then `|S • z| < 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1 :=\n\n/-- If $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$. -/\ntheorem", "choices": ["forall (z : ℂ), Complex.normSq (z * Complex.conj z) = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : ℂ), z * ↑(starRingEnd ℂ) z = 1 → (Complex.normSq (1 + z) + Complex.normSq (1 - z)) = 2 ", "forall (z : ℂ), Complex.normSq z = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : ℂ), z * z.conj = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : ℂ), z * starRingEnd ℂ z = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : ℂ), z * starRingEnd ℂ z = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "|1 + z|^2 + |1 - z|^2 = 2 * (1 + |z|^2) ", "∀ (z : ℂ), Complex.normSq z = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : ℂ), z * conj z = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 ", "forall (z : ℂ), Complex.normSq z = 1 → Complex.normSq (1 + z) + Complex.normSq (1 - z) = 2 "]}
{"docString": "Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$.", "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\\n  inner a x * inner a y + ↑(↑(Orientation.areaForm o) a) x * ↑(↑(Orientation.areaForm o) a) y = ‖a‖ ^ 2 * inner x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For vectors `a x y : E`, the identity `⟪a, x⟫ * ⟪a, y⟫ + ω a x * ω a y = ‖a‖ ^ 2 * ⟪x, y⟫`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\\n  inner a x * ↑(↑(Orientation.areaForm o) a) y - ↑(↑(Orientation.areaForm o) a) x * inner a y =\\n    ‖a‖ ^ 2 * ↑(↑(Orientation.areaForm o) x) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"For vectors `a x y : E`, the identity `⟪a, x⟫ * ω a y - ω a x * ⟪a, y⟫ = ‖a‖ ^ 2 * ω x y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\": \"Pythagorean theorem, vector inner product form. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\\n  ‖x‖ = ‖y‖ → ‖x + y‖ = ‖x‖ + ‖y‖ → x = y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\\ntheir sum is equal to the sum of their norms, then they are equal. \"}]\n", "prompt_cons": "/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ⟪a, y⟫ + ω a x * ω a y = ‖a‖ ^ 2 * ⟪x, y⟫`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\n  inner a x * inner a y + ↑(↑(Orientation.areaForm o) a) x * ↑(↑(Orientation.areaForm o) a) y = ‖a‖ ^ 2 * inner x y :=\n\n/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ω a y - ω a x * ⟪a, y⟫ = ‖a‖ ^ 2 * ω x y`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (a x y : E),\n  inner a x * ↑(↑(Orientation.areaForm o) a) y - ↑(↑(Orientation.areaForm o) a) x * inner a y =\n    ‖a‖ ^ 2 * ↑(↑(Orientation.areaForm o) x) y :=\n\n/-- Pythagorean theorem, vector inner product form. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), inner x y = 0 → ‖x + y‖ * ‖x + y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ :=\n\n/-- If `x` and `y` are two vectors in a strictly convex space have the same norm and the norm of\ntheir sum is equal to the sum of their norms, then they are equal. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\n  ‖x‖ = ‖y‖ → ‖x + y‖ = ‖x‖ + ‖y‖ → x = y :=\n\n/-- Prove that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ if $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$. -/\ntheorem", "choices": ["∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (x y : E),\n  ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * ‖x‖ * ‖x‖ + 2 * ‖y‖ * ‖y‖ ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] (x y : E),\n  ∥x + y∥ * ∥x + y∥ + ∥x - y∥ * ∥x - y∥ = 2 * ∥x∥ * ∥x∥ + 2 * ∥y∥ * ∥y∥ ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (x y : E),\n  ‖x + y‖ ^ 2 + ‖x - y‖ ^ 2 = 2 * ‖x‖ ^ 2 + 2 * ‖y‖ ^ 2 ", "∀ {k : Type u_1} [inst : NormedAddCommGroup k] [inst_1 : NormedSpace ℝ k] (x y : k),\n  ‖x + y‖ ^ 2 + ‖x - y‖ ^ 2 = 2 * ‖x‖ ^ 2 + 2 * ‖y‖ ^ 2 ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * ‖x‖ * ‖x‖ + 2 * ‖y‖ * ‖y‖ ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), ‖x + y‖ ^ 2 + ‖x - y‖ ^ 2 = 2 * ‖x‖ ^ 2 + 2 * ‖y‖ ^ 2 ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * ‖x‖ * ‖x‖ + 2 * ‖y‖ * ‖y‖ ", "∀ {k : ℕ} {x y : ℝ^(k)},\n  ‖x + y‖ ^ 2 + ‖x - y‖ ^ 2 = 2 * (‖x‖ ^ 2) + 2 * (‖y‖ ^ 2) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (x y : E), ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * ‖x‖ * ‖x‖ + 2 * ‖y‖ * ‖y‖ ", "∀ {R : Type u_1} {k : Type u_2} [inst : OrderedRing R] [inst_1 : NormedAddCommGroup k] [inst_2 : NormedSpace R k] (x y : k),\n  ‖x + y‖ ^ 2 + ‖x - y‖ ^ 2 = 2 * ‖x‖ ^ 2 + 2 * ‖y‖ ^ 2 "]}
{"docString": "If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y ≠ 0`. \"},\n {\"theorem\":\n  \"∀ (k : ℕ) {r : ℝ}, |r| < 1 → Filter.Tendsto (fun n => ↑n ^ k * r ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"}]\n", "prompt_cons": "/-- If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. -/\ntheorem ∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0 :=\n\n/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0 :=\n\n/-- If `|r| < 1`, then `n ^ k r ^ n` tends to zero for any natural `k`. -/\ntheorem ∀ (k : ℕ) {r : ℝ}, |r| < 1 → Filter.Tendsto (fun n => ↑n ^ k * r ^ n) Filter.atTop (nhds 0) :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- If $k = 1$ and $\\mathbf{x} \\in R^{k}$, prove that there does not exist $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$ -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  ¬(∃ y : R, y ≠ 0 ∧ x * y = 0) ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  ¬ (∃ (y : R), y ≠ 0 ∧ x * y = 0) ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  (∀ (y : R), y ≠ 0 → x * y ≠ 0) ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  ¬ (∃ y : R, y ≠ 0 ∧ x * y = 0) ", "forall {R : Type u_1} [inst : Semiring R] [inst_1 : NoZeroSmulDivisors R R] {x : R},\n  x ≠ 0 → ¬∃ y : R, y ≠ 0 ∧ x * y = 0 ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  ¬ (∃ y : R, y ≠ 0 ∧ x * y = 0) ", "forall {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R),\n  ¬(∃ y : R, y ≠ 0 ∧ x * y = 0) ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R}, x ≠ 0 → ¬(∃ y : R, y ≠ 0 ∧ x * y = 0) ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {x : R},\n  ¬ (∃ y : R, y ≠ 0 ∧ x * y = 0) ", "∀ {R : Type u_1} [inst : CommRing R] {x : R}, ¬(∃ y : R, y ≠ 0 ∧ x * y = 0) "]}
{"docString": "If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.", "prompts": "[{\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\": \"Two different points can be separated by open sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α]\\n  [inst_3 : OpensMeasurableSpace α] {s t : Set α},\\n  MeasureTheory.AnalyticSet s → MeasureTheory.AnalyticSet t → Disjoint s t → MeasureTheory.MeasurablySeparable s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Lusin separation theorem: if two analytic sets are disjoint, then they are contained in\\ndisjoint Borel sets. \"}]\n", "prompt_cons": "/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t :=\n\n/-- Two different points can be separated by open sets. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {x y : α},\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- The Lusin separation theorem: if two analytic sets are disjoint, then they are contained in\ndisjoint Borel sets. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α]\n  [inst_3 : OpensMeasurableSpace α] {s t : Set α},\n  MeasureTheory.AnalyticSet s → MeasureTheory.AnalyticSet t → Disjoint s t → MeasureTheory.MeasurablySeparable s t :=\n\n/-- If $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint U V ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint U V ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint U V ", "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : EmetricSpace α] [inst_2 : TopologicalSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ u v, IsOpen u ∧ IsOpen v ∧ A ⊆ u ∧ B ⊆ v ∧ Disjoint u v ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint U V ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ u v, IsOpen u ∧ IsOpen v ∧ A ⊆ u ∧ B ⊆ v ∧ Disjoint u v ", "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ u v, IsOpen u ∧ IsOpen v ∧ A ⊆ u ∧ B ⊆ v ∧ Disjoint u v ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α}, IsClosed A → IsClosed B → Disjoint A B → ∃ u v, IsOpen u ∧ IsOpen v ∧ A ⊆ u ∧ B ⊆ v ∧ Disjoint u v ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α}, IsClosed A → IsClosed B → Disjoint A B → ∃ u v, IsOpen u ∧ IsOpen v ∧ A ⊆ u ∧ B ⊆ v ∧ Disjoint u v ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  IsClosed A → IsClosed B → Disjoint A B → ∃ u v, IsOpen u ∧ IsOpen v ∧ A ⊆ u ∧ B ⊆ v ∧ Disjoint u v "]}
{"docString": "Prove that every compact metric space $K$ has a countable base.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"}]\n", "prompt_cons": "/-- In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Prove that every compact metric space $K$ has a countable base. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : EmetricSpace α] [is_compact : IsCompact (univ : Set α)],\n  TopologicalSpace.FirstCountableTopology α ", "∀ {α : Type u_1} [inst : MetricSpace α] [CompactSpace α],\n  TopologicalSpace.SecondCountableTopology α ", "∀ {α : Type u_1} [inst : MetricSpace α] {K : Set α}, IsCompact K → TopologicalSpace.HasCountableBasisAt K ", "∀ {α : Type u_1} [inst : MetricSpace α] {K : Set α}, IsCompact K → TopologicalSpace.FirstCountableTopology (subtype K) ", "∀ {α : Type u_1} [inst : MetricSpace α] {s : Set α}, IsCompact s → ∃ B : ℕ → Set α, (∀ i, IsOpen (B i)) ∧ Set.Countable (Set.Range B) ∧ s = ⋃ i, B i ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [self : MetricSpace α] [K : IsCompact α],\n  TopologicalSpace.CountableBasis α ", "∀ {α : Type u_1} [inst : MetricSpace α] {K : Set α}, IsCompact K → TopologicalSpace.FirstCountableTopology (↥K) ", "∀ {α : Type u_1} [inst : MetricSpace α] {s : Set α}, IsCompact s → TopologicalSpace.FirstCountableTopology (subtype s) ", "∀ {K : Type u_1} [inst : MetricSpace K] [self : IsCompact K],\n  TopologicalSpace.FirstCountableTopology K ", "∀ {α : Type u_1} [inst : MetricSpace α] {K : Set α}, IsCompact K → TopologicalSpace.SecondCountableTopology α "]}
{"docString": "Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\\n  Monotone f →\\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\\n      Set.Countable {x | ¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where a monotone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\\n  Antitone f →\\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\\n      Set.Countable {x | ¬ContinuousAt f x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second countable space, the set of points where an antitone function is not continuous\\nis at most countable. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In general it suffices that all but finitely many of the spaces are compact,\\nbut that's not straightforward to state and use. \"}]\n", "prompt_cons": "/-- In a second countable space, the set of points where a monotone function is not continuous\nis at most countable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\n  Monotone f →\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\n      Set.Countable {x | ¬ContinuousAt f x} :=\n\n/-- In a second countable space, the set of points where an antitone function is not continuous\nis at most countable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]\n  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},\n  Antitone f →\n    ∀ [inst_4 : TopologicalSpace α] [inst : OrderTopology α] [inst : TopologicalSpace.SecondCountableTopology β],\n      Set.Countable {x | ¬ContinuousAt f x} :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f :=\n\n/-- In general it suffices that all but finitely many of the spaces are compact,\nbut that's not straightforward to state and use. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : Finite ι], LocallyCompactSpace ((i : ι) → π i) :=\n\n/-- Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that at most countably many points of $E$ are not in $P$. -/\ntheorem", "choices": ["∀ {E : Set ℝ^k} [inst : TopologicalSpace ℝ^k] [inst_1 : TopologicalSpace.SecondCountableTopology ℝ^k] \n  [inst_2 : TopologicalSpace.IsTopologicalBasis (TopologicalSpace.CountableBasis ℝ^k)],\n  Set.Countable E → Set.Countable {x | x ∈ E ∧ ¬(x ∈ (TopologicalSpace.CountableBasis ℝ^k).condensation_points_of E)} ", "∀ {k : ℕ} {E : Set (Finₓ k → ℝ)} [inst : TopologicalSpace (Finₓ k → ℝ)] [inst_1 : TopologicalSpace.SecondCountableTopology (Finₓ k → ℝ)] [inst_2 : TopologicalSpace ℝ],\n  Set.Countable E → Set.Countable {x | ¬TopologicalSpace.IsCondensationPoint x E} ", "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] [inst_1 : TopologicalSpace.SecondCountableTopology ℝ],\n  Set.Countable E → Set.Countable {x | x ∈ E ∧ x ∉ 𝓟 x} ", "∀ {k : ℕ} {E : set (Finₓ k → ℝ)}, Set.Countable E →\n  Set.Countable {x | x ∈ E ∧ ¬(TopologicalSpace.IsCondensationPoint x E)} ", "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] [inst_1 : TopologicalSpace.SecondCountableTopology ℝ],\n  Set.Uncountable E →\n  Set.Countable (E \\ {x | Filter.IsCondensationPoint x E}) ", "{E : Set ℝ} (hE : Set.Countable E) : Set.Countable {x ∈ E | ∀ (t : ℝ), Filter.Frequently (fun x => x ∈ E) (𝓝[t] x)} ", "∀ {k : ℕ} {E : Set (Finₓ k → ℝ)},\n  Set.Countable E →\n    ∃ P : Set (Finₓ k → ℝ), IsCondensationSet E P ∧ Set.Countable (E \\ P) ", "∀ {k : ℕ} {E : Set (Finₓ k → ℝ)}, Set.Uncountable E →\n  Set.Countable (E \\ {x | IsCondensationPoint x E}) ", "∀ {k : ℕ} {E : Set (Finₓ k → ℝ)} [inst : TopologicalSpace (Finₓ k → ℝ)] [inst_1 : TopologicalSpace.SecondCountableTopology (Finₓ k → ℝ)],\n  Set.Countable E → Set.Countable {x | ¬IsCondensationPoint x E} ", "∀ {k : ℕ} {E : Set (Finₓ k → ℝ)},\n  Set.Countable E →\n    Set.Countable (E \\ {x | TopologicalSpace.IsCondensationPoint x E}) "]}
{"docString": "Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"}]\n", "prompt_cons": "/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Prove that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments. -/\ntheorem", "choices": ["forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α], \n  ∀ (U : Set α), IsOpen U → ∃ (𝓐 : Set (Set α)), Set.Countable 𝓐 ∧ (∀ (I : Set α), I ∈ 𝓐 → IsSegment I) ∧ HasSubset.Subset 𝓐 U ∧ PairwiseDisjoint 𝓐 ∧ U = ⋃₀ 𝓐 ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α] [inst_4 : TopologicalSpace.SecondCountableTopology α],\n  ∀ (U : Set α), IsOpen U → ∃ S, Set.Countable S ∧ (⋃₀ S = U) ∧ ∀ (s : Set α), s ∈ S → ∃ (a b : α), a < b ∧ Set.Ioo a b = s ", "∀ {R : Type} [inst : TopologicalSpace R] [inst_1 : LinearOrderedField R] [inst_2 : OrderTopology R] [inst_3 : TopologicalSpace.SecondCountableTopology R]\n  (U : Set R), IsOpen U → ∃ A, Set.Countable A ∧ U = ⋃ (a b : R) (_ : (a, b) ∈ A), Set.Ioo a b ", "∀ {s : Set ℝ} [t : TopologicalSpace ℝ] [inst : TopologicalSpace.SecondCountableTopology ℝ],\n  IsOpen s → ∃ T, Set.Countable T ∧ ⋃ (i : ℝ × ℝ) (_ : i ∈ T), Set.Ioo i.1 i.2 = s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [TopologicalSpace.SecondCountableTopology α], (∀ (s : Set α), IsOpen s →\n    ∃ B : Set (Set α),\n      Set.Countable B ∧\n        (∀ b ∈ B, ∃ a b, b = Set.Ioo a b) ∧\n          Pairwise (Disjoint on B) ∧ s = ⋃₀ B) ", "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] [DenselyOrdered α] {s : Set α},\n  IsOpen s → ∃ T, Set.Countable T ∧ (∀ (I : Set α), I ∈ T → IsOpen I ∧ IsSegment I) ∧ PairwiseDisjoint T ∧ s = ⋃₀ T ", "∀ {α : Type u} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {s : Set α}, IsOpen s →\n  ∃ (t : Set (Set α)), Set.Countable t ∧ (∀ (u : Set α), u ∈ t → IsOpen u ∧ IsConnected u) ∧\n    Pairwise (Disjoint on t) ∧ s = ⋃₀ t ", "∀ {s : Set ℝ} [inst : TopologicalSpace ℝ] [TopologicalSpace.SecondCountableTopology ℝ],\n  IsOpen s → ∃ (U : Set (Set ℝ)), Set.Countable U ∧ (∀ u ∈ U, IsOpen u) ∧ (∀ u ∈ U, IsDisjoint u s) ∧ ⋃₀ U = s ", "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {s : Set α},\n  IsOpen s → ∃ B : Set (Set α), Set.Countable B ∧ (∀ (b : Set α), b ∈ B → IsOpen b) ∧ (∀ (b : Set α), b ∈ B → IsDisjoint b s) ∧ ⋃₀ B = s "]}
{"docString": "Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$.", "prompts": "[{\"theorem\":\n  \"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) → CauchySeq f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. \"}]\n", "prompt_cons": "/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- If `dist (f n) (f (n+1))` is bounded by `(C / 2) / 2^n`, then `f` is a Cauchy sequence. -/\ntheorem ∀ {α : Type u_1} [inst : PseudoMetricSpace α] (C : ℝ) {f : ℕ → α},\n  (∀ (n : ℕ), dist (f n) (f (n + 1)) ≤ C / 2 / 2 ^ n) → CauchySeq f :=\n\n/-- Prove that $\\lim_{n \\rightarrow \\infty}\\sqrt{n^2 + n} -n = 1/2$. -/\ntheorem", "choices": ["Filter.Tendsto (λ n => sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => sqrt (↑n^2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => (sqrt (↑n ^ 2 + ↑n) - ↑n)) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => (sqrt (↑n ^ 2 + ↑n) - ↑n)) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) ", "Filter.Tendsto (fun n => sqrt (↑n ^ 2 + ↑n) - ↑n) Filter.atTop (nhds (1 / 2)) "]}
{"docString": "For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$.", "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E]\\n  {a b : ℝ} [inst_3 : Countable ι] {f : ι → C(ℝ, E)},\\n  (Summable fun i =>\\n      ‖ContinuousMap.restrict (↑{ carrier := Set.uIcc a b, isCompact' := (_ : IsCompact (Set.uIcc a b)) }) (f i)‖) →\\n    HasSum (fun i => ∫ (x : ℝ) in a..b, ↑(f i) x) (∫ (x : ℝ) in a..b, ∑' (i : ι), ↑(f i) x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Interval integrals commute with countable sums, when the supremum norms are summable (a\\nspecial case of the dominated convergence theorem). \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a ≤ a + b` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid γ]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] [inst_4 : ContinuousAdd γ] {f g : α → γ},\\n  UpperSemicontinuousAt f x → UpperSemicontinuousAt g x → UpperSemicontinuousAt (fun z => f z + g z) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\\naddition, for application to `EReal`. \"}]\n", "prompt_cons": "/-- Interval integrals commute with countable sums, when the supremum norms are summable (a\nspecial case of the dominated convergence theorem). -/\ntheorem ∀ {ι : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : CompleteSpace E] [inst_2 : NormedSpace ℝ E]\n  {a b : ℝ} [inst_3 : Countable ι] {f : ι → C(ℝ, E)},\n  (Summable fun i =>\n      ‖ContinuousMap.restrict (↑{ carrier := Set.uIcc a b, isCompact' := (_ : IsCompact (Set.uIcc a b)) }) (f i)‖) →\n    HasSum (fun i => ∫ (x : ℝ) in a..b, ↑(f i) x) (∫ (x : ℝ) in a..b, ∑' (i : ι), ↑(f i) x) :=\n\n/-- For any `a` and `b`, `a ≤ a + b` -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedAddMonoid α] (a b : α), a ≤ a + b :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b :=\n\n/-- The sum of two upper semicontinuous functions is upper semicontinuous. Formulated with\n`[ContinuousAdd]`. The primed version of the lemma uses an explicit continuity assumption on\naddition, for application to `EReal`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {x : α} {γ : Type u_2} [inst_1 : LinearOrderedAddCommMonoid γ]\n  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] [inst_4 : ContinuousAdd γ] {f g : α → γ},\n  UpperSemicontinuousAt f x → UpperSemicontinuousAt g x → UpperSemicontinuousAt (fun z => f z + g z) x :=\n\n/-- For any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, prove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ provided the sum on the right is not of the form $\\infty-\\infty$. -/\ntheorem", "choices": ["∀ {a b : ℕ → ℝ}, limsup_ennreal (λ n, a n + b n) ≤ limsup_ennreal a + limsup_ennreal b ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  {f g : ℕ → α}, BddAbove (Set.Range f) → BddAbove (Set.Range g) →\n    Filter.tendsto (fun n => f n + g n) Filter.atTop (nhds (Sup (Set.Range f) + Sup (Set.Range g))) ", "forall {a b : ℕ → ℝ}, Filter.Eventually (fun n => a n + b n ≤ Filter.limsup Filter.atTop a + Filter.limsup Filter.atTop b) Filter.atTop ", "forall {a b : ℕ → ℝ}, limsup at_top a + limsup at_top b ≠ ⊤ - ⊤ → limsup at_top (a + b) ≤ limsup at_top a + limsup at_top b ", "∀ {u v : ℕ → ℝ}, Filter.Tendsto u Filter.atTop Filter.atTop → Filter.Tendsto v Filter.atTop Filter.atTop →\n  Filter.Tendsto (fun n => u n + v n) Filter.atTop Filter.atTop →\n  (Filter.limsup Filter.atTop u + Filter.limsup Filter.atTop v ≠ ⊤ - ⊤) →\n    Filter.limsup Filter.atTop (u + v) ≤ Filter.limsup Filter.atTop u + Filter.limsup Filter.atTop v ", "∀ {u v : ℕ → ℝ}, LimsupAtTop (λ n, u n + v n) ≤ LimsupAtTop u + LimsupAtTop v ", "forall {a b : ℕ → ℝ}, limsup at_top a + limsup at_top b ≠ ⊤ - ⊤ → limsup at_top (a + b) ≤ limsup at_top a + limsup at_top b ", "forall {a b : ℕ → ℝ}, is_limsup_sum_le_limsup_sum (a : ℕ → ℝ) (b : ℕ → ℝ) : Filter.limsup Filter.atTop (fun n => a n + b n) ≤ Filter.limsup Filter.atTop a + Filter.limsup Filter.atTop b ", "∀ {a b : ℕ → ℝ}, Filter.Tendsto (λ n, a n + b n) Filter.atTop (nhds (Real.limsupₓ a + Real.limsupₓ b)) ", "forall {a b : ℕ → ℝ}, LimSup_ennreal a + LimSup_ennreal b ≠ ⊤ →\n  LimSup_ennreal (a + b) ≤ LimSup_ennreal a + LimSup_ennreal b "]}
{"docString": "Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$.", "prompts": "[{\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"}]\n", "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- Prove that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$. -/\ntheorem", "choices": ["∀ {β : Type u_1} {a b : β → ℝ}, (∀ (n : β), 0 ≤ a n) → (∀ (n : β), sqrt (a n) / n ≤ b n) → Summable a → Summable b ", "∀ {β : Type u_1} {a b : β → ℝ}, (∀ (n : β), 0 ≤ a n) → Summable a →\n  (∀ (n : β), b n = (Real.sqrt (a n)) / n) → Summable b ", "∀ {β : Type u_1} {f : β → ℝ}, (∀ (b : β), 0 ≤ f b) → Summable f → Summable (λ (b : β), sqrt (f b) / (↑b + 1)) ", "∀ {β : Type u_1} {a : β → ℝ}, (∀ (n : β), 0 ≤ a n) → Summable a → Summable (λ n, sqrt (a n) / (n + 1)) ", "∀ {β : Type u_1} {a : β → ℝ}, (∀ (n : β), 0 ≤ a n) → Summable a → Summable (λ n => sqrt (a n) / (n + 1)) ", "∀ {α : Type u_1} {f : α → ℝ}, (∀ (n : α), 0 ≤ f n) → Summable f → Summable (λ n => sqrt (f n) / (n : ℝ)) ", "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommMonoid α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : HasContinuousAdd α] {f : ℕ → α},\n  (∀ (n : ℕ), 0 ≤ f n) → Summable f → Summable (λ n => (sqrt (f n)) / ↑n) ", "∀ {β : Type u_1} {a : β → ℝ}, (∀ (b : β), 0 ≤ a b) → Summable a → Summable (λ n => (sqrt (a n)) / (n + 1)) ", "∀ {β : Type u_1} {f : β → ℝ}, (∀ (b : β), 0 ≤ f b) → Summable f → Summable (λ b => sqrt (f b) / (b + 1)) ", "∀ {β : Type u_1} {a : β → ℝ}, (∀ (n : β), 0 ≤ a n) → Summable a → Summable (λ n => sqrt (a n) / (n + 1)) "]}
{"docString": "Prove that the Cauchy product of two absolutely convergent series converges absolutely.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\\n  CauchySeq u →\\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop →\\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"}]\n", "prompt_cons": "/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- Prove that the Cauchy product of two absolutely convergent series converges absolutely. -/\ntheorem", "choices": ["∀ {α : Type u_1} {β : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {f : α → G} {g : β → G},\n  Summable fun x => ∥f x∥ →\n    Summable fun x => ∥g x∥ →\n      Summable fun x => ∥(f x.1) * (g x.2)∥ ", "∀ {α : Type u_1} {β : Type u_2} [inst : Semiring α] [inst_1 : RegularSpace α] [inst_2 : TopologicalRing α]\n  [inst_3 : UniformSpace β] [inst_4 : Semiring β] [inst_5 : UniformAddGroup β] [inst_6 : UniformContinuousMul β]\n  {a : ℕ → α} {b : ℕ → β},\n  HasSum (fun n => ∑ i in Finset.range (n + 1), a i * b (n - i)) (HasSum a * HasSum b) →\n    HasSum (fun n => ∥a n∥) →\n      HasSum (fun n => ∥b n∥) →\n        HasSum (fun n => ∑ i in Finset.range (n + 1), a i * b (n - i)) (HasSum a * HasSum b) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : Semiring α] [inst_1 : Semiring β] [inst_2 : Semiring γ] {f : ℕ → α} {g : ℕ → β} {h : ℕ → γ},\n  (Summable fun n => abs (f n)) →\n    (Summable fun n => abs (g n)) →\n      (∀ᵐ (n : ℕ), abs (h n) ≤ ∑ i in range (n + 1), abs (f i) * abs (g (n - i))) →\n        Summable fun n => abs (h n) ", "∀ {α : Type u} {G : Type u_1} [inst : NormedAddCommGroup G] {f g : ℕ → G}\n  [inst_1 : NormedSpace ℝ G] {γ : Type u_2} [inst_2 : LinearOrderedField γ] [inst_3 : Archimedean γ] {r : α → γ},\n  Summable (λ n, r (f n) * r (g n)) →\n    ∃ C : ℝ, 0 < C ∧ ∀ n : ℕ, r (f n * g n) ≤ C * r (f n) * r (g n) ", "∀ {α : Type u_1} {β : Type u_2} [Ring α] [Ring β]\n {f g : ℕ → α} {F G : ℕ → β} (hf : HasSum (λ i, F i) (Summable f)) (hg : HasSum (λ i, G i) (Summable g)),\n  Summable (λ i, ∑ (jk : ℕ × ℕ) in Finset.Nat.antidiagonal i, f jk.1 * g jk.2) →\n    HasSum (λ i, ∑ (jk : ℕ × ℕ) in Finset.Nat.antidiagonal i, F i * G i) (Summable (λ i, F i * G i)) ", "∀ {α : Type u_1} [inst : Semiring α] {G : Type u_2} [inst_1 : NormedGroup G] [inst_2 : NormedSpace α G] {ι : Type u_3} [inst_3 : Countable ι]\n  {F : ι → α → G} {f : α → G} {G' : ι → α → G} {g : α → G},\n  (∀ (x : α), Summable (λ (n : ι), F n x)) →\n    (∀ (x : α), Summable (λ (n : ι), G' n x)) →\n      (∀ (x : α), Summable (λ (n : ι), ∑ (i : ι) in Finset.range (n + 1), F i x • G' (n - i) x)) →\n        (∀ (x : α), HasSum (λ (n : ι), F n x) (f x)) →\n          (∀ (x : α), HasSum (λ (n : ι), G' n x) (g x)) →\n            (∀ (x : α), HasSum (λ (n : ι), ∑ (i : ι) in Finset.range (n + 1), F i x • G' (n - i) x) ((f x) * (g x)))", "∀ {α : Type u} {G : Type v} [inst : NormedGroup G] {f g : ℕ → G},\n  (∃ Kf, 0 < Kf ∧ ∀ (x : ℕ), ∥f x∥ ≤ Kf * (1 / (2 ^ x))) →\n    (∃ Kg, 0 < Kg ∧ ∀ (x : ℕ), ∥g x∥ ≤ Kg * (1 / (2 ^ x))) →\n      ∃ K, 0 < K ∧ ∀ (x : ℕ), ∥(∑ (k : ℕ) in Finset.range x, f k * g (x - k))∥ ≤ K * (1 / (2 ^ x)) ", "∀ {α : Type u} {β : Type v} [inst : NormedField α] [inst_1 : CompleteSpace α] {f : ℕ → α} {g : ℕ → α},\n  Summable (λ (n : ℕ), ∥f n∥) →\n    Summable (λ (n : ℕ), ∥g n∥) →\n      Summable (λ (n : ℕ), ∥f n * g n∥) ", "∀ {α : Type u_1} [inst : AddCommGroup α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalAddGroup α] {ι : Type u_2} [inst_3 : Nonempty ι] [inst_4 : SemilatticeSup ι] {a b : ι → α},\n  Summable a →\n    Summable b →\n      (∀ᵐ (n : ι) ∂nhds 0, HasSum (fun k : Finset (Σ (n : ι), ι) => (a (k.1) * b (k.2))) n) → Summable (λ n, ∑ k in Finset.sigma Finset.univ (fun n => Finset.range (n + 1)), a (k.1) * b (k.2)) ", "∀ {α : Type u_1} {β : Type u_2} [inst : Ring α] {abv : α → β} [inst_1 : IsAbsoluteValue abv] [inst_2 : ℕ → α] [inst_3 : ℕ → α],\n  (∀ᵐ (n : ℕ), Summable fun m => abv (inst_2 m * inst_3 (n - m))) →\n    (∀ (n : ℕ), Summable fun m => abv (inst_2 m) * abv (inst_3 (n - m))) →\n      (∀ᵐ (n : ℕ), HasSum (fun m => inst_2 m * inst_3 (n - m)) (inst_4 n)) →\n        HasSum (fun m => abv (inst_4 m)) (abv (∑' (n : ℕ), inst_4 n)) "]}
{"docString": "If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\\n  (∀ (n : ℕ), IsClosed (s n)) →\\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\\n      (∀ (N : ℕ), Set.Nonempty (⋂ (n : ℕ) (_ : n ≤ N), s n)) →\\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, if a family of closed sets with diameter tending to `0` is such that each\\nfinite intersection is nonempty, then the total intersection is also nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space, the minimal edistance to a nonempty set is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.Bounded s ↔ EMetric.diam s ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst : LinearOrder ι]\\n  [inst_1 : TopologicalSpace ι] [inst_2 : OrderTopology ι] [inst_3 : DenselyOrdered ι]\\n  [inst_4 : TopologicalSpace.FirstCountableTopology ι] {s : ι → Set α} {a : ι},\\n  (∀ (r : ι), r > a → MeasurableSet (s r)) →\\n    (∀ (i j : ι), a < i → i ≤ j → s i ⊆ s j) →\\n      (∃ r, r > a ∧ ↑↑μ (s r) ≠ ⊤) →\\n        Filter.Tendsto (↑↑μ ∘ s) (nhdsWithin a (Set.Ioi a)) (nhds (↑↑μ (⋂ (r : ι) (_ : r > a), s r)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The measure of the intersection of a decreasing sequence of measurable\\nsets indexed by a linear order with first countable topology is the limit of the measures. \"}]\n", "prompt_cons": "/-- In a complete space, if a family of closed sets with diameter tending to `0` is such that each\nfinite intersection is nonempty, then the total intersection is also nonempty. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (N : ℕ), Set.Nonempty (⋂ (n : ℕ) (_ : n ≤ N), s n)) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n) :=\n\n/-- In a metric space, the minimal edistance to a nonempty set is finite. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α}, Set.Nonempty s → EMetric.infEdist x s ≠ ⊤ :=\n\n/-- Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, Metric.Bounded s ↔ EMetric.diam s ≠ ⊤ :=\n\n/-- The measure of the intersection of a decreasing sequence of measurable\nsets indexed by a linear order with first countable topology is the limit of the measures. -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst : LinearOrder ι]\n  [inst_1 : TopologicalSpace ι] [inst_2 : OrderTopology ι] [inst_3 : DenselyOrdered ι]\n  [inst_4 : TopologicalSpace.FirstCountableTopology ι] {s : ι → Set α} {a : ι},\n  (∀ (r : ι), r > a → MeasurableSet (s r)) →\n    (∀ (i j : ι), a < i → i ≤ j → s i ⊆ s j) →\n      (∃ r, r > a ∧ ↑↑μ (s r) ≠ ⊤) →\n        Filter.Tendsto (↑↑μ ∘ s) (nhdsWithin a (Set.Ioi a)) (nhds (↑↑μ (⋂ (r : ι) (_ : r > a), s r))) :=\n\n/-- If $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric space $X$, if $E_{n} \\supset E_{n+1}$, and if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ then $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → ∃ x, ∀ ⦃y⦄, y ∈ (⋂ (n : ℕ), s n) ↔ x = y ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (N : ℕ), Set.Nonempty (⋂ (n : ℕ) (_ : n ≤ N), s n)) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n) ∧ ∀ x y ∈ ⋂₀ (Set.Range s), x = y ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (N : ℕ), Set.Nonempty (⋂ (n : ℕ) (_ : n ≤ N), s n)) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → ∃! x, x ∈ (⋂ (n : ℕ), s n) ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → ∃! x, x ∈ ⋂ (n : ℕ), s n ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n : ℕ), s (n + 1) ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n) ∧ ∀ x y ∈ (⋂ (n : ℕ), s n), x = y ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) →\n          ∃! x, x ∈ (⋂ (n : ℕ), s n) ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n) ∧ ∀ x y ∈ (⋂ (n : ℕ), s n), x = y ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → ∃ x, Set.eq_singleton x (⋂ (n : ℕ), s n) ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → Set.Nonempty (⋂ (n : ℕ), s n) ∧ ∀ x y ∈ (⋂ (n : ℕ), s n), x = y ", "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompleteSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsClosed (s n)) →\n    (∀ (n : ℕ), Metric.Bounded (s n)) →\n      (∀ (n m : ℕ), n ≤ m → s m ⊆ s n) →\n        Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0) → (∃ a, (⋂ (n : ℕ), s n) = {a}) "]}
{"docString": "Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous.", "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f → MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n", "prompt_cons": "/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem ∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f → MeasureTheory.LocallyIntegrable f :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- Suppose $f$ is a real function defined on $\\mathbb{R}$ which satisfies $\\lim_{h \\rightarrow 0} f(x + h) - f(x - h) = 0$ for every $x \\in \\mathbb{R}$. Show that $f$ does not need to be continuous. -/\ntheorem", "choices": ["It is not possible to express this theorem in Lean, as it is a counterexample rather than a provable statement. Lean is designed to prove theorems and not to provide counterexamples.", "Sorry, as a coding assistant, I can only provide Lean Theorem Prover code for statements that can be proven as theorems. The given statement is a counterexample and not a provable theorem. Please provide a provable statement or theorem, and I would be happy to help you with Lean code for that.", "This theorem statement is incorrect for Lean since it is not a formal statement that can be proven. It seems to be asking for a counterexample rather than a theorem to be proven. Please provide a valid theorem statement to be translated into Lean code.", "This statement is asking to prove that a function with the given property does not necessarily have to be continuous, which is not a theorem but rather an example or counterexample. Lean Theorem Prover is designed to prove theorems, not to provide examples or counterexamples. Please provide another theorem for me to translate into Lean code.", "In this task, the statement is not a theorem that can be proven within Lean. The statement describes a real function `f` that satisfies a specific limit condition but mentions that `f` may not necessarily be continuous.\n\nInstead of trying to prove this as a theorem in Lean, we can provide an example of a function that satisfies the given condition but is not continuous. One such example is the following function:\n\nf(x) = { 0, if x is rational\n      { x, if x is irrational\n\nThis function f satisfies the given condition that the limit as h approaches 0 of f(x + h) - f(x - h) equals 0, but is not continuous at any irrational point.\n\nNote that this example cannot be translated into Lean code as a theorem, but it serves as an illustration of the given statement.", "This statement is asking to prove that a function with a certain property does not need to be continuous. This cannot be directly translated to Lean code as a theorem because Lean theorems are required to prove that something is true, not that something does not need to be true.\n\nHowever, we can instead construct an example of a function that satisfies the given property but is not continuous. Here is the Lean code for that:\n\n```lean\nimport analysis.special_functions.trigonometric\nimport analysis.normed_space.real_inner_product\nimport topology.metric_space.basic\n\nnoncomputable def example_function (x : ℝ) : ℝ ", "There is no Lean theorem for this particular statement, as it is a counterexample rather than a general theorem. However, you can construct a counterexample in Lean to demonstrate that the given conditions do not imply continuity.\n\nFor example, consider the following function:\n\n```lean\ndef f (x : ℝ) : ℝ ", "Sorry, I cannot provide a theorem for this as Lean Theorem Prover code only supports translating statements that can be formalized in the Lean language. This statement includes non-mathematical phrases and is not directly translatable into Lean code.", "This is not a theorem, since it is asking to show that a given condition does not imply continuity. Instead, we can provide a counterexample.\n\nexample : ∃ (f : ℝ → ℝ), (∀ x : ℝ, filter.tendsto (λ h, f (x + h) - f (x - h)) (filter.tendsto_nhds 0) (filter.tendsto_nhds 0)) ∧ ¬continuous f ", "This is not a theorem that can be proven in Lean, as it is asking for a counterexample. Lean is a theorem prover and is not designed to provide counterexamples or disprove statements."]}
{"docString": "Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\\n  0 < r →\\n    r ≤ R →\\n      ∀ {f : ℂ → E} {s : Set ℂ},\\n        Set.Countable s →\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) →\\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s → DifferentiableAt ℂ f z) →\\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\\nequal to each other. \"}]\n", "prompt_cons": "/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0 :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\nequal to each other. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\n  0 < r →\n    r ≤ R →\n      ∀ {f : ℂ → E} {s : Set ℂ},\n        Set.Countable s →\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) →\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\ Metric.closedBall c r) \\ s → DifferentiableAt ℂ f z) →\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z :=\n\n/-- Let $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) be the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed. -/\ntheorem", "choices": ["∀ {X : Type u} [inst : PseudoMetricSpace X] {f : X → ℝ}, Continuous f → IsClosed (f ⁻¹' {0}) ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] {f : X → ℝ},\n  Continuous f → IsClosed (SetOf (λ p, f p = 0)) ", "∀ {X : Type u} [inst : MetricSpace X] [inst_1 : TopologicalSpace ℝ], ∀ {f : X → ℝ},\n    Continuous f → IsClosed (SetOf (λ (p : X), f p = 0)) ", "∀ {X : Type u} [inst : MetricSpace X] {f : X → ℝ}, Continuous f → IsClosed (Function.zeroSet f) ", "∀ {X : Type u} [inst : MetricSpace X] {f : X → ℝ}, Continuous f → IsClosed (SetOf (λ (p : X), f p = 0)) ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] {f : X → ℝ},\n  Continuous f → IsClosed (SetOf (λ x, f x = 0)) ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → ℝ}, Continuous f → IsClosed (f ⁻¹' {0}) ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : PseudoMetricSpace X] {f : X → ℝ},\n  Continuous f → IsClosed (SetOf (λ (p : X), f p = 0)) ", "∀ {X : Type u} [inst : MetricSpace X] {f : X → ℝ}, Continuous f → IsClosed (SetOf (λ (p : X), f p = 0)) ", "∀ {X : Type u} [inst : MetricSpace X] {f : X → ℝ}, Continuous f → IsClosed (SetOf (λ p, f p = 0)) "]}
{"docString": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) →\\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) → (∀ (x : X), ∃ c, ∀ᶠ (y : X) in nhds x, c ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x ∈ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"}]\n", "prompt_cons": "/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) →\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x ∈ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) → (∀ (x : X), ∃ c, ∀ᶠ (y : X) in nhds x, c ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that if $g(p) = f(p)$ for all $p \\in P$ then $g(p) = f(p)$ for all $p \\in X$. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : MetricSpace α] [inst_3 : MetricSpace β] {E : Set α},\n  Dense E → ∀ {f g : α → β}, Continuous f → Continuous g → Set.EqOn f g E → f = g ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g ", "forall {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X},\n  Dense E → ∀ {f g : X → Y}, Continuous f → Continuous g → Set.EqOn f g E → f = g ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g ", "forall {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g ", "∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X},\n  Dense E → ∀ {f g : X → Y}, Continuous f → Continuous g → Set.EqOn f g E → f = g ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g ", "forall {X Y : Type u} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X},\n  Dense E → ∀ {f g : X → Y}, Continuous f → Continuous g → Set.EqOn f g E → f = g ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g "]}
{"docString": "Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.", "prompts": "[{\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"}]\n", "prompt_cons": "/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- Show that there exist a set $E \\subset \\mathbb{R}$ and a real continuous function $f$ defined on $E$, such that there does not exist a continuous real function $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$. -/\ntheorem", "choices": ["∃ (E : Set ℝ) (f : E → ℝ), ContinuousOn f E ∧ ∀ (g : ℝ → ℝ), Continuous g → ¬ Set.EqOn g f E ", "∃ (E : Set ℝ) (f : E → ℝ), ContinuousOn f E ∧ ∀ (g : ℝ → ℝ), Continuous g → ¬ Set.EqOn g f E ", "∃ (E : Set ℝ) (f : ℝ → ℝ), ContinuousOn f E ∧ ∀ (g : ℝ → ℝ), Continuous g → ¬Set.EqOn g f E ", "∃ (E : Set ℝ) (f : ℝ → ℝ), ContinuousOn f E ∧ ¬ (∃ (g : ℝ → ℝ), Continuous g ∧ Set.EqOn f g E) ", "∃ (E : Set ℝ) (f : ℝ → ℝ), ContinuousOn f E ∧ ∀ (g : ℝ → ℝ), Continuous g → ¬ ∀ (x : ℝ), x ∈ E → g x = f x ", "∃ (E : Set ℝ) (f : E → ℝ), ContinuousOn f E ∧ ∀ (g : ℝ → ℝ), Continuous g → ¬Set.EqOn g f E ", "∃ (E : Set ℝ) (f : ℝ → ℝ), ContinuousOn f E ∧\n  ¬(∃ (g : ℝ → ℝ), Continuous g ∧ ∀ (x : ℝ), x ∈ E → g x = f x) ", "∃ (E : Set ℝ) (f : ℝ → ℝ), ContinuousOn f E ∧ ∀ (g : ℝ → ℝ), Continuous g → ¬ Set.EqOn f g E ", "∃ (E : Set ℝ) (f : ℝ → ℝ),\n  ContinuousOn f E ∧ (∀ (g : ℝ → ℝ), Continuous g → ∀ (x : ℝ), x ∈ E → g x = f x → False) ", "∃ (E : Set ℝ) (f : ℝ → ℝ), ContinuousOn f E ∧\n  ∀ (g : ℝ → ℝ), Continuous g → ¬ Set.EqOn g f E "]}
{"docString": "Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\\n  {f : ℂ → E} {s : Set ℂ},\\n  Set.Countable s →\\n    ContinuousOn f (Metric.closedBall c ↑R) →\\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\\\ s → DifferentiableAt ℂ f z) →\\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"}]\n", "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : ℂ → E} {s : Set ℂ},\n  Set.Countable s →\n    ContinuousOn f (Metric.closedBall c ↑R) →\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\ s → DifferentiableAt ℂ f z) →\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R :=\n\n/-- Let $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. Prove that $f$ is bounded on $E$. -/\ntheorem", "choices": ["forall {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace ℝ] [inst_4 : Nonempty α] {f : ℝ → α} {E : Set ℝ},\n  Bounded E → UniformContinuousOn f E → BddAbove (f '' E) ∧ BddBelow (f '' E) ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {E : Set β},\n  Bounded E → UniformContinuous f → BddAbove (f '' E) ∧ BddBelow (f '' E) ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {E : Set β},\n  Bounded E → UniformlyContinuousOn f E → BddAbove (f '' E) ∧ BddBelow (f '' E) ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α] [inst_3 : MetricSpace α]\n  {E : Set α} {f : α → ℝ},\n  IsBounded E → UniformlyContinuousOn f E → Bounded (f '' E) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : MetricSpace α] [inst_2 : LinearOrder β] [inst_3 : OrderClosedTopology β]\n  [inst_4 : TopologicalSpace β] {f : α → β} {E : Set α},\n  IsBounded E → UniformContinuous f → BddAbove (f '' E) ∧ BddBelow (f '' E) ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : Nonempty α] {f : α → ℝ} {E : Set α},\n  Bounded E → UniformContinuousOn f E → Bounded (f '' E) ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  {β : Type u_2} [inst_3 : TopologicalSpace β] {f : β → α} {E : Set β},\n  Bounded E → UniformlyContinuousOn f E → BddAbove (f '' E) ∧ BddBelow (f '' E) ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {E : Set β},\n  Bounded E → UniformContinuousOn f E → BddAbove (f '' E) ∧ BddBelow (f '' E) ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  {f : α → ℝ} {E : Set α},\n  Bounded E → UniformContinuous f → BddAbove (f '' E) ∧ BddBelow (f '' E) ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  {E : Set α} {f : α → ℝ},\n  Bounded E → UniformlyContinuousOn f E → BddAbove (f '' E) ∧ BddBelow (f '' E) "]}
{"docString": "Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {x : α} {p : Filter ι}\\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s → x ∈ s → Cauchy (Filter.map (fun i => F i x) p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\\na Cauchy sequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"}]\n", "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {x : α} {p : Filter ι}\n  [hp : Filter.NeBot p], UniformCauchySeqOn F p s → x ∈ s → Cauchy (Filter.map (fun i => F i x) p) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- Suppose $f$ is a uniformly continuous mapping of a metric space $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ is a Cauchy sequence in $Y$ for every Cauchy sequence $\\{x_n\\}$ in $X$. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  UniformContinuous f → ∀ {u : ℕ → α}, CauchySeq u → CauchySeq (f ∘ u) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {x : ℕ → α},\n  UniformContinuous f → CauchySeq x → CauchySeq (f ∘ x) ", "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : MetricSpace β] {f : α → β},\n  UniformContinuous f →\n    ∀ (u : ℕ → α), CauchySeq u → CauchySeq (f ∘ u) ", "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : MetricSpace β] (f : α → β),\n  UniformContinuous f → ∀ (u : ℕ → α), CauchySeq u → CauchySeq (f ∘ u) ", "∀ {α : Type u} {β : Type v} [_inst_1 : UniformSpace α] [_inst_2 : UniformSpace β]\n  {f : α → β} {u : ℕ → α}, UniformContinuous f → CauchySeq u → CauchySeq (f ∘ u) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  UniformContinuous f → ∀ {u : ℕ → α}, CauchySeq u → CauchySeq (f ∘ u) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {x : ℕ → α},\n  CauchySeq x → UniformContinuity f → CauchySeq (f ∘ x) ", "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {u : ℕ → α},\n  UniformContinuous f → CauchySeq u → CauchySeq (f ∘ u) ", "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → ∀ {u : ℕ → α}, CauchySeq u → CauchySeq (f ∘ u) ", "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β]\n  (f : α → β) (hf : UniformContinuous f) (u : ℕ → α),\n  CauchySeq u → CauchySeq (f ∘ u) "]}
{"docString": "Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.", "prompts": "[{\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] [inst_6 : DenselyOrdered β]\\n  {f : α → β}, Monotone f → Function.Surjective f → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monotone surjective function with a densely ordered codomain is continuous. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\\n  Continuous f → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function is monotone with respect to the specialization preorders on the domain and\\nthe codomain. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Proof of continuity of the Hom. \"}]\n", "prompt_cons": "/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- A monotone surjective function with a densely ordered codomain is continuous. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] [inst_6 : DenselyOrdered β]\n  {f : α → β}, Monotone f → Function.Surjective f → Continuous f :=\n\n/-- A continuous function is monotone with respect to the specialization preorders on the domain and\nthe codomain. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\n  Continuous f → Monotone f :=\n\n/-- Proof of continuity of the Hom. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Monoid A] [inst_1 : Monoid B] [inst_2 : TopologicalSpace A]\n  [inst_3 : TopologicalSpace B] (self : ContinuousMonoidHom A B), Continuous self.toFun :=\n\n/-- Prove that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic. -/\ntheorem", "choices": ["∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] [inst_6 : DenselyOrdered β]\n  {f : α → β}, Continuous f → ∀ ⦃x y⦄, x < y → f x ≤ f y ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : LinearOrder β] [inst_5 : OrderTopology β] {f : α → β},\n  Continuous f → IsOpenMap f → Monotone f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : LinearOrder α]\n  [inst_3 : LinearOrder β] [inst_4 : OrderTopology α] [inst_5 : OrderTopology β] {f : α → β}, Continuous f → IsOpenMap f → Monotone f ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : LinearOrder X] [inst_2 : OrderTopology X]\n[inst_3 : TopologicalSpace Y] [inst_4 : LinearOrder Y] [inst_5 : OrderTopology Y] {f : X → Y},\nContinuous f → IsOpenMap f → Monotone f ", "forall {R : Type u_1} [inst : TopologicalSpace R] [inst_1 : LinearOrder R] [inst_2 : TopologicalSpace R]\n  [inst_3 : OrderTopology R] {f : R → R}, Continuous f → IsOpenMap f → Monotone f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : LinearOrder α]\n  [inst_2 : OrderTopology α] [inst_3 : TopologicalSpace β] [inst_4 : LinearOrder β] [inst_5 : OrderTopology β]\n  {f : α → β}, Continuous f → IsOpenMap f → Monotone f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : LinearOrder α]\n  [inst_3 : LinearOrder β] [inst_4 : OrderClosedTopology α] [inst_5 : OrderClosedTopology β],\n  (α → β) → Continuous f → IsOpenMap f → Monotone f ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  {β : Type u_2} [inst_3 : TopologicalSpace β] [inst_4 : LinearOrder β] [inst_5 : OrderTopology β]\n  {f : α → β}, Continuous f → IsOpenMap f → Monotone f ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrderedField β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β]\n  {f : α → β}, Continuous f → IsOpenMap f → Monotone f ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : LinearOrderedRing α] [inst_2 : OrderTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : LinearOrderedRing β] [inst_5 : OrderTopology β]\n  {f : α → β}, Continuous f → IsOpenMap f → Monotone f "]}
{"docString": "Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$.", "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : MetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth σ-compact manifold with a metric. Let `K : ι → Set M` be a locally finite\\nfamily of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for all\\n`i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and `x ∈ K i`,\\nwe have `Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\\nexists a positive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`,\\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. \"}]\n", "prompt_cons": "/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `M` be a smooth σ-compact manifold with a metric. Let `K : ι → Set M` be a locally finite\nfamily of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for all\n`i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and `x ∈ K i`,\nwe have `Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : MetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `X` be an extended metric space. Let `K : ι → Set X` be a locally finite family of closed\nsets, let `U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there\nexists a positive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`,\nwe have `EMetric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : EMetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → EMetric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- Suppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. Prove that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$. -/\ntheorem", "choices": ["∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      K ∩ F = ∅ →\n        ∃ δ, (∀ (x : X), 0 < δ) ∧ ∀ (p ∈ K) (q ∈ F), Metric.dist p q > δ ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      Disjoint K F → ∃ δ : ℝ, 0 < δ ∧ ∀ (p ∈ K) (q ∈ F), δ < Metric.dist p q ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      K ∩ F = ∅ →\n        ∃ δ > 0, ∀ (p ∈ K) (q ∈ F), Metric.dist p q > δ ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      Disjoint K F →\n        ∃ δ > 0, ∀ (p ∈ K) (q ∈ F), δ < Metric.dist p q ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      Disjoint K F →\n        ∃ δ, δ > 0 ∧ ∀ (p ∈ K) (q ∈ F), dist p q > δ ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      Disjoint K F →\n        ∃ δ > 0, ∀ p ∈ K, ∀ q ∈ F, Metric.dist p q > δ ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      Disjoint K F →\n        ∃ δ : ℝ, 0 < δ ∧ ∀ (p ∈ K) (q ∈ F), δ < Metric.dist p q ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      K ∩ F = ∅ →\n        ∃ δ, 0 < δ ∧ ∀ (p : X), p ∈ K → ∀ (q : X), q ∈ F → δ < Metric.dist p q ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      Disjoint K F →\n        ∃ δ, 0 < δ ∧ ∀ (p ∈ K) (q ∈ F), δ ≤ Metric.dist p q ", "∀ {X : Type u_1} [inst : MetricSpace X] {K F : Set X},\n  IsCompact K →\n    IsClosed F →\n      K ∩ F = ∅ →\n        ∃ δ, 0 < δ ∧ ∀ (p ∈ K) (q ∈ F), δ < Metric.dist p q "]}
{"docString": "Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant.", "prompts": "[{\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ},\\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"}]\n", "prompt_cons": "/-- Let `f : ℝ → ℝ` be a differentiable function. If `C ≤ f'`, then `f` grows at least as fast\nas `C * x`, i.e., `C * (y - x) ≤ f y - f x` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), C ≤ deriv f x) → ∀ ⦃x y : ℝ⦄, x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let `f : ℝ → ℝ` be a differentiable function. If `f' ≤ C`, then `f` grows at most as fast\nas `C * x`, i.e., `f y - f x ≤ C * (y - x)` whenever `x ≤ y`. -/\ntheorem ∀ {f : ℝ → ℝ},\n  Differentiable ℝ f → ∀ {C : (fun x => ℝ) 1}, (∀ (x : ℝ), deriv f x ≤ C) → ∀ ⦃x y : ℝ⦄, x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \\leq (x-y)^{2}$ for all real $x$ and $y$. Prove that $f$ is constant. -/\ntheorem", "choices": ["∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y) ^ 2) → ∀ (x y : ℝ), f x = f y ", "∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y)^2) → ∀ (x y : ℝ), f x = f y ", "∀ {f : ℝ → ℝ},\n  (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y) ^ 2) →\n    (∀ (x y : ℝ), f x = f y) ", "∀ {f : ℝ → ℝ},\n  (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y)^2) →\n    (∀ (x y : ℝ), f x = f y) ", "∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y) ^ 2) → ∀ (x y : ℝ), f x = f y ", "∀ {f : ℝ → ℝ},\n  (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y)^2) → (∃ (C : ℝ), ∀ (x : ℝ), f x = C) ", "∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y)^2) → (∀ (x y : ℝ), f x = f y) ", "∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y) ^ 2) → ∀ (x y : ℝ), f x = f y ", "∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y) ^ 2) → ∀ (x y : ℝ), f x = f y ", "∀ {f : ℝ → ℝ}, (∀ (x y : ℝ), abs (f x - f y) ≤ (x - y)^2) → ∀ (x y : ℝ), f x = f y "]}
{"docString": "Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\\nintegral. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → ℝ),\\n  MeasureTheory.Integrable f →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), g x < ↑(f x)) ∧\\n            UpperSemicontinuous g ∧\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\\n                (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), EReal.toReal (g x) ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\\nof `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → ℝ),\\n  MeasureTheory.Integrable f →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), ↑(f x) < g x) ∧\\n            LowerSemicontinuous g ∧\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"}]\n", "prompt_cons": "/-- For any function `f : α → ℝ≥0∞`, there exists a measurable function `g ≤ f` with the same\nintegral. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) (f : α → ENNReal),\n  ∃ g, Measurable g ∧ g ≤ f ∧ ∫⁻ (a : α), f a ∂μ = ∫⁻ (a : α), g a ∂μ :=\n\n/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g < f` which is upper semicontinuous, with integral arbitrarily close to that\nof `f`. This function has to be `EReal`-valued in general. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → ℝ),\n  MeasureTheory.Integrable f →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), g x < ↑(f x)) ∧\n            UpperSemicontinuous g ∧\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\n                (∀ᵐ (x : α) ∂μ, ⊥ < g x) ∧ ∫ (x : α), f x ∂μ < ∫ (x : α), EReal.toReal (g x) ∂μ + ε :=\n\n/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → ℝ),\n  MeasureTheory.Integrable f →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), ↑(f x) < g x) ∧\n            LowerSemicontinuous g ∧\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- Suppose $g$ is a real function on $R^{1}$, with bounded derivative (say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. Prove that $f$ is one-to-one if $\\varepsilon$ is small enough. -/\ntheorem", "choices": ["∀ {g : ℝ → ℝ} {M : ℝ},\n  (∀ x, ∃ y, HasDerivAt g y x ∧ abs y ≤ M) →\n    ∀ {ε : ℝ},\n      0 < ε → ε < 1 / M →\n        Injective (λ x : ℝ, x + ε * g x) ", "∀ {M : ℝ} (g : ℝ → ℝ) (g_deriv : ℝ → ℝ) (ε : ℝ),\n  (∀ x, DifferentiableAt ℝ g x) →\n    (∀ x, ∥(g_deriv x)∥ ≤ M) →\n      0 < ε → ε < 1 / M →\n        ∀ x y, x ≠ y → (x + ε * g x) ≠ (y + ε * g y) ", "∀ {M : ℝ} {ε : ℝ},\n  0 < ε →\n    ε < 1/M →\n      ∀ {g : ℝ → ℝ} {g' : ℝ → ℝ},\n        (∀ x, DifferentiableAt ℝ g x ∧ deriv g x = g' x) →\n          (∀ x, abs (g' x) ≤ M) →\n            ∀ x y : ℝ, x ≠ y → x + ε * g x ≠ y + ε * g y ", "∀ {M : ℝ} (g : ℝ → ℝ) (g' : ℝ → ℝ),\n  (∀ (x : ℝ), ∥g' x∥ ≤ M) →\n    ∀ {ε : ℝ},\n      0 < ε → ε < 1 / M →\n        Injective (λ (x : ℝ), x + ε * g x) ", "∀ {g : ℝ → ℝ} {M : ℝ},\n  (∀ x, ∃ (hg' : ℝ), has_deriv_at g hg' x ∧ |hg'| ≤ M) →\n    ∀ {ε : ℝ},\n      0 < ε → ε < 1 / M →\n        injective (λ (x : ℝ), x + ε * g x) ", "∀ {M ε : ℝ},\n  0 < M →\n  0 < ε →\n  ε < 1 / M →\n    ∀ {g : ℝ → ℝ},\n      (∀ x, ∥deriv g x∥ ≤ M) →\n        Function.Injective (λ x, x + ε * g x) ", "∀ {g : ℝ → ℝ} (M : ℝ),\n  (∀ x : ℝ, ∃ (y : ℝ), HasDerivAt g y x ∧ abs y ≤ M) →\n    ∀ {ε : ℝ},\n      0 < ε ∧ ε < 1 / M →\n        Function.Injective (λ x, x + ε * g x) ", "∀ {f : ℝ → ℝ} {g : ℝ → ℝ} {g' : ℝ → ℝ} {M ε : ℝ},\n  (∀ x, HasDerivAt g (g' x) x) →\n    (∀ x, abs (g' x) ≤ M) →\n      0 < ε → ε < 1 / M →\n        Function.Injective (λ x, x + ε * g x) ", "∀ {M : ℝ} (hM : 0 < M) {g : ℝ → ℝ} (hg : ∀ x, ∥deriv g x∥ ≤ M) {ε : ℝ} (hε : 0 < ε) (hεM : ε * M < 1),\n  Function.Injective (λ x, x + ε * g x) ", "∀ {g : ℝ → ℝ} {M : ℝ},\n  (∀ x, ∃ y, has_deriv_at g y x ∧ abs y ≤ M) →\n  ∀ {ε : ℝ},\n    0 < ε → ε < 1 / M →\n      (∀ x₁ x₂, x₁ ≠ x₂ → x₁ + ε * g x₁ ≠ x₂ + ε * g x₂) "]}
{"docString": "Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$.", "prompts": "[{\"theorem\":\n  \"∀ {T : ℝ} {g : ℝ → ℝ},\\n  Function.Periodic g T →\\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\\n`t ↦ ∫ x in 0..t, g x` tends to `∞` as `t` tends to `∞`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {f' : E →L[𝕜] F} {x : E} {s : Set E},\\n  HasFDerivWithinAt f f' s x →\\n    ∀ {α : Type u_4} (l : Filter α) {c : α → 𝕜} {d : α → E} {v : E},\\n      (∀ᶠ (n : α) in l, x + d n ∈ s) →\\n        Filter.Tendsto (fun n => ‖c n‖) l Filter.atTop →\\n          Filter.Tendsto (fun n => c n • d n) l (nhds v) →\\n            Filter.Tendsto (fun n => c n • (f (x + d n) - f x)) l (nhds (↑f' v))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\\ntangent cone related discussions. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + τ f`. \"},\n {\"theorem\":\n  \"∀ {T : ℝ} {g : ℝ → ℝ},\\n  Function.Periodic g T →\\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atBot Filter.atBot\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\\n`t ↦ ∫ x in 0..t, g x` tends to `-∞` as `t` tends to `-∞`. \"}]\n", "prompt_cons": "/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `∞` as `t` tends to `∞`. -/\ntheorem ∀ {T : ℝ} {g : ℝ → ℝ},\n  Function.Periodic g T →\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop :=\n\n/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\ntangent cone related discussions. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x : E} {s : Set E},\n  HasFDerivWithinAt f f' s x →\n    ∀ {α : Type u_4} (l : Filter α) {c : α → 𝕜} {d : α → E} {v : E},\n      (∀ᶠ (n : α) in l, x + d n ∈ s) →\n        Filter.Tendsto (fun n => ‖c n‖) l Filter.atTop →\n          Filter.Tendsto (fun n => c n • d n) l (nhds v) →\n            Filter.Tendsto (fun n => c n • (f (x + d n) - f x)) l (nhds (↑f' v)) :=\n\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem ∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If `g : ℝ → ℝ` is periodic with period `T > 0` and `0 < ∫ x in 0..T, g x`, then\n`t ↦ ∫ x in 0..t, g x` tends to `-∞` as `t` tends to `-∞`. -/\ntheorem ∀ {T : ℝ} {g : ℝ → ℝ},\n  Function.Periodic g T →\n    (∀ (t₁ t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n      0 < ∫ (x : ℝ) in 0 ..T, g x → 0 < T → Filter.Tendsto (fun t => ∫ (x : ℝ) in 0 ..t, g x) Filter.atBot Filter.atBot :=\n\n/-- Suppose $f$ is defined and differentiable for every $x>0$, and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. Prove that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. -/\ntheorem", "choices": ["∀ {𝕜 E F : Type u} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F},\n  (∀ x, HasDerivAt f (f' x) x) →\n    Filter.Tendsto f' Filter.atTop (nhds 0) →\n      ∀ (x : ℝ), ContinuousAt f x → Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F},\n  (∀ x, DifferentiableAt 𝕜 f x) →\n    (∀ x₀, Filter.Tendsto (fun x => deriv f x) (𝓝[{x₀}ᶜ] x₀) (nhds 0)) →\n      ∀ {α : Type u_4} (l : Filter α) {d : α → E},\n        Filter.Tendsto (fun n => d n) l Filter.atTop →\n          Filter.Tendsto (fun n => f (d n + 1) - f (d n)) l (nhds 0) ", "forall {𝕜 : Type u_1} [inst : NondiscreteNormedField 𝕜] {F : Type u_2} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : 𝕜 → F},\n  (∀ (x : 𝕜), x > 0 → HasDerivAt f (f' x) x) →\n    Filter.Tendsto f' Filter.atTop (nhds 0) →\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace ℝ E] {f : ℝ → E}\n  (h_deriv : ∀ x, DifferentiableAt ℝ f x) (h_tendsto : Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0)),\n  Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ (f : ℝ → ℝ) (f' : ℝ → ℝ),\n  (∀ x > 0, HasDerivAt f (f' x) x) →\n    Filter.Tendsto f' Filter.atTop (nhds 0) →\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ {E : Type u_1} [inst : NormedGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n(∀ x > 0, DifferentiableAt ℝ f x) →\n  Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) →\n    Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ {E : Type u_1} [inst : NormedGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n  (∀ x, 0 < x → HasDerivAt f (f' x) x) →\n    Filter.Tendsto f' Filter.atTop (nhds 0) →\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ {E : Type u_1} [inst : NormedGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n  (∀ (x : ℝ), 0 < x → DifferentiableAt ℝ f x) →\n    Filter.Tendsto (fun x => deriv f x) Filter.atTop (nhds 0) →\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {f : 𝕜 → 𝕜} {f' : 𝕜 → 𝕜},\n  (∀ x > 0, HasDerivAt f (f' x) x) →\n    Filter.Tendsto f' Filter.atTop (nhds 0) →\n      Filter.Tendsto (fun x => f (x + 1) - f x) Filter.atTop (nhds 0) ", "∀ {E : Type u_1} [inst_1 : NormedGroup E] [inst_2 : NormedSpace ℝ E] {f : ℝ → E} {f' : ℝ → E},\n  (∀ x > 0, DifferentiableAt ℝ f x) →\n    Filter.Tendsto f' (Filter.atTop) (nhds 0) →\n      Filter.Tendsto (fun x => f (x + 1) - f x) (Filter.atTop) (nhds 0) "]}
{"docString": "Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p →\\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\\n          (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p →\\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` tends locally uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. \"}]\n", "prompt_cons": "/-- If `Fₙ` tends uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` -/\ntheorem ∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\n          (nhds x) :=\n\n/-- If `Fₙ` tends locally uniformly to `f`, and `gₙ` tends to `x`, then `Fₙ gₙ` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto g p (nhds x) → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Suppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, and $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$ -/\ntheorem", "choices": ["∀ {E : Type u_1} [NondiscreteNormedField E] {c : E} {F : Type u_2} [NormedGroup F] [NormedSpace E F] {f g : E → F} {f' g' : F} {x : E},\n  (HasDerivWithinAt f f' (Set.Iio x) x ∨ HasDerivWithinAt f f' (Set.Ioi x) x) →\n    (HasDerivWithinAt g g' (Set.Iio x) x ∨ HasDerivWithinAt g g' (Set.Ioi x) x) → g' ≠ 0 → f x = 0 → g x = 0 →\n      Filter.Tendsto (fun t => f t / g t) (𝓝[Iio x] x ⊔ 𝓝[Ioi x] x) (nhds (f' / g')) ", "∀ {E : Type u_1} [inst : NormedGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {f' g' : E} {x : ℝ},\n  HasDerivAt f f' x → HasDerivAt g g' x → g' ≠ 0 → f x = g x → f x = 0 →\n    Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (f' / g')) ", "∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F] {𝕜 : Type u_5} [inst_2 : IsROrC 𝕜]\n  [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedSpace 𝕜 F] {f g : E → F} {f' g' : E → E →L[𝕜] F} {x : E},\n  HasFDerivAt f f' x →\n    HasFDerivAt g g' x →\n      g' x ≠ 0 →\n        f x = g x →\n          f x = 0 →\n            Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (f' x / g' x)) ", "∀ {E : Type u} [inst : NormedAddCommGroup E] {𝕜 : Type v} [inst_1 : NondiscreteNormedField 𝕜] [inst_2 : NormedSpace 𝕜 E] {f g : 𝕜 → E} {f' g' : E} {x : 𝕜},\n  HasFDerivAt f f' x → HasFDerivAt g g' x → g x = 0 → f x = 0 → g' ≠ 0 →\n    Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (f' / g')) ", "∀ {𝕜 : Type u} {E : Type v} [inst : NondiscreteNormedField 𝕜] [inst_1 : NormedSpace 𝕜 E] {f g : E → 𝕜} {x : E},\n  HasDerivAt f (deriv f x) x → HasDerivAt g (deriv g x) x → g x = 0 → f x = 0 →\n    deriv g x ≠ 0 → Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (deriv f x / deriv g x)) ", "∀ {α : Type u} {β : Type v} [inst : LinearOrderedField α] [inst_1 : NormedSpace α β] {f g : α → β} {x : α} {f' g' : β},\n  HasDerivAt f f' x → HasDerivAt g g' x → g' ≠ 0 → f x = 0 → g x = 0 →\n    Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (f' / g')) ", "∀ {E : Type u_1} {𝕜 : Type u_4} [inst : NormedAddCommGroup E] [inst_1 : IsROrC 𝕜] [inst_2 : NormedSpace 𝕜 E] {f g : E → 𝕜}\n  {x : E},\n  DifferentiableAt 𝕜 f x → f x = 0 →\n    DifferentiableAt 𝕜 g x → g x = 0 → g' x ≠ 0 →\n      Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (f' x / g' x)) ", "∀ {E : Type u} [_inst_1 : NormedGroup E] [_inst_2 : NormedSpace ℝ E] {f g : ℝ → E} {f' g' : E} {x : ℝ},\n  DifferentiableAt ℝ f x → DifferentiableAt ℝ g x → f x = 0 → g x = 0 → g' ≠ 0 →\n    HasDerivAt f (f' x) → HasDerivAt g (g' x) →\n      Filter.Tendsto (λ t, (f t) / (g t)) (nhds x) (nhds (f' x / g' x)) ", "∀ {𝕜 : Type u} [inst : IsROrC 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E] {F : Type x}\n  [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {x : E} {f g : E → F} {f' g' : E →L[𝕜] F},\n  HasDerivAt f f' x → HasDerivAt g g' x → g' ≠ 0 → f x = 0 → g x = 0 →\n    Filter.Tendsto (fun t => f t / g t) (nhds x) (nhds (f' / g')) ", "∀ {𝕜 : Type u} [inst : NondiscreteNormedField 𝕜] {E : Type v} [inst_1 : NormedGroup E] [inst_2 : NormedSpace 𝕜 E] {f g : 𝕜 → E} {f' g' : E} {x : 𝕜},\n  HasDerivAt f f' x → HasDerivAt g g' x → g x = 0 → g' ≠ 0 → f x = 0 →\n    Filter.Tendsto (λ t => f t / g t) (𝓝[{x}ᶜ] x) (𝓝 (f' / g')) "]}
{"docString": "Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$.", "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  ConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → 𝕜` is concave, then for any three points `x < y < z` the slope of the secant line of\\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\\n  StrictConcaveOn 𝕜 s f ↔\\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function `f : 𝕜 → 𝕜` is strictly concave iff for any three points `x < y < z` the slope of\\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\\n`[x, z]`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), x ≤ 0 → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → z.im ≤ 0 → ‖f z‖ ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\\n  for some `c < 2`;\\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\\n\\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. \"}]\n", "prompt_cons": "/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0} :=\n\n/-- If `f : 𝕜 → 𝕜` is concave, then for any three points `x < y < z` the slope of the secant line of\n`f` on `[x, y]` is greater than the slope of the secant line of `f` on `[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  ConcaveOn 𝕜 s f → ∀ {x y z : 𝕜}, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) ≤ (f y - f x) / (y - x) :=\n\n/-- A function `f : 𝕜 → 𝕜` is strictly concave iff for any three points `x < y < z` the slope of\nthe secant line of `f` on `[x, y]` is strictly greater than the slope of the secant line of `f` on\n`[x, z]`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : 𝕜 → 𝕜},\n  StrictConcaveOn 𝕜 s f ↔\n    Convex 𝕜 s ∧ ∀ ⦃x y z : 𝕜⦄, x ∈ s → z ∈ s → x < y → y < z → (f z - f y) / (z - y) < (f y - f x) / (y - x) :=\n\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), x ≤ 0 → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → z.im ≤ 0 → ‖f z‖ ≤ C :=\n\n/-- Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ Prove that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$. -/\ntheorem", "choices": ["∀ {f : ℝ → ℝ},\n  TimesContDiff ℝ 3 f (Set.Interval (-1) 1) →\n    f (-1) = 0 →\n      f 0 = 0 →\n        f 1 = 1 →\n          f.deriv 0 = 0 →\n            ∃ x ∈ Set.Interval (-1) 1, f.deriv.deriv.deriv x ≥ 3 ", "∀ {f : ℝ → ℝ},\n  TimesContDiff ℝ 3 f (Set.Interval (-1) 1) →\n  f (-1) = 0 → f 0 = 0 → f 1 = 1 → f' 0 = 0 →\n  (∃ x ∈ Set.Ioo (-1) 1, f''' x ≥ 3) ", "∀ {𝕜 : Type u_1} [inst :LinearOrderedField 𝕜] [inst_1 :NormedSpace 𝕜 𝕜] {f : 𝕜 → 𝕜},\n  DifferentiableAt 𝕜 f (3 : ℕ) (-1 : 𝕜) → DifferentiableAt 𝕜 f (3 : ℕ) (1 : 𝕜) → \n  f (-1) = 0 → f 0 = 0 → f 1 = 1 → deriv f 0 = 0 → \n  ∃ x ∈ Ioo (-1 : 𝕜) 1, deriv^[3] f x ≥ 3 ", "∀ {f : ℝ → ℝ},\n  (f (-1) = 0 ∧ f 0 = 0 ∧ f 1 = 1 ∧ deriv f 0 = 0) →\n    TimesContDiff ℝ 3 f (Set.Icc (-1) 1) →\n      (∃ x, -1 < x ∧ x < 1 ∧ deriv (deriv (deriv f)) x ≥ 3) ", "∀ {f : ℝ → ℝ},\n  HasDerivAt f 0 (-1) →\n    HasDerivAt f 0 0 →\n      HasDerivAt f 0 1 →\n        HasDerivWithinAt (deriv f) 0 (Set.Ioo (-1) 1) 0 →\n          ContinuousOn (deriv^[3] f) (Set.Icc (-1) 1) →\n            ∃ x ∈ Set.Ioo (-1) 1, deriv^[3] f x ≥ 3 ", "∀ {f : ℝ → ℝ},\n  TimesContDiff ℝ 3 f (-1, 1) →\n    f (-1) = 0 → f 0 = 0 → f 1 = 1 → f' 0 = 0 → ∃ x ∈ (-1, 1), f''' x ≥ 3 ", "∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : NondiscreteNormedField 𝕜] {f : 𝕜 → 𝕜},\n  Differentiable.times 𝕜 3 f (Set.Icc (-1 : 𝕜) 1) →\n    ∀ (x : 𝕜), x ∈ Set.Icc (-1 : 𝕜) 1 → f x - (3 * x ^ 2 - x ^ 3) = 0 →\n      f (-1) = 0 ∧ f 1 = 1 ∧ f 0 = 0 ∧ deriv f 0 = 0 →\n        (∃ x, x ∈ Set.Ioo (-1 : 𝕜) 1 ∧ 3 ≤ deriv^[3] f x) ", "∀ {f : ℝ → ℝ},\n  TimesContDiff ℝ 3 f (-1 ≤ x ∧ x ≤ 1) →\n    f (-1) = 0 → f 0 = 0 → f 1 = 1 → f.derivAt 0 = 0 →\n      (∃ (x : ℝ), -1 < x ∧ x < 1 ∧ (deriv ^ 3) f x ≥ 3) ", "∀ {f : ℝ → ℝ},\n  DiffContOnCl ℝ f (Set.Icc (-1) 1) →\n    DiffContOnCl ℝ (deriv f) (Set.Icc (-1) 1) →\n      DiffContOnCl ℝ (deriv (deriv f)) (Set.Icc (-1) 1) →\n        f (-1) = 0 → f 0 = 0 → f 1 = 1 → deriv f 0 = 0 →\n          ∃ x ∈ Set.Ioo (-1) 1, deriv (deriv (deriv f)) x ≥ 3 ", "∀ {f : ℝ → ℝ},\n  (∀ x : ℝ, -1 ≤ x → x ≤ 1 → ContinuouslyDifferentiableOn ℝ f (Set.Icc (-1) x)) →\n  (f (-1) = 0 ∧ f 0 = 0 ∧ f 1 = 1 ∧ deriv f 0 = 0) →\n  ∃ x : ℝ, -1 < x ∧ x < 1 ∧ (deriv^[3] f x) ≥ 3 "]}
{"docString": "Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$.", "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [t : TopologicalSpace α], t = ⊤ → ∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ U = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\\n  TendstoUniformlyOn F f p ∅\",\n  \"isProp\": true,\n  \"docString\": \"Uniform convergence on the empty set is vacuously true \"}]\n", "prompt_cons": "/-- If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ) :=\n\n/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem ∀ {α : Type u_1} [t : TopologicalSpace α], t = ⊤ → ∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ U = ⊤ :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- Uniform convergence on the empty set is vacuously true -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι},\n  TendstoUniformlyOn F f p ∅ :=\n\n/-- Show that the collection $$\\mathcal{T}_\\infty = \\{U | X - U \\text{ is infinite or empty or all of X}\\}$$ does not need to be a topology on the set $X$. -/\ntheorem", "choices": ["∃ {α : Type u_1} [t : TopologicalSpace α] [inst : Infinite α],\n  ¬(∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ Set.Infinite (α \\ U) ∨ U = ⊤) ", "∃ {X : Type u_1} [inst : TopologicalSpace X], ¬IsTopologicalBasis (λ (U : Set X), Infinite (X - U) ∨ U = ∅ ∨ U = Set.univ) ", "There is no specific theorem to prove for this statement. Instead, you can provide a counterexample where the given collection does not form a topology on the set `X`. Here's an explanation of such a counterexample:\n\nConsider the set `X = ℕ`, the set of natural numbers. Now, let's consider two sets in the collection `T_infty`:\n\n1. `U1 = {2, 4, 6, ...}`, the set of even numbers.\n2. `U2 = {3, 5, 7, ...}`, the set of odd numbers.\n\nBoth `U1` and `U2` are in `T_infty`, since their complements are infinite sets. However, if we take the union of `U1` and `U2`, we get the whole set `X = ℕ`. The complement of `X` is the empty set, which is also a member of `T_infty`. Therefore, the union of `U1` and `U2` should be in `T_infty`.\n\nOn the other hand, if we take the intersection of `U1` and `U2`, we get the empty set. The complement of the empty set is `X`, which is not infinite or empty. Therefore, the intersection of `U1` and `U2` is not in `T_infty`.\n\nSince the intersection of two sets in `T_infty` is not necessarily in `T_infty`, the collection does not form a topology on the set `X`.", "∃ {X : Type u_1} [inst : TopologicalSpace X],\n  ¬(∀ (U : Set X), U ∈ ({⊥, ⊤} ∪ {U : Set X | ¬Set.Finite (X \\ U)}) →\n  (∃ (V : TopologicalSpace.Opens X), U = V ∧ V = ⊥ ∨ V = ⊤)) ", "∃ {X : Type u_1} [inst : TopologicalSpace X],\n  (∃ (U V : Set X), (Set.Infinite (X - U) ∨ U = ∅ ∨ U = X) ∧ (Set.Infinite (X - V) ∨ V = ∅ ∨ V = X)\n   ∧ ¬(Set.Infinite (X - (U ∩ V)) ∨ (U ∩ V) = ∅ ∨ (U ∩ V) = X)) ", "∃ (X : Type u_1) (T_inf : Set (TopologicalSpace.Opens X)), \n  (∀ (U : TopologicalSpace.Opens X), U = ∅ ∨ X - U = ∅ ∨ X - U = X) ∧ \n  ¬ TopologicalSpace.IsTopologicalBasis T_inf ", "∃ {X : Type u_1} [inst : TopologicalSpace X], ¬(∀ (U : Set X), (∃ V : TopologicalSpace.Opens X, V.1 = X \\ U ∧ V.1 = ∅ ∨ V.1 = X) → TopologicalSpace.IsOpen X U) ", "∃ {X : Type u_1} [inst : TopologicalSpace X], ¬TopologicalSpace.mkOfNhds (λ x, {U : TopologicalSpace.Opens X | X - U.val = ∅ ∨ Set.Infinite (X - U.val) ∨ X - U.val = X}) = inst ", "∀ {X : Type u_1} [inst : TopologicalSpace X] (T_inf : TopologicalSpace.Opens X),\n  (∀ (U : Set X), U ∈ T_inf → X - U = ∅ ∨ Set.Infinite (X - U) ∨ X - U = X) → ¬(TopologicalSpace.IsTopologicalBasis (T_inf : Set (Set X))) ", "∃ {α : Type u_1} [t : TopologicalSpace α], \n  ¬TopologicalSpace.IsTopologicalBasis {U : TopologicalSpace.Opens α | Set.Infinite Uᶜ ∨ U = ⊥ ∨ U = ⊤} "]}
{"docString": "If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\\nwhere `Π i, π i` is endowed with the usual product topology. \"}]\n", "prompt_cons": "/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem ∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\n  Inducing fun x i => f i x :=\n\n/-- If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcup \\mathcal{T}_\\alpha$ does not need to be a topology on $X$. -/\ntheorem", "choices": ["Sorry, I cannot create a theorem for this statement as it is not a valid theorem. A theorem in Lean Theorem Prover must be a provable statement which follows the given examples. The given statement does not seem to be a provable theorem, and it does not follow the given examples. Please provide a new statement or clarify the existing one.", "This is a counterexample, not a theorem. Consider two topologies on a set X, one being the discrete topology and the other being the indiscrete topology. The union of these two topologies is not a topology on X, as it does not satisfy the definition of a topology (for example, the intersection of an open set from the discrete topology and an open set from the indiscrete topology would not be included in the union).", "This theorem cannot be proven as it is a counterexample rather than a theorem statement.", "Sorry, I cannot prove this statement as it is not a valid theorem. I can only provide proofs for valid theorems in Lean Theorem Prover code.", "This statement is not a formal theorem that can be proven in Lean, as it does not have a precise mathematical formulation. It is rather an informal observation or a warning about possible misunderstandings. Please provide a theorem statement that can be translated into Lean code.", "Not possible to prove: The statement \"∪ T_α is not a topology on X\" is not a theorem in Lean, because it cannot be expressed as a general statement that can be proven true or false. Lean theorems must have a specific form and make a clear assertion about a mathematical object or property. The given statement is too vague and not well-defined, so it cannot be translated into Lean code.", "Sorry, but I can't provide a theorem statement for that as Lean Theorem Prover deals with proving mathematical statements rather than providing counterexamples.", "Sorry, I cannot prove this statement as it is not a valid Lean theorem. However, I can provide you with an explanation instead:\n\nA topology on a set `X` is a collection of subsets of `X` that satisfy certain properties, like the union of any subcollection of the topology is also in the topology, finite intersections of the topology are also in the topology, and the empty set and the whole set are also in the topology.\n\nGiven a family of topologies `{𝔗_α}` on `X`, the union of these topologies might not satisfy these properties. For example, let `𝔗_1` and `𝔗_2` be two topologies on the same set `X`. If `A` is in `𝔗_1` and `B` is in `𝔗_2`, then the intersection `A ∩ B` might not be in either `𝔗_1` or `𝔗_2`. Hence, the union of `𝔗_1` and `𝔗_2` might not be closed under finite intersections, and therefore, might not be a topology on `X`.", "Sorry, I can only translate to Lean Theorem Prover code following the examples provided. Please provide an example in the format you want me to use.", "This statement is incorrect and cannot be proven in Lean Theorem Prover, as the union of topologies is not guaranteed to be a topology. Instead, one can show that the union of topologies does not form a topology with a counterexample."]}
{"docString": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\\nwhere `Π i, π i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the topology of a space is induced by a countable family of seminorms, then the topology\\nis first countable. \"}]\n", "prompt_cons": "/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖) :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem ∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\n  Inducing fun x i => f i x :=\n\n/-- If the topology of a space is induced by a countable family of seminorms, then the topology\nis first countable. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {ι : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : Module 𝕜 E] [inst_3 : Nonempty ι] [inst_4 : Countable ι] {p : SeminormFamily 𝕜 E ι}\n  [inst_5 : TopologicalSpace E], WithSeminorms p → TopologicalSpace.FirstCountableTopology E :=\n\n/-- Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique largest topology on $X$ contained in all the collections $\\mathcal{T}_\\alpha$. -/\ntheorem", "choices": ["∀ {α : Type u} {ι : Type u_1} [inst : ι → TopologicalSpace α],\n  ∃!t, (i : ι) → TopologicalSpace.LessThanOrEqual t (inst i) ", "∀ {X : Type u_1} {α : Type u_2} {T : α → TopologicalSpace X},\n  ∃ t : TopologicalSpace X, (∀ a, T a ≤ t) ∧ ∀ {t' : TopologicalSpace X}, (∀ a, T a ≤ t') → t ≤ t' ", "∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  ∃ (T_inf : TopologicalSpace X), (∀ (α : ι), T_inf ≤ T α) ∧ ∀ (t : TopologicalSpace X), (∀ (α : ι), t ≤ T α) → t ≤ T_inf ", "∀ {α : Type u} {ι : Type u_1} [t : TopologicalSpace α] [self : (i : ι) → TopologicalSpace α],\n  (⨅ (i : ι), self i) ≤ t ∧ ∀ (u : TopologicalSpace α), (⨅ (i : ι), self i) ≤ u → u ≤ t ", "∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X},\n  ∃ (T₀ : TopologicalSpace X), (∀ (i : ι), T₀ ≤ T i) ∧ ∀ (T' : TopologicalSpace X), (∀ (i : ι), T' ≤ T i) → T' ≤ T₀ ", "∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃ T' : TopologicalSpace X, (∀ i, T' ≤ T i) ∧ ∀ T'' : TopologicalSpace X, (∀ i, T'' ≤ T i) → T'' ≤ T' ", "∀ {α : Type u} {ι : Type u_1} (T : ι → TopologicalSpace α),\n  ∃ (t : TopologicalSpace α), (∀ (i : ι), t ≤ T i) ∧ ∀ (u : TopologicalSpace α), (∀ (i : ι), u ≤ T i) → u ≤ t ", "∀ {α : Type u} {T : α → TopologicalSpace X},\n  ∃ t, ∀ α₀, t ≤ T α₀ ∧ ∀ t' : TopologicalSpace X, (∀ α₀, t' ≤ T α₀) → t' ≤ t ", "∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X}, ∃! topology : TopologicalSpace X, \n  ∀ i : ι, topology ≤ T i ", "∀ {X : Type u_1} {ι : Type u_2} [inst : Nonempty ι] {T : ι → TopologicalSpace X},\n  ∃ t : TopologicalSpace X, (∀ i : ι, t ≤ T i) ∧ ∀ t' : TopologicalSpace X, (∀ i : ι, t' ≤ T i) → t' ≤ t "]}
{"docString": "Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  t = TopologicalSpace.generateFrom s →\\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → TopologicalSpace (E i)] {s : (i : ι) → Set (Set (E i))},\\n  (∀ (i : ι), TopologicalSpace.IsTopologicalBasis (s i)) →\\n    TopologicalSpace.IsTopologicalBasis (⋃ (i : ι), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"}]\n", "prompt_cons": "/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s}) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → TopologicalSpace (E i)] {s : (i : ι) → Set (Set (E i))},\n  (∀ (i : ι), TopologicalSpace.IsTopologicalBasis (s i)) →\n    TopologicalSpace.IsTopologicalBasis (⋃ (i : ι), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- Show that if $\\mathcal{A}$ is a subbasis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$. -/\ntheorem", "choices": ["∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  t = TopologicalSpace.generateFrom A →\n    t = ⋂₀ {B : TopologicalSpace α | A ⊆ B.istopologicalbasis} ", "∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  TopologicalSpace.generateFrom A = ⋂₀ {B : TopologicalSpace α | A ⊆ B.1} ", "∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  t = TopologicalSpace.generateFrom A →\n    t = ⋂₀ {T : Set (Set α) | TopologicalSpace α T ∧ A ⊆ T} ", "∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  TopologicalSpace.generateFrom A = ⋂₀ {B : Set (Set α) | TopologicalSpace.IsTopologicalBasis B ∧ A ⊆ B} ", "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    (∀ (t₁ : TopologicalSpace α), s ⊆ t₁.sets → t ≤ t₁) ", "∀ {α : Type u} (A : Set (Set α)),\n  TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace α | A ⊆ t.1} ", "∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  TopologicalSpace.generateFrom A = ⋂₀ {B : Set (Set α) | TopologicalSpace.IsTopologicalBasis B ∧ A ⊆ B} ", "∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  t = TopologicalSpace.generateFrom A →\n    t = ⋂₀ {u | TopologicalSpace α u ∧ A ⊆ u} ", "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  TopologicalSpace.IsSubbasis s →\n    t = ⨅ (u : Set (Set α)) (h : s ⊆ u),\n          TopologicalSpace.generateFrom u ", "∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  t = TopologicalSpace.generateFrom A →\n    t = ⋂₀ {τ : TopologicalSpace α | ∀ (B ∈ A), TopologicalSpace.IsOpen τ B} "]}
{"docString": "Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$.", "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {α : Type ua} [inst : UniformSpace α], Filter.HasBasis (uniformity α) (fun V => V ∈ uniformity α ∧ IsOpen V) id\",\n  \"isProp\": true,\n  \"docString\": \"Open elements of `𝓤 α` form a basis of `𝓤 α`. \"}]\n", "prompt_cons": "/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- Open elements of `𝓤 α` form a basis of `𝓤 α`. -/\ntheorem ∀ {α : Type ua} [inst : UniformSpace α], Filter.HasBasis (uniformity α) (fun V => V ∈ uniformity α ∧ IsOpen V) id :=\n\n/-- Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates the standard topology on $\\mathbb{R}$. -/\ntheorem", "choices": ["∀ {α : Type ua} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α],\n  TopologicalSpace.IsTopologicalBasis {Iio a | ∃ q : α, a = Rat.cast q} ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [LinearOrder α] [OrderTopology α]\n  (H : ∀ {x : α}, ∃ u H, x < u ∧ ∀ (z : α), z < u → x ≤ z),\n  TopologicalSpace.IsTopologicalBasis (SetOf fun V => ∃ (i j : ℚ), i < j ∧ Set.Ioo (i : α) j = V) ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : DenseOrder α],\n  TopologicalSpace.IsTopologicalBasis {s : Set α | ∃ (a b : α), s = Set.Ioo a b ∧ a < b ∧ a ∈ Set.Range coe ∧ b ∈ Set.Range coe} ", "∀ {α : Type u} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α],\n  TopologicalSpace.IsTopologicalBasis (SetOf fun (ab : α × α) => ab.fst < ab.snd ∧ ∃ p q : ℚ, ab.fst = coe p ∧ ab.snd = coe q) ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {q : Set α},\n  Set.Countable q → Dense q →\n    TopologicalSpace.IsTopologicalBasis (SetOf (fun t => ∃ (a b : α) (ha : a ∈ q) (hb : b ∈ q), a < t ∧ t < b)) ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : NoMinMax α],\n  TopologicalSpace.IsTopologicalBasis (SetOf fun I => ∃ a b : Rational, a < b ∧ I = Set.Ioo (coe a) (coe b)) ", "∀ {α : Type ua} [inst : UniformSpace α], Filter.HasBasis (uniformity α) (fun V => V ∈ uniformity α ∧ IsOpen V) id ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderableTopology α] [inst_3 : DenselyOrdered α] [inst_4 : TopologicalSpace.SecondCountableTopology α],\n  TopologicalSpace.IsTopologicalBasis {s : Set α | ∃ (a b : α), IsRational a ∧ IsRational b ∧ a < b ∧ s = Set.Ioo a b} ", "∀ {α : Type u} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α], LinearOrder.IsRationalBasis α →\n  TopologicalSpace.IsTopologicalBasis {t : Set α | ∃ a b : α, HasSubset.Subset (Set.Ioo a b) t ∧ a < b ∧ LinearOrder.IsRational a ∧ LinearOrder.IsRational b} ", "Real.topological_space_generate_from_rat : TopologicalSpace.IsTopologicalBasis {V : Set ℝ | ∃ (a b : ℚ), V = Set.Ioo a b} "]}
{"docString": "Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"}]\n", "prompt_cons": "/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤ :=\n\n/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- Show that if $Y$ is a subspace of $X$, and $A$ is a subset of $Y$, then the topology $A$ inherits as a subspace of $Y$ is the same as the topology it inherits as a subspace of $X$. -/\ntheorem", "choices": ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {s : Set X} {t : Set Y}\n  (h : s ⊆ ↑t), TopologicalSpace.induced (coe : s → X) = TopologicalSpace.induced (coe : t → Y) ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {s : Set Y} {A : Set X},\n  s ⊆ A → TopologicalSpace.induced (inclusion s) inst_1 = TopologicalSpace.induced (inclusion A) inst ", "∀ {X Y : Type u_1} [inst : TopologicalSpace X] {A : Set Y} [inst_1 : TopologicalSpace Y] [YSub : YSubspace X] [AInh : AInheritsTopology YSub],\n  TopologicalSpace.induced YSub.val AInh.to_supspc = TopologicalSpace.induced (YSub.val ∘ Y.inclusion) A ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y}\n  (hY : Y ⊆ X), ∀ (hA : A ⊆ Y), TopologicalSpace.induced hA (TopologicalSpace.induced hY inst) = TopologicalSpace.induced (λ a, hY (hA a)) inst ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y}\n  [inst_2 : SubspaceTopology Y X] [inst_3 : SubspaceTopology A Y], TopologicalSpace.induced (↿) inst_2 = TopologicalSpace.induced (↿) inst_3 ", "∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] [inst_2 : Subspace X Y]\n  (A : Set Y), Subspace.topologicalSpace A = Subspace.topologicalSpace (Subspace.comap A) ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y}\n  (e : Y ≃ₜ Set.Inclusion A) (h : Y ⊆ X), TopologicalSpace.induced e (TopologicalSpace.induced (Set.inclusion h) inst) = TopologicalSpace.induced (Set.inclusion (λ a, h (e a))) inst ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  {A : Set Y} (hY : Y ⊆ X) (hA : A ⊆ Y), TopologicalSpace.induced (embedding_subtype_coe hY) A = TopologicalSpace.induced (embedding_subtype_coe (Set.Subset.trans hA hY)) A ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set Y} {e : Y → X}\n  (he : Embedding e), A ⊆ Set.Range e → TopologicalSpace.induced e inst_1 = TopologicalSpace.induced (e ∘ Subtype.val) inst ", "∀ {X Y : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {s : Set Y},\n  A ⊆ s → TopologicalSpace.induced (coe : Y → X) inst_1 ≤ TopologicalSpace.induced (coe : Y → X) inst "]}
{"docString": "Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\": \"Cardinal.mk ↑Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the reals, as a set. \"}]\n", "prompt_cons": "/-- Rational numbers are dense in a linear ordered archimedean field. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- The cardinality of the reals, as a set. -/\ntheorem Cardinal.mk ↑Set.univ = Cardinal.continuum :=\n\n/-- Show that the countable collection \\[\\{(a, b) \\times (c, d) \\mid a < b \\text{ and } c < d, \\text{ and } a, b, c, d \\text{ are rational}\\}\\] is a basis for $\\mathbb{R}^2$. -/\ntheorem", "choices": ["∀ {α : Type u_2} {β : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], \n  TopologicalSpace.HasBasis (α × β) (λ abcd : Rat × Rat × Rat × Rat, abcd.1.1 < abcd.1.2 ∧ abcd.2.1 < abcd.2.2)\n    (λ abcd, Set.Ioo (abcd.1.1.cast, abcd.2.1.cast) (abcd.1.2.cast, abcd.2.2.cast)) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : LinearOrderedField α] [inst_3 : LinearOrderedField β] [inst_4 : OrderTopology α] [inst_5 : OrderTopology β]\n  [inst_6 : Archimedean α] [inst_7 : Archimedean β], TopologicalSpace.is_topological_basis {p : Set (α × β) | ∃ (a b c d : Rat), a < b ∧ c < d ∧ (Set.Ioo (Rat.cast a) (Rat.cast b) ×ˢ Set.Ioo (Rat.cast c) (Rat.cast d)) = p} ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrderedField α] [inst_2 : OrderTopology α] [inst_3 : Archimedean α],\n  TopologicalSpace.IsTopologicalBasis {ab : α × α | Rat.exists_embedding (λ p, ab.1 < p.1 ∧ p.1 < ab.2)\n                                        ∧ Rat.exists_embedding (λ p, ab.2 < p.1 ∧ p.1 < ab.4)} ", "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrderedField α] [inst_2 : OrderTopology α]\n  [inst_3 : Archimedean α], TopologicalSpace.IsTopologicalBasis (Set.Image2 (fun (a b : Rat) => Set.Ioo (Rat.cast a) (Rat.cast b)) Rat.univ Rat.univ) ", "∀ {α : Type u_2} {β : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  TopologicalSpace.is_topological_basis (SetOf (λ (s : Set (α × β)), ∃ (a b : ℝ) (ha : a < b) (c d : ℝ) (hc : c < d),\n    s = Set.Ioo (a, c) (b, d) ∧ a ∈ ℚ ∧ b ∈ ℚ ∧ c ∈ ℚ ∧ d ∈ ℚ)) ", "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : Archimedean α], (∃ (Q : Set (Set (α × α))), (∀ (B : Set (α × α)), B ∈ Q ↔ ∃ (a b c d : Rat),\n  a < b ∧ c < d ∧ B = Set.Ioo (a.cast, c.cast) (b.cast, d.cast))) → TopologicalSpace.IsTopologicalBasis Q ", "∀ {R : Type u_1} [inst : LinearOrderedField R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R]\n  [inst_3 : Archimedean R], Filter.HasBasis (Filter.principal (Set.Ioo ×ˢ Set.Ioo))\n    (λ (i : ℚ × ℚ × ℚ × ℚ), i.1.1 < i.1.2 ∧ i.2.1 < i.2.2) (λ i, (Set.Ioo ↑i.1.1 ↑i.1.2 ×ˢ Set.Ioo ↑i.2.1 ↑i.2.2)) ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrderedField α] [inst_2 : OrderTopology α] [inst_3 : Archimedean α],\n  TopologicalBasis (SetOf fun s => ∃ a b c d, a < b ∧ c < d ∧ s = Set.Ioo (a, c) (b, d)) ", "∀ {α : Type u_1} {β : Type u_2} [LinearOrderedField α] [LinearOrderedField β] [TopologicalSpace α] [TopologicalSpace β]\n  [inst_1 : OrderTopology α] [inst_2 : OrderTopology β] [inst_3 : Archimedean α] [inst_4 : Archimedean β],\n  TopologicalSpace.is_topological_basis\n    (SetOf (λ (s : Set (α × β)), ∃ (a b c d : ℚ),\n      s = Set.Ioo (Rat.cast a) (Rat.cast b) ×ˢ Set.Ioo (Rat.cast c) (Rat.cast d))) ", "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : Archimedean α], DenseRange Rat.cast "]}
{"docString": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LE β] {f g : α → β} {a : α},\\n  f ≤ᶠ[nhds a] g → ∀ᶠ (y : α) in nhds a, f ≤ᶠ[nhds y] g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f x ≤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\\n`f x ≤ g x` in a neighbourhood of `y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : OrderClosedTopology α],\\n  IsClosed {p | p.fst ≤ p.snd}\",\n  \"isProp\": true,\n  \"docString\": \"The set `{ (x, y) | x ≤ y }` is a closed set. \"},\n {\"theorem\":\n  \"∀ {f g : ℝ → ℝ} {a b : ℝ},\\n  a < b →\\n    ContinuousOn f (Set.Icc a b) →\\n      ContinuousOn g (Set.Icc a b) →\\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. \"}]\n", "prompt_cons": "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- If `f x ≤ g x` in a neighbourhood of `a`, then for `y` sufficiently close to `a` we have\n`f x ≤ g x` in a neighbourhood of `y`. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LE β] {f g : α → β} {a : α},\n  f ≤ᶠ[nhds a] g → ∀ᶠ (y : α) in nhds a, f ≤ᶠ[nhds y] g :=\n\n/-- The set `{ (x, y) | x ≤ y }` is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Preorder α] [self : OrderClosedTopology α],\n  IsClosed {p | p.fst ≤ p.snd} :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. -/\ntheorem ∀ {f g : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Icc a b) →\n      ContinuousOn g (Set.Icc a b) →\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x :=\n\n/-- Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Show that the set $\\{x \\mid f(x) \\leq g(x)\\}$ is closed in $X$. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder β] [t : OrderClosedTopology β]\n  [inst_2 : TopologicalSpace α] {f g : α → β} {s : Set α},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  Continuous f → Continuous g → IsClosed {x | f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder β] [t : OrderClosedTopology β]\n  [inst_2 : TopologicalSpace α] {f g : α → β} {s : Set α},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder β] [t : OrderClosedTopology β]\n  [inst_2 : TopologicalSpace α] {f g : α → β} {s : Set α},\n  Continuous f → Continuous g → IsClosed {x | f x ≤ g x} ", "forall {X Y : Type} [TopologicalSpace X] [Preorder Y] [TopologicalSpace Y] [OrderClosedTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → IsClosed {x | f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  Continuous f → Continuous g → IsClosed {x | f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder β] [t : OrderClosedTopology β]\n  [inst_2 : TopologicalSpace α] {f g : α → β},\n  Continuous f → Continuous g → IsClosed {x | f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder β] [t : OrderClosedTopology β]\n  [inst_2 : TopologicalSpace α] {f g : α → β} {s : Set α},\n  IsClosed s → Continuous f → Continuous g → IsClosed {x | x ∈ s ∧ f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  Continuous f → Continuous g → IsClosed {x | f x ≤ g x} ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder β] [t : OrderClosedTopology β]\n  [inst_2 : TopologicalSpace α] {f g : α → β} {s : Set α},\n  Continuous f → Continuous g → IsClosed {x | f x ≤ g x} "]}
{"docString": "Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\\n  Function.Injective f → Continuous f → T2Space α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of an injective continuous function is a Hausdorff space, then so is its\\ndomain. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\\ndiscrete space, then `f` is continuous. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"}]\n", "prompt_cons": "/-- If the codomain of an injective continuous function is a Hausdorff space, then so is its\ndomain. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {f : α → β},\n  Function.Injective f → Continuous f → T2Space α :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- If a function `f x y` is such that `y ↦ f x y` is continuous for all `x`, and `x` lives in a\ndiscrete space, then `f` is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] [inst_3 : DiscreteTopology α] {f : α → β → γ},\n  (∀ (a : α), Continuous (f a)) → Continuous (Function.uncurry f) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- Let $A \\subset X$; let $f: A \\rightarrow Y$ be continuous; let $Y$ be Hausdorff. Show that if $f$ may be extended to a continuous function $g: \\bar{A} \\rightarrow Y$, then $g$ is uniquely determined by $f$. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β]\n  {A : set α} {f : subtype A → β} (hf : Continuous f) (g₁ g₂ : C(A, β)),\n  (∀ a : subtype A, g₁ a = g₂ a) → g₁ = g₂ ", "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]\n  {A : Set X} {f : A → Y},\n  Continuous f → (∀ {g₁ g₂ : C(X, Y)}, g₁.restrict_clm A = g₂.restrict_clm A → g₁ = g₂) ", "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y] {A : Set X} {f : A → Y},\n  Continuous f → Continuous (Set.extend f) → Set.extend f = f ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β]\n  {A : Set α} {f : ↥A → β} {g₁ g₂ : C(↥(Closure A), β)},\n  ContinuousWithinAt f A → Continuous g₁ → Continuous g₂ →\n    (∀ (a : ↥A), ⇑g₁ a = f a) → (∀ (a : ↥A), ⇑g₂ a = f a) → g₁ = g₂ ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β]\n  {A : Set α} {f : ↥A → β} {g₁ g₂ : α →ₗ[𝕜] β},\n  Continuous f → Continuous g₁ → Continuous g₂ → (∀ x : ↥A, g₁ x = f x) → (∀ x : ↥A, g₂ x = f x) → g₁ = g₂ ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {A : Set α}\n  {f : A → β} (Hcont : ContinuousOn f A) (H₂ : IsClosed A),\n  (∀ (g₁ g₂ : C(A, β)), g₁.to_fun ∘ coe = f → g₂.to_fun ∘ coe = f → g₁ = g₂) ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]\n  {A : Set X} {f : A → Y} {g₁ g₂ : C(X, Y)}, ContinuousWithinAt f A → Continuous g₁ → Continuous g₂ →\n  Set.EqOn (⇑g₁) f A → Set.EqOn (⇑g₂) f A → Set.EqOn (⇑g₁) (⇑g₂) (Closure A) ", "∀ {X : Type u} {A : Set X} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]\n  (f : C(A, Y)), (∀ (g₁ g₂ : C(closure A, Y)), g₁.restrict = f → g₂.restrict = f → g₁ = g₂) ", "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y] {A : Set X}\n  {f : C(A, Y)} (h : IsClosed A),\n  (∀ (g₁ g₂ : C(cl A, Y)), g₁.restrict A = g₂.restrict A → g₁ = g₂) ", "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]\n  {A : Set X} {f : C(A, Y)} {g₁ g₂ : C(closure A, Y)},\n  ContinuousWithinAt (coe f) A ↔ ContinuousWithinAt (coe g₁) A ∧ ContinuousWithinAt (coe g₂) A → g₁ = g₂ "]}
{"docString": "Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable.", "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners ℝ E H →\\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\\n  Measurable f → MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  TopologicalSpace.MetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Urysohn's metrization theorem* (Tychonoff's version): a T₃ topological space with second\\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\\nsame topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, strongly measurable and measurable are equivalent. \"}]\n", "prompt_cons": "/-- A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners ℝ E H →\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\n  Measurable f → MeasureTheory.StronglyMeasurable f :=\n\n/-- *Urysohn's metrization theorem* (Tychonoff's version): a T₃ topological space with second\ncountable topology `X` is metrizable, i.e., there exists a metric space structure that generates the\nsame topology. -/\ntheorem ∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  TopologicalSpace.MetrizableSpace X :=\n\n/-- In a space with second countable topology, strongly measurable and measurable are equivalent. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.MetrizableSpace β] [inst_3 : BorelSpace β]\n  [inst_4 : TopologicalSpace.SecondCountableTopology β], MeasureTheory.StronglyMeasurable f ↔ Measurable f :=\n\n/-- Show that $\\mathbb{R} \\times \\mathbb{R}$ in the dictionary order topology is metrizable. -/\ntheorem", "choices": ["TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "Real.timesRealDictionaryOrderTopologicalSpace : TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "TopologicalSpace.MetrizableSpace (ℝ × ℝ) [inst : TopologicalSpace (ℝ × ℝ)] [inst_1 : LinearOrder ℝ] [inst_2 : OrderTopology ℝ] [inst_3 : TopologicalSpace.SecondCountableTopology ℝ] [inst_4 : TopologicalSpace.MetrizableSpace ℝ] ", "TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "Real.prod.MetrizableSpace : TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "TopologicalSpace.MetrizableSpace (ℝ × ℝ) ", "TopologicalSpace.metrizable_space (Prod ℝ ℝ (OrderTopology.toUniformSpace ℝ.le_rfl)) "]}
{"docString": "Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly.", "prompts": "[{\"theorem\":\n  \"∀ (f : CircleDeg1Lift) (x : ℝ),\\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : ℝ` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\\n  Monotone f → ∀ (n : ℕ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℕ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}\\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace 𝕜 E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\\n  {I' : ModelWithCorners 𝕜 E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M → M'} {x : M} {n : ℕ},\\n  ContMDiffAt I I' (↑n) f x ↔ ∀ᶠ (x' : M) in nhds x, ContMDiffAt I I' (↑n) f x'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: This does not hold for `n = ∞`. `f` being `C^∞` at `x` means that for every `n`, `f` is\\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\\n  Monotone f → ∀ (n : ℤ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℤ), f a ≠ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. \"}]\n", "prompt_cons": "/-- For any `x : ℝ` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem ∀ (f : CircleDeg1Lift) (x : ℝ),\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- If `f` is a monotone function from `ℕ` to a preorder such that `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℕ → α},\n  Monotone f → ∀ (n : ℕ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℕ), f a ≠ x :=\n\n/-- Note: This does not hold for `n = ∞`. `f` being `C^∞` at `x` means that for every `n`, `f` is\n`C^n` on some neighborhood of `x`, but this neighborhood can depend on `n`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace 𝕜 E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\n  {I' : ModelWithCorners 𝕜 E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : M → M'} {x : M} {n : ℕ},\n  ContMDiffAt I I' (↑n) f x ↔ ∀ᶠ (x' : M) in nhds x, ContMDiffAt I I' (↑n) f x' :=\n\n/-- If `f` is a monotone function from `ℤ` to a preorder and `x` lies between `f n` and\n`f (n + 1)`, then `x` doesn't lie in the range of `f`. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {f : ℤ → α},\n  Monotone f → ∀ (n : ℤ) {x : α}, f n < x → x < f (n + 1) → ∀ (a : ℤ), f a ≠ x :=\n\n/-- Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}\\right)$ does not converge uniformly. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : NormedGroup α] [inst_1 : NormedSpace ℝ α] {ι : Type u_1} (F : ι → α → α)\n  (x₀ : α) (n : ℕ), ¬UniformConvergent (fun i => F i (λ x => x ^ n)) ", "∀ {α : Type u} [inst : NormedField α] [inst_1 : CompleteSpace α],\n  ¬Filter.TendstoUniformly (fun n x => x^n) (fun x => 0) Filter.atTop (𝓝[Set.Icc (0:α) 1] 0) ", "∀ {α : Type u} [inst : NormedGroup α] [inst_1 : NormedSpace ℝ α] {n : ℕ},\n  ¬UniformlyConvergent (fun n x => x ^ n) ", "∀ (n : ℕ) (x : ℝ), 0 ≤ x → x ≤ 1 → (fun n x => x ^ n) n x ", "∀ {α : Type u} [inst : NontriviallyNormedField α] [inst_1 : CompleteSpace α] [inst_2 : Archimedean α],\n  ¬UniformlyContinuous (fun (n : ℕ) => fun (x : α) => x ^ n) ", "not_uniformly_convergent_fn : ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormedGroup α],\n  ¬Filter.Tendsto (fun n => fun x => x ^ n) Filter.atTop (nhds (fun x => 0)) ", "∀ {ℝ : Type u} [inst : NontriviallyNormedField ℝ] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace ℝ E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type u_4}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {E' : Type u_5}\n  [inst_7 : NormedAddCommGroup E'] [inst_8 : NormedSpace ℝ E'] {H' : Type u_6} [inst_9 : TopologicalSpace H']\n  {I' : ModelWithCorners ℝ E' H'} {M' : Type u_7} [inst_10 : TopologicalSpace M'] [inst_11 : ChartedSpace H' M']\n  [inst_12 : SmoothManifoldWithCorners I' M'] {f : ℕ → (M → M')},\n  (∀ n, ∀ᶠ (x : M) in nhds (0 : M), ContinuousAt (f n) x) → ¬(uniformly_convergent (λ n x, f n x) (λ x, 0)) ", "∀ {α : Type u} [inst : NormedGroup α] [inst_1 : NormedSpace ℝ α] {f : ℕ → ℝ → α},\n  (∀ n x, f n x = x^n) → ¬ Filter.TendstoUniformly f (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (0:α))) Filter.atTop ", "∀ {α : Type u} [inst : LinearOrderedField α] (f : ℕ → α → α),\n  (∀ n : ℕ, ∀ x ∈ Set.Icc (0 : α) 1, f n x = x ^ n) →\n  ¬UniformContinuous fun p : ℕ × α, f p.fst p.snd ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : ℕ → E → 𝕜} {x : E},\n  (f n x = x ^ n) → ¬Filter.TendstoUniformly f (fun x => 0) Filter.atTop "]}
{"docString": "Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\\nhomotopic to `ContinuousMap.pi f₁`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"}]\n", "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\nhomotopic to `ContinuousMap.pi f₁`. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁) :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Let $p: X \\rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \\rightarrow X$ such that $p \\circ f$ equals the identity map of $Y$, then $p$ is a quotient map. -/\ntheorem", "choices": ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  Continuous p → (∃ (f : Y → X), Continuous f ∧ p ∘ f = id) → QuotientMap p ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  Continuous p → (∃ (f : Y → X) (hf : Continuous f), (Function.comp p f) = id) → QuotientMap p ", "forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y} {f : Y → X},\n  Continuous p → Continuous f → Function.comp p f = id → QuotientMap p ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β},\n  Continuous p → (∃ (f : β → α), Continuous f ∧ (p ∘ f = id)) → QuotientMap p ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β} {f : β → α},\n  Continuous p → Continuous f → (p ∘ f = id) → QuotientMap p ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y}\n  {f : Y → X}, Continuous p → Continuous f → Function.LeftInverse (⇑(p ∘ f)) id → QuotientMap p ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β} {f : β → α},\n  Continuous p → Continuous f → (p ∘ f = id) → QuotientMap p ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β} {f : β → α},\n  Continuous p → Continuous f → (p ∘ f = id) → QuotientMap p ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  Continuous p → (∃ (f : Y → X), Continuous f ∧ Function.LeftInverse f p) → QuotientMap p ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  Continuous p → (∃ (f : Y → X), Continuous f ∧ (Function.comp p f = id)) → QuotientMap p "]}
{"docString": "Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : ContinuousConstSMul Γ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group action is an open\\nquotient. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\\n  [inst_3 : ContinuousConstVAdd Γ T], IsOpenMap Quotient.mk'\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient map by a group action is open, i.e. the quotient by a group\\naction is an open quotient. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, IsOpenMap ↑f.linear ↔ IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. \"}]\n", "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group action is an open\nquotient. -/\ntheorem ∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\n  [inst_3 : ContinuousConstSMul Γ T], IsOpenMap Quotient.mk' :=\n\n/-- The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. -/\ntheorem ∀ {Γ : Type u_1} [inst : AddGroup Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : AddAction Γ T]\n  [inst_3 : ContinuousConstVAdd Γ T], IsOpenMap Quotient.mk' :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem ∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, IsOpenMap ↑f.linear ↔ IsOpenMap ↑f :=\n\n/-- Let $p \\colon X \\rightarrow Y$ be an open map. Show that if $A$ is open in $X$, then the map $q \\colon A \\rightarrow p(A)$ obtained by restricting $p$ is an open map. -/\ntheorem", "choices": ["∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → ∀ (A : Set α) (hA : IsOpen A), IsOpenMap (Set.restrict f A) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {A : Set α},\n  IsOpenMap f → IsOpen A → IsOpenMap (Set.restrict f A) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β}\n  {A : Set α} (hf : IsOpenMap f) (hA : IsOpen A), IsOpenMap (Set.restrict f A) ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y} {A : Set X},\n  IsOpenMap p → IsOpen A → IsOpenMap (Set.restrict p A) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {A : Set α},\n  IsOpenMap f → IsOpen A → IsOpenMap (Set.restrict f A) ", "∀ {X Y A : Type u_1} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  IsOpenMap p → IsOpen A → IsOpenMap (Set.restrict p A) ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y} {A : Set X},\n  IsOpenMap p → IsOpen A → IsOpenMap (λ x, p (x:A)) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → ∀ (A : Set α), IsOpen A → IsOpenMap (Set.restrict f A) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β} (A : Set α), \n  IsOpenMap p → IsOpen A → IsOpenMap (Set.restrict p A) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {A : Set α},\n  IsOpenMap f → IsOpen A → IsOpenMap (Set.restrict f A) "]}
{"docString": "Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"}]\n", "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- Let $\\left\\{A_{\\alpha}\\right\\}$ be a collection of connected subspaces of $X$; let $A$ be a connected subset of $X$. Show that if $A \\cap A_{\\alpha} \\neq \\varnothing$ for all $\\alpha$, then $A \\cup\\left(\\bigcup A_{\\alpha}\\right)$ is connected. -/\ntheorem", "choices": ["∀ {α : Type u} {ι : Type v} [inst : TopologicalSpace α] {A : Set α} {Aα : ι → Set α},\n  IsConnected A →\n    (∀ (i : ι), IsConnected (Aα i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ Aα i)) → IsConnected (A ∪ ⋃ (i : ι), Aα i) ", "∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type v} {A : Set X} {A_α : ι → Set X},\n  Connected A →\n    (∀ (i : ι), Connected (A_α i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ A_α i)) → Connected (A ∪ ⋃ (i : ι), A_α i) ", "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X} {ι : Type v} (B : ι → Set X),\n  ∀ [self : IsConnected A] (hB : ∀ (i : ι), IsConnected (B i)),\n    (∀ (i : ι), Set.Nonempty (A ∩ B i)) → IsConnected (A ∪ ⋃ (i : ι), B i) ", "∀ {X : Type u} [inst : TopologicalSpace X] {α : Type*} (A : Set X) (As : α → Set X),\n  IsConnected A →\n    (∀ (i : α), IsConnected (As i)) →\n      (∀ (i : α), Set.Nonempty (A ∩ As i)) → IsConnected (A ∪ ⋃ (i : α), As i) ", "∀ {X : Type u} [inst : TopologicalSpace X] {A : Set X} {ι : Type v} {C : ι → Set X},\n  IsConnected A →\n    (∀ (i : ι), IsConnected (C i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ C i)) → IsConnected (A ∪ ⋃ (i : ι), C i) ", "∀ {X : Type u_1} [inst : TopologicalSpace X] {ι : Type v_1} {A : Set X} {Aα : ι → Set X},\n  IsPreconnected A →\n    (∀ i, IsPreconnected (Aα i)) →\n      (∀ i, Set.Nonempty (A ∩ Aα i)) → IsPreconnected (A ∪ ⋃ (i : ι), Aα i) ", "∀ {X : Type u} [inst : TopologicalSpace X] {A : Set X} {ι : Type v} (C : ι → Set X),\n  IsConnected A →\n    (∀ (i : ι), IsConnected (C i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ C i)) → IsConnected (A ∪ ⋃ (i : ι), C i) ", "∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type v} {A : Set X} {Aα : ι → Set X},\n  IsConnected A →\n    (∀ (i : ι), IsConnected (Aα i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ Aα i)) → IsConnected (A ∪ ⋃ (i : ι), Aα i) ", "∀ {X : Type u_1} [inst : TopologicalSpace X] {ι : Type u} (A : Set X) {A' : ι → Set X},\n  Connected A →\n    (∀ (i : ι), Connected (A' i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ A' i)) → Connected (A ∪ ⋃ (i : ι), A' i) ", "∀ {α : Type u} {ι : Type v} [inst : TopologicalSpace α] {A : Set α} {B : ι → Set α},\n  IsConnected A →\n    (∀ (i : ι), IsConnected (B i)) →\n      (∀ (i : ι), Set.Nonempty (A ∩ B i)) → IsConnected (A ∪ ⋃ (i : ι), B i) "]}
{"docString": "Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] {A B : Set E},\\n  IsExposed 𝕜 A B → Set.Nonempty B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\\ndoesn't intersect `A`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] [inst_5 : Nontrivial 𝕜] {A B : Set E},\\n  IsExposed 𝕜 A B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nontrivial `𝕜`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\\nhalfspace doesn't intersect `A`. \"}]\n", "prompt_cons": "/-- If `B` is a nonempty exposed subset of `A`, then `B` is the intersection of `A` with some closed\nhalfspace. The converse is *not* true. It would require that the corresponding open halfspace\ndoesn't intersect `A`. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] {A B : Set E},\n  IsExposed 𝕜 A B → Set.Nonempty B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x} :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- For nontrivial `𝕜`, if `B` is an exposed subset of `A`, then `B` is the intersection of `A` with\nsome closed halfspace. The converse is *not* true. It would require that the corresponding open\nhalfspace doesn't intersect `A`. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : TopologicalSpace 𝕜] [inst_1 : OrderedRing 𝕜] [inst_2 : AddCommMonoid E]\n  [inst_3 : TopologicalSpace E] [inst_4 : Module 𝕜 E] [inst_5 : Nontrivial 𝕜] {A B : Set E},\n  IsExposed 𝕜 A B → ∃ l a, B = {x | x ∈ A ∧ a ≤ ↑l x} :=\n\n/-- Let $A \\subset X$. Show that if $C$ is a connected subspace of $X$ that intersects both $A$ and $X-A$, then $C$ intersects $\\operatorname{Bd} A$. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] {A C : Set α},\n  IsConnected C → Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (Set.Univ \\ A)) → Set.Nonempty (C ∩ Boundary A) ", "∀ {α : Type u} [inst : TopologicalSpace α] {A C : Set α},\n  IsConnected C →\n    Set.Nonempty (C ∩ A) →\n      Set.Nonempty (C ∩ (HasCompl.compl A)) → Set.Nonempty (C ∩ Frontier A) ", "∀ {X : Type u} [inst : TopologicalSpace X] {A C : Set X},\n  IsConnected C →\n    Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (X \\ A)) → Set.Nonempty (C ∩ Boundary A) ", "∀ {α : Type u} [inst : TopologicalSpace α] {A C : Set α},\n  IsConnected C → Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (α \\ A)) → Set.Nonempty (C ∩ Boundary A) ", "∀ {X : Type u_1} [inst : TopologicalSpace X] {A C : Set X},\n  IsConnected C →\n    Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (X \\ A)) → Set.Nonempty (C ∩ Boundary A) ", "∀ {α : Type u} [inst : TopologicalSpace α] {A C : Set α},\n  IsConnected C →\n    Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (HasCompl.compl A)) → Set.Nonempty (C ∩ (Frontier A)) ", "∀ {X : Type u} [inst : TopologicalSpace X] {A C : Set X},\n  IsConnected C →\n    (Set.Nonempty (C ∩ A) ∧ Set.Nonempty (C ∩ (X \\ A))) → Set.Nonempty (C ∩ Frontier A) ", "∀ {X : Type u} [inst : TopologicalSpace X] {A C : Set X},\n  IsConnected C → Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (X - A)) → Set.Nonempty (C ∩ Boundary A) ", "∀ {α : Type u} [inst : TopologicalSpace α] {A C : Set α},\n  IsConnected C →\n    Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (HasCompl.compl A)) → Set.Nonempty (C ∩ Frontier A) ", "∀ {X : Type u_1} [inst : TopologicalSpace X] {A C : Set X},\n  IsConnected C →\n    Set.Nonempty (C ∩ A) → Set.Nonempty (C ∩ (X - A)) → Set.Nonempty (C ∩ Boundary A) "]}
{"docString": "Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any two points of a set are contained in a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\\nhomotopic to `ContinuousMap.pi f₁`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"}]\n", "prompt_cons": "/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s :=\n\n/-- If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\nhomotopic to `ContinuousMap.pi f₁`. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁) :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- Let $p: X \\rightarrow Y$ be a quotient map. Show that if each set $p^{-1}(\\{y\\})$ is connected, and if $Y$ is connected, then $X$ is connected. -/\ntheorem", "choices": ["∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  QuotientMap f → (∀ (y : β), IsConnected (f ⁻¹' {y})) → IsConnected Y → IsConnected X ", "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  QuotientMap p → (∀ (y : Y), IsConnected (p ⁻¹' {y})) → IsConnected Y → IsConnected X ", "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  QuotientMap p → (∀ (y : Y), IsConnected (p ⁻¹' {y})) → IsConnected Y → IsConnected X ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  QuotientMap p → (∀ (y : Y), IsConnected (p⁻¹' {y})) → IsConnected Y → IsConnected X ", "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  QuotientMap p → (∀ (y : Y), IsConnected (p ⁻¹' {y})) → IsConnected Y → IsConnected X ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β},\n  QuotientMap p → (∀ (y : β), IsConnected (p ⁻¹' {y})) → IsConnected Y → IsConnected α ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  QuotientMap f → (∀ (y : β), IsConnected (f ⁻¹' singleton y)) → IsConnected β → IsConnected α ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β},\n  QuotientMap p → (∀ (y : β), IsConnected (p ⁻¹' {y})) → IsConnected Y → IsConnected X ", "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  QuotientMap p → (∀ (y : Y), IsConnected (p ⁻¹' {y})) → IsConnected Y → IsConnected X ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  QuotientMap f → (∀ (y : β), IsConnected (f ⁻¹' {y})) → IsConnected β → IsConnected α "]}
{"docString": "Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.)", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] {x : α}, Continuous fun f => ↑f x\",\n  \"isProp\": true,\n  \"docString\": \"When `x` is fixed, `(f : α →ᵇ β) ↦ f x` is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\\n  Continuous f → IsClosed (Function.fixedPoints f)\",\n  \"isProp\": true,\n  \"docString\": \"The set of fixed points of a continuous map is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α} {x y : α},\\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) → ContinuousAt f y → Function.IsFixedPt f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\\nthen `y` is a fixed point for `f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"}]\n", "prompt_cons": "/-- When `x` is fixed, `(f : α →ᵇ β) ↦ f x` is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β] {x : α}, Continuous fun f => ↑f x :=\n\n/-- The set of fixed points of a continuous map is a closed set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α},\n  Continuous f → IsClosed (Function.fixedPoints f) :=\n\n/-- If the iterates `f^[n] x` converge to `y` and `f` is continuous at `y`,\nthen `y` is a fixed point for `f`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α} {x y : α},\n  Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) → ContinuousAt f y → Function.IsFixedPt f y :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem ∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x :=\n\n/-- Let $f \\colon X \\rightarrow X$ be continuous. Show that if $X = [0, 1]$, there is a point $x$ such that $f(x) = x$. (The point $x$ is called a fixed point of $f$.) -/\ntheorem", "choices": ["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {f : X → X},\n  Continuous f → (∀ (x : X), x = 0 ∨ x = 1) → ∃ (x : X), Function.IsFixedPt f x ", "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α] [inst_3 : Preorder α],\n  Continuous f → ∃ (x : α), f x = x ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {f : X → X},\n  Continuous f → X = set.Icc (0 : ℝ) 1 → ∃ x, Function.IsFixedPt f x ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {f : X → X},\n  Continuous f → (∀ (x : X), HasMem.Mem x (@Set.Icc X _ 0 1)) → ∃ x, Function.IsFixedPt f x ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {f : X → X},\n  Continuous f → (0 : ℝ) ∈ X ∧ (1 : ℝ) ∈ X → ∃ x, f x = x ", "∀ {α : Type u} {f : α → α} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LinearOrder α] [inst_3 : OrderClosedTopology α] (hf : Continuous f) (h0 : f 0 ≤ 0) (h1 : f 1 ≥ 1),\n  ∃ x : α, Function.IsFixedPt f x ", "∀ {X : Type} [inst : TopologicalSpace X] [inst_1 : ConditionallyCompleteLinearOrder X] [inst_2 : OrderTopology X] {f : X → X},\n  Continuous f → (∀ (x : X), 0 ≤ x ∧ x ≤ 1) → ∃ x : X, Function.IsFixedPt f x ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace α] [inst_2 : CompactInterval α] {f : α → α},\n  Continuous f → ∃ (x : α), Function.IsFixedPt f x ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrderₓ α] [inst_2 : OrderClosedTopology α] [inst_3 : Preorderₓ α] {f : α → α},\n  Continuous f → ∃ (x : α), f x = x ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : ConditionallyCompleteLinearOrder X] [inst_2 : OrderTopology X] {f : X → X},\n  Continuous f → X = set.Icc (0 : X) 1 → ∃ x, f x = x "]}
{"docString": "Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological group `G` with normal subgroup `N`, `1 : G ⧸ N` has a\\ncountable neighborhood basis. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n", "prompt_cons": "/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- In a first countable topological group `G` with normal subgroup `N`, `1 : G ⧸ N` has a\ncountable neighborhood basis. -/\ntheorem ∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Let $G$ be a topological group; let $C$ be the component of $G$ containing the identity element $e$. Show that $C$ is a normal subgroup of $G$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.of (ConnectedComponent (1 : G))) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G], Subgroup.Normal (Subgroup.component (1 : G)) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G], Subgroup.Normal (Subgroup.component (Subgroup.center G)) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component 1) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G],\n  Subgroup.Normal (Subgroup.component (1 : G)) ", "∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G], Subgroup.Normal (Subgroup.component (1 : G)) "]}
{"docString": "Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact.", "prompts": "[{\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\": \"∀ {X Y : Profinite} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of profinite spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"}]\n", "prompt_cons": "/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- Any morphism of profinite spaces is a closed map. -/\ntheorem ∀ {X Y : Profinite} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- Let $p: X \\rightarrow Y$ be a closed continuous surjective map such that $p^{-1}(\\{y\\})$ is compact, for each $y \\in Y$. (Such a map is called a perfect map.) Show that if $Y$ is compact, then $X$ is compact. -/\ntheorem", "choices": ["∀ {X Y : Type} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : Y, IsCompact (p ⁻¹' {y})) → CompactSpace Y → CompactSpace X ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β},\n  IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : β, IsCompact (p ⁻¹' singleton y)) → CompactSpace β → CompactSpace α ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace β]\n  {p : α → β}, IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : β, IsCompact (p ⁻¹' {y})) → CompactSpace α ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  {p : α → β}, IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : β, IsCompact (p ⁻¹' {y})) →\n  CompactSpace β → CompactSpace α ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace β]\n  {f : α → β}, IsClosedMap f → Continuous f → Function.Surjective f → (∀ y : β, IsCompact (f ⁻¹' {y})) → CompactSpace α ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {p : α → β},\n  IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : β, IsCompact (p ⁻¹' {y})) → CompactSpace β → CompactSpace α ", "∀ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {p : X → Y},\n  IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : Y, IsCompact (p ⁻¹' {y})) → CompactSpace Y → CompactSpace X ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β]\n  {p : α → β}, IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : β, IsCompact (p ⁻¹' {y})) →\n  CompactSpace β → CompactSpace α ", "∀ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace Y] {p : X → Y},\n  IsClosedMap p → Continuous p → Function.Surjective p → (∀ y : Y, IsCompact (p ⁻¹' {y})) → CompactSpace X ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : CompactSpace β] {f : α → β}, IsClosedMap f → Continuous f → Function.Surjective f →\n  (∀ y : β, IsCompact (f ⁻¹' singleton y)) → CompactSpace α "]}
{"docString": "A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness.", "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\\nthat cover the entire space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"}]\n", "prompt_cons": "/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- In a σ-compact space, there exists (by definition) a countable collection of compact subspaces\nthat cover the entire space. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : SigmaCompactSpace α],\n  ∃ K, (∀ (n : ℕ), IsCompact (K n)) ∧ ⋃ (n : ℕ), K n = Set.univ :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- A space $X$ is said to be countably compact if every countable open covering of $X$ contains a finite subcollection that covers $X$. Show that for a $T_1$ space $X$, countable compactness is equivalent to limit point compactness. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α],\n  CountablyCompactSpace α ↔ LimitPointCompactSpace α ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α],\n  CountablyCompactSpace α ↔ LimitPointCompactSpace α ", "∀ {X : Type u_1} [inst : T1Space X] [inst_1 : TopologicalSpace X], \n  CountablyCompactSpace X ↔ LimitPointCompactSpace X ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T1Space α],\n  CountablyCompactSpace α ↔ LimitPointCompactSpace α ", "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : T1Space α],\n  CountablyCompactSpace α ↔ LimitPointCompactSpace α ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [T1Space α],\n  CountablyCompact α ↔ LimitPointCompact α ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α],\n  CountablyCompactSpace α ↔ LimitPointCompactSpace α ", "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α],\n  CountablyCompactSpace α ↔ LimitPointCompactSpace α ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [T1Space X],\n  CountablyCompactSpace X ↔ LimitPointCompactSpace X ", "forall {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X],\n  CountablyCompactSpace X ↔ LimitPointCompactSpace X "]}
{"docString": "Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism.", "prompts": "[{\"theorem\": \"∀ {α : Type u} [inst : PseudoMetricSpace α], Isometry ↑α\",\n  \"isProp\": true,\n  \"docString\":\n  \"The embedding of a metric space in its completion is an isometry. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformInducing f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform inducing map \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\\n  Isometry f → UniformContinuous f\",\n  \"isProp\": true,\n  \"docString\": \"An isometry from a metric space is a uniform continuous map \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"}]\n", "prompt_cons": "/-- The embedding of a metric space in its completion is an isometry. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α], Isometry ↑α :=\n\n/-- An isometry from a metric space is a uniform inducing map -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformInducing f :=\n\n/-- An isometry from a metric space is a uniform continuous map -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},\n  Isometry f → UniformContinuous f :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- Let $(X, d)$ be a metric space. If $f: X \\rightarrow X$ satisfies the condition $d(f(x), f(y))=d(x, y)$ for all $x, y \\in X$, then $f$ is called an isometry of $X$. Show that if $f$ is an isometry and $X$ is compact, then $f$ is bijective and hence a homeomorphism. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → α},\n  Isometry f → CompactSpace α → Function.Bijective f ∧ Homeomorph α α ", "∀ {X : Type u} [inst : PseudoMetricSpace X] [inst_1 : TopologicalSpace X] [inst_2 : CompactSpace X],\n  let f : X → X ", "forall {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : CompactSpace α] {f : α → α},\n  Isometry f → Function.Bijective f ∧ Homeomorphism f ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → α},\n  Isometry f → IsCompact α → Function.Bijective f ∧ Homeomorph α α ", "∀ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] (f : X → X), Isometry f → Function.Bijective f ∧ Homeomorphism X X ", "∀ {X : Type u} [inst : MetricSpace X] [inst_1 : CompactSpace X] (f : X → X), \n  Isometry f → Function.Bijective f ∧ Homeomorph X X ", "∀ {X : Type u} [inst : MetricSpace X] [CompactSpace X] (f : X → X),\n  Isometry f → (Function.Bijective f ∧ Homeomorphism X X) ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → α},\n  Isometry f → IsCompact α → Function.Bijective f ∧ Homeomorphism α α ", "∀ {X : Type u} [inst : PseudoMetricSpace X] [inst_1 : CompactSpace X] {f : X → X},\n  Isometry f → Function.Bijective f ∧ Homeomorph X X ", "∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → α},\n  Isometry f → IsCompact α → Function.Bijective f ∧ Homeomorph α α "]}
{"docString": "Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\":\n  \"∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\\n  {p : Filter ι} {F : ι → C(α, β)}, TendstoLocallyUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto F p (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Locally uniform convergence implies convergence in the compact-open topology. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"}]\n", "prompt_cons": "/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ :=\n\n/-- If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ) :=\n\n/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem ∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\n  {p : Filter ι} {F : ι → C(α, β)}, TendstoLocallyUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto F p (nhds f) :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- Show that $[0, 1]^\\omega$ is not locally compact in the uniform topology. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : UniformSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  {β : Type u_2} [inst_3 : TopologicalSpace β] [inst_4 : Compactum β], ¬LocallyCompactSpace (↥(α →₀ β)) ", "∀ {ω : Type u_1} [inst : Infinite ω] [inst_1 : Nonempty ω] [inst_2 : UniformSpace (ℝ × ℝ)],\n  ¬LocallyCompactSpace (ω → ℝ × ℝ) ", "not_locally_compact_space_uniformity_bounded_closed_finite_dimensional : ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : UniformSpace α] [inst_2 : CompactSpace α] [inst_3 : T2Space α] [fintype : Fintype α], ¬LocallyCompactSpace α ", "¬(∃ (s : Set (ℕ → ℝ)) (H : s ∈ 𝓝[Set.Icc 0 1] 0), IsCompact s) ", "∀ {β : Type u₁} [inst : UniformSpace β] [inst_1 : CompleteSpace β] [inst_2 : SeparatedSpace β] [self : CompactSpace β],\n  ¬LocalCompactness UniformSpace.toTopologicalSpace ", "∀ {α : Type u_1} [inst : UniformSpace α] [inst_1 : CompleteSpace α] [inst_2 : SeparatedSpace α],\n  ¬IsLocallyCompact (α →₀ ℝ) ", "∀ {β : Type u₁} [inst : UniformSpace β] [inst_1 : CompactSpace β] [inst_2 : SeparatedSpace β],\n  ¬LocallyCompactSpace (TopologicalSpace.Π₀ fun _x => β) ", "NotLocallyCompactTopologicalSpaceOfUniformSpace {U : Type u₁} [UniformSpace U]\n  {α : Type u₂} [LineOrder α] [TopologicalSpace α] [OrderTopology α]\n  [d : ℕ → α] [H : ∀ (n : ℕ), Set.Icc (d n) (d (Nat.succ n)) = Set.Icc ₀ ₁]\n  (h_mono : ∀ (n : ℕ), d (Nat.succ n) < d n) : ¬TopologicalSpace.LocallyCompactSpace (U →₀ α) ", "∀ {α : Type u_1} [inst : UniformSpace α] [inst_1 : CompleteSpace α] [inst_2 : SeparatedSpace α] [inst_3 : TotallyBoundedSpace α],\n  ¬(LocallyCompactSpace (α → ℝ)) ", "not_locally_compact_zero_one_omega : ¬LocallyCompactSpace (ℕ →ᵇ ℝ) "]}
{"docString": "Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\\n  TopologicalSpace.SeparableSpace ((i : ι) → X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"}]\n", "prompt_cons": "/-- There exists a countable dense set. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s)) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem ∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  TopologicalSpace.SeparableSpace ((i : ι) → X i) :=\n\n/-- Show that if $X$ is a countable product of spaces having countable dense subsets, then $X$ has a countable dense subset. -/\ntheorem", "choices": ["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  ∃ D : Set ((i : ι) → X i), Set.Countable D ∧ Dense D ", "∀ {ι : Type u_1} {X : ι → Type u_2} [_inst_1 : (i : ι) → TopologicalSpace (X i)] [_inst_2 : (i : ι) → TopologicalSpace.SeparableSpace (X i)]\n  [_inst_3 : Countable ι], ∃ s, Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), ∃ s, Set.Countable s ∧ Dense s] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), ∃ s, Set.Countable s ∧ Dense s] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), ∃ s, Set.Countable s ∧ Dense s] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), ∃ s, Set.Countable s ∧ Dense s] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), ∃ s : Set (X i), Set.Countable s ∧ Dense s] [inst_2 : Countable ι],\n  ∃ s : Set ((i : ι) → X i), Set.Countable s ∧ Dense s ", "∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  ∃ s, Set.Countable s ∧ Dense s "]}
{"docString": "Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\\n  x ≠ y →\\n    ∃ U₁,\\n      U₁ ∈ nhds x ∧\\n        ∃ V₁,\\n          V₁ ∈ nhds x ∧\\n            ∃ U₂,\\n              U₂ ∈ nhds y ∧\\n                ∃ V₂,\\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\\ndisjoint. \"}]\n", "prompt_cons": "/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds x ∧\n            ∃ U₂,\n              U₂ ∈ nhds y ∧\n                ∃ V₂,\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n\n/-- Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\ndisjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure) :=\n\n/-- Show that if $X$ is regular, every pair of points of $X$ have neighborhoods whose closures are disjoint. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [self : RegularSpace α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds y ∧\n            IsClosed (Closure U₁) ∧ IsClosed (Closure V₁) ∧ Disjoint (Closure U₁) (Closure V₁) ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : RegularSpace α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds y ∧ Closure U₁ ∩ Closure V₁ = ∅ ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : RegularSpace α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint (closure u) (closure v) ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : RegularSpace α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds y ∧\n            ∃ U₂,\n              U₂ ∈ nhds x ∧\n                ∃ V₂,\n                  V₂ ∈ nhds y ∧ IsClosed U₁ ∧ IsClosed V₁ ∧ IsOpen U₂ ∧ IsOpen V₂ ∧ U₁ ⊆ U₂ ∧ V₁ ⊆ V₂ ∧ Disjoint U₂ V₂ ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : RegularSpace α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds y ∧\n            IsClosed (closure U₁) ∧ IsClosed (closure V₁) ∧ Disjoint (closure U₁) (closure V₁) ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : RegularSpace α] (x y : α),\n  x ≠ y →\n    ∃ U₁ V₁,\n      U₁ ∈ nhds x ∧ V₁ ∈ nhds y ∧ IsClosed (Closure U₁) ∧ IsClosed (Closure V₁) ∧ Disjoint (Closure U₁) (Closure V₁) ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : RegularSpace α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint (closure u) (closure v) ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : RegularSpace α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds y ∧\n            ∃ U₂,\n              IsClosed U₂ ∧\n                U₂ ⊆ U₁ ∧\n                  ∃ V₂,\n                    IsClosed V₂ ∧ V₂ ⊆ V₁ ∧ Disjoint U₂ V₂ ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : T1Space α] [self_1 : RegularSpace α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint (closure u) (closure v) ", "forall {α : Type u} [inst : TopologicalSpace α] [self : T3Space α] {x y : α},\n  x ≠ y →\n    ∃ U₁ V₁ U₂ V₂,\n      U₁ ∈ nhds x ∧ V₁ ∈ nhds x ∧\n      U₂ ∈ nhds y ∧ V₂ ∈ nhds y ∧\n      IsClosed V₁ ∧ IsClosed V₂ ∧\n      IsOpen U₁ ∧ IsOpen U₂ ∧\n      V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint (closure U₁) (closure U₂) "]}
{"docString": "Show that every order topology is regular.", "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : LinearOrder β] [t : TopologicalSpace β]\\n  [inst_2 : OrderTopology β] {f : α → β},\\n  StrictMono f → Set.OrdConnected (Set.range f) → TopologicalSpace.induced f t = Preorder.topology α\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology induced by a strictly monotone function with order-connected range is the preorder\\ntopology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] {f : α → β},\\n  Inducing f → tα = TopologicalSpace.induced f tβ\",\n  \"isProp\": true,\n  \"docString\": \"The topology on the domain is equal to the induced topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"}]\n", "prompt_cons": "/-- A linear order with order topology is a completely normal Hausdorff topological space. -/\ntheorem ∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X :=\n\n/-- The topology induced by a strictly monotone function with order-connected range is the preorder\ntopology. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : LinearOrder β] [t : TopologicalSpace β]\n  [inst_2 : OrderTopology β] {f : α → β},\n  StrictMono f → Set.OrdConnected (Set.range f) → TopologicalSpace.induced f t = Preorder.topology α :=\n\n/-- The topology on the domain is equal to the induced topology. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] {f : α → β},\n  Inducing f → tα = TopologicalSpace.induced f tβ :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- Show that every order topology is regular. -/\ntheorem", "choices": ["∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T3Space X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T3Space X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T3Space X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst_2 : OrderTopology X], RegularSpace X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X ", "∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], RegularSpace X "]}
{"docString": "Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → EMetric.hausdorffEdist s t ≠ ⊤ → Set.Nonempty t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : MetricSpace α] {x y : TopologicalSpace.NonemptyCompacts α}, dist x y = Metric.hausdorffDist ↑x ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance on `NonemptyCompacts α` is the Hausdorff distance, by construction \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"}]\n", "prompt_cons": "/-- If a set is at finite Hausdorff edistance of a nonempty set, it is nonempty -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s t : Set α},\n  Set.Nonempty s → EMetric.hausdorffEdist s t ≠ ⊤ → Set.Nonempty t :=\n\n/-- The distance on `NonemptyCompacts α` is the Hausdorff distance, by construction -/\ntheorem ∀ {α : Type u} [inst : MetricSpace α] {x y : TopologicalSpace.NonemptyCompacts α}, dist x y = Metric.hausdorffDist ↑x ↑y :=\n\n/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- Show that if $\\prod X_\\alpha$ is Hausdorff, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [H : T2Space (α × β)],\n  (Nonempty α → Nonempty β) → T2Space α ", "∀ {ι : Type u} {α : ι → Type v} [t : ∀ i, TopologicalSpace (α i)] [inst : ∀ i, Nonempty (α i)],\n  TopologicalSpace.IsHausdorff (Π i, α i) → ∀ i, TopologicalSpace.IsHausdorff (α i) ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : ∀(i : α), Nonempty (β i)] {x y : Π (i : α), β i},\n  t2_space (Π (i : α), β i) → x ≠ y → ∃ (i : α), ∃ (U V : Set (β i)), IsOpen U ∧ IsOpen V ∧ HasMem.Mem (x i) U ∧ HasMem.Mem (y i) V ∧ HasInter.inter U V = ∅ ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α × β → α} {g : α × β → β},\n  Continuous f → Continuous g → (∀ x y, f x ≠ f y → ∃ u v, IsOpen u ∧ IsOpen v ∧ f x ∈ u ∧ f y ∈ v ∧ HasInter.inter u v = ∅) →\n  (∀ x y, x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ HasInter.inter u v = ∅) ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  (∀ (x : α), TopologicalSpace.Nonempty (β x)) →\n  TopologicalSpace.IsHausdorff (∏ x, TopologicalSpace.Nonempty (β x)) →\n  TopologicalSpace.IsHausdorff β ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [h : T2Space (α × β)],\n  Nonempty α → Nonempty β → T2Space α ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  (X : α → Set β) [inst_2 : (∀ a : α, Set.Nonempty (X a))]\n  (h : ∀ a₁ a₂ : α, Metric.hausdorffDist (X a₁) (X a₂) ≠ ⊤),\n  TopologicalSpace.IsHausdorff (TopologicalSpace.NonemptyCompacts α) ", "∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : Nonempty α] [inst_3 : Nonempty β],\n  T2Space (α × β) → T2Space α ", "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace β] [inst_1 : TopologicalSpace α] [inst_2 : T2Space (α × β)],\n  (∀ a : α, Set.Nonempty (SetOf fun b : β => (a, b) ∈ univ)) → T2Space α ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} {X : ι → TopologicalSpace.NonemptyCompacts α},\n  TopologicalSpace.IsHausdorff (Π (i : ι), X i) → TopologicalSpace.IsHausdorff α "]}
{"docString": "Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` has no zero divisors, then the product of two elements is nonzero iff both of them\\nare nonzero. \"}]\n", "prompt_cons": "/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s } :=\n\n/-- If `α` has no zero divisors, then the product of two elements is nonzero iff both of them\nare nonzero. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0 :=\n\n/-- Show that if $\\prod X_\\alpha$ is normal, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem", "choices": ["∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : ∀i, TopologicalSpace (ι i)] [inst_2 : ∀i, Nonempty (ι i)]\n  [inst_3 : T2Space α] [inst_4 : ∀i, T2Space (ι i)] {X : α → ι} (hX : NormalSpace (Π i, ι i)), ∀ i, NormalSpace (ι i) ", "∀ {ι : Type u_1} {α : ι → Type u_2} [t : ∀ i, TopologicalSpace (α i)] [inst : ∀ i, Nonempty (α i)] [inst_1 : NormalSpace (Π i, α i)],\n  ∀ i, NormalSpace (α i) ", "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)] [inst_1 : ∀ i, Nonempty (α i)]\n  [inst_2 : T2Space (Π i, α i)] [inst_3 : ∀ i, NormalSpace (α i)],\n  T2Space (α i) ∧ NormalSpace (α i) ", "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)] [inst_1 : ∀ i, Nonempty (α i)]\n  [t : TopologicalSpace (Π i, α i)] [inst_2 : T2Space (Π i, α i)] [inst_3 : ∀ i, NormalSpace (α i)],\n  NormalSpace (Π i, α i) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] [inst_3 : T2Space β]\n  [inst_4 : (∀ a : α, Nonempty β)] {f : α × β → α} {g : α × β → β},\n  Continuous f → Continuous g → (∀ x : α × β, f x ∈ set.prod {f x} {g x}) →\n  T2Space (α × β) → T2Space α ", "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : ∀i, TopologicalSpace (α i)] [inst_1 : ∀i, Nonempty (α i)] [inst_2 : NormalSpace (∏ i, α i)],\n  ∀ i, NormalSpace (α i) ", "∀ {ι : Type u} {α : ι → Type v} [inst : (i : ι) → TopologicalSpace (α i)] (h : NormalSpace (Pi.TopologicalSpace α))\n  [inst_1 : ∀ (i : ι), Nonempty (α i)] (i : ι), NormalSpace (α i) ", "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)] [inst_1 : ∀ i, Nonempty (α i)]\n  [inst_2 : T2Space (Π i, α i)] [inst_3 : ∀ i, NormalSpace (α i)], NormalSpace (Π i, α i) ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : β → TopologicalSpace α}\n  [inst_2 : Nonempty α] [inst_3 : Nonempty β] [inst_4 : ∀ b, Nonempty (f b)]\n  [inst_5 : NormalSpace (Π (b : β), f b)], ∀ b, NormalSpace (f b) ", "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)]\n  [inst_1 : ∀ (i : ι), Nonempty (α i)] {i : ι} {h : TopologicalSpace.IsNormal (TopologicalSpace.pi inst)},\n  TopologicalSpace.IsNormal (TopologicalSpace.induced (TopologicalSpace.pi.inclusion i) (inst i)) "]}
{"docString": "Show that every locally compact Hausdorff space is completely regular.", "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"}]\n", "prompt_cons": "/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α :=\n\n/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure μ) :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem ∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- Show that every locally compact Hausdorff space is completely regular. -/\ntheorem", "choices": ["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  CompletelyRegularSpace α ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  CompletelyRegularSpace α ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  CompletelyRegularSpace X "]}
{"docString": "Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable.", "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\\n  ModelWithCorners ℝ E H →\\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\\nmetrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α × β)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two compact spaces is compact. \"}]\n", "prompt_cons": "/-- A σ-compact Hausdorff topological manifold over a finite dimensional real vector space is\nmetrizable. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H],\n  ModelWithCorners ℝ E H →\n    ∀ (M : Type u_3) [inst : TopologicalSpace M] [inst_4 : ChartedSpace H M] [inst_5 : SigmaCompactSpace M]\n      [inst_6 : T2Space M], TopologicalSpace.MetrizableSpace M :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- The product of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α × β) :=\n\n/-- Let $X$ be a compact Hausdorff space that is the union of the closed subspaces $X_1$ and $X_2$. If $X_1$ and $X_2$ are metrizable, show that $X$ is metrizable. -/\ntheorem", "choices": ["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {X_1 : Type u_2} [inst_3 : TopologicalSpace X_1] [inst_4 : TopologicalSpace.MetrizableSpace X_1] [inst_5 : ClosedEmbedding (id : X_1 → X)]\n  {X_2 : Type u_3} [inst_6 : TopologicalSpace X_2] [inst_7 : TopologicalSpace.MetrizableSpace X_2] [inst_8 : ClosedEmbedding (id : X_2 → X)],\n  ∀ (h_union : X = X_1 ⊕ X_2), TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  {X₁ : Type u_2} [inst_3 : TopologicalSpace X₁] [inst_4 : ChartedSpace X X₁] [inst_5 : ClosedEmbedding (ChartedSpace.chartAt X₁ X)]\n  {X₂ : Type u_3} [inst_6 : TopologicalSpace X₂] [inst_7 : ChartedSpace X X₂] [inst_8 : ClosedEmbedding (ChartedSpace.chartAt X₂ X)]\n  [inst_9 : TopologicalSpace.MetrizableSpace X₁] [inst_10 : TopologicalSpace.MetrizableSpace X₂],\n  TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {X₁ : Type v} [inst_3 : TopologicalSpace X₁] [inst_4 : HasContinuousSubtypeEmbedding (X₁ → X)]\n  {X₂ : Type w} [inst_5 : TopologicalSpace X₂] [inst_6 : HasContinuousSubtypeEmbedding (X₂ → X)],\n  TopologicalSpace.MetrizableSpace X₁ → TopologicalSpace.MetrizableSpace X₂ → TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {X₁ : Type u_2} [inst_3 : TopologicalSpace X₁] [inst_4 : TopologicalSpace.MetrizableSpace X₁]\n  {X₂ : Type u_3} [inst_5 : TopologicalSpace X₂] [inst_6 : TopologicalSpace.MetrizableSpace X₂],\n  (∃ (i₁ : X₁ → X) (i₂ : X₂ → X), is_closed_map i₁ ∧ is_closed_map i₂ ∧ set.range i₁ ∪ set.range i₂ = set.univ) →\n    TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X],\n  ∀ {X₁ X₂ : Set X} [inst_3 : TopologicalSpace.SubtypeTopologicalSpace X₁] [inst_4 : TopologicalSpace.SubtypeTopologicalSpace X₂]\n    [inst_5 : TopologicalSpace.MetrizableSpace X₁] [inst_6 : TopologicalSpace.MetrizableSpace X₂],\n      IsClosed X₁ → IsClosed X₂ → X = X₁ ∪ X₂ → TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {X₁ : Type u_2} [inst_3 : TopologicalSpace X₁] [inst_4 : TopologicalSpace.MetrizableSpace X₁]\n  {X₂ : Type u_3} [inst_5 : TopologicalSpace X₂] [inst_6 : TopologicalSpace.MetrizableSpace X₂],\n  (∀ x : X, x ∈ set.range (sum.inl : X₁ → X) ∪ set.range (sum.inr : X₂ → X))\n  → TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X],\n  ∀ {X₁ : Type v} [inst_3 : TopologicalSpace X₁] [inst_4 : TopologicalSpace.ClosedEmbedding (e₁ : X₁ → X)]\n    [inst_5 : TopologicalSpace.MetrizableSpace X₁],\n  ∀ {X₂ : Type w} [inst_6 : TopologicalSpace X₂] [inst_7 : TopologicalSpace.ClosedEmbedding (e₂ : X₂ → X)]\n    [inst_8 : TopologicalSpace.MetrizableSpace X₂],\n    X = set.range e₁ ∪ set.range e₂ → TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {X₁ : Subtype X} [inst_3 : TopologicalSpace X₁] [inst_4 : ClosedEmbedding X₁] [inst_5 : TopologicalSpace.MetrizableSpace X₁]\n  {X₂ : Subtype X} [inst_6 : TopologicalSpace X₂] [inst_7 : ClosedEmbedding X₂] [inst_8 : TopologicalSpace.MetrizableSpace X₂],\n  X = Set.Unionₓ (λ b, cond b (Set.Range coe) (Set.Range coe)) →\n    TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompactSpace X]\n  {X₁ : Type u_2} [inst_3 : TopologicalSpace X₁] [inst_4 : ClosedEmbedding (F : X₁ → X)] [inst_5 : TopologicalSpace.MetrizableSpace X₁]\n  {X₂ : Type u_3} [inst_6 : TopologicalSpace X₂] [inst_7 : ClosedEmbedding (G : X₂ → X)] [inst_8 : TopologicalSpace.MetrizableSpace X₂],\n    TopologicalSpace.MetrizableSpace X ", "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst_2 : T2Space X]\n  {X₁ : Type u_1} [inst_3 : TopologicalSpace X₁] [inst_4 : TopologicalSpace.OpensMeasurableSpace X₁] [inst_5 : TopologicalSpace.MetrizableSpace X₁]\n  {X₂ : Type u_2} [inst_6 : TopologicalSpace X₂] [inst_7 : TopologicalSpace.OpensMeasurableSpace X₂] [inst_8 : TopologicalSpace.MetrizableSpace X₂],\n  (∃ (i₁ : X₁ → X) (i₂ : X₂ → X), IsClosedMap i₁ ∧ IsClosedMap i₂ ∧ Set.Range i₁ ⊆ @Closure X _ (Set.Range i₁) ∧ Set.Range i₂ ⊆ @Closure X _ (Set.Range i₂) ∧ Set.Unionₓ (Set.Range i₁) (Set.Range i₂) = Set.Univ)\n  → TopologicalSpace.MetrizableSpace X "]}
{"docString": "Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\\n  Filter.Tendsto b (nhds 0) (nhds 0) →\\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a family of functions between (pseudo) metric spaces, a convenient way to prove\\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\\nmodulus. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\\n  CompleteSpace ((i : ι) × E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"}]\n", "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- For a family of functions between (pseudo) metric spaces, a convenient way to prove\nuniform equicontinuity is to show that all of the functions share a common *global* continuity\nmodulus. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : PseudoMetricSpace α] {ι : Type u_1} [inst_1 : PseudoMetricSpace β] (b : ℝ → ℝ),\n  Filter.Tendsto b (nhds 0) (nhds 0) →\n    ∀ (F : ι → β → α), (∀ (x y : β) (i : ι), dist (F i x) (F i y) ≤ b (dist x y)) → UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\n  CompleteSpace ((i : ι) × E i) :=\n\n/-- Let $(X, d_X)$ and $(Y, d_Y)$ be metric spaces; let $Y$ be complete. Let $A \\subset X$. Show that if $f \\colon A \\rightarrow Y$ is uniformly continuous, then $f$ can be uniquely extended to a continuous function $g \\colon \\bar{A} \\rightarrow Y$, and $g$ is uniformly continuous. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : MetricSpace β] (A : Set α) [inst_2 : CompleteSpace β] (f : Set.MapsTo.restrict f A β),\n  UniformContinuous (Set.MapsTo.restrict f A β) →\n    ∃ g, UniformContinuous g ∧ Continuous (coe g) ∧ ∀ (x : α), x ∈ A → g x = f x ", "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] {A : Set α} [inst_1 : MetricSpace β] [inst_2 : CompleteSpace β] \n  (f : A → β), UniformlyContinuousOn f A → \n    ∃! (g : Closure A → β), Continuous g ∧ UniformlyContinuous g ∧ ∀ (a : α), a ∈ A → g ⟨a, mem_closure_self a⟩ = f a ", "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : CompleteSpace β] {f : α → β} {s : Set α},\n  UniformContinuousOn f s →\n    ∃ g, Continuous g ∧\n          UniformContinuous g ∧\n            (∀ (x : α), x ∈ s → g x = f x) ∧\n              ∀ (g' : α → β),\n                Continuous g' →\n                  UniformContinuous g' →\n                    (∀ (x : α), x ∈ s → g' x = f x) →\n                      g' = g ", "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : MetricSpace β] {A : Set α} [inst_2 : TopologicalSpace α] [inst_3 : CompleteSpace β],\n  (∃ (f : ↥A → β) (hf : UniformContinuous f),\n      ∃! (g : ↥(Closure A) → β), Continuous g ∧ ∀ (x : ↥A), g (Subtype.mk x.val (_ : HasMem.Mem x.val (Closure A))) = f x) →\n  (∃ (g : ↥(Closure A) → β), Continuous g ∧ UniformContinuous g) ", "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : MetricSpace β] [inst_2 : CompleteSpace β] {f : α → β} {s : Set α},\n  UniformlyContinuous f →\n    ∃ g, Continuous g ∧ ∀ (x : α), x ∈ Closure s → g x = f x ∧ UniformlyContinuous g ", "∀ {α : Type u_1} {β : Type u_2} [inst : MetricSpace α] {s : Set α} [inst_1 : CompleteSpace β] [inst_2 : MetricSpace β]\n  (f : α → β), UniformContinuousOn f s →\n  ∃ g : α → β, UniformContinuous g ∧ ∀ (x : α), x ∈ Closure s → f x = g x ", "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y]\n  (A : Set X) (f : A → Y),\n  UniformContinuous f →\n    ∃ g : Closure A → Y, Continuous g ∧ UniformContinuous g ∧ ∀ (x : A), g ⟨x, Subset.mem_closure x.2⟩ = f x ", "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] [inst_2 : CompleteSpace β] (f : α → β) (s : Set α),\n  UniformlyContinuousOn f s →\n    ∃ g : Ctop.Realizer (Closure s) → β,\n      UniformContinuous g ∧\n        ∀ (x : Ctop.Realizer (Closure s)), x.val ∈ s → g x = f x.val ", "∀ {α : Type u_1} {β : Type u_2} [inst : MetricSpace α] [inst_1 : CompleteSpace β] [inst_2 : MetricSpace β] (f : α → β) (s : Set α),\n  UniformContinuousOn f s →\n    ∃ g, ContinuousOn g (Closure s) ∧ UniformContinuousOn g (Closure s) ∧ ∀ (x : α), x ∈ s → g x = f x ", "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] [inst_2 : CompleteSpace Y]\n  (A : Set X) (f : (↥A) → Y) [inst_3 : UniformContinuous f],\n  ∃! (g : (↥(Closure A)) → Y), Continuous g ∧ UniformContinuous g "]}
{"docString": "Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1).", "prompts": "[{\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 3` is `√3 / 2`. \"},\n {\"theorem\": \"Real.cos (Real.pi / 6) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The cosine of `π / 6` is `√3 / 2`. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"}]\n", "prompt_cons": "/-- The sine of `π / 3` is `√3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- The cosine of `π / 6` is `√3 / 2`. -/\ntheorem Real.cos (Real.pi / 6) = Real.sqrt 3 / 2 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- Show that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1). -/\ntheorem", "choices": ["Complex.cpow ((-1 + Complex.i * Real.sqrt 3) / 2) 3 = 1 ", "Complex.exp (Complex.arg (-1 + Complex.i * Real.sqrt 3)/2) ^ 3 = 1 ", "(((-1 : ℂ) + Complex.sqrt 3 * Complex.i) / 2)^3 = 1 ", "Complex.cpow ((-1 + Complex.i * Real.sqrt 3) / 2) 3 = 1 ", "(Complex.mk (-1 / 2) (Real.sqrt 3 / 2)).cube = 1 ", "complex.cubicroot ((-1 + complex.I * Real.sqrt 3) / 2) = 1 ", "(((-1 + Complex.sqrt 3 * Complex.i) / 2)^3) = 1 ", "(Complex.mk (-1) (Real.sqrt 3) / 2).im_pow 3 = 1 ", "(Complex.mk (-1) (Real.sqrt 3) / 2).pow 3 = 1 ", "(Complex.mk (-1 / 2) (Real.sqrt 3 / 2)).re_cubed = 1 ∧ (Complex.mk (-1 / 2) (Real.sqrt 3 / 2)).im_cubed = 0 "]}
{"docString": "Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  ↑(quadraticChar F) a = 0 ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The value of the quadratic character on `a` is zero iff `a = 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"The `v`-adic valuation of `0 : R` equals 0. \"}]\n", "prompt_cons": "/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem ∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0 :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  ↑(quadraticChar F) a = 0 ↔ a = 0 :=\n\n/-- The `v`-adic valuation of `0 : R` equals 0. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 0 = 0 :=\n\n/-- Prove that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$. -/\ntheorem", "choices": ["forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  [self : Module.NoZeroSmulDivisors F V] {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 ", "∀ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 ", "∀ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a • v = 0 → a = 0 ∨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V},\n  a • v = 0 → a = 0 ∨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 ", "∀ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 ", "∀ {F : Type u_1} [inst : DivisionRing F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 ", "∀ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : VectorSpace F V] [self : VectorSpace.NoConfusionType V] {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 ", "forall {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : Module F V] [self : Nontrivial V] {a : F} {v : V}, a • v = 0 → a = 0 ∨ v = 0 "]}
{"docString": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subsemiring is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under addition. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V ⊆ U`.\"}]\n", "prompt_cons": "/-- A non-unital subring is closed under multiplication. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- A subsemiring is closed under multiplication. -/\ntheorem ∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- A non-unital subring is closed under addition. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U :=\n\n/-- Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication, but $U$ is not a subspace of $\\mathbf{R}^2$. -/\ntheorem", "choices": ["example : ∃ (U : Set (ℝ × ℝ)), (∀ (c : ℝ) (x : ℝ × ℝ), x ∈ U → (c * x.1, c * x.2) ∈ U) ∧ ¬(∀ x y : ℝ × ℝ, x ∈ U → y ∈ U → x + y ∈ U) ", "example : ∃ (U : Set (ℝ × ℝ)), (∀ (x : ℝ) (y : ℝ × ℝ), y ∈ U → (x * y) ∈ U) ∧ ¬(Subspace ℝ (ℝ × ℝ) U) ", "example (U : Set (ℝ × ℝ)) (hU : U ≠ ∅) (hsm : ∀ (c : ℝ) (x : ℝ × ℝ), x ∈ U → (c * x.1, c * x.2) ∈ U) :\n  ¬(∀ x y : ℝ × ℝ, x ∈ U → y ∈ U → x + y ∈ U) ", "example {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R} (hx : x ∈ s) (hy : y ∈ s) : x * y ∈ s ", "example (U : Set (ℝ × ℝ)) : Prop ", "I'm sorry, I cannot give examples in Lean Theorem Prover code. However, I can help you with writing proofs and theorems in Lean code. If you have any other questions about Lean code, please feel free to ask.", "I'm sorry, I cannot create a theorem for this request as it requires providing an example of a nonempty subset U of R^2 which is not a subspace. Theorem proving is used to prove the correctness of mathematical statements, not provide examples. Please ask for a theorem or another code translation, and I would be happy to help.", "example (U : Set (ℝ × ℝ)) : Prop ", "Sorry, I cannot provide examples or counterexamples as I can only translate given statements into Lean Theorem Prover code. Please provide a statement you would like me to translate.", "example {R : Type} [inst : Field R] (U : Set (R × R)) : Prop "]}
{"docString": "Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 ≤ s2 ↔ ∀ (p : P), p ∈ s1 → p ∈ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is less than or equal to another if and only if all its points are in the second\\nsubspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  (u : ℙ K V), u ∈ Projectivization.Subspace.span S ↔ ∀ (W : Projectivization.Subspace K V), S ⊆ ↑W → u ∈ W\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point in a projective space is contained in the span of a set of points if and only if the\\npoint is contained in all subspaces of the projective space which contain the set of points. \"}]\n", "prompt_cons": "/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- One subspace is less than or equal to another if and only if all its points are in the second\nsubspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), s1 ≤ s2 ↔ ∀ (p : P), p ∈ s1 → p ∈ s2 :=\n\n/-- A point in a projective space is contained in the span of a set of points if and only if the\npoint is contained in all subspaces of the projective space which contain the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  (u : ℙ K V), u ∈ Projectivization.Subspace.span S ↔ ∀ (W : Projectivization.Subspace K V), S ⊆ ↑W → u ∈ W :=\n\n/-- Prove that the union of two subspaces of $V$ is a subspace of $V$ if and only if one of the subspaces is contained in the other. -/\ntheorem", "choices": ["∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Projectivization.Subspace K V),\n  IsSubspace (S ∪ T) ↔ S ≤ T ∨ T ≤ S ", "forall {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {U W : Projectivization.Subspace K V},\n  IsSubspace (U ∪ W) ↔ U ≤ W ∨ W ≤ U ", "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace (S ∪ T) ≤ Projectivization.Subspace V ↔ S ⊆ T ∨ T ⊆ S ", "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {W₁ W₂ : Projectivization.Subspace K V},\n  IsSubspace (↑W₁ ∪ ↑W₂) ↔ W₁ ≤ W₂ ∨ W₂ ≤ W₁ ", "forall {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Projectivization.Subspace K V),\n  is_subspace (↑S ∪ ↑T) ↔ S ≤ T ∨ T ≤ S ", "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {U W : Projectivization.Subspace K V},\n  Projectivization.Subspace.is_subspace (U ∪ W) ↔ U ≤ W ∨ W ≤ U ", "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (W₁ W₂ : Projectivization.Subspace K V),\n  Projectivization.Subspace.span (↑W₁ ∪ ↑W₂) = W₁ ⊔ W₂ ↔ W₁ ≤ W₂ ∨ W₂ ≤ W₁ ", "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Projectivization.Subspace K V),\n  IsSubspace (↑(S ⊔ T) : Set V) ↔ S ≤ T ∨ T ≤ S ", "∀ {k : Type u_1} {V : Type u_2} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  (s1 s2 : Submodule k V), s1 ∪ s2 = Submodule.span k (s1 ∪ s2) ↔ s1 ≤ s2 ∨ s2 ≤ s1 ", "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (W1 W2 : Projectivization.Subspace K V),\n  IsSubmodule K V (W1 ∪ W2) ↔ W1 ≤ W2 ∨ W2 ≤ W1 "]}
{"docString": "Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `T₅` space is a `T₅` space. \"}]\n", "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- A subspace of a `T₅` space is a `T₅` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x } :=\n\n/-- Suppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. Prove that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ and range $T=\\{T u: u \\in U\\}$. -/\ntheorem", "choices": ["∀ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : AddCommGroup W] [inst_5 : Module K W] (T : V →ₗ[K] W),\n  ∃ (U : Submodule K V), (U ⊓ T.ker = ⊥) ∧ (T.range = Submodule.map T U) ", "∀ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W]\n  [inst_3 : Module K V] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : LinearMap K V W),\n  ∃ (U : Submodule K V), (U ⊓ T.ker = ⊥) ∧ (T.range = Submodule.map T U) ", "∀ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W]\n  [inst_3 : Module K V] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V]\n  (T : LinearMap K V W), ∃ (U : Submodule K V), U ⊓ LinearMap.ker T = ⊥ ∧ LinearMap.range T = Submodule.map T U ", "forall {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W]\n  [inst_3 : Module K V] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : LinearMap K V W),\n  ∃ (U : Submodule K V), U ⊓ T.ker = ⊥ ∧ T.range = LinearMap.range_restriction T U ", "forall {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : AddCommGroup W] [inst_5 : Module K W]\n  (T : V →ₗ[K] W), ∃ (U : Submodule K V), (U ⊓ T.ker = ⊥) ∧ (T.range = Submodule.map T U) ", "∀ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : AddCommGroup W] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : V →ₗ[K] W),\n  ∃ (U : Submodule K V), U ⊓ T.ker = ⊥ ∧ T.range = LinearMap.rangeRestrict T U ", "∀ {K : Type u} {V : Type v} {W : Type w} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : AddCommGroup W] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : LinearMap K V W),\n  ∃ (U : Submodule K V), (U ⊓ T.ker = ⊥) ∧ (T.range = LinearMap.range_restrict U) ", "∀ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : AddCommGroup W]\n  [inst_3 : Module K V] [inst_4 : Module K W] [inst_5 : FiniteDimensional K V] (T : V →ₗ[K] W),\n  ∃ (U : Submodule K V), (U ⊓ T.ker = ⊥) ∧ T.range = Submodule.map T U ", "∀ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : AddCommGroup W] [inst_5 : Module K W] (T : V →ₗ[K] W),\n  ∃ (U : Submodule K V), (U ⊓ T.ker = ⊥) ∧ (T.range = Submodule.map T U) ", "∀ {K : Type u} {V W : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : AddCommGroup W] [inst_5 : Module K W] (T : V →ₗ[K] W),\n  ∃ (U : Submodule K V), U ⊓ T.ker = ⊥ ∧ T.range = Submodule.map T U "]}
{"docString": "Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x }\",\n  \"isProp\": true,\n  \"docString\": \"A subspace of a `T₅` space is a `T₅` space. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsAddLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under addition. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h + g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsAddRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under addition. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"}]\n", "prompt_cons": "/-- A subspace of a `T₅` space is a `T₅` space. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T5Space α] {p : α → Prop}, T5Space { x // p x } :=\n\n/-- An alternative way to prove that `μ` is left invariant under addition. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsAddLeftInvariant μ :=\n\n/-- An alternative way to prove that `μ` is right invariant under addition. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h + g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsAddRightInvariant μ :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$. -/\ntheorem", "choices": ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {U : Π i, Set V} (m : ℕ) (T : V →ₛₖₗ[K] V),\n  (∀ i, T.to_fun '' (U i) ⊆ U i) → T.to_fun '' (⨁ i, U i) ⊆ ⨁ i, U i ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V →ₗ[K] V} {m : ℕ} {U : Finₓ m → Set (ℙ K V)},\n  (∀ i, Projectivization.Subspace.isInvariant T (Projectivization.Subspace.span (U i))) →\n  Projectivization.Subspace.isInvariant T (Projectivization.Subspace.span (⋃ i, U i)) ", "∀ {K : Type u} [inst : Field K] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V →ₗ[K] V} (U : Π (i : ℕ), i < m → Submodule K V),\n  (∀ (i : ℕ) (h : i < m), ∀ (x : V), HasMem.Mem x (U i h) → HasMem.Mem (T x) (U i h)) →\n  ∀ (x : V), HasMem.Mem x (⨁ i (hi : i < m), U i hi) → HasMem.Mem (T x) (⨁ i (hi : i < m), U i hi) ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : LinearMap K V V) (U : List (Submodule K V)),\n  (∀ (i : ℕ) (hi : i < List.length U), LinearMap.SubmoduleInvariance T (List.nthLe U i hi)) →\n    LinearMap.SubmoduleInvariance T (List.sum U) ", "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : V →ₗ[K] V} {Us : List (ℙ K V)},\n  (∀ U ∈ Us, ∀ v ∈ U, T v ∈ U) → ∀ v ∈ ⊥ (List.foldr Projectivization.Subspace.sup ⊥ Us), T v ∈ ⊥ (List.foldr Projectivization.Subspace.sup ⊥ Us) ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : V →ₗ[K] V) (Us : List (ℙ K V)),\n  (∀ U ∈ Us, ∀ x ∈ U, T x ∈ U) → ∀ x ∈ List.sum (List.map Projectivization.Subspace.span Us), T x ∈ List.sum (List.map Projectivization.Subspace.span Us) ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : V →ₗ[K] V) (U : List (Submodule K V)),\n  (∀ (i : ℕ) (h : i < U.length), ∀ (x : V), (U.nth_le i h) x → T x = x) →\n    ∀ (x : V), (Submodule.span K (List.foldr Set.Union ∅ (List.map Submodule.Carrier U))) x → T x = x ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : End K V} (U : Π (i : ℕ), Set (ℙ K V))\n  (hT : ∀ (i : ℕ), T '' (Projectivization.Subspace.span (U i)) = Projectivization.Subspace.span (U i)),\n  T '' (Projectivization.Subspace.span (⋃ i, U i)) = Projectivization.Subspace.span (⋃ i, U i) ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : V →ₗ[K] V) (U : Π (i : ℕ), Set (ℙ K V)),\n  (∀ (i : ℕ), ∀ (x : V), x ∈ Projectivization.Subspace.span (U i) → T x ∈ Projectivization.Subspace.span (U i)) →\n  ∀ (x : V), x ∈ Projectivization.Subspace.span (⋃ (i : ℕ), U i) → T x ∈ Projectivization.Subspace.span (⋃ (i : ℕ), U i) ", " ∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : V →ₗ[K] V) (U : Π (i : ℕ), i < m → Submodule K V),\n  (∀ (i : ℕ) (h : i < m), ∀ (x : V), x ∈ U i h → T x ∈ U i h) →\n  (∀ (x : V), x ∈ Submodule.sum {i : ℕ} (λ h, U i h) → T x ∈ Submodule.sum {i : ℕ} (λ h, U i h)) "]}
{"docString": "Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  (v : E) (μ : Module.End.Eigenvalues T),\\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U ≤ V → ∀ (x : E), ↑(orthogonalProjection U) ↑(↑(orthogonalProjection V) x) = ↑(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U ≤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"}]\n", "prompt_cons": "/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  (v : E) (μ : Module.End.Eigenvalues T),\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ :=\n\n/-- If `U ≤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U ≤ V → ∀ (x : E), ↑(orthogonalProjection U) ↑(↑(orthogonalProjection V) x) = ↑(orthogonalProjection U) x :=\n\n/-- Suppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues. -/\ntheorem", "choices": ["∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : LinearMap 𝕜 V V},\n  (λ : 𝕜), algebra_map 𝕜 (End 𝕜 V) λ is_eigenvalue_of (S.comp T) ↔ algebra_map 𝕜 (End 𝕜 V) λ is_eigenvalue_of (T.comp S) ", "∀ {𝕜 : Type u} [inst : Field 𝕜] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : V →ₗ[𝕜] V},\n  ∀ (μ : 𝕜), Module.End.HasEigenvalue (S.comp T) μ ↔ Module.End.HasEigenvalue (T.comp S) μ ", "∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : Module.End 𝕜 V},\n  (∀ μ : 𝕜, Module.End.eigenvalue μ (S.comp T) ↔ Module.End.eigenvalue μ (T.comp S)) ", "∀ {𝕜 : Type u} [inst : Field 𝕜] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : V →ₗ[𝕜] V},\n  ∀ (μ : 𝕜), Module.End.eigenvalue μ (S.comp T) ↔ Module.End.eigenvalue μ (T.comp S) ", "forall {𝕜 : Type u_1} [inst : Field 𝕜] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : VectorSpace 𝕜 E]\n  (S T : E →ₗ[𝕜] E), (Module.End.eigenvalues (S.comp T)) = (Module.End.eigenvalues (T.comp S)) ", "∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : V →ₗ[𝕜] V},\n  ∀ μ : 𝕜, Algebra.algebraMap 𝕜 (End 𝕜 V) μ - S.comp T ∈ Module.End.eigenvalues T ↔\n    Algebra.algebraMap 𝕜 (End 𝕜 V) μ - T.comp S ∈ Module.End.eigenvalues S ", "∀ {𝕜 : Type u} [inst : Field 𝕜] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : Module.End 𝕜 V},\n  (∃ (μ : 𝕜), Module.End.HasEigenvalue (S * T) μ) ↔ (∃ (μ : 𝕜), Module.End.HasEigenvalue (T * S) μ) ", "forall {𝕜 : Type u} {V : Type v} [Field 𝕜] [AddCommGroup V] [Module 𝕜 V]\n  (S T : End 𝕜 V), (Eigenvalue S T) = (Eigenvalue T S) ", "∀ {𝕜 : Type u} [inst : Field 𝕜] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  {S T : V →ₗ[𝕜] V}, (∀ μ : 𝕜, Module.End.HasEigenvalue (S.comp T) μ ↔ Module.End.HasEigenvalue (T.comp S) μ) ", "∀ {𝕜 : Type u} [inst : Field 𝕜] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  {S T : LinearMap 𝕜 V V}, LinearMap.HasEigenvalue (S.comp T) μ ↔ LinearMap.HasEigenvalue (T.comp S) μ "]}
{"docString": "Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace 𝕜 V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\\n    fun p => p.fst • p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  Module.rank K V ≤ 1 ↔ ∃ v₀, ∀ (v : V), ∃ r, r • v₀ = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A vector space has dimension at most `1` if and only if there is a\\nsingle vector of which all vectors are multiples. \"}]\n", "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace 𝕜 V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\n    fun p => p.fst • p.snd :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem ∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- A vector space has dimension at most `1` if and only if there is a\nsingle vector of which all vectors are multiples. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V ≤ 1 ↔ ∃ v₀, ∀ (v : V), ∃ r, r • v₀ = v :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator. -/\ntheorem", "choices": ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ W : Subspace K V, Module.rank K V - 1 = Module.rank K W → Subspace.map T W = W) → ∃ c, T = c • LinearMap.id ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ W : Submodule K V, Module.rank K W = Module.rank K V - 1 → Submodule.map T W = W) → ∃ (a : K), T = a • 1 ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : Module.End K V),\n  (∀ W : Submodule K V, Submodule.dimension K W = Module.rank K V - 1 → Submodule.map T W = W) → ∃ c, T = c • LinearMap.id ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ W : Submodule K V, Submodule.dim K W = Module.rank K V - 1 → Submodule.map T W ⊆ W) → ∃ c : K, T = c • 1 ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ W : Submodule K V, Module.rank K W = Module.rank K V - 1 → T.isInvariant W) → ∃ a, T = a • LinearMap.id ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ W : Submodule K V, Module.rank K W = Module.rank K V - 1 → Module.End.isInvariantSubmodule T W) →\n  (∃ a : K, ∀ v : V, T v = a • v) ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ W : Submodule K V, Module.rank K W = Module.rank K V - 1 → Submodule.map T W = W) → ∃ c, T = c • LinearMap.id ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (W : Submodule K V), Module.rank K W = Module.rank K V - 1 → T.isInvariant W) → ∃ c, T = c • LinearMap.id ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (W : submodule K V), submodule.dim K W = module.rank K V - 1 → submodule.map T W = W) → ∃ (c : K), T = c • 1 ", "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (W : Submodule K V), Module.rank K W = Module.rank K V - 1 → T.isInvariant W) → ∃ (c : K), T = c • LinearMap.id "]}
{"docString": "Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\\n  [inst_7 : Module.Free K V'],\\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V')\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two vector spaces are isomorphic if and only if they have the same dimension. \"}]\n", "prompt_cons": "/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem ∀ {K : Type u} {V : Type v} {V' : Type v'} [inst : Ring K] [inst_1 : StrongRankCondition K] [inst_2 : AddCommGroup V]\n  [inst_3 : Module K V] [inst_4 : Module.Free K V] [inst_5 : AddCommGroup V'] [inst_6 : Module K V']\n  [inst_7 : Module.Free K V'],\n  Nonempty (V ≃ₗ[K] V') ↔ Cardinal.lift (Module.rank K V) = Cardinal.lift (Module.rank K V') :=\n\n/-- Suppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension. -/\ntheorem", "choices": ["∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V),\n  (∀ λ : ℝ, ¬Module.End.eigenspace T λ ≠ ⊥) →\n  ∀ (W : Submodule ℝ V), Submodule.map T W = W → Even (FiniteDimensional.finrank ℝ { x // x ∈ W }) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V)\n  (hT : ∀ λ : ℝ, ¬(Eigenvalue λ T)), ∀ (S : Submodule ℝ V) (hS : ∀ x ∈ S, T x ∈ S),\n  Even (FiniteDimensional.finrank ℝ {x // x ∈ S}) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V),\n  (∀ (λ : ℝ), ¬ (Module.End.eigenspace T λ ≠ ⊥)) →\n  ∀ (S : Submodule ℝ V), (∀ (v : V), v ∈ S → T v ∈ S) → Even (FiniteDimensional.finrank ℝ { x // x ∈ S }) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V)\n  (h_eigenvalues : ∀ (x : V) (c : ℝ), T x = c • x → x = 0),\n  ∀ (W : Submodule ℝ V), Submodule.map T W = W → even (FiniteDimensional.finrank ℝ W) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V),\n  (∀ (λ : ℝ), ¬Module.End.HasEigenvalue T λ) →\n  ∀ (W : Submodule ℝ V), Submodule.IsInvariant T W → Even (FiniteDimensional.finrank ℝ {x // x ∈ W}) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V),\n  (∀ x, x ≠ 0 → T x ≠ x) →\n  ∀ (W : Submodule ℝ V), (∀ x ∈ W, T x ∈ W) → Even (FiniteDimensional.finrank ℝ {x // x ∈ W}) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V),\n  (∀ (x : ℝ), ¬Module.End.eigenvalues T x) →\n  ∀ (W : Submodule ℝ V), (∀ (w : V), w ∈ W → T w ∈ W) → Even (FiniteDimensional.finrank ℝ {x // x ∈ W}) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : V →ₗ[ℝ] V),\n  (∀ (x : ℝ), ¬IsEigenvalue T x) → ∀ (W : Submodule ℝ V), Submodule.map T W = W → Even (FiniteDimensional.finrank ℝ W) ", "∀ {V : Type u} [inst : AddCommGroup V] [inst_1 : Module ℝ V] (T : End ℝ V)\n  (hf : ∀ x : V, x ≠ 0 → (T x = x → False)),\n  ∀ (M : Submodule ℝ V), ∀ (h : ∀ x, x ∈ M → T x ∈ M),\n  Even (FiniteDimensional.finrank ℝ { x // x ∈ M }) ", "∀ {V : Type u} [inst : InnerProductSpace ℝ V] (T : V →ₗ[ℝ] V),\n  (∀ (x : ℝ), ¬T.HasEigenvalue x) →\n  ∀ (S : Submodule ℝ V), S.HasInvariantSubspace T → Even (FiniteDimensional.finrank ℝ {x // x ∈ S}) "]}
{"docString": "Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] (a b : α), a ≤ a * b\",\n  \"isProp\": true,\n  \"docString\": \"For any `a` and `b`, `a ≤ a * b` \"},\n {\"theorem\":\n  \"∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"}]\n", "prompt_cons": "/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- For any `a` and `b`, `a ≤ a * b` -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] (a b : α), a ≤ a * b :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem ∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- Prove that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} j a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ for all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$. -/\ntheorem", "choices": ["∀ {n : ℕ} {a b : Finₓ (n + 1) → ℝ},\n  (Finset.sum Finset.univ fun j => a j * b j) ^ 2 ≤\n    (Finset.sum Finset.univ fun j => (j + 1) * (a j ^ 2)) *\n      (Finset.sum Finset.univ fun j => (b j ^ 2) / (j + 1)) ", "∀ {n : ℕ} {a b : ℕ → ℝ},\n  (Finset.sum (Finset.range (n + 1)) fun j => a j * b j) ^ 2 ≤\n    (Finset.sum (Finset.range (n + 1)) fun j => (j + 1) * (a j ^ 2)) *\n      (Finset.sum (Finset.range (n + 1)) fun j => (b j ^ 2) / (j + 1)) ", "∀ {n : ℕ} {a b : ℕ → ℝ},\n  (Finset.sum (Finset.range (n + 1)) fun j => a j * b j) ^ 2 ≤\n    (Finset.sum (Finset.range (n + 1)) fun j => (j + 1) * (a j ^ 2)) *\n      (Finset.sum (Finset.range (n + 1)) fun j => (b j ^ 2) / (j + 1)) ", "∀ {n : ℕ} {a b : Finₓ (n + 1) → ℝ},\n  (Finset.sum Finset.univ fun j => a j * b j) ^ 2 ≤\n    (Finset.sum Finset.univ fun j => (j + 1) * (a j ^ 2)) *\n      (Finset.sum Finset.univ fun j => (b j ^ 2) / (j + 1)) ", "∀ {n : ℕ} {a b : ℕ → ℝ},\n  (Finset.sum (Finset.range (n + 1)) fun j => a j * b j) ^ 2 ≤\n    (Finset.sum (Finset.range (n + 1)) fun j => j * a j ^ 2) *\n      (Finset.sum (Finset.range (n + 1)) fun j => b j ^ 2 / j) ", "∀ {R : Type u_1} [inst : Semiring R] {n : ℕ} {a b : Finₓ (n + 1) → R},\n  (Finset.sum Finset.univ fun i => a i * b i) ^ 2 ≤\n    (Finset.sum Finset.univ fun i => (i + 1) * (a i ^ 2)) *\n      (Finset.sum Finset.univ fun i => (b i ^ 2) / (i + 1)) ", "∀ {n : ℕ} {a b : Finₓ (n + 1) → ℝ},\n  (Finset.sum Finset.univ fun j => a j * b j) ^ 2 ≤\n    (Finset.sum Finset.univ fun j => (j + 1) * a j ^ 2) *\n      (Finset.sum Finset.univ fun j => b j ^ 2 / (j + 1)) ", "∀ {n : ℕ} {a b : ℕ → ℝ},\n  (Finset.sum (Finset.range (n + 1)) fun j => a j * b j) ^ 2 ≤\n    (Finset.sum (Finset.range (n + 1)) fun j => j * (a j) ^ 2) *\n      (Finset.sum (Finset.range (n + 1)) fun j => (b j) ^ 2 / j) ", "∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {n : ℕ} {a b : Finₓ (n + 1) → 𝕜},\n  (Finset.sum (Finset.univ : Finset (Finₓ (n + 1))) fun j => a j * b j) ^ 2 ≤\n    (Finset.sum (Finset.univ : Finset (Finₓ (n + 1))) fun j => (j + 1) * (a j * a j)) *\n      (Finset.sum (Finset.univ : Finset (Finₓ (n + 1))) fun j => (b j * b j) / (j + 1)) ", "∀ {n : ℕ} {a b : ℕ → ℝ},\n  (∑ (j : ℕ) in Finset.range n, a j * b j) ^ 2 ≤\n    ((∑ (j : ℕ) in Finset.range n, j * a j ^ 2) * (∑ (j : ℕ) in Finset.range n, b j ^ 2 / j)) "]}
{"docString": "Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {s : Set E},\\n  Orthonormal 𝕜 Subtype.val →\\n    ∃ w _hw, Orthonormal 𝕜 Subtype.val ∧ ∀ (u : Set E), u ⊇ w → Orthonormal 𝕜 Subtype.val → u = w\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\\ncontaining it. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite-dimensional inner product space admits an orthonormal basis. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner (x + y) (x - y) = 0 ↔ ‖x‖ = ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum and difference of two vectors are orthogonal if and only\\nif they have the same norm. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_3} {v : ι → E}, Orthonormal 𝕜 v → LinearIndependent 𝕜 v\",\n  \"isProp\": true,\n  \"docString\": \"An orthonormal set is linearly independent. \"}]\n", "prompt_cons": "/-- Given an orthonormal set `v` of vectors in `E`, there exists a maximal orthonormal set\ncontaining it. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {s : Set E},\n  Orthonormal 𝕜 Subtype.val →\n    ∃ w _hw, Orthonormal 𝕜 Subtype.val ∧ ∀ (u : Set E), u ⊇ w → Orthonormal 𝕜 Subtype.val → u = w :=\n\n/-- A finite-dimensional inner product space admits an orthonormal basis. -/\ntheorem ∀ (𝕜 : Type u_2) [inst : IsROrC 𝕜] (E : Type u_1) [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E], ∃ w b, ↑b = Subtype.val :=\n\n/-- The sum and difference of two vectors are orthogonal if and only\nif they have the same norm. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner (x + y) (x - y) = 0 ↔ ‖x‖ = ‖y‖ :=\n\n/-- An orthonormal set is linearly independent. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E}, Orthonormal 𝕜 v → LinearIndependent 𝕜 v :=\n\n/-- Suppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an or thonormal list of vectors in $V$. Let $v \\in V$. Prove that $\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, e_{m}\\right\\rangle\\right|^{2}$ if and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$. -/\ntheorem", "choices": ["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {e : ι → E}, Orthonormal 𝕜 e → \n  ∀ (v : E), ∥v∥^2 = (∑ i, ∥inner (e i) v∥^2) ↔ v ∈ Submodule.span 𝕜 (set.Range e) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E}, Orthonormal 𝕜 v →\n    ∀ (x : E), (∥x∥^2 = Σ (i : ι), IsROrC.abs (inner x (v i))^2) ↔ x ∈ submodule.span 𝕜 (set.range v) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : E} {e : ι → E},\n  Orthonormal 𝕜 e →\n  (‖v‖^2 = ∑ i, ∥inner (v) (e i)∥^2 ↔ v ∈ Submodule.span 𝕜 (Set.Range e)) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E} {e : List E},\n  Orthonormal 𝕜 v →\n  ∀ (w : E), (∥w∥^2 = Finset.sum (List.toFinset e) (λ i, ∥inner (v i) w∥^2)) ↔ w ∈ Submodule.span 𝕜 (Set.Range v) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : E} {e : ι → E}, Orthonormal 𝕜 e →\n    (∥v∥^2 = ∑ i, IsROrC.abs (inner v (e i))^2 ↔ v ∈ Submodule.span 𝕜 (Set.Range e)) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E} {l : List ι}, Orthonormal 𝕜 v →\n    ∀ (x : E), (∑ i in l, abs (inner x (v i)) ^ 2) = ∥x∥ ^ 2 ↔ x ∈ Submodule.span 𝕜 (Set.Range v) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {e : ι → E} (he : Orthonormal 𝕜 e) (v : E),\n  (∥v∥^2 = ∑ i, IsROrC.abs (inner (e i) v)^2) ↔ v ∈ Submodule.span 𝕜 (Set.Range e) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E} {e : List E}, Orthonormal 𝕜 (λ i, (e.nth_le i)) →\n  ∀ (v : E), (∥v∥^2 = (∑ i in e.indices, abs (inner v (e.nth_le i))^2)) ↔ v ∈ Submodule.span 𝕜 (set.range e.nth_le) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {n : ℕ} {l : List E}, Orthonormal 𝕜 (List.nth l) → ∀ (v : E),\n  (∥v∥^2 = List.sum (List.map (λ i, IsROrC.abs (inner v (List.nth l i))^2) (List.range n))) ↔\n    v ∈ Submodule.span 𝕜 (Set.Range (List.nth l)) ", "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_3} {v : ι → E} {e : List E}, Orthonormal 𝕜 v →\n    (forall x ∈ e, x ∈ Set.Range v) →\n      (∀ w, ∥w∥^2 = ∑ i in e, ∥inner (v i) w∥^2 ↔ w ∈ Submodule.span 𝕜 (Set.Range v)) "]}
{"docString": "Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$.", "prompts": "[{\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), ¬s1 ≤ s2 ↔ ∃ p, p ∈ s1 ∧ ¬p ∈ s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"One subspace is not less than or equal to another if and only if it has a point not in the\\nsecond subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F)\\n  [inst_6 : RingHomIsometric σ₁₂], ‖f‖ = 0 ↔ f = 0\",\n  \"isProp\": true,\n  \"docString\": \"An operator is zero iff its norm vanishes. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\\n  [inst_5 : NormedSpace 𝕜 G] (f g : ContinuousMultilinearMap 𝕜 E G), ‖f + g‖ ≤ ‖f‖ + ‖g‖\",\n  \"isProp\": true,\n  \"docString\": \"The operator norm satisfies the triangle inequality. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"}]\n", "prompt_cons": "/-- One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s1 s2 : AffineSubspace k P), ¬s1 ≤ s2 ↔ ∃ p, p ∈ s1 ∧ ¬p ∈ s2 :=\n\n/-- An operator is zero iff its norm vanishes. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} (f : E →SL[σ₁₂] F)\n  [inst_6 : RingHomIsometric σ₁₂], ‖f‖ = 0 ↔ f = 0 :=\n\n/-- The operator norm satisfies the triangle inequality. -/\ntheorem ∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace 𝕜 G] (f g : ContinuousMultilinearMap 𝕜 E G), ‖f + g‖ ≤ ‖f‖ + ‖g‖ :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- Show that if $\\operatorname{dim} V \\geq 2$, then the set of normal operators on $V$ is not a subspace of $\\mathcal{L}(V)$. -/\ntheorem", "choices": ["∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V] (h : FiniteDimensional.finrank 𝕜 V ≥ 2),\n  ¬IsSubspace 𝕜 (End 𝕜 V) (SetOf (NormalOperator 𝕜 V)) ", "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : FiniteDimensional 𝕜 V],\n  FiniteDimensional.finrank 𝕜 V ≥ 2 → ¬(AffineSubspace 𝕜 (End 𝕜 V) ", "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V], FiniteDimensional.finrank 𝕜 V ≥ 2 →\n  ¬AffineSubspace 𝕜 (End 𝕜 V) (SetOf (λ A : End 𝕜 V, A * A = A)) ", "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  (h : FiniteDimensional.finrank 𝕜 V ≥ 2), ¬(Submodule 𝕜 (V →ₗ[𝕜] V) (SetOf NormalOperator)) ", "∀ {k : Type u_1} {V : Type u_2} [inst : Field k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : FiniteDimensional k V], findim k V ≥ 2 → ¬(AffineSubspace k (V →ₗ[k] V) (λ f, normal_operator V f)) ", "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V], 2 ≤ FiniteDimensional.finrank 𝕜 V → ¬Subspace 𝕜 (End 𝕜 V) ", "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  (h : FiniteDimensional.finrank 𝕜 V ≥ 2), ¬(∃ W : Subspace 𝕜 (V →ₗ[𝕜] V), ∀ f : V →ₗ[𝕜] V, f ∈ W ↔ NormalOperator 𝕜 V f) ", "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] (h : FiniteDimensional.finrank 𝕜 V ≥ 2),\n  ¬Submodule.SubsetOf (SetOf (λ T : End 𝕜 V, T.IsNormal)) (LinearMap.ker (LinearMap.sub (Algebra.lmul 𝕜 V) (Algebra.lmul 𝕜 V))) ", "∀ {𝕜 : Type u} {V : Type v} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {σ : 𝕜 →+* 𝕜}\n  [inst_3 : RingHomIsometric σ] (h : findim 𝕜 V ≥ 2), ¬(AffineSubspace 𝕜 (End 𝕜 V) ", "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : FiniteDimensional 𝕜 V],\n  FiniteDimensional.finrank 𝕜 V ≥ 2 → ¬(AffineSubspace 𝕜 (End 𝕜 V) NormalOperators) ≤ (AffineSubspace 𝕜 (End 𝕜 V) LinearOperators) "]}
{"docString": "Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"}]\n", "prompt_cons": "/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ :=\n\n/-- Prove that a normal operator on a complex inner-product space is self-adjoint if and only if all its eigenvalues are real. -/\ntheorem", "choices": ["∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsNormal T →\n    (∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ↔ IsSelfAdjoint T ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  (LinearMap.IsSymmetric T ↔\n  (∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ)) ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  (LinearMap.IsSymmetric T ↔ (∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ∧ LinearMap.IsNormal T) ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T ↔ (∀ μ : 𝕜, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ∧ LinearMap.IsNormal T ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsNormal T →\n    (∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ↔\n    LinearMap.IsSymmetric T ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsNormal T →\n    (LinearMap.IsSymmetric T ↔ ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ", "forall {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsNormal T →\n    (LinearMap.IsSymmetric T ↔\n     ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ", "forall {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T ↔\n    (LinearMap.IsNormal T ∧ (∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ)) ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsNormal T →\n    ((∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ↔ IsSelfAdjoint T) ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsNormal T → (∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ) ↔ IsSelfAdjoint T "]}
{"docString": "Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.)", "prompts": "[{\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`⟪T v, v⟫_ℂ` is real for all v.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"}]\n", "prompt_cons": "/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`⟪T v, v⟫_ℂ` is real for all v. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- Suppose $V$ is a complex inner-product space. Prove that every normal operator on $V$ has a square root. (An operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.) -/\ntheorem", "choices": ["∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ (S : V →ₗ[ℂ] V), S * S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ (S : V →ₗ[ℂ] V), S * S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ (S : V →ₗ[ℂ] V), S * S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ (S : V →ₗ[ℂ] V), S * S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ (S : V →ₗ[ℂ] V), S * S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ S : V →ₗ[ℂ] V, LinearMap.comp S S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ (S : V →ₗ[ℂ] V), LinearMap.Comp S S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] [inst_2 : CompleteSpace V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ S : V →ₗ[ℂ] V, S * S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] [inst_2 : CompleteSpace V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ (S : V →ₗ[ℂ] V), S * S = T ", "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] {T : V →ₗ[ℂ] V},\n  LinearMap.IsNormal T → ∃ S : V →ₗ[ℂ] V, S * S = T "]}
{"docString": "Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\\n    1 ≤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\":\n  \"∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2))\",\n  \"isProp\": true,\n  \"docString\": \"The sequence `n / (2 * n + 1)` tends to `1/2` \"}]\n", "prompt_cons": "/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\n    1 ≤ b :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem ∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem ∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0 :=\n\n/-- The sequence `n / (2 * n + 1)` tends to `1/2` -/\ntheorem Filter.Tendsto (fun n => ↑n / (2 * ↑n + 1)) Filter.atTop (nhds (1 / 2)) :=\n\n/-- Prove that $\\frac{1}{2}+\\frac{1}{3}+\\cdots+\\frac{1}{n}$ is not an integer. -/\ntheorem", "choices": ["¬∃ (n : ℕ), ∃ (m : ℕ), (1 / 2 + 1 / 3 + ... + 1 / n) = m ", "∀ (n : ℕ), n > 0 → ¬(∃ (k : ℕ), ∑ i in Finset.range n, (1 / (i + 1)) = ↑k) ", "∀ (n : ℕ), ¬(∃ (k : ℕ), (1 / 2 + 1 / 3 + ... + 1 / n) = ↑k) ", "∀ (n : ℕ), ¬∃ (k : ℕ), ∑ i in Finset.range n, (1 / (i + 2)) = ↑k ", "∀ (n : ℕ), ¬(∃ k : ℕ, (1 / 2 + 1 / 3 + ... + 1 / (n + 1)) = ↑k) ", "∀ (n : ℕ), ¬ (∃ (k : ℕ), (∑ i in Finset.range n, (1 / (i + 2))) = ↑k) ", "∀ (n : ℕ), ¬∃ (k : ℕ), (finset.sum (finset.range (n + 1)) (λ i, (1 / (i + 1)) : ℝ)) = ↑k ", "∀ (n : ℕ), ¬ ∃ (k : ℕ), ∑ (i : ℕ) in (Finset.range n), 1 / (i + 2) = ↑k ", "¬ ∃ n : ℕ, IsIntegral ℤ (finset.sum (finset.range n) (λ (k : ℕ), 1 / (k + 2) : ℕ → ℝ)) ", "forall {n : ℕ} (h : n ≠ 0), ¬(∃ k : ℕ, ((finset.range (n + 1).succ).sum (λ i, 1 / (i + 1))) = ↑k) "]}
{"docString": "If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even.", "prompts": "[{\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"}]\n", "prompt_cons": "/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- If $a$ is a nonzero integer, then for $n>m$ show that $\\left(a^{2^{n}}+1, a^{2^{m}}+1\\right)=1$ or 2 depending on whether $a$ is odd or even. -/\ntheorem", "choices": ["∀ {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1 ∨ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "∀ {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1 ∨ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "forall {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1 ∨ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "∀ {a : ℤ} (m n : ℕ), a ≠ 0 → n > m → (Int.gcd (a ^ (2^n) + 1) (a ^ (2^m) + 1) = 1) ∨ (Int.gcd (a ^ (2^n) + 1) (a ^ (2^m) + 1) = 2) ", "∀ {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1 ∨ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "forall {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) ∨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "∀ {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1 ∨ Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "forall {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m →\n  (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) ∨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "forall {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) ∨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) ", "∀ {a : ℤ} {m n : ℕ}, a ≠ 0 → n > m → (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 1) ∨ (Int.gcd (a ^ (2 ^ n) + 1) (a ^ (2 ^ m) + 1) = 2) "]}
{"docString": "Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, 512 ≤ n → n * (2 * n) ^ Nat.sqrt (2 * n) * 4 ^ (2 * n / 3) ≤ 4 ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inequality which contradicts Bertrand's postulate, for large enough `n`.\\n\"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"}]\n", "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- The inequality which contradicts Bertrand's postulate, for large enough `n`. -/\ntheorem ∀ {n : ℕ}, 512 ≤ n → n * (2 * n) ^ Nat.sqrt (2 * n) * 4 ^ (2 * n / 3) ≤ 4 ^ n :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Show that $\\sum^{\\prime} 1 / n$, the sum being over square free integers, diverges. -/\ntheorem", "choices": ["∀ {ι : Type u_1} [inst : OrderedCancelAddCommMonoid ι] (f : ℕ → ι),\n  (∀ (n : ℕ), 1 ≤ f n) → (∀ (n : ℕ), SquareFree n → f (2 * n + 1) = f (2 * n)) → ¬ Summable f ", "Summable (λ (n : ℕ), if SquareFree n then (1:ℝ) / n else 0) → False ", "∀ {N : ℕ}, ∃ {n : ℕ}, N ≤ n ∧ (Finset.sum (Finset.filter Nat.square_free (Finset.range n)) fun k => 1 / ↑k) > M ", "∀ {A : Type u_1} [inst : CommRing A], Summable (λ n : ℕ, if SquareFree n then (n : ℝ)⁻¹ else 0) ", "∀ {L : Type u_1} [inst : LinearOrderedField L] [inst_1 : FloorRing L], ¬ Summable (λ (n : {n // SquareFree n}), (↑n)⁻¹) ", "∀ (r : ℕ), ∃ (N : ℕ), ∑ (n : ℕ) in (Finset.filter (fun x => ∀ (y : ℕ), Nat.Prime y → y ^ 2 ∣ x → x = y ^ 2) (Finset.range N)), (1 / ↑n) > r ", "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.filter (fun k => SquareFree k) (Finset.range n)) (fun k => 1 / k)) Filter.atTop Filter.atTop ", "∀ {α : Type u_1} [inst_1 : LinearOrderedField α] (P : α → Prop) [inst_2 : NoBotOrder α P] [inst_3 : NoTopOrder α P],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range (Nat.succ n)) fun k => if SquareFree k ∧ ∀ (i : ℕ), i ^ 2 ∣ k → ¬P i then (1 / ↑k) else 0) Filter.atTop Filter.atTop ", "theorem square_free_sum_diverges : ¬ Summable (λ n, if Nat.square_free n then (n : ℝ)⁻¹ else 0) ", "∀ {N : ℕ},\n  (Finset.sum (Finset.filter (fun n => SquareFree n) (Finset.range (N + 1))) fun n => (1 : ℝ) / n) = ∞ "]}
{"docString": "Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers.", "prompts": "[{\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x ≠ 0`. \"}]\n", "prompt_cons": "/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- A solution has `x ≠ 0`. -/\ntheorem ∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0 :=\n\n/-- Show that the equation $3 x^{2}+2=y^{2}$ has no solution in integers. -/\ntheorem", "choices": ["no_solution : ∀ (x y : ℤ), 3 * x ^ 2 + 2 ≠ y ^ 2 ", "∀ {x y : ℤ}, 3 * x * x + 2 ≠ y * y ", "∀ (x y : ℤ), 3 * x ^ 2 + 2 ≠ y ^ 2 ", "∀ (x y : ℤ), 3 * x ^ 2 + 2 ≠ y ^ 2 ", "no_solution_3x2_2_eq_y2 : ∀ (x y : ℤ), 3 * (x ^ 2) + 2 ≠ y ^ 2 ", "∀ (x y : ℤ), 3 * x^2 + 2 ≠ y^2 ", "∀ (x y : ℤ), 3 * x * x + 2 ≠ y * y ", "∀ (x y : ℤ), 3 * x ^ 2 + 2 ≠ y ^ 2 ", "no_solution : ∀ (x y : ℤ), 3 * x^2 + 2 ≠ y^2 ", "∀ (x y : ℤ), 3 * x * x + 2 ≠ y * y "]}
{"docString": "If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$.", "prompts": "[{\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"}]\n", "prompt_cons": "/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- If $n$ is not a prime, show that $(n-1) ! \\equiv 0(n)$, except when $n=4$. -/\ntheorem", "choices": ["∀ {n : ℕ}, ¬Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 ", "∀ {n : ℕ}, n ≠ 1 → ¬Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 ", "∀ {n : ℕ}, ¬ Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 ", "∀ {n : ℕ}, n ≠ 1 → ¬ Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 ", "∀ {n : ℕ}, ¬Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 ", "forall {n : ℕ}, ¬Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 ", "∀ {n : ℕ}, n ≠ 1 → (¬Nat.Prime n → ↑(Nat.factorial (n - 1)) = 0 ∨ n = 4) ", "forall {n : ℕ}, n ≠ 1 → ¬ Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 ", "forall {n : ℕ}, n ≠ 1 → n ≠ 4 → ¬Nat.Prime n → ↑(Nat.factorial (n - 1)) = 0 ", "∀ {n : ℕ}, n ≠ 1 → ¬ Nat.Prime n → n ≠ 4 → ↑(Nat.factorial (n - 1)) = 0 "]}
{"docString": "Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$.", "prompts": "[{\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 ↔ ¬IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"}]\n", "prompt_cons": "/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 ↔ ¬IsSquare ↑a :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- Consider a prime $p$ of the form $4 t+1$. Show that $a$ is a primitive root modulo $p$ iff $-a$ is a primitive root modulo $p$. -/\ntheorem", "choices": ["∀ {a t p : ℕ}, Nat.Prime p → p = 4 * t + 1 → is_primitive_root a p ↔ is_primitive_root (-a) p ", "∀ {a : ℤ} {p t : ℕ} [inst : Fact (Nat.Prime p)], p = 4 * t + 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p ", "∀ {a p : ℕ} (t : ℕ), Nat.Prime p → p = 4 * t + 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p ", "∀ {a t : ℕ} {p : ℕ} [inst : Fact (Nat.Prime p)], p = 4 * t + 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p ", "∀ {a t : ℕ} {p : ℕ}, Nat.Prime p → p = 4 * t + 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p ", "∀ {a t p : ℕ}, Nat.Prime p → p = 4 * t + 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p ", "∀ {a t : ℕ} {p : ℕ} [inst : Fact (Nat.Prime p)], p = 4 * t + 1 → is_primitive_root a p ↔ is_primitive_root (-a) p ", "∀ {a p t : ℕ} [inst : Fact (Nat.Prime p)], p = 4 * t + 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p ", "∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p ", "∀ {a p t : ℕ}, Nat.Prime p → p = 4 * t + 1 → IsPrimitiveRoot a p ↔ IsPrimitiveRoot (-a) p "]}
{"docString": "If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"}]\n", "prompt_cons": "/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- If $p=2^{n}+1$ is a Fermat prime, show that 3 is a primitive root modulo $p$. -/\ntheorem", "choices": ["forall {p : ℕ} (n : ℕ), Nat.Prime p → p = 2 ^ n + 1 → IsPrimitiveRoot 3 p ", "∀ {n p : ℕ}, Nat.Prime p → p = 2 ^ n + 1 → IsPrimitiveRoot (3 : ZMod p) n ", "∀ {n p : ℕ}, p = 2 ^ n + 1 → Nat.Prime p → IsPrimitiveRoot 3 p ", "∀ {n p : ℕ}, Nat.Prime p → p = 2 ^ n + 1 → ZMod.primitive_root 3 p ", "∀ {n p : ℕ}, p = 2 ^ n + 1 → Nat.Prime p → IsPrimitiveRoot (3 : ZMod p) n ", "∀ (n p : ℕ) (h₁ : p = 2 ^ n + 1) (h₂ : Nat.Prime p), primitive_root 3 p ", "∀ (n : ℕ), Nat.Prime (2 ^ n + 1) → IsPrimitiveRoot (3 : ZMod (2 ^ n + 1)) (2 ^ n + 1) ", "∀ (n : ℕ), Nat.Prime (2 ^ n + 1) → IsPrimitiveRoot 3 (2 ^ n + 1) ", "∀ (n : ℕ), Nat.Prime (2 ^ n + 1) → IsPrimitiveRoot 3 (2 ^ n + 1) ", "∀ {n p : ℕ}, p = 2 ^ n + 1 → Nat.Prime p → IsPrimitiveRoot 3 p "]}
{"docString": "Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"}]\n", "prompt_cons": "/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1 :=\n\n/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- Prove that $1^{k}+2^{k}+\\cdots+(p-1)^{k} \\equiv 0(p)$ if $p-1 \\nmid k$ and $-1(p)$ if $p-1 \\mid k$. -/\ntheorem", "choices": ["∀ (p : ℕ) (k : ℕ) [inst : Fact (Nat.Prime p)], (p - 1) ∣ k → (∑ a in Finset.range (p - 1), (ZMod p).mk a ^ k) = -1 ", "∀ {p k : ℕ} [inst : Fact (Nat.Prime p)],\n  (p - 1 ∣ k) → ↑(Finset.sum (Finset.range p) (λ x, x ^ k)) = -1 ", "∀ {p k : ℕ} [inst : Fact (Nat.Prime p)], (p - 1) ∣ k → (∑ x in Finset.range (p - 1), (x + 1) ^ k) ≡ -1 [MOD p] ", "(p : ℕ) [inst : Fact (Nat.Prime p)] (k : ℕ), (p - 1) ∣ k ↔ ∑ i in Finset.range (p - 1), (i + 1)^k = (p - 1) ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (k : ℕ), (¬ (p - 1) ∣ k) → (finset.sum (finset.range p) (λ x, x ^ k)) ≡ 0 [MOD p] ", "∀ {p k : ℕ} [inst : Fact (Nat.Prime p)], ¬((p - 1) ∣ k) → (Finset.sum (Finset.range p) (λ i, i ^ k) ≡ 0 [MOD p]) ", "∀ (k p : ℕ) [inst : Fact (Nat.Prime p)], ¬ (p - 1) ∣ k → (∑ i in Finset.range (p - 1), i ^ k) ≡ 0 [MOD p] ", "∀ {p k : ℕ} [inst : Fact (Nat.Prime p)], (p - 1 ∣ k) → (finset.range (p - 1)).sum (λ x, (x + 1) ^ k) ≡ -1 [MOD p] ", "∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (k : ℕ) (h : ¬ (p - 1) ∣ k), \n  (Finset.sum (Finset.range p) (λ x, x ^ k)) % p = if (p - 1) ∣ k then (-1 : ZMod p) else 0 ", "∀ {p k : ℕ} [inst : Fact (Nat.Prime p)], ¬(p - 1) ∣ k → ∑ x in Finset.range (p - 1), (x : ZMod p) ^ k = 0 "]}
{"docString": "Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"}]\n", "prompt_cons": "/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1 :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- Show that $x^{4} \\equiv 2(p)$ has a solution for $p \\equiv 1(4)$ iff $p$ is of the form $A^{2}+64 B^{2}$. -/\ntheorem", "choices": ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → (ExistsSolution x^4 ≡ 2 [MOD p] ↔ ∃ A B, p = A^2 + 64 * B^2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → (ExistsSolution x^4 ≡ 2[p] ↔ ∃ A B, p = A^2 + 64 * B^2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ((∃ x, x ^ 4 ≡ 2 (ZMod p)) ↔ ∃ A B, p = A ^ 2 + 64 * B ^ 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → (∃ x, x ^ 4 = 2 * p ↔ ∃ A B, p = A ^ 2 + 64 * B ^ 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (p % 4 = 1)], (∃ x : ZMod p, x ^ 4 = 2) ↔ (∃ a b : ℕ, p = a ^ 2 + 64 * b ^ 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → (Exists (λ x, x ^ 4 = 2 * p) ↔ Exists (λ A, Exists (λ B, p = A ^ 2 + 64 * B ^ 2))) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ((∃ x, x ^ 4 ≡ 2 * p) ↔ ∃ A B, p = A ^ 2 + 64 * B ^ 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → (Exists (λ x : ZMod p, x ^ 4 = 2 * p) ↔ Exists (λ A : ℕ, Exists (λ B : ℕ, p = A ^ 2 + 64 * B ^ 2))) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ((∃ x, x ^ 4 = 2 * p) ↔ ∃ A B, p = A ^ 2 + 64 * B ^ 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → (Exists (λ (x : ZMod p), x ^ 4 = 2) ↔ Exists (λ (A B : ℕ), p = A ^ 2 + 64 * B ^ 2)) "]}
{"docString": "Show that $\\sin (\\pi / 12)$ is an algebraic number.", "prompts": "[{\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 6` is `1 / 2`. \"},\n {\"theorem\":\n  \"∀ (x : ℝ),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\": \"Real.sin (Real.pi / 3) = Real.sqrt 3 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 3` is `√3 / 2`. \"},\n {\"theorem\":\n  \"∀ (z : ℂ),\\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (↑Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"}]\n", "prompt_cons": "/-- The sine of `π / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem ∀ (x : ℝ),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- The sine of `π / 3` is `√3 / 2`. -/\ntheorem Real.sin (Real.pi / 3) = Real.sqrt 3 / 2 :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem ∀ (z : ℂ),\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (↑Real.pi * z))) :=\n\n/-- Show that $\\sin (\\pi / 12)$ is an algebraic number. -/\ntheorem", "choices": ["Real.sin (Real.pi / 12).is_algebraic ", "Real.sin (Real.pi / 12).is_algebraic ", "is_algebraic (Real.sin (Real.pi / 12)) ", "Real.sin (Real.pi / 12) = Real.sqrt (1 / 2 - Real.sqrt 3 / 4) ", "Real.sin_algebraic (Real.pi / 12) : IsAlgebraic ℚ (Real.sin (Real.pi / 12)) ", "is_algebraic ℝ (Real.sin (Real.pi / 12)) ", "Real.sin (Real.pi / 12) = (Real.sqrt 6 - Real.sqrt 2) / 4 ", "algebraic (Real.sin (Real.pi / 12)) ", "Real.sin (Real.pi / 12).is_algebraic : is_algebraic ℤ (Real.sin (Real.pi / 12)) ", "is_algebraic ℚ (Real.sin (Real.pi / 12)) "]}
{"docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant.", "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\\n  AnalyticOn ℂ g U →\\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `ℂ`). \"}]\n", "prompt_cons": "/-- If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `ℂ`). -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\n  AnalyticOn ℂ g U →\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s) :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Im}(f)$ is constant, then $f$ is constant. -/\ntheorem", "choices": ["∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    IsOpen U → (∀ (z : E), z ∈ U → (f z).im = 0) → ∀ (a b : E), a ∈ U → b ∈ U → f a = f b ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → ℂ} {U : Set M},\n  AnalyticOn ℂ f U →\n    (∀ (x : M), x ∈ U → Im (f x) = Im (f (arbitrary M))) → ∀ (a b : M), a ∈ U → b ∈ U → f a = f b ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f Ω →\n    (∀ x y ∈ Ω, f x ≠ f y → (f x).im ≠ (f y).im) → ∀ x y ∈ Ω, f x = f y ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    IsOpen U → (∀ x ∈ U, (f x).im = (f U).im) → ∀ x y ∈ U, f x = f y ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    IsOpen U → (∃ c, ∀ (z : E), z ∈ U → (f z).im = c) → (∃ w, ∀ (z : E), z ∈ U → f z = w) ", "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsOpen U → a ∈ U → b ∈ U → (∀ x ∈ U, (f x).im = a.im) → f a = f b ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f Ω →\n    (∃ c : ℝ, ∀ z : E, z ∈ Ω → f z = (f z).re + c * I) → ∀ (a b : E), a ∈ Ω → b ∈ Ω → f a = f b ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    (∀ (z : E), z ∈ U → (f z).im = 0) → (∃ w, ∀ (z : E), z ∈ U → f z = w) ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    (∃ c, ∀ (z : E), z ∈ U → (f z).im = c) → (∃ w, ∀ (z : E), z ∈ U → f z = w) ", "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f Ω →\n    (∃ c, ∀ (z : E), z ∈ Ω → (f z).im = c) → (∃ w, ∀ (z : E), z ∈ Ω → f z = w) "]}
{"docString": "Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle.", "prompts": "[{\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\": \"¬Summable fun n => 1 / ↑n\",\n  \"isProp\": true,\n  \"docString\": \"Harmonic series is not unconditionally summable. \"}]\n", "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Harmonic series is not unconditionally summable. -/\ntheorem ¬Summable fun n => 1 / ↑n :=\n\n/-- Prove that the power series $\\sum nz^n$ does not converge on any point of the unit circle. -/\ntheorem", "choices": ["∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedGroup E] [inst_2 : NormedSpace 𝕜 E] (p : ℕ → 𝕜), ¬HasSum (fun z => ∑ (n : ℕ), p n * z^n) (circle_map {𝕜 : 𝕜} 𝟙) ", "∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup 𝕜] [inst_2 : NormedSpace 𝕜 𝕜],\n  ¬HasSum (λ n, n * (1 : 𝕜) ^ n) (1 : 𝕜) ", "∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedSpace 𝕜 𝕜]\n  (z : 𝕜), (abs z = 1) → ¬HasSum (fun n => n * z ^ n) ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] (z : 𝕜), IsROrC.abs z = 1 → ¬HasSum (fun n => n * z ^ n) ", "∀ (z : ℂ), Complex.abs z = 1 → ¬HasSum (fun n => ↑n * z ^ n) ", "∀ {𝕜 : Type u_3} [_inst_1 : Is_R_or_C 𝕜] {n : ℕ} {z : 𝕜}, HasMem.Mem z (Metric.Circle 0 1) → ¬HasSum (fun k => (k : 𝕜) * z ^ k) n ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] (z : 𝕜), IsROrC.abs z = 1 → ¬HasSum (λ n, n * z ^ n) (𝕜 → 𝕜) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E],\n  ¬HasSum (fun n => n • (1 : 𝕜) ^ n) (FormalMultilinearSeries.radius (1 : 𝕜)) ", "∀ {𝕜 : Type u_1} [inst : NondiscreteNormedField 𝕜] {z : 𝕜}, HasMem.Mem z (Metric.Sphere 0 1) → ¬Summable fun n => n * z ^ n ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [inst_1 : CompleteSpace 𝕜] {z : 𝕜}, HasMem.Mem z (Metric.Sphere 0 1) → ¬HasSum (fun n => ↑n * z ^ n) "]}
{"docString": "Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$.", "prompts": "[{\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"}]\n", "prompt_cons": "/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Prove that the power series $\\sum zn/n$ converges at every point of the unit circle except $z = 1$. -/\ntheorem", "choices": ["∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {z : 𝕜},\n  HasMem.Mem z (Metric.Sphere (0 : 𝕜) 1) →\n    z ≠ 1 → HasSum (fun n => z ^ (n + 1) / (n + 1)) (-(1 - z)⁻¹) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {R : ℝ} (z : 𝕜),\n  abs (Complex.abs z - 1) < R →\n    Summable (λ (n : ℕ), z ^ n * (↑(n + 1))⁻¹) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {z : 𝕜}, (Complex.abs z = 1 ∧ z ≠ 1) → Summable (λ n => z^n / (n+1 : 𝕜)) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜],\n  ContinuousOn (PowerSeries.partialSum (λ n, PowerSeries.mk (λ n => ↑n⁻¹)) n) (Metric.sphere 0 1)ᶜ (1 : 𝕜) ", "∀ {𝕜 : Type u_1} [_inst_1 : IsROrC 𝕜] [_inst_2 : CompleteSpace 𝕜],\n  ∀ z : 𝕜, HasMem.Mem z (Metric.Sphere 0 1) → z ≠ 1 → HasSum (λ n => z ^ n / (n + 1)) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] (z : 𝕜),\n  abs z = 1 ∧ z ≠ 1 → Summable (λ n => z ^ n / ↑n) ", "∀ {𝕜 : Type u_1} [_inst_1 : NondiscreteNormedField 𝕜] {z : 𝕜}, HasMem.Mem z (Metric.Sphere (0 : 𝕜) 1) → z ≠ 1 →\n  Summable (λ n => z ^ n / (n + 1 : 𝕜)) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {z : 𝕜},\n  HasMem.Mem z (Metric.Sphere 0 1) ∧ z ≠ 1 → Summable (λ (n : ℕ), z ^ n / (n + 1 : 𝕜)) ", "∀ {𝕜 : Type u_1} [inst : NondiscreteNormedField 𝕜] {z : 𝕜},\n  (HasMem.Mem z (Metric.Sphere 0 1) ∧ z ≠ 1) →\n    Summable (λ n => z ^ n / (n + 1 : 𝕜)) ", "∀ {A : Type u_1} [inst : Field A] [inst_1 : Algebra ℚ A] [inst_2 : CharP A 0],\n  ContinuousOn (PowerSeries.sum (PowerSeries.mk (λ (n : ℕ), (algebraMap ℚ A) (1 / ↑(n + 1)))))\n    (Metric.sphere 0 1 \\ {1}) "]}
{"docString": "Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$.", "prompts": "[{\"theorem\":\n  \"∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"},\n {\"theorem\":\n  \"∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. \"},\n {\"theorem\": \"∀ {x : ℝ}, 0 < x → Real.sin x < x\",\n  \"isProp\": true,\n  \"docString\": \"For 0 < x, we have sin x < x. \"},\n {\"theorem\": \"Real.sin (Real.pi / 6) = 1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"The sine of `π / 6` is `1 / 2`. \"}]\n", "prompt_cons": "/-- Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem ∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. -/\ntheorem ∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I :=\n\n/-- For 0 < x, we have sin x < x. -/\ntheorem ∀ {x : ℝ}, 0 < x → Real.sin x < x :=\n\n/-- The sine of `π / 6` is `1 / 2`. -/\ntheorem Real.sin (Real.pi / 6) = 1 / 2 :=\n\n/-- Show that $\\int_{0}^{\\infty} \\frac{\\sin x}{x} d x=\\frac{\\pi}{2}$. -/\ntheorem", "choices": ["∀ (ε : ℝ), 0 < ε → ∃ (δ : ℝ), 0 < δ ∧ (λ x, ∫ (t : ℝ) in 0 .. x, (Real.sin t) / t) = Real.pi / 2 ", "∀ h : ℝ, 0 < h → (∫ (x : ℝ) in 0 ..h, (Real.sin x) / x) = Real.pi / 2 ", "∀ (x : ℝ), 0 < x → (1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x / x) = Real.pi / 2 ", "∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n ", "∀ (n : ℕ), ∫ (x : ℝ) in 0 ..+∞, (Real.sin x / x) = Real.pi / 2 ", "∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n ", "∀ (h : ℝ → ℝ) (c : ℝ), h = fun x => Real.sin x / x → ∫ (x : ℝ) in 0 ..Real.top, h x = Real.pi / 2 ", "∀ f : ℝ → ℝ, f = (λ x, Real.sin x / x) → ∫ (x : ℝ) in 0 ..+∞, f x = Real.pi / 2 ", "∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n ", "∀ (ε : ℝ), 0 < ε → ∃ (u : ℝ), (∫ (x : ℝ) in 0 ..u, (Real.sin x) / x) < 1 / 2 * Real.pi + ε "]}
{"docString": "Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E} {z₀ : 𝕜},\\n  AnalyticAt 𝕜 f z₀ → (∀ᶠ (z : 𝕜) in nhds z₀, f z = 0) ∨ ∀ᶠ (z : 𝕜) in nhdsWithin z₀ {z₀}ᶜ, f z ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *principle of isolated zeros* for an analytic function, local version: if a function is\\nanalytic at `z₀`, then either it is identically zero in a neighborhood of `z₀`, or it does not\\nvanish in a punctured neighborhood of `z₀`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\\n  {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → y ∈ EMetric.ball x r → AnalyticAt 𝕜 f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\\nit is analytic at every point of this ball. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {h : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R → WittVector p R}\\n  {f g : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R} [hh : WittVector.IsPoly₂ p h]\\n  [hf : WittVector.IsPoly p f] [hg : WittVector.IsPoly p g], WittVector.IsPoly₂ p fun R _Rcr x y => h (f x) (g y)\",\n  \"isProp\": true,\n  \"docString\": \"The composition of polynomial functions is polynomial. \"},\n {\"theorem\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"}]\n", "prompt_cons": "/-- The *principle of isolated zeros* for an analytic function, local version: if a function is\nanalytic at `z₀`, then either it is identically zero in a neighborhood of `z₀`, or it does not\nvanish in a punctured neighborhood of `z₀`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E} {z₀ : 𝕜},\n  AnalyticAt 𝕜 f z₀ → (∀ᶠ (z : 𝕜) in nhds z₀, f z = 0) ∨ ∀ᶠ (z : 𝕜) in nhdsWithin z₀ {z₀}ᶜ, f z ≠ 0 :=\n\n/-- If a function admits a power series expansion `p` on an open ball `B (x, r)`, then\nit is analytic at every point of this ball. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] [inst_5 : CompleteSpace F]\n  {f : E → F} {p : FormalMultilinearSeries 𝕜 E F} {x y : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → y ∈ EMetric.ball x r → AnalyticAt 𝕜 f y :=\n\n/-- The composition of polynomial functions is polynomial. -/\ntheorem ∀ {p : ℕ} {h : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R → WittVector p R}\n  {f g : ⦃R : Type u_1⦄ → [inst : CommRing R] → WittVector p R → WittVector p R} [hh : WittVector.IsPoly₂ p h]\n  [hf : WittVector.IsPoly p f] [hg : WittVector.IsPoly p g], WittVector.IsPoly₂ p fun R _Rcr x y => h (f x) (g y) :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem ∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q :=\n\n/-- Suppose $f$ is an analytic function defined everywhere in $\\mathbb{C}$ and such that for each $z_0 \\in \\mathbb{C}$ at least one coefficient in the expansion $f(z) = \\sum_{n=0}^\\infty c_n(z - z_0)^n$ is equal to 0. Prove that $f$ is a polynomial. -/\ntheorem", "choices": ["∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E}, (∀ z₀ : 𝕜, ∃ n : ℕ, ∀ (p : FormalMultilinearSeries 𝕜 𝕜 E),\n  HasFPowerSeriesAt f p z₀ → p n = 0) → IsPoly 𝕜 f ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E},\n  (∀ z₀ : 𝕜, AnalyticAt 𝕜 f z₀ ∧ ∃ n : ℕ, FormalMultilinearSeries.coeff 𝕜 n (fNearRing 𝕜 f z₀) = 0)\n  → ∃ p : Polynomial 𝕜 E, ∀ z : 𝕜, f z = Polynomial.eval z p ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {F : Type u_2} [inst_1 : NormedAddCommGroup F]\n  [inst_2 : NormedSpace 𝕜 F] [inst_3 : CompleteSpace F] {f : 𝕜 → F},\n  (∀ z₀ : 𝕜, AnalyticAt 𝕜 f z₀ ∧ ∃ n₀, (FormalMultilinearSeries 𝕜 𝕜 F).coeff n₀ z₀ = 0) → ∃ p : 𝕜[X], ∀ z : 𝕜, f z = p.eval z ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E},\n  (∀ z₀ : 𝕜, AnalyticAt 𝕜 f z₀ ∧ ∃ n, (FormalMultilinearSeries 𝕜 (fun _x => z₀) f).n = 0) → IsPoly 𝕜 f ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E},\n  (AnalyticAt 𝕜 f z₀ → ∀ n : ℕ, ∃ z : 𝕜, (fDerivativeSeries 𝕜 f z₀ n).coeff n ≠ 0) → Polynomial 𝕜 f ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E}, (∀ z₀ : 𝕜, ∃ n : ℕ, (AnalyticAtSeries 𝕜 f z₀).coeff n = 0) →\n  ∃ (p : 𝕜[X]), ∀ (z : 𝕜), f z = eval_polynomial p z ", "forall {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] (f : 𝕜 → E),\n  (∀ z₀ : 𝕜, AnalyticAt 𝕜 f z₀ ∧ ∃ n, ∀ p : FormalMultilinearSeries 𝕜 𝕜 E, HasFPowerSeriesAt f p z₀ → p n = 0) →\n  (∃ N p, (∀ n > N, p n = 0) ∧ ∀ₓ (x : 𝕜), f x = FPowerSeries 𝕜 E p x) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E},\n  (∀ z₀ : 𝕜, AnalyticAt 𝕜 f z₀ ∧ ∃ n, (FormalMultilinearSeries.coeff 𝕜 f n z₀) = 0) → IsPoly 𝕜 f ", "∀ {𝕜 : Type u_1} [inst : NondiscreteNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : 𝕜 → E},\n  (∀ z₀ : 𝕜, AnalyticAt 𝕜 f z₀ ∧ ∃ n : ℕ, (formal_multilinear_series 𝕜 E f z₀).n = 0) →\n  ∃ n : ℕ, ∃ p : 𝕜[𝕜], Polynomial.degree p = n ∧ ∀ z : 𝕜, f z = (p.eval z) ", "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace E] {f : 𝕜 → E},\n  (∀ z₀ : 𝕜, ∃ n : ℕ, AnalyticAt 𝕜 f z₀ ∧ (∃ (p : FormalMultilinearSeries 𝕜 𝕜 E) (r : ENNReal),\n    HasFPowerSeriesOnBall f p z₀ r ∧ p n = 0)) → ∃ p : Polynomial 𝕜 (E → 𝕜), ∀ z, f z = p.eval z "]}
{"docString": "Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"∀ (a : ℝ) {b : ℝ}, 0 < b → MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\": \"`exp (-b * x)` is integrable on `(a, ∞)`. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\\nPicard-Lindelöf/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"}]\n", "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- `exp (-b * x)` is integrable on `(a, ∞)`. -/\ntheorem ∀ (a : ℝ) {b : ℝ}, 0 < b → MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a) :=\n\n/-- Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\nPicard-Lindelöf/Cauchy-Lipschitz theorem. -/\ntheorem ∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Show that $ \\int_{-\\infty}^{\\infty} \\frac{x \\sin x}{x^2 + a^2} dx = \\pi e^{-a}$ for $a > 0$. -/\ntheorem", "choices": ["∀ (a : ℝ), 0 < a → ∫ (x : ℝ) in -∞..∞, (x * sin x) / (x^2 + a^2) = π * exp (-a) ", "∀ (a : ℝ), 0 < a → ∫ (x : ℝ) in (-∞, ∞), (x * sin x) / (x^2 + a^2) = π * rexp (-a) ", "∀ (a : ℝ), 0 < a → ∫ (x : ℝ) in Set.Univ, (x * sin x) / (x ^ 2 + a ^ 2) = π * rexp (-a) ", "∀ (a : ℝ), 0 < a → ∫ (x : ℝ) in -∞..∞, (x * sin x) / (x^2 + a^2) = π * exp (-a) ", "∀ (a : ℝ), 0 < a → ∫ (x : ℝ) in ℝ, (x * sin x) / (x^2 + a^2) = π * E.real_exp (-a) ", "∀ (a : ℝ), 0 < a → ∫ x in ℝ, (x * sin x) / (x^2 + a^2) = π * exp (-a) ", "∀ (a : ℝ), 0 < a → ∫ x in (Set.Iic (-Real.pi)) ⊔ Set.Ici Real.pi, (x * sin x) / (x ^ 2 + a ^ 2) = π * exp (-a) ", "∀ (a : ℝ), 0 < a → ∫ (x : ℝ) in (-∞, ∞), (x * sin x) / (x^2 + a^2) = π * rexp (-a) ", "∀ (a : ℝ), 0 < a → ∫ (x : ℝ) in ℝ, (x * sin x) / (x^2 + a^2) = π * exp (-a) ", "forall (a : ℝ), 0 < a →\n  ∫ (x : ℝ) in ℝ, (x * sin x) / (x^2 + a^2) = π * exp (-a) "]}
{"docString": "Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) [inst : IsTrichotomous α r] [inst : IsIrrefl β s]\\n  (f : α → β), (∀ {x y : α}, r x y → s (f x) (f y)) → Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"An increasing function is injective \"},\n {\"theorem\":\n  \"∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EmbeddingLike F α β] (f : F),\\n  Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\": \"The coercion to functions must produce injective functions. \"},\n {\"theorem\":\n  \"∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e g : E),\\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g\",\n  \"isProp\": true,\n  \"docString\": \"The two coercions to functions are jointly injective. \"},\n {\"theorem\":\n  \"∀ {α : Sort u_3} {β : Sort u_1} {γ : Sort u_2} {g : β → γ},\\n  Function.Injective g → Function.Injective ((fun x x_1 => x ∘ x_1) g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition by an injective function on the left is itself injective. \"}]\n", "prompt_cons": "/-- An increasing function is injective -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) [inst : IsTrichotomous α r] [inst : IsIrrefl β s]\n  (f : α → β), (∀ {x y : α}, r x y → s (f x) (f y)) → Function.Injective f :=\n\n/-- The coercion to functions must produce injective functions. -/\ntheorem ∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EmbeddingLike F α β] (f : F),\n  Function.Injective ↑f :=\n\n/-- The two coercions to functions are jointly injective. -/\ntheorem ∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e g : E),\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g :=\n\n/-- Composition by an injective function on the left is itself injective. -/\ntheorem ∀ {α : Sort u_3} {β : Sort u_1} {γ : Sort u_2} {g : β → γ},\n  Function.Injective g → Function.Injective ((fun x x_1 => x ∘ x_1) g) :=\n\n/-- Prove that all entire functions that are also injective take the form $f(z) = az + b$, $a, b \\in \\mathbb{C}$ and $a \\neq 0$. -/\ntheorem", "choices": ["∀ {ℂ : Type u_1} [inst : Field ℂ] [inst : Algebra ℂ ℂ] (f : ℂ → ℂ),\n  (∀ (x : ℂ), f x ≠ 0) → Function.Injective f → ∃ (a b : ℂ), a ≠ 0 ∧ f = (fun z : ℂ => a * z + b) ", "∀ {α : Type u_1} {β : Type u_2} [inst : Ring α] [inst : Ring β] (f : α → β),\n  Function.Injective f → (∀ x y, f (x * y) = f x * f y) → ∃ a b, ∀ x, f x = a * x + b ∧ a ≠ 0 ", "∀ {α : Type u_1} {β : Type u_2} [inst_1 : IntegralDomain α] [inst_2 : Field β] (f : α → β),\n  Function.Injective f → (∃ a b : β, a ≠ 0 ∧ ∀ x : α, f x = a * x + b) ", "∀ {α : Type u_1} {β : Type u_2} [inst : Field α] [inst : Field β] (f : α → β),\n  Function.Injective f → (∃ a b : β, a ≠ 0 ∧ ∀ z : α, f z = a * z + b) ", "∀ {α : Type u_1} {β : Type u_2} [inst : Field α] [inst : Field β]\n  (f : α → β), (∀ x : α, f x ≠ 0) → Function.Injective f →\n  (∃ a b : β, a ≠ 0 ∧ ∀ x : α, f x = a * x + b) ", "∀ {α : Type u_1} {β : Type u_2} [inst : Field α] [inst : Field β] (f : α → β),\n  (∀ (x : α), f (x + 1) - f x = f 1) → Function.Injective f → ∃ (a b : β), a ≠ 0 ∧ ∀ (x : α), f x = a * x + b ", "forall {α : Type u_1} {β : Type u_2} [inst : Field α] [inst : Field β] [inst : IsEntire α β]\n  (f : α → β), Function.Injective f → ∃ a b : β, a ≠ 0 ∧ ∀ z : α, f z = a * z + b ", "∀ {α : Type u_1} {β : Type u_2} [inst : Field α] [inst : Field β] (f : α → β), \n  (∀ (x y : α), f x = f y → x = y) ∧ (∀ x, ∃ a b : β, a ≠ 0 ∧ f x = a * x + b) →\n  (∃ a b : β, a ≠ 0 ∧ ∀ x, f x = a * x + b) ", "∀ {α : Type u_1} {β : Type u_2} [inst : Field α] [inst : Field β]\n  (f : α → β), (∀ (x : α), f x ≠ 0) → Function.Injective f →\n  (∃ (a : β) (b : β), a ≠ 0 ∧ ∀ (x : α), f x = a * x + b) ", "∀ {α : Type u_1} {β : Type u_2} [inst1 : Field α] [inst2 : Field β] [inst3 : Algebra α β]\n  (f : α →+* β), Function.Injective f → ∃ a b : β, a ≠ 0 ∧ ∀ z : α, f z = a * z + b "]}
{"docString": "Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$.", "prompts": "[{\"theorem\":\n  \"∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) ≤ abs z`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\\n  0 ≤ R →\\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\\n      Set.Countable s →\\n        ContinuousOn f (Metric.closedBall c R) →\\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\\\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"}]\n", "prompt_cons": "/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) ≤ abs z`. -/\ntheorem ∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\n  0 ≤ R →\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\n      Set.Countable s →\n        ContinuousOn f (Metric.closedBall c R) →\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0 :=\n\n/-- Prove that if $f$ is holomorphic in the unit disc, bounded and not identically zero, and $z_{1}, z_{2}, \\ldots, z_{n}, \\ldots$ are its zeros $\\left(\\left|z_{k}\\right|<1\\right)$, then $\\sum_{n}\\left(1-\\left|z_{n}\\right|\\right)<\\infty$. -/\ntheorem", "choices": ["∀ {𝕜 : Type u_1} [inst : NondiscreteNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {f : ℂ → 𝕜},\n  DifferentiableOn 𝕜 f (Metric.ball 0 1) →\n    Bounded (f '' Metric.ball 0 1) →\n      f ≠ 0 →\n        ∀ {s : Set ℂ},\n          Set.Countable s →\n            (∀ z ∈ s, Complex.abs z < 1 ∧ f z = 0) →\n              HasSum (λ z : ℂ, 1 - Complex.abs z) (tsum fun z => 1 - Complex.abs z) ", "∀ {f : ℂ → ℂ} {z : ℕ → ℂ},\n  DifferentiableOn ℂ f (Metric.ball 0 1) →\n    BoundedOn ℂ f (Metric.ball 0 1) →\n      f ≠ 0 →\n        (∀ (n : ℕ), Complex.abs (z n) < 1 ∧ f (z n) = 0) →\n          Summable (λ (n : ℕ), 1 - Complex.abs (z n)) ", "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E} {dis : ℝ},\n  0 < dis →\n    ContinuousOn f (Metric.ball 0 dis) →\n      (∀ (z : ℂ), z ∈ Metric.ball 0 dis → f z = 0 ∨ DifferentiableAt ℂ f z) →\n        (∃ (c : ℝ), 0 < c ∧ ∀ (z : ℂ), z ∈ Metric.ball 0 dis → Complex.abs (f z) ≤ c) →\n          ∀ {s : ℕ → ℂ},\n            (∀ (n : ℕ), Complex.abs (s n) < dis ∧ f (s n) = 0) →\n              Summable (λ n : ℕ, 1 - Complex.abs (s n)) ", "∀ {f : ℂ → ℂ} {s : ℕ → ℂ},\n  (∀ (z : ℂ), HasMem.Mem z (Metric.Ball 0 1) → ContinuousAt f z ∧ DifferentiableAt ℂ f z) →\n    Bounded (f '' (Metric.Ball 0 1)) →\n      (∀ (n : ℕ), HasMem.Mem (s n) (Metric.Ball 0 1) ∧ f (s n) = 0) →\n        Summable (λ (n : ℕ), 1 - ↑Complex.abs (s n)) ", "∀ {f : ℂ → ℂ} {z : ℕ → ℂ},\n  DifferentiableOn ℂ f (Metric.ball 0 1) →\n    BoundedOn f (Metric.ball 0 1) →\n      f ≠ 0 →\n        (∀ (n : ℕ), Complex.abs (z n) < 1 ∧ f (z n) = 0) →\n          Summable (λ n, 1 - Complex.abs (z n)) ", "∀ {f : ℂ → ℂ} {z : ℕ → ℂ},\n  DifferentiableOn ℂ f (Metric.ball 0 1) →\n    Bounded (f '' Metric.ball 0 1) →\n      (∀ (n : ℕ), f (z n) = 0 ∧ ↑Complex.abs (z n) < 1) →\n        Summable (λ n, 1 - ↑Complex.abs (z n)) ", "∀ {f : ℂ → ℂ} {s : ℕ → ℂ},\n  ContinuousOn f (Metric.closedBall 0 1) →\n    BoundedAtDisc f →\n      ¬(f = 0) →\n        (∀ (n : ℕ), s n ∈ Metric.ball 0 1 ∧ f (s n) = 0) →\n          Summable (λ n, 1 - ↑Complex.abs (s n)) ", "∀ {f : ℂ → ℂ} (hf : Not (f = Zero.zero)),\n  ContinuousOn f (Metric.ball 0 1) →\n    DifferentiableOn ℂ f (Metric.ball 0 1) →\n      BoundedContinuousFunction.NormedSpace (Set.Pi (Metric.ball 0 1) f) →\n        ∀ {z : ℕ → ℂ},\n          (∀ (n : ℕ), (z n) ∈ Metric.ball 0 1) →\n            (∀ (n : ℕ), f (z n) = 0) → ∃ (C : ℝ), HasSum (fun n => 1 - ↑Complex.abs (z n)) C ", "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {f : ℂ → E} {s : ℕ → ℂ},\n  ContinuousOn f (Metric.ball 0 1) →\n    (∀ (n : ℕ), Complex.abs (s n) < 1) →\n      Bounded (range f) →\n        (∀ (z : ℂ), f z = 0 ↔ z ∈ Set.Range s) →\n          Summable (λ (n : ℕ), 1 - Complex.abs (s n)) ", "∀ {f : ℂ → ℂ} {R : ℝ},\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\n      BoundedContinuousFunction f (Metric.ball 0 R) →\n        f ≠ 0 →\n          ∀ {s : Set ℂ}, Set.Countable s →\n            (∀ (z : ℂ), z ∈ s → f z = 0 ∧ Complex.abs z < 1) →\n              Summable (λ z, 1 - Complex.abs z) "]}
{"docString": "Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {x y : α}, 0 < x → y < 1 → ∃ n, y ^ n < x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ} {x : ℝ} {n : ℕ},\\n  ConvexOn ℝ (Set.Ioi 0) f →\\n    (∀ {y : ℝ}, 0 < y → f (y + 1) = f y + Real.log y) → 2 ≤ n → 0 < x → f ↑n + x * Real.log (↑n - 1) ≤ f (↑n + x)\",\n  \"isProp\": true,\n  \"docString\": \"Linear lower bound for `f (x + n)` on unit interval \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {n : ℕ∞}, ContDiff 𝕜 n f → 1 ≤ n → Differentiable 𝕜 f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is `C^n` with `n ≥ 1`, then it is differentiable. \"}]\n", "prompt_cons": "/-- If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n] :=\n\n/-- For any `y < 1` and any positive `x`, there exists `n : ℕ` with `y ^ n < x`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {x y : α}, 0 < x → y < 1 → ∃ n, y ^ n < x :=\n\n/-- Linear lower bound for `f (x + n)` on unit interval -/\ntheorem ∀ {f : ℝ → ℝ} {x : ℝ} {n : ℕ},\n  ConvexOn ℝ (Set.Ioi 0) f →\n    (∀ {y : ℝ}, 0 < y → f (y + 1) = f y + Real.log y) → 2 ≤ n → 0 < x → f ↑n + x * Real.log (↑n - 1) ≤ f (↑n + x) :=\n\n/-- If a function is `C^n` with `n ≥ 1`, then it is differentiable. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {n : ℕ∞}, ContDiff 𝕜 n f → 1 ≤ n → Differentiable 𝕜 f :=\n\n/-- Let $f: \\mathbb{R} \\rightarrow \\mathbb{R}$ be an infinitely differentiable function satisfying $f(0)=0, f(1)=1$, and $f(x) \\geq 0$ for all $x \\in$ $\\mathbb{R}$. Show that there exist a positive integer $n$ and a real number $x$ such that $f^{(n)}(x)<0$. -/\ntheorem", "choices": ["∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {f : E → E} [inst_3 : OpenEmbedding f],\n  f 0 = 0 → f 1 = 1 → (∀ x, 0 ≤ f x) →\n  ∃ (n : ℕ) (h₁ : 0 < n) (x : E), f^[n] x < 0 ", "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {f : 𝕜 → 𝕜} [inst_1 : Archimedean 𝕜], f 0 = 0 → f 1 = 1 →\n  (∀ x, 0 ≤ f x) → ContDiff 𝕜 ⊤ f → ∃ (n : ℕ) (x : 𝕜), 0 < n ∧ f^[n] x < 0 ", "∀ {f : ℝ → ℝ}, ContDiff ℝ ⊤ f → f 0 = 0 → f 1 = 1 → (∀ x, 0 ≤ f x) → ∃ (n : ℕ) (x : ℝ), 0 < n ∧ f^[n] x < 0 ", "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : 𝕜 → 𝕜}\n  {n : ℕ∞}, ContDiff 𝕜 n f → f 0 = 0 → f 1 = 1 → (∀ x, 0 ≤ f x) → ∃ n : ℕ, ∃ x : 𝕜, 0 < n ∧ Differentiable 𝕜 f ∧ fderiv 𝕜 (f ^ [n]) x < 0 ", "∀ {f : ℝ → ℝ}, ContDiff ℝ ⊤ f → f 0 = 0 → f 1 = 1 → (∀ x, 0 ≤ f x) → ∃ (n : ℕ) (x : ℝ), 0 < n ∧ f^[n] x < 0 ", "∀ {f : ℝ → ℝ} [inst : ContDiff ℝ 𝔠 f] (hf₀ : f 0 = 0) (hf₁ : f 1 = 1) (hf_pos : ∀ x, 0 ≤ f x),\n  ∃ n : ℕ, ∃ x : ℝ, 0 < n ∧ f^[n] x < 0 ", "∀ {f : ℝ → ℝ}, ContDiff ℝ ⊤ f → f 0 = 0 → f 1 = 1 → ∀ x : ℝ, 0 ≤ f x → ∃ n : ℕ, ∃ x : ℝ, n > 0 ∧ f^[n] x < 0 ", "∀ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n  ContDiff ℝ 𝕜∞ f → f 0 = 0 → f 1 = 1 → (∀ x, 0 ≤ f x) → ∃ n : ℕ, ∃ x : ℝ, 0 < n ∧ f^[n] x < 0 ", "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F},\n  ContDiff 𝕜 ℕ∞ f → f 0 = 0 → f 1 = 1 → (∀ x : 𝕜, 0 ≤ f x) → ∃ n : ℕ, ∃ x : 𝕜, f^[n] x < 0 ", "∀ {f : ℝ → ℝ}, ContDiff 𝕜 ℕ∞ f → f 0 = 0 → f 1 = 1 → (∀ x, 0 ≤ f x) → ∃ (n : ℕ) (x : ℝ), 0 < n ∧ f^[n] x < 0 "]}
{"docString": "Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic.", "prompts": "[{\"theorem\": \"∀ {n : ℕ}, orderOf (QuaternionGroup.a 1) = 2 * n\",\n  \"isProp\": true,\n  \"docString\": \"If `0 < n`, then `a 1` has order `2 * n`.\\n\"},\n {\"theorem\": \"∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"}]\n", "prompt_cons": "/-- If `0 < n`, then `a 1` has order `2 * n`. -/\ntheorem ∀ {n : ℕ}, orderOf (QuaternionGroup.a 1) = 2 * n :=\n\n/-- `a ^ 0 = 1` -/\ntheorem ∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Any point is a periodic point of period `0`. -/\ntheorem ∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x :=\n\n/-- Given a real number $a$, we define a sequence by $x_{0}=1$, $x_{1}=x_{2}=a$, and $x_{n+1}=2 x_{n} x_{n-1}-x_{n-2}$ for $n \\geq 2$. Prove that if $x_{n}=0$ for some $n$, then the sequence is periodic. -/\ntheorem", "choices": ["∀ {α : Type u_1} [self : LinearOrderedSemifield α] (a : α) (n : ℕ) (hn : n > 0) (hx : LinearOrderedSemifield.zpow (Int.ofNat n) a = 0),\n  Function.IsPeriodicPt (λ x : α, 2 * x * (LinearOrderedSemifield.zpow (Int.ofNat (Nat.pred n)) x) - LinearOrderedSemifield.zpow (Int.ofNat (Nat.pred (Nat.pred n))) x) n a ", "∀ {α : Type u_1} [self : LinearOrderedSemiring α] (a : α) (n : ℕ) (hn : n > 0),\n  (Function.IsPeriodicPt (fun x => 2 * x * (2 * x - 1) - (x - 2)) a n) →\n  ∀ (m : ℕ), Function.IsPeriodicPt (fun x => 2 * x * (2 * x - 1) - (x - 2)) a m ", "∀ {a : ℝ} (hn : ∃ n : ℕ, (λ (n : ℕ), nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * xn)) n)) n)) n)) n)) n)) n)) n)) n)) n)) n) 0),\n  ∀ (x : ℕ), Function.IsPeriodicPt (λ (n : ℕ), nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * (nat.rec 1 (nat.rec a (λ (n : ℕ) (xn : ℝ), 2 * xn * xn)) n)) n)) n)) n)) n)) n)) n)) n)) n) x ", "forall {a : ℝ} (n : ℕ) (x : ℕ → ℝ),\n  x 0 = 1 →\n  x 1 = a →\n  x 2 = a →\n  (∀ n, n ≥ 2 → x (n + 1) = 2 * x n * x (n - 1) - x (n - 2)) →\n  x n = 0 →\n  Function.IsPeriodicPt x n ", "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (a : α),\n  (∃ n : ℕ, a_nth_seq a n = 0) → Function.IsPeriodicSeq (a_nth_seq a) ", "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (a : α) (n : ℕ), \n  (∃ n, (Function.iterate (λ x, 2 * x * x - x) n 1) 0 = 0) → Function.IsPeriodicPt (λ x, 2 * x * x - x) n 0 ", "∀ {α : Type u_1} [self : LinearOrderedField α] (a : α) (n : ℕ) (hn : n > 0) (hx : LinearOrderedField.zpow (Int.ofNat n) a = 0),\n  Function.IsPeriodicPt (λ x, 2 * x * LinearOrderedField.zpow (Int.ofNat (n - 1)) a - LinearOrderedField.zpow (Int.ofNat (n - 2)) a) n (LinearOrderedField.zpow (Int.ofNat n) a) ", "∀ {α : Type u_1} [self : DivisionRing α] (a : α),\n  (∃ n : ℕ, n > 0 ∧ Pell.xn a n = 0) → (∀ n : ℕ, Pell.xn a (n + 2 * Pell.pellPeriod a) = Pell.xn a n) ", "∀ {α : Type u_1} [self : LinearOrderedSemifield α] (a : α) (n : ℕ) (hn : n > 0),\n  (λ (x : ℕ), if x = 0 then 1 else if x = 1 ∨ x = 2 then a else 2 * (LinearOrderedSemifield.zpow (Int.ofNat (x - 1)) a) * (LinearOrderedSemifield.zpow (Int.ofNat (x - 2)) a) - (LinearOrderedSemifield.zpow (Int.ofNat (x - 3)) a)) n = 0 →\n  Function.IsPeriodicPt (λ (x : ℕ), if x = 0 then 1 else if x = 1 ∨ x = 2 then a else 2 * (LinearOrderedSemifield.zpow (Int.ofNat (x - 1)) a) * (LinearOrderedSemifield.zpow (Int.ofNat (x - 2)) a) - (LinearOrderedSemifield.zpow (Int.ofNat (x - 3)) a)) n a ", "theorem periodic_sequence {a : ℝ} (n : ℕ) (hn : n > 0) (hxn : (2 * a * a - 1) ^ n = 0) :\n  ∀ k : ℕ, (2 * a * a - 1) ^ (n + k * n) = (2 * a * a - 1) ^ k "]}
{"docString": "Let", "prompts": "[{\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\\n  CategoryTheory.CategoryStruct.comp self.g₁ self.f₁ = CategoryTheory.CategoryStruct.comp self.g₂ self.f₂\",\n  \"isProp\": true,\n  \"docString\": \"The relation itself. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] (s : Finset α), BddBelow ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finset is bounded below. \"},\n {\"theorem\":\n  \"∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"The ideal is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (o : Part α), { Dom := o.Dom, get := fun h => Part.get o h } = o\",\n  \"isProp\": true,\n  \"docString\": \"`Part` eta expansion \"}]\n", "prompt_cons": "/-- The relation itself. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C} {J : CategoryTheory.GrothendieckTopology C}\n  {S : CategoryTheory.GrothendieckTopology.Cover J X} (self : CategoryTheory.GrothendieckTopology.Cover.Relation S),\n  CategoryTheory.CategoryStruct.comp self.g₁ self.f₁ = CategoryTheory.CategoryStruct.comp self.g₂ self.f₂ :=\n\n/-- A finset is bounded below. -/\ntheorem ∀ {α : Type u} [inst : SemilatticeInf α] [inst_1 : Nonempty α] (s : Finset α), BddBelow ↑s :=\n\n/-- The ideal is nonempty. -/\ntheorem ∀ {P : Type u_1} [inst : LE P] (self : Order.Ideal P), Set.Nonempty self.carrier :=\n\n/-- `Part` eta expansion -/\ntheorem ∀ {α : Type u_1} (o : Part α), { Dom := o.Dom, get := fun h => Part.get o h } = o :=\n\n/-- Let -/\ntheorem", "choices": ["∀ {α : Sort u} {p : α → Prop} (f : {a // p a}), (fun a => Subtype.mk a (f.property a)) f.val = f ", "∀ {α : Type u} [inst : PartialOrder α] {a b : α} (self : Order.Ideal.Relation a b), a ≤ b ", "forall {α : Type u} {β : α → Type v} {γ : Type w} [inst : DecidableEq α] [inst_1 : DecidableEq γ]\n  (f : Sigma β → γ) (x y : Sigma β),\n  f x = f y → (x.fst = y.fst → HEq x.snd y.snd) → x = Sigmap.mk x.fst x.snd → y = Sigmap.mk y.fst y.snd ", "∀ {α : Type u} [inst : HasLiftT α ℕ] {m₁ m₂ : α}, coe m₁ ≤ coe m₂ → m₁ ≤ m₂ ", "∀ {α : Type u} [inst : HasOne α] [inst_1 : HasMul α] (a b : α), Let a b = a * b ", "∀ {α : Type u} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ℝ≥0∞}\n  (hf : ∀ (n : ℕ), Measurable (f n)) (h_mono : ∀ (n : ℕ), Monotone (f n)),\n  Monotone (λ (n : ℕ) (a : α), MeasureTheory.lintegral μ (fun a_1 => f n a_1)) ", "∀ {α : Type u} (l₁ l₂ : List α) (a : α), (a :: l₁ ~ a :: l₂) ↔ (l₁ ~ l₂) ", "∀ {α : Type u} {a : α} (p : α → Prop) (x : ∃ h, p a), Classical.some x = a ", "∀ {α : Type u} {f : α → α} {x : α} (hx : ∃ n : ℕ, f^[n] x = x), ∃ n : ℕ, 0 < n ∧ f^[n] x = x ", "∀ {α : Type u_1} {f : α → α} {x : α}, (Function.iterate f (Nat.add 1 0) x) = f x "]}
{"docString": "Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {b : ℕ} {l : List ℕ}, (∀ (x : ℕ), x ∈ l → x < b + 2) → Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b + 2 is less than (b + 2)^n \"},\n {\"theorem\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem ∀ {b : ℕ} {l : List ℕ}, (∀ (x : ℕ), x ∈ l → x < b + 2) → Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem ∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Prove that there are unique positive integers $a, n$ such that $a^{n+1}-(a+1)^n=2001$. -/\ntheorem", "choices": ["unique_solution :\n  ∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "unique_solution_2001 : ∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "exists_unique_a_n : ∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "unique_sol_a_pow_n_plus_1_sub_a_plus_1_pow_n_eq_2001 : ∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "ExistsUnique λ a, ExistsUnique λ n, a ^ (n + 1) - (a + 1) ^ n = 2001 ", "exists_unique_a_n : ∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "exists_unique_a_n : ∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "ExistsUnique λ a : ℕ, ExistsUnique λ n : ℕ, a ^ (n + 1) - (a + 1)^n = 2001 ", "exists_unique_a_n : ∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 ", "∃! (a n : ℕ), a > 0 ∧ n > 0 ∧ a ^ (n + 1) - (a + 1) ^ n = 2001 "]}
{"docString": "Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$.", "prompts": "[{\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), deriv^[2] f x < 0) → StrictConcaveOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `ℝ`, and `f''` is strictly negative on `ℝ`,\\nthen `f` is strictly concave on `ℝ`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly negative, except at at most one point. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), 0 < deriv^[2] f x) → StrictConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous on `ℝ`, and `f''` is strictly positive on `ℝ`,\\nthen `f` is strictly convex on `ℝ`.\\nNote that we don't require twice differentiability explicitly as it is already implied by the second\\nderivative being strictly positive, except at at most one point. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"}]\n", "prompt_cons": "/-- If a function `f` is continuous on `ℝ`, and `f''` is strictly negative on `ℝ`,\nthen `f` is strictly concave on `ℝ`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly negative, except at at most one point. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), deriv^[2] f x < 0) → StrictConcaveOn ℝ Set.univ f :=\n\n/-- If a function `f` is continuous on `ℝ`, and `f''` is strictly positive on `ℝ`,\nthen `f` is strictly convex on `ℝ`.\nNote that we don't require twice differentiability explicitly as it is already implied by the second\nderivative being strictly positive, except at at most one point. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → (∀ (x : ℝ), 0 < deriv^[2] f x) → StrictConvexOn ℝ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let $f$ be a real function with a continuous third derivative such that $f(x), f^{\\prime}(x), f^{\\prime \\prime}(x), f^{\\prime \\prime \\prime}(x)$ are positive for all $x$. Suppose that $f^{\\prime \\prime \\prime}(x) \\leq f(x)$ for all $x$. Show that $f^{\\prime}(x)<2 f(x)$ for all $x$. -/\ntheorem", "choices": ["∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        (∀ (x : ℝ), 0 < f x ∧ 0 < deriv f x ∧ 0 < deriv^[2] f x ∧ 0 < deriv^[3] f x) →\n          (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n            ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        (∀ (x : ℝ), 0 < f x ∧ 0 < deriv f x ∧ 0 < deriv^[2] f x ∧ 0 < deriv^[3] f x) →\n          (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n            ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        Continuous (deriv^[3] f) →\n          (∀ (x : ℝ), 0 < f x) →\n            (∀ (x : ℝ), 0 < deriv f x) →\n              (∀ (x : ℝ), 0 < deriv^[2] f x) →\n                (∀ (x : ℝ), 0 < deriv^[3] f x) →\n                  (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n                    ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        Continuous (deriv^[3] f) →\n          (∀ (x : ℝ), 0 < f x) →\n            (∀ (x : ℝ), 0 < deriv f x) →\n              (∀ (x : ℝ), 0 < deriv^[2] f x) →\n                (∀ (x : ℝ), 0 < deriv^[3] f x) →\n                  (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n                    ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous (deriv^[3] f) →\n    (∀ (x : ℝ), 0 < f x ∧ 0 < deriv f x ∧ 0 < deriv^[2] f x ∧ deriv^[3] f x ≤ f x) →\n      ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        Continuous (deriv^[3] f) →\n          (∀ (x : ℝ), 0 < f x) →\n            (∀ (x : ℝ), 0 < deriv f x) →\n              (∀ (x : ℝ), 0 < deriv^[2] f x) →\n                (∀ (x : ℝ), 0 < deriv^[3] f x) →\n                  (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n                    ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        Continuous (deriv^[3] f) →\n          (∀ (x : ℝ), 0 < f x) →\n            (∀ (x : ℝ), 0 < deriv f x) →\n              (∀ (x : ℝ), 0 < deriv^[2] f x) →\n                (∀ (x : ℝ), 0 < deriv^[3] f x) →\n                  (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n                    ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    (∀ (x : ℝ), 0 < f x) →\n      (∀ (x : ℝ), 0 < deriv f x) →\n        (∀ (x : ℝ), 0 < deriv^[2] f x) →\n          (∀ (x : ℝ), 0 < deriv^[3] f x) →\n            (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n              ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        (∀ (x : ℝ), 0 < f x ∧ 0 < deriv f x ∧ 0 < deriv^[2] f x ∧ deriv^[3] f x ≤ f x) →\n          ∀ (x : ℝ), deriv f x < 2 * f x ", "∀ {f : ℝ → ℝ},\n  Continuous f →\n    Continuous (deriv f) →\n      Continuous (deriv^[2] f) →\n        (∀ (x : ℝ), 0 < f x) →\n          (∀ (x : ℝ), 0 < deriv f x) →\n            (∀ (x : ℝ), 0 < deriv^[2] f x) →\n              (∀ (x : ℝ), deriv^[3] f x ≤ f x) →\n                ∀ (x : ℝ), deriv f x < 2 * f x "]}
{"docString": "Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer.", "prompts": "[{\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal a b (-c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"}]\n", "prompt_cons": "/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal a b (-c) :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem ∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0 :=\n\n/-- Prove that, for any integers $a, b, c$, there exists a positive integer $n$ such that $\\sqrt{n^3+a n^2+b n+c}$ is not an integer. -/\ntheorem", "choices": ["∀ (a b c : ℤ), ∃ (n : ℕ), ¬IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬Int.IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬ IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬(is_square (n ^ 3 + a * n ^ 2 + b * n + c)) ", "∀ {a b c : ℤ}, ∃ (n : ℕ), ¬IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬(IsSquare (n ^ 3 + a * n ^ 2 + b * n + c)) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬(is_square (n ^ 3 + a * n ^ 2 + b * n + c)) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬IsSquare (n ^ 3 + a * n ^ 2 + b * n + c) ", "∀ (a b c : ℤ), ∃ (n : ℕ), ¬(Int.sqrt (n ^ 3 + a * n ^ 2 + b * n + c) * Int.sqrt (n ^ 3 + a * n ^ 2 + b * n + c) = n ^ 3 + a * n ^ 2 + b * n + c) "]}
{"docString": "Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U Z : Set α},\\n  IsPreirreducible Z → Set.Nonempty U → IsOpen U → U ⊆ S → S ⊆ Z → IsIrreducible S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `∅ ≠ U ⊆ S ⊆ Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"}]\n", "prompt_cons": "/-- If `∅ ≠ U ⊆ S ⊆ Z` such that `U` is open and `Z` is preirreducible, then `S` is irreducible. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U Z : Set α},\n  IsPreirreducible Z → Set.Nonempty U → IsOpen U → U ⊆ S → S ⊆ Z → IsIrreducible S :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- The complement of a closed set is an open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n\n/-- Prove that a set $U \\subset M$ is open if and only if none of its points are limits of its complement. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ (∀ (x : α), x ∈ U → ¬ ClusterPt x (Filter.principal Uᶜ)) ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ ∀ (x : α), x ∈ U → ∃ V, IsOpen V ∧ x ∈ V ∧ V ⊆ Uᶜᶜ ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ (∀ x : α, x ∈ U → ¬HasMem.Mem x (Closure (Uᶜ))) ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ (∀ x : α, x ∈ U → ¬ nhds x ⊓ Filter.principal Uᶜ ≠ ⊥) ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ ∀ (x : α), x ∈ U → ¬HasMem.Mem x (Set.Frontier Uᶜ) ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ (∀ (x : α), x ∈ U → ¬ClusterPt x (Uᶜ)) ", "∀ {α : Type u} [inst : TopologicalSpace α], (U : Set α),\n  IsOpen U ↔ (∀ x : α, x ∈ U → ¬IsLimitPoint (Uᶜ) x) ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ (∀ (x : α), x ∈ U → ¬ClusterPt x (Uᶜ)) ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ ∀ (x : α), x ∈ U → ¬ Filter.Tendsto id (nhds x) (Filter.principal Uᶜ) ", "∀ {α : Type u} [inst : TopologicalSpace α] {U : Set α},\n  IsOpen U ↔ (∀ x : α, x ∈ U → ¬filter.is_limit (nhds.without U x)) "]}
{"docString": "Show that every subset of $\\mathbb{N}$ is clopen.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"}]\n", "prompt_cons": "/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Show that every subset of $\\mathbb{N}$ is clopen. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [inst2 : ℕ → α] {s : Set α},\n  (∀ n : ℕ, inst2 n ∈ s ∨ inst2 n ∉ s) → IsClopen s ", "∀ {α : Type u} [inst : TopologicalSpace α] [Nonempty α] [LocallyFiniteOrder α] {s : Set α},\n  (∀ n : α, n ∈ s ↔ n ∈ (Set.Iic n)) → IsClopen s ", "forall {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (n : ℕ), IsClopen (s n)) → (∀ (t : Set α), t ⊆ s → IsClopen t) ", "∀ {α : Type u} [inst : DiscreteTopology α] {s : Set α}, IsClopen s ", "∀ {α : Type u} [inst : TopologicalSpace α] [preorder α] [inst2 : OrderTopology α] {s : Set α},\n  (∀ x y z : α, x ∈ s → y ∈ s → z ∈ s → x < z → y < z → x < y) → IsClopen s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst : DiscreteTopology α] (s : Set α),\n  IsClopen s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst2 : DiscreteTopology α] {s : Set α}, s ⊆ SetOf ℕ → IsClopen s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst2 : DiscreteTopology α] {s : Set α}, s ⊆ ℕ → IsClopen s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst2 : DiscreteTopology α] {s : Set ℕ},\n  IsClopen s ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst2 : DiscreteTopologicalSpace α] {s : Set α}, IsClopen s "]}
{"docString": "Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Add G] [self : UniqueSums G] {A B : Finset G},\\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueAdd A B a0 b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\\n`UniqueAdd A B a0 b0` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\\nedistance. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Mul G] [self : UniqueProds G] {A B : Finset G},\\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueMul A B a0 b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\\n`UniqueMul A B a0 b0` \"}]\n", "prompt_cons": "/-- For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\n`UniqueAdd A B a0 b0` -/\ntheorem ∀ {G : Type u_1} [inst : Add G] [self : UniqueSums G] {A B : Finset G},\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueAdd A B a0 b0 :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- If two sets are nonempty and bounded in a metric space, they are at finite Hausdorff\nedistance. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Set.Nonempty s → Set.Nonempty t → Metric.Bounded s → Metric.Bounded t → EMetric.hausdorffEdist s t ≠ ⊤ :=\n\n/-- For `A B` two nonempty finite sets, there always exist `a0 ∈ A, b0 ∈ B` such that\n`UniqueMul A B a0 b0` -/\ntheorem ∀ {G : Type u_1} [inst : Mul G] [self : UniqueProds G] {A B : Finset G},\n  Finset.Nonempty A → Finset.Nonempty B → ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ UniqueMul A B a0 b0 :=\n\n/-- Assume that $A, B$ are compact, disjoint, nonempty subsets of $M$. Prove that there are $a_0 \\in A$ and $b_0 \\in B$ such that for all $a \\in A$ and $b \\in B$ we have $d(a_0, b_0) \\leq d(a, b)$. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : PseudoMetricSpace α] {A B : Set α} [inst_1 : CompactSpace A] [inst_2 : CompactSpace B],\n  Set.Nonempty A → Set.Nonempty B → Disjoint A B →\n  ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, dist a0 b0 ≤ dist a b ", "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : CompactSpace α] {A B : Set α},\n  Set.Nonempty A → Set.Nonempty B → IsCompact A → IsCompact B → Disjoint A B →\n  ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ ∀ a ∈ A, ∀ b ∈ B, Metric.dist a0 b0 ≤ Metric.dist a b ", "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : CompactSpace α] {A B : Set α},\n  Set.Nonempty A → Set.Nonempty B → A ∩ B = ∅ →\n  ∃ a0 b0, a0 ∈ A ∧ b0 ∈ B ∧ ∀ a ∈ A, ∀ b ∈ B, Metric.dist a0 b0 ≤ Metric.dist a b ", "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : CompactSpace α] {A B : Set α},\n  Set.Nonempty A → Set.Nonempty B → IsCompact A → IsCompact B → Disjoint A B →\n  ∃ a0, a0 ∈ A ∧ ∃ b0, b0 ∈ B ∧ ∀ a, a ∈ A → ∀ b, b ∈ B → Metric.dist a0 b0 ≤ Metric.dist a b ", "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : CompactSpace α] {A B : Set α},\n  Set.Nonempty A → Set.Nonempty B → Disjoint A B → ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, Metric.dist a0 b0 ≤ Metric.dist a b ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α}, Compact A → Compact B → Set.Nonempty A → Set.Nonempty B → Disjoint A B →\n  ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, dist a0 b0 ≤ dist a b ", "∀ {α : Type u} [inst : MetricSpace α] [self : CompactSpace α] {A B : Set α},\n  Set.Nonempty A → Set.Nonempty B → Disjoint A B → ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, dist a0 b0 ≤ dist a b ", "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : CompactSpace α] {A B : Set α},\n  Set.Nonempty A → Set.Nonempty B → IsCompact A → IsCompact B → Disjoint A B →\n  ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, dist a0 b0 ≤ dist a b ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α} [inst_1 : CompactSpace A] [inst_2 : CompactSpace B],\n  Set.Nonempty A → Set.Nonempty B → Disjoint A B → ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, Metric.dist a0 b0 ≤ Metric.dist a b ", "∀ {α : Type u} [inst : MetricSpace α] {A B : Set α},\n  Compact A → Compact B → Set.Nonempty A → Set.Nonempty B → Disjoint A B →\n  ∃ a0 ∈ A, ∃ b0 ∈ B, ∀ a ∈ A, ∀ b ∈ B, Metric.dist a0 b0 ≤ Metric.dist a b "]}
{"docString": "Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `ℕ`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"}]\n", "prompt_cons": "/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `ℕ`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- Give a direct proof that the nested decreasing intersection of nonempty covering compact sets is nonempty. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "forall {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) ", "forall {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) "]}
{"docString": "Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.", "prompts": "[{\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. \"}]\n", "prompt_cons": "/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜₂ : Type u_3} {E : Type u_4} {F : Type u_5} {𝓕 : Type u_1} [inst : SeminormedAddCommGroup E]\n  [inst_1 : SeminormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : SemilinearMapClass 𝓕 σ₁₂ E F]\n  (f : 𝓕), Continuous ↑f → ∀ {x : E}, ‖x‖ = 0 → ‖↑f x‖ = 0 :=\n\n/-- Assume that $f \\colon \\mathbb{R} \\rightarrow \\mathbb{R}$ satisfies $|f(t)-f(x)| \\leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant. -/\ntheorem", "choices": ["∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℝ F] {f : E → F}, (∀ t x : E, ∥f t - f x∥ ≤ ∥t - x∥^2) → ∀ (z w : E), f z = f w ", "∀ {f : ℝ → ℝ}, (∀ t x : ℝ, abs (f t - f x) ≤ abs (t - x)^2) → ∀ (z w : ℝ), f z = f w ", "∀ {f : ℝ → ℝ}, (∀ (t x : ℝ), abs (f t - f x) ≤ abs (t - x) ^ 2) → ∃ c, ∀ (x : ℝ), f x = c ", "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℝ F] {f : E → F}, (∀ t x : E, ∥f t - f x∥ ≤ ∥t - x∥^2) → ∀ (z w : E), f z = f w ", "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℝ F] {f : E → F}, (∀ t x : E, ∥f t - f x∥ ≤ ∥t - x∥^2) → ∀ (z w : E), f z = f w ", "∀ {f : ℝ → ℝ}, (∀ (t x : ℝ), abs (f t - f x) ≤ abs (t - x)^2) → ∃ c, ∀ (x : ℝ), f x = c ", "∀ {𝕜 : Type u_2} [inst : LinearOrderedField 𝕜] [inst_1 : NontriviallyNormedField 𝕜] {E : Type u_4} [inst_2 : NormedAddCommGroup E]\n  [inst_3 : NormedSpace 𝕜 E] {f : 𝕜 → E}, (∀ (t x : 𝕜), ∥f t - f x∥ ≤ ∥t - x∥ ^ 2) → ∀ (x y : 𝕜), f x = f y ", "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℝ F] {f : E → F}, (∀ t x : E, ∥f t - f x∥ ≤ ∥t - x∥^2) → ∀ (z w : E), f z = f w ", "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℝ F] {f : E → F}, (∀ t x : E, ∥f t - f x∥ ≤ ∥t - x∥^2) → ∀ (z w : E), f z = f w ", "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℝ F] {f : E → F}, (∀ t x : E, ∥f t - f x∥ ≤ ∥t - x∥^2) → ∀ (z w : E), f z = f w "]}
{"docString": "Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$.", "prompts": "[{\"theorem\": \"∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\": \"∀ {p : ℝ}, (Summable fun n => (↑n ^ p)⁻¹) ↔ 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"∀ {x : ℝ}, |x| < 1 → HasSum (fun n => x ^ (n + 1) / (↑n + 1)) (-Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\": \"Power series expansion of the logarithm around `1`. \"}]\n", "prompt_cons": "/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem ∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\nif and only if `1 < p`. -/\ntheorem ∀ {p : ℝ}, (Summable fun n => (↑n ^ p)⁻¹) ↔ 1 < p :=\n\n/-- Power series expansion of the logarithm around `1`. -/\ntheorem ∀ {x : ℝ}, |x| < 1 → HasSum (fun n => x ^ (n + 1) / (↑n + 1)) (-Real.log (1 - x)) :=\n\n/-- Prove that $\\sum 1/k(\\log(k))^p$ converges when $p > 1$. -/\ntheorem", "choices": ["∀ {p : ℝ}, (Summable fun k => (↑k * Real.log ↑k ^ p)⁻¹) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => 1 / (↑k * (Real.log ↑k) ^ p)) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => 1 / (↑k * (Real.log ↑k) ^ p)) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => (↑k * Real.log (↑k) ^ p)⁻¹) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => (↑k * Real.log (↑k) ^ p)⁻¹) ↔ 1 < p ", "forall {p : ℝ}, (Summable fun k => 1 / ↑k * (Real.log ↑k) ^ p) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => 1 / (↑k * (Real.log ↑k) ^ p)) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => (↑k * Real.log (↑k) ^ p)⁻¹) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => 1 / (↑k * (Real.log ↑k) ^ p)) ↔ 1 < p ", "∀ {p : ℝ}, (Summable fun k => (↑k * Real.log ↑k ^ p)⁻¹) ↔ 1 < p "]}
{"docString": "A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"}]\n", "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A continuous, strictly increasing function $\\mu \\colon (0, \\infty) \\rightarrow (0, \\infty)$ is a modulus of continuity if $\\mu(s) \\rightarrow 0$ as $s \\rightarrow 0$. A function $f \\colon [a, b] \\rightarrow \\mathbb{R}$ has modulus of continuity $\\mu$ if $|f(s) - f(t)| \\leq \\mu(|s - t|)$ for all $s, t \\in [a, b]$. Prove that a function is uniformly continuous if and only if it has a modulus of continuity. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : α → β} [inst_5 : UniformSpace β],\n  (∃ (μ : ℝ → ℝ), Continuous μ ∧ StrictMono μ ∧ Limit (μ ∘ Real.toNnreal) 0 (nhds 0)) ↔ UniformContinuous f ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : α → β} {a b : α},\n  (∀ (s t : α), a ≤ s → b ≥ s → a ≤ t → b ≥ t → abs (f s - f t) ≤ ∃ (μ : ℝ → ℝ), StrictMono μ ∧ Continuous μ ∧\n    ∀ (ε : ℝ), 0 < ε → ∃ (δ : ℝ), 0 < δ ∧ ∀ (s : ℝ), 0 < s → s < δ → μ s < ε) ↔\n  UniformContinuousOn f (Set.Icc a b) ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β} {μ : α → α},\n  ContinuousOn f K → Tendsto μ (nhds 0) (nhds 0) → (∀ s t ∈ K, abs (f s - f t) ≤ μ (abs (s - t))) → UniformContinuousOn f K ", "forall {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  (UniformContinuous f ↔ (∃ (μ : (0, ⊤) → (0, ⊤)), StrictMono μ ∧ Continuous μ ∧ Filter.Tendsto μ (𝓝 0) (𝓝 0) ∧\n    ∀ (s t : β), s ∈ K → t ∈ K → abs (f s - f t) ≤ μ (abs (s - t)))) ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β} {μ : α → α},\n  ContinuousOn f K → (∀ s t ∈ K, abs (f s - f t) ≤ μ (abs (s - t))) → Tendsto μ (𝓝 0) (𝓝 0) → UniformContinuousOn f K ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  (∃ (μ : α → α), Continuous μ ∧ StrictMono μ ∧ (∀ (s : α), 0 < s → 0 < μ s) ∧ Filter.Tendsto μ (𝓝 0) (𝓝 0) ∧\n    ∀ (s t : β), s ∈ K → t ∈ K → abs (f s - f t) ≤ μ (abs (s - t))) ↔ UniformContinuousOn f K ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β} {μ : ℝ → ℝ},\n  ContinuousOn f K ∧ (∀ s t ∈ K, abs (f s - f t) ≤ μ (abs (s - t))) ∧\n  (∀ ⦃s : ℝ⦄, s > 0 → ∃ δ > 0, ∀ ⦃x : ℝ⦄, x ≠ 0 → abs x < δ → abs (μ x) < s) ↔ UniformContinuousOn f K ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : TopologicalSpace α] [inst_3 : OrderTopology α]\n  [inst_4 : TopologicalSpace β] [inst_5 : LinearOrder β] [inst_6 : OrderClosedTopology β] {f : α → β} {a b : α},\n  UniformContinuousOn f (Set.Interval a b) ↔ ∃ (μ : α → α), StrictMono μ ∧ Continuous μ ∧ Filter.Tendsto μ (𝓝 0) (𝓝 0) ∧ ∀ (s t : α), s ∈ Set.Interval a b → t ∈ Set.Interval a b → abs (f s - f t) ≤ μ (abs (s - t)) ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  (UniformContinuous f ↔ (∃ (μ : α → α), Continuous μ ∧ StrictMono μ ∧ ∀ᶠ (s : α) in 𝓝 0, μ s = 0 ∧ ∀ (s t : β), (s, t) ∈ K ×ˢ K → abs (f s - f t) ≤ μ (abs (s - t)))) ", "∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : LinearOrderedAddCommGroup β] [inst_5 : TopologicalAddGroup β]\n  {f : α → β} {a b : α} (hab : a < b),\n  (∃ (μ : α → α), (∀ (s : α), 0 < s → 0 < μ s) ∧ Continuous (λ (s : α), μ s) ∧ Filter.Tendsto μ (𝓝 0) (𝓝 0) ∧\n    ∀ (s t : α), a ≤ s → s ≤ t → t ≤ b → abs (f s - f t) ≤ μ (abs (s - t))) ↔\n  UniformContinuousOn f (Set.Icc a b) "]}
{"docString": "If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"}]\n", "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- If $G$ is a finite group of even order, show that there must be an element $a \\neq e$ such that $a=a^{-1}$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (2 ∣ Fintype.card G) → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (2 ∣ Fintype.card G) → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Even (Fintype.card G) → ∃ a ≠ 1, a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], 2 ∣ Fintype.card G → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], 2 ∣ Fintype.card G → ∃ a : G, a ≠ 1 ∧ a * a = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ a : G, a ≠ 1 ∧ a * a = 1 "]}
{"docString": "If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$.", "prompts": "[{\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n", "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If $G$ is a finite group, prove that, given $a \\in G$, there is a positive integer $n$, depending on $a$, such that $a^n = e$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n : ℕ, n > 0 ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∀ (a : G), ∃ n : ℕ, n > 0 ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ n : ℕ, ∀ (a : G), a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n : ℕ, n > 0 ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n, 0 < n ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n, 0 < n ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n : ℕ, n > 0 ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n : ℕ, n > 0 ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (a : G), ∃ n : ℕ, n > 0 ∧ a ^ n = 1 ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ n, ∀ a : G, a ^ n = 1 "]}
{"docString": "If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian.", "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.numerators g n = ppredA →\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"}]\n", "prompt_cons": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.numerators g n = ppredA →\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- If $G$ is a group in which $(a b)^{i}=a^{i} b^{i}$ for three consecutive integers $i$, prove that $G$ is abelian. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] {a b : G}, (∀ i : ℤ, i ∈ [(-1 : ℤ), 0, 1] → (a * b)^i = a^i * b^i) → ∀ x y : G, x * y = y * x ", "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  (∀ i : ℕ, i < 3 → (a * b) ^ i = a ^ i * b ^ i) →\n    ∀ x y : G, x * y = y * x ", "∀ {G : Type u_1} [inst : Group G] {a b : G},\n    (a * b) * (a * b) * (a * b) = a * a * a * (b * b * b) →\n      (a * b) * (a * b) = a * a * (b * b) →\n        (a * b) = a * b →\n          ∀ (x y : G), x * y = y * x ", "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  (∀ i ∈ [0, 1, 2], (a * b) ^ i = a ^ i * b ^ i) → IsCommutative G (*) ", "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  ((a * b) ^ 1 = a ^ 1 * b ^ 1) →\n  ((a * b) ^ 2 = a ^ 2 * b ^ 2) →\n  ((a * b) ^ 3 = a ^ 3 * b ^ 3) →\n  ∀ x y : G, x * y = y * x ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, (∀ i ∈ [(-1 : ℤ), (0 : ℤ), (1 : ℤ)], ((a * b) ^ i) = (a ^ i) * (b ^ i)) → Commute a b ", "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  (∀ i : ℤ, i ∈ [0, 1, 2] → (a * b)^i = a^i * b^i) →\n    ∀ x y : G, x * y = y * x ", "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  (∀ i, i ∈ [0, 1, 2], a * b * a⁻¹ * b⁻¹ = 1) → IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, (∀ i, i ∈ [(1 : ℤ), 2, 3] → (a * b) ^ i = a ^ i * b ^ i) → Commute a b ", "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  (∀ i : ℤ, i = -1 ∨ i = 0 ∨ i = 1 → (a * b) ^ i = a ^ i * b ^ i) →\n  ∀ (x y : G), x * y = y * x "]}
{"docString": "Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"}]\n", "prompt_cons": "/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- Let $G$ be a group in which $(a b)^{n}=a^{n} b^{n}$ for some fixed integer $n>1$ for all $a, b \\in G$. For all $a, b \\in G$, prove that $\\left(a b a^{-1} b^{-1}\\right)^{n(n-1)}=e$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [group G] (n : ℕ) (hn : n > 1)\n  (h : ∀ (a b : G), (a * b) ^ n = a ^ n * b ^ n),\n  ∀ (a b : G), ((a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1))) = 1 ", "forall {G : Type u_1} [inst : Group G] (n : ℕ) (h : ∀ a b : G, (a * b) ^ n = a ^ n * b ^ n) (a b : G),\n  (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 ", "∀ {G : Type u_1} [inst : Group G] (n : ℕ) (hn : n > 1) (a b : G),\n  (a * b) ^ n = a ^ n * b ^ n → (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 ", "∀ {G : Type u_1} [inst : Group G] (a b : G) (n : ℕ) (h : ∀ x y : G, (x * y) ^ n = x ^ n * y ^ n) (hn : 1 < n),\n  (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 ", "forall {G : Type u_1} [group G] (n : ℕ) (h : ∀ (a b : G), (a * b) ^ n = a ^ n * b ^ n)\n  (a b : G), (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 ", "forall {G : Type u} [group G] (n : ℕ) (h : ∀ a b : G, (a * b) ^ n = a ^ n * b ^ n) (a b : G),\n  (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 ", "forall {G : Type u_1} [inst : Group G] (n : ℕ) (hn : n > 1)\n  (h : ∀ (a b : G), (a * b) ^ n = a ^ n * b ^ n)\n  (a b : G), (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 ", "∀ {G : Type u_1} [group G] (n : ℕ) (h : ∀ a b : G, (a * b)^n = a^n * b^n) (a b : G),\n  (a * b * a⁻¹ * b⁻¹)^(n * (n - 1)) = 1 ", "∀ {G : Type u_1} [self : Group G] (n : ℕ) (hn : n > 1) (a b : G),\n  (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 ", "∀ {G : Type u_1} [group G] (n : ℕ) (hn : 1 < n) (a b : G),\n  (a * b * a⁻¹ * b⁻¹) ^ (n * (n - 1)) = 1 "]}
{"docString": "If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If a group $G$ has no proper subgroups, prove that $G$ is cyclic of order $p$, where $p$ is a prime number. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ H : Subgroup G, H = ⊥ ∨ H = ⊤) → Fintype.card G = p → IsCyclic G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], \n  (∀ H : Subgroup G, H = ⊥ ∨ H = ⊤) → Fintype.card G = p → IsCyclic G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (Fintype.card G = p ∧ ∀ H : Subgroup G, H = ⊥ ∨ H = ⊤) → IsCyclic G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ H : Subgroup G, H ≠ ⊥ → H = ⊤) → Fintype.card G = p → IsCyclic G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ H : Subgroup G, H = ⊥ ∨ H = ⊤) → Fintype.card G = p → IsCyclic G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ H : Subgroup G, H = ⊥ ∨ G = H) → Fintype.card G = p → IsCyclic G ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ H : Subgroup α, H = ⊥ ∨ H = ⊤) → Fintype.card α = p → IsCyclic α ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ (H : Subgroup G), H ≠ ⊥ → G ≤ H) → Fintype.card G = p → IsCyclic G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  (∀ H : Subgroup G, H = ⊥ ∨ H = ⊤) → Fintype.card G = p → IsCyclic G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], \n  (∀ (H : Subgroup G), H = ⊥ ∨ H = ⊤) → Fintype.card G = p → IsCyclic G "]}
{"docString": "Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"}]\n", "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- Let $G$ be a group such that all subgroups of $G$ are normal in $G$. If $a, b \\in G$, prove that $ba = a^jb$ for some $j$. -/\ntheorem", "choices": ["forall {G : Type u_1} [inst : Group G] (a b : G), AllSubgroupsNormal G → ∃ (j : ℤ), b * a = a ^ j * b ", "∀ {G : Type u_1} [inst : Group G] (a b : G), AllSubgroupsNormal G → ∃ (j : ℤ), b * a = a ^ j * b ", "∀ {G : Type u_1} [inst : Group G] (a b : G), AllSubgroupsNormal G → ∃ (j : ℤ), b * a = a ^ j * b ", "forall {G : Type u_1} [inst : Group G] (a b : G), NormalSubgroups G → ∃ (j : ℤ), b * a = a ^ j * b ", "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  (∀ (H : Subgroup G), Subgroup.Normal H) → ∃ (j : ℤ), b * a = a ^ j * b ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), (∀ H' : Subgroup G, Subgroup.Normal H') → ∀ (a b : G), ∃ (j : ℤ), b * a = a^j * b ", "∀ {G : Type u_1} [inst : Group G] (a b : G), (∀ (H : Subgroup G), Subgroup.Normal H) → ∃ (j : ℤ), b * a = a ^ j * b ", "∀ {G : Type u_1} [inst : Group G] (a b : G), (∀ (H : Subgroup G), Subgroup.Normal H) → ∃ (j : ℤ), b * a = a ^ j * b ", "∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Subgroup.Normal H) → ∀ (a b : G), ∃ (j : ℕ), b * a = a ^ j * b ", "∀ {G : Type u_1} [inst : Group G] (a b : G), (∀ (H : Subgroup G), Subgroup.Normal H) → ∃ (j : ℤ), b * a = a ^ j * b "]}
{"docString": "Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- Suppose that $G$ is an abelian group of order $p^nm$ where $p \\nmid m$ is a prime.  If $H$ is a subgroup of $G$ of order $p^n$, prove that $H$ is a characteristic subgroup of $G$. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n m : ℕ} [hp : Fact (Nat.Prime p)] [AddCommGroup G],\n  Fintype.card G = p ^ n * m → Nat.Coprime p m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → Subgroup.char_sub H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [inst_2 : AddCommGroup G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m → Nat.Coprime p m →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → Subgroup.IsCompl (Subgroup.normalizer H) H ", "∀ {G : Type u} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m → Nat.Coprime p m →\n    ∀ (H : AddSubgroup G), Fintype.card { x // x ∈ H } = p ^ n → AddSubgroup.IsCharSubgroup H ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m → Nat.Coprime p m →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → Subgroup.IsChar H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [inst_2 : AddCommGroup G] {p n m : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m → Nat.Coprime p m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → H.charact_of_order_pn ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [_hp : Fact (Nat.Prime p)] (H : Subgroup G) (m : ℕ),\n  Fintype.card G = p ^ n * m → Nat.Coprime p m → Fintype.card { x // x ∈ H } = p ^ n → Subgroup.IsChar H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [inst_2 : AddCommGroup G] (p : ℕ) {n m : ℕ} [inst_3 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m → Nat.Coprime p m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → Subgroup.IsChar H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p n m : ℕ) [inst_2 : Fact (Nat.Prime p)] (H : Subgroup G),\n  Fintype.card G = p ^ n * m → Nat.Coprime p m → Fintype.card { x // x ∈ H } = p ^ n → Subgroup.IsCharSubgroup H ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] [inst_2 : AddCommGroup G] {p n m : ℕ} [inst_3 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n * m → ¬p ∣ m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → Subgroup.IsCharSubgroup H ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n m : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  IsAddGroup G →\n  Fintype.card G = p ^ n * m →\n  Nat.Coprime p m →\n  Fintype.card { x // x ∈ H } = p ^ n →\n  Subgroup.IsCharSubgroup H "]}
{"docString": "Prove that a group of order 9 must be abelian.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x\",\n  \"isProp\": true,\n  \"docString\": \"This is [bourbaki2007][] $9 Lemma 3. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"}]\n", "prompt_cons": "/-- This is [bourbaki2007][] $9 Lemma 3. -/\ntheorem ∀ {R : Type u1} [inst : CommRing R] {M : Type u2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q Q' Q'' : QuadraticForm R M} {B B' : BilinForm R M} (h : BilinForm.toQuadraticForm B = Q' - Q)\n  (h' : BilinForm.toQuadraticForm B' = Q'' - Q') (x : CliffordAlgebra Q),\n  ↑(CliffordAlgebra.changeForm h') (↑(CliffordAlgebra.changeForm h) x) =\n    ↑(CliffordAlgebra.changeForm (_ : BilinForm.toQuadraticForm (B + B') = Q'' - Q)) x :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- Prove that a group of order 9 must be abelian. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Fintype G] [inst_1 : Group G], Fintype.card G = 9 → Group.IsAbelian G ", "∀ {G : Type u_1} [inst : Fintype G] [inst_1 : Group G], Fintype.card G = 9 → Group.IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 9 → Group.IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] [fintypeG : Fintype G] (h : Fintype.card G = 9),\n  IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [F : Fintype G], Fintype.card G = 9 → Group.IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] (h : Fintype.card G = 9), IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [fintype G], fintype.card G = 9 → IsCommutativeGroup G ", "∀ {G : Type u_1} [inst : Group G] [fintype: Fintype G], Fintype.card G = 9 → Group.IsAbelian G ", "∀ {G : Type u_1} [inst : Fintype G] [inst_1 : Group G], Fintype.card G = 9 → Group.IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] (h: Fintype.card G = 9), Group.IsAbelian G "]}
{"docString": "Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.IsInvInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any Haar measure is invariant under inversion in an abelian group. \"}]\n", "prompt_cons": "/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Any Haar measure is invariant under inversion in an abelian group. -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G] [inst_3 : T2Space G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  (μ : MeasureTheory.Measure G) [inst_7 : MeasureTheory.Measure.IsHaarMeasure μ] [inst_8 : LocallyCompactSpace G],\n  MeasureTheory.Measure.IsInvInvariant μ :=\n\n/-- Let $G$ be a finite group and $\\varphi$ an automorphism of $G$ such that $\\varphi(x) = x^{-1}$ for more than three-fourths of the elements of $G$. Prove that $\\varphi(y) = y^{-1}$ for all $y \\in G$, and so $G$ is abelian. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (ϕ : Aut G),\n  (Fintype.card (Subtype {x // ϕ x = x⁻¹}) : ℝ) / Fintype.card G > 3 / 4 →\n    ∀ (y : G), ϕ y = y⁻¹ ", "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  let φ ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (ϕ : G →* G), ∀ (x : G), ϕ x = x⁻¹ ∧ Fintype.card { y // ϕ y = y⁻¹ } > (3 / 4) * Fintype.card G) →\n  ∀ (y : G), y⁻¹ = y⁻¹ ∧ G.is_abelian ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (φ : G →* G), φ.is_involution ∧ Fintype.card {x // φ x = x⁻¹} > 3 * Fintype.card G / 4) →\n    ∀ (y : G), (∃ (ψ : G →* G), ψ.is_involution ∧ ψ y = y⁻¹) ∧ G.is_abelian ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (φ : G →* G), ∀ x, x⁻¹ = φ x → Fintype.card {y // y⁻¹ = φ y} > (Fintype.card G * 3) / 4) →\n  ∀ (y : G), y⁻¹ = (φ y) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], \n  (∃ (ϕ : Aut G), (∀ y : G, ϕ y = y⁻¹) ∧ (Fintype.card { x // ϕ x = x⁻¹ } > (3 * Fintype.card G) / 4)) →\n    ∀ y : G, ϕ y = y⁻¹ ∧ IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (φ : G ≃* G), ∀ (x : G), φ x = x⁻¹ ∧ Fintype.card {x // φ x = x⁻¹} > (3 * Fintype.card G) / 4) →\n    (∀ (y : G), φ y = y⁻¹) ∧ ∀ (a b : G), a * b = b * a ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (ϕ : G ≃* G), ∀ (x : G), (ϕ x = x⁻¹ ∧ ϕ x ≠ x⁻¹) → Fintype.card G * 3 ≤ 4 * Fintype.card { x // ϕ x = x⁻¹ ∧ ϕ x ≠ x⁻¹ }) →\n    ∀ (y : G), (∃ (ϕ : G ≃* G), ϕ y = y⁻¹) ∧ G → CommGroup G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (φ : Aut G), ∀ x : G, φ x = x⁻¹ ∧ Fintype.card {x // φ x = x⁻¹} > (3 * Fintype.card G) / 4) →\n    (∀ y : G, y⁻¹ = y⁻¹ ∧ G.is_abelian) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ (φ : G ≃* G), ∀ x : G, φ x = x⁻¹) → G_is_abelian G "]}
{"docString": "If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$.", "prompts": "[{\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\\na homomorphism from the whole of `G` to `F`. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is an isometry. \"}]\n", "prompt_cons": "/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- The natural homomorphism from a monoid to its quotient by a congruence relation is\nsurjective. -/\ntheorem ∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ↑(Con.mk' c) :=\n\n/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem ∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F) :=\n\n/-- The ring homomorphism is an isometry. -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖↑σ x‖ = ‖x‖ :=\n\n/-- If $\\varphi$ is a homomorphism of $G$ onto $G'$ and $N \\triangleleft G$, show that $\\varphi(N) \\triangleleft G'$. -/\ntheorem", "choices": ["∀ {G : Type u} {G' : Type v} [inst : Group G] [inst_1 : Group G'] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  {σ : G →* G'} [self : MonoidHomSurjective σ], Subgroup.Normal (Subgroup.map σ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  {φ : G →* G'} [self : Function.Surjective φ], Subgroup.Normal (Subgroup.map φ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {N : Subgroup G} [Normal N] {φ : G →* G'}\n  [self : Function.Surjective φ], Normal (Subgroup.map φ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {N : Subgroup G} [inst_2 : Subgroup.Normal N]\n  {φ : G →* G'} (hφ : Function.Surjective ↑φ), Subgroup.Normal (Subgroup.map φ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'} [self : Function.Surjective φ]\n  {N : Subgroup G} [self_1 : Subgroup.Normal N], Subgroup.Normal (Subgroup.map φ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {N : Subgroup G} [self : Normal N] {φ : G →* G'}\n  [self_1 : Function.Surjective φ], Subgroup.Normal (Subgroup.map φ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {N : Subgroup G} [self : Subgroup.Normal N]\n  {ϕ : G →* G'}, Subgroup.Normal (Subgroup.map ϕ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {φ : G →* G'} [self : Function.Surjective φ]\n  {N : Subgroup G} [self_1 : Subgroup.Normal N], Subgroup.Normal (Subgroup.map φ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {N : Subgroup.Normal G} {φ : G →* G'}\n  [self : Function.Surjective ↑φ], Subgroup.Normal (Subgroup.map φ N) ", "∀ {G : Type u_1} {G' : Type u_2} [inst : Group G] [inst_1 : Group G'] {ϕ : G →* G'} [self : Function.Surjective ϕ]\n  {N : Subgroup G} [normal : Subgroup.Normal N], Subgroup.Normal (Subgroup.map ϕ N) "]}
{"docString": "Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"}]\n", "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- Prove that if $p > q$ are two primes such that $q \\mid p - 1$, then any two nonabelian groups of order $pq$ are isomorphic. -/\ntheorem", "choices": ["∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q → q ∣ p - 1 →\n    Nonabelian G → Fintype.card G = p * q →\n      Nonabelian G₂ → Fintype.card G₂ = p * q →\n        Nonempty (G ≃* G₂) ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂] [inst_1 : Fintype G₁] [inst_2 : Fintype G₂] (p q : ℕ)\n  [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)], \n  p > q → q ∣ p - 1 → ¬IsAbelian G₁ → ¬IsAbelian G₂ → Fintype.card G₁ = p * q → Fintype.card G₂ = p * q → Nonempty (G₁ ≃* G₂) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {G₂ : Type u_2} [inst_2 : Group G₂] [inst_3 : Fintype G₂] (p q : ℕ)\n  [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q → q ∣ (p - 1) → Nonabelian G → Nonabelian G₂ → Fintype.card G = p * q → Fintype.card G₂ = p * q → Isomorphic G G₂ ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂] [inst_1 : Fintype G₁] [inst_2 : Fintype G₂] (p q : ℕ)\n  [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q → q ∣ p - 1 → Nonabelian G₁ → Nonabelian G₂ → Fintype.card G₁ = p * q → Fintype.card G₂ = p * q →\n    Nonempty (Group.Isomorphism G₁ G₂) ", "∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q →\n    q ∣ (p - 1) →\n      Nonabelian G →\n        Nonabelian G₂ →\n          Fintype.card G = p * q →\n            Fintype.card G₂ = p * q → Isomorphic G G₂ ", "forall {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q →\n    q ∣ p - 1 →\n      ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n        Fintype.card { x // x ∈ H₁ } = p * q →\n          Fintype.card { x // x ∈ H₂ } = p * q →\n            Nonabelian { x // x ∈ H₁ } →\n              Nonabelian { x // x ∈ H₂ } → Isomorphic { x // x ∈ H₁ } { x // x ∈ H₂ } ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {G₂ : Type u_2} [inst_2 : Group G₂] [inst_3 : Fintype G₂]\n  (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q → q ∣ (p - 1) →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂),\n      Fintype.card { x // x ∈ H₁ } = p * q →\n        Fintype.card { x // x ∈ H₂ } = p * q →\n          Nonabelian { x // x ∈ H₁ } →\n            Nonabelian { x // x ∈ H₂ } → Isomorphic (Group.mk { x // x ∈ H₁ }) (Group.mk { x // x ∈ H₂ }) ", "∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q → q ∣ (p - 1) → ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂), Fintype.card { x // x ∈ H₁ } = p * q → Fintype.card { x // x ∈ H₂ } = p * q →\n    Nonabelian (Group.groupOf H₁) → Nonabelian (Group.groupOf H₂) → Group.isomorphic (Group.groupOf H₁) (Group.groupOf H₂) ", "∀ {G H : Type*} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H] (p q : ℕ)\n  [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q → q ∣ (p - 1) → Fintype.card G = p * q → Fintype.card H = p * q → Nonabelian G → Nonabelian H → Isomorphic G H ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {G₂ : Type u_2} [inst_2 : Group G₂] [inst_3 : Fintype G₂] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  p > q → q ∣ p - 1 →\n    Nonabelian G → Nonabelian G₂ →\n      Fintype.card G = p * q → Fintype.card G₂= p * q → Isomorphic G G₂ "]}
{"docString": "Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"}]\n", "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Let $A$ be a normal subgroup of a group $G$, and suppose that $b \\in G$ is an element of prime order $p$, and that $b \\not\\in A$. Show that $A \\cap (b) = (e)$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] {A : Subgroup G} (b : G) (p : ℕ),\n  Subgroup.Normal A → orderOf b = p → Nat.Prime p → b ∉ A → A ∩ Subgroup.zpowers b = ⊥ ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G),\n  Subgroup.Normal A → orderOf b = Nat.minFac (orderOf b) → b ∉ A → A ⊓ Subgroup.zpowers b = Subgroup.bot ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G), Subgroup.Normal A → orderOf b = ℕ.prime → b ∉ A → A ∩ Subgroup.centralizer (Subgroup.zpowers b) = Subgroup.bot ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G),\n  Subgroup.Normal A → orderOf b = p → b ∉ A → A ∩ Subgroup.zpowers b = Subgroup.singleton 1 ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G) (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Subgroup.Normal A → orderOf b = p → b ∉ A → A ∩ Subgroup.generator {b} = ⊥ ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G),\n  Subgroup.Normal A → orderOf b = Nat.minFac (orderOf b) → b ∉ A → A ⊓ Subgroup.zpowers b = ⊥ ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G) (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Subgroup.Normal A → orderOf b = p → b ∉ A → A ∩ Subgroup.centralizer (Subtype.mk b) = ⊥ ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G),\n  Subgroup.Normal A → orderOf b = Nat.Prime → b ∉ A → A ∩ Subgroup.Closure {b} = Subgroup.Closure {1} ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G),\n  Subgroup.Normal A → orderOf b = Nat.minFac (orderOf b) → b ∉ A → A ⊓ Subgroup.zpowers b = ⊥ ", "∀ {G : Type u_1} [inst : Group G] (A : Subgroup G) (b : G),\n  Subgroup.Normal A → Nat.Prime (orderOf b) → b ∉ A → A ⊓ Subgroup.zpowers b = ⊥ "]}
{"docString": "If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- If $P \\triangleleft G$, $P$ a $p$-Sylow subgroup of $G$, prove that $\\varphi(P) = P$ for every automorphism $\\varphi$ of $G$. -/\ntheorem", "choices": ["∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} [_inst_4 : Fact (Nat.Prime p)] [inst_1 : IsPGroup p { x // x ∈ P }] (hP : P.normal),\n  ∀ (ϕ : G ≃* G), ∃ (hϕ : ∀ (x : { x // x ∈ P }), coe (ϕ x) = coe x), (ϕ.map P).Subtype = P.Subtype ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fact (Nat.Prime p)] {P : Sylow p G},\n  P.1 ⊲ G → ∀ (φ : G ≃* G), ∃ (e : P.1 ≃* P.1), ∀ (x : G), x ∈ P.1 → φ x ∈ P.1 ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} [inst_1 : Fact (Nat.Prime p)] [inst_2 : IsPGroup p { x // x ∈ P }] (hP : P.normal),\n  ∀ (φ : G ≃* G), ∀ x ∈ P, φ x ∈ P ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Sylow p G}, normal P →\n  ∀ (ϕ : G ≃* G), Subgroup.comap (MulEquiv.toMonoidHom ϕ) P = P ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G},\n  IsPGroup p { x // x ∈ P } → P.normal → ∀ (ϕ : G ≃* G), Subgroup.map ϕ P = P ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} (hP : IsPSylow p P) [inst_1 : Normal P],\n  ∀ (ϕ : G →* G), Subgroup.map ϕ P = P ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} [inst_1 : Fact (Nat.Prime p)],\n  P.normal → IsPSylow p { x // x ∈ P } → ∀ (φ : G ≃* G), ∀ x ∈ P, φ x ∈ P ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fact (Nat.Prime p)] {P : Subgroup G},\n  IsPGroup p { x // x ∈ P } → Subgroup.normal P → ∀ (ϕ : G ≃* G), Subgroup.comap (MulEquiv.toMonoidHom ϕ) P = P ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} [inst_1 : Fact (Nat.Prime p)] [inst_2 : IsPGroup p { x // x ∈ P }],\n  P.normal → ∀ (ϕ : G ≃* G), (Subgroup.equivMap P ϕ).range = P ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} [inst_1 : Fact (Nat.Prime p)],\n  P.normal → IsPSylow p { x // x ∈ P } → ∀ (ϕ : G ≃* G), ∀ x ∈ P, ϕ x ∈ P "]}
{"docString": "If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {f g : Equiv.Perm α} {x : α} [inst : DecidableEq α] [inst_1 : Fintype α],\\n  Equiv.Perm.IsCycle f →\\n    Equiv.Perm.IsCycle g →\\n      (∀ (x : α), x ∈ Equiv.Perm.support f ∩ Equiv.Perm.support g → ↑f x = ↑g x) →\\n        ↑f x = ↑g x → x ∈ Equiv.Perm.support f → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two cyclic permutations agree on all terms in their intersection,\\nand that intersection is not empty, then the two cyclic permutations must be equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},\\n  s =ᶠ[MeasureTheory.Measure.ae μ] t → ↑↑μ s = ↑↑μ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two sets are equal modulo a set of measure zero, then `μ s = μ t`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"}]\n", "prompt_cons": "/-- If two cyclic permutations agree on all terms in their intersection,\nand that intersection is not empty, then the two cyclic permutations must be equal. -/\ntheorem ∀ {α : Type u_1} {f g : Equiv.Perm α} {x : α} [inst : DecidableEq α] [inst_1 : Fintype α],\n  Equiv.Perm.IsCycle f →\n    Equiv.Perm.IsCycle g →\n      (∀ (x : α), x ∈ Equiv.Perm.support f ∩ Equiv.Perm.support g → ↑f x = ↑g x) →\n        ↑f x = ↑g x → x ∈ Equiv.Perm.support f → f = g :=\n\n/-- If two sets are equal modulo a set of measure zero, then `μ s = μ t`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s t : Set α},\n  s =ᶠ[MeasureTheory.Measure.ae μ] t → ↑↑μ s = ↑↑μ t :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- If $\\sigma, \\tau$ are two permutations that disturb no common element and $\\sigma \\tau = e$, prove that $\\sigma = \\tau = e$. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ → σ * τ = Equiv.Perm.refl α → σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α ", "forall {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ → σ * τ = Equiv.Perm.refl → σ = Equiv.Perm.refl ∧ τ = Equiv.Perm.refl ", "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ → σ * τ = Equiv.Perm.refl α → σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α ", "forall {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ →\n    Equiv.Perm.IsCycle σ →\n      Equiv.Perm.IsCycle τ →\n        σ * τ = Equiv.Perm.refl α → σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α ", "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ →\n    σ * τ = Equiv.Perm.refl → σ = Equiv.Perm.refl ∧ τ = Equiv.Perm.refl ", "forall {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α]\n  {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ →\n    σ * τ = Equiv.Perm.refl →\n      σ = Equiv.Perm.refl ∧ τ = Equiv.Perm.refl ", "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ →\n    σ * τ = Equiv.Perm.refl α →\n      σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α ", "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  ∀ (x : α), x ∉ Equiv.Perm.support σ ∩ Equiv.Perm.support τ →\n  σ * τ = Equiv.Perm.refl α → σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α ", "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Equiv.Perm.Disjoint σ τ →\n    σ * τ = Equiv.Perm.refl α →\n      σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α ", "∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : Fintype α] {σ τ : Equiv.Perm α},\n  Disjoint (Equiv.Perm.support σ) (Equiv.Perm.support τ) → σ * τ = Equiv.Perm.refl α → σ = Equiv.Perm.refl α ∧ τ = Equiv.Perm.refl α "]}
{"docString": "Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3.", "prompts": "[{\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is T₃. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\\n  T ≤ S →\\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\\n      [inst_5 : Fintype (M ⧸ T)],\\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` \"},\n {\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T5Space Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is T₅. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"}]\n", "prompt_cons": "/-- The topology on a linearly ordered group with zero element adjoined is T₃. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀ :=\n\n/-- Corollary of the third isomorphism theorem: `[S : T] [M : S] = [M : T]` -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (S T : Submodule R M),\n  T ≤ S →\n    ∀ [inst_3 : DecidablePred fun x => x ∈ Submodule.map (Submodule.mkQ T) S] [inst_4 : Fintype (M ⧸ S)]\n      [inst_5 : Fintype (M ⧸ T)],\n      Fintype.card { x // x ∈ Submodule.map (Submodule.mkQ T) S } * Fintype.card (M ⧸ S) = Fintype.card (M ⧸ T) :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is T₅. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T5Space Γ₀ :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- Let $T$ be the group of $2\\times 2$ matrices $A$ with entries in the field $\\mathbb{Z}_2$ such that $\\det A$ is not equal to 0. Prove that $T$ is isomorphic to $S_3$, the symmetric group of degree 3. -/\ntheorem", "choices": ["∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [hF : Invertible (2 : F)], Matrix.groupOfGLOnDet F 2 ≃* SymmetricGroup (Finₓ 3) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] (T : Set (Matrix (Finₓ 2) (Finₓ 2) F)),\n  T = {A : Matrix (Finₓ 2) (Finₓ 2) F | Matrix.det A ≠ 0} →\n    Nonempty (MulEquiv (Groupₓ.Closure T) (SymmetricGroup (Finₓ 3))) ", "∀ {F : Type u_1} [inst : Field F] (hF : CharP F 2),\n  Matrix.SpecialLinearGroup 2 F ≃ SymmetricGroup 3 ", "∀ {K : Type u_1} [inst : Field K] (T : Set (Matrix (Finₓ 2) (Finₓ 2) K)),\n  (∀ A : Matrix (Finₓ 2) (Finₓ 2) K, A ∈ T ↔ Matrix.det A ≠ 0) →\n    Nonempty (T ≃* S3) ", "∀ {F : Type u_1} [inst : Field F] (h : F →+* F ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [h : Fintype.card F = bit0 1], Matrix.det2_isom_S3 F ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : Invertible (2 : F)], \n  IsomorphicGroups (Units (Matrix.SpecialLinearGroup (Finₓ 2) F)) (SymmetricGroup (Finₓ 3)) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F], \n  Fintype.card F = 2 → \n  let T ", "∀ {Γ₀ : Type u_1} [inst : Field Γ₀] [inst_1 : Fintype (Γ₀ × Γ₀)] [inst_2 : CharP Γ₀ 2],\n  Nonempty (Matrix.SpecialLinearGroup (Finₓ 2) Γ₀ ≃* SymmetricGroup (Finₓ 3)) ", "∀ {F : Type u_1} [inst : Field F] (h : Fintype.card F = 2),\n  Nonempty (matrix.special_linear_group (Finₓ 2) F ≃* S_3) "]}
{"docString": "If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$.", "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\": \"∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ 0 = 1` \"}]\n", "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- `a ^ 0 = 1` -/\ntheorem ∀ {K : Type u} [self : Field K] (a : K), Field.zpow 0 a = 1 :=\n\n/-- If $a^2 = 0$ in $R$, show that $ax + xa$ commutes with $a$. -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 → AddCommute (a * x + x * a) a ", "∀ {R : Type u} [self : Ring R] (a x : R), a * a = 0 → Commute (a * x + x * a) a ", "∀ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 → Commute (a * x + x * a) a ", "∀ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 → Commute (a * x + x * a) a ", "∀ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 → Commute (a * x + x * a) a ", "∀ {R : Type u} [self : Ring R] (a x : R), a * a = 0 → Commute (a * x + x * a) a ", "∀ {R : Type u} [self : Ring R] {a x : R}, a * a = 0 → Commute (a * x + x * a) a ", "∀ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 → Commute (a * x + x * a) a ", " ∀ {R : Type u_1} [inst : Ring R] (a x : R), a * a = 0 → Commute (a * x + x * a) a ", "∀ {R : Type u_1} [inst : Ring R] {a x : R}, a * a = 0 → Commute (a * x + x * a) a "]}
{"docString": "If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an element `a` of a commutative semigroup with zero, there exists another element whose\\nproduct with zero equals `a` iff `a` equals zero. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"}]\n", "prompt_cons": "/-- Given an element `a` of a commutative semigroup with zero, there exists another element whose\nproduct with zero equals `a` iff `a` equals zero. -/\ntheorem ∀ {α : Type u_1} [inst : SemigroupWithZero α] {a : α}, 0 ∣ a ↔ a = 0 :=\n\n/-- A ring is a `ℚ`-algebra iff it has equal characteristic zero. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I) :=\n\n/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem ∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- If $R$ is a commutative ring and $a \\in R$, let $L(a) = \\{x \\in R \\mid xa = 0\\}$. Prove that $L(a)$ is an ideal of $R$. -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : CommSemiring R] (a : R), Ideal (λ x, x * a = 0) ", "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R ", "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R ", "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R ", "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R ", "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R (λ x, x * a = 0) ", "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R (λ x, x * a = 0) ", "∀ {R : Type u_1} [inst : CommRing R] {a : R}, Ideal R ", "∀ {R : Type u_1} [inst : CommRing R] (a : R), Ideal R ", "forall {R : Type u_1} [inst : CommRing R] (a : R), Ideal (set_of (λ x, x * a = 0)) "]}
{"docString": "Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$.", "prompts": "[{\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"}]\n", "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Show that $(p - 1)/2$ of the numbers $1, 2, \\ldots, p - 1$ are quadratic residues and $(p - 1)/2$ are quadratic nonresidues $\\mod p$. -/\ntheorem", "choices": ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 →\n  (card {x : ℕ | x ∈ finset.range (p - 1) ∧ legendreSym x ↑p = 1} = (p - 1) / 2) ∧\n  (card {x : ℕ | x ∈ finset.range (p - 1) ∧ legendreSym x ↑p = -1} = (p - 1) / 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 →\n  (card {x ∈ Finset.range (p - 1) | legendreSym x ↑p = 1} = (p - 1) / 2) ∧\n  (card {x ∈ Finset.range (p - 1) | legendreSym x ↑p = -1} = (p - 1) / 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 →\n  (card {x : ℕ | x ∈ finset.range (p - 1) ∧ legendreSym x ↑p = 1} = (p - 1) / 2) ∧\n  (card {x : ℕ | x ∈ finset.range (p - 1) ∧ legendreSym x ↑p = -1} = (p - 1) / 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → \n  (finset.card (finset.filter (λ x, legendreSym x ↑p = 1) (finset.range p)) = (p - 1) / 2) ∧ \n  (finset.card (finset.filter (λ x, legendreSym x ↑p = -1) (finset.range p)) = (p - 1) / 2) ", " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 →\n    (card {x : ℕ | x ∈ Finset.range (p - 1) ∧ ∃ a : ℕ, a * a ≡ x [MOD p]} = (p - 1) / 2) ∧\n    (card {x : ℕ | x ∈ Finset.range (p - 1) ∧ ¬ (∃ a : ℕ, a * a ≡ x [MOD p])} = (p - 1) / 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)],\n  p ≠ 2 →\n  (card (filter (λ x, legendreSym x ↑p = 1) (range (p - 1))) = (p - 1) / 2) ∧\n  (card (filter (λ x, legendreSym x ↑p = -1) (range (p - 1))) = (p - 1) / 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)],\n  p ≠ 2 →\n  (card {x : ℕ | x ∈ Finset.range (p - 1) ∧ x ∈ quadraticResidues (Zmod p)} = (p - 1) / 2) ∧\n  (card {x : ℕ | x ∈ Finset.range (p - 1) ∧ x ∈ quadraticNonResidues (Zmod p)} = (p - 1) / 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 →\n  (cardinality {x : ℕ | x ∈ Finset.range p ∧ x ≠ 0 ∧ legendreSym x ↑p = 1} = (p - 1) / 2) ∧\n  (cardinality {x : ℕ | x ∈ Finset.range p ∧ x ≠ 0 ∧ legendreSym x ↑p = -1} = (p - 1) / 2) ", "quadratic_residues (p : ℕ) [Fact (Nat.Prime p)] (hp : p ≠ 2) :\n  (card (quadratic_residues p) = (p - 1) / 2) ∧ (card (quadratic_nonresidues p) = (p - 1) / 2) ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 →\n  card (SetOf (λ x, quadraticResidueModP x p)) = (p - 1) / 2 ∧\n  card (SetOf (λ x, quadraticNonResidueModP x p)) = (p - 1) / 2 "]}
{"docString": "Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"}]\n", "prompt_cons": "/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- Let $F = \\mathbb{Z}_7$ and let $p(x) = x^3 - 2$ and $q(x) = x^3 + 2$ be in $F[x]$. Show that $p(x)$ and $q(x)$ are irreducible in $F[x]$ and that the fields $F[x]/(p(x))$ and $F[x]/(q(x))$ are isomorphic. -/\ntheorem", "choices": ["let F : Type u_1 ", "irreducible_px_qx : ∀ {F : Type u_1} [inst : CommRing F] [inst_1 : IsDomain F] [inst_2 : CharP F 7],\n  Irreducible (Polynomial.x ^ 3 - 2) ∧ Irreducible (Polynomial.x ^ 3 + 2) ", "∀ {F : Type u_1} [inst : Field F],\n  (¬ char_p F 7) →\n    ∀ (p q : Polynomial F),\n      p = (C (F.mk 1) * X ^ 3) - (C (F.mk 2)) →\n        q = (C (F.mk 1) * X ^ 3) + (C (F.mk 2)) →\n          Irreducible p ∧ Irreducible q ∧\n            (Polynomial.AlgebraMap F (Polynomial.QuotientRing F p) ≃ₐ[F] Polynomial.AlgebraMap F (Polynomial.QuotientRing F q)) ", "irreducible_F_p_q : ∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F 7],\n  let p ", "example : ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : CharP F 7],\n  let p : Polynomial F ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] (hpq : Fintype.card F = 7),\n  let p ", "irreducible_p_in_Fx : ∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F 7], \n  Irreducible (Polynomial.x ^ 3 - 2) ", "∀ {F : Type u_1} [inst : Field F] {p q : Polynomial F}, F = Zmod 7 →\n  p = Polynomial.x ^ 3 - 2 → q = Polynomial.x ^ 3 + 2 →\n  Irreducible p → Irreducible q →\n  ∃ (ϕ : Polynomial F →+* Polynomial F),\n    IsFieldHom ϕ ∧ Polynomial.map ϕ p = p ∧ Polynomial.map ϕ q = q ", "/-- Let `F = Zmod 7` and let `p(x) = x ^ 3 - 2` and `q(x) = x ^ 3 + 2` be in `F[x]`. -/\n/-- Show that `p(x)` and `q(x)` are irreducible in `F[x]`. -/\ntheorem irreducible_p_q {F : Type u_1} [inst : Field F] [inst_1 : CharP F 7] :\n  Irreducible (Polynomial.x ^ 3 - 2) ∧ Irreducible (Polynomial.x ^ 3 + 2) ", "irreducible_px_qx : ∀ (F : Type u_1) [inst : CommRing F] [inst_1 : CharP F 7],\n  Irreducible (Polynomial.x ^ 3 - 2) ∧ Irreducible (Polynomial.x ^ 3 + 2) "]}
{"docString": "Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- Prove that $f(x) = x^3 + 3x + 2$ is irreducible in $Q[x]$. -/\ntheorem", "choices": ["f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "irreducible_fx : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "irreducible_fx : Irreducible (Polynomial.x^3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "irreducible_fx : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "irreducible_fx : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) ", "f_irreducible : Irreducible (Polynomial.x ^ 3 + 3 * Polynomial.x + 2 : Polynomial ℚ) "]}
{"docString": "If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → a ^ (Fintype.card F / 2) = 1 ∨ a ^ (Fintype.card F / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ {R' : Type v} [inst : CommRing R'] {F : Type u} [inst_1 : Field F] {ψ : AddChar F R'},\\n  AddChar.IsNontrivial ψ → AddChar.IsPrimitive ψ\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `R` is a field `F`, then a nontrivial additive character is primitive \"}]\n", "prompt_cons": "/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- If `F` has odd characteristic, then for nonzero `a : F`, we have that `a ^ (#F / 2) = ±1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ {a : F}, a ≠ 0 → a ^ (Fintype.card F / 2) = 1 ∨ a ^ (Fintype.card F / 2) = -1 :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- When `R` is a field `F`, then a nontrivial additive character is primitive -/\ntheorem ∀ {R' : Type v} [inst : CommRing R'] {F : Type u} [inst_1 : Field F] {ψ : AddChar F R'},\n  AddChar.IsNontrivial ψ → AddChar.IsPrimitive ψ :=\n\n/-- If $F$ is a field of characteristic $p \\neq 0$, show that $(a + b)^m = a^m + b^m$, where $m = p^n$, for all $a, b \\in F$ and any positive integer $n$. -/\ntheorem", "choices": ["∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] {p : ℕ} (hc : Fact (p ≠ 0)),\n  ∀ {a b : F} {n : ℕ} (m : ℕ ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] {p : ℕ} [inst_2 : Fact (Nat.Prime p)] {m : ℕ} (h : CharP F p) (a b : F),\n  m = p ^ Nat.findGreatest (λ n, p ^ n ∣ m) 0 → (a + b) ^ m = a ^ m + b ^ m ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fact (0 < ringChar F)], \n  ∀ {a b : F}, ∀ {n : ℕ}, 0 < n → (a + b) ^ (ringChar F ^ n) = a ^ (ringChar F ^ n) + b ^ (ringChar F ^ n) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fact (Nat.Prime (ringChar F))] {a b : F} {n : ℕ},\n  0 < n → (a + b) ^ (ringChar F ^ n) = a ^ (ringChar F ^ n) + b ^ (ringChar F ^ n) ", "∀ {F : Type u_1} [inst : Field F] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] [char_p : CharP F p]\n  {a b : F} {n : ℕ} (m : ℕ ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] {p : ℕ} (hp : Fact (Nat.Prime p)),\n  CharP.char_ne_zero F hp → ∀ (n : ℕ), n > 0 → ∀ (a b : F), (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F p] (h : p ≠ 0) {a b : F} {n : ℕ} (hn : n > 0),\n(a + b) ^ (p^n) = a^(p^n) + b^(p^n) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F ≠ 0] {a b : F} {n : ℕ}, n > 0 → (a + b) ^ (CharP π₁ F ^ n) = a ^ (CharP π₁ F ^ n) + b ^ (CharP π₁ F ^ n) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F] (p : ℕ) [inst_2 : Fact (0 < p)],\n  ∀ (n : ℕ) (a b : F), (a + b) ^ (p ^ n) = a ^ (p ^ n) + b ^ (p ^ n) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F p] (m : ℕ) (hn : p ^ m ≠ 0), ∀ {a b : F}, (a + b) ^ (p ^ m) = a ^ (p ^ m) + b ^ (p ^ m) "]}
{"docString": "If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} {L : Type u_2} {A : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\\n  Algebra.IsAlgebraic K L → Algebra.IsAlgebraic L A → Algebra.IsAlgebraic K A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If L is an algebraic field extension of K and A is an algebraic algebra over L,\\nthen A is algebraic over K. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\\n  Algebra.IsAlgebraic K A → Algebra.IsAlgebraic L A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A] {x : A},\\n  IsAlgebraic K x → IsAlgebraic L x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x is algebraic over K, then x is algebraic over L when L is an extension of K \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (A : Subalgebra K L),\\n  Algebra.IsAlgebraic K L → IsField { x // x ∈ A }\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an algebraic extension L/K, an intermediate subalgebra is a field. \"}]\n", "prompt_cons": "/-- If L is an algebraic field extension of K and A is an algebraic algebra over L,\nthen A is algebraic over K. -/\ntheorem ∀ {K : Type u_1} {L : Type u_2} {A : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\n  Algebra.IsAlgebraic K L → Algebra.IsAlgebraic L A → Algebra.IsAlgebraic K A :=\n\n/-- If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K -/\ntheorem ∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A],\n  Algebra.IsAlgebraic K A → Algebra.IsAlgebraic L A :=\n\n/-- If x is algebraic over K, then x is algebraic over L when L is an extension of K -/\ntheorem ∀ (K : Type u_1) (L : Type u_3) {A : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : CommRing A]\n  [inst_3 : Algebra K L] [inst_4 : Algebra L A] [inst_5 : Algebra K A] [inst_6 : IsScalarTower K L A] {x : A},\n  IsAlgebraic K x → IsAlgebraic L x :=\n\n/-- In an algebraic extension L/K, an intermediate subalgebra is a field. -/\ntheorem ∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (A : Subalgebra K L),\n  Algebra.IsAlgebraic K L → IsField { x // x ∈ A } :=\n\n/-- If $a \\in K$ is such that $a^2$ is algebraic over the subfield $F$ of $K$, show that a is algebraic over $F$. -/\ntheorem", "choices": ["∀ (F : Type u_1) (K : Type u_2) {A : Type u_3} [inst : Field F] [inst_1 : Field K] [inst_2 : CommRing A]\n  [inst_3 : Algebra F K] [inst_4 : Algebra K A] [inst_5 : Algebra F A] [inst_6 : IsScalarTower F K A] {a : A},\n  IsAlgebraic F (a^2) → IsAlgebraic F a ", "∀ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) → IsAlgebraic F a ", "∀ (F : Type u_1) (K : Type u_3) {A : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : CommRing A]\n  [inst_3 : Algebra F K] [inst_4 : Algebra K A] [inst_5 : Algebra F A] [inst_6 : IsScalarTower F K A] {a : A},\n  IsAlgebraic F (a * a) → IsAlgebraic F a ", "∀ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) → IsAlgebraic F a ", "∀ {F: Type u_1} {K : Type u_2} {a : K} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K],\n  IsAlgebraic F (a * a) → IsAlgebraic F a ", "forall {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] (a : K),\n  IsAlgebraic F (a^2) → IsAlgebraic F a ", "∀ {F : Type u_1} {K : Type u_2} {a : K} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K],\n  IsAlgebraic F (a ^ 2) → IsAlgebraic F a ", "∀ {F : Type u_1} {K : Type u_2} {a : K} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] [inst_3 : Algebra K K]\n  [inst_4 : IsScalarTower F K K], IsAlgebraic F (a^2) → IsAlgebraic F a ", "∀ {F : Type u_1} {K : Type u_2} [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a ^ 2) → IsAlgebraic F a ", "∀ (F : Type u_1) (K : Type u_2) [inst : Field F] [inst_1 : Field K] [inst_2 : Algebra F K] {a : K},\n  IsAlgebraic F (a * a) → IsAlgebraic F a "]}
{"docString": "If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80.", "prompts": "[{\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)],\\n  p ≠ 2 → ∀ (a : ℤ), ↑(Finset.card (Set.toFinset {x | x ^ 2 = ↑a})) = legendreSym p a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of square roots of `a` modulo `p` is determined by the Legendre symbol. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p (a ^ 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"}]\n", "prompt_cons": "/-- The number of square roots of `a` modulo `p` is determined by the Legendre symbol. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)],\n  p ≠ 2 → ∀ (a : ℤ), ↑(Finset.card (Set.toFinset {x | x ^ 2 = ↑a})) = legendreSym p a + 1 :=\n\n/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p :=\n\n/-- The Legendre symbol of `a^2` at `p` is 1 if `p ∤ a`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p (a ^ 2) = 1 :=\n\n/-- Euler's Criterion: a nonzero `a : ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → (IsSquare a ↔ a ^ (p / 2) = 1) :=\n\n/-- If $a \\in C$ is such that $p(a) = 0$, where $p(x) = x^5 + \\sqrt{2}x^3 + \\sqrt{5}x^2 + \\sqrt{7}x + \\sqrt{11}$, show that $a$ is algebraic over $\\mathbb{Q}$ of degree at most 80. -/\ntheorem", "choices": ["∀ {C : Type u} [inst : Field C] [inst2 : Algebra ℚ C] {a : C},\n  a ^ 5 + a ^ 3 * algebraMap ℚ C (Rational.SqRoot 2) +\n  a ^ 2 * algebraMap ℚ C (Rational.SqRoot 5) +\n  a * algebraMap ℚ C (Rational.SqRoot 7) +\n  algebraMap ℚ C (Rational.SqRoot 11) = 0 →\n  IsAlgebraic ℚ a ∧ algebraicDim ℚ a ≤ 80 ", "∀ (C : Type u) [inst : Field C] (a : C),\n  a ^ 5 + (2 ^ (1 / 2)) * a ^ 3 + (5 ^ (1 / 2)) * a ^ 2 + (7 ^ (1 / 2)) * a + (11 ^ (1 / 2)) = 0 →\n  IsAlgebraic ℚ a ∧ ∃ (p : Polynomial ℚ), p ≠ 0 ∧ a ∈ (SetOf fun a => Polynomial.eval a p = 0) ∧ p.degree ≤ 80 ", "∀ (C : Type u) [inst : Field C] (a : C),\n  a ^ 5 + (2 ^ (1 / 2)) * a ^ 3 + (5 ^ (1 / 2)) * a ^ 2 + (7 ^ (1 / 2)) * a + 11 ^ (1 / 2) = 0 →\n  IsAlgebraic (Ratfunc Q) a ∧ algebraicDegree (Ratfunc Q) a ≤ 80 ", "∀ {C : Type u} [inst : Field C] {a : C},\n  a ^ 5 + (√2 : ℝ) * a ^ 3 + (√5 : ℝ) * a ^ 2 + (√7 : ℝ) * a + (√11 : ℝ) = 0 →\n  is_algebraic ℚ a ∧ algebraic_degree ℚ a ≤ 80 ", "∀ {C : Type u} [inst : Field C] {p : Polynomial C},\n  (∀ {a : C}, p = a ^ 5 + (√2 * a ^ 3) + (√5 * a ^ 2) + (√7 * a) + √11 → p ≠ 0) ->\n  ∀ {a : C}, p.eval a = 0 → IsAlgebraic (↥Rational) a ∧ (Algebraic.degree (↥Rational) a) ≤ 80 ", "∀ {C : Type u} [inst : Field C] (pa : @Algebra ℝ C _ _) {a : C},\n  a ^ 5 + pa.toFun (Real.sqrt 2) * a ^ 3 + pa.toFun (Real.sqrt 5) * a ^ 2 + pa.toFun (Real.sqrt 7) * a + pa.toFun (Real.sqrt 11) = 0 →\n  ∃ (p : @Polynomial ℚ _ _) (hp : p ≠ 0), Polynomial.degree p ≤ 80 ∧ Polynomial.aeval a p = 0 ", "∀ {C : Type u} [inst : Field C] [inst : Algebroid.Rat C] {p : Polynomial C},\n  p = (Polynomial.X ^ 5 + (Polynomial.C (Algebroid.ofRat (√2))) * (Polynomial.X ^ 3)\n        + (Polynomial.C (Algebroid.ofRat (√5))) * (Polynomial.X ^ 2)\n        + (Polynomial.C (Algebroid.ofRat (√7))) * Polynomial.X\n        + Polynomial.C (Algebroid.ofRat (√11)))\n  → ∀ {a : C}, p.eval a = 0 → IsAlgebraic (AlgebraicClosure Q) a ∧ Algebraic.degree a ≤ 80 ", "∀ {C : Type u} [inst : CommRing C] [Algebra ℚ C] (a : C),\n  a ^ 5 + ↑(Algebra.adjoinRoot (Real.sqrt 2)) * a ^ 3 + ↑(Algebra.adjoinRoot (Real.sqrt 5)) * a ^ 2 + ↑(Algebra.adjoinRoot (Real.sqrt 7)) * a + ↑(Algebra.adjoinRoot (Real.sqrt 11)) = 0 → IsAlgebraic ℚ a ∧ Algebraic.degree ℚ a ≤ 80 ", "∀ {C : Type u} [inst1 : Field C] [inst2 : Algebra ℝ C] {a : C},\n  a ^ 5 + (2 ^ (1 / 2)) * a ^ 3 + (5 ^ (1 / 2)) * a ^ 2 + (7 ^ (1 / 2)) * a + (11 ^ (1 / 2)) = 0 →\n  IsAlgebraic ℚ a ∧ Polynomial.degree (minpoly ℚ a) ≤ 80 ", "∀ {C : Type u} [inst : Field C] (a : C),\n  (a ^ 5 + √(2) * a ^ 3 + √(5) * a ^ 2 + √(7) * a + √(11) = 0) → IsAlgebraic (ℚ : Type u) a ∧ Algebraic.degree ℚ a ≤ 80 "]}
{"docString": "If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℕ), padicNorm p ↑m = 1 ↔ ¬p ∣ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"}]\n", "prompt_cons": "/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p :=\n\n/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℕ), padicNorm p ↑m = 1 ↔ ¬p ∣ m :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R) :=\n\n/-- If $F$ is of characteristic $p \\neq 0$, show that all the roots of $x^m - x$, where $m = p^n$, are distinct. -/\ntheorem", "choices": ["forall {F : Type u_1} [inst : Field F] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] {n m : ℕ}, ringChar F = p →\n  (Polynomial.X ^ (p ^ n) - Polynomial.X).roots.nodup ", "∀ (F : Type u_1) [inst : Field F] {p : ℕ} [inst_1 : Fact (Nat.Prime p)] [hp : CharP F p],\n  ringChar F ≠ 0 → ∀ (n : ℕ), Polynomial.nodup_roots (Polynomial.x ^ (p^n) - Polynomial.x) ", "∀ {F : Type u_1} [inst : Field F] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] (n : ℕ),\n  ringChar F = p →\n  Polynomial.nodupRoots (Polynomial.x ^ (p ^ n) - Polynomial.x) ", "∀ {F : Type u_1} [inst : Field F] {p : ℕ} [inst_1 : Fact (Nat.Prime p)],\n  ringChar F ≠ 0 →\n    ∀ {n : ℕ}, Polynomial.roots (Polynomial.x ^ (p ^ n) - Polynomial.x) = Multiset.repeat Multiset.nil (p ^ n) ", "forall {F : Type u_1} [inst : Field F] {p : ℕ} [hp : Fact (Nat.Prime p)] [CharP F p] {n : ℕ},\n  UniqueRoots (Polynomial.x ^ (p ^ n) - Polynomial.x) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  ringChar F = p → ∀ {m n : ℕ}, m = p ^ n → Polynomial.roots (Polynomial.x ^ m - Polynomial.x) = Finset.univ ", " ∀ {F : Type u_1} [inst : Field F],\n  ∀ {p : ℕ} [inst_1 : Fact (Nat.Prime p)] (hp : ringChar F = p) {n : ℕ},\n    Polynomial.nodup_roots (Polynomial.X ^ (p ^ n) - Polynomial.X) ", "∀ {F : Type u} [inst : Field F] {p : ℕ} [hchar : Fact (ringChar F = p)],\n  Nat.Prime p →\n    ∀ {n : ℕ}, Polynomial.nodupRoots (Polynomial.map (algebraMap (Zmod p) F) (Polynomial.x ^ (p ^ n) - Polynomial.x)) ", "∀ {F : Type u_1} [inst : Field F] {p : ℕ} [Fact (Nat.Prime p)] {n : ℕ},\n  ringChar F = p → Fintype.card (Polynomial.rootSet (Polynomial.x ^ (p ^ n) - Polynomial.x) F) = p ^ n ", "∀ {F : Type u_1} [inst : Field F] {p n : ℕ} [hp : Fact (Nat.Prime p)] [hF : ringChar F = p],\n  (m : ℕ) → m = p ^ n → Polynomial.roots (Polynomial.x ^ m - Polynomial.x) = Multiset.eraseDup (Polynomial.roots (Polynomial.x ^ m - Polynomial.x)) "]}
{"docString": "Prove that the products $a b$ and $b a$ are conjugate elements in a group.", "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ∃ c, SemiconjBy c a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\\nis transitive. \"}]\n", "prompt_cons": "/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- The relation “there exists an element that semiconjugates `a` to `b`” on a semigroup\nis transitive. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S], Transitive fun a b => ∃ c, SemiconjBy c a b :=\n\n/-- Prove that the products $a b$ and $b a$ are conjugate elements in a group. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] (a b : G), ∃ c, SemiconjBy c (a * b) (b * a) ", "forall {G : Type u_1} [inst : Group G] {a b : G}, ∃ c, Conjugate (a * b) (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, Conjugate (a * b) (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, ∃ c, SemiconjBy c (a * b) (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, ∃ c, ConjBy c (a * b) (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, IsConj a b → IsConj (a * b) (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, ∃ c, SemiconjBy c (a * b) (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, ∃ c, Conjugate a b c ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, ∃ z, SemiconjBy z (a * b) (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, ∃ c, ConjugateBy c (a * b) (b * a) "]}
{"docString": "Prove that the center of the product of two groups is the product of their centers.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalNonAssocSemiring α] (self : CentroidHom α) (a b : α),\\n  ZeroHom.toFun (↑self.toAddMonoidHom) (a * b) = ZeroHom.toFun (↑self.toAddMonoidHom) a * b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of centroid homomorphims with right multiplication. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"}]\n", "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem ∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M :=\n\n/-- Commutativity of centroid homomorphims with right multiplication. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalNonAssocSemiring α] (self : CentroidHom α) (a b : α),\n  ZeroHom.toFun (↑self.toAddMonoidHom) (a * b) = ZeroHom.toFun (↑self.toAddMonoidHom) a * b :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- Prove that the center of the product of two groups is the product of their centers. -/\ntheorem", "choices": ["∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Set.center (G × H) = (Set.center G).prod (Set.center H) ", "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], Set.center (G × H) = Set.prod (Set.center G) (Set.center H) ", "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst_1 : Group G₁] [inst_2 : Group G₂],\n  Set.center (G₁ × G₂) = (Set.center G₁).prod (Set.center G₂) ", "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "∀ {G : Type u_1} {H : Type u_2} [inst₁ : Group G] [inst₂ : Group H],\n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], \n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) ", "forall {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Subgroup.center (G × H) = Subgroup.prod (Subgroup.center G) (Subgroup.center H) "]}
{"docString": "Prove that every homomorphism of fields is injective.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R →\\n    ∀ (ps : ι → MvPolynomial ι R),\\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"}]\n", "prompt_cons": "/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1) :=\n\n/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem ∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f :=\n\n/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\n  Algebra.IsAlgebraic K R →\n    ∀ (ps : ι → MvPolynomial ι R),\n      (Function.Injective fun v i => ↑(MvPolynomial.eval v) (ps i)) →\n        Function.Surjective fun v i => ↑(MvPolynomial.eval v) (ps i) :=\n\n/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- Prove that every homomorphism of fields is injective. -/\ntheorem", "choices": ["∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K →+* L}, Function.Injective ↑f ", "∀ {F : Type u} {K : Type v} [inst : Field F] [inst_1 : Field K] {f : F → K},\n  IsFieldHom f → Function.Injective f ", "∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K →+* L},\n  Function.Injective ↑f ", "∀ {F : Type u} {K : Type v} [inst : Field F] [inst_1 : Field K] {f : F →+* K}, Function.Injective ↑f ", "∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K →+* L}, Function.Injective ↑f ", "∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K →+* L}, Function.Injective ↑f ", "∀ {K : Type u} {L : Type v} [field K] [field L] (f : K →+* L), Function.Injective f ", "∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K →+* L},\n  Function.Injective ↑f ", "∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f : K →+* L}, Function.Injective ↑f ", "∀ {F : Type u} {K : Type v} [inst : Field F] [inst_1 : Field K] {f : F →+* K}, Function.Injective ↑f "]}
{"docString": "Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces.", "prompts": "[{\"theorem\":\n  \"∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] (E : Type v) [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : ProperSpace 𝕜] [inst : FiniteDimensional 𝕜 E], ProperSpace E\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any finite-dimensional vector space over a proper field is proper.\\nWe do not register this as an instance to avoid an instance loop when trying to prove the\\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\\nexplicitly when needed. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\\n    ∀ (f : V'' →ₗ[R] V),\\n      Function.Injective ↑f →\\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\\n * the function `f' : V'' → V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"}]\n", "prompt_cons": "/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem ∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] (E : Type v) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : ProperSpace 𝕜] [inst : FiniteDimensional 𝕜 E], ProperSpace E :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\n * the function `f' : V'' → V'` doesn't need to be injective -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\n    ∀ (f : V'' →ₗ[R] V),\n      Function.Injective ↑f →\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\n  AffineIndependent k f → Set.Finite s :=\n\n/-- Let $V$ be a vector space over an infinite field $F$. Prove that $V$ is not the union of finitely many proper subspaces. -/\ntheorem", "choices": ["∀ (F : Type u_1) [inst : Field F] [inst_1 : Infinite F] (V : Type u_2) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  ¬∃ (I : Type u_3) (t : I → Submodule F V), (⋃ (i : I), ↑(t i)) = Set.Univ ∧ ∀ (i : I), t i < ⊤ ", "∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  (h𝕜 : Infinite 𝕜), ¬∃ (t : Set V) [inst_3 : Fintype t], Submodule.span 𝕜 t = ⊤ → ∃ (s : Finset (Submodule 𝕜 V)), ¬(⋃₀ s) = ⊤ ", "∀ (𝕜 : Type u) [inst : Field 𝕜] [inst_1 : Infinite 𝕜] (E : Type v) [inst_2 : AddCommGroup E] [inst_3 : Module 𝕜 E],\n  ¬∃ (n : ℕ) (s : Finₓ n → Submodule 𝕜 E), (∀ (i : Finₓ n), s i < ⊤) ∧ (Submodule.span 𝕜 (Set.Unionₓ (s '' coe)) = ⊤) ", "∀ (F : Type u) [inst : Field F] [inst_1 : Infinite F] (V : Type v) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  ¬∃ (s : Set (Submodule F V)), Set.Finite s ∧ (⋃₀ s = ⊤) ", "∀ {F : Type u} [inst : Field F] {V : Type v} [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  ¬∃ (t : ℕ) (s : Finₓ t → Submodule F V), ∀ (x : V), ∃ (i : Finₓ t), x ∈ s i ", "∀ (F : Type u) [inst : Field F] [inst_1 : Infinite F] (V : Type v) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  ¬∃ (ι : Type u_1) (s : ι → Submodule F V), (∀ (i : ι), s i < ⊤) ∧ Submodule.span F (Set.Unionₓ (s '' Set.Univ)) = ⊤ ", "∀ {F : Type u_1} {V : Type u_2} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V], Infinite F → ∀ (n : ℕ) (S : Finₓ n → Subspace F V),\n  (∀ (i : Finₓ n), (S i).proper) → ¬(V = ⋃ (i : Finₓ n), (S i : Set V)) ", "∀ (F : Type u_1) [inst : Field F] [inst_1 : IsInfinite F] (V : Type u_2) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  ¬∃ (t : Set (Subspace F V)), Set.Finite t ∧ Submodule.span F (⋃ (s : ↥t), ↑s) = ⊤ ", "∀ (F : Type u_1) {V : Type u_2} [inst : Infinite F] [inst_1 : DivisionRing F] [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  ¬∃ (s : ℕ) (S : Finₓ s → Submodule F V), ∀ (x : V), ∃ (i : Finₓ s), x ∈ S i ", "∀ (F : Type u_1) {V : Type u_2} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  ¬∃ (f : ℕ → Submodule F V), (∀ (i : ℕ), (f i) < ⊤) → ⋃ (i : ℕ), ↑(f i) = ↑⊤ "]}
{"docString": "Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Prove that no group of order $p q$, where $p$ and $q$ are prime, is simple. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → ¬ IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → ¬ IsSimpleGroup G ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card α = p * q → ¬ IsSimpleGroup α ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → ¬ IsSimpleGroup G ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card α = p * q → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card α = p * q → ¬ IsSimpleGroup α ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → ¬ IsSimpleGroup G ", "∀ {G : Type u_2} [inst : Group G] [inst_1 : Fintype G] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → ¬ IsSimpleGroup G ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → ¬IsSimpleGroup G "]}
{"docString": "Prove that no group of order 224 is simple.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"}]\n", "prompt_cons": "/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- Prove that no group of order 224 is simple. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬ IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Fintype.card α = 224 → ¬IsSimpleGroup α "]}
{"docString": "An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] {x : R}, ‖x‖ < 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a normed ring, the powers of an element x with `‖x‖ < 1` tend to zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\\nnilpotent, except its constant term which is a unit. \"}]\n", "prompt_cons": "/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- In a normed ring, the powers of an element x with `‖x‖ < 1` tend to zero. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] {x : R}, ‖x‖ < 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) :=\n\n/-- Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\nnilpotent, except its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- An element $x$ of a ring $R$ is called nilpotent if some power of $x$ is zero. Prove that if $x$ is nilpotent, then $1+x$ is a unit in $R$. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] {x : R},\n  IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R},\n  IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R},\n  IsNilpotent x → IsUnit (1 + x) ", "forall {R : Type u} [inst : CommRing R] {x : R},\n  IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R},\n  IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R},\n  IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R},\n  IsNilpotent x → IsUnit (1 + x) ", "∀ {R : Type u} [inst : CommRing R] {x : R}, IsNilpotent x → IsUnit (1 + x) "]}
{"docString": "Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I\",\n  \"isProp\": true,\n  \"docString\": \"Nonzero fractional ideals contain a nonzero integer. \"},\n {\"theorem\":\n  \"∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\\n  ¬IsField A →\\n    ∀ {I : Ideal A},\\n      I ≠ ⊥ →\\n        ∃ Z,\\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) (I : { x // x ∈ nonZeroDivisors (Ideal S) }),\\n  ∃ b, b ∈ ↑I ∧ b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ↑abv (↑(Algebra.norm R) c) < ↑abv (↑(Algebra.norm R) b) → c = 0\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero ideal has an element of minimal norm. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"}]\n", "prompt_cons": "/-- Nonzero fractional ideals contain a nonzero integer. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I :=\n\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) -/\ntheorem ∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\n  ¬IsField A →\n    ∀ {I : Ideal A},\n      I ≠ ⊥ →\n        ∃ Z,\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥ :=\n\n/-- A nonzero ideal has an element of minimal norm. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : EuclideanDomain R] [inst_1 : CommRing S] [inst_2 : IsDomain S]\n  [inst_3 : Algebra R S] (abv : AbsoluteValue R ℤ) (I : { x // x ∈ nonZeroDivisors (Ideal S) }),\n  ∃ b, b ∈ ↑I ∧ b ≠ 0 ∧ ∀ (c : S), c ∈ ↑I → ↑abv (↑(Algebra.norm R) c) < ↑abv (↑(Algebra.norm R) b) → c = 0 :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem ∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- Prove that every nonzero ideal in the ring of Gauss integers contains a nonzero integer. -/\ntheorem", "choices": ["∀ {I : Ideal ℤ[i]},\n  I ≠ ⊥ →\n    ∃ x : ℤ, x ≠ 0 ∧ ↑x ∈ I ", "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I ", "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I ", "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {K : Type u_2} [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_5 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I ", "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I ", "∀ {K : Type u_2} [inst : Field K] [inst_1 : Algebra ℤ[K] K] {I : FractionalIdeal (nonZeroDivisors ℤ[K]) K} [inst_2 : Nontrivial ℤ[K]],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap ℤ[K] K) x ∈ I ", "∀ {I : Ideal ℤ[i]}, I ≠ ⊥ → ∃ x : ℤ, x ≠ 0 ∧ ↑x ∈ I ", "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : FractionalIdeal (nonZeroDivisors R) K} [inst_4 : Nontrivial R],\n  I ≠ 0 → ∃ x x_1, ↑(algebraMap R K) x ∈ I ", "∀ {I : Ideal ℤ[i]}, I ≠ ⊥ → ∃ x : ℤ, x ≠ 0 ∧ ↑x ∈ I "]}
{"docString": "Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (∀ (P : Ideal R) (x : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\\n    I = J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\\nthe localization of `J` at `P`, then `I = J`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (∀ (P : Ideal R) (hP : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I ≤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\\n    I ≤ J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\\nthe localization of `J` at `P`, then `I ≤ J`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\\n  Ideal.comap (algebraMap R S) (conductor R x) ⊔ I = ⊤ →\\n    Function.Injective ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) →\\n      Ideal.comap (algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\\n        Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"}]\n", "prompt_cons": "/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (∀ (P : Ideal R) (x : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\n    I = J :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I ≤ J`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (∀ (P : Ideal R) (hP : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I ≤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\n    I ≤ J :=\n\n/-- A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\n  Ideal.comap (algebraMap R S) (conductor R x) ⊔ I = ⊤ →\n    Function.Injective ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) →\n      Ideal.comap (algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\n        Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥ :=\n\n/-- Let $I, J$ be ideals of a ring $R$ such that $I+J=R$. Prove that $I J=I \\cap J$. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I ⊔ J = ⊤ →\n    I * J = I ⊓ J ", "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I ⊔ J = ⊤ →\n    I * J = I ⊓ J ", "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R}, I ⊔ J = ⊤ → I * J = I ⊓ J ", "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (I ⊔ J = ⊤) →\n    (I * J = I ⊓ J) ", "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R}, I + J = ⊤ → I * J = I ⊓ J ", "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I ⊔ J = ⊤ →\n  I * J = I ⊓ J ", "forall {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I ⊔ J = ⊤ →\n    I * J = I ⊓ J ", "forall {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I ⊔ J = ⊤ →\n  I * J = I ⊓ J ", "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  I ⊔ J = ⊤ →\n    I * J = I ⊓ J ", "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R}, I ⊔ J = ⊤ → I * J = I ⊓ J "]}
{"docString": "If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$.", "prompts": "[{\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → (a ∣ b + c ↔ a ∣ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\\nelement `c` iff `a` divides `c`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ c → (a ∣ b + c ↔ a ∣ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\\n`b` with `c` iff `a` divides `b`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. \"}]\n", "prompt_cons": "/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0 :=\n\n/-- If an element `a` divides another element `b` in a ring, `a` divides the sum of `b` and another\nelement `c` iff `a` divides `c`. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → (a ∣ b + c ↔ a ∣ c) :=\n\n/-- If an element `a` divides another element `c` in a ring, `a` divides the sum of another element\n`b` with `c` iff `a` divides `b`. -/\ntheorem ∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ c → (a ∣ b + c ↔ a ∣ b) :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0 :=\n\n/-- If $a, b$ are integers and if $a$ divides $b$ in the ring of Gauss integers, then $a$ divides $b$ in $\\mathbb{Z}$. -/\ntheorem", "choices": ["∀ {a b : ℤ}, (ℤ_[a] ∣ ℤ_[b]) → (a ∣ b) ", "∀ {a b : ℤ}, a ∣ b → a ∣ b ", "∀ {a b : ℤ} [inst : CommRing ℤ], a ∣ b → (a ∣ b ↔ a ∣ b) ", "∀ {a b : ℤ}, a ∣ b → (a ∣ b) ", "∀ {a b : ℤ}, is_gaussian_int a → is_gaussian_int b → a ∣ b → a ∣ b ", "∀ {a b : ℤ} [inst : NonUnitalRing ℤ], a ∣ b → a ∣ b ", "∀ {a b : ℤ} [inst : NonUnitalRing ℤ], a ∣ b → (a ∣ b → a ∣ b) ", "∀ {a b : ℤ}, a ∣ b → (a ∣ b) ", "∀ {a b : ℤ} [inst : NonUnitalRing ℤ] {a b : ℤ}, a ∣ b → (a ∣ b + c ↔ a ∣ c) ", "∀ {a b : ℤ}, a ∣ b → (a ∣ b ↔ a ∣ b) "]}
{"docString": "Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- Prove that $x^2+x+1$ is irreducible in the field $\\mathbb{F}_2$. -/\ntheorem", "choices": ["irreducible_x_pow2_x_plus1_F2 : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "x_sq_plus_x_plus_1_irreducible : Irreducible (Polynomial.x ^ 2 + Polynomial.x + (1 : Polynomial (Zmod 2))) ", "x_sq_x_one_irreducible : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "IrreducibleF2_x2_x_1 : Irreducible (Polynomial.x^2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "Irreducible_x_pow_two_plus_x_plus_one_F2 : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "Irreducible_x2x1_in_F2 : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial ℤ) ", "Irreducible_x2_x_plus_1_F2 : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial 𝔽₂) ", "irreducible_x_pow_two_plus_x_plus_one : ∀ {F : Type u_1} [inst : Field F], ringChar F = 2 → Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1) ", "Irreducible_x_pow2_x_add_1_F2 : Irreducible (Polynomial.x ^ 2 + Polynomial.x + 1 : Polynomial (Zmod 2)) ", "irreducible_x_pow_two_plus_x_plus_one : ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 → Irreducible (Polynomial.x^2 + Polynomial.x + 1) "]}
{"docString": "Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- Prove that $x^3 - 9$ is irreducible in $\\mathbb{F}_{31}$. -/\ntheorem", "choices": ["forall {x : Polynomial (Zmod 31)}, x = X ^ 3 - 9 → Irreducible x ", "irreducible_x_pow_sub_n_in_F_31 : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) ", "irreducible_x_pow_minus_nine_f31 : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) ", "forall {A : Type u_1} [inst : Field A] (x : A), Irreducible (Polynomial.x ^ 3 - 9) ", "∀ {F : Type u_1} [inst : Field F] [CharP F 31], Irreducible (Polynomial.x ^ 3 - 9 : Polynomial F) ", "irreducible_x_pow_sub {F : Type u_1} [inst : Field F] [inst_1 : CharZero F] (n : ℕ) (m : F) : 0 < n → Irreducible (Polynomial.x ^ n - Polynomial.c (m^n)) ", "x_pow_3_minus_9_irreducible : Irreducible (Polynomial.map (Int.castRingHom (Zmod 31)) (Polynomial.x ^ 3 - 9)) ", "∀ {F : Type u_1} [inst : Field F] [inst_1 : CharP F 31], Irreducible (Polynomial.x^3 - 9 : Polynomial F) ", "x_pow_3_minus_9_irreducible : Irreducible (Polynomial.map (Int.castRingHom (Zmod 31)) (Polynomial.x ^ 3 - 9)) ", "irreducible_x_pow_sub_nine : Irreducible (Polynomial.x ^ 3 - 9 : Polynomial (Zmod 31)) "]}
{"docString": "Prove that there are infinitely many primes congruent to $-1$ (modulo $4$).", "prompts": "[{\"theorem\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"}]\n", "prompt_cons": "/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- Prove that there are infinitely many primes congruent to $-1$ (modulo $4$). -/\ntheorem", "choices": ["Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ 3 [MOD 4]} ", "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 4]} "]}
{"docString": "Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ K → ↑(reflection Kᗮ) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `Kᗮ` of an element of `K` is its negation. \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\\n  a ≠ 0 → a * b = a * c → b = c\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication by a nonzero element is left cancellative. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(reflection K) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `K` of an element of `Kᗮ` is its negation. \"}]\n", "prompt_cons": "/-- The reflection in `Kᗮ` of an element of `K` is its negation. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ K → ↑(reflection Kᗮ) v = -v :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- Multiplication by a nonzero element is left cancellative. -/\ntheorem ∀ {M₀ : Type u} [inst : Mul M₀] [inst_1 : Zero M₀] [self : IsLeftCancelMulZero M₀] {a b c : M₀},\n  a ≠ 0 → a * b = a * c → b = c :=\n\n/-- The reflection in `K` of an element of `Kᗮ` is its negation. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, v ∈ Kᗮ → ↑(reflection K) v = -v :=\n\n/-- Let $K$ be a finite field. Prove that the product of the nonzero elements of $K$ is $-1$. -/\ntheorem", "choices": ["∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (1 : K)], (∏ x in (K)ᶜ {0}, x) = -1 ", "∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (1 : K)], (∏ x in (K \\ {0}), x) = -1 ", "∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : IsFinite K], \n  ∏ x in (Finset.erase (Finset.univ : Finset K) 0), x = -1 ", "∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : IsFiniteField K], \n  ∏ (x : K) in (finset.univ.filter (λ x, x ≠ 0)), x = -1 ", "∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : IsFinite K], \n  (∏ x in (K \\ {0}), x) = -1 ", "∀ (K : Type u_1) [inst : Field K] [inst_1 : Fintype K] [inst_2 : Nontrivial K], \n  ∏ x in (finset.univ.filter (λ x, x ≠ 0)), x = (-1 : K) ", "∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [_inst_1 : IsFinite K], ∏ (x : K) in (K \\ {0}), x = -1 ", "∀ {K : Type u} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Nontrivial K], (list.prod (list.erase (list.erase (finset.univ.val) 0) 1)).prod = -1 ", "∀ {K : Type u_1} [inst : Field K] [inst_1 : Fintype K] [inst_2 : Invertible (1 : K)], (∏ x in (K)ᶜ{0}, x) = -1 ", "∀ (K : Type u_1) [inst : Field K] [inst_1 : Fintype K] [inst_2 : IsFiniteField K], \n  ∏ x in (K.nonzero), x = -1 "]}
{"docString": "Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PartialOrder α] {f : β → β → α},\\n  (∀ (a b : β), f a b ≤ f b a) → ∀ (a b : β), f a b = f b a\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove commutativity of a binary operation `○`, we only to check `a ○ b ≤ b ○ a` for all `a`,\\n`b`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊓ a \\\\ b = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"For any `a`, `b`, `(a ⊓ b) ⊓ (a / b) = ⊥` \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.denominators g n = ppredB →\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"}]\n", "prompt_cons": "/-- To prove commutativity of a binary operation `○`, we only to check `a ○ b ≤ b ○ a` for all `a`,\n`b`. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PartialOrder α] {f : β → β → α},\n  (∀ (a b : β), f a b ≤ f b a) → ∀ (a b : β), f a b = f b a :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- For any `a`, `b`, `(a ⊓ b) ⊓ (a / b) = ⊥` -/\ntheorem ∀ {α : Type u} [self : GeneralizedBooleanAlgebra α] (a b : α), a ⊓ b ⊓ a \\ b = ⊥ :=\n\n/-- Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.denominators g n = ppredB →\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Prove the the operation $\\star$ on $\\mathbb{Z}$ defined by $a\\star b=a-b$ is not commutative. -/\ntheorem", "choices": ["not_commutative_star : ¬(∀ (a b : ℤ), a - b = b - a) ", "∀ (a b : ℤ), a - b ≠ b - a → ¬(∀ (a b : ℤ), a - b = b - a) ", "∀ {α : Type u} [inst : Ring α] {f : α → α → α},\n  (∃ (a b : α), f a b ≠ f b a) → ∀ (a b : α), f a b ≠ f b a ", "not_commutative : ¬ (∀ (a b : ℤ), a - b = b - a) ", "∀ {α : Type u} [inst : Sub α] [inst_1 : Neg α] [inst_2 : Ne α] {a b : α},\n  a ≠ b → a - b ≠ b - a ", "non_commutative_star : ¬(∀ (a b : ℤ), a - b = b - a) ", "∀ {a b : ℤ}, (a - b ≠ b - a) → (∃ a b : ℤ), a - b ≠ b - a ", "∀ {α : Type u} [inst : Sub α] [inst_1 : HasNeg α] {f : α → α → α},\n  (∃ (a b : α), f a b ≠ f b a) → ∀ (a b : α), f a b ≠ f b a ", "not_commutative : ¬(∀ (a b : ℤ), a - b = b - a) ", "not_commutative : ¬ (∀ (a b : ℤ), a - b = b - a) "]}
{"docString": "Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is associative \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w * y) (x * z)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is commutative. \"}]\n", "prompt_cons": "/-- Multiplication is associative -/\ntheorem ∀ {α : Type u} [self : NonUnitalSemiring α] (a b c : α), a * b * c = a * (b * c) :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y :=\n\n/-- Multiplicative congruence relations preserve multiplication. -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] (c : Con M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w * y) (x * z) :=\n\n/-- Multiplication is commutative. -/\ntheorem ∀ {α : Type u_1} [self : SeminormedCommRing α] (x y : α), x * y = y * x :=\n\n/-- Prove that the multiplication of residue class $\\mathbb{Z}/n\\mathbb{Z}$ is associative. -/\ntheorem", "choices": ["∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {n : ℕ} (a b c : Zmod n), a * b * c = a * (b * c) ", "∀ {α : Type u} [self : Ring α] (n : ℕ) (a b c : Zmod n), a * b * c = a * (b * c) "]}
{"docString": "Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ -(n + 1) = (a ^ (n + 1))⁻¹` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"}]\n", "prompt_cons": "/-- `a ^ -(n + 1) = (a ^ (n + 1))⁻¹` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (n : ℕ) (a : α),\n  LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a = (LinearOrderedCommGroupWithZero.zpow (↑(Nat.succ n)) a)⁻¹ :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- Proof of right inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Prove that $(a_1a_2\\dots a_n)^{-1} = a_n^{-1}a_{n-1}^{-1}\\dots a_1^{-1}$ for all $a_1, a_2, \\dots, a_n\\in G$. -/\ntheorem", "choices": ["forall {G : Type u} [self : Group G] (l : List G),\n  List.prod (List.map Group.inv (List.reverse l)) = Group.inv (List.prod l) ", "∀ {α : Type u} [self : Group α] (l : List α),\n  List.prod l⁻¹ = List.prod (List.map (λ a, a⁻¹) (List.reverse l)) ", "∀ {G : Type u} [self : Group G] (l : List G),\n  List.prod l⁻¹ = List.prod (List.map (λ a, a⁻¹) (List.reverse l)) ", "∀ {G : Type u} [self : Group G] (n : ℕ) (a : Vector G n),\n  (Vector.prod a)⁻¹ = Vector.prod (Vector.map (λ x, x⁻¹) (Vector.reverse a)) ", "∀ {G : Type u} [self : Group G] (l : List G),\n  List.prod l⁻¹ = List.prod (List.map (λ a, a⁻¹) (List.reverse l)) ", "∀ {α : Type u} [self : Group α] (a : List α),\n  List.prod a⁻¹ = List.prod (List.map Inv.inv (List.reverse a)) ", "∀ {α : Type u} [self : Group α] (l : List α),\n  List.prod (List.map (fun x => x⁻¹) (List.reverse l)) = (List.prod l)⁻¹ ", "∀ {α : Type u} [self : Group α] (a : List α),\n  (List.prod a)⁻¹ = List.prod (List.map (λ a_i, a_i⁻¹) (List.reverse a)) ", "∀ {G : Type u} [self : Group G] (l : List G),\n  List.prod (List.map Inv.inv (List.reverse l)) = Inv.inv (List.prod l) ", "∀ {G : Type u} [self : Group G] (L : List G),\n  (List.prod L)⁻¹ = List.prod (List.map (λ (a : G), a⁻¹) (List.reverse L)) "]}
{"docString": "Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x ≠ 0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n)\",\n  \"isProp\": true,\n  \"docString\": \"If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` \"}]\n", "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- By definition, if `x` is invertible then `inverse x = x⁻¹`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹ :=\n\n/-- If `n * x = 0`, but `n/p * x ≠ 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n :=\n\n/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n) :=\n\n/-- Let $x$ be an element of $G$. Prove that if $|x|=n$ for some positive integer $n$ then $x^{-1}=x^{n-1}$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) ", "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  orderOf x = n → x⁻¹ = x ^ (n - 1) ", "forall {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n  → x⁻¹ = x^(n - 1) ", "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) ", "forall {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) ", "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) ", "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) ", "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → (x⁻¹ = x ^ (n - 1)) ", "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) ", "∀ {G : Type u_1} [inst : Group G] {x : G} {n : ℕ},\n  0 < n → orderOf x = n → x⁻¹ = x ^ (n - 1) "]}
{"docString": "For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inverses of elements of finite additive order have finite additive order.\"}]\n", "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- Inverses of elements of finite additive order have finite additive order. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder x → IsOfFinAddOrder (-x) :=\n\n/-- For $x$ an element in $G$ show that $x$ and $x^{-1}$ have the same order. -/\ntheorem", "choices": ["forall {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "forall {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "forall {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "forall {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "forall {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "forall {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ ", "forall {G : Type u_1} [inst : Group G] {x : G}, orderOf x = orderOf x⁻¹ "]}
{"docString": "Deduce that $|a b|=|b a|$ for all $a, b \\in G$.", "prompts": "[{\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\": \"∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e\",\n  \"isProp\": true,\n  \"docString\": \"We have that `J(a^e | b) = J(a | b)^e`. \"}]\n", "prompt_cons": "/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem ∀ (a : ℤ) (e b : ℕ), jacobiSym (a ^ e) b = jacobiSym a b ^ e :=\n\n/-- Deduce that $|a b|=|b a|$ for all $a, b \\in G$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : HasAbs G] {a b : G}, abs (a * b) = abs (b * a) ", "∀ {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Mul G] {a b : G}, abs (a * b) = abs (b * a) ", "forall {G : Type u_1} [inst : Group G] {a b : G}, abs (a * b) = abs (b * a) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Mul G] {a b : G}, abs (a * b) = abs (b * a) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : HasAbs G] {a b : G}, abs (a * b) = abs (b * a) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {a b : G}, card (a * b) = card (b * a) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : AddGroup G] {a b : G}, abs (a * b) = abs (b * a) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Add G] {a b : G}, abs (a * b) = abs (b * a) ", "forall {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : One M₀] [self : MulOneClass M₀] [inst_2 : Mul M₀] [inst_3 : MulOneClass M₀] {a b : M₀}, a * b = b * a "]}
{"docString": "Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian.", "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"}]\n", "prompt_cons": "/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Prove that $A \\times B$ is an abelian group if and only if both $A$ and $B$ are abelian. -/\ntheorem", "choices": ["∀ {A : Type u} {B : Type v} [inst : AddGroup A] [inst_1 : AddGroup B],\n  AddGroup (A × B) ↔ (AddGroup A ∧ AddGroup B) ", "∀ {G H : Type u} [inst : Group G] [inst_1 : Group H], IsAbelian G → IsAbelian H → IsAbelian (G × H) ", "∀ {A B : Type u_1} [inst : AddGroup A] [inst_1 : AddGroup B],\n  AddGroup (A × B) ↔ AddGroup A ∧ AddGroup B ", "∀ {A : Type u} {B : Type v} [inst : AddGroup A] [inst_1 : AddGroup B],\n  AddGroup (A × B) ↔ (AddGroup A ∧ AddGroup B) ", "∀ {A : Type u_1} {B : Type u_2} [inst_1 : AddGroup A] [inst_2 : AddGroup B],\n  AddGroup (A × B) ↔ AddGroup A ∧ AddGroup B ", "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], IsAddGroup (G × H) ↔ (IsAddGroup G ∧ IsAddGroup H) ", "∀ {G H : Type} [inst : Group G] [inst_1 : Group H], IsAddGroup (G × H) ↔ IsAddGroup G ∧ IsAddGroup H ", "∀ {A B : Type u} [instA : AddGroup A] [instB : AddGroup B],\n  AddGroup (A × B) ↔ (AddGroup A ∧ AddGroup B) ", "∀ {A B : Type u} [inst : AddGroup A] [inst_1 : AddGroup B],\n  AddGroup (A × B) ↔ (AddGroup A ∧ AddGroup B) ", "∀ {A B : Type u} [inst : AddGroup A] [inst_1 : AddGroup B], AddGroup (A × B) ↔ AddGroup A ∧ AddGroup B "]}
{"docString": "Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : ℕ → Set α},\\n  ∑' (i : ℕ), ↑↑μ (s i) ≠ ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"One direction of the **Borel-Cantelli lemma**: if (sᵢ) is a sequence of sets such\\nthat `∑ μ sᵢ` is finite, then the limit superior of the `sᵢ` is a null set. \"}]\n", "prompt_cons": "/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x ∈ H } :=\n\n/-- One direction of the **Borel-Cantelli lemma**: if (sᵢ) is a sequence of sets such\nthat `∑ μ sᵢ` is finite, then the limit superior of the `sᵢ` is a null set. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : ℕ → Set α},\n  ∑' (i : ℕ), ↑↑μ (s i) ≠ ⊤ → ↑↑μ (Filter.limsup s Filter.atTop) = 0 :=\n\n/-- Prove that if $\\Omega=\\{1,2,3, \\ldots\\}$ then $S_{\\Omega}$ is an infinite group -/\ntheorem", "choices": ["∀ (α : Type u_1) [inst : Infinite α] [inst_1 : Fintype α] [Nonempty α], Group.Infinite (Equiv.Perm α) ", "∀ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], ¬ Fintype.card (SymGroup G) = 0 ", "∀ {α : Type u_1} [_inst_1 : Fintype α] [_inst_2 : Infinite α] [inst : Nonempty (Equiv.Perm α)],\n  Infinite { x // x ∈ Equiv.Perm α } ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), Infinite { x // x ∈ H } → Infinite G ", "∀ (α : Type u_1) [inst : Fintype α] [inst_1 : Infinite α], Infinite (Equiv.perm α) ", "∀ (Ω : Type u_1) [inst : Fintype Ω] [hΩ : Infinite Ω] [decidableEq Ω],\n  Infinite (Permutation Ω) ", "∀ {α : Type u_1} [Fintype α] [Infinite α], Infinite (SymmetricGroup α) ", "∀ {α : Type u_1} [hα : Fintype α] (g : ℕ → α) [inst : Infinite α] [inst_1 : Group (Equiv.Perm α)],\n  ∃ (P : Subgroup (Equiv.Perm α)), Infinite { x // x ∈ P } ", "∀ {Ω : Type u_1} [hΩ : Nonempty Ω] [inst : Infinite Ω] [h₁ : One ℕ < Fintype.card Ω],\n  Infinite (SymmetricGroup Ω) ", "∀ {α : Type u_1} [inst : Infinite α] [Fintype α], Infinite (perm α) "]}
{"docString": "Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$.", "prompts": "[{\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.continuants g n = ppred →\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"}]\n", "prompt_cons": "/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- If both `a` and `b` commute with `c`, then their product commutes with `c`. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.continuants g n = ppred →\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- Let $A$ and $B$ be groups. Prove that $A \\times B \\cong B \\times A$. -/\ntheorem", "choices": ["forall {A B : Type u_1} [instA : Group A] [instB : Group B], MulEquiv (A × B) (B × A) ", "∀ {A B : Type u_1} [inst_1 : Group A] [inst_2 : Group B],\n  Iso (A × B) (B × A) ", "∀ {A B : Type u_1} [instA : Group A] [instB : Group B],\n  IsGroupHom (λ (ab : A × B), (ab.2, ab.1)) →\n    A × B ≃ B × A ", "∀ {A B : Type u_1} [instA : Group A] [instB : Group B],\n  IsomorphicGroups (A × B) (B × A) ", "∀ {A B : Type u_1} [instA : Group A] [instB : Group B], IsGroupIsomorphism (λ (ab : A × B), (ab.2, ab.1)) ", "∀ {A B : Type u_1} [inst₁ : Group A] [inst₂ : Group B], \n  IsGroupHomomorphism (λ (ab : A × B), (ab.snd, ab.fst)) → \n    IsGroupIsomorphism (λ (ab : A × B), (ab.snd, ab.fst)) ", "∀ {A B : Type u_1} [instA : Group A] [instB : Group B],\n  Group.Isomorphic (A × B) (B × A) ", "∀ {A B : Type u_1} [instA : Group A] [instB : Group B], \n  IsGroupIso (Prod.swap : A × B → B × A) ", "∀ {A B : Type u_1} [instA : Group A] [instB : Group B],\n  IsGroupHomomorphism (λ (ab : A × B), (ab.2, ab.1)) →\n    IsGroupHomomorphism (λ (ba : B × A), (ba.2, ba.1)) →\n      Bijective (λ (ab : A × B), (ab.2, ab.1)) ", "∀ {A : Type u_1} {B : Type u_2} [inst_A : Group A] [inst_B : Group B],\n  Isomorphic (A × B) (B × A) "]}
{"docString": "Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian.", "prompts": "[{\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two `σ`-linear maps from `R` are equal on `1`, then they are equal. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformFun α G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. \"}]\n", "prompt_cons": "/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- If two `σ`-linear maps from `R` are equal on `1`, then they are equal. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} {M₃ : Type u_3} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : AddCommMonoid M₃]\n  [inst_3 : Module S M₃] {σ : R →+* S} {f g : R →ₛₗ[σ] M₃}, ↑f 1 = ↑g 1 → f = g :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. -/\ntheorem ∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun α G) :=\n\n/-- Let $G$ be a finite group which possesses an automorphism $\\sigma$ such that $\\sigma(g)=g$ if and only if $g=1$. If $\\sigma^{2}$ is the identity map from $G$ to $G$, prove that $G$ is abelian. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G] {σ : Aut G}, (∀ g : G, σ.to_fun g = g ↔ g = 1) → σ.to_fun ∘ σ.to_fun = id → IsCommGroup G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G]\n  {σ : G ≃* G}, (∀ g : G, σ g = g ↔ g = 1) → σ.trans σ = MulEquiv.refl G → IsCommutative G ", "∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite G] {σ : Aut G}, σ^2 = 1 → (∀ g, σ g = g ↔ g = 1) → IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G] {σ : Aut G}, (σ * σ = Aut.id) → (∀ g : G, σ g = g ↔ g = 1) → IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {σ : Aut G}, (∀ g : G, σ.to_fun g = g ↔ g = 1) → σ.to_fun ∘ σ.to_fun = id → IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {σ : Aut G},\n  (∀ g : G, σ.to_fun g = g ↔ g = 1) → σ.to_fun * σ.to_fun = id → IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G] {σ : Aut G},\n  (∀ g : G, σ g = g ↔ g = 1) → (∀ g : G, σ^2 g = g) → IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {σ : Aut G}, (∀ g : G, σ.to_fun g = g ↔ g = 1) → (σ * σ).to_fun = Aut.id.to_fun → IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {σ : G ≃* G}, (∀ g : G, σ g = g ↔ g = 1) → (σ * σ = Equiv.refl G) → IsCommutative G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {σ : MulAut G}, (∀ g : G, σ g = g ↔ g = 1) → σ.to_pow 2 = 1 → IsCommutative G "]}
{"docString": "Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G), Subsingleton (G ⧸ H) → H = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an additive subgroup gives a singleton then the additive subgroup\\nis the whole additive group.\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R), 0 ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"An additive submonoid contains `0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"An additive group homomorphism sends 0 to 0.\"}]\n", "prompt_cons": "/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem ∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤ :=\n\n/-- If the quotient by an additive subgroup gives a singleton then the additive subgroup\nis the whole additive group. -/\ntheorem ∀ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G), Subsingleton (G ⧸ H) → H = ⊤ :=\n\n/-- An additive submonoid contains `0`. -/\ntheorem ∀ {R : Type u} [inst : NonAssocSemiring R] (self : Subsemiring R), 0 ∈ self.carrier :=\n\n/-- An additive group homomorphism sends 0 to 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0 :=\n\n/-- Let $H$ be a subgroup of the additive group of rational numbers with the property that $1 / x \\in H$ for every nonzero element $x$ of $H$. Prove that $H=0$ or $\\mathbb{Q}$. -/\ntheorem", "choices": ["∀ {H : AddSubgroup ℚ}, (∀ x ∈ H, x ≠ 0 → 1 / x ∈ H) → H = ⊥ ∨ H = ⊤ ", "∀ {H : AddSubgroup ℚ}, (∀ x ∈ H, x ≠ 0 → 1 / x ∈ H) → H = ⊥ ∨ H = ⊤ ", "∀ {R : Type u} [inst : NonAssocSemiring R] (H : AddSubgroup R), (∀ x : R, x ≠ 0 → (1 / x) ∈ H) → H = ⊥ ∨ H = ⊤ ", "∀ {Q : Type u} [inst : AddGroup Q] (H : Subgroup Q), (∀ x ∈ H, x ≠ 0 → (1 / x) ∈ H) → H = ⊥ ∨ H = ⊤ ", "∀ {H : AddSubgroup ℚ}, (∀ x : ℚ, x ≠ 0 → x⁻¹ ∈ H) → H = ⊥ ∨ H = ⊤ ", "∀ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G) (h : ∀ (x : G), x ≠ 0 → (1 / x) ∈ H), H = ⊥ ∨ H = ⊤ ", "∀ {Q : Type u} [inst : Field Q] (H : AddSubgroup Q), (∀ x ∈ H, x ≠ 0 → 1 / x ∈ H) → H = ⊥ ∨ H = ⊤ ", "∀ {G : Type u} [inst : AddGroup G] (H : AddSubgroup G), (∀ x ∈ H, x ≠ 0 → (1 / x) ∈ H) → H = ⊥ ∨ H = ⊤ ", "∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β}, IsAddGroupHom f → f 0 = 0 ", "∀ {R : Type u} [inst : NonAssocSemiring R] (H : AddSubgroup R), (∀ x ∈ H, x ≠ 0 → (1 / x) ∈ H) → H = ⊥ ∨ H = ⊤ "]}
{"docString": "A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"}]\n", "prompt_cons": "/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- A subgroup $M$ of a group $G$ is called a maximal subgroup if $M \\neq G$ and the only subgroups of $G$ which contain $M$ are $M$ and $G$. Prove that if $H$ is a proper subgroup of the finite group $G$ then there is a maximal subgroup of $G$ containing $H$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [F : Fintype G] (H : Subgroup G), H ≠ ⊤ → ∃ M : Subgroup G, IsCoatom M ∧ H ≤ M ", "∀ {G : Type u_1} [inst : Group G] [fG : Fintype G] (H : Subgroup G), H ≠ ⊤ → ∃ M : Subgroup G, IsCoatom M ∧ H ≤ M ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H ≠ ⊤ → ∃ M : Subgroup G, IsCoatom M ∧ H ≤ M ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G) (hH : H ≠ ⊤),\n  ∃ M : Subgroup G, H ≤ M ∧ IsCoatom M ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G) (hH : H ≠ ⊤),\n  ∃ M : Subgroup G, IsMaximal M ∧ H ≤ M ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G),\n  H < Subgroup.top → ∃ M : Subgroup G, IsCoatom M ∧ H ≤ M ", "∀ {G : Type u_1} [inst : Group G] [fG : Fintype G] (H : Subgroup G), H ≠ ⊤ → ∃ M : Subgroup G, IsCoatom M ∧ H ≤ M ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G), H ≠ ⊤ → ∃ M : Subgroup G, IsCoatom M ∧ H ≤ M ", "∀ {G : Type u_1} [inst : Group G] [fG : Fintype G] (H : Subgroup G) (hH : H ≠ ⊤),\n  ∃ M : Subgroup G, H ≤ M ∧ IsCoatom M ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G),\n  H ≠ ⊤ → ∃ M : Subgroup G, IsCoatom M ∧ H ≤ M "]}
{"docString": "Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Show that if $G=\\langle x\\rangle$ is a cyclic group of order $n \\geq 1$ then a subgroup $H$ is maximal if and only $H=\\left\\langle x^{p}\\right\\rangle$ for some prime $p$ dividing $n$. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : orderOf x = n) (hn : 0 < n),\n  ∀ {H : Subgroup G}, (∃ {K : Subgroup G}, H < K) ↔\n    (∃ (p : ℕ) [_hp : Fact (Nat.Prime p)], p ∣ n ∧ H = Subgroup.zpowers (x ^ p)) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : ∀ y : G, ∃ m : ℕ, y = x ^ m) (hn : Fintype.card G = n) (hn_pos : 0 < n),\n  ∀ {H : Subgroup G}, H.is_maximal ↔ (∃ p [_hp : Fact (Nat.Prime p)], p ∣ n ∧ Fintype.card { x // x ∈ H } = p) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : generate (singleton x) = ⊤) (hn : Fintype.card G = n) (hn_pos : 0 < n),\n  ∀ (H : Subgroup G), is_maximal H ↔ (∃ p [_hp : Fact (Nat.Prime p)], p ∣ n ∧ Fintype.card { x // x ∈ H } = n / p) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : Subgroup.Zpowers x = ⊤) (hn : Fintype.card G = n),\n  (∀ {H : Subgroup G}, H.IsMaximal → ∃ p [hp : Fact (Nat.Prime p)], p ∣ n ∧ H = Subgroup.map ⟨x ^ p, pow_card_of_prime x p hp⟩ ⊤) ∧\n  (∀ p [hp : Fact (Nat.Prime p)], p ∣ n → Subgroup.IsMaximal (Subgroup.map ⟨x ^ p, pow_card_of_prime x p hp⟩ ⊤)) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : orderOf x = n),\n  1 ≤ n →\n    ∀ {H : Subgroup G}, H ≤ Subgroup.zpowers x →\n      (∃ K, K ≠ ⊤ ∧ H < K) ↔ (∃ p [_inst : Fact (Nat.Prime p)], p ∣ n ∧ H = Subgroup.zpowers (x ^ p)) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (x : G) {n : ℕ} (hx : orderOf x = n) (hn : 0 < n),\n  ∀ {H : Subgroup G}, (∃ p [_hp : Fact (Nat.Prime p)], Fintype.card {x // x ∈ H} = orderOf (x ^ p)) ↔\n    (∀ K : Subgroup G, H ≤ K → K = ⊤ ∨ ∃ q [_hq : Fact (Nat.Prime q)], Fintype.card {x // x ∈ K} = orderOf (x ^ q)) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : x ^ n = 1) (hn : 1 ≤ n) (H : Subgroup G),\n  (∀ (K : Subgroup G), H ≤ K → K = H ∨ K = ⊤) ↔\n  (∃ p [_hp : Fact (Nat.Prime p)], p ∣ n ∧ H = Subgroup.zpowers (x ^ (n / p))) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : orderOf x = n) (hn : n ≥ 1),\n  ∀ (H : Subgroup G), H ≤ Subgroup.zpowers x →\n    (∃ p [_hp : Fact (Nat.Prime p)], p ∣ n ∧ Fintype.card { y // y ∈ H } = p) ↔\n      (Subgroup.zpowers x ≤ H ∧ ∃! (K : Subgroup G), K ≤ Subgroup.zpowers x ∧ K ≠ H ∧ H ≤ K) ", "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {x : G} {n : ℕ} (hx : orderOf x = n) (hn : 1 ≤ n),\n  ∀ (H : Subgroup G), H.is_cyclic →\n    (∃ K : Subgroup G, K.is_maximal H) ↔ (∃ p [_hp : Fact (Nat.Prime p)], p ∣ n ∧ Subgroup.zpowers (x ^ p) = H) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (x : G) {n : ℕ} (hx : generatePowers x = ⊤) (hn : Fintype.card G = n) (hnpos : 0 < n),\n  ∀ (H : Subgroup G), is_maximal H ↔ (∃ p [_hp : Fact (Nat.Prime p)] (hpn : p ∣ n), H = Subgroup.map (pow x p) ⊤) "]}
{"docString": "Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"}]\n", "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Prove that if $H$ and $K$ are normal subgroups of a group $G$ then their intersection $H \\cap K$ is also a normal subgroup of $G$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H.subgroup_of K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) ", "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.Normal H → Subgroup.Normal K → Subgroup.Normal (H ⊓ K) "]}
{"docString": "Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K :=\n\n/-- Prove that if $H$ and $K$ are finite subgroups of $G$ whose orders are relatively prime then $H \\cap K=1$. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {H K : Subgroup G} [inst_2 : Fintype { x // x ∈ H }] [inst_3 : Fintype { x // x ∈ K }],\n  Nat.Coprime (Fintype.card { x // x ∈ H }) (Fintype.card { x // x ∈ K }) → ∀ x ∈ H ∩ K, x = 1 ", "forall {G : Type u_1} [inst : Group G] (H K : Subgroup G) [inst_1 : Fintype (Subgroup.Carrier H)] \n[inst_2 : Fintype (Subgroup.Carrier K)], Nat.Coprime (Fintype.card (Subgroup.Carrier H)) (Fintype.card (Subgroup.Carrier K)) → \n  Subgroup.carrier (Subgroup.inf H K) = {1} ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Finite {x // x ∈ H}] [inst_2 : Finite {x // x ∈ K}],\n  Nat.Coprime (Fintype.card { x // x ∈ H }) (Fintype.card { x // x ∈ K }) → Subgroup.intersection H K = ⊥ ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Finite { x // x ∈ H }] [inst_2 : Finite { x // x ∈ K }],\n  Nat.Coprime (Fintype.card { x // x ∈ H }) (Fintype.card { x // x ∈ K }) → ∀ x, x ∈ H ∩ K → x = 1 ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype (↥H)] [inst_2 : Fintype (↥K)],\n  Nat.Coprime (Fintype.card (↥H)) (Fintype.card (↥K)) → H ⊓ K = ⊥ ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Finite { x // x ∈ H }] [inst_2 : Finite { x // x ∈ K }],\n  Nat.Coprime (Fintype.card { x // x ∈ H }) (Fintype.card { x // x ∈ K }) → Subgroup.map (coe : H →* G) (Subgroup.comap (coe : K →* G) H) = ⊥ ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype (↥H)] [inst_2 : Fintype (↥K)],\n  Nat.Coprime (Fintype.card (↥H)) (Fintype.card (↥K)) → Subgroup.carrier (H ⊓ K) = {1} ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Finite { x // x ∈ H }] [inst_2 : Finite { x // x ∈ K }],\n  Nat.Coprime (Fintype.card { x // x ∈ H }) (Fintype.card { x // x ∈ K }) → ∀ x, x ∈ H ∩ K → x = 1 ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Finite { x // x ∈ H }] [inst_2 : Finite { x // x ∈ K }],\n  Nat.Coprime (Fintype.card { x // x ∈ H }) (Fintype.card { x // x ∈ K }) → ∀ x, x ∈ H ∩ K → x = 1 ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G} [inst_1 : Fintype (↥H)] [inst_2 : Fintype (↥K)],\nNat.Coprime (Fintype.card (↥H)) (Fintype.card (↥K)) → Subgroup.comap H.subtype (H ⊓ K) = ⊥ "]}
{"docString": "Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n", "prompt_cons": "/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Use Lagrange's Theorem in the multiplicative group $(\\mathbb{Z} / p \\mathbb{Z})^{\\times}$to prove Fermat's Little Theorem: if $p$ is a prime then $a^{p} \\equiv a(\\bmod p)$ for all $a \\in \\mathbb{Z}$. -/\ntheorem", "choices": ["∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "fermats_little_theorem : ∀ {p : ℕ} (hp : Nat.Prime p) {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "`¬ (p = 0) → ∀ (a : ℤ), a ^ p ≡ a [ZMOD p]` ", "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "forall {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] ", "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ℤ}, a ^ p ≡ a [ZMOD ↑p] "]}
{"docString": "Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"}]\n", "prompt_cons": "/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- Prove that if $H$ is a normal subgroup of $G$ of prime index $p$ then for all $K \\leq G$ either $K \\leq H$, or $G=H K$ and $|K: K \\cap H|=p$. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Subgroup.normal H),\n  Fintype.card (G ⧸ H) = p →\n    ∀ (K : Subgroup G), K ≤ H ∨ Fintype.card (G ⧸ K) = Fintype.card (G ⧸ H) * Fintype.card (K ⧸ (K ⊓ H)) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H K : Subgroup G},\n  Subgroup.normal H →\n    Fintype.card (G ⧸ H) = p →\n      K ≤ H ∨ (∃ L : Subgroup G, Fintype.card { x // x ∈ L } = p ∧ K ≤ L ∧ H ≤ L ∧ Subgroup.comap (Subgroup.subtype L) H = Subgroup.inf K H) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Subgroup.normal H),\n  Fintype.card (G ⧸ H) = p →\n    ∀ (K : Subgroup G), K ≤ H ∨ (Fintype.card ({x // x ∈ K} ⧸ {x // x ∈ H ∩ K}) = p ∧ Subgroup.comap (Subgroup.subtype K) H = Subgroup.comap (Subgroup.subtype K) (H⊓K)) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Subgroup.normal H),\n  Fintype.card (G ⧸ H) = p →\n    ∀ (K : Subgroup G), K ≤ H ∨ (∃ hK : Fintype.card (K ⧸ (K⊓H)) = p, G = H * K) ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G}\n  [hH : Subgroup.normal H] (h_card : Fintype.card (G ⧸ H) = p)\n  (K : Subgroup G), K ≤ H ∨ ∃ (h : Fintype.card (K ⧸ (K ⊓ H)) = p) (hG : G = H * K), Fintype.card (K ⧸ (K ⊓ H)) = p ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G} (hH : Subgroup.normal H),\n  Fintype.card (G ⧸ H) = p →\n    ∀ (K : Subgroup G), K ≤ H ∨ ∃ L : Subgroup G, Fintype.card { x // x ∈ L } = p ∧ H ⊓ K = L ", "forall {G : Type u} [group G] [fintype G] {p : ℕ} [fact (nat.prime p)] {H : subgroup G} (hH : H.normal),\n  fintype.card (G ⧸ H) = p →\n    ∀ (K : subgroup G), K ≤ H ∨ (∃ (h : fintype.card {x // x ∈ K} ∣ fintype.card G), H * K = ⊤ ∧ fintype.card (K ⧸ (H.subgroup_of K)) = p) ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H K : Subgroup G},\n  Subgroup.normal H →\n  Fintype.card (G ⧸ H) = p →\n    K ≤ H ∨ (∃ (h : G), Fintype.card (K ⧸ (K ⊓ H)) = p ∧ ∀ x : G, x ∈ H ∨ x ∈ K) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Subgroup.normal H → Fintype.card (G ⧸ H) = p →\n    ∀ (K : Subgroup G), K ≤ H ∨ (H * K = ⊤ ∧ Fintype.card (K ⧸ (K ⊓ H)) = p) ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {H K : Subgroup G},\n  Subgroup.normal H →\n  Fintype.card (G ⧸ H) = p →\n  K ≤ G →\n  (K ≤ H) ∨ (Fintype.card { x // x ∈ Subgroup.of_mul_image H K } = p ∧ Subgroup.is_complement' H K) "]}
{"docString": "Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"}]\n", "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- Use Cauchy's Theorem and induction to show that a finite abelian group has a subgroup of order $n$ for each positive divisor $n$ of its order. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ), n ∣ Fintype.card G → ∃ H : Subgroup G, Fintype.card H = n ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card (↥H) = n ", "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card H = n ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card (↥H) = n ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card H = n ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card (↥H) = n ", "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card (↥H) = n ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card (↥H) = n ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card (↥H) = n ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (n : ℕ),\n  n ∣ Fintype.card G → ∃ H : AddSubgroup G, Fintype.card (↥H) = n "]}
{"docString": "Prove that quotient groups of a solvable group are solvable.", "prompts": "[{\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\\n  ↑h (x / y) = ↑h x / ↑h y\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G ⧸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"}]\n", "prompt_cons": "/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A multiplicative equivalence of groups preserves division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x y : G),\n  ↑h (x / y) = ↑h x / ↑h y :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G ⧸ H) :=\n\n/-- Prove that quotient groups of a solvable group are solvable. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) ", "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : IsSolvable G],\n  IsSolvable (G ⧸ H) "]}
{"docString": "Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- Prove that if $H$ has finite index $n$ then there is a normal subgroup $K$ of $G$ with $K \\leq H$ and $|G: K| \\leq n!$. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  Fintype.card (G ⧸ H) = n → ∃ K : Subgroup G, K.normal ∧ H ≤ K ∧ Fintype.card (G ⧸ K) ≤ n ! ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  ∃ K : Subgroup G, K ≤ H ∧ K.normal ∧ Fintype.card (G ⧸ K) ≤ Fintype.card { x // x ∈ H } ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G) (n : ℕ),\n  Fintype.card (G ⧸ H) = n → ∃ K : Subgroup G, K ≤ H ∧ K.normal ∧ Fintype.card (G ⧸ K) ≤ n! ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ} {H : Subgroup G},\n  Fintype.card (G ⧸ H) = n → ∃ K : Subgroup G, K.normal ∧ H ≤ K ∧ Fintype.card (G ⧸ K) ≤ n.fact ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ} {H : Subgroup G},\n  Fintype.card (G ⧸ H) = n →\n    ∃ K : Subgroup G, K.normal ∧ K ≤ H ∧ Fintype.card (G ⧸ K) ≤ n! ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  ∃ K : Subgroup G, K ≤ H ∧ K.normal ∧ Fintype.card (G ⧸ K) ≤ Fintype.card { x // x ∈ H }! ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ} {H : Subgroup G},\n  Fintype.card (G ⧸ H) = n →\n    ∃ K : Subgroup.Normal G, K ≤ H ∧ Fintype.card (G ⧸ K) ≤ n! ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ} {H : Subgroup G},\n  Fintype.card (G ⧸ H) = n →\n    ∃ K : Subgroup G, K.normal ∧ K ≤ H ∧ Fintype.card (G ⧸ K) ≤ n.fact ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (H : Subgroup G),\n  let n ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  Fintype.card (G ⧸ H) < +∞ →\n  ∃ K : Subgroup G, K ≤ H ∧ Fintype.card { x // x ∈ K } ≤ Fintype.card (G ⧸ H)! "]}
{"docString": "Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"}]\n", "prompt_cons": "/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- Prove that if $p$ is a prime and $G$ is a group of order $p^{\\alpha}$ for some $\\alpha \\in \\mathbb{Z}^{+}$, then every subgroup of index $p$ is normal in $G$. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ α →\n  Fintype.card (G ⧸ H) = p → Subgroup.normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ α → Fintype.card (G ⧸ H) = p → Subgroup.normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ α → Fintype.card (G ⧸ H) = p → Subgroup.normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ α →\n    Fintype.card (G ⧸ H) = p →\n      Subgroup.normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ α → Fintype.card (G ⧸ H) = p → Subgroup.normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ α →\n    Fintype.card (G ⧸ H) = p → Subgroup.normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ α →\n    Fintype.card (G ⧸ H) = p → Subgroup.Normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ n →\n  Fintype.card (G ⧸ H) = p →\n  H.normal ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ α →\n  Fintype.card (G ⧸ H) = p →\n  Subgroup.normal H ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p α : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ α → Fintype.card (G ⧸ H) = p → Subgroup.Normal H "]}
{"docString": "Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n", "prompt_cons": "/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Prove that if $G$ is an abelian group of order $p q$, where $p$ and $q$ are distinct primes, then $G$ is cyclic. -/\ntheorem", "choices": ["∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)] [inst_3 : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G ", "∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card α = p * q → IsAddCyclic α ", "∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G ", "∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G ", "∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)]\n  (h_card : Fintype.card G = p * q), IsAddCyclic G ", "∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G ", "∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G ", "∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G ", "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G ", "∀ {p q : ℕ} {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p * q → IsAddCyclic G "]}
{"docString": "Prove that there exists a normal subgroup that is not characteristic.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"}]\n", "prompt_cons": "/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1 :=\n\n/-- Prove that there exists a normal subgroup that is not characteristic. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Nontrivial G], ∃ (H : Subgroup G), H.normal ∧ ¬ H.char ", "∀ {G : Type u_1} [inst : Group G], ∃ (H : Subgroup G), H.normal ∧ ¬Subgroup.IsChar H ", "∀ {G : Type u_1} [inst : Group G] (N : Subgroup.Normal G), N ≠ ⊥ → ∃ (H : Subgroup.Normal G), H ≠ ⊥ ∧ H ≠ N ", "∀ {G : Type u_1} [inst : Group G], ∃ (N : Subgroup G), Subgroup.Normal N ∧ ¬Subgroup.IsCharacteristic G N ", "∀ {G : Type u_1} [inst : Group G], ∃ N : Subgroup G, N.normal ∧ ¬N.char_subgroup ", "∀ {G : Type u_1} [inst : Group G], ∃ N : Subgroup G, Subgroup.Normal N ∧ ¬Subgroup.Characteristic N ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Nontrivial G], ∃ N : Subgroup G, N.normal ∧ (∀ (φ : G ≃* G), ¬(φ '' N = N)) ", "∀ {G : Type u_1} [inst : Group G], ∃ (N : Subgroup G), N.normal ∧ ¬Subgroup.IsCharacteristic N ", "∀ {G : Type u_1} [inst : Group G], ∃ (N : Subgroup G) [h : N.normal], ¬Subgroup.IsChar N ", "∀ {G : Type u_1} [inst : Group G], ∃ H : Subgroup G, Subgroup.Normal H ∧ ¬Group.CharSubgroup G H "]}
{"docString": "Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schur-Zassenhaus** for normal subgroups:\\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\\nsubgroup `K` which is a (left) complement of `H`. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- **Schur-Zassenhaus** for normal subgroups:\nIf `H : Subgroup G` is normal, and has order coprime to its index, then there exists a\nsubgroup `K` which is a (left) complement of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {N : Subgroup G} [inst_2 : Subgroup.Normal N],\n  Nat.coprime (Fintype.card { x // x ∈ N }) (Subgroup.index N) → ∃ H, Subgroup.IsComplement' H N :=\n\n/-- Let $G$ be a group with subgroups $H$ and $K$ with $H \\leq K$. Prove that if $H$ is characteristic in $K$ and $K$ is normal in $G$ then $H$ is normal in $G$. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsChar H K → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsCharacteristic H K → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsCharSubgroup K H → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsCharacteristic H K → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.Char H K → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsCharacteristic K H → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Subgroup.IsChar H K → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  H ≤ K → Subgroup.char_in H K → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Subgroup.charachteristic H K → Subgroup.Normal K → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},\n  Subgroup.CharSub H K → Subgroup.Normal K → Subgroup.Normal H "]}
{"docString": "Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"}]\n", "prompt_cons": "/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- Prove that a group of order 56 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 56 → ∃ p K, Fact (Nat.Prime p) ∧ p ∣ 56 ∧ IsPGroup p { x // x ∈ K } ∧ Subgroup.normal K ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  (∃ p, Fact (Nat.Prime p) ∧ p ∣ Fintype.card G) →\n    ∃ P : Subgroup G, Subgroup.normal P ∧\n      IsPGroup p { x // x ∈ P } ∧ Fintype.card { x // x ∈ P } ∣ Fintype.card G ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], \n  Fintype.card G = 56 → ∃ p [hp : Fact (Nat.Prime p)], ∃ P : Sylow p G, Subgroup.normal P ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 → ∃ p, ∃ [hp : Fact (Nat.Prime p)], ∃ P : Sylow p G, ∀ Q : Sylow p G, P = Q ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 → ∃ p [hp : Fact (Nat.Prime p)], ∃ H : Sylow p G, H.normal ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 → ∃ p [hp : Fact (Nat.Prime p)] (P : Sylow p G), IsNormalSubgroup P ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 56 → ∃ p [Fact (Nat.Prime p)], ∃ P : Sylow p G, Subgroup.normal (coe P) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 56 → ∃ p [Fact (Nat.Prime p)], ∃ P : Sylow p G, Subgroup.normal ↑P ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 56 →\n  ∃ p [hp : Fact (Nat.Prime p)] (P : Sylow p G), Subgroup.normal (coe P) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 56 → ∃ p [hp : Fact (Nat.Prime p)], ∃ P : Sylow p G, P.normal "]}
{"docString": "Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"}]\n", "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- Prove that a group of order 351 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem", "choices": ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 351),\n  ∃ {p : ℕ} (K : Sylow p G), Fact (Nat.Prime p) ∧ p ∣ 351 ∧ Subgroup.normal ↑K ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 → ∃ (p : ℕ) [Fact (Nat.Prime p)] (P : Sylow p G), Subgroup.normal (subtype.val P) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 → ∃ p [inst_2 : Fact (Nat.Prime p)], ∃ K : Sylow p G, ∀ Q, Q.to_subgroup.normal ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 351 → ∃ p (H : Fact (Nat.Prime p)) (N : Sylow p G), Subgroup.normal (coe N) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 → ∃ p [inst_2 : Fact (Nat.Prime p)], ∃ P : Sylow p G, IsNormalSubgroup P ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 → ∃ p, Fact (Nat.Prime p) ∧ ∃ P : Sylow p G, IsNormal P ", "∀ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 → ∃ (p : ℕ) (P : Sylow p G), IsNormal (↑P : Subgroup G) ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 → ∃ p [Fact (Nat.Prime p)], ∃ K : Sylow p G, Sylow.normal K ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 → ∃ (p : ℕ) [inst_2 : Fact (Nat.Prime p)], ∃ (P : Sylow p G), Subgroup.normal ↑P ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 351 → ∃ p [Fact (Nat.Prime p)] (P : Sylow p G),\n  Subgroup.Normal (coe P) "]}
{"docString": "Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\\n      Nonempty\\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"}]\n", "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\n      Nonempty\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)] :=\n\n/-- Prove that if $|G|=105$ then $G$ has a normal Sylow 5 -subgroup and a normal Sylow 7-subgroup. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P5 : Sylow 5 G), Subgroup.Normal ↑P5 ∧ ∃ (P7 : Sylow 7 G), Subgroup.Normal ↑P7) ", "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P : Sylow 5 G), Subgroup.Normal ↑P) ∧ (∃ (Q : Sylow 7 G), Subgroup.Normal ↑Q) ", "forall {G : Type u_1} [hG : Group G] [inst : Fintype G] (h_card : Fintype.card G = 105),\n  (∃ (P : Sylow 5 G), Subgroup.Normal ↑P) ∧ (∃ (Q : Sylow 7 G), Subgroup.Normal ↑Q) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P_5 : Sylow 5 G), Subgroup.Normal ↑P_5) ∧ (∃ (P_7 : Sylow 7 G), Subgroup.Normal ↑P_7) ", "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G] (hcard : Fintype.card G = 105),\n  (∃ (P5 : Sylow 5 G), Subgroup.Normal ↑P5) ∧ (∃ (P7 : Sylow 7 G), Subgroup.Normal ↑P7) ", "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P5 : Sylow 5 G), Subgroup.Normal (↑P5)) ∧\n    (∃ (P7 : Sylow 7 G), Subgroup.Normal (↑P7)) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n  (∃ (P5 : Sylow 5 G), Subgroup.Normal ↑P5) ∧ (∃ (P7 : Sylow 7 G), Subgroup.Normal ↑P7) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P : Sylow 5 G), Subgroup.Normal ↑P) ∧ (∃ (Q : Sylow 7 G), Subgroup.Normal ↑Q) ", "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P : Sylow 5 G), Subgroup.Normal ↑P) ∧ (∃ (Q : Sylow 7 G), Subgroup.Normal ↑Q) ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (N_5 : Sylow 5 G), Subgroup.Normal ↑N_5) ∧ (∃ (N_7 : Sylow 7 G), Subgroup.Normal ↑N_7) "]}
{"docString": "Prove that if $|G|=6545$ then $G$ is not simple.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"}]\n", "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Prove that if $|G|=6545$ then $G$ is not simple. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 6545 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] (hSize : Fintype.card G = 6545),\n  ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 6545 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] (hG : Fintype.card G = 6545), ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6545 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G], Fintype.card G = 6545 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 6545 → ¬IsSimpleGroup G "]}
{"docString": "Prove that if $|G|=2907$ then $G$ is not simple.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"}]\n", "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- Prove that if $|G|=2907$ then $G$ is not simple. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [hN : Fintype G] (hG : Fintype.card G = 2907), ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 2907 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G], card G = 2907 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] (hG : Fintype.card G = 2907), ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 2907 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 2907 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G] (hG : Fintype.card G = 2907), ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], order_of G = 2907 → ¬IsSimpleGroup G "]}
{"docString": "Prove that if $|G|=462$ then $G$ is not simple.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"}]\n", "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G :=\n\n/-- Prove that if $|G|=462$ then $G$ is not simple. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 462 → ¬IsSimpleGroup G ", "forall {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 462 → ¬IsSimpleGroup G ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G],\n  Fintype.card G = 462 → \n    ¬IsSimpleGroup G "]}
{"docString": "Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$.", "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"}]\n", "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- Let $P$ be a normal Sylow $p$-subgroup of $G$ and let $H$ be any subgroup of $G$. Prove that $P \\cap H$ is the unique Sylow $p$-subgroup of $H$. -/\ntheorem", "choices": ["∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } →\n  (∀ {H : Subgroup G}, P.normal → ∃! Q, IsPGroup p { y // y ∈ Q } ∧ P ⊓ H = Q) ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) (P : Subgroup G),\n  IsPGroup p { x // x ∈ P } → P.normal →\n    (∀ Q : Subgroup {x // x ∈ H}, IsPGroup p {x // x ∈ Q} → {x // x ∈ P} ≤ Q) ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} (hP : P.is_p_group p),\n  Subgroup.normal P →\n    ∀ (H : Subgroup G),\n      ∃! Q : Sylow p { x // x ∈ H }, P ⊓ H = ↑Q ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsPGroup p { x // x ∈ P } →\n  P.normal →\n  ∃! Q : Sylow p { x // x ∈ H }, P ⊓ H = ↑Q ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsPGroup p { x // x ∈ P } → P.normal →\n  (∃! Q : Sylow p { x // x ∈ H }, P ⊓ H = ↑Q) ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} [_inst_2 : Fact (Nat.Prime p)] (H : Subgroup G),\n  IsPGroup p { x // x ∈ P } → P.normal →\n    ∃! Q : Sylow p { x // x ∈ H }, P ⊓ H = ↑Q ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → P.normal →\n  ∀ (H : Subgroup G), ∃! Q : Sylow p { x // x ∈ H }, P ⊓ H = ↑Q ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsNormal P → IsPGroup p { x // x ∈ P } → Sylow p { x // x ∈ H } → P ⊓ H = ↑Sylow p { x // x ∈ H } ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} (hp : IsPGroup p { x // x ∈ P }) (hP : Subgroup.Normal P)\n  {H : Subgroup G}, ∃! Q : Sylow p { x // x ∈ H }, P ⊓ H = ↑Q ", "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G} {H : Subgroup G},\n  IsSylow p P → Subgroup.normal P →\n    (∃ Q : Sylow p { x // x ∈ H }, Subgroup.comap P.val Q = P ⊓ H) ∧ ∀ Q : Sylow p { x // x ∈ H }, Subgroup.comap P.val Q = P ⊓ H "]}
{"docString": "Prove that if $u$ is a unit in $R$ then so is $-u$.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {n : ℕ} (u : Rˣ),\\n  IsUnit ↑n → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C ↑u)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `IsUnit n` in a `CommRing R`, then `X ^ n - u` is separable for any unit `u`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (u : Rˣ), ↑u < 0 → ∀ (v : Module.Ray R M), u • v = -v\",\n  \"isProp\": true,\n  \"docString\": \"Scaling by a negative unit is negation. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"}]\n", "prompt_cons": "/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b :=\n\n/-- If `IsUnit n` in a `CommRing R`, then `X ^ n - u` is separable for any unit `u`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {n : ℕ} (u : Rˣ),\n  IsUnit ↑n → Polynomial.Separable (Polynomial.X ^ n - ↑Polynomial.C ↑u) :=\n\n/-- Scaling by a negative unit is negation. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (u : Rˣ), ↑u < 0 → ∀ (v : Module.Ray R M), u • v = -v :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Prove that if $u$ is a unit in $R$ then so is $-u$. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-u) ", "∀ {R : Type u} [inst : Ring R] (u : Rˣ), IsUnit (-↑u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-↑u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-↑u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-↑u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (- ↑u) ", "∀ {R : Type u} [inst : CommRing R] (u : Rˣ), IsUnit (-↑u) "]}
{"docString": "Prove that any subring of a field which contains the identity is an integral domain.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multivariate polynomial ring over an integral domain is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K],\\n  ⨅ (v : PrimeSpectrum R),\\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\\n    ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An integral domain is equal to the intersection of its localizations at all its prime ideals\\nviewed as subalgebras of its field of fractions. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"}]\n", "prompt_cons": "/-- The multivariate polynomial ring over an integral domain is an integral domain. -/\ntheorem ∀ {R : Type u} {σ : Type v} [inst : CommRing R] [inst_1 : IsDomain R], IsDomain (MvPolynomial σ R) :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- An integral domain is equal to the intersection of its localizations at all its prime ideals\nviewed as subalgebras of its field of fractions. -/\ntheorem ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type v) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K],\n  ⨅ (v : PrimeSpectrum R),\n      Localization.subalgebra.ofField K (Ideal.primeCompl v.asIdeal)\n        (_ : Ideal.primeCompl v.asIdeal ≤ nonZeroDivisors R) =\n    ⊥ :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- Prove that any subring of a field which contains the identity is an integral domain. -/\ntheorem", "choices": ["∀ {K : Type u} [inst : Field K] (R : Subring K), (1 : K) ∈ R → IsDomain R ", "∀ (K : Type u) [inst : Field K] (R : Subring K) (one_mem : 1 ∈ R), IsDomain R ", "∀ {K : Type u} [inst : Field K] (R : Subring K), (1 : K) ∈ R.toSubmonoid → IsDomain R ", "∀ {K : Type u} [inst : Field K] (S : Subring K), One.one ∈ S → IsDomain S ", "∀ {K : Type u_1} [inst : Field K] (R : Subring K), (∃ x : R, x ≠ 0) → IsDomain R ", "∀ {K : Type u} [inst : Field K] (R : Subring K), (1 : K) ∈ R → IsDomain R ", "∀ (K : Type u) [inst : Field K] (R : Subring K) (h : (1 : K) ∈ R), IsDomain R ", "∀ {K : Type u} [inst : Field K] (R : Subring K), Subring.one_mem R → IsDomain (↥R) ", "∀ {K : Type u} [inst : Field K] (R : Subring K) (h_one_mem : (1 : K) ∈ R), IsDomain R ", "∀ {K : Type u} [inst : Field K] (R : Subring K), (1 : K) ∈ R → IsDomain R "]}
{"docString": "Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\\n`(X - a) ^ n` divides `p`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\\n  P ≠ ⊥ →\\n    (∀ (x : R), ↑Polynomial.C x ∈ P → x = 0) →\\n      ∃ p, p ∈ P ∧ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"This technical lemma asserts the existence of a polynomial `p` in an ideal `P ⊂ R[x]`\\nthat is non-zero in the quotient `R / (P ∩ R) [x]`.  The assumptions are equivalent to\\n`P ≠ 0` and `P ∩ R = (0)`.\\n\"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p ≠ 1`. \"}]\n", "prompt_cons": "/-- The multiplicity of `a` as root of a nonzero polynomial `p` is at least `n` iff\n`(X - a) ^ n` divides `p`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → ∀ {a : R} {n : ℕ}, n ≤ Polynomial.rootMultiplicity a p ↔ (Polynomial.X - ↑Polynomial.C a) ^ n ∣ p :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0 :=\n\n/-- This technical lemma asserts the existence of a polynomial `p` in an ideal `P ⊂ R[x]`\nthat is non-zero in the quotient `R / (P ∩ R) [x]`.  The assumptions are equivalent to\n`P ≠ 0` and `P ∩ R = (0)`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal (Polynomial R)},\n  P ≠ ⊥ →\n    (∀ (x : R), ↑Polynomial.C x ∈ P → x = 0) →\n      ∃ p, p ∈ P ∧ Polynomial.map (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)) p ≠ 0 :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p ≠ 1`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1 :=\n\n/-- Let $p(x)=a_{n} x^{n}+a_{n-1} x^{n-1}+\\cdots+a_{1} x+a_{0}$ be an element of the polynomial ring $R[x]$. Prove that $p(x)$ is a zero divisor in $R[x]$ if and only if there is a nonzero $b \\in R$ such that $b p(x)=0$. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  (∃ (b : R), b ≠ 0 ∧ b • p = 0) ↔ p * q = 0 ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  (∃ (a : R), a ≠ 0 ∧ a • p = 0) ↔ p ∣ 0 ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p * 0 = 0 → (∃ b : R, b ≠ 0 ∧ (Polynomial.C b) * p = 0) ↔ p = 0 ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p * q = 0 ↔ ∃ b : R, b ≠ 0 ∧ b * p = 0 ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p * 0 = 0 → (∃ b : R, b ≠ 0 ∧ (Polynomial.C b) * p = 0) ↔ p ≠ 0 → p * (Polynomial.C 0) ≠ 0 ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p * q = 0 ↔ (∃ (b : R), b ≠ 0 ∧ b * p = 0) ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → (∃ (b : R), b ≠ 0 ∧ b • p = 0) ↔ p * Polynomial.X ≠ p ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  (∃ (b : R), b ≠ 0 ∧ b • p = 0) ↔ p * q = 0 ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p * q = 0 ↔ (∃ (b : R), b ≠ 0 ∧ Polynomial.smul b p = 0) ", "∀ {R : Type u} [inst : CommRing R] {p : Polynomial R},\n  p ≠ 0 → (∃ (b : R), b ≠ 0 ∧ b • p = 0) ↔ p * Polynomial.X ≠ p "]}
{"docString": "Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$.", "prompts": "[{\"theorem\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ↑σ\",\n  \"isProp\": true,\n  \"docString\": \"The ring homomorphism is surjective \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S),\\n  Function.Surjective ↑f → IsLocalRingHom f → Function.Surjective ↑(Units.map ↑f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : R →+* S` is a surjective local ring hom, then the induced units map is surjective. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (↑f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subsemiring generated by a set equals\\nthe subsemiring generated by the image of the set. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) (s : Set R),\\n  Subring.map f (Subring.closure s) = Subring.closure (↑f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under a ring homomorphism of the subring generated by a set equals\\nthe subring generated by the image of the set. \"}]\n", "prompt_cons": "/-- The ring homomorphism is surjective -/\ntheorem ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\n  [self : RingHomSurjective σ], Function.Surjective ↑σ :=\n\n/-- If `f : R →+* S` is a surjective local ring hom, then the induced units map is surjective. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S),\n  Function.Surjective ↑f → IsLocalRingHom f → Function.Surjective ↑(Units.map ↑f) :=\n\n/-- The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}\n  [inst_2 : NonUnitalRingHomClass F R S] (f : F) (s : Set R),\n  NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s) = NonUnitalSubsemiring.closure (↑f '' s) :=\n\n/-- The image under a ring homomorphism of the subring generated by a set equals\nthe subring generated by the image of the set. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) (s : Set R),\n  Subring.map f (Subring.closure s) = Subring.closure (↑f '' s) :=\n\n/-- Let $\\varphi: R \\rightarrow S$ be a surjective homomorphism of rings. Prove that the image of the center of $R$ is contained in the center of $S$. -/\ntheorem", "choices": ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (φ : R →+* S),\n  Function.Surjective ↑φ → (↑φ '' (Subring.center R)) ⊆ Subring.center S ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Surjective ↑f → ∀ (x : R), x ∈ Subring.center R → ↑f x ∈ Subring.center S ", "∀ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] {σ : R →+* S},\n  Function.Surjective ↑σ → IsSubring (Center R) → ∀ x : R, x ∈ Center R → (σ x) ∈ Center S ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Surjective ↑f → ∀ (x : R), IsCentralScalar R x → IsCentralScalar S (↑f x) ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Surjective ↑f → ∀ (a : R), HasMem.Mem a (Center R) → HasMem.Mem (↑f a) (Center S) ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Surjective ↑f → (∀ (r : R), (HasMem.Mem r (Subring.center R)) → (HasMem.Mem (f r) (Subring.center S))) ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Surjective ↑f → (∀ r : R, ∀ s : R, r * s = s * r) → ∀ s' : S, ∃ r : R, ↑f r = s' → ∀ s : S, s' * s = s * s' ", "∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {σ : R →+* S}\n  [self : RingHomSurjective σ], (↑σ '' Subring.center R) ⊆ Subring.center S ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Surjective ↑f → ∀ (x : R), HasMem.Mem x (Center R) → HasMem.Mem (coeFn f x) (Center S) ", "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Surjective ↑f → ∀ (x : R), x ∈ Subring.center R → ↑(f x) ∈ Subring.center S "]}
{"docString": "Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\\nnilpotent, then `P` is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\\nexcept its constant term which is a unit. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\\nnilpotent, except its constant term which is a unit. \"}]\n", "prompt_cons": "/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b :=\n\n/-- Let `P` be a polynomial over `R`. If its constant term is a unit and its other coefficients are\nnilpotent, then `P` is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit (Polynomial.coeff P 0) → (∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i)) → IsUnit P :=\n\n/-- Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {P : Polynomial R},\n  IsUnit P → IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- Let `P` be a polynomial over `R`. `P` is a unit if and only if all its coefficients are\nnilpotent, except its constant term which is a unit. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Polynomial R),\n  IsUnit P ↔ IsUnit (Polynomial.coeff P 0) ∧ ∀ (i : ℕ), i ≠ 0 → IsNilpotent (Polynomial.coeff P i) :=\n\n/-- Let $R$ be a commutative ring with $1 \\neq 0$. Prove that if $a$ is a nilpotent element of $R$ then $1-a b$ is a unit for all $b \\in R$. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] [nontrivial : ¬(0 : R) = 1] {a b : R},\n  IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R] {a : R}, IsNilpotent a → ∀ (b : R), IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] [NontrivialDomain R] {a b : R},\n  IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] [zero_ne_one : Zero.ne One.one] {a b : R},\n  IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] {a b : R}, IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] [nontrivial R] {a b : R}, IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] [inst2 : Nontrivial R] {a b : R}, IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] (a b : R), IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] [Nontrivial R] {a b : R}, IsNilpotent a → IsUnit (1 - a * b) ", "∀ {R : Type u} [inst : CommRing R] [Nontrivial R] {a b : R}, IsNilpotent a → IsUnit (1 - a * b) "]}
{"docString": "Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R], UniqueFactorizationMonoid R\",\n  \"isProp\": true,\n  \"docString\": \"A principal ideal domain has unique factorization \"},\n {\"theorem\":\n  \"∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\\n  ¬IsField A →\\n    ∀ {I : Ideal A},\\n      I ≠ ⊥ →\\n        ∃ Z,\\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"}]\n", "prompt_cons": "/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P) :=\n\n/-- A principal ideal domain has unique factorization -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsPrincipalIdealRing R], UniqueFactorizationMonoid R :=\n\n/-- In a noetherian integral domain which is not a field, every non-zero ideal contains a non-zero\nproduct of prime ideals; in a field, the whole ring is a non-zero ideal containing only 0 as\nproduct or prime ideals ([samuel, § 3.3, Lemma 3]) -/\ntheorem ∀ {A : Type u} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : IsNoetherianRing A],\n  ¬IsField A →\n    ∀ {I : Ideal A},\n      I ≠ ⊥ →\n        ∃ Z,\n          Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I ∧\n            Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≠ ⊥ :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- Let $R$ be an integral domain. Prove that if the following two conditions hold then $R$ is a Principal Ideal Domain: (i) any two nonzero elements $a$ and $b$ in $R$ have a greatest common divisor which can be written in the form $r a+s b$ for some $r, s \\in R$, and (ii) if $a_{1}, a_{2}, a_{3}, \\ldots$ are nonzero elements of $R$ such that $a_{i+1} \\mid a_{i}$ for all $i$, then there is a positive integer $N$ such that $a_{n}$ is a unit times $a_{N}$ for all $n \\geq N$. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ (a b : R), a ≠ 0 → b ≠ 0 → ∃ r s, IsGreatestCommonDivisor r a b ∧ r = s * a + t * b) →\n  (∀ (a : ℕ → R), (∀ i, a i ≠ 0) → (∀ i, a (i + 1) ∣ a i) → ∃ N, ∀ n ≥ N, ∃ u, a n = u * a N) →\n    IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ (a b : R), a ≠ 0 → b ≠ 0 → ∃ r s, ((Ideal.span {a, b}) = Ideal.span {r * a + s * b})) ∧\n  (∀ (f : ℕ → R), (∀ i, f (i+1) ∣ f i) → ∃ N, ∀ n ≥ N, ∃ u, is_unit u ∧ (f n = u * f N)) →\n    IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ (a b : R), a ≠ 0 → b ≠ 0 → ∃ (gcd : R), ∃ (r s : R), gcd = r * a + s * b) →\n  (∀ (a : ℕ → R), (∀ i, a (i + 1) ∣ a i) → ∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → ∃ (u : R), a n = u * a N) →\n    IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], \n  (∀ a b : R, a ≠ 0 → b ≠ 0 → ∃ r s, IsGCD (r * a + s * b) (a * b)) → \n  (∀ (a : ℕ → R), (∀ i, a (i + 1) ∣ a i) → ∃ N, ∀ n ≥ N, ∃ u, Associated (a n) (u * a N)) → \n  IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ a b : R, a ≠ 0 → b ≠ 0 → ∃ r s, gcd a b = r * a + s * b) →\n  (∀ (a : ℕ → R), (∀ i, a (i + 1) ∣ a i) → ∃ N, ∀ n, n ≥ N → ∃ u, a n = u * a N) →\n    IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ a b : R, a ≠ 0 → b ≠ 0 → ∃ r s, r * a + s * b = Gcd a b) →\n  (∀ f : ℕ → R, (∀ i, f i ≠ 0) → (∀ i, f (i + 1) ∣ f i) → ∃ N, ∀ n, Associated (f n) (f N)) →\n  IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ a b : R, a ≠ 0 → b ≠ 0 → ∃ r s d, a * r + b * s = d ∧ Ideal.gcd a b ≤ Ideal.span {d}) ∧\n  (∀ (a : ℕ → R), (∀ i, a i ≠ 0) → (∀ i, a (i + 1) ∣ a i) → ∃ N, ∀ n ≥ N, a n ∣ a N) →\n    IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ (a b : R), a ≠ 0 → b ≠ 0 → ∃ (r s : R), EuclideanDomain.gcd a b = r * a + s * b) →\n  (∀ (a : ℕ → R), (∀ (i : ℕ), a (i + 1) ∣ a i) → ∃ (N : ℕ), ∀ (n : ℕ), n ≥ N → IsUnit (a n)) →\n  IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ a b : R, a ≠ 0 → b ≠ 0 → ∃ r s, gcd a b = r * a + s * b) →\n  (∀ (f : ℕ → R), (∀ i, f i ≠ 0) → (∀ i, f (i + 1) ∣ f i) → ∃ N, ∀ n ≥ N, IsUnit (f n) ∨ f N = 0) →\n    IsPrincipalIdealRing R ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], \n  (∀ a b : R, a ≠ 0 → b ≠ 0 → ∃ r s, IsGreatestCommonDivisor (r * a + s * b) a b) →\n  (∀ (a : ℕ → R), (∀ i, a (i + 1) ∣ a i) → ∃ N, ∀ n ≥ N, ∃ u, a n = u * a N) → \n    IsPrincipalIdealRing R "]}
{"docString": "Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$.", "prompts": "[{\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"}]\n", "prompt_cons": "/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- Let $R=\\mathbb{Z}[\\sqrt{-n}]$ where $n$ is a squarefree integer greater than 3. Prove that $2, \\sqrt{-n}$ and $1+\\sqrt{-n}$ are irreducibles in $R$. -/\ntheorem", "choices": ["∀ {n : ℕ}, Nat.squarefree n → n > 3 → (Irreducible (2 : ℤ[sqrt (-n)]) ∧ Irreducible (sqrt (-n) : ℤ[sqrt (-n)]) ∧ Irreducible ((1 + sqrt (-n)) : ℤ[sqrt (-n)])) ", "∀ {n : ℕ}, n > 3 → Nat.squarefree n → (Irreducible (2 : ℤ[ℤ.sqrt (-n)]) ∧ Irreducible (ℤ.sqrt (-n) : ℤ[ℤ.sqrt (-n)]) ∧ Irreducible (1 + ℤ.sqrt (-n) : ℤ[ℤ.sqrt (-n)])) ", "∀ {n : ℕ}, Nat.square_free n → n > 3 → Irreducible (2 : ℤ[sqrt n]) ∧ Irreducible (ℤ[sqrt n].sqrt) ∧ Irreducible (1 + ℤ[sqrt n].sqrt) ", "∀ {n : ℕ}, Nat.squarefree n → n > 3 → (∀ {a b : ℤ}, a ^ 2 + n * b ^ 2 = 2 → Irreducible (a + b * sqrt(-n)) ∧ Irreducible (1 + sqrt(-n))) ", "∀ {n : ℕ}, 3 < n → Nat.square_free n → IsIrreducible (√(-n), 2) ∧ IsIrreducible (√(-n), 1 + √(-n)) ", "forall {n : ℕ}, Nat.square_free n → n > 3 → \n  (Irreducible (2 : ℤ[sqrt (-n)]) ∧ Irreducible (sqrt (-n) : ℤ[sqrt (-n)]) ∧ Irreducible (1 + sqrt (-n) : ℤ[sqrt (-n)])) ", "∀ {n : ℕ}, Nat.squarefree n → n > 3 → (Irreducible (2 : ℤ√-n) ∧ Irreducible (sqrt_nat_cast (-n) : ℤ√-n) ∧ Irreducible (1 + sqrt_nat_cast (-n) : ℤ√-n)) ", "∀ {n : ℕ}, (Nat.squarefree n ∧ n > 3) → (Irreducible (2 : ℤ[sqrt -n]) ∧ Irreducible (sqrt (-n) : ℤ[sqrt -n]) ∧ Irreducible (1 + sqrt (-n) : ℤ[sqrt -n])) ", "∀ {n : ℕ}, (n > 3) ∧ Nat.squarefree n → Irreducible (2 : ℤ[sqrtd (-n)]) ∧ Irreducible (sqrtd (-n)) ∧ Irreducible (1 + sqrtd (-n)) ", "∀ {n : ℕ}, Squarefree n → n > 3 → (Irreducible (2 : ℤ√-n) ∧ Irreducible (Complex.sqrt (-n) : ℤ√-n) ∧ Irreducible (1 + Complex.sqrt (-n) : ℤ√-n)) "]}
{"docString": "Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements.", "prompts": "[{\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"}]\n", "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- Let $q \\in \\mathbb{Z}$ be a prime with $q \\equiv 3 \\bmod 4$. Prove that the quotient ring $\\mathbb{Z}[i] /(q)$ is a field with $q^{2}$ elements. -/\ntheorem", "choices": ["∀ {q : ℕ} [inst : Fact (Nat.Prime q)] [inst_1 : Fact (q % 4 = 3)],\n  IsField (Zmod q)[X] (Ideal.span {X ^ 2 + 1}) ∧ Fintype.card (Zmod q)[X] (Ideal.span {X ^ 2 + 1}) = q ^ 2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)], q % 4 = 3 → IsField (ℤ[i] ⧸ Ideal.span ({q} : Set (ℤ[i]))) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span ({q} : Set (ℤ[i]))) = q ^ 2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)], q % 4 = 3 → IsField (Zmodp (q * q)) ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)],\n  q % 4 = 3 → IsField (ℤ[i] ⧸ Ideal.span (singleton q)) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span (singleton q)) = q ^ 2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)],\n  q % 4 = 3 → IsField (ℤ[i] ⧸ idealOf q) ∧ Cardinal.mk ((ℤ[i] ⧸ idealOf q)) = q ^ 2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)], q % 4 = 3 → IsField (ℤ[i] ⧸ Ideal.span {q}) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span {q}) = q^2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)], q % 4 = 3 → IsField (Z[i] ⧸ (q)) ∧ Fintype.card (Z[i] ⧸ (q)) = q ^ 2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)] (h : q % 4 = 3),\n  IsField (ℤ[i] ⧸ Ideal.span ({I, -I} : Set ℤ[i])) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span ({I, -I} : Set ℤ[i])) = q ^ 2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)], q % 4 = 3 → IsField (ℤ[i] ⧸ idealOfNorm q) ∧ Fintype.card (ℤ[i] ⧸ idealOfNorm q) = q^2 ", "∀ {q : ℕ} [inst : Fact (Nat.Prime q)], q % 4 = 3 → IsField (Z[i] ⧸ Ideal.span {(q : ℤ)}) ∧ Fintype.card (Z[i] ⧸ Ideal.span {(q : ℤ)}) = q ^ 2 "]}
{"docString": "Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals.", "prompts": "[{\"theorem\":\n  \"∀ (R : Type w₁) [inst : CommRing R] (ι : Type u_2) [inst_1 : Finite ι], Algebra.FinitePresentation R (MvPolynomial ι R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of polynomials in finitely many variables is finitely presented. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ↔ ∀ (I : Ideal R), Ideal.FG I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"}]\n", "prompt_cons": "/-- The ring of polynomials in finitely many variables is finitely presented. -/\ntheorem ∀ (R : Type w₁) [inst : CommRing R] (ι : Type u_2) [inst_1 : Finite ι], Algebra.FinitePresentation R (MvPolynomial ι R) :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem ∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem ∀ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ↔ ∀ (I : Ideal R), Ideal.FG I :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I} :=\n\n/-- Prove that the ring $\\mathbb{Z}\\left[x_{1}, x_{2}, x_{3}, \\ldots\\right] /\\left(x_{1} x_{2}, x_{3} x_{4}, x_{5} x_{6}, \\ldots\\right)$ contains infinitely many minimal prime ideals. -/\ntheorem", "choices": ["∀ (n : ℕ), ∃ (P : Ideal (MvPolynomial (Fin n) ℤ)), P.isPrime ∧ ∀ (Q : Ideal (MvPolynomial (Fin n) ℤ)), Q.isPrime → P ≠ Q → Ideal.IsMinPrime P → Ideal.IsMinPrime Q ", "∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], ∃ (f : ℕ → Ideal R), ∀ i j, i ≠ j → (f i).isPrime ∧ (f j).isPrime ∧ Disjoint (f i) (f j) ", "∀ {R : Type u_1} [inst : CommRing R] (ι : Type u_2) [inst_1 : Infinite ι] (f : ι → Ideal R),\n  (∀ n, f n * f (n + 1) = 0) → Set.Infinite {v | ∃ n, v.asIdeal = f n} ", "∃ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], ¬(∀ (R' : Type u_1) [inst_2 : CommRing R'] [inst_3 : IsDomain R'],\n  Ideal.IsPrime (Ideal.span {(x_1 x_2, x_3 x_4, x_5 x_6, ...)}) → Set.Finite {v | v.asIdeal ∈ SetOf (Ideal.IsMin R')}) ", "∃ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], \n  ¬ Set.Finite (SetOf fun I => Ideal.IsPrime I ∧ Ideal.Minimal I) ", "∀ {R : Type w₁} [inst : CommRing R] (ι : ℕ), Algebra.FinitePresentation R (MvPolynomial (Finₓ (2 * ι + 1)) R) →\n  Set.Infinite {I : Ideal (MvPolynomial (Finₓ (2 * ι + 1)) R) | Ideal.IsMinimal I} ", "∀ (n : ℕ), ∃ (P : Ideal (MvPolynomial (Finₓ (n * 2)) ℤ)),\n  P.isPrime ∧ P ∣ Ideal.span {MvPolynomial.x (2 * i) * MvPolynomial.x (2 * i.succ) | i : Finₓ n} ", "∃ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], ¬(∀ (S : Ideal R), Ideal.IsMinPrime S → Set.Finite {v | v.asIdeal ∣ S}) ", "∀ (R : Type w₁) [inst : CommRing R], ExistsInfinitelyManyMinimalPrimes (Ideal R [X₁, X₂, X₃, …] / (X₁ * X₂, X₃ * X₄, X₅ * X₆, …)) ", "∃ (f : ℕ → Ideal (ℤ[x_1, x_2, x_3, ...])) (hf : ∀ n, Ideal.IsMinPrime (f n)), ∀ m n, m ≠ n → f m ≠ f n "]}
{"docString": "Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- Prove that $x^4-4x^3+6$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem", "choices": ["example : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_sub_four_x_pow_three_plus_six_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_minus_4_x_pow_three_plus_6_irr : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_four_minus_4_x_pow_three_plus_6_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "irreducible_x_pow4_sub_four_x_pow3_plus_six : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "x_pow_4_minus_4_x_pow_3_plus_6_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "irreducible_x_pow_four_sub_four_x_pow_three_plus_six : Irreducible (Polynomial.x ^ 4 - 4 • Polynomial.x ^ 3 + 6) ", "x_pow_4_sub_4_x_pow_3_plus_6_irreducible : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "irreducible_x_pow_four_sub_four_x_pow_three_plus_six : Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) ", "irreducible_x_pow_four_minus_four_x_pow_three_plus_six: Irreducible (Polynomial.x ^ 4 - 4 * Polynomial.x ^ 3 + 6) "]}
{"docString": "Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- Prove that $x^4+4x^3+6x^2+2x+1$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem", "choices": ["irreducible_x_pow_4_plus_4_x_pow_3_plus_6_x_pow_2_plus_2_x_plus_1 : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_4_plus_4_x_pow_3_plus_6_x_pow_2_plus_2_x_plus_1 : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_4_add_4_pow_3_add_6_pow_2_add_2_pow_1_add_1 :\n  Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_four_add_four_x_pow_three_add_six_x_pow_two_add_two_x_add_one : \n  Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_4_add_4x_pow_3_add_6x_pow_2_add_2x_add_1 : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "x_pow_four_plus_4x_pow_three_plus_6x_pow_two_plus_2x_plus_1_irreducible :\n  Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_4_add_4_pow_3_add_6_pow_2_add_2_pow_1_add_1 : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "x_pow_four_add_four_x_pow_three_add_six_x_pow_two_add_two_x_add_one_irreducible : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) ", "irreducible_x_pow_4_add_4x_pow_3_add_6x_pow_2_add_2x_add_1 : Irreducible (Polynomial.x^4 + 4*Polynomial.x^3 + 6*Polynomial.x^2 + 2*Polynomial.x + 1) ", "irreducible_x_pow_four_add_four_x_pow_three_add_six_x_pow_two_add_two_x_add_one\n  : Irreducible (Polynomial.x ^ 4 + 4 * Polynomial.x ^ 3 + 6 * Polynomial.x ^ 2 + 2 * Polynomial.x + 1) "]}
{"docString": "Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D.", "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"}]\n", "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Squarefree (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- Prove that the polynomial $x^{2}-\\sqrt{2}$ is irreducible over $\\mathbb{Z}[\\sqrt{2}]$. You may assume that $\\mathbb{Z}[\\sqrt{2}]$ is a U.F.D. -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Algebra ℤ R] [inst_3 : IsUFD R],\n  Irreducible (Polynomial.map (algebraMap ℤ R) (Polynomial.x ^ 2 - coe (2))) ", "∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : Algebra ℤ S] [inst_3 : Algebra ℝ S] [inst_4 : Algebra ℚ S],\n  (∀ (x : S), IsIntegral ℤ x → IsIntegral ℝ x) →\n    (∀ (x : ℝ), IsAlgebraic ℚ x → IsAlgebraic ℤ x) →\n      Irreducible (Polynomial.x ^ 2 - (coeFn (algebraMap ℝ S) (Real.sqrt 2))) ", "∀ {R : Type u_1} [inst : CommRing R] [IsDomain R] [_inst_1 : Algebra R ℝ] [_inst_2 : IsDomain ℝ] {x : ℝ},\n  (∀ (p : R), p * p = 2) →\n    Irreducible (Polynomial.map (algebraMap R ℝ) (Polynomial.x ^ 2 - Polynomial.C (p * p))) ", "irreducible_X_pow_sub_sqrt_two {α : Type u_1} [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : Algebra ℤ α] [inst_3 : Nontrivial α] [inst_4 : NormedDivisionRing α] [inst_5 : RootsOfUnity α] (h : SquareRootTwo α) : Irreducible (Polynomial.x ^ 2 - coeFn (algebraMap ℤ α) 2) ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Algebra R ℝ] [inst_2 : IsDomain R] [inst_3 : Algebra R ℚ] [inst_4 : Algebra ℚ ℝ] [inst_5 : IsScalarTower R ℚ ℝ],\n  (∀ (x : ℝ), x ^ 2 ≠ 2 → IsIntegral R (x ^ 2 - 2)) →\n  Irreducible (Polynomial.x ^ 2 - coeFn (algebraMap R ℝ) (2 : R)) ", "∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℤ A], Irreducible (Polynomial.x ^ 2 - coeFn (algebraMap ℤ A) 2) ", "∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℝ A] [inst_2 : Algebra ℤ A] [inst_3 : IsDomain A],\n  (∀ {x : A}, x ^ 2 ≠ 2) → Irreducible (Polynomial.x ^ 2 - Polynomial.C √2) ", "irreducible_X_pow_sub_sqrt_two {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℕ A] [inst_2 : IsDomain A] [inst_3 : UniqueFactorizationMonoid A] :\n  (IsIntegral A (sqrt (2 : ℝ))) → Irreducible (Polynomial.x ^ 2 - coeFn (algebraMap ℕ A) 2) ", "irreducible_x_pow_sub_sqrt_of_ufd {D : ℤ} [inst : IsDomain ℤ] [inst_1 : UniqueFactorizationMonoid D] [inst_2 : NormedRing D] [inst_3 : IsAbsoluteValue (abs : D → ℝ)] :\n  Irreducible (Polynomial.x ^ 2 - C (ℤ.sqrt 2)) ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Algebra ℤ R] [inst_2 : IsDomain R],\n  Irreducible (Polynomial.x ^ 2 - coeFn (algebraMap ℤ R) 2) "]}
{"docString": "Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$.", "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if and only if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\\n  FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F → Nonempty (E ≃L[𝕜] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two finite-dimensional topological vector spaces over a complete normed field are continuously\\nlinearly equivalent if they have the same (finite) dimension. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : ContinuousSMul ℝ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module ℝ F]\\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul ℝ F] [inst_8 : T2Space F] {G : Type u_1}\\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous ↑f → ∀ (c : ℝ) (x : E), ↑f (c • x) = c • ↑f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous additive map between two vector spaces over `ℝ` is `ℝ`-linear. \"}]\n", "prompt_cons": "/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\n  Nonempty (E ≃L[𝕜] F) ↔ FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F :=\n\n/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if they have the same (finite) dimension. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : T2Space F]\n  [inst_13 : FiniteDimensional 𝕜 E] [inst_14 : FiniteDimensional 𝕜 F],\n  FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 F → Nonempty (E ≃L[𝕜] F) :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- A continuous additive map between two vector spaces over `ℝ` is `ℝ`-linear. -/\ntheorem ∀ {E : Type u_2} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : ContinuousSMul ℝ E] {F : Type u_3} [inst_4 : AddCommGroup F] [inst_5 : Module ℝ F]\n  [inst_6 : TopologicalSpace F] [inst_7 : ContinuousSMul ℝ F] [inst_8 : T2Space F] {G : Type u_1}\n  [inst_9 : AddMonoidHomClass G E F] (f : G), Continuous ↑f → ∀ (c : ℝ) (x : E), ↑f (c • x) = c • ↑f x :=\n\n/-- Prove that as vector spaces over $\\mathbb{Q}, \\mathbb{R}^n \\cong \\mathbb{R}$, for all $n \\in \\mathbb{Z}^{+}$. -/\ntheorem", "choices": ["∀ (n : ℕ), Nonempty ((fin n → ℝ) ≃ₗ[ℚ] ℝ) ", "∀ {n : ℕ}, Nonempty ((Finₓ n → ℝ) ≃ₗ[ℚ] ℝ) ", "∀ {n : ℕ}, Nonempty ((Finₓ n → ℝ) ≃ₗ[ℚ] ℝ) ", "forall (n : ℕ), Nonempty ((Finₓ n → ℝ) ≃ₗ[ℚ] ℝ) ", "∀ (n : ℕ), Nonempty ((Finₓ n → ℝ) ≃ₗ[ℚ] ℝ) ", "∀ (n : ℕ), Nonempty ((fin n → ℝ) ≃ₗ[ℚ] ℝ) ", "∀ (n : ℕ), Nonempty (((ℝ ^ n) ≃ₗ[ℚ] ℝ) ", "∀ {n : ℕ},\n  Nonempty ((Finₓ (n + 1) → ℝ) ≃ₗ[ℚ] ℝ) ", "∀ (n : ℕ), Nonempty ((Finₓ n → ℝ) ≃ₗ[ℚ] ℝ) ", "forall (n : ℕ), nonempty ((fin n → ℝ) ≃ₗ[ℚ] ℝ) "]}
