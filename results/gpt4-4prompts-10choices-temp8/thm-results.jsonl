{"docString": "If every proper closed subset of a topological space is compact, then the space itself is compact.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- If every proper closed subset of a topological space is compact, then the space itself is compact. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α) (h1 : IsClosed K) (h2 : K ≠ univ), IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (C : Set α), IsClosed C ∧ C ≠ univ → IsCompact C) → CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K ∧ K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K → K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K ∧ K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ K : Set α, IsClosed K ∧ K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K → K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K → K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K → K ≠ univ → IsCompact K), CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (K : Set α), K ≠ univ → IsClosed K → IsCompact K), CompactSpace α "]}
{"docString": "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.", "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 ≠ 3 → ∃ a b, a ^ 2 + b ^ 2 = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\\nof two squares. Also known as **Fermat's Christmas theorem**. \"},\n {\"theorem\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\",\n  \"isProp\": true,\n  \"docString\": \"**Four squares theorem** \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- **Fermat's theorem on the sum of two squares**. Every prime not congruent to 3 mod 4 is the sum\nof two squares. Also known as **Fermat's Christmas theorem**. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 ≠ 3 → ∃ a b, a ^ 2 + b ^ 2 = p :=\n\n/-- **Four squares theorem** -/\ntheorem ∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n :=\n\n/-- Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares. -/\ntheorem", "choices": ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≡ 1 [MOD 4] → ∃ x y, x ^ 2 + y ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ", "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p "]}
{"docString": "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.", "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Euler's four-square identity**. \"}]\n", "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ∀ (a b c d x y z w : ℕ),\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- **Euler's four-square identity**. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\n      (a * w + b * z - c * y + d * x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem", "choices": ["∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ {u v x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ}, u = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 → v = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ r₁ r₂ r₃ r₄, u * v = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ", "∀ {a b x y u v m n : ℕ}, a = x ^ 2 + y ^ 2 + m ^ 2 + n ^ 2 → b = u ^ 2 + v ^ 2 + m ^ 2 + n ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ", "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ", "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ", "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ", "∀ {a b x y z w u v t s : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ", "∀ {a b x y u v p q : ℕ}, a = x ^ 2 + y ^ 2 + p ^ 2 + q ^ 2 → b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ", "∀ {a b x y z w u v s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ", "∀ {a b x y z w u v t s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 "]}
{"docString": "A ring with all elements idempotent is commutative.", "prompts": "[{\"theorem\": \"∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"}]\n", "prompt_cons": "/-- Multiplication in a boolean ring is idempotent. -/\ntheorem ∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- A ring with all elements idempotent is commutative. -/\ntheorem", "choices": ["∀ {α : Type u_1} [self : Mul α] [add_self : ∀ a : α, a * a = a], CommSemigroup α ", "∀ {α : Type u_1} [self : Mul α] [self_1 : Add α] (h : ∀ a : α, a * a = a), Commutative Mul.mul ", "∀ {α : Type u_1} [inst : Semiring α] (H : ∀ (x : α), x * x = x), CommRing α ", "∀ {α : Type u_1} [self : BooleanRing α], IsCommutative α (*) ", "∀ {α : Type u_1} [self : Ring α] (h : ∀ (a : α), a * a = a), CommRing α ", "∀ {α : Type u_1} [self : Mul α] [inst : Add α] (h : ∀ (a : α), a * a = a), IsCommutative α (*) ", "∀ {α : Type u_1} [inst : Mul α] [inst_1 : Add α] [inst_2 : Zero α] [inst_3 : One α] (a b : α) (h : ∀ (c : α), c * c = c), a * b = b * a ", "∀ {α : Type u_1} [self : Ring α] (∀ a : α, a * a = a), IsCommutative α Mul ", "∀ {α : Type u_1} [self : Semiring α] (H : ∀ (a : α), a * a = a), CommSemiring α ", "∀ {α : Type u_1} [self : BooleanRing α], IsCommutative α (*) "]}
{"docString": "There are infinitely many pairs of primes that differ exactly by `2`.", "prompts": "[{\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"}]\n", "prompt_cons": "/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- There are infinitely many pairs of primes that differ exactly by `2`. -/\ntheorem", "choices": ["∃ f : ℕ → ℕ, IsPrimePair f ∧ ∀ (n : ℕ), f n + 2 ≠ f (n + 1) ", "∃ (f : ℕ → ℕ), (∀ n, Nat.Prime (f n)) ∧ (∀ n, f (n + 1) - f n = 2) ", "∃ f : ℕ → ℕ, ∀ n, ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ q - p = 2 ∧ f n = q ", "∃ (f : ℕ → ℕ × ℕ), (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ Function.Injective f ", "Exists (λ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p - q = 2 * n) ", "∃ (f : ℕ → ℕ × ℕ), ∀ (n : ℕ), ∃ (m : ℕ) (H : m > n), Nat.Prime (f m).fst ∧ Nat.Prime (f m).snd ∧ (f m).snd - (f m).fst = 2 ", "∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p < q → p + 2 = q → ∃ k : ℕ, ∃ a b : ℕ, a ≠ b ∧ Nat.Prime a ∧ Nat.Prime b ∧ a + 2 = b ∧ a > p ", "ExistsInfinitelyManyPairsOfPrimesWithDiff2 : ∃ p q, p ≠ q ∧ (p - q = 2 ∨ q - p = 2) ∧ Nat.Prime p ∧ Nat.Prime q ", "∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 2 = 1 ∧ q % 2 = 1 → ∃ n, ∀ m ≥ n, ∃ p₁ q₁, Fact (Nat.Prime p₁) ∧ Fact (Nat.Prime q₁) ∧ p₁ % 2 = 1 ∧ q₁ % 2 = 1 ∧ p₁ + 2 = q₁ ∧ p₁ > m ", "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p - q = 2 ∧ p > n "]}
{"docString": "Every finite division ring is a field.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"}]\n", "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem ∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- Every finite division ring is a field. -/\ntheorem", "choices": ["∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ", "∀ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ {R : Type u_1} [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ", "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DivisionRing α], Field α ", "∀ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ", "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DivisionRing α], Field α ", "∀ {D : Type u_1} [inst : Fintype D] [inst_1 : DivisionRing D], Field D ", "∀ (R : Type u) [inst : DivisionRing R] [inst_1 : Fintype R], Field R ", "∀ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R "]}
{"docString": "If each of two types can be mapped injectively into the other, then there is a bijection between them.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {M₁ : Type v} {M₂ : Type v'} [inst_1 : AddCommMonoid M₁] [inst_2 : Module R M₁]\\n  [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M₂] {f : M₁ →ₗ[R] M₂},\\n  Function.Surjective ↑f → Function.Injective ↑(LinearMap.dualMap f)\",\n  \"isProp\": true,\n  \"docString\": \"If a linear map is surjective, then its dual is injective. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E ≃ₗ[𝕜] F),\\n  Continuous ↑e → Continuous ↑(LinearEquiv.symm e)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a bounded linear map is a bijection, then its inverse is also a bounded linear map. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_3} {M₂ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R₂]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\\n  {f : M →ₛₗ[τ₁₂] M₂},\\n  (∀ (u v : { x // x ∈ LinearMap.ker f } →ₗ[R] M), LinearMap.comp f u = LinearMap.comp f v → u = v) →\\n    LinearMap.ker f = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"A monomorphism is injective. \"},\n {\"theorem\":\n  \"∀ {X Y : Type u} (f : X ⟶ Y), CategoryTheory.IsIso f ↔ Function.Bijective f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A morphism in `Type u` is an isomorphism if and only if it is bijective. \"}]\n", "prompt_cons": "/-- If a linear map is surjective, then its dual is injective. -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {M₁ : Type v} {M₂ : Type v'} [inst_1 : AddCommMonoid M₁] [inst_2 : Module R M₁]\n  [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M₂] {f : M₁ →ₗ[R] M₂},\n  Function.Surjective ↑f → Function.Injective ↑(LinearMap.dualMap f) :=\n\n/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E ≃ₗ[𝕜] F),\n  Continuous ↑e → Continuous ↑(LinearEquiv.symm e) :=\n\n/-- A monomorphism is injective. -/\ntheorem ∀ {R : Type u_1} {R₂ : Type u_2} {M : Type u_3} {M₂ : Type u_4} [inst : Semiring R] [inst_1 : Semiring R₂]\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\n  {f : M →ₛₗ[τ₁₂] M₂},\n  (∀ (u v : { x // x ∈ LinearMap.ker f } →ₗ[R] M), LinearMap.comp f u = LinearMap.comp f v → u = v) →\n    LinearMap.ker f = ⊥ :=\n\n/-- A morphism in `Type u` is an isomorphism if and only if it is bijective. -/\ntheorem ∀ {X Y : Type u} (f : X ⟶ Y), CategoryTheory.IsIso f ↔ Function.Bijective f :=\n\n/-- If each of two types can be mapped injectively into the other, then there is a bijection between them. -/\ntheorem", "choices": ["∀ {α : Type u_1} {β : Type u_2}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) ", "∀ {α : Type u} {β : Type v}, \n  (∃ (f : α → β), Function.Injective f) → \n  (∃ (g : β → α), Function.Injective g) → \n  (∃ (h : α ≃ β), True) ", "∀ {α β : Type u}, (∃ (f : α ↪ β), ∃ (g : β ↪ α)) → Nonempty (α ≃ β) ", "∀ {X Y : Type u},\n  (Nonempty (Function.Embedding X Y) ∧ Nonempty (Function.Embedding Y X)) →\n  Nonempty (X ≃ Y) ", "∀ {α : Type u} {β : Type v},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → Nonempty (α ≃ β) ", "∀ {α : Type u} {β : Type v}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) ", "∀ {α : Type u} {β : Type u'} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ", "∀ {α : Type u} {β : Type v} (f : α ↪ β) (g : β ↪ α),\n  Nonempty (α ≃ β) ", "∀ {α β : Type u}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → Nonempty (α ≃ β) ", "∀ {α : Type u} {β : Type v}, (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) "]}
{"docString": "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.", "prompts": "[{\"theorem\":\n  \"∀ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\\n  SimpleGraph.minDegree G ≤ SimpleGraph.degree G v\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimum degree in the graph is at most the degree of any particular vertex. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"}]\n", "prompt_cons": "/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem ∀ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem ∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (v : V),\n  SimpleGraph.minDegree G ≤ SimpleGraph.degree G v :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val :=\n\n/-- A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices. -/\ntheorem", "choices": ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → ∃! (w : V), SimpleGraph.Adj G u w ∧ SimpleGraph.Adj G v w) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj], (∀ (v w : V), v ≠ w → ∃! (z : V), SimpleGraph.Adj G v z ∧ SimpleGraph.Adj G w z) → ∃ (x : V), ∀ (y : V), y ≠ x → SimpleGraph.Adj G x y ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n  ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v ", "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (x : V), SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x) →\n  ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v ", "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] [inst_2 : SimpleGraph.OneCommonNeighbor G],\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → ∃! (w : V), G.Adj u w ∧ G.Adj v w) → ∃ (y : V), ∀ (x : V), x ≠ y → SimpleGraph.Adj G x y ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ExistsUnique (λ (x : V), SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x)) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ", "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (u v : V), u ≠ v → (∃! w, G.Adj u w ∧ G.Adj v w)) → ∃ x, ∀ y, x ≠ y → G.Adj x y ", "∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → (Finset.card (SimpleGraph.commonNeighbors G v w) = 1)) →\n  ∃ (v : V), SimpleGraph.isUniversal G v "]}
{"docString": "The number of partitions with odd parts is equal to the number of partitions with distinct parts.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\\n  {G : SimpleGraph α} {ε : ℝ},\\n  Finset.card P.parts * 16 ^ Finset.card P.parts ≤ Fintype.card α →\\n    ¬Finpartition.IsUniform P G ε →\\n      Finset.card (SzemerediRegularity.increment hP G ε).parts = SzemerediRegularity.stepBound (Finset.card P.parts)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The increment partition has a prescribed (very big) size in terms of the original partition. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Lattice α] [inst_1 : OrderBot α] {a : α} (self : Finpartition a), Finset.SupIndep self.parts id\",\n  \"isProp\": true,\n  \"docString\": \"The partition is supremum-independent \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ↑f.parts\",\n  \"isProp\": true,\n  \"docString\": \"A finpartition gives rise to a setoid partition \"},\n {\"theorem\": \"∀ {α : Type u_1} {r : Setoid α} (a : α), ∃! b x, a ∈ b\",\n  \"isProp\": true,\n  \"docString\": \"Equivalence classes partition the type. \"}]\n", "prompt_cons": "/-- The increment partition has a prescribed (very big) size in terms of the original partition. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph α} {ε : ℝ},\n  Finset.card P.parts * 16 ^ Finset.card P.parts ≤ Fintype.card α →\n    ¬Finpartition.IsUniform P G ε →\n      Finset.card (SzemerediRegularity.increment hP G ε).parts = SzemerediRegularity.stepBound (Finset.card P.parts) :=\n\n/-- The partition is supremum-independent -/\ntheorem ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : OrderBot α] {a : α} (self : Finpartition a), Finset.SupIndep self.parts id :=\n\n/-- A finpartition gives rise to a setoid partition -/\ntheorem ∀ {α : Type u_1} (f : Finpartition Set.univ), Setoid.IsPartition ↑f.parts :=\n\n/-- Equivalence classes partition the type. -/\ntheorem ∀ {α : Type u_1} {r : Setoid α} (a : α), ∃! b x, a ∈ b :=\n\n/-- The number of partitions with odd parts is equal to the number of partitions with distinct parts. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : Fintype α] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P},\n  Finset.card (Finpartition.oddParts P).parts = Finset.card (Finpartition.distinctParts P).parts ", "∀ {n : ℕ}, Nat.partitions_odds_card n = Nat.partitions_distinct_card n ", "∀ {n : ℕ}, Nat.Partition.odd_parts (n : ℕ) = Nat.Partition.distinct_parts (n : ℕ) ", "∀ {α : Type u_1} [inst : Fintype α] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph α} {ε : ℝ},\n  Finset.card P.parts * 16 ^ Finset.card P.parts ≤ Fintype.card α →\n    ¬Finpartition.IsUniform P G ε →\n      Finset.card (SzemerediRegularity.increment hP G ε).parts = SzemerediRegularity.stepBound (Finset.card P.parts) ", "forall {α : Type u_1} [inst : Fintype α] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n  {G : SimpleGraph α} {ε : ℝ},\n  Finset.card P.parts * 16 ^ Finset.card P.parts ≤ Fintype.card α ->\n    ¬Finpartition.IsUniform P G ε ->\n      Finset.card (SzemerediRegularity.increment hP G ε).parts = SzemerediRegularity.stepBound (Finset.card P.parts) ", "∀ {n : ℕ}, odd_partit n = distinct_partit n ", "∀ {α : Type u_1} [inst : Fintype α] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P}\n    (O : ℕ → ℕ) (D : ℕ → ℕ),\n    (∀ n, P.oddPartsCount n = O n) →\n    (∀ n, P.distinctPartsCount n = D n) →\n      ∀ n, O n = D n ", "∀ {α : Type u_1} [inst : Fintype α],\n  Finset.card (Finpartition.oddParts Finset.univ) = Finset.card (Finpartition.distinctParts Finset.univ) ", "∀ (n : ℕ), num_partitions_odd_parts n = num_partitions_distinct_parts n ", "∀ {α : Type u_1} [inst : Fintype α] {P : Finpartition Finset.univ} {hP : Finpartition.IsEquipartition P},\n  Finset.card (oddParts P) = Finset.card (distinctParts P) "]}
{"docString": "Every non-empty poset in which every chain has an upper bound contains a maximal element.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\\nthere is a maximal element.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop},\\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} {c : Set α}, IsChain r c → ∃ M, IsMaxChain r M ∧ c ⊆ M\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\\n  c ⊆ nonPrincipals R →\\n    IsChain (fun x x_1 => x ≤ x_1) c →\\n      ∀ {K : Ideal R}, K ∈ c → ∃ I, I ∈ nonPrincipals R ∧ ∀ (J : Ideal R), J ∈ c → J ≤ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any chain in the set of non-principal ideals has an upper bound which is non-principal.\\n(Namely, the union of the chain is such an upper bound.)\\n\"}]\n", "prompt_cons": "/-- A variant of Zorn's lemma. If every nonempty chain of a nonempty type has an upper bound, then\nthere is a maximal element. -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m :=\n\n/-- **Zorn's lemma**\n\nIf every chain has an upper bound, then there exists a maximal element. -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m :=\n\n/-- Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle. -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop} {c : Set α}, IsChain r c → ∃ M, IsMaxChain r M ∧ c ⊆ M :=\n\n/-- Any chain in the set of non-principal ideals has an upper bound which is non-principal.\n(Namely, the union of the chain is such an upper bound.) -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (c : Set (Ideal R)),\n  c ⊆ nonPrincipals R →\n    IsChain (fun x x_1 => x ≤ x_1) c →\n      ∀ {K : Ideal R}, K ∈ c → ∃ I, I ∈ nonPrincipals R ∧ ∀ (J : Ideal R), J ∈ c → J ≤ I :=\n\n/-- Every non-empty poset in which every chain has an upper bound contains a maximal element. -/\ntheorem", "choices": ["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ", "∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m "]}
{"docString": "A group whose automorphism group is cyclic is Abelian.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"}]\n", "prompt_cons": "/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- A group whose automorphism group is cyclic is Abelian. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsCommutative G ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsCyclic (Aut G) → IsAbelian G ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] (h : IsCyclic (Aut α)), IsAbelian α ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsCyclic (Aut G) → IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "∀ {G : Type u} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "∀ {G : Type u} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] (C : Cyclic (Aut α)), IsAbelian α ", "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsCyclic (Aut G)], IsAbelian G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsCyclic (Aut G)], IsAbelian G "]}
{"docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"}]\n", "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] \n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst_1 : UniformSpace α] [inst_2 : UniformSpace β] [inst_3 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]}
{"docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"}]\n", "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem", "choices": ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ", "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]}
{"docString": "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : DiscreteTopology α], TopologicalSpace.SeparableSpace α ↔ Countable α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α\",\n  \"isProp\": true,\n  \"docString\": \"A space with discrete topology is a locally connected space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"}]\n", "prompt_cons": "/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : DiscreteTopology α], TopologicalSpace.SeparableSpace α ↔ Countable α :=\n\n/-- A space with discrete topology is a locally connected space. -/\ntheorem ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ \n  (∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1)) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ", "forall {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ", "∀ {α : Type u} [t : TopologicalSpace α], NormalSpace α ↔\n  (∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1)) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ (∀ (x : α), HasMem.Mem x s → f x = 0) ∧ (∀ (x : α), HasMem.Mem x t → f x = 1) ", "∀ {α : Type u} [t : TopologicalSpace α], NormalSpace α ↔\n  (∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ (∀ (x : α), HasMem.Mem x s → f x = 0) ∧ (∀ (x : α), HasMem.Mem x t → f x = 1)) ", "∀ {α : Type u} [t : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ (∀ x : α, x ∈ s → f x = 0) ∧ (∀ x : α, x ∈ t → f x = 1) ", "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f : α → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1) "]}
{"docString": "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\",\n  \"isProp\": true,\n  \"docString\": \"Any point is a periodic point of period `0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"theorem\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\",\n  \"isProp\": true,\n  \"docString\": \"For the identity map, all points are periodic. \"},\n {\"theorem\":\n  \"∀ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {p₁ p₂ p₃ p₄ p₅ : P},\\n  p₁ ∈ affineSpan k {p₄, p₅} → p₂ ∈ affineSpan k {p₄, p₅} → p₃ ∈ affineSpan k {p₄, p₅} → Collinear k {p₁, p₂, p₃}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If three points lie in the affine span of two points, the first three points are collinear. \"}]\n", "prompt_cons": "/-- Any point is a periodic point of period `0`. -/\ntheorem ∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x :=\n\n/-- A fixed point of `f` is a periodic point of `f` of any prescribed period. -/\ntheorem ∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x :=\n\n/-- For the identity map, all points are periodic. -/\ntheorem ∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x :=\n\n/-- If three points lie in the affine span of two points, the first three points are collinear. -/\ntheorem ∀ {k : Type u_2} {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p₁ p₂ p₃ p₄ p₅ : P},\n  p₁ ∈ affineSpan k {p₄, p₅} → p₂ ∈ affineSpan k {p₄, p₅} → p₃ ∈ affineSpan k {p₄, p₅} → Collinear k {p₁, p₂, p₃} :=\n\n/-- If a function from the unit interval to itself has a point of period three, then it has points of all positive periods. -/\ntheorem", "choices": ["∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : ℝ≃oα] (f : Icc (0 : ℝ) 1 → Icc (0 : ℝ) 1),\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n, n > 0 → ∃ x, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : MeasurableSpace α] [inst_4 : BorelSpace α]\n  (f : I → I) (hf : ∀ x ∈ I, f x ∈ I) (hf' : Continuous f) (h : ∃ x, Function.IsPeriodicPt f 3 x),\n  ∀ (n : ℕ), n > 0 → ∃ x, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [Preorder α] [_inst_1 : TopologicalSpace α] [_inst_2 : OrderTopology α] {f : α → α} (hf : Continuous f)\n  (h₀ : ∀ x, x ≤ f x) (h₁ : ∀ x, f x ≤ 1) {x₀ : α}, Function.IsPeriodicPt f 3 x₀ → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] {_inst_2 : TopologicalSpace α} {_inst_3 : OrderTopology α}\n  (f : α → α) (hf₀ : Continuous f) (hf₁ : ∀ x, x ∈ set.Icc (0 : α) 1 → f x ∈ set.Icc (0 : α) 1) (x : α),\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), n > 0 → ∃ y, Function.IsPeriodicPt f n y ", "∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] [inst : TopologicalSpace α] [inst_2 : OrderTopology α]\n  (f : (α × α) → α × α), (∀ x : α × α, x ∈ Set.Icc (0, 0) (1, 1) → f x ∈ Set.Icc (0, 0) (1, 1)) →\n  (∃ x : α × α, Function.IsPeriodicPt f 3 x) → ∀ n : ℕ, n > 0 → ∃ x : α × α, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  (f : Icc (0 : α) 1 → Icc (0 : α) 1) (hf : ContinuousOn f (Set.Icc 0 1)), (∃ (x : Icc (0 : α) 1), Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), n > 0 → ∃ (x : Icc (0 : α) 1), Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : LinearOrderedField α] {f : α → α} (h₀ : ∀ x, 0 ≤ x → x ≤ 1 → 0 ≤ f x → f x ≤ 1)\n  (h₁ : ∃ x, Function.IsPeriodicPt f 3 x), ∀ n, ∃ x, Function.IsPeriodicPt f (n + 1) x ", "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] {f : α → α} (hf : Continuous f) {x : α},\n  (∃ (hx₀ : HasMem.Mem x (Set.Icc (0 : α) 1)), Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), n ≠ 0 → ∃ (x : α), Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] [_inst_2 : TopologicalSpace α] [_inst_3 : OrderTopology α] {f : α → α},\n  Continuous f → (∀ x : α, 0 ≤ x → x ≤ 1 → f x ∈ Set.Icc 0 1) → (∃ x : α, Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), n > 0 → ∃ x : α, Function.IsPeriodicPt f n x ", "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {f : α → α},\n  Continuous f → f 0 = 0 → f 1 = 1 →\n  (∃ x : α, x ∈ set.Icc (0 : α) 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ n : ℕ, n > 0 → ∃ x : α, x ∈ set.Icc (0 : α) 1 ∧ Function.IsPeriodicPt f n x "]}
{"docString": "A terminal object in a category is unique up to unique isomorphism.", "prompts": "[{\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (Y ⟶ X)],\\n  CategoryTheory.Limits.HasTerminal C\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can more explicitly show that a category has a terminal object by specifying the object,\\nand showing there is a unique morphism to it from any other object. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g\",\n  \"isProp\": true,\n  \"docString\": \"Any two morphisms to a terminal object are equal. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"theorem\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism from a terminal object is mono. \"}]\n", "prompt_cons": "/-- We can more explicitly show that a category has a terminal object by specifying the object,\nand showing there is a unique morphism to it from any other object. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X : C) [h : (Y : C) → Unique (Y ⟶ X)],\n  CategoryTheory.Limits.HasTerminal C :=\n\n/-- Any two morphisms to a terminal object are equal. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g :=\n\n/-- The subcategory of subterminal objects is an exponential ideal. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C) :=\n\n/-- Any morphism from a terminal object is mono. -/\ntheorem ∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.Mono f :=\n\n/-- A terminal object in a category is unique up to unique isomorphism. -/\ntheorem", "choices": ["forall {C : Type u₁} [inst : CategoryTheory.Category C] (X Y : C) [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] (X Y : C) [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n    CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}\n  [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}\n  [hX : CategoryTheory.Limits.IsTerminal X] [hY : CategoryTheory.Limits.IsTerminal Y],\n  Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Unique (X ≅ Y) ", "∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X)\n  (hY : CategoryTheory.Limits.IsTerminal Y), Unique (X ≅ Y) "]}
{"docString": "The complement of the union of two sets is the intersection of their complements.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\",\n  \"isProp\": true,\n  \"docString\": \"The complement of a closed set is an open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t)\",\n  \"isProp\": true,\n  \"docString\": \"The union of two bounded sets is bounded. \"}]\n", "prompt_cons": "/-- The complement of a closed set is an open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ :=\n\n/-- The complement of a set has the same frontier as the original set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- The union of two bounded sets is bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded s → Metric.Bounded t → Metric.Bounded (s ∪ t) :=\n\n/-- The complement of the union of two sets is the intersection of their complements. -/\ntheorem", "choices": ["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ = (s ∩ t)ᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ", "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ "]}
{"docString": "The sum of the cubes of two positive integers is never equal to the cube of a third integer.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₁ ≠ p₃\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first and third points are not\\nequal. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₁ ≠ p₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sign of the angle between three points is positive, the first two points are not\\nequal. \"}]\n", "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem ∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n :=\n\n/-- If the sign of the angle between three points is positive, the first and third points are not\nequal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₁ ≠ p₃ :=\n\n/-- If the sign of the angle between three points is positive, the first two points are not\nequal. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₁ ≠ p₂ :=\n\n/-- The sum of the cubes of two positive integers is never equal to the cube of a third integer. -/\ntheorem", "choices": ["∀ {x y z : ℕ}, x > 0 → y > 0 → x * x * x + y * y * y ≠ z * z * z ", "∀ {m n k : ℕ}, 0 < m → 0 < n → m^3 + n^3 ≠ k^3 ", "∀ {n m k : ℕ}, n > 0 → m > 0 → n * n * n + m * m * m ≠ k * k * k ", "∀ {n m k : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ k * k * k ", "∀ {m n k : ℕ}, 0 < m → 0 < n → m * m * m + n * n * n ≠ k * k * k ", "∀ {m n k : ℕ}, 0 < m → 0 < n → m * m * m + n * n * n ≠ k * k * k ", "∀ {n m k : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ k * k * k ", "∀ {n m k : ℕ}, n > 0 → m > 0 → n * n * n + m * m * m ≠ k * k * k ", "∀ {x y z : ℕ}, x > 0 → y > 0 → x * x * x + y * y * y ≠ z * z * z ", "∀ {n m l : ℕ}, 0 < n → 0 < m → n * n * n + m * m * m ≠ l * l * l "]}
{"docString": "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.", "prompts": "[{\"theorem\": \"∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself.\"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n", "prompt_cons": "/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] (a : S), AddCommute a a :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- If every element of a group `G` has order `2`, then every pair of elements of `G` commutes. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G] (h : ∀ (a : G), a * a = 1), ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x ^ 2 = 1), ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b ", "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ", "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y "]}
{"docString": "The product of two consecutive natural numbers is even.", "prompts": "[{\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"}]\n", "prompt_cons": "/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- The product of two consecutive natural numbers is even. -/\ntheorem", "choices": ["∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), even (n * (n + 1)) ", "∀ (n : ℕ), 2 ∣ (n * (n + 1)) "]}
{"docString": "Every index 2 subgroup of a group is normal.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n", "prompt_cons": "/-- The subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0 :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Every index 2 subgroup of a group is normal. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H = ₂ → Subgroup.Normal H ", "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ", "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} (cond : Subgroup.index H = 2), Subgroup.Normal H "]}
{"docString": "Every free group is torsion free.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"}]\n", "prompt_cons": "/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Direct products of torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Every free group is torsion free. -/\ntheorem", "choices": ["∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst : Monoid.FreeGroup G α], Monoid.IsTorsionFree G ", "∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst : Fintype α], FreeGroup.IsFree G α → Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G], Monoid.IsFree G → Monoid.IsTorsionFree G ", "forall {α : Type u_1} {G : Type u_2} [inst : Group G] [F : FreeGroup α → G], Monoid.IsTorsionFree G ", "∀ {α : Type u_1} {G : Type u_2} [inst : Group G], Monoid.FreeFunctor α G → Monoid.IsTorsionFree G ", "forall {G : Type u_1} [inst : Group G] [inst2 : IsFreeGroup G], Monoid.IsTorsionFree G ", "∀ {G : Type u_1} [inst : Group G] [Free : Group.IsFree G], Monoid.IsTorsionFree G ", "forall {G : Type u_1} [inst : Group G], Monoid.FreeGroup G → Monoid.IsTorsionFree G ", "∀ {α : Type u_1} {G : Type u_2} [inst : Group G],\n  (α → G) → Monoid.IsTorsionFree G ", "∀ {α : Type u_1} {G : Type u_2} [inst : Group G], Monoid.Free G α → Monoid.IsTorsionFree G "]}
{"docString": "Every natural number greater than `1` is divisible by a prime number.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\ntheorem ∀ {a b : ℕ}, a ∣ b → b < a → b = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- Every natural number greater than `1` is divisible by a prime number. -/\ntheorem", "choices": ["∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → (∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n) ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n ", "∀ (n : ℕ), n > 1 → ∃ (p : ℕ) [inst : Fact (Nat.Prime p)], p ∣ n "]}
{"docString": "A finite torsion-free group is trivial", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"}]\n", "prompt_cons": "/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- A finite torsion-free group is trivial -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → G ≃ Unit ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Monoid.Trivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → G ≃ Unit ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Monoid.IsTrivial G ", "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → G ≃ Unit ", "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Trivial G "]}
{"docString": "Every finite division ring is a field.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field is closed under division. \"},\n {\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L\",\n  \"isProp\": true,\n  \"docString\":\n  \"A cyclotomic finite extension of a number field is a number field. \"}]\n", "prompt_cons": "/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- An intermediate field is closed under division. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S :=\n\n/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- A cyclotomic finite extension of a number field is a number field. -/\ntheorem ∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L :=\n\n/-- Every finite division ring is a field. -/\ntheorem", "choices": ["∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ", "∀ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ", "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ", "∀ {D : Type u_1} [inst : Fintype D] [inst_1 : DivisionRing D], Field D ", "∀ {R : Type u_1} [inst : Fintype R] [inst_1 : DivisionRing R], Field R ", "∀ (D : Type u) [inst : Fintype D] [inst_1 : DivisionRing D], Field D ", "∀ (R : Type u_1) [inst : Ring R] [inst_1 : Fintype R] [inst_2 : Nontrivial R] [inst_3 : DivisionRing R], Field R ", "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DivisionRing α], Field α ", "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R ", "∀ (R : Type u_1) [inst : Fintype R] [inst_1 : DivisionRing R], Field R "]}
{"docString": "Every finite topological space is compact.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\",\n  \"isProp\": true,\n  \"docString\": \"The underlying topological space is compact.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α\",\n  \"isProp\": true,\n  \"docString\": \"A compact discrete space is finite. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"}]\n", "prompt_cons": "/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- The underlying topological space is compact. -/\ntheorem ∀ (self : CompHaus), CompactSpace ↑self.toTop :=\n\n/-- A compact discrete space is finite. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- Every finite topological space is compact. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ", "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α "]}
{"docString": "Every surjective homomorphism from a finitely generated free group to itself is injective.", "prompts": "[{\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"}]\n", "prompt_cons": "/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem ∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ↑f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1) :=\n\n/-- Any surjective endomorphism of a Noetherian module is injective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ↑f → Function.Injective ↑f :=\n\n/-- Any injective endomorphism of an Artinian module is surjective. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ↑f → Function.Surjective ↑f :=\n\n/-- Every surjective homomorphism from a finitely generated free group to itself is injective. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : Group α] [inst_1 : Fg α] [inst_2 : IsFreeGroup α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : FgFreeGroup α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : FgFree α] {f : α → α}, IsGroupHom f →\n  Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f ", "∀ {α : Type u} [inst : Group α] [inst_1 : IsFg α] [inst_2 : IsFreeGroup α] (f : α → α),\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {f : α → α},\n  IsGroupHom f → Function.Surjective f → Function.Injective f ", "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsFreeGroup α] {f : α →* α},\n  Function.Surjective ↑f → Function.Injective ↑f "]}
{"docString": "Every positive even integer can be written as the sum of two primes.", "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"}]\n", "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Two positive naturals are equal if their prime padic valuations are equal -/\ntheorem ∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b) :=\n\n/-- Every positive even integer can be written as the sum of two primes. -/\ntheorem", "choices": ["/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} ", "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ {n : ℕ}, n > 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), n = p + q ∧ Nat.Prime p ∧ Nat.Prime q ", "∀ {n : ℕ}, n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "Goldbach's_conjecture : ∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ", "∀ (n : ℕ), n > 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q "]}
{"docString": "Every matrix satisfies its own characteristic polynomial.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero α] [inst_2 : One α], Matrix.IsDiag 1\",\n  \"isProp\": true,\n  \"docString\": \"Every identity matrix is diagonal. \"},\n {\"theorem\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q\",\n  \"isProp\": true,\n  \"docString\": \"Every polynomial is a polynomial in finitely many variables. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a nonzero element has nonzero constant coefficient. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [inst_6 : Fintype ι]\\n  (b : Basis ι R M), Matrix.charpoly (↑(LinearMap.toMatrix b b) f) = LinearMap.charpoly f\",\n  \"isProp\": true,\n  \"docString\":\n  \"`charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. \"}]\n", "prompt_cons": "/-- Every identity matrix is diagonal. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : DecidableEq n] [inst_1 : Zero α] [inst_2 : One α], Matrix.IsDiag 1 :=\n\n/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem ∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] (p : MvPolynomial σ R),\n  ∃ n f _hf q, p = ↑(MvPolynomial.rename f) q :=\n\n/-- The minimal polynomial of a nonzero element has nonzero constant coefficient. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → x ≠ 0 → Polynomial.coeff (minpoly A x) 0 ≠ 0 :=\n\n/-- `charpoly f` is the characteristic polynomial of the matrix of `f` in any basis. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [inst_6 : Fintype ι]\n  (b : Basis ι R M), Matrix.charpoly (↑(LinearMap.toMatrix b b) f) = LinearMap.charpoly f :=\n\n/-- Every matrix satisfies its own characteristic polynomial. -/\ntheorem", "choices": ["∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M), (LinearMap.charpoly f).eval f = 0 ", "∀ {n : Type u} {R : Type v} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] (M : Matrix n n R),\n  Polynomial.evalM M (Matrix.charpoly M) = 0 ", "∀ {n : Type u_1} {R : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R]\n  (M : Matrix n n R), Polynomial.eval M (Matrix.charpoly M) = 0 ", "∀ {n : Type u} {R : Type v} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] (M : Matrix n n R),\n  Polynomial.eval M (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [inst_6 : Fintype ι]\n  (b : Basis ι R M), Matrix.eval (↑(LinearMap.toMatrix b b) f) (LinearMap.charpoly f) = 0 ", "∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M),\n  (LinearMap.charpoly f).eval (LinearMap.toMatrix (Module.Free.chooseBasis R M) (Module.Free.chooseBasis R M) f) = 0 ", "∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M) {ι : Type w} [inst_6 : Fintype ι]\n  (b : Basis ι R M), (Matrix.charpoly (↑(LinearMap.toMatrix b b) f)).eval (↑(LinearMap.toMatrix b b) f) = 0 ", "∀ {n : Type u} {R : Type v} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing R] (M : Matrix n n R),\n  Polynomial.eval (Matrix.det (M - (Matrix.scalar n (Polynomial.x)))) (Matrix.charpoly M) = 0 ", "∀ {R : Type u} {n : Type w} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : Fintype n] [inst_3 : DecidableEq n]\n  (M : Matrix n n R), Matrix.charpoly_eval M (Matrix.charpoly M) = 0 ", "∀ {n : Type u_1} {α : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing α] (A : Matrix n n α),\n  Matrix.IsDiag (Matrix.charpoly A • 1 - Matrix.map A (⇑Polynomial.c)) "]}
{"docString": "The square root of an irrational number is irrational.", "prompts": "[{\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"Irrational goldenRatio\",\n  \"isProp\": true,\n  \"docString\": \"The golden ratio is irrational. \"}]\n", "prompt_cons": "/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- The golden ratio is irrational. -/\ntheorem Irrational goldenRatio :=\n\n/-- The square root of an irrational number is irrational. -/\ntheorem", "choices": ["∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r) ", "∀ {a : ℝ}, Irrational a → Irrational (Real.sqrt a) "]}
{"docString": "If the square of a number is even, the number itself is even.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"}]\n", "prompt_cons": "/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- If the square of a number is even, the number itself is even. -/\ntheorem", "choices": ["∀ {n : ℕ}, n * n % 2 = 0 → n % 2 = 0 "]}
{"docString": "In a finite commutative ring, all prime ideals are maximal.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"}]\n", "prompt_cons": "/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I :=\n\n/-- In a finite commutative ring, all prime ideals are maximal. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [Finsupp : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [Fintype R], (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ", "∀ {R : Type u} [inst : CommRing R] [Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ", "∀ {R : Type u} [inst : CommRing R] [hf : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) "]}
{"docString": "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"}]\n", "prompt_cons": "/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- The **Heine–Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- In a complete space, the type of closed subsets is complete for the\nHausdorff edistance. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α) :=\n\n/-- A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α], IsClosed (Set.Diagonal α) ↔ T2Space α ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed (IdRel.diag α) ", "∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α],\n  IsClosed (Set.Diagonal α) ↔ T2Space α ", "∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed (Set.Diagonal α) ", "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed (Diagonal α) "]}
{"docString": "If every point of a subset of a topological space is contained in some open set, the subset itself is open.", "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [t : TopologicalSpace α], t = ⊤ → ∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ U = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\\n  IsOpen s → Set.Nonempty s → Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"}]\n", "prompt_cons": "/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U :=\n\n/-- An open set in the indiscrete topology is either empty or the whole space. -/\ntheorem ∀ {α : Type u_1} [t : TopologicalSpace α], t = ⊤ → ∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ U = ⊤ :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\n  IsOpen s → Set.Nonempty s → Dense s :=\n\n/-- If every point of a subset of a topological space is contained in some open set, the subset itself is open. -/\ntheorem", "choices": ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ t) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ", "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U : Set α, x ∈ U ∧ IsOpen U ∧ U ⊆ s) → IsOpen s "]}
{"docString": "Every non-identity element of a free group is of infinite order.", "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"}]\n", "prompt_cons": "/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g :=\n\n/-- Every non-identity element of a free group is of infinite order. -/\ntheorem", "choices": ["∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {G : Type u_1} [inst : Group G], FreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {G : Type u_1} [inst : Group G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (g : α), g ≠ 1 → ¬IsOfFinOrder g ", "∀ {G : Type u_1} [inst : Group G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u_1} [inst : Monoid α] {f : FreeGroup α} (x : α), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u_1} [inst : FreeGroup α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u_1} [inst : Group α] [IsFreeGroup α] (a : α), a ≠ 1 → ¬IsOfFinOrder a ", "∀ {α : Type u_1} [inst : SemigroupWithZero α], ∀ x : FreeGroup α, x ≠ 1 → ¬IsOfFinOrder x ", "∀ {α : Type u_1} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x "]}
{"docString": "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.", "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a monoid with zero, if zero equals one, then zero is the only element. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\\n  (∃ p, Irreducible p) → (∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) → DiscreteValuationRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unique factorization domain with at least one irreducible element\\nin which all irreducible elements are associated\\nis a discrete valuation ring.\\n\"}]\n", "prompt_cons": "/-- If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. -/\ntheorem ∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0 :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥ :=\n\n/-- In a monoid with zero, if zero equals one, then zero is the only element. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀], 0 = 1 → ∀ (a : M₀), a = 0 :=\n\n/-- A unique factorization domain with at least one irreducible element\nin which all irreducible elements are associated\nis a discrete valuation ring. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R],\n  (∃ p, Irreducible p) → (∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) → DiscreteValuationRing R :=\n\n/-- An element of a discrete valuation ring is a unit if and only if it has a valuation of zero. -/\ntheorem", "choices": ["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ DiscreteValuationRing.HasValuation R x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R],\n  ∀ (x : R), IsUnit x ↔ DiscreteValuationRing.valuation R x = 0 ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  {Γ₀ : Type u_2} [inst_3 : LinearOrderedCommMonoidWithZero Γ₀] [inst_4 : Nontrivial Γ₀] (v : Valuation R Γ₀)\n  {x : R}, IsUnit x ↔ ↑v x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R],\n  ∀ (x : R), IsUnit x ↔ DiscreteValuationRing.valuation R x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ DiscreteValuationRing.valuation R x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (ϖ : DiscreteValuationRing.ϖ R), ∀ (u : R), IsUnit u ↔ DiscreteValuationRing.valuation R ϖ u = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  IsUnit x ↔ DiscreteValuationRing.valuation R x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R],\n  (x : R), x ∈ Units R ↔ DiscreteValuationRing.valuation R x = 0 ", "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ DiscreteValuationRing.valuation R x = 0 ", "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] {x : R},\n  IsUnit x ↔ DiscreteValuationRing.valuation R x = 0 "]}
{"docString": "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.", "prompts": "[{\"theorem\":\n  \"∀ {a b : ℤ}, a ≠ 0 → IsLeast {n | 0 < n ∧ ∃ x y, ↑n = a * x + b * y} (Int.gcd a b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every x greater than or equal to 1 is between two successive\\nnatural-number powers of every y greater than one. \"},\n {\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {a b : ℕ},\\n  a ≠ 0 → b ≠ 0 → List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) ∪ List.toFinset (Nat.factors b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` \"}]\n", "prompt_cons": "/-- For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` -/\ntheorem ∀ {a b : ℤ}, a ≠ 0 → IsLeast {n | 0 < n ∧ ∃ x y, ↑n = a * x + b * y} (Int.gcd a b) :=\n\n/-- Every x greater than or equal to 1 is between two successive\nnatural-number powers of every y greater than one. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : Archimedean α] {x y : α},\n  1 ≤ x → 1 < y → ∃ n, y ^ n ≤ x ∧ x < y ^ (n + 1) :=\n\n/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `a`, `b` are positive, the prime divisors of `a * b` are the union of those of `a` and `b` -/\ntheorem ∀ {a b : ℕ},\n  a ≠ 0 → b ≠ 0 → List.toFinset (Nat.factors (a * b)) = List.toFinset (Nat.factors a) ∪ List.toFinset (Nat.factors b) :=\n\n/-- For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers. -/\ntheorem", "choices": ["∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ},\n  Nat.Coprime a b → ∃ N, ∀ n ≥ N, ∃ x y : ℕ, n = a * x + b * y ", "forall {a b N : ℕ}, Nat.gcd a b = 1 → a ≠ 0 → b ≠ 0 → N ≥ a * b - a - b → ∃ x y : ℕ, N = a * x + b * y ", "∀ {a b : ℕ}, a ≠ 0 → b ≠ 0 → Nat.Coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.Coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ", "∀ {a b : ℕ}, Nat.Coprime a b → ∃ N, ∀ n ≥ N, ∃ x y : ℕ, n = a * x + b * y ", "∀ {a b : ℕ}, Nat.gcd a b = 1 → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y "]}
{"docString": "Every field is a ring.", "prompts": "[{\"theorem\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\",\n  \"isProp\": true,\n  \"docString\": \"A field is a valuation ring. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 0. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\",\n  \"isProp\": true,\n  \"docString\": \"An intermediate field contains the ring's 1. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\",\n  \"isProp\": true,\n  \"docString\": \"A linear ordered field that is a floor ring is archimedean. \"}]\n", "prompt_cons": "/-- A field is a valuation ring. -/\ntheorem ∀ (K : Type u) [inst : Field K], ValuationRing K :=\n\n/-- An intermediate field contains the ring's 0. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  0 ∈ S :=\n\n/-- An intermediate field contains the ring's 1. -/\ntheorem ∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\n  1 ∈ S :=\n\n/-- A linear ordered field that is a floor ring is archimedean. -/\ntheorem ∀ (α : Type u_1) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α :=\n\n/-- Every field is a ring. -/\ntheorem", "choices": ["∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K ", "∀ (K : Type u) [inst : Field K], Ring K "]}
{"docString": "The set of units in a ring forms a group.", "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\\n  IsCyclic { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ↑f → IsCyclic G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n", "prompt_cons": "/-- The group of units of a complete normed ring is an open subset of the ring. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x} :=\n\n/-- A finite subgroup of the units of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite { x // x ∈ S }],\n  IsCyclic { x // x ∈ S } :=\n\n/-- A finite subgroup of the unit group of an integral domain is cyclic. -/\ntheorem ∀ {R : Type u_2} {G : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\n  (f : G →* R), Function.Injective ↑f → IsCyclic G :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- The set of units in a ring forms a group. -/\ntheorem", "choices": ["∀ {R : Type u_1} [inst : Ring R], IsGroup (Units R) ", "∀ {R : Type u_1} [inst : Monoid R], IsGroup {x | IsUnit x} ", "∀ {R : Type u_1} [inst : Ring R], IsGroup {x | IsUnit x} ", "∀ {R : Type u_1} [inst : Ring R], IsGroup {x | IsUnit x} ", "forall {R : Type u_1} [inst : Monoid R], Group (Units R) ", "∀ {R : Type u_1} [inst : Ring R], Group (Rˣ) ", "∀ {R : Type u_1} [inst : Ring R], Group (Rˣ) ", "∀ {R : Type u_1} [inst : Monoid R], IsGroup {x | IsUnit x} ", "∀ {R : Type u_1} [inst : Monoid R], Group {x | IsUnit x} ", "∀ {R : Type u_1} [inst : Ring R], Group (Rˣ) "]}
{"docString": "If the direct product of two groups is torsion free then each of the groups is torsion free.", "prompts": "[{\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"Direct products of torsion free groups are torsion free. \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"}]\n", "prompt_cons": "/-- Direct products of torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- Direct products of additive torsion free groups are torsion free. -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i) :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- If the direct product of two groups is torsion free then each of the groups is torsion free. -/\ntheorem", "choices": ["forall {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G H : Type u_1} [inst_G : Group G] [inst_H : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H ", "∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\n  Monoid.IsTorsionFree ((i : η) → Gs i) → ∀ (i : η), Monoid.IsTorsionFree (Gs i) ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "forall {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ ", "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂ "]}
