{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["A finitely-presented group containing a torsion element is finite.",
  "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.",
  "Every injective homomorphism from a finitely generated free group to itself is surjective.",
  "The characteristic polynomial of every matrix has real roots.",
  "Every uniformly continuous function is bounded above.",
  "The number of partitions of a finite set is a prime number.",
  "If a poset has a maximal element, then it has a unique minimal element.",
  "If the set of units of a ring forms a group then the ring is commutative.",
  "The initial object of a category is isomorphic to its terminal object.",
  "If the composition of two functions is continuous, then each of them is continuous."],
 "elaborated-prompts":
 [{"theorem": "∀ {R : Type u} [inst : Semiring R], IsField R ∨ ¬IsField R",
   "some-correct": true,
   "prompt": "Every ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : Semiring R], IsField R ∨ ¬IsField R",
     "∀ {R : Type u} [inst : Semiring R], IsField R ∨ ¬IsField R"],
    ["∀ {R : Type u} [inst : Semiring R], IsField R ∨ ¬IsField R ∨ ¬Nonempty R ∨ ¬Infinite R"],
    ["∀ {R : Type u} [inst : Semiring R], IsField R"],
    ["{R : Type u} → [inst : Semiring R] → Field R"],
    ["(R : Type u) → [inst : Ring R] → Field R"],
    ["∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x : R), x ≠ 0 → ∃ y, x * y = 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ {R : Type u} [inst : Semiring R], IsField R ∨ ¬IsField R",
    " ∀ {R : Type u} [inst : Semiring R], IsField R ∨ ¬IsField R",
    " ∀ {R : Type u} [inst : Semiring R], IsField R",
    " ∀ {R : Type u} [inst : Semiring R], Field R",
    " ∀ (R : Type u) [inst : Ring R], Field R",
    " ∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x : R), x ≠ 0 → ∃ y, x * y = 1 ",
    " ∀ {R : Type u} [inst : Semiring R], IsField R ∨ ¬IsField R ∨ ¬Nonempty R ∨ ¬Infinite R"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
   "some-correct": null,
   "prompt": "Every vector space is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {k : Type u} {V : Type v} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional k V"],
    ["∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V : FdRep k G), FiniteDimensional k (CoeSort.coe V)",
     "∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] {V : FdRep k G}, FiniteDimensional k (CoeSort.coe V)"],
    ["∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V], FiniteDimensional 𝕜 V"],
    ["∀ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional k V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
    " ∀ {k : Type u} {V : Type v} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  FiniteDimensional k V",
    " ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V : FdRep k G), FiniteDimensional k V",
    " ∀ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n    FiniteDimensional k V",
    " ∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V],\n  FiniteDimensional 𝕜 V ",
    " ∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] {V : FdRep k G}, FiniteDimensional k V "]},
  {"theorem": "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "groups":
   [["∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"],
    ["{G : Type u_1} → [inst : Group G] → Monoid G"],
    ["(G : Type u_1) → [inst : Group G] → Monoid G"],
    ["(G : Type u_1) → [inst : Group G] → Monoid G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " ∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " ∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " ∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    " ∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G ",
    " ∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G ",
    " ∀ (G : Type u_1) [inst : Group G], Monoid G",
    " ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ",
    " ∀ (G : Type u_1) [inst : Group G], Monoid G ",
    " ∀ {G : Type u_1} [inst : Group G], Monoid G"]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup α → Fintype.card α = p ∨ Fintype.card α = 0",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "groups":
   [["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup α → Fintype.card α = p ∨ Fintype.card α = 0",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup α → Fintype.card α = p ∨ Fintype.card α = 0"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsSimpleGroup α],\n  Fintype.card α ≠ 0 → Nat.Prime (Fintype.card α)",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsSimpleGroup α],\n  Fintype.card α ≠ 0 → Nat.Prime (Fintype.card α)"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup α → Fintype.card α = p ∧ IsCyclic α ∧ IsSimpleGroup α ∧ p ≠ 2 ∧ p ≠ 3"]],
   "correct": true,
   "comments": "It gives a more complete statement than the provided one",
   "all-elabs":
   [" ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsSimpleGroup α],\n  Fintype.card α ≠ 0 → Nat.Prime (Fintype.card α)",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] [inst_2 : IsSimpleGroup α],\n  Fintype.card α ≠ 0 → Nat.Prime (Fintype.card α)",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup α → Fintype.card α = p ∨ Fintype.card α = 0",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup α → Fintype.card α = p ∨ Fintype.card α = 0",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  IsSimpleGroup α → Fintype.card α = p ∧ IsCyclic α ∧ IsSimpleGroup α ∧ p ≠ 2 ∧ p ≠ 3"]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "groups":
   [["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    " ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G "]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Prime (Fintype.card α)",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "groups":
   [["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Prime (Fintype.card α)",
     "∀ (α : Type u) [inst : Group α] [inst_1 : Fintype α], Prime (Fintype.card α)",
     "∀ (α : Type u) [inst : Group α] [inst_1 : Fintype α], Prime (Fintype.card α)"],
    ["∀ (α : Type u) [inst : Group α] [inst_1 : Fintype α], IsPrimePow (Fintype.card α) → IsSimpleGroup α"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → IsPrimePow (Fintype.card α)"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Finite α → IsPrimePow (Fintype.card α)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Prime (Fintype.card α)",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → IsPrimePow (Fintype.card α) ",
    " ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Finite α → IsPrimePow (Fintype.card α) ",
    " ∀ (α : Type u) [inst : Group α] [inst_1 : Fintype α], Prime (Fintype.card α) ",
    " ∀ (α : Type u) [inst : Group α] [inst_1 : Fintype α], Prime (Fintype.card α) ",
    " ∀ (α : Type u) [inst : Group α] [inst_1 : Fintype α],\n    IsPrimePow (Fintype.card α) → IsSimpleGroup α"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.1801831 s = 0",
   "some-correct": true,
   "prompt": "Every set has Lebesgue measure zero.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.1801831 s = 0",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.1801831 s = 0"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ?m.1801496 = 0",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ?m.1801496 = 0"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ?m.1802006 = 0",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ?m.1802006 = 0"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] {s : Set α},\n  ?m.1802205 = 0"],
    ["∀ (s : Set ℝ), ?m.1801666 s = 0"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α}, ?m.1802099 = 0"]],
   "correct": false,
   "comments": "Unidentified metavariable in the statement. In all elaborations, only the one on reals is true, and coercions need to be removed for it to be true.",
   "all-elabs":
   [" ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ↑↑MeasureTheory.volume s = 0 ",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ↑↑MeasureTheory.volume s = 0 ",
    " ∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0 ",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 ",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 ",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ↑↑volume s = 0 ",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, ↑↑volume s = 0 ",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α}, ↑↑μ univ = 0 ",
    " ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {s : Set α}, ↑↑MeasureTheory.volume s = 0 "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α) [inst_1 : CompactSpace α], IsCompact s"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, IsCompact s → IsCompact s",
     "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, IsCompact s ↔ IsCompact s",
     "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, IsCompact s → IsCompact s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
    " ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    " ∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, IsCompact s → IsCompact s",
    " ∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α) [inst_1 : CompactSpace α], IsCompact s",
    " ∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, IsCompact ↑s ↔ IsCompact s ",
    " ∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, IsCompact s → IsCompact ↑s -------------"]},
  {"theorem":
   "{E : Type u_1} →\n  [inst : NormedAddCommGroup E] →\n    [inst_1 : NormedSpace ℝ E] →\n      [inst_2 : MeasurableSpace E] →\n        [inst_3 : BorelSpace E] →\n          [inst_4 : FiniteDimensional ℝ E] →\n            (μ : MeasureTheory.Measure E) → [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] → Set E → Prop → Prop",
   "some-correct": true,
   "prompt":
   "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
   "groups":
   [["{E : Type u_1} →\n  [inst : NormedAddCommGroup E] →\n    [inst_1 : NormedSpace ℝ E] →\n      [inst_2 : MeasurableSpace E] →\n        [inst_3 : BorelSpace E] →\n          [inst_4 : FiniteDimensional ℝ E] →\n            (μ : MeasureTheory.Measure E) → [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] → Set E → Prop → Prop"],
    ["∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set E} [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] (μ : MeasureTheory.Measure E) [inst_4 : MeasureTheory.Measure.IsAddHaarMeasure μ],\n  MeasurableSet s → ¬BorelSpace ↑s → ↑↑μ s = 0"]],
   "correct": false,
   "comments": "The statement has been replaced with Prop. Ashvni thinks one statement in all-elabs is true, might be better if it is also checked by somebody else - there might be an extra unnecessary hypothesis.",
   "all-elabs":
   [" ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set E}\n  [inst_2 : MeasurableSpace E] [inst_3 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_4 : MeasureTheory.Measure.IsAddHaarMeasure μ], MeasurableSet s → ¬BorelSpace s → μ s = 0 ",
    " ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], Set E → Prop → Prop "]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s",
     "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ a ∈ s, ∃ t, IsClosed t ∧ a ∈ t) → IsClosed s"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
     "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ a ∈ s, ∃ t, IsClosed t ∧ a ∈ t ∧ t ⊆ s) → IsClosed s"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s",
     "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s",
    " ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    " ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (∀ x ∈ s, ∃ t, x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (∀ a ∈ s, ∃ t, IsClosed t ∧ a ∈ t) → IsClosed s ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (∀ a ∈ s, ∃ t, IsClosed t ∧ a ∈ t ∧ t ⊆ s) → IsClosed s"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "groups":
   [["∀ {α : Type u_1} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x = 1",
     "∀ {α : Type u_1} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1",
     "∀ {α : Type u_1} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1"],
    ["∀ {α : Type u} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1",
     "∀ {α : Type u} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1",
     "∀ {α : Type u} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1"],
    ["∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → x = 1",
     "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → x = 1",
     "∀ {α : Type u_1} [inst : Monoid α] {x : α}, IsOfFinOrder x → x = 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → x = 1 ",
    " ∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → x = 1 ",
    " ∀ {α : Type u_1} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1 ",
    " ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x = 1",
    " ∀ {α : Type u} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1 ",
    " ∀ {α : Type u} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1 ",
    " ∀ {α : Type u_1} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1",
    " ∀ {α : Type u_1} [inst : Group α] {x : α}, IsOfFinOrder x → x = 1",
    " ∀ {α : Type u_1} [inst : Monoid α] {x : α}, IsOfFinOrder x → x = 1",
    " ∀ {α : Type u} [inst : Group α] {x : α} (hx : IsOfFinOrder x), x = 1"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt":
   "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G"]},
  {"theorem":
   "∀ (D : Type u) [inst : DivisionRing D], IsField D ∨ Nonempty (Finite D) ∧ ¬Nonempty D",
   "some-correct": true,
   "prompt": "Every division ring is either a field or finite.",
   "groups":
   [["∀ (D : Type u) [inst : DivisionRing D], IsField D ∨ Nonempty (Finite D) ∧ ¬Nonempty D"],
    ["∀ (R : Type u) [inst : DivisionRing R], IsField R ∨ Finite R"],
    ["∀ (R : Type u) [inst : DivisionRing R], IsField R ∨ IsDomain R"]],
   "correct": false,
   "comments": "Could not translate finiteness.",
   "all-elabs":
   [" ∀ (R : Type u) [inst : DivisionRing R], IsField R ∨ Finite R ",
    " ∀ (R : Type u) [inst : DivisionRing R], IsField R ∨ IsDomain R",
    " ∀ (D : Type u) [inst : DivisionRing D], IsField D ∨ Nonempty (Finite D) ∧ ¬(Nonempty D)"]},
  {"theorem":
   "∀ (n : ℕ), n ≠ 0 → ∃ p₁ p₂, Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ n = p₁ * p₂",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "groups":
   [["∀ (n : ℕ), n ≠ 0 → ∃ p₁ p₂, Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ n = p₁ * p₂",
     "∀ (n : ℕ), n ≠ 0 → ∃ p₁ p₂, Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ n = p₁ * p₂"],
    ["∀ (n : ℕ), 0 < n → ∃ p₁ p₂, Prime p₁ → Prime p₂ → n = p₁ * p₂ ∧ Nat.Prime (p₁ * p₂)"],
    ["∀ (n : ℕ), ∃ p₁ p₂, Nat.Prime p₁ → Nat.Prime p₂ → p₁ * p₂ = n"],
    ["∀ (n : ℕ), ∃ p q, Nat.Prime p → Nat.Prime q → n = p * q"],
    ["∀ {x : ℕ}, x ≠ 0 → ∃ p₁ p₂, Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ x = p₁ * p₂ ∧ p₁ ≠ p₂ ∧ p₁ ≠ x ∧ p₂ ≠ x"],
    ["∀ (n : ℕ), ∃ p₁ p₂, Nat.Prime p₁ → Nat.Prime p₂ → n = p₁ * p₂ ∧ p₁ < p₂ ∧ ¬p₁ ∣ p₂ ∧ ¬p₂ ∣ p₁"]],
   "correct": true,
   "comments": "It also understood that natural number in math is separate from natural number in Lean.",
   "all-elabs":
   [" ∀ (n : ℕ), ∃ (p₁ p₂ : ℕ), Nat.Prime p₁ → Nat.Prime p₂ → p₁ * p₂ = n ",
    " ∀ (n : ℕ), n ≠ 0 → ∃ p₁ p₂ : ℕ, Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ n = p₁ * p₂",
    " ∀ (n : ℕ), ∃ p q : ℕ, Nat.Prime p → Nat.Prime q → n = p * q",
    " ∀ (n : ℕ), n ≠ 0 → ∃ p₁ p₂, Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ n = p₁ * p₂",
    " ∀ {x : ℕ}, x ≠ 0 → ∃ p₁ p₂ : ℕ, Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ x = p₁ * p₂ ∧ p₁ ≠ p₂ ∧ p₁ ≠ x ∧ p₂ ≠ x",
    " ∀ n : ℕ, ∃ (p₁ p₂ : ℕ), Nat.Prime p₁ → Nat.Prime p₂ → n = p₁ * p₂ ∧ p₁ < p₂ ∧ ¬p₁ ∣ p₂ ∧ ¬p₂ ∣ p₁",
    " ∀ (n : ℕ), 0 < n → ∃ p₁ p₂ : ℕ, Prime p₁ → Prime p₂ → n = p₁ * p₂ ∧ Nat.Prime (p₁ * p₂)"]},
  {"theorem": "∀ {a : ℕ}, Even a → ∃ b, a = b * b",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "groups":
   [["∀ {a : ℕ}, Even a → ∃ b, a = b * b"],
    ["∀ {n : ℕ}, n % 2 = 0 → ∃ a, n = a * a"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2 ",
    " ∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2 ",
    " ∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2",
    " ∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
    " ∀ {n : ℕ}, n % 2 = 0 → ∃ a, n = a * a ",
    " ∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2",
    " ∀ {a : ℕ}, Even a → ∃ b, b ^ 2 = a ",
    " ∀ {a : ℕ}, Even a → ∃ b, a = b * b ",
    " ∀ {n : ℕ}, Even n → ∃ k, ↑k ^ 2 = n ",
    " ∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ∧ Odd m ∨ n = 0"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
   "some-correct": null,
   "prompt": "Every normal subgroup of a group has finite index.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H"],
    ["∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N ∨ N = ⊤"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H ",
    " ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H ",
    " ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
    " ∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N ∨ N = ⊤"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R],\n  (∀ (P M : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal M → P ≤ M → P = M) ∧\n    ∀ (P M : Ideal R), Ideal.IsPrime P → Ideal.IsPrime M → (P ≤ M ↔ P = M)",
   "some-correct": false,
   "prompt":
   "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R],\n  (∀ (P M : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal M → P ≤ M → P = M) ∧\n    ∀ (P M : Ideal R), Ideal.IsPrime P → Ideal.IsPrime M → (P ≤ M ↔ P = M)"],
    ["∀ {R : Type u} [inst : CommRing R] (P M : Ideal R), Ideal.IsPrime P → Ideal.IsPrime M → P ≤ M → M = P ∨ P < M"],
    ["∀ {R : Type u} [inst : CommRing R] (P M : Ideal R) [inst_1 : Ideal.IsPrime P] [inst_2 : Ideal.IsMaximal M],\n  P ≤ M ∧ ∀ (N : Ideal R) [inst_3 : Ideal.IsPrime N] [inst_4 : Ideal.IsMaximal N], P ≤ N → N = M"],
    ["∀ {R : Type u} [inst : CommRing R],\n  (∀ (P Q : Ideal R), Ideal.IsPrime P → Ideal.IsPrime Q → P ≤ Q → P = Q) →\n    ∀ (M P : Ideal R), Ideal.IsPrime P → P ≤ M → ∃ I, Ideal.IsMaximal I ∧ I = M ∧ P ≤ I"]],
   "correct": false,
   "comments": "The second statement in all-elabs comes close to being true but it assumes P le M for any maximal ideal M",
   "all-elabs":
   [" ∀ {R : Type u} [inst : CommRing R],\n  ∀ (P M : Ideal R), Ideal.IsPrime P → Ideal.IsPrime M → P ≤ M → M = P ∨ P < M",
    " ∀ {R : Type u} [inst : CommRing R] (P M : Ideal R) [inst_1 : Ideal.IsPrime P] [inst_2 : Ideal.IsMaximal M], P ≤ M ∧ ∀ (N : Ideal R) [inst_3 : Ideal.IsPrime N] [inst_4 : Ideal.IsMaximal N], P ≤ N → N = M ",
    " ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P Q : Ideal R), Ideal.IsPrime P → Ideal.IsPrime Q → P ≤ Q → P = Q) → ∀ (M : Ideal R) (P : Ideal R),\n    Ideal.IsPrime P → P ≤ M → ∃ (I : Ideal R), Ideal.IsMaximal I ∧ I = M ∧ P ≤ I",
    " ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R) (M : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal M → P ≤ M → P = M) ∧ ∀ (P M : Ideal R), Ideal.IsPrime P → Ideal.IsPrime M → (P ≤ M ↔ P = M)"]},
  {"theorem":
   "∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β), Continuous self.toFun",
   "some-correct": true,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β), Continuous self.toFun",
     "∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β), Continuous self.toFun"],
    ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun ∧ UniformContinuous self.toFun"]],
   "correct": false,
   "comments": "Given statement is a bit ambiguous, the chosen statement says the opposite of what is wanted.",
   "all-elabs":
   [" ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun",
    " ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun ",
    " ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
    " ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ",
    " ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun ∧ UniformContinuous self.toFun ",
    " ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] (s : Set X), IsCompact s → IsClosed s → CompactSpace X"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {X : Type u} [inst : TopologicalSpace X], (∀ s : Set X, IsCompact s → IsClosed s) → CompactSpace X ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] (h : ∀ s : Set X, IsCompact s → IsClosed s), CompactSpace X ",
    " ∀ {X : Type u} [inst : TopologicalSpace X],\n  (∀ s : Set X, IsCompact s → IsClosed s) → CompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ s : Set X, IsCompact s → IsClosed s) → CompactSpace X ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] (h : ∀ s : Set X, IsCompact s → IsClosed s), CompactSpace X",
    " ∀ {X : Type u} [inst : TopologicalSpace X],\n  (∀ s : Set X, IsCompact s → IsClosed s) → CompactSpace X",
    " ∀ {X : Type u} [inst : TopologicalSpace X] (hX : ∀ s : Set X, IsCompact s → IsClosed s), CompactSpace X ",
    " ∀ {X : Type u} [inst : TopologicalSpace X], ∀ s : Set X, IsCompact s → IsClosed s → CompactSpace X",
    " ∀ {X : Type u} [inst : TopologicalSpace X] (hX : ∀ (s : Set X), IsCompact s → IsClosed s), CompactSpace X"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {α : Type u} [inst : CommRing α] {a b : α}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)"],
    ["∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
     "∀ {R : Type u_1} [inst : CommRing R] (e f : R), IsIdempotentElem e → IsIdempotentElem f → IsIdempotentElem (e + f)"],
    ["∀ {R : Type u_1} [inst : CommRing R] (I J : Submodule R R),\n  IsIdempotentElem I → IsIdempotentElem J → IsIdempotentElem (I + J)"],
    ["∀ {R : Type u_4} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)"]],
   "correct": false,
   "comments": "Statement is correct if sum is replaced by addition of 2 elements. Maybe somebody else should check it.",
   "all-elabs":
   [" ∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    " ∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    " ∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    " ∀ {R : Type u_4} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    " ∀ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    " ∀ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    " ∀ {R : Type u} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    " ∀ {R : Type u_1} [inst : CommRing R] (e f : R), IsIdempotentElem e → IsIdempotentElem f → IsIdempotentElem (e + f)",
    " ∀ {α : Type u} [inst : CommRing α] {a b : α}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ",
    " ∀ {R : Type u_1} [inst : CommRing R] (I J : Submodule R R), IsIdempotentElem I → IsIdempotentElem J → IsIdempotentElem (I + J) "]},
  {"theorem":
   "∀ {α : Type u} [inst : CommGroup α], ∃ a, ∀ (g : ?m.44869332 a), IsOfFinOrder g ↔ g = a⁻¹ * g * a",
   "some-correct": null,
   "prompt": "The automorphism group of an Abelian group is cyclic.",
   "groups":
   [["∀ {α : Type u} [inst : CommGroup α], ∃ a, ∀ (g : ?m.44869332 a), IsOfFinOrder g ↔ g = a⁻¹ * g * a"]],
   "correct": false,
   "comments": "Unidentified metavariable in the statement. There is a typeclass inference error in the all-elabs statement. It is also otherwise incorrect.",
   "all-elabs":
   [" ∀ {α : Type u} [inst : CommGroup α], ∃ a, ∀ g, IsOfFinOrder g ↔ g = a⁻¹ * g * a "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : TopologicalSpace α] (f : ℝ → ℝ) {x : ℝ},\n  x ∈ Set.Icc 0 1 → Function.IsFixedPt f x → ∀ (n : ℕ), ∃ y ∈ Set.Icc 0 1, Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "groups":
   [["∀ {α : Type u_1} [inst : TopologicalSpace α] (f : ℝ → ℝ) {x : ℝ},\n  x ∈ Set.Icc 0 1 → Function.IsFixedPt f x → ∀ (n : ℕ), ∃ y ∈ Set.Icc 0 1, Function.IsPeriodicPt f n y"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u_1} [inst : TopologicalSpace α] (f : ℝ → ℝ) {x : ℝ},\n  x ∈ Set.Icc 0 1 → Function.IsFixedPt f x → ∀ (n : ℕ), ∃ y ∈ Set.Icc 0 1, Function.IsPeriodicPt f n y "]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ∪ t ⊆ sᶜ ∪ tᶜ",
   "some-correct": true,
   "prompt":
   "The complement of the union of two sets contains the union of their complements.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ∪ t ⊆ sᶜ ∪ tᶜ",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ∪ t ⊆ sᶜ ∪ tᶜ",
     "∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s ∪ t ⊆ sᶜ ∪ tᶜ",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α},\n  s ∪ t ⊆ sᶜ ∪ tᶜ ∧\n    sᶜ ∪ tᶜ ⊆ sᶜ ∪ tᶜ ∧\n      sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n        sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n          sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n            sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n              sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                  sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                    sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                      sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                        sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                          sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                            sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                              sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                  sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                    sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                      sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                        sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                          sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                            sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                              sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                                sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                                  sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                                    sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                                      sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                                        sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧\n                                                          sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α},\n  s ∪ t ⊆ sᶜ ∪ tᶜ ∨ s ∪ t ⊆ sᶜ ∧ t ⊆ tᶜ ∨ s ⊆ sᶜ ∧ t ⊆ tᶜ ∨ s = sᶜ ∨ t = tᶜ ∨ sᶜ = tᶜ"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ"]],
   "correct": false,
   "comments": "There is an unnecessary topological space hypothesis.",
   "all-elabs":
   [" ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ∪ t ⊆ sᶜ ∪ tᶜ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ∪ t ⊆ sᶜ ∪ tᶜ ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s ∪ t ⊆ sᶜ ∪ tᶜ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α},\n  sᶜ ∪ tᶜ = (s ∪ t)ᶜ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ∪ t ⊆ sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ ⊆ sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ∧ sᶜ ∪ tᶜ = sᶜ ∪ tᶜ ",
    " ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, s ∪ t ⊆ sᶜ ∪ tᶜ ∨ s ∪ t ⊆ sᶜ ∧ t ⊆ tᶜ ∨ s ⊆ sᶜ ∧ t ⊆ tᶜ ∨ s = sᶜ ∨ t = tᶜ ∨ sᶜ = tᶜ"]},
  {"theorem": "∀ (x : ℚ), Real.sqrt ↑x = ↑(Rat.sqrt x)",
   "some-correct": null,
   "prompt": "The square root of an rational number is rational.",
   "groups": [["∀ (x : ℚ), Real.sqrt ↑x = ↑(Rat.sqrt x)"]],
   "correct": true,
   "comments": "Interesting way to prove it!",
   "all-elabs":
   [" ∀ {q : ℚ}, Real.sqrt (↑q) ∈ Set.range Rat.cast ",
    " Rat.sqrt = Rat.sqrt ∘ Rat.cast ∘ Rat.sqrt ∘ Rat.inv ∘ Rat.sqrt ∘ Rat.cast ∘ Rat.inv ∘ Rat.sqrt",
    " ∀ (q : ℚ), Real.sqrt (q : ℝ) ∈ Set.range Rat.cast",
    " ∀ (x : ℚ), Real.sqrt x = Rat.sqrt x",
    " ∀ {p : ℚ}, ∃ q, Rat.sqrt p = ↑q ∨ Rat.sqrt p = -↑q ascript"]},
  {"theorem":
   "{R : Type u} →\n  {M : Type v} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] → [inst_3 : Module.Free R M] → [inst : Module.Finite R M] → CommRing R",
   "some-correct": null,
   "prompt": "If a module over a ring is free, then the ring is commutative.",
   "groups":
   [["{R : Type u} →\n  {M : Type v} →\n    [inst : Ring R] →\n      [inst_1 : AddCommGroup M] →\n        [inst_2 : Module R M] → [inst_3 : Module.Free R M] → [inst : Module.Finite R M] → CommRing R"],
    ["(R : Type u_1) →\n  (M : Type u_2) →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → [inst_3 : Module.Free R M] → CommRing R"],
    ["{R : Type u} →\n  {M : Type v} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → [inst_3 : Module.Free R M] → CommRing R"],
    ["{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → [inst_3 : Module.Free R M] → CommRing R"],
    ["(R : Type u_1) →\n  (M : Type u_2) →\n    [inst : Ring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → [inst_3 : Module.Free R M] → CommRing R"],
    ["{R : Type u} →\n  {M : Type v} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → [inst_3 : Module.Free R M] → CommRing R"],
    ["(R : Type u_3) →\n  (M : Type u_4) →\n    [inst : Ring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → [inst_3 : Module.Free R M] → CommRing R"],
    ["{R : Type u_3} →\n  {M : Type u_4} →\n    [inst : Ring R] →\n      [inst_1 : StrongRankCondition R] →\n        [inst_2 : AddCommGroup M] → [inst_3 : Module R M] → [inst_4 : Module.Free R M] → CommRing R"]],
   "correct": true,
   "comments": "There is an extra unwanted finiteness hypothesis.",
   "all-elabs":
   [" ∀ (R : Type u_1) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " ∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R",
    " ∀ (R : Type u_1) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " ∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R",
    " ∀ (R : Type u_3) (M : Type u_4) [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R ",
    " ∀ {R : Type u_3} {M : Type u_4} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M], CommRing R",
    " ∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], ∀ [Module.Finite R M], CommRing R "]},
  {"theorem":
   "∀ {n : ℕ}, 10 < n → ∃ x y z, y ∈ {x_1 | ?m.47318208 x y z x_1} ∧ n = x ^ 2 + y ∧ ∃ u v, Nat.Prime u ∧ n = x ^ 2 + y + u",
   "some-correct": false,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "groups":
   [["∀ {n : ℕ}, 10 < n → ∃ x y z, y ∈ {x_1 | ?m.47318208 x y z x_1} ∧ n = x ^ 2 + y ∧ ∃ u v, Nat.Prime u ∧ n = x ^ 2 + y + u"],
    ["∀ {n : ℕ}, 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ∧ y ≠ 2 ∧ y ≠ 3 ∧ y ≠ 5 ∧ y ≠ 7 ∧ y ≠ 11"],
    ["∀ {n : ℕ}, 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ∧ 0 < y ∧ y ≤ n"],
    ["∀ {n : ℕ}, 10 < n → ∃ x y z, n = x ^ 2 + z ∧ Nat.Prime z ∧ y ^ 2 + 1 = 0"],
    ["∀ {n : ℕ}, 10 < n → ∃ x y z, y ^ 2 + z ^ 2 = n ∧ Nat.Prime z"],
    ["∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ∧ 0 < p ∧ ¬p ∣ x"],
    ["∀ {n : ℕ}, 10 < n → ∃ x y p, n = x ^ 2 + y ^ 2 ∧ Nat.Prime p ∧ 2 ≤ p ∧ p ≤ n ∧ ¬(x = 0 ∧ y = 0)"],
    ["∀ {n : ℕ}, 10 < n → ∃ x y p, n = x ^ 2 + y ^ 2 ∧ Nat.Prime p ∧ (y = 0 ∨ ¬Nat.Prime y) ∧ p ∣ n"]],
   "correct": false,
   "comments": "Unidentified metavariable in the statement. Other extra hallucinated goals added in other statements.",
   "all-elabs":
   [" ∀ {n : ℕ}, 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ∧ y ≠ 2 ∧ y ≠ 3 ∧ y ≠ 5 ∧ y ≠ 7 ∧ y ≠ 11",
    " ∀ {n : ℕ}, 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ∧ 0 < y ∧ y ≤ n",
    " ∀ {n : ℕ}, 10 < n → ∃ x y z, n = x ^ 2 + z ∧ Nat.Prime z ∧ y ^ 2 + 1 = 0",
    " ∀ {n : ℕ}, 10 < n → ∃ x y z, y ^ 2 + z ^ 2 = n ∧ Nat.Prime z",
    " ∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ∧ 0 < p ∧ ¬(p ∣ x)",
    " ∀ {n : ℕ}, 10 < n → ∃ x y p, n = x ^ 2 + y ^ 2 ∧ Nat.Prime p ∧ 2 ≤ p ∧ p ≤ n ∧ ¬(x = 0 ∧ y = 0)",
    " ∀ {n : ℕ}, 10 < n → ∃ x y p, n = x ^ 2 + y ^ 2 ∧ Nat.Prime p ∧ (y = 0 ∨ ¬Nat.Prime y) ∧ p ∣ n",
    " ∀ {n : ℕ}, 10 < n → ∃ x y z, y ∈ {Nat.prime _ | Nat.Prime _} ∧ n = x ^ 2 + y ∧ ∃ u v, Nat.Prime u ∧ n = x ^ 2 + y + u"]},
  {"theorem":
   "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "groups":
   [["∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c"],
    ["∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c"]],
   "correct": true,
   "comments": "Extra assumptions in hypothesis, statement a bit ambiguous.",
   "all-elabs":
   [" ∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    " ∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    " ∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    " ∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ",
    " ∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    " ∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    " ∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ----"]},
  {"theorem":
   "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S) {r : R}, f r = 0 → r = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "groups":
   [["∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S) {r : R}, f r = 0 → r = 0",
     "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} {a : R}, f a = 0 → a = 0"],
    ["∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S}, ∀ r ∈ RingHom.ker f, r = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, f r = 0 → r = 0"],
    ["∀ {R : Type u_1} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) {a : R}, f a = 0 → a = 0"]],
   "correct": true,
   "comments": "Generalized version",
   "all-elabs":
   [" ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R},\n  f r = 0 → r = 0 ",
    " ∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S) {r : R},\n  f r = 0 → r = 0 ",
    " ∀ {R : Type u_1} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) {a : R},\n  f a = 0 → a = 0 ",
    " ∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} {a : R}, f a = 0 → a = 0 ",
    " ∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S}, ∀ (r : R), r ∈ RingHom.ker f → r = 0"]},
  {"theorem": "∀ {p q : Prop}, (p → q) → q → p",
   "some-correct": null,
   "prompt": "Implication `→` is symmetric. If `P → Q` then `Q → P`.",
   "groups":
   [["∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p",
     "∀ {p q : Prop}, (p → q) → q → p"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {p q : Prop}, (p → q) → q → p ",
    " ∀ {p q : Prop}, (p → q) → q → p ",
    " ∀ {p q : Prop}, (p → q) → q → p ",
    " ∀ {p q : Prop}, (p → q) → q → p ",
    " ∀ {p q : Prop}, (p → q) → q → p ",
    " ∀ {p q : Prop}, (p → q) → q → p ",
    " ∀ {p q : Prop}, (p → q) → q → p",
    " ∀ {p q : Prop}, (p → q) → q → p",
    " ∀ {p q : Prop}, (p → q) → q → p",
    " ∀ {p q : Prop}, (p → q) → q → p"]},
  {"theorem": "∀ {m n : ℕ}, (∀ (p : ℕ), Nat.Prime p → p ∣ m ↔ p ∣ n) ↔ m = n",
   "some-correct": true,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "groups":
   [["∀ {m n : ℕ}, (∀ (p : ℕ), Nat.Prime p → p ∣ m ↔ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∀ (p : ℕ), Nat.Prime p → p ∣ m ↔ p ∣ n) ↔ m = n"],
    ["∀ {a b : ℕ}, (∀ (p : ℕ), Nat.Prime p → (p ∣ a ↔ p ∣ b)) ↔ a = b"],
    ["∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n"],
    ["∀ {m n : ℕ}, (∀ (p : ℕ), Irreducible p → p ∣ m ↔ p ∣ n) ↔ m = n"],
    ["∀ {m n : ℕ}, (∃ p, ∃ (_ : Nat.Prime p), p ∣ m ∧ p ∣ n) ↔ m = n"]],
   "correct": false,
   "comments": "It gives the correct definition of equality of prime numbers.",
   "all-elabs":
   [" ∀ {m n : ℕ}, (∀ (p : ℕ), Nat.Prime p → p ∣ m ↔ p ∣ n) ↔ m = n ",
    " ∀ {m n : ℕ}, (∀ (p : ℕ), Nat.Prime p → p ∣ m ↔ p ∣ n) ↔ m = n ",
    " ∀ {m n : ℕ}, (∃ p : ℕ, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ",
    " ∀ {m n : ℕ}, (∀ (p : ℕ), Irreducible p → p ∣ m ↔ p ∣ n) ↔ m = n ",
    " ∀ {m n : ℕ}, (∃ (p : ℕ) (hp : Nat.Prime p), p ∣ m ∧ p ∣ n) ↔ m = n ",
    " ∀ {a b : ℕ}, (∀ (p : ℕ) (hp : Nat.Prime p), p ∣ a ↔ p ∣ b) ↔ a = b",
    " ∀ {a b : ℕ}, a = b ↔ ∃ p, Prime p ∧ p ∣ a ∧ p ∣ b ∧ ¬(p ∣ a ∧ ¬p ∣ b) ∧ ¬(¬p ∣ a ∧ p ∣ b) ∧ (¬p ∣ a → p ∣ b) ∧ (p ∣ a → ¬p ∣ b)"]}],
 "elaborated": 30}