{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["Every set of Borel measure zero is Lebesgue measurable.",
  "There are `3` prime numbers below `8`.",
  "Every commutative ring is a monoid.",
  "The diameter of a singleton space is `0`."],
 "elaborated-prompts":
 [{"theorem": "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
     "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
     "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p"],
    ["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ∨ p % 2 = 3 ∨ p % 2 = 5 ∨ p % 2 = 7"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
    " ∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p ",
    " ∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p ----",
    " ∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p ----",
    " ∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ∨ p % 2 = 3 ∨ p % 2 = 5 ∨ p % 2 = 7"]},
  {"theorem": "∀ {n : ℕ}, n ≠ 0 → ∃ m, n < m ∧ ¬Even m ∧ n ≤ m ∧ m ≤ n ∧ Odd m",
   "some-correct": true,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["∀ {n : ℕ}, n ≠ 0 → ∃ m, n < m ∧ ¬Even m ∧ n ≤ m ∧ m ≤ n ∧ Odd m"],
    ["∀ (n : ℕ), Odd n → ∃ m, n ≤ m ∧ Odd m ∧ ¬m < n"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" Set.Infinite {n : ℕ | n % 2 = 1} ",
    " Set.Infinite {m : ℕ | ¬ Even m} ",
    " ∃ᶠ (n : ℕ) in Filter.atTop, Odd n ∧ Odd (n + 1) ∧ Odd (n + 2)",
    " ∀ (n : ℕ), Odd n → ∃ m, n ≤ m ∧ Odd m ∧ ¬m < n",
    " ∀ (a : ℕ), 2 < a → ∃ b, Odd b ∧ a < b ∧ Even (a + 1)",
    " ∀ {n : ℕ}, n ≠ 0 → ∃ m, n < m ∧ ¬Even m ∧ n ≤ m ∧ m ≤ n ∧ Odd m"]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → ¬p = 2 → p = 3 ∨ p = 5 ∨ p = 7",
   "some-correct": true,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → ¬p = 2 → p = 3 ∨ p = 5 ∨ p = 7"],
    ["∀ (p : ℕ), Nat.Prime p → p % 2 = 1 → p = 3"],
    ["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p < 3 → ¬p % 2 = 1"],
    ["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p < 3 ↔ p = 2"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ (p : ℕ), Nat.Prime p → p % 2 = 1 → p = 3",
    " ∃! (p : ℕ), Nat.Prime p ∧ p % 2 = 1 ∧ p < 5",
    " ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p < 3 → ¬p % 2 = 1",
    " ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p < 3 ↔ p = 2",
    " ∀ {p : ℕ}, Nat.Prime p → ¬(p = 2) → p = 3 ∨ p = 5 ∨ p = 7"]},
  {"theorem": "∀ {n : ℕ}, Odd n → ∃ p, Nat.Prime p ∧ n < p ∧ Odd p",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups": [["∀ {n : ℕ}, Odd n → ∃ p, Nat.Prime p ∧ n < p ∧ Odd p"]],
   "correct": true,
   "comments": "The odd hypothesis is not required but still true.",
   "all-elabs":
   [" Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    " Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    " Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    " Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    " Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    " Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
    " ∀ {n : ℕ}, Odd n → ∃ (p : ℕ), Nat.Prime p ∧ n < p ∧ Odd p",
    " ∀ {n : ℕ}, Nat.Prime (2 * n + 1) → n ≠ 0 ∧ Nat.Prime (2 * n + 1)"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {𝕜 : Type u} {V : Type v} [inst : DivisionRing 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V],\n  Module.rank 𝕜 V = 2 → FiniteDimensional 𝕜 V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {𝕜 : Type u} {V : Type v} [inst : DivisionRing 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {n : ℕ}\n  [inst_3 : AddTorsor V V], Module.rank 𝕜 V = 2 → FiniteDimensional 𝕜 V"],
    ["∀ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  Module.rank k V = 2 → FiniteDimensional k V",
     "∀ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  Module.rank k V = 2 → FiniteDimensional k V"],
    ["∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V],\n  Module.rank 𝕜 V = 2 → FiniteDimensional 𝕜 V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    " ∀ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  (h : Module.rank k V = 2), FiniteDimensional k V ",
    " ∀ {𝕜 : Type u} {V : Type v} [inst : DivisionRing 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V],\n  Module.rank 𝕜 V = 2 → FiniteDimensional 𝕜 V ",
    " ∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V],\n  Module.rank 𝕜 V = 2 → FiniteDimensional 𝕜 V ",
    " ∀ {k : Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V],\n  Module.rank k V = 2 → FiniteDimensional k V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (h : Module.rank K V = 2),\n  FiniteDimensional K V ",
    " ∀ {𝕜 : Type u} {V : Type v} [inst : DivisionRing 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {n : ℕ} [inst_3 : AddTorsor V V],\n  Module.rank 𝕜 V = 2 → FiniteDimensional 𝕜 V "]},
  {"theorem": "{K : Type u_1} → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["{K : Type u_1} → [inst : Field K] → DivisionRing K",
     "{K : Type u_1} → [inst : Field K] → DivisionRing K",
     "{K : Type u_1} → [inst : Field K] → DivisionRing K"],
    ["{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K"],
    ["{R : Type u} → [inst : Field R] → DivisionRing R"],
    ["(K : Type u) → [inst : Field K] → DivisionRing K"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {K : Type u} [inst : Field K], DivisionRing K ",
    " ∀ {K : Type u} [inst : Field K], DivisionRing K ",
    " ∀ {K : Type u} [inst : Field K], DivisionRing K ",
    " ∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    " ∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    " ∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    " ∀ (K : Type u) [inst : Field K], DivisionRing K ",
    " ∀ {R : Type u} [inst : Field R], DivisionRing R"]},
  {"theorem":
   "∀ {α : Type u} [inst : Bornology α] {ι : Type v}, (ι → α) → Cardinal.mk ι = 2 → BoundedSpace α",
   "some-correct": true,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {α : Type u} [inst : Bornology α] {ι : Type v}, (ι → α) → Cardinal.mk ι = 2 → BoundedSpace α"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": false,
   "comments": "Statement is ambiguous.",
   "all-elabs":
   [" ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Module.rank K V = 2), FiniteDimensional K V ",
    " ∀ {α : Type u} [inst : Bornology α] {ι : Type v} (f : ι → α) (h : Cardinal.mk ι = 2), BoundedSpace α"]},
  {"theorem": "∀ (n : ℕ), ∃ m, Nat.succ m = n",
   "some-correct": true,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ m, Nat.succ m = n",
     "∀ {n : ℕ}, ∃ m, Nat.succ m = n",
     "∀ (n : ℕ), ∃ m, m + 1 = n"],
    ["∀ {n : ℕ}, ∃ m, m = n + 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ (n : ℕ), ∃ m, Nat.succ m = n ",
    " ∀ {n : ℕ}, ∃ m, Nat.succ m = n",
    " ∀ {n : ℕ}, ∃ m, m = n + 1 ",
    " ∀ (n : ℕ), ∃ m, m + 1 = n"]},
  {"theorem": "∀ (n : ℕ), n < Nat.succ n",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n ≤ n + 1",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < n + 1",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ {a : ℕ}, a ≤ a + 1",
     "∀ {α : Type u_9} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α] (n : ℕ), n ≤ n + 1"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ (n : ℕ), n < Nat.succ n ",
    " ∀ (n : ℕ), n ≤ n + 1 ",
    " ∀ (n : ℕ), n < Nat.succ n",
    " ∀ (n : ℕ), n < n + 1 ",
    " ∀ (n : ℕ), n < n.succ",
    " ∀ {a : ℕ}, a ≤ a + 1",
    " ∀ {α : Type u_9} [inst : Zero α] [inst_1 : One α] [inst_2 : LE α] [self : ZeroLEOneClass α], ∀ n : ℕ, n ≤ ↑(n + 1) "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s ∧ ↑↑μ s ≠ ⊤ → ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s",
   "some-correct": false,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s ∧ ↑↑μ s ≠ ⊤ → ∃ t, s ⊆ t ∧ MeasurableSet t ∧ ↑↑μ t = ↑↑μ s"],
    ["∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] (s : Set α),\n  MeasurableSet s"],
    ["∀ {α : Type u_5} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α],\n  MeasureTheory.Measure α → MeasurableSet Set.univ"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] (s : Set α),\n  MeasurableSet s",
    " ∀ {α : Type u_5} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α), MeasurableSet (Set.univ : Set α) ",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s ∧ μ s ≠ ⊤ → ∃ t, s ⊆ t ∧ MeasurableSet t ∧ μ t = μ s "]},
  {"theorem": "∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n ∧ ¬IsSquare (n ^ 2)",
   "some-correct": false,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n ∧ ¬IsSquare (n ^ 2)",
     "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p ∧ ¬IsSquare (p ^ 2)"]],
   "correct": false,
   "comments": "Extra unnecessary goal",
   "all-elabs":
   [" ∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n ∧ ¬IsSquare (n ^ 2)",
    " ∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p ∧ ¬IsSquare (p ^ 2)"]},
  {"theorem": "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Odd p → 2 < p",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Odd p → 2 < p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Odd p → p > 2"],
    ["∀ (p : ℕ), Nat.Prime p → Odd p → 2 < p",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], 2 < p ∧ Odd p ∧ ↑p ≠ 0"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p ∧ p ≠ 3"],
    ["∀ (p : ℕ), Nat.Prime p → Odd p → 2 < p ∧ Nat.minFac p = 2"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ (p : ℕ), Nat.Prime p → Odd p → 2 < p ",
    " ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (h : Odd p), 2 < p",
    " ∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Odd p → p > 2 ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] (h : Odd p), 2 < p ∧ p ≠ 3",
    " ∀ (p : ℕ), Nat.Prime p → Odd p → 2 < p ∧ Nat.minFac p = 2",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], 2 < p ∧ Odd p ∧ (p : ℤ) ≠ 0"]},
  {"theorem":
   "∀ (a b x y u v r s : ℕ), a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ∧ b = r ^ 2 + s ^ 2 ↔ ∃ q p, a * b = q ^ 2 + p ^ 2",
   "some-correct": true,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ (a b x y u v r s : ℕ), a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ∧ b = r ^ 2 + s ^ 2 ↔ ∃ q p, a * b = q ^ 2 + p ^ 2"],
    ["∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  ∃ x y z u v w,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 →\n      ∃ r s t u_1 v, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u_1 ^ 2"],
    ["∀ {α : Type u} [inst : CommRing α] (a b : α),\n  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n    (∃ u v w x, b = u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["∀ (a b : ℕ),\n  ∃ x y z w u v u_1 v_1,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ b = u ^ 2 + v ^ 2 + u_1 ^ 2 + v_1 ^ 2 ∧ ∃ r s, a * b = r ^ 2 + s ^ 2"],
    ["∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  ∃ x y z w a' b',\n    a = (x + y) ^ 2 + (z + w) ^ 2 ∧ b = a' ^ 2 + b' ^ 2 ∧ a * b = (x * a' + y * b') ^ 2 + (z * a' + w * b') ^ 2"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ {R : Type u_1} [inst : CommRing R] (a b : R), ∃ x y z u v w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u v, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
    " ∀ {α : Type u} [inst : CommRing α] (a b : α),\n    (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n      (∃ u v w x, b = u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) →\n        ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ",
    " ∀ (a b : ℕ), ∃ x y z w u v u_1 v_1,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ b = u ^ 2 + v ^ 2 + u_1 ^ 2 + v_1 ^ 2 ∧ ∃ r s, a * b = r ^ 2 + s ^ 2",
    " ∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n ∃ x y z w a' b' : R,\n    a = (x + y) ^ 2 + (z + w) ^ 2 ∧ b = a' ^ 2 + b' ^ 2 ∧ a * b = (x * a' + y * b') ^ 2 + (z * a' + w * b') ^ 2",
    " ∀ (a b x y u v r s : ℕ),\n    a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 ∧ b = r ^ 2 + s ^ 2 ↔ ∃ q p : ℕ, a * b = q ^ 2 + p ^ 2 "]},
  {"theorem":
   "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    " ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    " ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun → UniformContinuous self.toFun"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun → UniformContinuous self.toFun ",
    " ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f "]},
  {"theorem":
   "∀ (p₁ p₂ p₃ : ℕ), Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ ≠ p₃ → p₂ ≠ p₃ → p₁ + p₂ = p₃ → false = true",
   "some-correct": true,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["∀ (p₁ p₂ p₃ : ℕ), Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ ≠ p₃ → p₂ ≠ p₃ → p₁ + p₂ = p₃ → false = true"],
    ["∀ {p₁ p₂ p₃ : ℕ}, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → Nat.Prime p₃ → p₁ + p₂ = p₃ → False"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ¬(∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6) ",
    " ¬∃ p₁ p₂ : ℕ, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → 6 = p₁ + p₂",
    " ¬∃ p₁ p₂, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ + p₂ = 6",
    " ∀ (p q : ℕ), Nat.Prime p → Nat.Prime q → p + q = 6 → p = 2 ∧ q = 3 ∨ p = 3 ∧ q = 2 ∨ p = q = 1 ∨ p = q = 5",
    " ∀ {p₁ p₂ p₃ : ℕ}, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → Nat.Prime p₃ → p₁ + p₂ = p₃ → False ",
    " ∀ (p₁ p₂ p₃ : ℕ), Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ ≠ p₃ → p₂ ≠ p₃ → p₁ + p₂ = p₃ → false"]},
  {"theorem": "∀ (a : ℤ), ¬Irrational ↑a ∧ (0 < Int.natAbs a ∨ a = 0)",
   "some-correct": false,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (a : ℤ), ¬Irrational ↑a ∧ (0 < Int.natAbs a ∨ a = 0)"],
    ["∀ {x : ℤ}, Irrational ↑x → 0 = x ∨ 1 = x ∨ -1 = x"]],
   "correct": false,
   "comments": "Extra unnecessary goals",
   "all-elabs":
   [" ∀ {x : ℤ}, Irrational x → 0 = x ∨ 1 = x ∨ -1 = x",
    " ∀ (a : ℤ), ¬Irrational a ∧ (0 < a.natAbs ∨ a = 0)"]},
  {"theorem": "∀ {R : Type u} [inst : Ring R] {r : R}, IsUnit r ↔ r = 1",
   "some-correct": true,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R] {r : R}, IsUnit r ↔ r = 1"],
    ["∀ {R : Type u_1} [inst : CommRing R], IsUnit 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ {R : Type u} [inst : Ring R], IsUnit 1 ",
    " ∀ {R : Type u_1} [inst : CommRing R], IsUnit (1 : R) ",
    " ∀ {R : Type u} [inst : Ring R] {r : R}, IsUnit r ↔ r = 1 "]},
  {"theorem": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H"],
    ["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H ",
    " ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H ",
    " ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H ",
    " ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H"]},
  {"theorem": "∀ {a b : ℕ}, a + b ∈ Set.range id",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["∀ {a b : ℕ}, a + b ∈ Set.range id", "∀ {m n : ℕ}, ∃ p, m + n = p"],
    ["∀ {a b : ℕ}, a ∣ b ↔ ∃ c, a + c = b"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {a b : ℕ}, a + b ∈ Set.range id",
    " ∀ {m n : ℕ}, ∃ p : ℕ, m + n = p ",
    " ∀ {a b : ℕ}, a ∣ b ↔ ∃ c, a + c = b ",
    " ∀ {m n : ℕ}, m + n ≤ ⊤ → ∃ k, m + n = k ∧ k ≤ ⊤ "]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (id x)",
   "some-correct": true,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (id x)"],
    ["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder 1"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" IsOfFinOrder 1",
    " IsOfFinOrder 1",
    " ∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1 ",
    " ∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
    " ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (1 : G) ",
    " ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder (id x) "]},
  {"theorem": "∀ {q : ℕ}, Nat.Prime q ↔ q = 2 ∨ q = 3 ∨ q = 5 ∨ q = 7",
   "some-correct": true,
   "prompt": "`7` is a prime number.",
   "groups": [["∀ {q : ℕ}, Nat.Prime q ↔ q = 2 ∨ q = 3 ∨ q = 5 ∨ q = 7"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7",
    " Nat.Prime 7 ",
    " Nat.Prime 7 ",
    " Nat.Prime 7 ",
    " Nat.Prime 7 ∧ Nat.Prime 7",
    " ∀ {q : ℕ}, Nat.Prime q ↔ q = 2 ∨ q = 3 ∨ q = 5 ∨ q = 7"]},
  {"theorem": "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"],
    ["∀ {α : Type u_1} [inst : Finite α], Set.Finite {x | x ∈ ∅} ∧ ∀ (s : Set α), Set.Finite s → ∃ a ∈ s, a ∈ ∅"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    " ∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ",
    " ∀ {α : Type u_1} [inst : Finite α], Set.Finite {x | x ∈ ∅} ∧ ∀ (s : Set α), Set.Finite s → ∃ a, a ∈ s ∧ a ∈ ∅"]},
  {"theorem":
   "∀ {α : Type u} {s : Set α}, Infinite ↑s → Set.Finite s ∧ Nonempty ↑s ∧ ∃ t ⊆ s, Set.Finite t",
   "some-correct": true,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, Infinite ↑s → Set.Finite s ∧ Nonempty ↑s ∧ ∃ t ⊆ s, Set.Finite t"],
    ["∀ {α : Type u} (s : Set α), Infinite ↑s → ∃ t, Set.Finite t ∧ t ⊆ s"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} (s : Set α), Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
    " ∀ {α : Type u} [inst : Infinite α], ∃ s, Set.Finite s ∧ s ⊆ Set.univ",
    " ∀ {α : Type u} {s : Set α}, Infinite s → Set.Finite s ∧ Nonempty s ∧ ∃ t ⊆ s, Set.Finite t"]},
  {"theorem":
   "∀ (𝕜 : Type u_1) [inst : DivisionRing 𝕜] (a : 𝕜), 10 = a ^ 2 ∨ 10 = a ^ 3 → ¬IsField 𝕜",
   "some-correct": false,
   "prompt": "There is no field of order `10`.",
   "groups":
   [["∀ (𝕜 : Type u_1) [inst : DivisionRing 𝕜] (a : 𝕜), 10 = a ^ 2 ∨ 10 = a ^ 3 → ¬IsField 𝕜"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ (𝕜 : Type u_1) [inst : DivisionRing 𝕜] (a : 𝕜), 10 = a ^ 2 ∨ 10 = a ^ 3 → ¬IsField 𝕜"]},
  {"theorem":
   "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b ∧ Odd a ∧ Odd b ∧ ∀ (c : ℕ), Odd c → c ≠ a ∧ c ≠ b → Odd (a + b + c)",
   "some-correct": true,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b ∧ Odd a ∧ Odd b ∧ ∀ (c : ℕ), Odd c → c ≠ a ∧ c ≠ b → Odd (a + b + c)"],
    ["∀ {n : ℕ}, Odd n → ∃ x y, n = x + y ∧ x ≠ y ∧ x ≠ y ∧ y ≠ 0"],
    ["∀ {n : ℕ}, Odd n → ∃ x y, Nat.Prime x → Nat.Prime y → x ≠ y → n = x * y ∧ n ≠ x * x ∧ n ≠ y * y"],
    ["∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b ∧ Odd a ∧ Odd b"],
    ["∀ {m : ℕ}, Odd m → ∃ a b, a ≠ b ∧ m = a + b ∧ Even a ∧ Even b"],
    ["∀ {n : ℕ}, Odd n → ∃ x y z, x < y ∧ y < z ∧ n = x + y ∧ n = y + z ∧ x ≠ z ∧ x ≠ y"]],
   "correct": false,
   "comments": "Extra unnecessary goals. One statement in all-elabs is correct but only because Nat is abelian, it has one extra (equivalent) unnecessary goal.",
   "all-elabs":
   [" ∀ {n : ℕ}, Odd n → ∃ x y, n = x + y ∧ x ≠ y ∧ x ≠ y ∧ y ≠ 0",
    " ∀ {n : ℕ}, Odd n → ∃ a b, 0 < a ∧ 0 < b ∧ a ≠ b ∧ n = a + b ∧ n = b + a",
    " ∀ {n : ℕ}, Odd n → ∃ x y, Nat.Prime x → Nat.Prime y → x ≠ y → n = x * y ∧ n ≠ x * x ∧ n ≠ y * y",
    " ∀ {n : ℕ}, Odd n → ∃ a b : ℕ, n = a + b ∧ a ≠ b ∧ Odd a ∧ Odd b",
    " ∀ (m : ℕ), Odd m → ∃ a b, Odd a → Odd b → m = a + b ∧ m ≠ a → m ≠ b",
    " ∀ {m : ℕ}, Odd m → ∃ a b, a ≠ b ∧ m = a + b ∧ Even a ∧ Even b",
    " ∀ {n : ℕ}, Odd n → ∃ x y z : ℕ, x < y ∧ y < z ∧ n = x + y ∧ n = y + z ∧ x ≠ z ∧ x ≠ y",
    " ∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b ∧ Odd a ∧ Odd b ∧ (∀ c, Odd c → c ≠ a ∧ c ≠ b → Odd (a + b + c))"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ↔ x = 1",
   "some-correct": false,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ↔ x = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ↔ x = 1",
     "∀ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x ↔ x = 1"],
    ["∀ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1"]],
   "correct": false,
   "comments": "Does not understand trivial group. Statement is a bit ambiguous as well.",
   "all-elabs":
   [" ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ↔ x = 1",
    " ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x ↔ x = 1 ",
    " ∀ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x ↔ x = 1",
    " ∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1",
    " ∀ {G : Type u_1} [inst : Group G], ∀ x : G, IsOfFinOrder x "]},
  {"theorem": "∀ (n : ℕ), Even n → Even (n * n)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ (n : ℕ), Even n → Even (n * n)", "∀ (n : ℕ), Even n → Even (n * n)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ (n : ℕ), Even n → Even (n ^ 2) ",
    " ∀ (n : ℕ), Even n → Even (n ^ 2) ",
    " ∀ (n : ℕ), Even n → Even (n ^ 2)",
    " ∀ (n : ℕ), Even n → Even (n * n) ",
    " ∀ (a : ℕ), Even a → Even (a ^ 2)",
    " ∀ n : ℕ, Even n → Even (n ^ 2) ",
    " ∀ n : ℕ, Even n → Even (n ^ 2) ",
    " ∀ n : ℕ, Even n → Even (n * n)"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R",
   "some-correct": true,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R",
     "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R",
     "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R"],
    ["(R : Type u) → [inst : CommRing R] → [inst_1 : IsDomain R] → [inst_2 : CommGroupWithZero R] → Field R",
     "(R : Type u) → [inst : CommRing R] → [inst_1 : IsDomain R] → [inst_2 : CommGroupWithZero R] → Field R"],
    ["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DivInvMonoid R], IsField R"],
    ["∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], IsField R"],
    ["∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R"]],
   "correct": false,
   "comments": "",
   "all-elabs":
   [" ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], Field R ",
    " ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], Field R ",
    " ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R ",
    " ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R ",
    " ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommGroupWithZero R], IsField R ",
    " ∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], IsField R ",
    " ∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R ",
    " ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DivInvMonoid R], IsField R "]},
  {"theorem": "∀ {α : Type u} [inst : Group α], id 1 = 1",
   "some-correct": true,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups": [["∀ {α : Type u} [inst : Group α], id 1 = 1"]],
   "correct": false,
   "comments": "The statement is a bit ambiguous, Lean infers 1 to have type Nat.",
   "all-elabs":
   [" ∀ {α : Type u} [inst : Monoid α], id 1 = 1",
    " ∀ {α : Type u} [inst : Group α], id (1 : α) = 1 ",
    " ∀ {α : Type u} [inst : MulOneClass α], 1 = id 1 "]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {X : Type u} (x : X), Function.IsFixedPt id x",
     "∀ {X : Type u} (x : X), Function.IsFixedPt id x",
     "∀ {X : Type u} (x : X), Function.IsFixedPt id x"],
    ["∀ {α : Type u}, Function.IsFixedPt id α"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {X : Type u} (x : X), Function.IsFixedPt id x ",
    " ∀ {X : Type u} (x : X), Function.IsFixedPt id x ",
    " ∀ {X : Type u} (x : X), Function.IsFixedPt id x ",
    " ∀ {α : Type u}, Function.IsFixedPt id α "]},
  {"theorem": "∀ {α : Type u_1} [inst : Group α], Nonempty α",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α"],
    ["∀ {α : Type u} [inst : Group α], Nonempty α",
     "∀ {α : Type u} [inst : Group α], Nonempty α",
     "∀ {α : Type u} [inst : Group α], Nonempty α",
     "∀ {α : Type u} [inst : Group α], Nonempty α"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u} [inst : Group α], Nonempty α",
    " ∀ {α : Type u} [inst : Group α], Nonempty α",
    " ∀ {α : Type u_1} [inst : Group α], Nonempty α"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)",
   "some-correct": false,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)",
     "∀ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)"],
    ["∀ (α : Type u) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace α] (x : α),\n  IsConnected (connectedComponent x) ∧\n    ∀ (y : α),\n      ∃ z ∈ connectedComponent x,\n        z ∈ connectedComponent y ∧ y ∈ connectedComponent z ∧ x ∈ connectedComponent z ∧ y ∈ connectedComponent z"],
    ["∀ {X : Type u_4} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)"],
    ["∀ {X : Type u_3} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)"]],
   "correct": false,
   "comments": "The statement is not incorrect but it is not the correct interpretation.",
   "all-elabs":
   [" ∀ {X : Type u_4} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " ∀ {X : Type u_3} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x) ",
    " ∀ (α : Type u) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace α],\n  (x : α) → IsConnected (connectedComponent x) ∧ ∀ (y : α), ∃ (z : α), z ∈ connectedComponent x ∧ z ∈ connectedComponent y ∧ y ∈ connectedComponent z ∧ x ∈ connectedComponent z ∧ y ∈ connectedComponent z"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥",
   "some-correct": false,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥"]],
   "correct": false,
   "comments": "Type of M is not specified for statements in all-elabs",
   "all-elabs":
   [" ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ ",
    " ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], ∃ M, Ideal.IsMaximal M",
    " ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R],\n  ∃ M, Ideal.IsMaximal M ∧ M ≠ ⊥"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5 ",
    " PythagoreanTriple 3 4 5 "]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι K V → Subsingleton V",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι K V → Subsingleton V"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   [" ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι K V → Subsingleton V "]}],
 "elaborated": 36}