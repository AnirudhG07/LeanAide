{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α),\n  IsClosed s → s ≠ Set.univ → IsCompact s → IsCompact s","text":"If every proper closed subset of a topological space is compact, then the space itself is compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α),\n  IsClosed s → s ≠ Set.univ → IsCompact s → IsCompact s"],["∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ (s : Set X), IsClosed s → s ≠ Set.univ → IsCompact s) → CompactSpace X"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_3} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is included in a measurable set, then so is its closure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} [inst : MeasurableSpace G] [inst_1 : TopologicalSpace G] [inst_2 : BorelSpace G] [inst_3 : Group G]\\n  [inst_4 : TopologicalGroup G] {k s : Set G}, IsCompact k → MeasurableSet s → k ⊆ s → closure k ⊆ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\"},\n {\"role\": \"user\", \"content\": \"The product of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X × Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : WeaklyLocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s → IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every proper closed subset of a topological space is compact, then the space itself is compact.\"}]","all_elaborations":[" ∀ {X : Type u_1} [inst : TopologicalSpace X] (h : ∀ s : Set X, IsClosed s → s ≠ Set.univ → IsCompact s), CompactSpace X"," ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsClosed s → s ≠ Set.univ → IsCompact s → IsCompact ↑s "]}
{"theorem":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = (2 * ↑p - 1) / 4","text":"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.","result":true,"gps":[["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = (2 * ↑p - 1) / 4"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Note that most of the lemmas about powers of two refer to it as `sq`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (f : ℕ → ℕ), (∀ k < n, Squarefree (f k)) → Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.\"}]","all_elaborations":[" ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b : ℤ, a ^ 2 + b ^ 2 = (2 * p - 1) / 4"]}
{"theorem":"∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n    (∃ u v t w, b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2) → ∃ u v t w, a * b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"gps":[["∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n    (∃ u v t w, b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2) → ∃ u v t w, a * b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2","∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n    (∃ u v p q, b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2) → ∃ p p_1 q q_1, a * b = p ^ 2 + p_1 ^ 2 + q ^ 2 + q_1 ^ 2"],["∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  ∃ x y z u v, x ^ 2 + y ^ 2 = a ∧ z ^ 2 + u ^ 2 = b → ∃ r s t n, a * b = r ^ 2 + s ^ 2 + t ^ 2 + n ^ 2"],["∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  ∃ x y z w u v,\n    a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 →\n      ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],["∀ (R : Type u_1) [inst : CommRing R] (a b : R),\n  IsSquare (a ^ 2 + b ^ 2) → IsSquare (a ^ 2 - b ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The product of the factors is the original number \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ+), PrimeMultiset.prod (PNat.factorMultiset n) = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two positive elements is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), 0 < a → 0 < b → 0 < a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : ℕ → R},\\n  f 1 = 1 →\\n    (∀ {m n : ℕ}, Nat.Coprime m n → f (m * n) = f m * f n) →\\n      (∀ {p : ℕ}, Nat.Prime p → Summable fun n => ‖f (p ^ n)‖) →\\n        ∀ (N : ℕ),\\n          (Summable fun m => ‖f ↑m‖) ∧\\n            HasSum (fun m => f ↑m) (Finset.prod (Nat.primesBelow N) fun p => ∑' (n : ℕ), f (p ^ n))\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_5} [self : SeminormedCommRing α] (x y : α), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The scalar quadruple product identity, related to the Binet-Cauchy identity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (u v w x : Fin 3 → R),\\n  Matrix.dotProduct ((crossProduct u) v) ((crossProduct w) x) =\\n    Matrix.dotProduct u w * Matrix.dotProduct v x - Matrix.dotProduct u x * Matrix.dotProduct v w\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (f : ℕ → ℕ), (∀ k < n, Squarefree (f k)) → Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Representation of a difference of two squares in a commutative ring as a product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type x} [inst : CommRing R] (a b : R), a * a - b * b = (a + b) * (a - b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Expressing the product of two polynomials as a double sum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] {p q : Polynomial R},\\n  p * q =\\n    Finset.sum (Polynomial.support p) fun i =>\\n      Polynomial.sum q fun j a => (Polynomial.monomial (i + j)) (Polynomial.coeff p i * a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two Chebyshev polynomials is the sum of two other Chebyshev polynomials. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (m k : ℕ),\\n  2 * Polynomial.Chebyshev.T R m * Polynomial.Chebyshev.T R (m + k) =\\n    Polynomial.Chebyshev.T R (2 * m + k) + Polynomial.Chebyshev.T R k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]","all_elaborations":[" ∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n    (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n      (∃ u v t w, b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2) →\n        ∃ u v t w, a * b = u ^ 2 + v ^ 2 + t ^ 2 + w ^ 2 "," ∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n   ∃ x y z w u v, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 →\n      ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 "," ∀ (R : Type u_1) [inst : CommRing R] (a b : R),\n  IsSquare (a ^ 2 + b ^ 2) → IsSquare (a ^ 2 - b ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 "," ∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n    (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n      (∃ u v p q, b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2) →\n        ∃ p p_1 q q_1, a * b = p ^ 2 + p_1 ^ 2 + q ^ 2 + q_1 ^ 2 "," ∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n     ∃ x y z u v : R, x ^ 2 + y ^ 2 = a ∧ z ^ 2 + u ^ 2 = b → ∃ r s t n, a * b = r ^ 2 + s ^ 2 + t ^ 2 + n ^ 2 "]}
{"theorem":"∀ {α : Type u_2} [inst : NonUnitalNonAssocSemiring α] (a x y : α), a * a * (x * y) = x * y ∧ a * a * (y * x) = x * y","text":"A ring with all elements idempotent is commutative.","result":true,"gps":[["∀ {α : Type u_2} [inst : NonUnitalNonAssocSemiring α] (a x y : α), a * a * (x * y) = x * y ∧ a * a * (y * x) = x * y"],["∀ {α : Type u_3} [inst : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → Commute a b"],["∀ {α : Type u_5} [inst : CommRing α] (a : α), a * a = a → Commute a a"],["∀ {α : Type u_2} [inst : CommRing α] (x y : α),\n  IsIdempotentElem x →\n    IsIdempotentElem y → Commute x y ∧ IsIdempotentElem (x * y) ∧ IsIdempotentElem (y * x) ∧ x + y = 1 ∧ y + x = 1"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_2) [inst : CategoryTheory.Category.{u_3, u_2} D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\": \"Composition of non-unital ring homomorphisms is associative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [inst : NonUnitalNonAssocSemiring α]\\n  [inst_1 : NonUnitalNonAssocSemiring β] [inst_2 : NonUnitalNonAssocSemiring γ] {δ : Type u_5}\\n  {x : NonUnitalNonAssocSemiring δ} (f : α →ₙ+* β) (g : β →ₙ+* γ) (h : γ →ₙ+* δ),\\n  NonUnitalRingHom.comp (NonUnitalRingHom.comp h g) f = NonUnitalRingHom.comp h (NonUnitalRingHom.comp g f)\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The additive inverse of one multiplied by an element of a ring is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), -1 * a = -a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I → (IsIdempotentElem I ↔ ∃ e, IsIdempotentElem e ∧ I = Submodule.span R {e})\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is an isometry. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_5} {R₂ : Type u_6} [inst : Semiring R₁] [inst_1 : Semiring R₂] [inst_2 : Norm R₁] [inst_3 : Norm R₂]\\n  {σ : R₁ →+* R₂} [self : RingHomIsometric σ] {x : R₁}, ‖σ x‖ = ‖x‖\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : ι → Type u_2} [inst : AddCommMonoid ι] [inst_1 : (i : ι) → AddCommMonoid (A i)]\\n  [self : DirectSum.GCommSemiring A] (a b : GradedMonoid A), a * b = b * a\"},\n {\"role\": \"user\", \"content\": \"Multiplication is commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_5} [self : SeminormedCommRing α] (x y : α), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"By definition, a ring isomorphism preserves the additive structure. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_7} {R : outParam (Type u_8)} {S : outParam (Type u_9)} [inst : Mul R] [inst_1 : Add R] [inst_2 : Mul S]\\n  [inst_3 : Add S] [self : RingEquivClass F R S] (f : F) (a b : R), f (a + b) = f a + f b\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication is commutative in a commutative semigroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : StrictOrderedCommRing α] (a b : α), a * b = b * a\"},\n {\"role\": \"user\", \"content\": \"Equivalence closure is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (r : α → α → Prop), EqvGen.Setoid (Setoid.Rel (EqvGen.Setoid r)) = EqvGen.Setoid r\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends zero to zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_4} {S : Type u_5} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ≃+* S), f 0 = 0\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism sends one to one. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_4} {S : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R ≃+* S), f 1 = 1\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_2} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves addition. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), e (x + y) = e x + e y\"},\n {\"role\": \"user\", \"content\": \"A ring isomorphism preserves multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_4} {S : Type u_5} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), e (x * y) = e x * e y\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_4} [self : BooleanRing α] (a : α), a * a = a\"},\n {\"role\": \"user\",\n  \"content\": \"A ring with all elements idempotent is commutative.\"}]","all_elaborations":[" ∀ {α : Type u_3} [inst : CommRing α] (a b : α), IsIdempotentElem a → IsIdempotentElem b → Commute a b"," ∀ {α : Type u_5} [inst : CommRing α] (a : α), a * a = a → Commute a a"," ∀ {α : Type u_2} [inst : CommRing α] (x y : α), IsIdempotentElem x → IsIdempotentElem y → Commute x y ∧ IsIdempotentElem (x * y) ∧ IsIdempotentElem (y * x) ∧ x + y = 1 ∧ y + x = 1"," ∀ {α : Type u_2} [inst : NonUnitalNonAssocSemiring α] (a : α), ∀ x y : α, a * a * (x * y) = x * y ∧ a * a * (y * x) = x * y"]}
{"theorem":"∀ (n : ℕ), n ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≠ n ∧ p = n + 2}","text":"There are infinitely many pairs of primes that differ exactly by `2`.","result":true,"gps":[["∀ (n : ℕ), n ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≠ n ∧ p = n + 2}"],["∀ {n : ℕ}, n ≠ 0 → ∃ p q, Nat.Prime p → Nat.Prime q → p % 2 = 0 → q % 2 = 1 → p + 2 = q"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\", \"content\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ}, Nat.Prime p → (Nat.factorization p) p = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, all elements commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 → ∀ (x y : G), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\": \"Two (finite) ℤ-bases have the same discriminant. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (A : Type u) {ι : Type w} [inst : DecidableEq ι] [inst_1 : CommRing A] [inst_2 : Fintype ι] (b b' : Basis ι ℤ A),\\n  Algebra.discr ℤ ⇑b = Algebra.discr ℤ ⇑b'\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, every element is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 → ∀ (x : G), x⁻¹ = x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\", \"content\": \"An inequality involving `2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : LinearOrderedField α] {a : α}, 2 ≤ a → (1 - 1 / a)⁻¹ ≤ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There are infinitely many pairs of primes that differ exactly by `2`.\"}]","all_elaborations":[" ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p + 2 = q"," ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p + 2 = q ∧ p ≠ q"," ∀ {n : ℕ}, n ≠ 0 → ∃ p q : ℕ, Nat.Prime p → Nat.Prime q → p % 2 = 0 → q % 2 = 1 → p + 2 = q"," ∀ (n : ℕ), n ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≠ n ∧ p = n + 2} "]}
{"theorem":"∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D","text":"Every finite division ring is a field.","result":true,"gps":[["∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D","∀ (R : Type u_1) [inst : Finite R] [inst_1 : DivisionRing R], IsField R"],["∀ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], IsField D ∧ Finite D ∧ NoZeroDivisors D"],["∀ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x * y ∈ S\"},\n {\"role\": \"user\",\n  \"content\": \"Any infinite type can be endowed a field structure. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Infinite α], Nonempty (Field α)\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"An algebraically closed field is also separably closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u) [inst : Field k] [inst_1 : IsAlgClosed k], IsSepClosed k\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A field extension is algebraic if it is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) (A : Type u_5) [inst : Field K] [inst_1 : Ring A] [inst_2 : Algebra K A]\\n  [inst_3 : FiniteDimensional K A], Algebra.IsAlgebraic K A\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ⇑f → IsCyclic G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ↔ Module.Finite K V\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_2) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f → Polynomial.Separable f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite ↥S], IsCyclic ↥S\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A cyclotomic finite extension of a number field is a number field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\", \"content\": \"A finite field has prime power cardinality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite domain is a field. See also `littleWedderburn` and `Fintype.divisionRingOfIsDomain`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_1) [inst : Finite D] [inst : Ring D] [inst_1 : IsDomain D], IsField D\"},\n {\"role\": \"user\", \"content\": \"Every finite division ring is a field.\"}]","all_elaborations":[" ∀ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], IsField D "," ∀ (R : Type u_1) [inst : Finite R] [inst : DivisionRing R], IsField R "," ∀ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D "," ∀ {D : Type u_1} [inst : Finite D] [inst : DivisionRing D], IsField D ∧ Finite (D) ∧ NoZeroDivisors D"]}
{"theorem":"∀ {X : Type u} {Y : Type v}, ((∃ f, Function.Injective f) ∧ ∃ f, Function.Injective f) → Nonempty (X ≃ Y)","text":"If each of two types can be mapped injectively into the other, then there is a bijection between them.","result":true,"gps":[["∀ {X : Type u} {Y : Type v}, ((∃ f, Function.Injective f) ∧ ∃ f, Function.Injective f) → Nonempty (X ≃ Y)"],["∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"],["∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∃ h, ⇑h = f ∧ ⇑h.symm = g"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The dimensions of the domain and range of an injective linear map are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : Ring K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {V₂ : Type v'}\\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] {f : V →ₗ[K] V₂},\\n  Function.Injective ⇑f → FiniteDimensional.finrank K ↥(LinearMap.range f) = FiniteDimensional.finrank K V\"},\n {\"role\": \"user\", \"content\": \"An epimorphism is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} {R₂ : Type u_3} {M₂ : Type u_4} [inst : Ring R] [inst_1 : Ring R₂]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommGroup M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\\n  [inst_6 : RingHomSurjective τ₁₂] {f : M →ₛₗ[τ₁₂] M₂},\\n  (∀ (u v : M₂ →ₗ[R₂] M₂ ⧸ LinearMap.range f), LinearMap.comp u f = LinearMap.comp v f → u = v) → LinearMap.range f = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"The induced map from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S),\\n  Function.Injective ⇑(RingHom.kerLift f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the equalizer of two morphisms is an epimorphism, then the two morphisms are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f g : X ⟶ Y}\\n  [inst_1 : CategoryTheory.Limits.HasEqualizer f g]\\n  [inst_2 : CategoryTheory.Epi (CategoryTheory.Limits.equalizer.ι f g)], f = g\"},\n {\"role\": \"user\",\n  \"content\": \"The two coercions to functions are jointly injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} [self : EquivLike E α β] (e g : E),\\n  EquivLike.coe e = EquivLike.coe g → EquivLike.inv e = EquivLike.inv g → e = g\"},\n {\"role\": \"user\",\n  \"content\": \"Composing with a surjective linear map is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_7} {M₂ : Type u_10} [inst_5 : AddCommMonoid M₂]\\n  [inst_6 : Module R M₂] (f : M₂ →ₗ[R] M),\\n  Function.Surjective ⇑f → Function.Injective fun g => AlternatingMap.compLinearMap g f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A scheme where the children of each set are pairwise disjoint induces an injective map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β : Type u_1} {α : Type u_2} {A : List β → Set α},\\n  CantorScheme.Disjoint A → Function.Injective (CantorScheme.inducedMap A).snd\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ⇑f ↔ Function.Surjective ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map sending a congruence relation to its underlying binary relation is injective. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u_1} [inst : Mul M] {c d : Con M}, ⇑c = ⇑d → c = d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In any concrete category, injective morphisms are monomorphisms. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X Y : C}\\n  (f : X ⟶ Y), Function.Injective ⇑f → CategoryTheory.Mono f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The map sending a congruence relation to its underlying equivalence relation is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c d : Con M}, c.toSetoid = d.toSetoid → c = d\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ⇑f → Function.Surjective ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two partial homeomorphisms are equivalent, so are their inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  {e e' : PartialHomeomorph α β}, e ≈ e' → PartialHomeomorph.symm e ≈ PartialHomeomorph.symm e'\"},\n {\"role\": \"user\",\n  \"content\": \"An equivalence of categories transfers enough injectives. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\\n  (e : CategoryTheory.Functor C D) [inst_2 : CategoryTheory.IsEquivalence e]\\n  [inst_3 : CategoryTheory.EnoughInjectives D], CategoryTheory.EnoughInjectives C\"},\n {\"role\": \"user\", \"content\": \"All maps in the diagram are injective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {G : ι → Type u_2} {H : Type u_3} [inst : (i : ι) → Group (G i)] [inst_1 : Group H]\\n  {φ : (i : ι) → H →* G i}, Monoid.PushoutI.NormalWord.Transversal φ → ∀ (i : ι), Function.Injective ⇑(φ i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For functions on finite sets, they are bijections iff they map universes into universes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Fintype α] [inst_1 : Fintype β] (f : α → β),\\n  Function.Bijective f ↔ Multiset.map f Finset.univ.val = Finset.univ.val\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism in `Type u` is an isomorphism if and only if it is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X Y : Type u} (f : X ⟶ Y), CategoryTheory.IsIso f ↔ Function.Bijective f\"},\n {\"role\": \"user\", \"content\": \"A monomorphism is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\\n  {f : M →ₛₗ[τ₁₂] M₂},\\n  (∀ (u v : ↥(LinearMap.ker f) →ₗ[R] M), LinearMap.comp f u = LinearMap.comp f v → u = v) → LinearMap.ker f = ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a bounded linear map is a bijection, then its inverse is also a bounded linear map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (e : E ≃ₗ[𝕜] F),\\n  Continuous ⇑e → Continuous ⇑(LinearEquiv.symm e)\"},\n {\"role\": \"user\",\n  \"content\": \"If a linear map is surjective, then its dual is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {M₁ : Type v} {M₂ : Type v'} [inst_1 : AddCommMonoid M₁] [inst_2 : Module R M₁]\\n  [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M₂] {f : M₁ →ₗ[R] M₂},\\n  Function.Surjective ⇑f → Function.Injective ⇑(LinearMap.dualMap f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\"}]","all_elaborations":[" ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) "," ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∃ h : α ≃ β, ⇑h = f ∧ ⇑h.symm = g "," ∀ {X : Type u} {Y : Type v},\n  (∃ f : X → Y, Function.Injective f) ∧ (∃ f : Y → X, Function.Injective f) → Nonempty (X ≃ Y) "]}
{"theorem":"∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α] (s : Set α),\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) →\n    (∀ a ∈ s, ∀ b ∈ s, r a b → r b a) →\n      Nonempty (∀ a ∈ s, ∃ ub, ∀ a ∈ s, r a ub) ∧ Set.Nonempty s → Nonempty (∃ m ∈ s, ∀ a ∈ s, r a m → r m a)","text":"Every non-empty poset in which every chain has an upper bound contains a maximal element.","result":true,"gps":[["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α] (s : Set α),\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) →\n    (∀ a ∈ s, ∀ b ∈ s, r a b → r b a) →\n      Nonempty (∀ a ∈ s, ∃ ub, ∀ a ∈ s, r a ub) ∧ Set.Nonempty s → Nonempty (∃ m ∈ s, ∀ a ∈ s, r a m → r m a)"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The intrinsic interior of a nonempty convex set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : NormedSpace ℝ V] [inst_2 : FiniteDimensional ℝ V] {s : Set V},\\n  Convex ℝ s → Set.Nonempty s → Set.Nonempty (intrinsicInterior ℝ s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a (nontrivial) complex Banach algebra, every element has nonempty spectrum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_2} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : Nontrivial A]\\n  (a : A), Set.Nonempty (spectrum ℂ a)\"},\n {\"role\": \"user\", \"content\": \"A nonempty convex set is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsConnected s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of two sets is bounded above if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≤ x_1] {s t : Set α},\\n  BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_9} [self : CompleteSemilatticeInf α] (s : Set α), ∀ a ∈ s, sInf s ≤ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\"},\n {\"role\": \"user\",\n  \"content\": \"Every set open in the upper topology is a upper set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : Topology.IsUpper α] {s : Set α},\\n  IsOpen s → IsUpperSet s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of bounded above sets is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≤ x_1] {s t : Set α},\\n  BddAbove s → BddAbove t → BddAbove (s ∪ t)\"},\n {\"role\": \"user\", \"content\": \"A chain of lifts has an upper bound. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} {E : Type u_2} {K : Type u_3} [inst : Field F] [inst_1 : Field E] [inst_2 : Field K]\\n  [inst_3 : Algebra F E] [inst_4 : Algebra F K] (c : Set (IntermediateField.Lifts F E K)),\\n  IsChain (fun x x_1 => x ≤ x_1) c → ∃ ub, ∀ a ∈ c, a ≤ ub\"},\n {\"role\": \"user\", \"content\": \"A finite set is bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≤ x_1] [inst_2 : Nonempty α] {s : Set α},\\n  Set.Finite s → BddAbove s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded above is still bounded above.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≤ x_1] [inst_2 : Nonempty α]\\n  {I : Set β} {S : β → Set α}, Set.Finite I → (BddAbove (⋃ i ∈ I, S i) ↔ ∀ i ∈ I, BddAbove (S i))\"},\n {\"role\": \"user\",\n  \"content\": \"When there is a global maximum, every set is bounded above. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderTop α] (s : Set α), BddAbove s\"},\n {\"role\": \"user\", \"content\": \"Any upper bound is more than the set supremum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α), (∀ b ∈ s, b ≤ a) → sSup s ≤ a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every chain is contained in a maximal chain. This generalizes Hausdorff's maximality principle.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} {c : Set α}, IsChain r c → ∃ M, IsMaxChain r M ∧ c ⊆ M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Zorn's lemma**\\n\\nIf every chain has an upper bound, then there exists a maximal element. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {r : α → α → Prop},\\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) →\\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every non-empty poset in which every chain has an upper bound contains a maximal element.\"}]","all_elaborations":[" ∀ {α : Type u_1} [Preorder α] [Nonempty α] (c : Set α),\n  (∀ (a : α), IsChain (· ≤ ·) c → ∃ ub, ∀ a ∈ c, a ≤ ub) → ∃ m ∈ c, ∀ a ∈ c, a ≤ m ∧ m ≤ a → m = a ∧ m ∈ c"," ∀ {α : Type u_1} [inst : PartialOrder α] (h : ∀ c, IsChain (· ≤ ·) c → ∃ ub, ∀ a ∈ c, a ≤ ub) (c : Set α),\n  c ≠ ∅ → ∃ m, ∀ a ∈ c, a ≤ m ∧ ∀ b ∈ c, m ≤ b → m = b"," ∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α] (s : Set α)\n  (h : ∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) (hs : ∀ a ∈ s, ∀ b ∈ s, r a b → r b a),\n  Nonempty (∀ a ∈ s, ∃ ub, ∀ a ∈ s, r a ub) ∧ s.Nonempty → Nonempty (∃ m ∈ s, ∀ a ∈ s, r a m → r m a) "]}
{"theorem":"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {g : β → α}\n  [inst_2 : TopologicalSpace β], UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {g : β → α}\n  [inst_2 : TopologicalSpace β], UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)"],["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous ⇑(UniformEquiv.symm self) → UniformContinuous self.toFun"],["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ∧ UniformContinuous self.invFun →\n    UniformContinuous self.toFun ∧ UniformContinuous self.invFun"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace β]\\n  [inst_3 : ClosedIciTopology α] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X → Y}, SeqContinuous f → Continuous f\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α), ∀ u ∈ uniformity β, ∃ t ∈ nhds x, ∃ F, ContinuousAt F x ∧ ∀ y ∈ t, (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ u ∈ uniformity β, ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_6} {β : Type u_7} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A uniformly continuous function of a uniformly continuous function is uniformly continuous.\"}]","all_elaborations":[" ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.symm → UniformContinuous self.toFun "," ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ∧ UniformContinuous self.invFun → UniformContinuous self.toFun ∧ UniformContinuous self.invFun "," ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {g : β → α}\n  [inst_2 : TopologicalSpace β],\n  UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)"]}
{"theorem":"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {g : β → α}\n  [inst_2 : TopologicalSpace β], UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {g : β → α}\n  [inst_2 : TopologicalSpace β], UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)"],["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun → UniformContinuous self.invFun"],["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous ⇑(UniformEquiv.symm self) → UniformContinuous self.toFun"],["∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ∧ UniformContinuous self.invFun →\n    UniformContinuous self.toFun ∧ UniformContinuous self.invFun"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A constant sequence of functions is uniformly integrable in the probability sense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UniformIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous function is bounded above on a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace β]\\n  [inst_3 : ClosedIciTopology α] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\"},\n {\"role\": \"user\",\n  \"content\": \"Each function of an equicontinuous family is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : Type u_3} {α : Type u_6} [inst : TopologicalSpace X] [inst_1 : UniformSpace α] {F : ι → X → α},\\n  Equicontinuous F → ∀ (i : ι), Continuous (F i)\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially continuous function defined on a sequential space is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : SequentialSpace X]\\n  {f : X → Y}, SeqContinuous f → Continuous f\"},\n {\"role\": \"user\", \"content\": \"Uniform continuity of the function \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\"},\n {\"role\": \"user\", \"content\": \"A constant function is uniformly integrable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α), ∀ u ∈ uniformity β, ∃ t ∈ nhds x, ∃ F, ContinuousAt F x ∧ ∀ y ∈ t, (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\": \"A locally uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ u ∈ uniformity β, ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_6} {β : Type u_7} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A uniformly continuous function of a uniformly continuous function is uniformly continuous.\"}]","all_elaborations":[" ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun → UniformContinuous self.invFun "," ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.symm → UniformContinuous self.toFun "," ∀ {α : Type u_4} {β : Type u_5} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ∧ UniformContinuous self.invFun → UniformContinuous self.toFun ∧ UniformContinuous self.invFun "," ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} {g : β → α}\n  [inst_2 : TopologicalSpace β],\n  UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)"]}
{"theorem":"∀ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ ∀ x ∈ t, f x = 1","text":"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.","result":true,"gps":[["∀ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ ∀ x ∈ t, f x = 1","∀ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ ∀ x ∈ t, f x = 1"],["∀ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (s t : Set X),\n      IsClosed s →\n        IsClosed t →\n          Disjoint s t → ∃ f a a', Disjoint a a' ∧ (∀ x ∈ s, f x ∈ a) ∧ (∀ x ∈ t, f x ∈ a') ∧ IsOpen a ∧ IsOpen a'"],["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s → IsClosed t → Disjoint s t → Nonempty { f // Continuous f ∧ s ⊆ f ⁻¹' Set.Iic 0 ∧ t ⊆ f ⁻¹' Set.Ici 0 }"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only open sets in the indiscrete topology are the empty set and the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (U : Set α), IsOpen U ↔ U = ∅ ∨ U = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_3} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\\n  TopologicalSpace.SeparableSpace ((i : ι) → X i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ i ∈ a, IsOpen (s i)) → (∀ i ∈ a, Set.Nonempty (s i)) → Set.Countable a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ⇑f\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two separable spaces is a separable space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\\n  TopologicalSpace.SeparableSpace (α × β)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T2Space X] (x y : X),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A regular topological space with second countable topology is a normal space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : RegularSpace X] [inst_2 : SecondCountableTopology X],\\n  NormalSpace X\"},\n {\"role\": \"user\",\n  \"content\": \"A space with discrete topology is a locally connected space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_3) [inst : TopologicalSpace α] [inst_1 : DiscreteTopology α], LocallyConnectedSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : DiscreteTopology α], TopologicalSpace.SeparableSpace α ↔ Countable α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.\"}]","all_elaborations":[" ∀ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X],\n  (s t : Set X) → IsClosed s → IsClosed t → Disjoint s t → ∃ f : X → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1)"," ∀ {X : Type u} [inst : TopologicalSpace X] [self : NormalSpace X] (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ f : X → ℝ, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1)"," ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {s t : Set X},\n  IsClosed s → IsClosed t → Disjoint s t → Nonempty { f : X → ℝ // Continuous f ∧ s ⊆ f ⁻¹' Set.Iic 0 ∧ t ⊆ f ⁻¹' Set.Ici 0 } "," ∀ {X : Type u} [inst : TopologicalSpace X], NormalSpace X ↔\n  ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : C(X, ℝ)) (a a' : Set ℝ),\n    Disjoint a a' ∧ (∀ (x : X), x ∈ s → f x ∈ a) ∧ (∀ (x : X), x ∈ t → f x ∈ a') ∧ IsOpen a ∧ IsOpen a'"]}
{"theorem":"∀ {α : Type u_1} [inst : Nonempty α] (f : α → α) {x : α},\n  Function.IsPeriodicPt f 3 x → ∀ (m : ℕ), 0 < m → ∃ y, Function.IsPeriodicPt f m y","text":"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.","result":true,"gps":[["∀ {α : Type u_1} [inst : Nonempty α] (f : α → α) {x : α},\n  Function.IsPeriodicPt f 3 x → ∀ (m : ℕ), 0 < m → ∃ y, Function.IsPeriodicPt f m y"],["∀ {α : Type u_1} [inst : Nontrivial α] (f : ℝ → ℝ) {x : ℝ},\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), ∃ y, Function.IsPeriodicPt f n y"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any three points in an orthocentric system are affinely independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.OrthocentricSystem s →\\n    ∀ {p : Fin 3 → P}, Set.range p ⊆ s → Function.Injective p → AffineIndependent ℝ p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ},\\n  Function.IsPeriodicPt f m x → Function.IsPeriodicPt f n y → 0 < m → 0 < n → f x = f y → x = y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Right multiplication by a positive element is strictly monotone. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyLinearOrderedSemifield α] (a b c : α), a < b → 0 < c → a * c < b * c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If three points are not collinear, the angle between them is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P}, ¬Collinear ℝ {p₁, p₂, p₃} → 0 < EuclideanGeometry.angle p₁ p₂ p₃\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a point lies in the affine span of two points, those three points are collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {p₁ p₂ p₃ : P}, p₁ ∈ affineSpan k {p₂, p₃} → Collinear k {p₁, p₂, p₃}\"},\n {\"role\": \"user\", \"content\": \"A continuous, periodic function is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → Bornology.IsBounded (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\": \"If the angle between three points is π, they are collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P}, EuclideanGeometry.angle p₁ p₂ p₃ = Real.pi → Collinear ℝ {p₁, p₂, p₃}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two functions are equal in the relevant interval, their interval integrals are also equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {μ : MeasureTheory.Measure ℝ}\\n  {a b : ℝ}, Set.EqOn f g (Set.uIcc a b) → ∫ (x : ℝ) in a..b, f x ∂μ = ∫ (x : ℝ) in a..b, g x ∂μ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If three points are not collinear, the sine of the angle between them is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P},\\n  ¬Collinear ℝ {p₁, p₂, p₃} → 0 < Real.sin (EuclideanGeometry.angle p₁ p₂ p₃)\"},\n {\"role\": \"user\", \"content\": \"Three points are coplanar. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] (p₁ p₂ p₃ : P), Coplanar k {p₁, p₂, p₃}\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any three points in a cospherical set are affinely independent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : Set P},\\n  EuclideanGeometry.Cospherical s →\\n    ∀ {p₁ p₂ p₃ : P}, p₁ ∈ s → p₂ ∈ s → p₃ ∈ s → p₁ ≠ p₂ → p₁ ≠ p₃ → p₂ ≠ p₃ → AffineIndependent ℝ ![p₁, p₂, p₃]\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If three points lie in the affine span of two points, the first three points are collinear. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {p₁ p₂ p₃ p₄ p₅ : P},\\n  p₁ ∈ affineSpan k {p₄, p₅} → p₂ ∈ affineSpan k {p₄, p₅} → p₃ ∈ affineSpan k {p₄, p₅} → Collinear k {p₁, p₂, p₃}\"},\n {\"role\": \"user\", \"content\": \"For the identity map, all points are periodic. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (n : ℕ) (x : α), Function.IsPeriodicPt id n x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\"}]","all_elaborations":[" ∀ {α : Type u_1} [inst : TopologicalSpace α] (f : ℝ → ℝ) (x : ℝ),\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), ∃ (y : ℝ), Function.IsPeriodicPt f (n * 3) y"," ∀ {α : Type u_1} [inst : Nontrivial α] (f : ℝ → ℝ) {x : ℝ} (_ : Function.IsPeriodicPt f 3 x), ∀ (n : ℕ), ∃ (y : ℝ), Function.IsPeriodicPt f n y"," ∀ {α : Type u_1} [inst : Nonempty α] (f : α → α) {x y : α},\n  Function.IsPeriodicPt f 3 x → Function.IsPeriodicPt f 3 y → ∀ (n : ℕ), Function.IsPeriodicPt f (n + 3) x ∧ Function.IsPeriodicPt f (n + 3) y "," ∀ {α : Type u_1} [inst : Nonempty α] (f : α → α) {x : α},\n  Function.IsPeriodicPt f 3 x → ∀ (m : ℕ), 0 < m → ∃ y, Function.IsPeriodicPt f m y "]}
{"theorem":"(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] → Unique (∀ (X : C), Nonempty (X ≅ ⊤_ C))","text":"A terminal object in a category is unique up to unique isomorphism.","result":true,"gps":[["(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] → Unique (∀ (X : C), Nonempty (X ≅ ⊤_ C))"],["(C : Type u) →\n  [inst : CategoryTheory.Category.{v, u} C] → [inst_1 : CategoryTheory.Limits.HasTerminal C] → Unique (C ≌ C)"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The (unique) isomorphism between the chosen terminal object and any other terminal object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"{C : Type u₁} →\\n  [inst : CategoryTheory.Category.{v₁, u₁} C] →\\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] → {P : C} → CategoryTheory.Limits.IsTerminal P → (⊤_ C ≅ P)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any category with pullbacks and terminal object has binary products. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\\n  [inst_2 : CategoryTheory.Limits.HasPullbacks C], CategoryTheory.Limits.HasBinaryProducts C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A strong mono category is a category in which every monomorphism is strong. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [self : CategoryTheory.StrongMonoCategory C] {X Y : C}\\n  (f : X ⟶ Y) [inst_1 : CategoryTheory.Mono f], CategoryTheory.StrongMono f\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero epimorphism from a simple object is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C] {X Y : C}\\n  [inst_2 : CategoryTheory.Simple X] {f : X ⟶ Y} [inst_3 : CategoryTheory.Epi f], f ≠ 0 → CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\": \"A nonzero monomorphism to a simple object is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] {X Y : C}\\n  [inst_2 : CategoryTheory.Simple Y] {f : X ⟶ Y} [inst_3 : CategoryTheory.Mono f], f ≠ 0 → CategoryTheory.IsIso f\"},\n {\"role\": \"user\", \"content\": \"The category `D` has isomorphic objects equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]\\n  {F : CategoryTheory.Functor D C}, CategoryTheory.IsSkeletonOf C D F → CategoryTheory.Skeletal D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A category in which coimage-image comparisons are all isomorphisms has images. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]\\n  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : ∀ {X Y : C} (f : X ⟶ Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)],\\n  CategoryTheory.Limits.HasImages C\"},\n {\"role\": \"user\",\n  \"content\": \"Any morphism from a terminal object is split mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.IsSplitMono f\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_2) [inst : CategoryTheory.Category.{u_3, u_2} D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\": \"A category with finite biproducts has a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\", \"content\": \"Any morphism from a terminal object is mono. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f : X ⟶ Y), CategoryTheory.Mono f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The subcategory of subterminal objects is an exponential ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Limits.HasFiniteProducts C]\\n  [inst_2 : CategoryTheory.CartesianClosed C], CategoryTheory.ExponentialIdeal (CategoryTheory.subterminalInclusion C)\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A terminal object in a category is unique up to unique isomorphism.\"}]","all_elaborations":[" ∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C],\n  Unique (C ≌ C) "," ∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasTerminal C],\n  Unique (∀ (X : C), Nonempty (X ≅ ⊤_ C)) "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ","text":"The complement of the union of two sets is the intersection of their complements.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ"],["∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s ∪ tᶜ = sᶜ ∩ tᶜ","∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s ∪ tᶜ = sᶜ ∩ tᶜ ∧ t ∪ sᶜ = tᶜ ∩ sᶜ"],["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a compact set is covered by two open sets, then we can cover it by two compact subsets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {K U V : Set X},\\n  IsCompact K → IsOpen U → IsOpen V → K ⊆ U ∪ V → ∃ K₁ K₂, IsCompact K₁ ∧ IsCompact K₂ ∧ K₁ ⊆ U ∧ K₂ ⊆ V ∧ K = K₁ ∪ K₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a directed order, the union of two sets is bounded above if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≤ x_1] {s t : Set α},\\n  BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (S T : Set (Projectivization K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of all sets in a compact exhaustion equals the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_4} [inst : TopologicalSpace X] (self : CompactExhaustion X),\\n  ⋃ n, CompactExhaustion.toFun self n = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a codirected order, the union of two sets is bounded below if and only if both sets are. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] [inst_1 : IsDirected α fun x x_1 => x ≥ x_1] {s t : Set α},\\n  BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_1) (V : Type u_2) {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s a b : Set X},\\n  IsClopen s → s ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (s ∩ a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets intersect, the diameter of the union is bounded by the sum of the diameters. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty (s ∩ t) → Metric.diam (s ∪ t) ≤ Metric.diam s + Metric.diam t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s → IsOpen t → IsCompact (s \\\\ t)\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X ⊕ Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a preperfect set and an open set is preperfect. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C U : Set α}, Preperfect C → IsOpen U → Preperfect (U ∩ C)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} (S T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets belong to a filter, then their intersection belongs to the filter as well. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (self : Filter α) {x y : Set α}, x ∈ self.sets → y ∈ self.sets → x ∩ y ∈ self.sets\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup E] {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμs : ↑↑μ s ≠ ⊤)\\n  (hμt : ↑↑μ t ≠ ⊤),\\n  s ∩ t = ∅ →\\n    ∀ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ∪ t)) (_ : ↑↑μ (s ∪ t) ≠ ⊤) c =\\n        MeasureTheory.indicatorConstLp p hs hμs c + MeasureTheory.indicatorConstLp p ht hμt c\"},\n {\"role\": \"user\", \"content\": \"The union of two bounded sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_3} [inst : SeminormedRing 𝕜] [inst_1 : SMul 𝕜 E] [inst_2 : Zero E]\\n  [inst_3 : TopologicalSpace E] {s₁ s₂ : Set E},\\n  Bornology.IsVonNBounded 𝕜 s₁ → Bornology.IsVonNBounded 𝕜 s₂ → Bornology.IsVonNBounded 𝕜 (s₁ ∪ s₂)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets is the intersection of their complements.\"}]","all_elaborations":[" ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ "," ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ"," ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ"," ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ"," ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ"," ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, sᶜ ∪ tᶜ = (s ∪ t)ᶜ"," ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (s ∪ t)ᶜ = sᶜ ∩ tᶜ "," ∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s ∪ tᶜ = sᶜ ∩ tᶜ"," ∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, s ∪ tᶜ = sᶜ ∩ tᶜ ∧ t ∪ sᶜ = tᶜ ∩ sᶜ"]}
{"theorem":"∀ {m n k : ℕ}, 0 < m → 0 < n → k * k * k ≠ m * m + n * n → ¬(0 < k → 0 < k → k * k = m * m + n * n)","text":"The sum of the cubes of two positive integers is never equal to the cube of a third integer.","result":true,"gps":[["∀ {m n k : ℕ}, 0 < m → 0 < n → k * k * k ≠ m * m + n * n → ¬(0 < k → 0 < k → k * k = m * m + n * n)"],["∀ {n m k : ℕ}, 0 < n → 0 < m → k ≠ n * n + m * m"],["∀ {α : Type u} [inst : LinearOrderedRing α] [inst_1 : DivisionRing α] {x y z : α},\n  0 < x → 0 < y → 0 < z → x * x + y * y ≠ z * z"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `-π / 2`, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(-Real.pi / 2) → p₁ ≠ p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is nonzero, the first two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) ≠ 0 → p₁ ≠ p₂\"},\n {\"role\": \"user\", \"content\": \"A sort of triangle inequality. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : LinearOrder α] [inst_1 : LocallyFiniteOrder α] {a b c : α},\\n  Finset.uIcc a c ⊆ Finset.uIcc a b ∪ Finset.uIcc b c\"},\n {\"role\": \"user\",\n  \"content\": \"The n-th harmonic number is not an integer for n ≥ 2. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 2 ≤ n → ¬Rat.isInt (harmonic n) = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is positive, the last two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₃ ≠ p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is negative, the first two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = -1 → p₁ ≠ p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `-π / 2`, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(-Real.pi / 2) → p₁ ≠ p₃\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `π / 2`, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is nonzero, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ ≠ 0 → p₁ ≠ p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `π`, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₃\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `π`, the first two points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑Real.pi → p₁ ≠ p₂\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is nonzero, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ ≠ 0 → p₁ ≠ p₃\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the angle between three points is `π / 2`, the first and third points are not equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₃\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the sign of the angle between three points is positive, the first two points are not\\nequal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\\n  {p₁ p₂ p₃ : P}, Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) = 1 → p₁ ≠ p₂\"},\n {\"role\": \"user\",\n  \"content\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\"}]","all_elaborations":[" ∀ {n m k : ℕ}, 0 < n → 0 < m → 0 < k → n ^ 3 + m ^ 3 ≠ k ^ 3"," ∀ {x y z : ℕ}, 0 < x → 0 < y → 0 < z → x ^ 3 + y ^ 3 ≠ z ^ 3 "," ∀ {α : Type u} [inst : LinearOrderedCommRing α] {x y z : α}, 0 < x → 0 < y → 0 < z → x ^ 3 + y ^ 3 ≠ z ^ 3 "," ∀ {n m k : ℕ}, 0 < n → 0 < m → k ≠ n * n + m * m"," ∀ {x y z : ℕ}, x ≠ 0 → y ≠ 0 → z ≠ 0 → x ^ 3 + y ^ 3 ≠ z ^ 3"," ∀ {m n k : ℕ}, 0 < m → 0 < n → k * k = m ^ 2 + n ^ 2 → k = m ∧ k = n "," ∀ {n : ℕ}, 0 < n → ∀ m p : ℕ, m ^ 3 + p ^ 3 ≠ n ^ 3 ∧ 0 < m → 0 < p ∧ p ≠ n"," ∀ {α : Type u} [inst : LinearOrderedRing α] [inst_1 : DivisionRing α] {x y z : α}, 0 < x → 0 < y → 0 < z → x * x + y * y ≠ z * z"," ∀ {m n k : ℕ}, 0 < m → 0 < n → k * k * k ≠ m * m + n * n → ¬(0 < k → 0 < k → k * k = m * m + n * n)"]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y","text":"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y"],["∀ {G : Type u_1} [inst : Group G] (x y : G), orderOf x = 2 → orderOf y = 2 → Commute x y","∀ {G : Type u_1} [inst : Group G] (x y : G), orderOf x = 2 → orderOf y = 2 → Commute x y"],["∀ (G : Type u_1) [inst : Group G], (∀ (x : G), IsOfFinOrder x → orderOf x = 2) → ∀ (x y : G), Commute x y"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_2} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute a c → AddCommute a (b + c)\"},\n {\"role\": \"user\",\n  \"content\": \"A normal element of a star monoid commutes with its adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Mul R] [inst_1 : Star R] {x : R} [self : IsStarNormal x], Commute (star x) x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite ↥(commutator G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f)\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G (↥(Subgroup.center G)) G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite additive order are closed under addition.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x y : G},\\n  AddCommute x y → IsOfFinAddOrder x → IsOfFinAddOrder y → IsOfFinAddOrder (x + y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a c → Commute b c → Commute (a * b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Self-adjoint elements commute if and only if their product is self-adjoint. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_3} [inst : Mul R] [inst_1 : StarMul R] {x y : R},\\n  IsSelfAdjoint x → IsSelfAdjoint y → (Commute x y ↔ IsSelfAdjoint (x * y))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_2} [inst : AddSemigroup S] {a b c : S}, AddCommute a c → AddCommute b c → AddCommute (a + b) c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element in a group has order two, then it is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 2 → x⁻¹ = x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commuting elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x y : G}, Commute x y → IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_2} [inst : Mul S] {a b : S}, Commute a b → Commute b a\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type u_2} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If n is odd, then the Dihedral group of order $2n$ has $n(n+3)$ pairs of commuting elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, Odd n → Nat.card { p // Commute p.1 p.2 } = n * (n + 3)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_2} [inst : Mul S] (a : S), Commute a a\"},\n {\"role\": \"user\", \"content\": \"Any element commutes with itself.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {S : Type u_2} [inst : Add S] (a : S), AddCommute a a\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, all elements commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 → ∀ (x y : G), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.\"}]","all_elaborations":[" ∀ {G : Type u_1} [inst : Group G], ∀ (x y : G), orderOf x = 2 → orderOf y = 2 → Commute x y"," ∀ {G : Type u_1} [inst : Group G], ∀ (x y : G), orderOf x = 2 → orderOf y = 2 → Commute x y"," ∀ {G : Type u_1} [inst : Group G] (h : ∀ x : G, orderOf x = 2), ∀ (x y : G), Commute x y "," ∀ {G : Type u_1} [inst : Group G] (h : ∀ x : G, orderOf x = 2), ∀ (x y : G), Commute x y"," ∀ {G : Type u_1} [inst : Group G] (h : ∀ x : G, orderOf x = 2), ∀ x y : G, Commute x y "," ∀ {G : Type u_1} [inst : Group G],\n  (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y "," ∀ {G : Type u_1} [inst : Group G] (H : ∀ x : G, orderOf x = 2), ∀ (x y : G), Commute x y "," ∀ (G : Type u_1) [inst : Group G] (h : ∀ (x : G), IsOfFinOrder x → orderOf x = 2), ∀ (x y : G), Commute x y "]}
{"theorem":"∀ {a b : ℕ}, a + 1 ≤ b → Even (a * b)","text":"The product of two consecutive natural numbers is even.","result":true,"gps":[["∀ {a b : ℕ}, a + 1 ≤ b → Even (a * b)"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x + y)\"},\n {\"role\": \"user\",\n  \"content\": \"The product of non-negative elements is non-negative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : OrderedRing α] (a b : α), 0 ≤ a → 0 ≤ b → 0 ≤ a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two finite adèles is a finite adèle. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K]\\n  {x y : DedekindDomain.ProdAdicCompletions R K},\\n  DedekindDomain.ProdAdicCompletions.IsFiniteAdele x →\\n    DedekindDomain.ProdAdicCompletions.IsFiniteAdele y → DedekindDomain.ProdAdicCompletions.IsFiniteAdele (x * y)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\", \"content\": \"the condition on the two integers \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℤ} (self : CochainComplex.HomComplex.Triplet n), self.p + n = self.q\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {R : Type u_8} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ i ∈ s, f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two positive elements is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), 0 < a → 0 < b → 0 < a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two consecutive natural numbers is even.\"}]","all_elaborations":[" ∀ (n : ℕ), Even (n * (n + 1))"," ∀ (n : ℕ), Even (n * (n + 1))"," ∀ {n : ℕ}, Even (n * (n + 1))"," ∀ n : ℕ, Even (n * (n + 1)) "," ∀ {a b : ℕ}, a + 1 ≤ b → Even (a * b)"," ∀ (n : ℕ), Even (2 * n) → Even (2 * (n + 1))"," ∀ {n : ℕ}, Even n → Even (n + 1) → ∃ m, 2 * m = n ∨ 2 * m + 1 = n"," ∀ {n : ℕ}, Even (2 * n) ↔ n ≤ 2 ∧ Even n ∧ ¬n = 0 ∧ ¬n = 1"," ∀ {n : ℕ}, (∀ (k : ℕ), k ≤ n ↔ k ∈ Finset.range (n + 1)) → Even (Finset.prod Finset.univ fun k => k)"]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H","text":"Every index 2 subgroup of a group is normal.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t\"},\n {\"role\": \"user\", \"content\": \"The additive subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_2} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an element in a group has order two, then it is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 2 → x⁻¹ = x\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, every element is its own inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 → ∀ (x : G), x⁻¹ = x\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_5} {S : Type u_6} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\"},\n {\"role\": \"user\",\n  \"content\": \"In a group of exponent two, all elements commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.exponent G = 2 → ∀ (x y : G), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"Two subgroups are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G}, (∀ (x : G), x ∈ H ↔ x ∈ K) → H = K\"},\n {\"role\": \"user\", \"content\": \"A subgroup contains the group's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), 1 ∈ H\"},\n {\"role\": \"user\", \"content\": \"Any normal subgroup is either `⊥` or `⊤` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤\"},\n {\"role\": \"user\", \"content\": \"The normal closure of a set is a subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\", \"content\": \"The normal closure of s is a normal subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\"},\n {\"role\": \"user\", \"content\": \"Every index 2 subgroup of a group is normal.\"}]","all_elaborations":[" ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H "," ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H "," ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H"," ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H "]}
{"theorem":"∀ (G : Type u_1) [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G","text":"Every free group is torsion free.","result":true,"gps":[["∀ (G : Type u_1) [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G"],["∀ (G : Type u_1) [inst : Group G], Function.Injective ⇑(MonoidHom.id G) → Monoid.IsTorsionFree G"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion ↥(CommMonoid.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion ↥N → AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic ↥(NumberField.Units.torsion K)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion ↥N → Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\", \"content\": \"Every free group is torsion free.\"}]","all_elaborations":[" ∀ (G : Type u_1) [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G "," ∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G"," ∀ (G : Type u_1) [inst : Group G], Function.Injective (MonoidHom.id G) → Monoid.IsTorsionFree G"]}
{"theorem":"∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","text":"Every natural number greater than `1` is divisible by a prime number.","result":true,"gps":[["∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ {n : ℕ}, 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ {n : ℕ}, 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ {n : ℕ}, 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"No zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {k p : ℕ}, k ≠ 0 → Nat.Prime p → (p ^ k).primeFactors = {p}\"},\n {\"role\": \"user\",\n  \"content\": \"Exactly `n / p` naturals in `(0, n]` are multiples of `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n p : ℕ), Finset.card (Finset.filter (fun x => p ∣ x) (Finset.Ioc 0 n)) = n / p\"},\n {\"role\": \"user\", \"content\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ}, Nat.Prime p → (Nat.factorization p) p = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of the prime factors of `n` that are less than `N` is an `N`-smooth number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n N : ℕ), List.prod (List.filter (fun x => decide (x < N)) (Nat.factors n)) ∈ Nat.smoothNumbers N\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\": \"All composite numbers are Fermat pseudoprimes to base 1.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 1 < n → ¬Nat.Prime n → Nat.FermatPsp n 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, m ∣ n + m ↔ m ∣ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.\"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, m ∣ m + n ↔ m ∣ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"Exactly `n / p` naturals in `[1, n]` are multiples of `p`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n p : ℕ), Finset.card (Finset.filter (fun e => p ∣ e + 1) (Finset.range n)) = n / p\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number greater than `1` is divisible by a prime number.\"}]","all_elaborations":[" ∀ (n : ℕ), 1 < n → ∃ p : ℕ, Nat.Prime p ∧ p ∣ n"," ∀ {n : ℕ}, 1 < n → ∃ p : ℕ, Nat.Prime p ∧ p ∣ n"," Set.InjOn Nat.factorization {x | 1 < x} "," ∀ {n : ℕ}, 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "," ∀ {n : ℕ}, 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n"," Set.InjOn (fun (p : ℕ) => Nat.Prime p) {x | 1 < x}"]}
{"theorem":"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α","text":"A finite torsion-free group is trivial","result":true,"gps":[["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α","∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Fintype.card G).primeFactors }) → (P : Sylow (↑p) G) → ↥↑P) ≃* G → Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion ↥N → AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\", \"content\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion ↥N → Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite torsion-free group is trivial\"}]","all_elaborations":[" ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α "," ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α"]}
{"theorem":"∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D","text":"Every finite division ring is a field.","result":true,"gps":[["∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D","∀ (R : Type u_1) [inst : Finite R] [inst_1 : DivisionRing R], IsField R"],["∀ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], IsField D ∧ Finite D ∧ NoZeroDivisors D"],["∀ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"The group exponent exists for any bounded torsion group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G],\\n  Monoid.IsTorsion G → Set.Finite (Set.range fun g => orderOf g) → Monoid.ExponentExists G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Fintype.card G).primeFactors }) → (P : Sylow (↑p) G) → ↥↑P) ≃* G → Group.IsNilpotent G\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion ↥N → AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\", \"content\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion ↥N → Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite torsion-free group is trivial\"}]","all_elaborations":[" ∀ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], IsField D "," ∀ (R : Type u_1) [inst : Finite R] [inst : DivisionRing R], IsField R "," ∀ {D : Type u_1} [inst : Finite D] [inst_1 : CommRing D] [inst_2 : IsDomain D], IsField D "," ∀ {D : Type u_1} [inst : Finite D] [inst : DivisionRing D], IsField D ∧ Finite (D) ∧ NoZeroDivisors D"]}
{"theorem":"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X","text":"Every finite topological space is compact.","result":true,"gps":[["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X","∀ (X : Type u) [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"All hom spaces are finite dimensional. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k G : Type u} [inst : Field k] [inst_1 : Monoid G] (V W : FdRep k G), FiniteDimensional k (V ⟶ W)\"},\n {\"role\": \"user\", \"content\": \"A finite space is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_4} [inst : Bornology α] [inst_1 : Finite α], BoundedSpace α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : WeaklyLocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ⇑f → CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\",\n  \"content\": \"The disjoint union of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X ⊕ Y)\"},\n {\"role\": \"user\", \"content\": \"Convex hull of a finite set is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {E : Type u_3} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Set.Finite s → IsCompact ((convexHull ℝ) s)\"},\n {\"role\": \"user\", \"content\": \"In a `T2Space`, every compact set is closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X}, IsCompact s → IsClosed s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every open cover of a paracompact space assumes a locally finite refinement. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type v} [inst : TopologicalSpace X] [self : ParacompactSpace X] (α : Type v) (s : α → Set X),\\n  (∀ (a : α), IsOpen (s a)) →\\n    ⋃ a, s a = Set.univ →\\n      ∃ β t, ∃ (_ : ∀ (b : β), IsOpen (t b)) (_ : ⋃ b, t b = Set.univ), LocallyFinite t ∧ ∀ (b : β), ∃ a, t b ⊆ s a\"},\n {\"role\": \"user\", \"content\": \"The product of two compact spaces is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : CompactSpace Y], CompactSpace (X × Y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_2} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A measure which is finite on compact sets in a locally compact space is locally finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : TopologicalSpace α]\\n  [inst_1 : WeaklyLocallyCompactSpace α] [inst_2 : MeasureTheory.IsFiniteMeasureOnCompacts μ],\\n  MeasureTheory.IsLocallyFiniteMeasure μ\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\", \"content\": \"A compact discrete space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] [inst : DiscreteTopology X], Finite X\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X\"},\n {\"role\": \"user\", \"content\": \"Every finite topological space is compact.\"}]","all_elaborations":[" ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X "," ∀ (X : Type u) [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : Group β] (f : α →* β) [inst_2 : IsFreeGroup α]\n  [inst_3 : IsFreeGroup β], Function.Surjective ⇑f → Function.Injective ⇑f","text":"Every surjective homomorphism from a finitely generated free group to itself is injective.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : Group β] (f : α →* β) [inst_2 : IsFreeGroup α]\n  [inst_3 : IsFreeGroup β], Function.Surjective ⇑f → Function.Injective ⇑f"],["∀ {α : Type u} [inst : Group α] {β : Type v} [inst_1 : Group β] (f : α →* β),\n  Function.Surjective ⇑f → Function.Injective ⇑f"],["∀ {α : Type u} [inst : Group α] (β : Type v) [inst_1 : Group β] (f : α →ₙ* β),\n  Function.Surjective ⇑f → Function.Injective ⇑f"],["∀ (G : Type u_3) [inst : Group G] [inst_1 : Fintype G] (f : G →* G), Function.Surjective ⇑f → Function.Injective ⇑f"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The natural homomorphism from a monoid to its quotient by a congruence relation is\\nsurjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : MulOneClass M] {c : Con M}, Function.Surjective ⇑(Con.mk' c)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ⇑f → CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ⇑f ↔ Function.Surjective ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing with a family of surjective linear maps is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type uR} {ι : Type uι} {M₁ : ι → Type v₁} {M₂ : Type v₂} [inst : Semiring R]\\n  [inst_1 : (i : ι) → AddCommMonoid (M₁ i)] [inst_2 : AddCommMonoid M₂] [inst_3 : (i : ι) → Module R (M₁ i)]\\n  [inst_4 : Module R M₂] {M₁' : ι → Type u_1} [inst_5 : (i : ι) → AddCommMonoid (M₁' i)]\\n  [inst_6 : (i : ι) → Module R (M₁' i)] (f : (i : ι) → M₁ i →ₗ[R] M₁' i),\\n  (∀ (i : ι), Function.Surjective ⇑(f i)) → Function.Injective fun g => MultilinearMap.compLinearMap g f\"},\n {\"role\": \"user\", \"content\": \"A monomorphism is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_9} {M₂ : Type u_12} [inst : Semiring R] [inst_1 : Semiring R₂]\\n  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module R₂ M₂] {τ₁₂ : R →+* R₂}\\n  {f : M →ₛₗ[τ₁₂] M₂},\\n  (∀ (u v : ↥(LinearMap.ker f) →ₗ[R] M), LinearMap.comp f u = LinearMap.comp f v → u = v) → LinearMap.ker f = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism sends inverses to inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹\"},\n {\"role\": \"user\",\n  \"content\": \"Composing with a surjective linear map is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {N : Type u_3}\\n  [inst_3 : AddCommMonoid N] [inst_4 : Module R N] {ι : Type u_7} {M₂ : Type u_10} [inst_5 : AddCommMonoid M₂]\\n  [inst_6 : Module R M₂] (f : M₂ →ₗ[R] M),\\n  Function.Surjective ⇑f → Function.Injective fun g => AlternatingMap.compLinearMap g f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} {P : Type u_3} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\\n  Function.Injective ⇑(Con.kerLift f)\"},\n {\"role\": \"user\", \"content\": \"The ring homomorphism is surjective \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ : R₁ →+* R₂}\\n  [self : RingHomSurjective σ], Function.Surjective ⇑σ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The induced algebra morphism from the quotient by the kernel is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R₁ : Type u_1} {A : Type u_3} {B : Type u_4} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra R₁ A] [inst_4 : Algebra R₁ B] (f : A →ₐ[R₁] B), Function.Injective ⇑(Ideal.kerLiftAlg f)\"},\n {\"role\": \"user\", \"content\": \"Group homomorphisms preserve inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_6} {H : Type u_7} {F : Type u_8} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), f a⁻¹ = (f a)⁻¹\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ⇑f → Function.Bijective ⇑f\"},\n {\"role\": \"user\",\n  \"content\": \"Any injective endomorphism of an Artinian module is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ⇑f → Function.Bijective ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective polynomial map over an algebraic extension of a finite field is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {K : Type u_2} {R : Type u_3} [inst : Field K] [inst_1 : Finite K] [inst_2 : CommRing R]\\n  [inst_3 : Finite ι] [inst_4 : Algebra K R],\\n  Algebra.IsAlgebraic K R →\\n    ∀ (ps : ι → MvPolynomial ι R),\\n      (Function.Injective fun v i => (MvPolynomial.eval v) (ps i)) →\\n        Function.Surjective fun v i => (MvPolynomial.eval v) (ps i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ⇑f → Function.Surjective ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An additive group homomorphism is injective if its kernel is trivial.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : AddGroup α] [inst_1 : AddGroup β] {f : α → β},\\n  IsAddGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 0 → a = 0)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any injective endomorphism of an Artinian module is surjective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsArtinian R M] (f : M →ₗ[R] M), Function.Injective ⇑f → Function.Surjective ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any surjective endomorphism of a Noetherian module is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  [inst_3 : IsNoetherian R M] (f : M →ₗ[R] M), Function.Surjective ⇑f → Function.Injective ⇑f\"},\n {\"role\": \"user\",\n  \"content\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\"},\n {\"role\": \"user\",\n  \"content\": \"Every graph homomorphism from a complete graph is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} {W : Type v} {G' : SimpleGraph W} (f : ⊤ →g G'), Function.Injective ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every surjective homomorphism from a finitely generated free group to itself is injective.\"}]","all_elaborations":[" ∀ {α : Type u} [inst : Group α] {β : Type v} [inst_1 : Group β] (f : α →* β),\n  Function.Surjective ⇑f → Function.Injective ⇑f "," ∀ {α : Type u} [inst : Group α] (β : Type v) [inst_1 : Group β] (f : α →ₙ* β),\n  Function.Surjective ⇑f → Function.Injective ⇑f"," ∀ (G : Type u_3) [inst : Group G] [inst_1 : Fintype G] (f : G →* G),\n  Function.Surjective ⇑f → Function.Injective ⇑f"," ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : Group β] (f : α →* β) [inst_2 : IsFreeGroup α] [inst_3 : IsFreeGroup β],\n    Function.Surjective ⇑f → Function.Injective ⇑f"]}
{"theorem":"∀ {n : ℕ}, 0 < n → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","text":"Every positive even integer can be written as the sum of two primes.","result":true,"gps":[["∀ {n : ℕ}, 0 < n → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ (n : ℕ), 0 < n → Even n → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ n = a + b","∀ {n : ℕ}, 0 < n → Even n → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ n = a + b"],["∀ (n : ℕ), 0 < n → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ∧ p < q"],["∀ {n : ℕ}, 0 < n → Even n → ∃ p q, Prime p ∧ Prime q ∧ n = p + q ∧ p < q"],["∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ 2 * p + 2 * q = n"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A minimal polynomial is prime. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\"},\n {\"role\": \"user\",\n  \"content\": \"Any common divisor of both elements is a divisor of the GCD. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_2} [inst : CancelCommMonoidWithZero α] [self : GCDMonoid α] {a b c : α}, a ∣ c → a ∣ b → a ∣ gcd c b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\\n  n ≠ 0 → ∀ {x y : α}, x < y → 0 < y → ∃ q, 0 < q ∧ x < ↑q ^ n ∧ ↑q ^ n < y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The numerator and denominator are coprime: it is in \\\"reduced form\\\". \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : ℚ), Nat.Coprime (Int.natAbs self.num) self.den\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product lies in the prime ideal, then at least one element lies in the prime ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsPrime I] {x y : α}, x * y ∈ I → x ∈ I ∨ y ∈ I\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two positive elements is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [self : StrictOrderedRing α] (a b : α), 0 < a → 0 < b → 0 < a * b\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : ℕ → R},\\n  f 1 = 1 →\\n    (∀ {m n : ℕ}, Nat.Coprime m n → f (m * n) = f m * f n) →\\n      (∀ {p : ℕ}, Nat.Prime p → Summable fun n => ‖f (p ^ n)‖) →\\n        ∀ (N : ℕ),\\n          (Summable fun m => ‖f ↑m‖) ∧\\n            HasSum (fun m => f ↑m) (Finset.prod (Nat.primesBelow N) fun p => ∑' (n : ℕ), f (p ^ n))\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two positive naturals are equal if their prime padic valuations are equal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b : ℕ), a ≠ 0 → b ≠ 0 → (a = b ↔ ∀ (p : ℕ), Nat.Prime p → padicValNat p a = padicValNat p b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every positive even integer can be written as the sum of two primes.\"}]","all_elaborations":[" ∀ {n : ℕ}, 0 < n → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"," ∀ (n : ℕ) (_ : 0 < n), Even n → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ n = a + b"," ∀ {n : ℕ}, 0 < n → Even n → ∃ a b : ℕ, Nat.Prime a ∧ Nat.Prime b ∧ n = a + b"," ∀ (n : ℕ) (_ : 0 < n) (_ : Even n), ∃ p q, Prime p ∧ Prime q ∧ n = p + q"," ∀ {n : ℕ}, 0 < n → Even n → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ∧ p < q"," ∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ 2 * p + 2 * q = n"," ∀ (n : ℕ) (_ : 0 < n) (h : n % 2 = 0), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ∧ p < q"]}
{"theorem":"∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)","text":"The square root of an irrational number is irrational.","result":true,"gps":[["∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)","∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)","∀ {r : ℝ} {x : ℝ}, Irrational r → Irrational (Real.sqrt r)"],["∀ {x : ℚ}, Irrational ↑x → Irrational (Real.sqrt ↑x)"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖φ x‖ = 1) → ∃ n, ∃ (_ : 0 < n), x ^ n = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Let `r` be an irrational number. Then `B⁺_r` and `B⁺'_r` are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {r : ℝ}, Irrational r → {x | ∃ k > 0, beattySeq' r k = x} = {x | ∃ k > 0, beattySeq r k = x}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every terminating continued fraction corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {v : K},\\n  GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of v) → ∃ q, v = ↑q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\"},\n {\"role\": \"user\", \"content\": \"The complex numbers are not countable. \"},\n {\"role\": \"assistant\", \"content\": \"¬Set.Countable Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\"},\n {\"role\": \"user\",\n  \"content\": \"Every finite convergent corresponds to a rational number. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K) (n : ℕ),\\n  ∃ q, GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n = ↑q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\"},\n {\"role\": \"user\",\n  \"content\": \"The continued fraction of a rational number terminates. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\",\n  \"content\": \"If a rational is not a p-adic integer, it is not an integer. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (p : ℕ) {a : ℚ} [hp : Fact (Nat.Prime p)], 1 < padicNorm p a → ¬Rat.isInt a = true\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p x : ℝ}, LiouvilleWith p x → 1 < p → Irrational x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\", \"content\": \"The golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenRatio\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an irrational number is irrational.\"}]","all_elaborations":[" ∀ {r : ℝ} (h : Irrational r), Irrational (Real.sqrt r) "," ∀ {r : ℝ} (h : Irrational r), Irrational (Real.sqrt r) "," ∀ {x : ℚ}, Irrational x → Irrational (Real.sqrt x) "," ∀ {r x : ℝ}, Irrational r → Irrational (Real.sqrt r)"]}
{"theorem":"∀ {α : Type u} [inst : LinearOrderedRing α] {n : α}, n * n = 0 → n = 0","text":"If the square of a number is even, the number itself is even.","result":true,"gps":[["∀ {α : Type u} [inst : LinearOrderedRing α] {n : α}, n * n = 0 → n = 0"],["∀ {α : Type u} [inst : LinearOrderedRing α] {n : α}, ∃ x, x * x = 2 * n → Even n"],["∀ {α : Type u} [inst : LinearOrderedRing α] {a b : α}, a * a = 2 * b ↔ Even b ∧ Even a"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square in `F` iff `#F` is not congruent to `3` or `5` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare 2 ↔ Fintype.card F % 8 ≠ 3 ∧ Fintype.card F % 8 ≠ 5\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\", \"content\": \"The square of the symbol is 1 if `p ∤ a`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A square has a lifting if and only if its (right) adjoint square has a lifting. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_3, u_1} C]\\n  [inst_1 : CategoryTheory.Category.{u_4, u_2} D] {G : CategoryTheory.Functor C D} {F : CategoryTheory.Functor D C}\\n  {A B : C} {X Y : D} {i : A ⟶ B} {p : X ⟶ Y} {u : G.obj A ⟶ X} {v : G.obj B ⟶ Y}\\n  (sq : CategoryTheory.CommSq u (G.map i) p v) (adj : G ⊣ F),\\n  CategoryTheory.CommSq.HasLift\\n      (_ :\\n        CategoryTheory.CommSq ((CategoryTheory.Adjunction.homEquiv adj A X) u) i (F.map p)\\n          ((CategoryTheory.Adjunction.homEquiv adj B Y) v)) ↔\\n    CategoryTheory.CommSq.HasLift sq\"},\n {\"role\": \"user\",\n  \"content\": \"The square of `J(a | b)` is `1` when `a` and `b` are coprime. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℤ} {b : ℕ}, Int.gcd a ↑b = 1 → jacobiSym a b ^ 2 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum over the values of the quadratic character is zero when the characteristic is odd. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F ≠ 2 → (Finset.sum Finset.univ fun a => (quadraticChar F) a) = 0\"},\n {\"role\": \"user\",\n  \"content\": \"The square of a quadratic character is the trivial character. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {χ : MulChar R R'},\\n  MulChar.IsQuadratic χ → χ ^ 2 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `n`th power of a quadratic character is itself, when `n` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {χ : MulChar R R'},\\n  MulChar.IsQuadratic χ → ∀ {n : ℕ}, Odd n → χ ^ n = χ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_5} {S' : Type u_6}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The special case of Graham's conjecture where all numbers are squarefree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (f : ℕ → ℕ), (∀ k < n, Squarefree (f k)) → Nat.GrahamConjecture n f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a ≠ 0 → (quadraticChar F) a ^ 2 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_3} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The convolution of two even functions is also even. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\": \"If the square of a number is even, the number itself is even.\"}]","all_elaborations":[" ∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 "," ∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 "," ∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 "," ∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x ^ 2 % 2 = 0 → x % 2 = 0 "," ∀ {α : Type u} [inst : LinearOrderedRing α] {n : α}, n * n % 2 = 0 → n % 2 = 0 "," ∀ {α : Type u} [inst : LinearOrderedRing α] (x : α), x ^ 2 % 2 = 0 → x % 2 = 0"," ∀ {α : Type u} [inst : LinearOrderedRing α] {n : α}, ∃ x, x * x = 2 * n → Even n"," ∀ {α : Type u} [inst : LinearOrderedRing α] {a b : α}, a * a = 2 * b ↔ Even b ∧ Even a"," ∀ {α : Type u} [inst : LinearOrderedRing α] {n : α}, n * n = 0 → n = 0 "," ∀ {α : Type u} [inst : LinearOrderedRing α] {n : α}, ∃ k : α, n ^ 2 = 2 * k → n = 0 ∨ n = 2 * k ∧ k = 0 𝕜"]}
{"theorem":"∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","text":"In a finite commutative ring, all prime ideals are maximal.","result":true,"gps":[["∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"],["∀ {R : Type u} [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u} [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ (R : Type u) [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"],["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Finite R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The unique maximal ideal of the localization at `I.primeCompl` lies over the ideal `I`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] {I : Ideal R} [hI : Ideal.IsPrime I],\\n  Ideal.comap (algebraMap R (Localization.AtPrime I)) (LocalRing.maximalIdeal (Localization (Ideal.primeCompl I))) = I\"},\n {\"role\": \"user\",\n  \"content\": \"The only constant in a maximal ideal over a field is `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R],\\n  IsField R → ∀ (I : Ideal (Polynomial R)) [hI : Ideal.IsMaximal I] (x : R), Polynomial.C x ∈ I → x = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The prime spectrum of a commutative ring is a compact topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R], CompactSpace (PrimeSpectrum R)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The variable of the power series ring over an integral domain is prime.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], Prime PowerSeries.X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `Ideal.closure` of a maximal ideal in a complete normed ring is the ideal itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R}, Ideal.IsMaximal I → Ideal.closure I = I\"},\n {\"role\": \"user\",\n  \"content\": \"The kernel of a homomorphism to a field is a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {K : Type u_2} {F : Type u_3} [inst : Ring R] [inst_1 : Field K] [inst_2 : RingHomClass F R K] (f : F),\\n  Function.Surjective ⇑f → Ideal.IsMaximal (RingHom.ker f)\"},\n {\"role\": \"user\",\n  \"content\": \"This ideal is maximal in the collection of proper ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {P : Type u_1} [inst : LE P] {I : Order.Ideal P} [self : Order.Ideal.IsMaximal I] ⦃J : Order.Ideal P⦄,\\n  I < J → ↑J = Set.univ\"},\n {\"role\": \"user\",\n  \"content\": \"The category of commutative rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommRingCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A ring is Noetherian if and only if all its ideals are finitely-generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Semiring R], IsNoetherianRing R ↔ ∀ (I : Ideal R), Ideal.FG I\"},\n {\"role\": \"user\", \"content\": \"Any finitely generated ideal is principal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] [self : IsBezout R] (I : Ideal R), Ideal.FG I → Submodule.IsPrincipal I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\": \"Maximal ideals in complete normed rings are closed. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\": \"In a finite commutative ring, all prime ideals are maximal.\"}]","all_elaborations":[" ∀ {R : Type u} [inst : CommRing R] [inst_1 : Finite R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P "," ∀ {R : Type u} [inst : CommRing R] [Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) "," ∀ {R : Type u} [inst : CommRing R] [inst_1 : Finite R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"," ∀ (R : Type u) [inst : CommRing R] [Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"," ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Finite R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P "," ∀ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P "," ∀ (R : Type u) [inst : CommRing R] [inst_1 : Finite R],\n  (P : Ideal R) → Ideal.IsPrime P → Ideal.IsMaximal P "," ∀ (R : Type u) [inst : CommRing R] [inst_1 : Fintype R], ∀ P : Ideal R, Ideal.IsPrime P → Ideal.IsMaximal P"]}
{"theorem":"∀ (X : Type u) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.1 = p.2}","text":"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.","result":true,"gps":[["∀ (X : Type u) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.1 = p.2}"],["∀ (X : Type u_3) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.1 = p.2}"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ⇑f → CategoryTheory.IsIso f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A linear order with order topology is a completely normal Hausdorff topological space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : LinearOrder X] [inst_1 : TopologicalSpace X] [inst : OrderTopology X], T5Space X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous injective map from a compact space to a Hausdorff space is a closed embedding. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X → Y}, Continuous f → Function.Injective f → ClosedEmbedding f\"},\n {\"role\": \"user\",\n  \"content\": \"A weakly locally compact Hausdorff space is locally compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] [inst_2 : T2Space X],\\n  LocallyCompactSpace X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X → Y}, Function.Surjective f → Continuous f → QuotientMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff edistance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s t : Set α},\\n  IsClosed s → IsClosed t → (EMetric.hausdorffEdist s t = 0 ↔ s = t)\"},\n {\"role\": \"user\", \"content\": \"Stonean spaces are Hausdorff. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (X : Stonean), T2Space (CoeSort.coe X)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ⇑f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff space is totally disconnected\\nif and only if it is totally separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {H : Type u_3} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H],\\n  TotallyDisconnectedSpace H ↔ TotallySeparatedSpace H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {H : Type u_3} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  IsClosed s → IsClosed t → EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ s = t)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a complete space, the type of closed subsets is complete for the\\nHausdorff edistance. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompleteSpace α], CompleteSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : T2Space X] (x y : X),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : CompactSpace X]\\n  [inst_3 : T2Space Y] {f : X → Y}, Continuous f → IsClosedMap f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.\"}]","all_elaborations":[" ∀ (X : Type u_3) [inst : TopologicalSpace X],\n  T2Space X ↔ IsClosed { p : X × X | p.1 = p.2 } "," ∀ (X : Type u) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p : X × X | p.1 = p.2}"," ∀ (X : Type u_3) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {x | x.fst = x.snd}"]}
{"theorem":"∀ {α : Type u_1} [inst : TopologicalSpace α] (U : Set α) (x : α → α),\n  ∀ y ∈ U, ∃ V, IsOpen V ∧ y ∈ V ∧ x y ∈ V → U ⊆ V ∧ IsOpen U","text":"If every point of a subset of a topological space is contained in some open set, the subset itself is open.","result":true,"gps":[["∀ {α : Type u_1} [inst : TopologicalSpace α] (U : Set α) (x : α → α),\n  ∀ y ∈ U, ∃ V, IsOpen V ∧ y ∈ V ∧ x y ∈ V → U ⊆ V ∧ IsOpen U"],["∀ {α : Type u} [inst : TopologicalSpace α] (U : Set α), (∀ x ∈ U, ∃ V, IsOpen V ∧ x ∈ V ∧ V ⊆ U) → IsOpen U"],["∀ {α : Type u} [inst : TopologicalSpace α] (U : Set α), (∀ x ∈ U, ∃ V, IsOpen V ∧ x ∈ V) → IsOpen U"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The first projection in a product of topological spaces sends open sets to open sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.fst\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only open sets in the indiscrete topology are the empty set and the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} (U : Set α), IsOpen U ↔ U = ∅ ∨ U = Set.univ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S U : Set X},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] {s : Set X},\\n  Set.Finite s → ∃ U, (∀ (x : X), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\"},\n {\"role\": \"user\",\n  \"content\": \"Subsets of a given closed subset form a closed set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\"},\n {\"role\": \"user\",\n  \"content\": \"In a (pre)irreducible space, a nonempty open set is dense. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : PreirreducibleSpace X],\\n  IsOpen s → Set.Nonempty s → Dense s\"},\n {\"role\": \"user\", \"content\": \"The closure of every open set is open. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : ExtremallyDisconnected X] (U : Set X), IsOpen U → IsOpen (closure U)\"},\n {\"role\": \"user\",\n  \"content\": \"A closed subset of a compact set is a compact set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {s t : Set X}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An open set in the indiscrete topology is either empty or the whole space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_5} [t : TopologicalSpace α], t = ⊤ → ∀ (U : TopologicalSpace.Opens α), U = ⊥ ∨ U = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Characterization of when a subset of the space of points is open. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (L : Type u_1) [inst : CompleteLattice L] (U : Set (Locale.PT L)), IsOpen U ↔ ∃ u, {x | x u} = U\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\"}]","all_elaborations":[" ∀ {α : Type u} [inst : TopologicalSpace α] (U : Set α),\n  (∀ (x : α), x ∈ U → ∃ (V : Set α), IsOpen V ∧ x ∈ V ∧ V ⊆ U) → IsOpen U "," ∀ {α : Type u} [inst : TopologicalSpace α] (U : Set α),\n  (∀ (x : α), x ∈ U → ∃ (V : Set α), IsOpen V ∧ x ∈ V) → IsOpen U "," ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X},\n  (∀ x : X, x ∈ s → ∃ u, IsOpen u ∧ x ∈ u) → IsOpen s"," ∀ {X : Type u} [inst : TopologicalSpace X] (s t : Set X), ∀ (x : X), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U → x ∈ t → U ⊆ t ∧ IsOpen s ∧ IsClosed t"," ∀ {α : Type u_1} [inst : TopologicalSpace α] (U : Set α) (x : α → α), ∀ y ∈ U, ∃ V : Set α, IsOpen V ∧ y ∈ V ∧ x y ∈ V → U ⊆ V ∧ IsOpen U "," ∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α) [inst_1 : T1Space α] (x : α) (hx : x ∈ s), ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s ∧ Set.Nonempty (U ∩ s) → IsOpen s"]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x","text":"Every non-identity element of a free group is of infinite order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g"],["∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Inverses of elements of finite additive order\\nhave finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {x : G}, IsOfFinAddOrder (-x) ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\", \"content\": \"0 is of finite order in any additive monoid.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is simple. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The Nielsen-Schreier theorem: a subgroup of a free group is free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] (H : Subgroup G), IsFreeGroup ↥H\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\"},\n {\"role\": \"user\", \"content\": \"1 is of finite order in any monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1\"},\n {\"role\": \"user\",\n  \"content\": \"The free product of free groups is itself a free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_4} (G : ι → Type u_5) [inst : (i : ι) → Group (G i)] [inst_1 : ∀ (i : ι), IsFreeGroup (G i)],\\n  IsFreeGroup (Monoid.CoprodI G)\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The image of an element of finite additive order has finite additive order.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddMonoid G] [inst_1 : AddMonoid H] (f : G →+ H) {x : G},\\n  IsOfFinAddOrder x → IsOfFinAddOrder (f x)\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group element has finite additive order iff its order is positive.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G}, 0 < addOrderOf x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of finite order are of finite order in submonoids.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {H : AddSubmonoid G} {x : ↥H}, IsOfFinAddOrder ↑x ↔ IsOfFinAddOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an element of finite order has finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (f x)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g\"},\n {\"role\": \"user\",\n  \"content\": \"A group element has finite order iff its order is positive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Inverses of elements of finite order have finite order. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every non-identity element of a free group is of infinite order.\"}]","all_elaborations":[" ∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x "," ∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x "," ∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x "," ∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x"," ∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g "," ∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x "," ∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g"]}
{"theorem":"∀ {a b : ℕ} {x y u v : ℕ},\n  Nat.Coprime a b →\n    ∀ (N : ℕ), ∃ r s, r * a + s * b = N ∧ ∀ (m : ℕ), Nat.Coprime m a → Nat.Coprime m b → ∃ x y, m = a * x + b * y","text":"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.","result":true,"gps":[["∀ {a b : ℕ} {x y u v : ℕ},\n  Nat.Coprime a b →\n    ∀ (N : ℕ), ∃ r s, r * a + s * b = N ∧ ∀ (m : ℕ), Nat.Coprime m a → Nat.Coprime m b → ∃ x y, m = a * x + b * y"],["∀ {a b : ℕ} {x y u v : ℕ}, Nat.Coprime a b → ∀ (N : ℕ), ∃ r s, a * r + b * s = N"],["∀ {a b n : ℕ} {x y : ℕ}, Nat.Coprime a b → 0 < a → 0 < b → ∃ x y, n = a * x + b * y"],["∀ {a b : ℕ} {x y : ℕ} {N : ℕ},\n  a ≠ 0 → b ≠ 0 → Nat.Coprime a b → ∃ x y, a * x + b * y = N ∧ y < N ∧ x < N ∧ (y + x) * (y + x) ≤ 2 * N"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Rational numbers are dense in a linear ordered archimedean field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]\\n  [inst_3 : Archimedean 𝕜], DenseRange Rat.cast\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is a rational power between any two positive elements of an archimedean ordered field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\\n  n ≠ 0 → ∀ {x y : α}, x < y → 0 < y → ∃ q, 0 < q ∧ x < ↑q ^ n ∧ ↑q ^ n < y\"},\n {\"role\": \"user\", \"content\": \"For `a ≤ b`, there is a `c` so `b = a * c`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedCommMonoid α] {a b : α}, a ≤ b → ∃ c, b = a * c\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For coprime `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b : ℕ}, Nat.Coprime a b → List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"We relate a finite product over primes to an infinite sum over smooth numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedCommRing R] [inst_1 : CompleteSpace R] {f : ℕ → R},\\n  f 1 = 1 →\\n    (∀ {m n : ℕ}, Nat.Coprime m n → f (m * n) = f m * f n) →\\n      (∀ {p : ℕ}, Nat.Prime p → Summable fun n => ‖f (p ^ n)‖) →\\n        ∀ (N : ℕ),\\n          (Summable fun m => ‖f ↑m‖) ∧\\n            HasSum (fun m => f ↑m) (Finset.prod (Nat.primesBelow N) fun p => ∑' (n : ℕ), f (p ^ n))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For positive `a` and `b`, the prime factors of `a * b` are the union of those of `a` and `b` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b : ℕ}, a ≠ 0 → b ≠ 0 → List.Perm (Nat.factors (a * b)) (Nat.factors a ++ Nat.factors b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.\"}]","all_elaborations":[" ∀ {a b x y u v : ℕ}, Nat.Coprime a b → ∀ N, ∃ r s, a * r + b * s = N"," ∀ {a b n x y : ℕ}, Nat.Coprime a b → 0 < a → 0 < b → ∃ (x y : ℕ), ↑n = a * x + b * y"," ∀ {a b x y u v : ℕ}, Nat.Coprime a b → ∃ r s, ∀ N > max u v, ∃ m n, N = a * m + b * n"," ∀ {a b x y u v n : ℕ}, ∃ n, Nat.Coprime a b → x ≠ 0 → y ≠ 0 → a * u ^ 2 + b * v ^ 2 = n * (a * x + b * y) "," ∀ {a b x y u v N : ℕ}, Nat.Coprime a b → 0 < a → 0 < b → ∃ u v r s, N = u * a + v * b → a * b * r = a * u * x + b * v * y "," ∀ {a b x y u v : ℕ}, Nat.Coprime a b → ∀ (N : ℕ) (_hp : 1 < N), ∃ r s, ↑N = ↑a * r + ↑b * s"," ∀ {a b x y N : ℕ}, a ≠ 0 → b ≠ 0 → Nat.Coprime a b → ∃ x y, a * x + b * y = N ∧ y < N ∧ x < N ∧ (y + x) * (y + x) ≤ 2 * N"," ∀ {a b x y u v : ℕ}, Nat.Coprime a b → ∀ (N : ℕ), ∃ r s, r * a + s * b = N ∧ ∀ m, Nat.Coprime m a → Nat.Coprime m b → ∃ x y, m = a * x + b * y"," ∀ {a b x y u v : ℕ} [inst : DecidableEq ℕ] {n : ℕ},\n  a ≠ 0 → b ≠ 0 → Nat.Coprime a b →\n    ∃ N, ∀ n, N ≤ n → ∃ x y u v,\n      a * x + b * y = n ∧ u * a + v * b = n ∧ x < u ∧ y < v ∧ (¬x.Prime ∨ ¬y.Prime) ∧ (¬u.Prime ∨ ¬v.Prime)"]}
{"theorem":"{K : Type u_1} → [inst : Field K] → Ring K","text":"Every field is a ring.","result":true,"gps":[["{K : Type u_1} → [inst : Field K] → Ring K","{K : Type u_1} → [inst : Field K] → Ring K","{K : Type u_1} → [inst : Field K] → Ring K"],["∀ {K : Type u_1} [inst : Field K] {R : Type u_2} [inst_1 : Ring R],\n  K ≃+* R → IsDomain R ∧ ∀ (x : R), ∃ y, x * y = 1 ∨ y * x = 1 ∧ y ≠ 0"],["{K : Type u} → [inst : Field K] → Ring K"],["(K : Type u) → [inst : Field K] → Ring K"],["(K : Type u_1) → [inst : Field K] → Ring K"],["{F : Type u_2} → [inst : Field F] → Ring F"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"The characteristic of a finite ring cannot be zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : NonAssocRing R] (p : ℕ) [inst : CharP R p] [inst : Finite R], p ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two rings are isomorphic, and the second is a domain, then so is the first. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {A : Type u_7} (B : Type u_8) [inst : Semiring A] [inst_1 : Semiring B] [inst_2 : IsDomain B], A ≃* B → IsDomain A\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"Every ring involution must be its own inverse \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_2} {R : outParam (Type u_3)} [inst : Semiring R] [self : RingInvoClass F R] (f : F) (x : R),\\n  MulOpposite.unop (f (MulOpposite.unop (f x))) = x\"},\n {\"role\": \"user\", \"content\": \"A seminormed ring is a topological ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NonUnitalSeminormedRing α], TopologicalRing α\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A field is perfect if every irreducible polynomial is separable. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : Field K] [self : PerfectField K] {f : Polynomial K}, Irreducible f → Polynomial.Separable f\"},\n {\"role\": \"user\",\n  \"content\": \"Stalks of a locally ringed space are local rings. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (self : AlgebraicGeometry.LocallyRingedSpace) (x : ↑↑self.toPresheafedSpace),\\n  LocalRing ↑(TopCat.Presheaf.stalk self.presheaf x)\"},\n {\"role\": \"user\",\n  \"content\": \"The ring of integers of a number field is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField ↥(NumberField.ringOfIntegers K)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A perfect field of characteristic `p` (prime) is a perfect ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : PerfectField K] (p : ℕ) [hp : Fact (Nat.Prime p)] [inst_2 : CharP K p],\\n  PerfectRing K p\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\",\n  \"content\": \"A linear ordered field that is a floor ring is archimedean. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u_2) [inst : LinearOrderedField α] [inst_1 : FloorRing α], Archimedean α\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  1 ∈ S\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"Every field is a ring.\"}]","all_elaborations":[" ∀ {K : Type u_1} [inst : Field K], Ring K "," ∀ {K : Type u_1} [inst : Field K], Ring K "," ∀ {K : Type u_1} [inst : Field K], Ring K "," ∀ {K : Type u} [inst : Field K], Ring K "," ∀ (K : Type u) [inst : Field K], Ring K "," ∀ (K : Type u_1) [inst : Field K], Ring K "," ∀ {F : Type u_2} [inst : Field F], Ring F "," ∀ {K : Type u_1} [inst : Field K] {R : Type u_2} [inst_1 : Ring R],\n  K ≃+* R → IsDomain R ∧ ∀ (x : R), ∃ (y : R), x * y = 1 ∨ y * x = 1 ∧ y ≠ 0"]}
{"theorem":"{R : Type u_1} → [inst : Ring R] → Group Rˣ","text":"The set of units in a ring forms a group.","result":true,"gps":[["{R : Type u_1} → [inst : Ring R] → Group Rˣ","{R : Type u_1} → [inst : Ring R] → Group Rˣ"],["{R : Type u_1} → [inst : GroupWithZero R] → [inst_1 : Invertible 0] → Group Rˣ"],["{R : Type u_1} → [inst : Ring R] → Group Rˣ"],["{R : Type u} → [inst : Ring R] → Group Rˣ"],["{R : Type u_1} → [inst : CommRing R] → Group Rˣ"],["{R : Type u} → [inst : GroupWithZero R] → GroupWithZero Rˣ"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Multivariate formal power series over a local ring form a local ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {σ : Type u_1} {R : Type u_2} [inst : CommRing R] [inst_1 : LocalRing R], LocalRing (MvPowerSeries σ R)\"},\n {\"role\": \"user\",\n  \"content\": \"The subring generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {s : Set R}, s ⊆ ↑(Subring.closure s)\"},\n {\"role\": \"user\", \"content\": \"A unit in a monoid is regular. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Monoid R] {a : R}, IsUnit a → IsRegular a\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\", \"content\": \"A finite group of prime order is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\"},\n {\"role\": \"user\", \"content\": \"The normal closure of a set is a subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A group is finitely generated if and only if it is finitely generated as a monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {G : Type u_3} [inst : Group G], Group.FG G ↔ Monoid.FG G\"},\n {\"role\": \"user\", \"content\": \"A seminormed ring is a topological ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NonUnitalSeminormedRing α], TopologicalRing α\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 1. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 1 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\", \"content\": \"A subring contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R] (s : Subring R), 0 ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"The subgroup generated by a set includes the set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\"},\n {\"role\": \"user\", \"content\": \"The unit circle in `ℂ` is a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"LieGroup (modelWithCornersSelf ℝ (EuclideanSpace ℝ (Fin 1))) ↥circle\"},\n {\"role\": \"user\",\n  \"content\": \"The center of a group acts commutatively on that group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G (↥(Subgroup.center G)) G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the unit group of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Group G] [inst_3 : Finite G]\\n  (f : G →* R), Function.Injective ⇑f → IsCyclic G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite subgroup of the units of an integral domain is cyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (S : Subgroup Rˣ) [inst_2 : Finite ↥S], IsCyclic ↥S\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\",\n  \"content\": \"The units of a complete normed ring form a Lie group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {𝕜 : Type u_2} [inst_2 : NontriviallyNormedField 𝕜]\\n  [inst_3 : NormedAlgebra 𝕜 R], LieGroup (modelWithCornersSelf 𝕜 R) Rˣ\"},\n {\"role\": \"user\", \"content\": \"The set of units in a ring forms a group.\"}]","all_elaborations":[" ∀ {R : Type u_1} [inst : Ring R], Group Rˣ "," ∀ {R : Type u_1} [inst : Ring R], Group Rˣ "," ∀ {R : Type u_1} [inst : Ring R], Group Rˣ"," ∀ {R : Type u} [inst : Ring R], Group Rˣ "," ∀ {R : Type u_1} [inst : CommRing R], Group Rˣ "," ∀ {R : Type u} [inst : GroupWithZero R], GroupWithZero Rˣ"," ∀ {R : Type u_1} [inst : GroupWithZero R] [inst_1 : Invertible (0 : R)], Group Rˣ "]}
{"theorem":"∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G → Monoid.IsTorsionFree H","text":"If the direct product of two groups is torsion free then each of the groups is torsion free.","result":true,"gps":[["∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G → Monoid.IsTorsionFree H","∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G → Monoid.IsTorsionFree H"],["∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H"]],"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting by the torsion submodule gives a torsion-free module. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M],\\n  Submodule.torsion R (M ⧸ Submodule.torsion R M) = ⊥\"},\n {\"role\": \"user\",\n  \"content\": \"The free product of free groups is itself a free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_4} (G : ι → Type u_5) [inst : (i : ι) → Group (G i)] [inst_1 : ∀ (i : ι), IsFreeGroup (G i)],\\n  IsFreeGroup (Monoid.CoprodI G)\"},\n {\"role\": \"user\", \"content\": \"The torsion subgroup is cylic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsCyclic ↥(NumberField.Units.torsion K)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\", \"content\": \"Torsion submonoids are torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion ↥(CommMonoid.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Additive torsion groups are closed under extensions.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : AddGroup G] {N : AddSubgroup G} [inst_1 : AddGroup H] {f : G →+ H},\\n  N = AddMonoidHom.ker f → AddMonoid.IsTorsion H → AddMonoid.IsTorsion ↥N → AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\"},\n {\"role\": \"user\",\n  \"content\": \"The image of a quotient is torsion iff the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  Function.Surjective ⇑f → N = MonoidHom.ker f → Monoid.IsTorsion ↥N → (Monoid.IsTorsion H ↔ Monoid.IsTorsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"If a group exponent exists, the group is torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.ExponentExists G → Monoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion ↥H\"},\n {\"role\": \"user\", \"content\": \"Torsion groups are closed under extensions. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion ↥N → Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree ↥H\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_3} {Gs : η → Type u_4} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the direct product of two groups is torsion free then each of the groups is torsion free.\"}]","all_elaborations":[" ∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H "," ∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G → Monoid.IsTorsionFree H"," ∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G → Monoid.IsTorsionFree H"]}
