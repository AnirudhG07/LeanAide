{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "prompt-examples":
 {"sequence":
  [{"embedSearch": {"penalty": 1, "n": 10, "descField": "docString"}},
   {"embedSearch": {"penalty": 1, "n": 2, "descField": "concise-description"}},
   {"embedSearch": {"penalty": 1, "n": 2, "descField": "description"}},
   {"moogle":
    {"preferDocs": true,
     "n": 2,
     "descFields": ["concise-description", "description"]}}]},
 "number-similar-sentences":
 "docString:10-concise-description:2-description:2-moogle:2",
 "failures":
 [[],
  [],
  [{"parsed":
    {"text": "∀ (F : Type u) [inst : FiniteField F], FiniteField.card F ≠ 10",
     "elabError":
     "unknown identifier 'FiniteField' ; identifiers [F, u, inst, FiniteField, F, FiniteField.card, F] (during elaboration) for ∀ (F : Type u) [inst : FiniteField F], FiniteField.card F ≠ 10",
     "context?": "There is no field of order `10`.",
     "cmdErrors":
     ["invalid binder annotation, type is not a class instance\n  ?m.12\nuse the command `set_option checkBinderAnnotations false` to disable the check",
      "function expected at\n  FiniteField\nterm has type\n  ?m.6",
      "unused universe parameter 'u'"]}},
   {"unparsed":
    {"text": "∄ (F : Type u) [inst : FiniteField F], F ≃ₐ ℤmod 10",
     "parseError": "<input>:1:0: expected token",
     "context?": "There is no field of order `10`."}},
   {"parsed":
    {"text":
     "∀ (F : Type u) [inst : Field F], ¬IsFiniteField F ∧ Cardinal.ord (F) = 10",
     "elabError":
     "unknown identifier 'IsFiniteField' ; identifiers [F, u, inst, Field, F, IsFiniteField, F, Cardinal.ord, F] (during elaboration) for ∀ (F : Type u) [inst : Field F], ¬IsFiniteField F ∧ Cardinal.ord (F) = 10",
     "context?": "There is no field of order `10`.",
     "cmdErrors":
     ["application type mismatch\n  Cardinal.ord F\nargument\n  F\nhas type\n  Type u : Type (u + 1)\nbut is expected to have type\n  Cardinal.{?u.20} : Type (?u.20 + 1)",
      "function expected at\n  IsFiniteField\nterm has type\n  ?m.9"]}},
   {"unparsed":
    {"text": "¬∃ (F : Type u) [inst : Field F], F ≃ₛ fin 10",
     "parseError": "<input>:1:16: expected ','",
     "context?": "There is no field of order `10`."}},
   {"unparsed":
    {"text": "¬∃ (F : Type u) [inst : Field F], #F = 10",
     "parseError": "<input>:1:16: expected ','",
     "context?": "There is no field of order `10`."}}],
  [{"parsed":
    {"text":
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V = ⊥",
     "elabError":
     "failed to synthesize\n  EmptyCollection (Type ?u.8256319)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [K, u, V, v, inst, DivisionRing, K, inst_1, AddCommGroup, V, inst_2, Module, K, V, Basis, K, V, V] (during elaboration) for ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V = ⊥",
     "context?": "A vector space with the empty set as basis is trivial.",
     "cmdErrors":
     ["failed to synthesize\n  EmptyCollection (Type ?u.1864)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "failed to synthesize\n  Bot (Type v)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text":
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → ∀ (v : V), v = 0",
     "elabError":
     "failed to synthesize\n  EmptyCollection (Type ?u.8259588)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [K, u, V, v, inst, DivisionRing, K, inst_1, AddCommGroup, V, inst_2, Module, K, V, Basis, K, V, v, V, v] (during elaboration) for ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → ∀ (v : V), v = 0",
     "context?": "A vector space with the empty set as basis is trivial.",
     "cmdErrors":
     ["failed to synthesize\n  EmptyCollection (Type ?u.1864)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text":
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → Submodule.eq_bot (Module.span K ∅)",
     "elabError":
     "failed to synthesize\n  EmptyCollection (Type ?u.8262857)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [K, u, V, v, inst, DivisionRing, K, inst_1, AddCommGroup, V, inst_2, Module, K, V, Basis, K, V, Submodule.eq_bot, Module.span, K] (during elaboration) for ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → Submodule.eq_bot (Module.span K ∅)",
     "context?": "A vector space with the empty set as basis is trivial.",
     "cmdErrors":
     ["failed to synthesize\n  EmptyCollection (Type ?u.1864)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "unknown constant 'Submodule.eq_bot'"]}},
   {"parsed":
    {"text":
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V = ⊥",
     "elabError":
     "failed to synthesize\n  EmptyCollection (Type ?u.8256319)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [K, u, V, v, inst, DivisionRing, K, inst_1, AddCommGroup, V, inst_2, Module, K, V, Basis, K, V, V] (during elaboration) for ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ∅ K V → V = ⊥",
     "context?": "A vector space with the empty set as basis is trivial.",
     "cmdErrors":
     ["failed to synthesize\n  EmptyCollection (Type ?u.1864)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "failed to synthesize\n  Bot (Type v)\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text":
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → IsTrivial K V",
     "elabError":
     "unknown identifier 'IsTrivial' ; identifiers [K, u, V, v, inst, DivisionRing, K, inst_1, AddCommGroup, V, inst_2, Module, K, V, Basis, Set, V, K, V, IsTrivial, K, V] (during elaboration) for ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → IsTrivial K V",
     "context?": "A vector space with the empty set as basis is trivial.",
     "cmdErrors":
     ["function expected at\n  IsTrivial\nterm has type\n  ?m.3595"]}}]],
 "elaborated-prompts":
 [{"theorem": "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
     "∀ {p : ℕ}, Nat.Prime p ↔ p = 2 ∨ Odd p",
     "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
     "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
     "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p ↔ p = 2 ∨ Odd p",
    "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
    "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
    "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p"]},
  {"theorem": "Nat.Prime 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3"], ["Nat.minFac 3 = 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Nat.Prime 3", "Nat.Prime 3", "Nat.minFac 3 = 3", "Nat.Prime 3"]},
  {"theorem": "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | p.Prime ∧ p % 2 = 1}",
    "{p | p.Prime ∧ p % 2 = 1}.Infinite",
    "{p | p.Prime ∧ p % 2 = 1}.Infinite",
    "Set.Infinite {p | p.Prime ∧ p % 2 = 1}",
    "Set.Infinite {p | p.Prime ∧ p % 2 = 1}"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], FiniteDimensional.finrank K V = 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], FiniteDimensional.finrank K V = 2"]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K"],
    ["{K : Type u} → [inst : Field K] → DivisionRing K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "∀ (n : ℕ), ∃ m, n.succ = m",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ m, n.succ = m",
     "∀ (n : ℕ), ∃ m, n.succ = m",
     "∀ (n : ℕ), ∃ m, m = n.succ",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n.succ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ (m : ℕ), n.succ = m",
    "∀ (n : ℕ), ∃ m : ℕ, n.succ = m",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n.succ",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n.succ"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ?m.93208 μ s = 0 → MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ?m.93208 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ?m.92393 μ s = 0 → MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α),\n  ∀ s : Set α, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α),\n  (∀ (s : Set α), ↑↑μ s = 0 → MeasurableSet s)"]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
     "∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n",
     "∀ (p : ℕ), Nat.Prime p → ¬IsSquare p",
     "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
     "∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, p.Prime → ¬IsSquare p",
    "∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n",
    "∀ (p : ℕ), Nat.Prime p → ¬IsSquare p",
    "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
    "∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n"]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"]},
  {"theorem":
   "∀ {a b : ℕ} {c d x y z w : ℕ},\n  (∃ a₁ b₁ c₁ d₁, a = a₁ ^ 2 + b₁ ^ 2 + c₁ ^ 2 + d₁ ^ 2) →\n    (∃ x₁ y₁ z₁ w₁, b = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b : ℕ} {c d x y z w : ℕ},\n  (∃ a₁ b₁ c₁ d₁, a = a₁ ^ 2 + b₁ ^ 2 + c₁ ^ 2 + d₁ ^ 2) →\n    (∃ x₁ y₁ z₁ w₁, b = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["∀ (a b c d x y z w : ℕ),\n  ∃ p q r s,\n    a = p ^ 2 + q ^ 2 →\n      b = r ^ 2 + s ^ 2 →\n        x = p * r - q * s → y = p * s + q * r → c = x ^ 2 + y ^ 2 → d = z ^ 2 + w ^ 2 → ∃ m n, c * d = m ^ 2 + n ^ 2"],
    ["∀ {a b c d x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = c ^ 2 + d ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"],
    ["∀ (a b : ℕ),\n  ℕ →\n    ℕ →\n      ∀ (x y z w : ℕ),\n        a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n          b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["∀ (a b : ℕ),\n  ℕ →\n    ℕ →\n      ℕ →\n        ℕ →\n          ℕ →\n            ℕ →\n              ∃ r s t u,\n                a = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 →\n                  b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 → ∃ v w x y, a * b = v ^ 2 + w ^ 2 + x ^ 2 + y ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a b c d x y z w : ℕ),\n  ∃ (p q r s : ℕ),\n    (a = p ^ 2 + q ^ 2) → (b = r ^ 2 + s ^ 2) → (x = p * r - q * s) → (y = p * s + q * r) →\n      c = x ^ 2 + y ^ 2 → d = z ^ 2 + w ^ 2 → ∃ (m n : ℕ), c * d = m ^ 2 + n ^ 2",
    "∀ {a b c d x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = c ^ 2 + d ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  (a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → (b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ (r s t u : ℕ), a = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 → b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 →\n    ∃ (v w x y : ℕ), a * b = v ^ 2 + w ^ 2 + x ^ 2 + y ^ 2",
    "∀ {a b c d x y z w : ℕ},\n  (∃ a₁ b₁ c₁ d₁, a = a₁ ^ 2 + b₁ ^ 2 + c₁ ^ 2 + d₁ ^ 2) →\n    (∃ x₁ y₁ z₁ w₁, b = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2) →\n      ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]},
  {"theorem": "¬∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["¬∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
     "¬∃ p q, p ≠ q ∧ Nat.Prime p ∧ Nat.Prime q ∧ p + q = 6",
     "¬∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
     "¬∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6"],
    ["¬∃ p q, p ≠ q ∧ Nat.Prime p ∧ Nat.Prime q ∧ 6 = p + q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), p ≠ q ∧ Nat.Prime p ∧ Nat.Prime q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), p ≠ q ∧ Nat.Prime p ∧ Nat.Prime q ∧ 6 = p + q",
    "¬∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6"]},
  {"theorem": "∀ (m : ℤ), ¬Irrational ↑m",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (m : ℤ), ¬Irrational ↑m",
     "∀ (m : ℤ), ¬Irrational ↑m",
     "∀ (m : ℤ), ¬Irrational ↑m",
     "∀ (m : ℤ), ¬Irrational ↑m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (m : ℤ), ¬Irrational ↑m",
    "∀ (m : ℤ), ¬ Irrational ↑m",
    "∀ (m : ℤ), ¬ Irrational ↑m",
    "∀ (m : ℤ), ¬Irrational ↑m"]},
  {"theorem": "∀ {R : Type u} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1"],
    ["∀ {R : Type u} [inst : Ring R], IsUnit 0",
     "∀ {R : Type u} [inst : Ring R], IsUnit 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], IsUnit (0 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (0 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)"]},
  {"theorem": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H"]},
  {"theorem": "∀ (m n : ℕ), m + n = m + n",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups": [["∀ (m n : ℕ), m + n = m + n"]],
   "correct": null,
   "comments": "",
   "all-elabs": ["∀ (m n : ℕ), m + n = m + n"]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)"]},
  {"theorem": "Nat.Prime 7",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups":
   [["Nat.Prime 7",
     "Nat.Prime 7",
     "Nat.Prime 7",
     "Nat.Prime 7",
     "Nat.Prime 7"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7"]},
  {"theorem":
   "3 = (List.filter (fun x => decide (Nat.Prime x)) (List.range 8)).length",
   "some-correct": null,
   "prompt": "There are `3` prime numbers below `8`.",
   "groups":
   [["3 = (List.filter (fun x => decide (Nat.Prime x)) (List.range 8)).length"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(3 : ℕ) = (List.filter (fun x => decide (Nat.Prime x)) (List.range 8)).length"]},
  {"theorem": "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, s.Finite → ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u}, ∀ s : Finset α, ∅ ⊆ s",
    "∀ {α : Type u}, ∀ {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u}, ∀ (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u}, ∀ {s : Finset α}, ∅ ⊆ s"]},
  {"theorem": "∀ {α : Type u} {s : Set α}, Infinite ↑s → ∃ t, ↑t ⊆ s",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, Infinite ↑s → ∃ t, ↑t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Infinite ↑s → ∃ t, ↑t ⊆ s"],
    ["∀ {α : Type u} {s : Set α}, s.Infinite → ∃ t, ↑t ⊆ s",
     "∀ {α : Type u} {s : Set α}, s.Infinite → ∃ t, ↑t ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Finset α), ↑t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Infinite s → ∃ (t : Finset α), ↑t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Finset α), ↑t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Infinite s → ∃ (t : Finset α), ↑t ⊆ s"]},
  {"theorem": "{R : Type u_1} → [inst : CommRing R] → Monoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u_1} → [inst : CommRing R] → Monoid R",
     "{R : Type u_1} → [inst : CommRing R] → Monoid R"],
    ["(R : Type ?u.7816763) → [inst : CommRing R] → Monoid R",
     "(R : Type ?u.7816763) → [inst : CommRing R] → Monoid R"],
    ["{R : Type u_3} → [inst : CommRing R] → Monoid R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ R [inst : CommRing R], Monoid R",
    "∀ {R : Type u_3} [inst : CommRing R], Monoid R",
    "∀ R [inst : CommRing R], Monoid R",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R"]},
  {"theorem": "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b"],
    ["∀ (n : ℕ), n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b"],
    ["∀ (n : ℕ), Odd n → ∃ a b, n = a + b ∧ a ≠ b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), Odd n → ∃ (a b : ℕ), a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ (a b : ℕ), a ≠ b ∧ n = a + b",
    "∀ (n : ℕ), Odd n → ∃ (a b : ℕ), n = a + b ∧ a ≠ b",
    "∀ n : ℕ, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ (n : ℕ), Odd n → ∃ (a b : ℕ), a ≠ b ∧ n = a + b"]},
  {"theorem": "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1"],
    ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"],
    ["∀ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder (0 : G)",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)"]},
  {"theorem": "∀ {n : ℤ}, Even n → Even (n ^ 2)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ {n : ℤ}, Even n → Even (n ^ 2)",
     "∀ {n : ℤ}, Even n → Even (n ^ 2)",
     "∀ {n : ℤ}, Even n → Even (n ^ 2)"],
    ["∀ (n : ℤ), Even n → Even (n * n)", "∀ {n : ℤ}, Even n → Even (n * n)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℤ}, Even n → Even (n ^ 2)",
    "∀ (n : ℤ), Even n → Even (n * n)",
    "∀ {n : ℤ}, Even n → Even (n ^ 2)",
    "∀ {n : ℤ}, Even n → Even (n * n)",
    "∀ {n : ℤ}, Even n → Even (n ^ 2)"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R",
     "∀ {R : Type u} [inst : CommRing R] (inst : DivisionRing R), IsField R",
     "∀ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R"],
    ["∀ {R : Type u} [inst : CommSemiring R], IsDomain R → IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommSemiring R], IsDomain R → IsField R",
    "∀ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R",
    "∀ {R : Type u} [inst : CommRing R] (inst : DivisionRing R), IsField R",
    "∀ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R"]},
  {"theorem": "id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["id 1 = 1",
     "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
     "∀ {α : Type u_1} [inst : MulOneClass α], id 1 = 1",
     "∀ {M : Type u_1} [inst : MulOneClass M], id 1 = 1",
     "∀ {M : Type u_1} [inst : MulOneClass M], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["theorem image_of_identity_under_id : id 1 = 1",
    "∀ {α : Type u} [inst : MulOneClass α], id 1 = (1 : α)",
    "∀ {α : Type u_1} [inst : MulOneClass α], id 1 = (1 : α)",
    "∀ {M : Type u_1} [inst : MulOneClass M], id 1 = 1",
    "∀ {M : Type u_1} [inst : MulOneClass M], id 1 = 1"]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u_1} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u}, ∀ (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u_1} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u}, ∀ x : α, Function.IsFixedPt id x",
    "∀ {α : Type u}, ∀ x : α, Function.IsFixedPt id x"]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]},
  {"theorem": "∀ {G : Type u} [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G"],
    ["∀ {G : Type u_1} [inst : Group G], Nonempty G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ (G : Type u) [inst : Group G], Nonempty G"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] (x : ?m.8193998), IsConnected (connectedComponent x)"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace ↑(connectedComponent x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), ConnectedSpace (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ x, IsConnected (connectedComponent x)"]},
  {"theorem": "∃ I, I.IsMaximal",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["∃ I, I.IsMaximal",
     "∃ I, I.IsMaximal",
     "∃ M, M.IsMaximal",
     "∃ M, M.IsMaximal"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ (I : Ideal ℤ), I.IsMaximal ",
    "∃ I, Ideal.IsMaximal I",
    "∃ M, Ideal.IsMaximal M",
    "∃ (M : Ideal ℤ), Ideal.IsMaximal M"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5"]}],
 "elaborated": 36}