{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "prompt-examples":
 {"sequence":
  [{"embedSearch": {"penalty": 1, "n": 10, "descField": "docString"}},
   {"embedSearch": {"penalty": 1, "n": 2, "descField": "concise-description"}},
   {"embedSearch": {"penalty": 1, "n": 2, "descField": "description"}},
   {"moogle":
    {"preferDocs": true,
     "n": 2,
     "descFields": ["concise-description", "description"]}}]},
 "number-similar-sentences":
 "docString:10-concise-description:2-description:2-moogle:2",
 "failures":
 [[{"parsed":
    {"text":
     "∀ {𝕜 : Type u} {E : Type v} [inst : Field 𝕜] [inst_1 : Module 𝕜 E] [inst_2 : FiniteDimensional 𝕜 E],\n  Dimension 𝕜 E = 2 → FiniteDimensional 𝕜 E",
     "elabError":
     "failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [𝕜, u, E, v, inst, Field, 𝕜, inst_1, Module, 𝕜, E, inst_2, FiniteDimensional, 𝕜, E, Dimension, 𝕜, E, FiniteDimensional, 𝕜, E] (during elaboration) for ∀ {𝕜 : Type u} {E : Type v} [inst : Field 𝕜] [inst_1 : Module 𝕜 E] [inst_2 : FiniteDimensional 𝕜 E],\n  Dimension 𝕜 E = 2 → FiniteDimensional 𝕜 E",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "unused universe parameter 'v'"]}},
   {"parsed":
    {"text":
     "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Field 𝕜] [inst_1 : Module 𝕜 E], Dim 𝕜 E = 2 → FiniteDimensional 𝕜 E",
     "elabError":
     "failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [𝕜, u_1, E, u_2, inst, Field, 𝕜, inst_1, Module, 𝕜, E, Dim, 𝕜, E, FiniteDimensional, 𝕜, E] (during elaboration) for ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Field 𝕜] [inst_1 : Module 𝕜 E], Dim 𝕜 E = 2 → FiniteDimensional 𝕜 E",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "unused universe parameter 'u_2'"]}},
   {"parsed":
    {"text":
     "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : VectorSpace K V], Dimension K V = 2 → FiniteDimensional K V",
     "elabError":
     "unknown identifier 'VectorSpace' ; identifiers [K, u, V, v, inst, Field, K, inst_1, VectorSpace, K, V, Dimension, K, V, FiniteDimensional, K, V] (during elaboration) for ∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : VectorSpace K V], Dimension K V = 2 → FiniteDimensional K V",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["invalid binder annotation, type is not a class instance\n  ?m.22\nuse the command `set_option checkBinderAnnotations false` to disable the check",
      "function expected at\n  VectorSpace\nterm has type\n  ?m.11",
      "unused universe parameter 'v'"]}},
   {"parsed":
    {"text":
     "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E],\n  Dimension 𝕜 E = 2 → FiniteDimensional 𝕜 E",
     "elabError":
     "unknown identifier 'Dimension' ; identifiers [𝕜, u_1, E, u_2, inst, Field, 𝕜, inst_1, AddCommGroup, E, inst_2, Module, 𝕜, E, Dimension, 𝕜, E, FiniteDimensional, 𝕜, E] (during elaboration) for ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E],\n  Dimension 𝕜 E = 2 → FiniteDimensional 𝕜 E",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["function expected at\n  Dimension\nterm has type\n  ?m.813"]}},
   {"parsed":
    {"text":
     "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Field 𝕜] [inst_1 : Module 𝕜 E], FiniteDimensional 𝕜 E → FiniteDimensional.finrank 𝕜 E = 2",
     "elabError":
     "failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [𝕜, u_1, E, u_2, inst, Field, 𝕜, inst_1, Module, 𝕜, E, FiniteDimensional, 𝕜, E, FiniteDimensional.finrank, 𝕜, E] (during elaboration) for ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Field 𝕜] [inst_1 : Module 𝕜 E], FiniteDimensional 𝕜 E → FiniteDimensional.finrank 𝕜 E = 2",
     "context?": "If a space has dimension `2` then it is finite dimensional.",
     "cmdErrors":
     ["failed to synthesize\n  AddCommMonoid E\nAdditional diagnostic information may be available using the `set_option diagnostics true` command.",
      "unused universe parameter 'u_2'"]}}],
  [{"parsed":
    {"text": "∀ (m n : ℕ), m + n ∈ ℕ",
     "elabError":
     "failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for ∀ (m n : ℕ), m + n ∈ ℕ",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "∀ (m n : ℕ), m + n ∈ ℕ",
     "elabError":
     "failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for ∀ (m n : ℕ), m + n ∈ ℕ",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "∀ (a b : ℕ), a + b ∈ ℕ",
     "elabError":
     "failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [a, b, a, b] (during elaboration) for ∀ (a b : ℕ), a + b ∈ ℕ",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "∀ (m n : ℕ), m + n ∈ ℕ",
     "elabError":
     "failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for ∀ (m n : ℕ), m + n ∈ ℕ",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}},
   {"parsed":
    {"text": "∀ (m n : ℕ), m + n ∈ ℕ",
     "elabError":
     "failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command. ; identifiers [m, n, m, n] (during elaboration) for ∀ (m n : ℕ), m + n ∈ ℕ",
     "context?": "The sum of two natural numbers is a natural number.",
     "cmdErrors":
     ["failed to synthesize\n  Membership ℕ Type\nAdditional diagnostic information may be available using the `set_option diagnostics true` command."]}}],
  [{"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow.card = 3)",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}},
   {"unparsed":
    {"text": "(8.primesBelow).card = 3",
     "parseError": "<input>:1:3: expected ')', ',' or ':'",
     "context?": "There are `3` prime numbers below `8`."}}],
  [{"parsed":
    {"text":
     "∀ (F : Type u_1) [inst : Field F], ¬IsFiniteField F ∧ F.card = 10",
     "elabError":
     "unknown identifier 'IsFiniteField' ; identifiers [F, u_1, inst, Field, F, IsFiniteField, F, F.card] (during elaboration) for ∀ (F : Type u_1) [inst : Field F], ¬IsFiniteField F ∧ F.card = 10",
     "context?": "There is no field of order `10`.",
     "cmdErrors":
     ["invalid field notation, type is not of the form (C ...) where C is a constant\n  F\nhas type\n  Type u_1",
      "function expected at\n  IsFiniteField\nterm has type\n  ?m.9"]}},
   {"parsed":
    {"text": "∀ (F : Type u_1) [inst : Field F], fintype.card F ≠ 10",
     "elabError":
     "unknown identifier 'fintype.card' ; identifiers [F, u_1, inst, Field, F, fintype.card, F] (during elaboration) for ∀ (F : Type u_1) [inst : Field F], fintype.card F ≠ 10",
     "context?": "There is no field of order `10`.",
     "cmdErrors": ["unknown identifier 'fintype.card'"]}},
   {"unparsed":
    {"text": "¬∃ (F : Type u) [inst : Field F], Cardinal.mk F = 10",
     "parseError": "<input>:1:16: expected ','",
     "context?": "There is no field of order `10`."}},
   {"parsed":
    {"text":
     "∀ (F : Type u) [inst : FiniteField F] (h : Cardinal.mk F = 10), False",
     "elabError":
     "unknown identifier 'FiniteField' ; identifiers [F, u, inst, FiniteField, F, h, Cardinal.mk, F, False] (during elaboration) for ∀ (F : Type u) [inst : FiniteField F] (h : Cardinal.mk F = 10), False",
     "context?": "There is no field of order `10`.",
     "cmdErrors":
     ["invalid binder annotation, type is not a class instance\n  ?m.12\nuse the command `set_option checkBinderAnnotations false` to disable the check",
      "function expected at\n  FiniteField\nterm has type\n  ?m.6",
      "unused universe parameter 'u'"]}},
   {"parsed":
    {"text": "∀ (F : Type u_1) [inst : Field F], ¬(fintype.card F = 10)",
     "elabError":
     "unknown identifier 'fintype.card' ; identifiers [F, u_1, inst, Field, F, fintype.card, F] (during elaboration) for ∀ (F : Type u_1) [inst : Field F], ¬(fintype.card F = 10)",
     "context?": "There is no field of order `10`.",
     "cmdErrors": ["unknown identifier 'fintype.card'"]}}]],
 "elaborated-prompts":
 [{"theorem": "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
     "∀ (n : ℕ), Nat.Prime n → n = 2 ∨ Odd n"],
    ["∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
     "∀ {p : ℕ}, Nat.Prime p ↔ p = 2 ∨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p ↔ p = 2 ∨ Odd p",
    "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ (n : ℕ), Nat.Prime n → n = 2 ∨ Odd n"]},
  {"theorem": "Infinite { n // Odd n }",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["Infinite { n // Odd n }"],
    ["∃ᶠ (n : ℕ) in Filter.atTop, Odd n"],
    ["Infinite { n // n % 2 = 1 }"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "Infinite {n : ℕ // n % 2 = 1}",
    "Infinite {n : ℕ // Odd n}"]},
  {"theorem": "Nat.Prime 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups": [["Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3"]],
   "correct": null,
   "comments": "",
   "all-elabs": ["Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3", "Nat.Prime 3"]},
  {"theorem": "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite",
     "{p | Nat.Prime p ∧ p % 2 = 1}.Infinite"],
    ["∃ n ≥ 3, ∃ p, Nat.Prime p ∧ p % 2 = 1 ∧ p > n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | p.Prime ∧ p % 2 = 1}",
    "{p | p.Prime ∧ p % 2 = 1}.Infinite",
    "{p | p.Prime ∧ p % 2 = 1}.Infinite",
    "∃ (n : ℕ), n ≥ 3 ∧ ∃ (p : ℕ), p.Prime ∧ p % 2 = 1 ∧ p > n",
    "Set.Infinite {p | p.Prime ∧ p % 2 = 1}"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K"]},
  {"theorem": "∀ (n : ℕ), ∃ m, m = n.succ",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ m, m = n.succ",
     "∀ (n : ℕ), ∃ m, n.succ = m",
     "∀ (n : ℕ), ∃ m, n.succ = m",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, n.succ = m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ (m : ℕ), m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, n.succ = m",
    "∀ (n : ℕ), ∃ (m : ℕ), n.succ = m",
    "∀ (n : ℕ), ∃ (m : ℕ), m = n + 1",
    "∀ (n : ℕ), ∃ (m : ℕ), n.succ = m"]},
  {"theorem": "∀ (n : ℕ), n < n.succ",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MetricSpace α] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (s : Set α),\n  MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MetricSpace α] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (s : Set α),\n  MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α] (s : Set α),\n  ?m.257738 s = 0 → MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α] (s : Set α),\n  ?m.257738 s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ?m.257052 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) [inst_1 : MeasureTheory.SigmaFinite μ]\n  {s : Set α}, ?m.257224 μ = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ?m.257396 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\n  {s : Set α}, ?m.257566 = 0 → MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α] (μ : MeasureTheory.Measure α),\n  (∀ (s : Set α), ↑↑μ s = 0 → MeasurableSet s)",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) [inst_1 : MeasureTheory.SigmaFinite μ]\n  {s : Set α}, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ]\n  {s : Set α}, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [h : MeasurableSpace α] [self : OpensMeasurableSpace α],\n  ∀ (s : Set α), ↑↑(borel α) s = 0 → MeasurableSet s"]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
     "∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n",
     "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
     "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
     "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
    "∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n",
    "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p",
    "∀ {p : ℕ}, p.Prime → ¬IsSquare p",
    "∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p"]},
  {"theorem": "∀ (p : ℕ), Nat.Prime p → Odd p → p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ (p : ℕ), Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Odd p → Nat.Prime p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (p : ℕ), Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ}, Odd p → Nat.Prime p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"]},
  {"theorem":
   "∀ {a b c d x y z w : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = c ^ 2 + d ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b c d x y z w : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = c ^ 2 + d ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["∀ (a b : ℕ),\n  ℕ →\n    ℕ →\n      ∀ (x y : ℕ),\n        ℕ →\n          ℕ →\n            ∃ m n p q,\n              a = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 →\n                b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 →\n                  x = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 → y = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2"],
    ["∀ {a b : ℕ} {c d x y z w : ℕ},\n  (∃ a₁ b₁ c₁ d₁, a = a₁ ^ 2 + b₁ ^ 2 + c₁ ^ 2 + d₁ ^ 2) →\n    (∃ x₁ y₁ z₁ w₁, b = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],
    ["∀ (a b c d w x : ℕ),\n  ℕ →\n    ℕ →\n      (∃ u v, a = u ^ 2 + v ^ 2) →\n        (∃ m n, b = m ^ 2 + n ^ 2) → ∃ r s, c = r ^ 2 + s ^ 2 ∧ d = w ^ 2 + x ^ 2 ∧ a * b = c ^ 2 + d ^ 2"],
    ["∀ (a b c d x y z w : ℕ),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = ∃ r s t u, r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a b c d x y z w : ℕ),\n  ∃ (m n p q : ℕ),\n    a = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 → b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 →\n      x = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 → y = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 →\n        ∃ (r s : ℕ), a * b = r ^ 2 + s ^ 2",
    "∀ {a b c d x y z w : ℕ}, (∃ a₁ b₁ c₁ d₁, a = a₁ ^ 2 + b₁ ^ 2 + c₁ ^ 2 + d₁ ^ 2) → (∃ x₁ y₁ z₁ w₁, b = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2) → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "∀ (a b c d w x y z : ℕ), (∃ u v, a = u ^ 2 + v ^ 2) → (∃ m n, b = m ^ 2 + n ^ 2) →\n  ∃ r s, c = r ^ 2 + s ^ 2 ∧ d = w ^ 2 + x ^ 2 ∧ a * b = c ^ 2 + d ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) =\n    ∃ (r s t u : ℕ), r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "∀ {a b c d x y z w : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = c ^ 2 + d ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]},
  {"theorem": "∀ (p q : ℕ), Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["∀ (p q : ℕ), Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
     "¬∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
     "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6"],
    ["∀ (p q : ℕ), Nat.Prime p → Nat.Prime q → p ≠ q → 6 ≠ p + q"],
    ["¬∃ p q, Nat.Prime p → Nat.Prime q → p ≠ q → 6 = p + q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ p q : ℕ, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ p q : ℕ, Nat.Prime p → Nat.Prime q → p ≠ q → 6 = p + q",
    "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
    "∀ p q : ℕ, Nat.Prime p → Nat.Prime q → p ≠ q → 6 ≠ p + q"]},
  {"theorem": "∀ (m : ℤ), ¬Irrational ↑m",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (m : ℤ), ¬Irrational ↑m",
     "∀ (m : ℤ), ¬Irrational ↑m",
     "∀ (m : ℤ), ¬Irrational ↑m",
     "∀ (m : ℤ), ¬Irrational ↑m",
     "∀ (n : ℤ), ¬Irrational ↑n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (m : ℤ), ¬Irrational ↑m",
    "∀ (m : ℤ), ¬Irrational ↑m",
    "∀ (m : ℤ), ¬Irrational ↑m",
    "∀ (m : ℤ), ¬ Irrational (m : ℝ)",
    "∀ (n : ℤ), ¬ Irrational ↑n"]},
  {"theorem": "∀ {R : Type u} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)"]},
  {"theorem": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H"]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)"]},
  {"theorem": "Nat.Prime 7",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups": [["Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7"]],
   "correct": null,
   "comments": "",
   "all-elabs": ["Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7", "Nat.Prime 7"]},
  {"theorem": "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s"],
    ["∀ {α : Type u}, ∅.Finite → ∀ (s : Finset α), ∅ ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u}, ∀ (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u}, Set.Finite ∅ → ∀ (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u}, ∀ (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u}, ∀ (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u}, ∀ {s : Finset α}, ∅ ⊆ s"]},
  {"theorem": "∀ {α : Type u} {s : Set α} [inst : Infinite ↑s], ∃ t, ↑t ⊆ s",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α} [inst : Infinite ↑s], ∃ t, ↑t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Infinite ↑s → ∃ t, ↑t ⊆ s"],
    ["∀ {α : Type u} {s : Set α}, s.Infinite → ∃ t, ↑t ⊆ s",
     "∀ {α : Type u} {s : Set α}, s.Infinite → ∃ t, ↑t ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Finset α), ↑t ⊆ s",
    "∀ {α : Type u} {s : Set α} [inst : Infinite s], ∃ (t : Finset α), ↑t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Infinite s → ∃ (t : Finset α), ↑t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Finset α), ↑t ⊆ s"]},
  {"theorem": "{R : Type u_1} → [inst : CommRing R] → Monoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u_1} → [inst : CommRing R] → Monoid R",
     "{R : Type u_1} → [inst : CommRing R] → Monoid R"],
    ["(R : Type ?u.5349148) → [inst : CommRing R] → Monoid R",
     "(R : Type ?u.5349148) → [inst : CommRing R] → Monoid R"],
    ["{R : Type u_3} → [inst : CommRing R] → Monoid R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ R [inst : CommRing R], Monoid R",
    "∀ {R : Type u_3} [inst : CommRing R], Monoid R",
    "∀ R [inst : CommRing R], Monoid R",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R"]},
  {"theorem": "∀ (n : ℕ), Odd n → ∃ a b, n = a + b ∧ a ≠ b",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ (n : ℕ), Odd n → ∃ a b, n = a + b ∧ a ≠ b",
     "∀ (n : ℕ), Odd n → ∃ a b, n = a + b ∧ a ≠ b",
     "∀ {n : ℕ}, Odd n → ∃ x y, n = x + y ∧ x ≠ y",
     "∀ (n : ℕ), Odd n → ∃ a b, n = a + b ∧ a ≠ b"],
    ["∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), Odd n → ∃ (a b : ℕ), n = a + b ∧ a ≠ b",
    "∀ (n : ℕ), Odd n → ∃ (a b : ℕ), n = a + b ∧ a ≠ b",
    "∀ {n : ℕ}, Odd n → ∃ x y, n = x + y ∧ x ≠ y",
    "∀ (n : ℕ), Odd n → ∃ (a b : ℕ), a ≠ b ∧ n = a + b",
    "∀ (n : ℕ), Odd n → ∃ (a b : ℕ), n = a + b ∧ a ≠ b"]},
  {"theorem": "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1"],
    ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)"]},
  {"theorem": "∀ {n : ℤ}, Even n → Even (n ^ 2)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ {n : ℤ}, Even n → Even (n ^ 2)",
     "∀ {n : ℤ}, Even n → Even (n ^ 2)",
     "∀ {n : ℤ}, Even n → Even (n ^ 2)"],
    ["∀ {n : ℤ}, Even n → Even (n * n)", "∀ {n : ℤ}, Even n → Even (n * n)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℤ}, Even n → Even (n * n)",
    "∀ {n : ℤ}, Even n → Even (n ^ 2)",
    "∀ {n : ℤ}, Even n → Even (n * n)",
    "∀ {n : ℤ}, Even n → Even (n ^ 2)",
    "∀ {n : ℤ}, Even n → Even (n ^ 2)"]},
  {"theorem": "∀ {R : Type u} [inst : CommRing R], IsDomain R → IsField R",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R], IsDomain R → IsField R",
     "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], IsField R"],
    ["∀ {R : Type u} [inst : CommRing R] [inst : IsDomain R] [inst : DivisionRing R], IsField R"],
    ["∀ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] [inst : DivisionRing R], IsField R",
    "∀ {R : Type u} [inst : CommRing R] (inst_1 : IsDomain R), IsField R",
    "∀ {R : Type u} [inst : CommRing R] [inst : IsDomain R] [inst : DivisionRing R], IsField R",
    "∀ (R : Type u) [inst : CommRing R] [inst : IsDomain R], IsField R"]},
  {"theorem": "∀ {R : Type u_1} [inst : MulOneClass R], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["∀ {R : Type u_1} [inst : MulOneClass R], id 1 = 1",
     "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
     "∀ {M : Type u_1} [inst : MulOneClass M], id 1 = 1",
     "∀ {A : Type u_1} [inst : MulOneClass A], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : MulOneClass R], id 1 = (1 : R)",
    "∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1",
    "∀ {M : Type u_1} [inst : MulOneClass M], (id 1) = (1 : M)",
    "∀ {A : Type u_1} [inst : MulOneClass A], id 1 = (1 : A)"]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x"],
    ["∀ {α : Type u} (inst : TopologicalSpace α) (x : α), ContinuousAt id x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u}, ∀ (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (inst : TopologicalSpace α) (x : α), ContinuousAt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x"]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0"]},
  {"theorem": "∀ (G : Type u) [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G"],
    ["∀ (G : Type), Nonempty (Group G)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (G : Type u) [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ G : Type, Nonempty (Group G)"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace ↑(connectedComponent x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), ConnectedSpace (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)"]},
  {"theorem": "∃ M, M.IsMaximal",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups": [["∃ M, M.IsMaximal", "∃ M, M.IsMaximal", "∃ I, I.IsMaximal"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ M, Ideal.IsMaximal M",
    "∃ M, Ideal.IsMaximal M",
    "∃ (I : Ideal ℤ), Ideal.IsMaximal I"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Basis ∅ K V → V = ⊥",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Basis ∅ K V → V = ⊥"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → V = ⊥"]}],
 "elaborated": 36}