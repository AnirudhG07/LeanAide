{"theorem":"¬LocallyCompactSpace ℚ","text":"Show that the rationals `ℚ` are not locally compact.","result":true,"gps":[["¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ","¬LocallyCompactSpace ℚ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ ","¬LocallyCompactSpace ℚ "]}
{"theorem":"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a","text":"Show that if `X` has a countable dense subset, every collection of disjoint open sets in `X` is countable.","result":true,"gps":[["∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a","∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a","∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a"],["∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a","∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a ","∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a ","forall {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a ","∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a ","∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → Set.Countable a "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)","text":"Show that if `X` is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s →\n    IsClosed t → Disjoint s t → ∃ U₁ U₂, IsOpen U₁ ∧ IsOpen U₂ ∧ s ⊆ U₁ ∧ t ⊆ U₂ ∧ Disjoint (closure U₁) (closure U₂)","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (A B : Set α),\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint (closure U) (closure V)","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ U V, IsOpen U ∧ IsOpen V ∧ s ⊆ U ∧ t ⊆ V ∧ Disjoint (closure U) (closure V)","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ U₁ U₂, IsOpen U₁ ∧ IsOpen U₂ ∧ s ⊆ U₁ ∧ t ⊆ U₂ ∧ Disjoint (closure U₁) (closure U₂) ","forall {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (A B : Set α),\n  IsClosed A → IsClosed B → Disjoint A B → ∃ U V, IsOpen U ∧ IsOpen V ∧ A ⊆ U ∧ B ⊆ V ∧ Disjoint (closure U) (closure V) ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ U V, IsOpen U ∧ IsOpen V ∧ s ⊆ U ∧ t ⊆ V ∧ Disjoint (closure U) (closure V) ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] ⦃s t : Set α⦄,\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {s : Set α}, IsClosed s → NormalSpace { x // x ∈ s }","text":"Show that a closed subspace of a normal space is normal.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {s : Set α}, IsClosed s → NormalSpace { x // x ∈ s }","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {S : Set α}, IsClosed S → NormalSpace { x // x ∈ S }","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α), IsClosed s → NormalSpace { x // x ∈ s }","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s : Set α}, IsClosed s → NormalSpace { x // x ∈ s }","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] (A : Set α), IsClosed A → NormalSpace { x // x ∈ A }","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α), IsClosed s → NormalSpace { x // x ∈ s }","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α), IsClosed s → NormalSpace { x // x ∈ s }"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {s : Set α},\n  IsClosed s → NormalSpace {x // x ∈ s} ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] {S : Set α},\n  IsClosed S → NormalSpace { x // x ∈ S } ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace { x // x ∈ s } ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s : Set α},\n  IsClosed s → NormalSpace { x // x ∈ s } ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : NormalSpace α] (A : Set α),\n  IsClosed A → NormalSpace {x // x ∈ A} ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace { x // x ∈ s } ","∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace { x // x ∈ s } "]}
{"theorem":"∀ {α : Type u_1} {X_α : α → Type u_2} [inst : (a : α) → TopologicalSpace (X_α a)] [inst_1 : ∀ (a : α), Nonempty (X_α a)]\n  [inst_2 : RegularSpace ((a : α) → X_α a)] (a : α), RegularSpace (X_α a)","text":"Show that if `Π X_α` is regular, then so is `X_α`. Assume that each `X_α` is nonempty.","result":true,"gps":[["∀ {α : Type u_1} {X_α : α → Type u_2} [inst : (a : α) → TopologicalSpace (X_α a)] [inst_1 : ∀ (a : α), Nonempty (X_α a)]\n  [inst_2 : RegularSpace ((a : α) → X_α a)] (a : α), RegularSpace (X_α a)","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : RegularSpace ((i : ι) → X i)] (i : ι), RegularSpace (X i)"],["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), T2Space (X i)]\n  [inst_2 : Nonempty ι] [inst_3 : ∀ (i : ι), Nonempty (X i)] [inst_4 : RegularSpace ((i : ι) → X i)] (i : ι),\n  RegularSpace (X i)"],["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_2 : ∀ (i : ι), RegularSpace (X i)], RegularSpace ((i : ι) → X i)"],["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : ∀ (i : ι), T2Space (X i)] [inst_2 : TopologicalSpace.SecondCountableTopology ((i : ι) → X i)],\n  RegularSpace ((i : ι) → X i) → ∀ (i : ι), RegularSpace (X i)"],["∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : ∀ (i : ι), T2Space (X i)] [inst_2 : ∀ (i : ι), RegularSpace (X i)], RegularSpace ((i : ι) → X i)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst : (i : ι) → Nonempty (X i)] [inst_1 : (i : ι) → T2Space (X i)] [inst_2 : (i : ι) → RegularSpace (X i)],\n  RegularSpace ((i : ι) → X i) ","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] [inst : (i : ι) → Nonempty (X i)] [inst : (i : ι) → RegularSpace (X i)],\n  RegularSpace ((i : ι) → X i) ","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : ∀ (i : ι), TopologicalSpace (X i)] [inst : ∀ (i : ι), Nonempty (X i)]\n  [inst_1 : ∀ (i : ι), T2Space (X i)] [inst_2 : TopologicalSpace.SecondCountableTopology (Π i, X i)],\n  RegularSpace (Π i, X i) → ∀ (i : ι), RegularSpace (X i) ","∀ {α : Type u_1} {X_α : α → Type u_2} [inst : (a : α) → TopologicalSpace (X_α a)] [inst_1 : (∀ (a : α), Nonempty (X_α a))]\n  [inst_2 : RegularSpace ((a : α) → X_α a)], (a : α) → RegularSpace (X_α a) ","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : ∀ (i : ι), TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), T2Space (X i)]\n  [inst_2 : Nonempty ι] [inst_3 : ∀ (i : ι), Nonempty (X i)] [inst_4 : RegularSpace ((i : ι) → X i)],\n  ∀ (i : ι), RegularSpace (X i) ","forall {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst : (i : ι) → Nonempty (X i)] [inst_1 : RegularSpace ((i : ι) → X i)],\n  forall (i : ι), RegularSpace (X i) "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","text":"Show that every locally compact Hausdorff space is regular.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α], RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α], RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α "]}
{"theorem":"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A →\n    IsClosed B →\n      Disjoint A B → IsCompact A → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2980018 f x ∈ Set.Icc 0 1","text":"Let `X` be completely regular, let `A` and `B` be disjoint closed subsets of `X`. Show that if `A` is compact, there is a continuous function `f: X → [0, 1]` such that `f(A) = {0}` and `f(B) = {1}`.","result":true,"gps":[["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A →\n    IsClosed B →\n      Disjoint A B → IsCompact A → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2980018 f x ∈ Set.Icc 0 1"],["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] [inst_2 : T1Space X] {A B : Set X},\n  IsCompact A →\n    IsClosed B → Disjoint A B → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2963658 f x ∈ Set.Icc 0 1"],["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : LocallyCompactSpace X] {A B : Set X},\n  IsCompact A →\n    IsClosed A →\n      IsClosed B → Disjoint A B → ∃ f, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : X), ?m.2971849 f x ∈ Set.Icc 0 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] [inst_2 : T1Space X] {A B : Set X},\n  IsCompact A → IsClosed B → Disjoint A B → ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 ","∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T0Space X] [inst_2 : LocallyCompactSpace X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B → ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 ","∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NormalSpace X] {A B : Set X},\n  IsClosed A → IsClosed B → Disjoint A B → IsCompact A →\n    ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 "]}
{"theorem":"∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","text":"Prove that `-(-v) = v` for every `v ∈ V`.","result":true,"gps":[["∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","∀ {α : Type u_1} [inst : AddGroup α] (v : α), - -v = v","∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v","∀ {V : Type u_2} [inst : AddGroup V] (v : V), - -v = v","∀ {V : Type u_1} [inst : AddGroup V] (v : V), - -v = v"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","∀ {α : Type u_1} [inst : AddGroup α] (v : α), -(-v) = v ","forall {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v ","∀ {V : Type u_2} [inst : AddGroup V] (v : V), -(-v) = v ","∀ {V : Type u_1} [inst : AddGroup V] (v : V), -(-v) = v "]}
{"theorem":"∃ U,\n  (∀ (u v : ℝ × ℝ), u ∈ U → v ∈ U → u + v ∈ U) ∧\n    (∀ (u : ℝ × ℝ), u ∈ U → -u ∈ U) ∧ ¬∀ (a : ℝ) (u : ℝ × ℝ), u ∈ U → (a * u.fst, a * u.snd) ∈ U","text":"Give an example of a nonempty subset `U` of `ℝ^2` such that `U` is closed under addition and under taking additive inverses (meaning `-u ∈ U` whenever `u ∈ U`), but `U` is not a subspace of `ℝ^2`.","result":true,"gps":[["∃ U,\n  (∀ (u v : ℝ × ℝ), u ∈ U → v ∈ U → u + v ∈ U) ∧\n    (∀ (u : ℝ × ℝ), u ∈ U → -u ∈ U) ∧ ¬∀ (a : ℝ) (u : ℝ × ℝ), u ∈ U → (a * u.fst, a * u.snd) ∈ U"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["example : ∃ (U : Set (ℝ × ℝ)), (∀ (u v : ℝ × ℝ), u ∈ U → v ∈ U → u + v ∈ U) ∧ (∀ (u : ℝ × ℝ), u ∈ U → -u ∈ U) ∧ ¬(∀ (a : ℝ) (u : ℝ × ℝ), u ∈ U → (a * u.1, a * u.2) ∈ U) "]}
{"theorem":"{K : Type u} →\n  {V : Type v} →\n    [inst : Field K] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → {ι : Sort u_1} → (ι → Submodule K V) → Submodule K V","text":"Prove that the intersection of any collection of subspaces of `V` is a subspace of `V`.","result":true,"gps":[["{K : Type u} →\n  {V : Type v} →\n    [inst : Field K] →\n      [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → {ι : Sort u_1} → (ι → Submodule K V) → Submodule K V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Submodule K V), Submodule K V "]}
{"theorem":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v","text":"Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if `dim V = 1` and `T ∈ L(V, V)`, then there exists `a ∈ F` such that `T v = a v` for all `v ∈ V`.","result":true,"gps":[["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v"],["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V],\n  Module.rank K V = 1 → ∀ (f : V →ₗ[K] V), ∃ (a : K), ∀ (v : V), ↑f v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V ≤ 1 → ∀ (T : V →ₗ[K] V), ∃ a, ∀ (v : V), ↑T v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ (v : V), T v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ (a : K), ∀ (v : V), T v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (f : V →ₗ[K] V), ∃ (a : K), ∀ (v : V), ↑f v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ (v : V), T v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ (v : V), T v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ v : V, T v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Module.rank K V = 1 → ∃ a, ∀ (v : V), ↑f v = a • v ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ v : V, T v = a • v "]}
{"theorem":"∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = ↑Multiset.card (Polynomial.roots p) ↔ ∀ (a : R), Polynomial.rootMultiplicity a p ≤ 1","text":"Suppose `p ∈ P(ℂ)` has degree `m`. Prove that `p` has `m` distinct roots if and only if `p` and its derivative `p'` have no roots in common.","result":true,"gps":[["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = ↑Multiset.card (Polynomial.roots p) ↔ ∀ (a : R), Polynomial.rootMultiplicity a p ≤ 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {p : Polynomial R},\n  Polynomial.natDegree p = Multiset.card (Polynomial.roots p) ↔\n    ∀ (a : R), Polynomial.rootMultiplicity a p ≤ 1 ","∀ {p : Polynomial ℂ} {m : ℕ},\n  Polynomial.natDegree p = m →\n    (p ≠ 0 →\n       (∀ a, Polynomial.IsRoot p a ↔ Polynomial.IsRoot (↑Polynomial.derivative p) a → False) ↔\n         m = Multiset.card (Polynomial.roots p)) ","∀ {p : Polynomial ℂ},\n  Polynomial.natDegree p = Finset.card (Multiset.toFinset (Polynomial.roots p)) ↔\n  Multiset.Disjoint (Polynomial.roots p) (Polynomial.roots (↑Polynomial.derivative p)) ","∀ {m : ℕ} {p : Polynomial ℂ},\n  Polynomial.natDegree p = m →\n    ((∀ a : ℂ, Polynomial.rootMultiplicity a p ≤ 1) ↔\n     ∀ a : ℂ, ¬Polynomial.IsRoot p a ∨ ¬Polynomial.IsRoot (↑Polynomial.derivative p) a) "]}
{"theorem":"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ c, ↑T v = c • v) → ∃ c, ∀ (v : V), ↑T v = c • v","text":"Suppose `T ∈ L(V)` is such that every vector in `V` is an eigenvector of `T`. Prove that `T` is a scalar multiple of the identity operator.","result":true,"gps":[["∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ c, ↑T v = c • v) → ∃ c, ∀ (v : V), ↑T v = c • v"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ (c : K), Module.End.HasEigenvector T c v) → ∃ (c : K), T = c • LinearMap.id ","∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (h_eigvec : ∀ (v : V), v ≠ 0 → ∃ (μ : K), T v = μ • v),\n  ∃ (c : K), T = c • LinearMap.id ","∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), ∃ (c : K), T v = c • v) → (∃ (c : K), T = c • LinearMap.id) ","forall {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ c, T v = c • v) → (∃ c, T = c • (LinearMap.id : Module.End K V)) ","∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ (c : K), T v = c • v) → (∃ (c : K), ∀ (v : V), T v = c • v) ","∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {T : Module.End K V},\n  (∀ (v : V), v ≠ 0 → ∃ c, T v = c • v) → (∃ c, T = c • 1) "]}
{"theorem":"∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V] {T S : V →ₗ[𝕜] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank 𝕜 V →\n    (∀ (x : V) (μ : 𝕜), x ∈ Module.End.eigenspace S μ ↔ x ∈ Module.End.eigenspace T μ) →\n      LinearMap.comp S T = LinearMap.comp T S","text":"Suppose that `T ∈ L(V)` has `dim V` distinct eigenvalues and that `S ∈ L(V)` has the same eigenvectors as `T` (not necessarily with the same eigenvalues). Prove that `S T = T S`.","result":true,"gps":[["∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V] {T S : V →ₗ[𝕜] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank 𝕜 V →\n    (∀ (x : V) (μ : 𝕜), x ∈ Module.End.eigenspace S μ ↔ x ∈ Module.End.eigenspace T μ) →\n      LinearMap.comp S T = LinearMap.comp T S"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : FiniteDimensional 𝕜 V]\n  {T S : V →ₗ[𝕜] V},\n  Fintype.card (Module.End.Eigenvalues T) = FiniteDimensional.finrank 𝕜 V →\n    (∀ (x : V) (μ : 𝕜), x ∈ Module.End.eigenspace S μ ↔ x ∈ Module.End.eigenspace T μ) → S.comp T = T.comp S "]}
{"theorem":"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)","text":"Suppose `U` is a subspace of `V`. Prove that `U⊥ = {0}` if and only if `U = V`.","result":true,"gps":[["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V)"],["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, Uᗮ = ⊥ ↔ U = V","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, Uᗮ = ⊥ ↔ U = V"],["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → Uᗮ = ⊥ ↔ U = V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} ,\n  Uᗮ = ⊥ ↔ U = V ","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → Uᗮ = ⊥ ↔ U = V ","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ","∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E},\n  Uᗮ = ⊥ ↔ U = V "]}
{"theorem":"∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","text":"For all odd `n` show that `8 | n^2 - 1`.","result":true,"gps":[["∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall_odd_n_eight_divides_pow_minus_one : ∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ","∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ","forall {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ","forall_odd_n_8_dvd_n_squared_minus_one : ∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ","∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ","forall_odd_n_eight_divides_nsq_minus_one : ∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ","∀ {n : ℕ}, Odd n → 8 ∣ (n^2 - 1) ","∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ","∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) "]}
{"theorem":"IsSquare 2","text":"Show that 2 is divisible by `(1 + i)^2` in `ℤ[i]`.","result":true,"gps":[["IsSquare 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["IsSquare 2 "]}
