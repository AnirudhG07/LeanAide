{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["Every set is Lebesgue measurable.",
  "Every continuous function is uniformly continuous.",
  "There are `3` prime numbers below `8`.",
  "There is no field of order `10`."],
 "elaborated-prompts":
 [{"theorem": "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p"],
    ["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p"]},
  {"theorem": "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n"]},
  {"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≥ 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≥ 3",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≥ 3",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≥ 3",
     "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], Odd p → p ≥ 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ (p : ℕ), Nat.Prime p ∧ Odd p ∧ ∀ (q : ℕ), Nat.Prime q ∧ Odd q → p ≤ q ∧ p = 3",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≥ 3",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≥ 3",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≥ 3",
    "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], Odd p → p ≥ 3"]},
  {"theorem": "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "{K : Type u} → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "∀ (n : ℕ), ∃ s, n + 1 = s",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ s, n + 1 = s",
     "∀ (n : ℕ), ∃ s, s = n + 1",
     "∀ (n : ℕ), ∃ s, n + 1 = s",
     "∀ (n : ℕ), ∃ s, n + 1 = s",
     "∀ (n : ℕ), ∃ s, n + 1 = s",
     "∀ (n : ℕ), ∃ s, n + 1 = s",
     "∀ (n : ℕ), ∃ s, s = n + 1"],
    ["∀ (n : ℕ), ∃ s, n < s",
     "∀ (n : ℕ), ∃ s, n < s",
     "∀ (n : ℕ), ∃ m, n < m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ s, n < s",
    "∀ (n : ℕ), ∃ s, n + 1 = s",
    "∀ (n : ℕ), ∃ s, n < s",
    "∀ (n : ℕ), ∃ s, s = n + 1",
    "∀ (n : ℕ), ∃ m, n < m",
    "∀ (n : ℕ), ∃ s, n + 1 = s",
    "∀ (n : ℕ), ∃ s, n + 1 = s",
    "∀ (n : ℕ), ∃ s, n + 1 = s",
    "∀ (n : ℕ), ∃ s, n + 1 = s",
    "∀ (n : ℕ), ∃ s, s = n + 1"]},
  {"theorem": "∀ (n : ℕ), n < Nat.succ n",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n < Nat.succ n",
    "∀ n : ℕ, n < Nat.succ n",
    "∀ (n : ℕ), n < Nat.succ n",
    "∀ n : ℕ, n < Nat.succ n",
    "∀ n : ℕ, n < Nat.succ n",
    "∀ n : ℕ, n < Nat.succ n",
    "∀ n : ℕ, n < Nat.succ n",
    "∀ n : ℕ, n < Nat.succ n",
    "∀ n : ℕ, n < n.succ",
    "∀ n : ℕ, n < Nat.succ n"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ] (s : Set α),\n  ?m.453019 μ s = 0 → MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ] (s : Set α),\n  ?m.453019 μ s = 0 → MeasurableSet s",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ] (s : Set α),\n  ?m.453019 μ s = 0 → MeasurableSet s",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ] (s : Set α),\n  ?m.453019 μ s = 0 → MeasurableSet s",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ] (s : Set α),\n  ?m.453019 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] {s : Set α}\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ], ?m.453205 μ = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.IsComplete μ] (s : Set α),\n  ?m.452121 s = 0 → MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.IsComplete μ], ∀ s : Set α, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ], ∀ s : Set α, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ], ∀ s : Set α, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ], ∀ s : Set α, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  {s : Set α} (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ],\n  ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_3 : MeasureTheory.Measure.IsComplete μ], ∀ s : Set α, ↑↑μ s = 0 → MeasurableSet s"]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p"]},
  {"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2"],
    ["∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"]},
  {"theorem":
   "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ (a b c d x y z w : ℕ),\n  ∃ r s t u, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
     "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ (a b x y z w u v p q : ℕ),\n  ℕ →\n    ℕ →\n      a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n        b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 → ∃ m n o p, a * b = m ^ 2 + n ^ 2 + o ^ 2 + p ^ 2",
     "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ (a b c d x y z w : ℕ),\n  ∃ r s t u, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
     "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ (a b c d w x y z : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2"],
    ["∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 * x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ r s t u, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s,\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) =\n             p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ (a b x y z w u v p q r s : ℕ),\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 →\n    ∃ m n o p, a * b = m ^ 2 + n ^ 2 + o ^ 2 + p ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ r s t u, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 * x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ (a b c d x y z w : ℕ),\n  ∃ p q r s,\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ (a b c d w x y z : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α"]},
  {"theorem": "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6"],
    ["∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
    "∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6"]},
  {"theorem": "∀ (z : ℤ), ¬Irrational ↑z",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (x : ℤ), ¬Irrational ↑x",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ {z : ℤ}, ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ {z : ℤ}, ¬Irrational ↑z"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (z : ℤ), ¬Irrational z",
    "∀ (z : ℤ), ¬Irrational ↑z",
    "∀ (x : ℤ), ¬Irrational x",
    "∀ (z : ℤ), ¬Irrational z",
    "∀ {z : ℤ}, ¬Irrational ↑z",
    "∀ (z : ℤ), ¬Irrational ↑z",
    "∀ (z : ℤ), ¬Irrational ↑z",
    "∀ (z : ℤ), ¬Irrational z",
    "∀ (z : ℤ), ¬Irrational ↑z",
    "∀ {z : ℤ}, ¬Irrational ↑z"]},
  {"theorem": "∀ {R : Type u_1} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u_1} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u_1} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u_1} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u_1} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u_1} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)"]},
  {"theorem": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }"]},
  {"theorem": "∀ {a b : ℕ}, ∃ c, a + b = c",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {m n : ℕ}, ∃ r, m + n = r",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ {m n : ℕ}, ∃ r : ℕ, m + n = r",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c"]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"],
    ["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)"]},
  {"theorem": "Fact (Nat.Prime 7)",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups": [["Fact (Nat.Prime 7)", "Fact (Nat.Prime 7)"]],
   "correct": null,
   "comments": "",
   "all-elabs": ["Fact (Nat.Prime 7)", "Fact (Nat.Prime 7)"]},
  {"theorem": "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]},
  {"theorem":
   "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
     "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
     "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
     "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
     "∀ {α : Type u} (s : Set α), ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
     "∀ {α : Type u} (s : Set α), ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t"],
    ["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} (s : Set α), ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
    "∀ {α : Type u} {s : Set α}, ¬ Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
    "∀ {α : Type u} {s : Set α}, s.Nonempty → ∃ t : Finset α, ↑t ⊆ s ∧ t.Nonempty",
    "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
    "∀ {α : Type u} {s : Set α}, ¬ Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
    "∀ {α : Type u} (s : Set α), ¬ Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
    "∀ {α : Type u} (s : Set α), ¬ Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ∧ Set.Nonempty t",
    "∀ {α : Type u} (s : Set α), ¬Set.Finite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s"]},
  {"theorem": "{R : Type u} → [inst : CommRing R] → Monoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R"],
    ["{R : Type u} → [inst : CommRing R] → MulOneClass R",
     "{R : Type u} → [inst : CommRing R] → MulOneClass R"],
    ["{α : Type u} → [inst : CommRing α] → Monoid α"],
    ["{R : Type u_1} → [inst : CommRing R] → Monoid R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], MulOneClass R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {α : Type u} [inst : CommRing α], Monoid α",
    "∀ {R : Type u} [inst : CommRing R], MulOneClass R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R"]},
  {"theorem": "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ x y : ℕ, x ≠ y ∧ n = x + y",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ x y : ℕ, x ≠ y ∧ n = x + y",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x"]},
  {"theorem": "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
     "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
     "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
     "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
     "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
     "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
     "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2"],
    ["∀ {n : ℕ}, Even n → Even (n ^ 2)",
     "∀ {n : ℕ}, Even n → Even (n ^ 2)",
     "∀ {n : ℕ}, Even n → Even (n ^ 2)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, even n → even (n ^ 2)",
    "∀ {n : ℕ}, Even n → Even (n ^ 2)",
    "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, Even n → Even (n ^ 2)",
    "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : DivisionRing R], IsField R"],
    ["∀ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R], (∀ (x : R), x ≠ 0 → ∃ y, x * y = 1) → IsField R"],
    ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], DivisionRing R → IsField R"],
    ["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], (∀ (x : R), x ≠ 0 → ∃ y, x * y = 1) → IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R], (∀ (x : R), x ≠ 0 → ∃ (y : R), x * y = 1) → IsField R",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R], DivisionRing R → IsField R",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], (∀ (x : R), x ≠ 0 → ∃ (y : R), x * y = 1) → IsField R",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : DivisionRing R], IsField R"]},
  {"theorem": "∀ {G : Type u} [inst : Group G], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["∀ {G : Type u} [inst : Group G], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
     "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
     "∀ {G : Type u} [inst : Group G], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
     "∀ {G : Type u} [inst : Group G], id 1 = 1",
     "∀ {α : Type u} [inst : One α], id 1 = 1",
     "∀ {α : Type u} [inst : Monoid α], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u} [inst : Group G], id (1 : G) = 1",
    "∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1",
    "∀ {G : Type u} [inst : Group G], id (1 : G) = 1",
    "∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id 1 = 1",
    "∀ {G : Type u} [inst : Group G], id (1 : G) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1"]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x"]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoEMetricSpace α] {a : α}, EMetric.diam {a} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] (a : α), Metric.diam {a} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : MetricSpace α] {x : α}, Metric.diam {x} = 0"],
    ["∀ {α : Type u} [inst : MetricSpace α] {s : Set α}, Set.Subsingleton s → Metric.diam s = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam (singleton x) = 0",
    "∀ {α : Type u} [inst : PseudoEMetricSpace α] {a : α}, EMetric.diam ({a} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] (a : α), Metric.diam (singleton a) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam (singleton x) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam ({x} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam (singleton x) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam ({x} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam (singleton x) = 0",
    "∀ {α : Type u} [inst : MetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : MetricSpace α] {s : Set α}, Set.Subsingleton s → Metric.diam s = 0"]},
  {"theorem": "∀ (G : Type u) [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G"],
    ["∀ (G : Type u_1) [inst : Group G], Nonempty G",
     "∀ (G : Type u_1) [inst : Group G], Nonempty G",
     "∀ (G : Type u_1) [inst : Group G], Nonempty G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (G : Type u_1) [inst : Group G], Nonempty G",
    "∀ (G : Type u) [Group G], Nonempty G",
    "∀ (G : Type u) [Group G], Nonempty G",
    "∀ (G : Type u) [Group G], Nonempty G",
    "∀ (G : Type u) [Group G], Nonempty G",
    "∀ (G : Type u) [Group G], Nonempty G",
    "∀ (G : Type u) [Group G], Nonempty G",
    "∀ (G : Type u_1) [Group G], Nonempty G",
    "∀ (G : Type u_1) [Group G], Nonempty G",
    "∀ (G : Type u) [Group G], Nonempty G"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"]},
  {"theorem":
   "∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ I, Ideal.IsMaximal I",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ I, Ideal.IsMaximal I",
     "∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ I, Ideal.IsMaximal I"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ M, Ideal.IsMaximal M",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [Algebra ℤ R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M",
    "∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ M, Ideal.IsMaximal M",
    "∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ I : Ideal (NumberField.ringOfIntegers K), Ideal.IsMaximal I",
    "∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ M, Ideal.IsMaximal M",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M",
    "∀ {K : Type u} [inst : Field K] [inst_1 : NumberField K], ∃ I, @Ideal.IsMaximal (NumberField.ringOfIntegers K) _ I"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set PEmpty) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set (Unit)) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set (ULift ℕ)) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V"]}],
 "elaborated": 36}