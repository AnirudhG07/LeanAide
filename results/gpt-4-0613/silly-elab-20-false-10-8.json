{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["Every set is Lebesgue measurable.", "There is no field of order `10`."],
 "elaborated-prompts":
 [{"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p"],
    ["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p"]},
  {"theorem": "∃ᶠ (m : ℕ) in Filter.atTop, Odd m",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["∃ᶠ (m : ℕ) in Filter.atTop, Odd m",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
     "∃ᶠ (n : ℕ) in Filter.atTop, Odd n"],
    ["∀ {p : ℕ → Prop}, (∀ (n : ℕ), p (2 * n + 1)) → ∃ᶠ (n : ℕ) in Filter.atTop, p n"],
    ["∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ᶠ (m : ℕ) in Filter.atTop, Odd m",
    "∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1",
    "∀ {p : ℕ → Prop}, (∀ (n : ℕ), p (2 * n + 1)) → ∃ᶠ (n : ℕ) in Filter.atTop, p n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n",
    "∃ᶠ (n : ℕ) in Filter.atTop, Odd n"]},
  {"theorem": "Nat.minFac 9 = 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["Nat.minFac 9 = 3",
     "Nat.minFac 9 = 3",
     "Nat.minFac 3 = 3",
     "Nat.minFac 9 = 3",
     "Nat.minFac 9 = 3",
     "Nat.minFac 9 = 3"],
    ["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p ≠ 2 → p ≥ 3"],
    ["Fact (Nat.minFac 9 = 3)"],
    ["Fact (Nat.Prime 3) ∧ ∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → 3 ≤ p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Nat.minFac 9 = 3",
    "Fact (Nat.minFac 9 = 3)",
    "Nat.minFac 9 = 3",
    "Fact (Nat.Prime 3) ∧ ∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → 3 ≤ p",
    "Nat.minFac 3 = 3",
    "Nat.minFac 9 = 3",
    "Nat.minFac 9 = 3",
    "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p ≠ 2 → p ≥ 3",
    "Nat.minFac 9 = 3"]},
  {"theorem": "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
     "Set.Infinite {p | Nat.Prime p ∧ Odd p}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p}",
    "Set.Infinite { p : ℕ | Nat.Prime p ∧ Odd p }",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p}",
    "Set.Infinite { p : ℕ | Nat.Prime p ∧ Odd p }",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  (Module.rank K V = 2) → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K"],
    ["{K : Type u} → [inst : Field K] → DivisionRing K",
     "{K : Type u} → [inst : Field K] → DivisionRing K"],
    ["(K : Type u_1) → [inst : Field K] → DivisionRing K"],
    ["{F : Type u_1} → [inst : Field F] → DivisionRing F"],
    ["(α : Type u) → [inst : Field α] → DivisionRing α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (α : Type u) [inst : Field α], DivisionRing α",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ {F : Type u_1} [inst : Field F], DivisionRing F",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ (K : Type u_1) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (FiniteDimensional.finrank K V = 2) → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  (FiniteDimensional.finrank K V = 2) → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "∀ (n : ℕ), ∃ m, n + 1 = m",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ m, n + 1 = m",
     "∀ (n : ℕ), ∃ k, Nat.succ n = k",
     "∀ (n : ℕ), ∃ m, Nat.succ n = m",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ k, n + 1 = k",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ k, n + 1 = k",
     "∀ (n : ℕ), ∃ k, n + 1 = k",
     "∀ (n : ℕ), ∃ m, n + 1 = m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ m, n + 1 = m",
    "∀ (n : ℕ), ∃ k, Nat.succ n = k",
    "∀ (n : ℕ), ∃ m, Nat.succ n = m",
    "∀ (n : ℕ), ∃ m, m = n + 1",
    "∀ (n : ℕ), ∃ m, m = n + 1",
    "∀ (n : ℕ), ∃ k, n + 1 = k",
    "∀ (n : ℕ), ∃ m, m = n + 1",
    "∀ (n : ℕ), ∃ k : ℕ, n + 1 = k",
    "∀ (n : ℕ), ∃ k, n + 1 = k",
    "∀ (n : ℕ), ∃ m, n + 1 = m"]},
  {"theorem": "∀ (n : ℕ), n < Nat.succ n",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < Nat.succ n",
     "∀ (n : ℕ), n < n + 1",
     "∀ (n : ℕ), n < Nat.succ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < Nat.succ n",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ n : ℕ, n < n.succ",
    "∀ (n : ℕ), n < n + 1",
    "∀ (n : ℕ), n < n.succ"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ?m.354219 μ s = 0 → MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ?m.354219 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ?m.351980 μ s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ?m.353629 μ = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} {s : Set α}, ?m.353907 = 0 → MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α} (μ : MeasureTheory.Measure α), ?m.354059 μ = 0 → MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} {s : Set α}, ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α} (μ : MeasureTheory.Measure α),\n  ↑↑μ s = 0 → MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), ↑↑μ s = 0 → MeasurableSet s"]},
  {"theorem": "∀ {n : ℕ}, Nat.Prime n → ¬∃ a, a * a = n",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {n : ℕ}, Nat.Prime n → ¬∃ a, a * a = n",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p",
     "∀ (n : ℕ), Nat.Prime n → ¬∃ a, a * a = n",
     "∀ {n : ℕ} {m : ℕ}, Nat.Prime n → ¬∃ t, t * t = n",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p",
     "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p"],
    ["∀ {n : ℕ} [hprime : Fact (Nat.Prime n)], ¬∃ m, m * m = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Nat.Prime n → ¬∃ a, a * a = n",
    "∀ {n : ℕ} [hprime : Fact (Nat.Prime n)], ¬∃ m, m * m = n",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p",
    "∀ (n : ℕ), Nat.Prime n → ¬∃ a, a * a = n",
    "∀ {n m : ℕ}, Nat.Prime n → ¬∃ t, t * t = n",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p"]},
  {"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → 2 < p",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → 2 < p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2",
     "∀ {n : ℕ} [inst : Fact (Nat.Prime n)], n % 2 = 1 → 2 < n",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → 2 < p"],
    ["∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
     "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → 2 < p"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → 2 < p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2",
    "∀ {n : ℕ} [inst : Fact (Nat.Prime n)], n % 2 = 1 → 2 < n",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → 2 < p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → 2 < p"]},
  {"theorem":
   "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
     "∀ {a b x y z w u v r s : ℕ} {t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2",
     "∀ {a b x y z w u v p q : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 → ∃ r s t l, a * b = r ^ 2 + s ^ 2 + t ^ 2 + l ^ 2",
     "∀ {a b w x y z r s t u : ℕ},\n  a = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 →\n    b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 → ∃ v w x y, a * b = v ^ 2 + w ^ 2 + x ^ 2 + y ^ 2"],
    ["∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
     "∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
     "∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2"],
    ["∀ {R : Type u_1} [inst : CommRing R] {a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R},\n  ∃ c₁ c₂ c₃ c₄,\n    (a₁ * a₁ + a₂ * a₂ + a₃ * a₃ + a₄ * a₄) * (b₁ * b₁ + b₂ * b₂ + b₃ * b₃ + b₄ * b₄) =\n      c₁ * c₁ + c₂ * c₂ + c₃ * c₃ + c₄ * c₄"],
    ["∀ {a b x y u v r s t : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 → ∃ p q m n, a * b = p ^ 2 + q ^ 2 + m ^ 2 + n ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
    "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ}, \na = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 → \nb = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → \n∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2",
    "∀ {a b x y z w u v r s t : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2",
    "∀ {a b x y z w u v p q : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + p ^ 2 + q ^ 2 → ∃ r s t l, a * b = r ^ 2 + s ^ 2 + t ^ 2 + l ^ 2",
    "∀ {a b x y u v w z : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
    "∀ {a b x y u v w z : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → \n∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ {a b x y u v w z : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
    "∀ {a b x y u v r s t : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 → ∃ p q m n, a * b = p ^ 2 + q ^ 2 + m ^ 2 + n ^ 2",
    "∀ {a b w x y z r s t u : ℕ},\n  a = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 →\n  b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 →\n  ∃ v w x y : ℕ, a * b = v ^ 2 + w ^ 2 + x ^ 2 + y ^ 2",
    "∀ {R : Type u_1} [inst : CommRing R] {a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : R},\n  ∃ c₁ c₂ c₃ c₄,\n    (a₁ * a₁ + a₂ * a₂ + a₃ * a₃ + a₄ * a₄) * (b₁ * b₁ + b₂ * b₂ + b₃ * b₃ + b₄ * b₄) =\n      c₁ * c₁ + c₂ * c₂ + c₃ * c₃ + c₄ * c₄"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [topological_space : TopologicalSpace α] [compact_space : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : CompactSpace α], LocallyCompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [self : CompactSpace α], LocallyCompactSpace α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [topological_space : TopologicalSpace α] [compact_space : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : CompactSpace α], LocallyCompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [self : CompactSpace α], LocallyCompactSpace α"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} [inst_2 : CompactSpace α],\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} [inst_2 : CompactSpace α],\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun → UniformContinuous self.toFun"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  Continuous self.toFun → UniformContinuous self.toFun",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β} [CompactSpace α],\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β}, \n  Continuous f → UniformContinuous f"]},
  {"theorem": "∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6",
     "∀ {p₁ p₂ : ℕ}, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ + p₂ ≠ 6",
     "¬∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ a ≠ b ∧ a + b = 6",
     "¬∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
     "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
     "¬∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
     "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
     "∀ {p₁ p₂ : ℕ}, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ + p₂ ≠ 6"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6",
    "∀ {p₁ p₂ : ℕ}, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ + p₂ ≠ 6",
    "¬ ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a ≠ b ∧ a + b = 6",
    "¬∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
    "¬∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
    "∀ {p₁ p₂ : ℕ}, Nat.Prime p₁ → Nat.Prime p₂ → p₁ ≠ p₂ → p₁ + p₂ ≠ 6"]},
  {"theorem": "∀ (z : ℤ), ¬Irrational ↑z",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ {n : ℤ}, ¬Irrational ↑n",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (a : ℤ), ¬Irrational ↑a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (z : ℤ), ¬ Irrational z",
    "∀ (n : ℤ), ¬ Irrational ↑n",
    "∀ (z : ℤ), ¬Irrational (↑z : ℝ)",
    "∀ (n : ℤ), ¬Irrational (↑n : ℝ)",
    "∀ {n : ℤ}, ¬Irrational n",
    "∀ (n : ℤ), ¬ Irrational ↑n",
    "∀ (z : ℤ), ¬Irrational (↑z : ℝ)",
    "∀ (z : ℤ), ¬Irrational ↑z",
    "∀ (a : ℤ), ¬ Irrational a"]},
  {"theorem": "∀ {R : Type u} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u_1} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : CommRing R], IsUnit 1",
     "∀ {R : Type u_1} [inst : CommRing R], R → IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u_1} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : CommRing R], R → IsUnit 1",
     "∀ {R : Type u_1} [inst : CommRing R], IsUnit 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u_1} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : CommRing R], IsUnit (1 : R)",
    "∀ {R : Type u_1} [inst : CommRing R] (a : R), IsUnit 1",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u_1} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : CommRing R] (x : R), IsUnit (1:R)",
    "∀ {R : Type u_1} [inst : CommRing R], IsUnit (1 : R)"]},
  {"theorem": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H"],
    ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), ∃ inst2, true = true",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), ∃ inst_1, true = true",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), ∃ inst_1, true = true"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), ∃ (inst2 : Group { x // x ∈ H }), true",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H }",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), ∃ (inst_1 : Group { x // x ∈ H }), true",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), ∃ (inst_1 : Group {x // x ∈ H}), true"]},
  {"theorem": "∀ (a b : ℕ), ∃ c, a + b = c",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (m n : ℕ), ∃ x, m + n = x",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ n, a + b = n",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a b : ℕ), ∃ c : ℕ, a + b = c",
    "∀ (m n : ℕ), ∃ x : ℕ, m + n = x",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ n : ℕ, a + b = n",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c",
    "∀ (a b : ℕ), ∃ c : ℕ, a + b = c",
    "∀ {a b : ℕ}, ∃ (c : ℕ), a + b = c",
    "∀ {a b : ℕ}, ∃ c : ℕ, a + b = c"]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)"]},
  {"theorem": "Fact (Nat.Prime 7)",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups":
   [["Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)",
     "Fact (Nat.Prime 7)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)",
    "Fact (Nat.Prime 7)"]},
  {"theorem":
   "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
   "some-correct": null,
   "prompt": "There are `3` prime numbers below `8`.",
   "groups":
   [["List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3",
     "(Finset.filter Nat.Prime (Finset.range 8)).card = 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["List.length (List.filter Nat.Prime (List.range 8)) = 3",
    "List.length (List.filter Nat.Prime (List.range 8)) = 3",
    "List.length (List.filter Nat.Prime (List.range 8)) = 3",
    "List.length (List.filter Nat.Prime (List.range 8)) = 3",
    "List.length (List.filter Nat.Prime (List.range 8)) = 3",
    "List.length (List.filter Nat.Prime (List.range 8)) = 3",
    "List.length (List.filter Nat.Prime (List.range 8)) = 3",
    "Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3"]},
  {"theorem": "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {a : Finset α}, ∅ ⊆ a",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
     "∀ {α : Type u} {a : Set α}, a ⊆ ∅ ↔ a = ∅",
     "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {a : Finset α}, ∅ ⊆ ↑a",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → HasSubset.Subset ∅ s",
    "∀ {α : Type u} {s : Finset α}, ∅ ⊆ ↑s",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s",
    "∀ {α : Type u} {a : Set α}, a ⊆ ∅ ↔ a = ∅",
    "∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]},
  {"theorem":
   "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s"],
    ["∀ {α : Type u} {s : Set α}, ∃ t, Set.Finite t ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, ∃ t, Set.Finite t ∧ t ⊆ s"],
    ["∀ {α : Type u} {s : Set α}, Nonempty (Set.Finite s)"],
    ["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t ⊆ s, Set.Finite t ∧ ¬Set.Finite (s \\ t)"],
    ["∀ {α : Type u} {s : Set α}, ∃ t ⊆ s, Set.Finite t ∧ Set.Nonempty t"],
    ["∀ {α : Type u} {s : Set α}, (∃ x, x ∈ s) → ∃ t, Set.Finite t ∧ t ⊆ s"],
    ["∀ {α : Type u} {s : Set α}, Set.Nonempty s → ∃ t, Set.Finite t ∧ t ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t ⊆ s, Set.Finite t ∧ ¬Set.Finite (sdiff s t)",
    "∀ {α : Type u} {s : Set α}, ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, ∃ t ⊆ s, Set.Finite t ∧ Set.Nonempty t",
    "∀ {α : Type u} {s : Set α}, (∃ x : α, x ∈ s) → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Nonempty s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Nonempty (Set.Finite s)"]},
  {"theorem": "{R : Type u_1} → [inst : CommRing R] → Monoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u_1} → [inst : CommRing R] → Monoid R",
     "{R : Type u_1} → [inst : CommRing R] → Monoid R",
     "{R : Type u_1} → [inst : CommRing R] → Monoid R"],
    ["{α : Type u} → [inst : CommRing α] → Monoid α",
     "{α : Type u} → [inst : CommRing α] → Monoid α"],
    ["(R : Type u) → [inst : CommRing R] → Monoid R"],
    ["(R : Type u) → [inst : CommRing R] → MulOneClass R"],
    ["{R : Type u_1} → [inst : CommRing R] → MulOneClass R"],
    ["{α : Type u} → [inst : CommRing α] → MulOneClass α"],
    ["{R : Type u} → [inst : CommRing R] → Monoid R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R], Monoid R",
    "∀ {α : Type u} [inst : CommRing α], MulOneClass α",
    "∀ (R : Type u) [inst : CommRing R], MulOneClass R",
    "∀ {R : Type u_1} [inst : CommRing R], MulOneClass R",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R",
    "∀ {R : Type u_1} [inst : CommRing R], Monoid R",
    "∀ {α : Type u} [inst : CommRing α], Monoid α",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ (R : Type u) [inst : CommRing R], Monoid R",
    "∀ {α : Type u} [inst : CommRing α], Monoid α"]},
  {"theorem": "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b"],
    ["∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b",
     "∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b"],
    ["∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ a + b = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ (n : ℕ), Odd n → ∃ (a b : ℕ), a ≠ b ∧ a + b = n",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x = 1) → ∀ (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x = 1) → ∀ (x : G), IsOfFinOrder x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : GroupWithZero G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : GroupWithZero G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G], (∀ x : G, x = 1) → ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : GroupWithZero G] (x : G), IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G], (∀ x : G, x = 1) → ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : GroupWithZero G], ∀ x : G, IsOfFinOrder x"]},
  {"theorem": "∀ {n : ℕ}, Even n → Even (n ^ 2)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ {n : ℕ}, Even n → Even (n ^ 2)",
     "∀ {n : ℕ}, Even n → Even (n ^ 2)",
     "∀ {n : ℕ}, Even n → Even (n ^ 2)",
     "∀ {n : ℕ}, Even n → Even (n ^ 2)",
     "∀ {n : ℕ}, Even n → Even (n ^ 2)"],
    ["∀ {n : ℕ}, Even n → Even (n * n)",
     "∀ {n : ℕ}, Even n → Even (n * n)",
     "∀ {n : ℕ}, Even n → Even (n * n)"],
    ["∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2", "∀ (n : ℕ), 2 ∣ n → 2 ∣ n ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even n → Even (n ^ 2)",
    "∀ {n : ℕ}, Even n → Even (n ^ 2)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n ^ 2)",
    "∀ {n : ℕ}, 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ (n : ℕ), 2 ∣ n → 2 ∣ n ^ 2",
    "∀ {n : ℕ}, Even n → Even (n ^ 2)",
    "∀ {n : ℕ}, Even n → Even (n ^ 2)"]},
  {"theorem":
   "∀ {K : Type u} [inst : CommRing K] [inst_1 : Nontrivial K] [inst_2 : DivisionRing K], IsField K",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {K : Type u} [inst : CommRing K] [inst_1 : Nontrivial K] [inst_2 : DivisionRing K], IsField K",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : CommRing K] [inst_1 : Nontrivial K] [inst_2 : DivisionRing K], IsField K",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R"]},
  {"theorem": "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
     "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
     "∀ {α : Type u} [inst : One α], id 1 = 1",
     "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
    "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1",
    "∀ {α : Type u} [inst : One α], id 1 = 1",
    "∀ {α : Type u} [inst : MulOneClass α], id 1 = 1"]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt id x"]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]},
  {"theorem": "∀ {G : Type u} [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ (G : Type u) [self : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ (G : Type u) [inst : Group G], Nonempty G"],
    ["∀ {G : Type u_1} [self : Group G], Nonempty G",
     "∀ {G : Type u_1} [inst : Group G], Nonempty G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ (G : Type u) [group G], Nonempty G",
    "∀ (G : Type u) [self : Group G], Nonempty G",
    "∀ {G : Type u} [Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u_1} [self : Group G], Nonempty G",
    "∀ (G : Type u) [group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u_1} [Group G], Nonempty G",
    "∀ (G : Type u) [group G], Nonempty G"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
     "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsPreconnected s → IsConnected s",
     "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
     "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsConnected s ↔ IsPreconnected s"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsConnected s → IsPreconnected s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
    "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsConnected s → IsPreconnected s",
    "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsPreconnected s → IsConnected s",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
    "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsPreconnected s → IsConnected s",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), IsConnected s ↔ IsPreconnected s",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"]},
  {"theorem":
   "∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M",
     "∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M",
     "∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M"],
    ["∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], ∃ M, Ideal.IsMaximal M"],
    ["∀ {α : Type u} [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : IsDedekindDomain α] [inst_3 : IsIntegrallyClosed α],\n  ∃ M, Ideal.IsMaximal M"],
    ["∀ (α : Type u) [inst : Ring α] [inst_1 : IsDomain α], ∃ M, Ideal.IsMaximal M"],
    ["∀ (Z : Type u) [inst : CommRing Z] [inst_1 : IsDomain Z] [inst_2 : IsDedekindDomain Z] [inst_3 : Nontrivial Z],\n  ∃ M, Ideal.IsMaximal M"],
    ["∀ (α : Type u) [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : IsDedekindDomain α] [inst_3 : Module.Free ℤ α]\n  [inst_4 : Module.Finite ℤ α], ∃ M, Ideal.IsMaximal M"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M",
    "∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M",
    "∀ {α : Type u} [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : IsDedekindDomain α] [inst_3 : IsIntegrallyClosed α],\n  ∃ M, Ideal.IsMaximal M",
    "∀ (α : Type u) [inst : Ring α] [inst_1 : IsDomain α], ∃ M, Ideal.IsMaximal M",
    "∀ (Z : Type u) [inst : CommRing Z] [inst_1 : IsDomain Z] [inst_2 : IsDedekindDomain Z]\n[inst_3 : Nontrivial Z], ∃ M, Ideal.IsMaximal M",
    "∀ (α : Type u) [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : IsDedekindDomain α]\n  [inst_3 : Module.Free ℤ α] [inst_4 : Module.Finite ℤ α], ∃ M, Ideal.IsMaximal M",
    "∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M",
    "∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R], ∃ M, Ideal.IsMaximal M"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑⊥) K V → Subsingleton V",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑⊥) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑⊥) K V → Subsingleton V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι K V → Subsingleton V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  Basis (⊥ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (⊥ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : IsEmpty ι], Basis ι K V → Subsingleton V"]}],
 "elaborated": 38}