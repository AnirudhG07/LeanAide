{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["If every proper closed subset of a topological space is compact, then the space itself is compact.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian.",
  "Every matrix satisfies its own characteristic polynomial.",
  "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
  "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers."],
 "elaborated-prompts":
 [{"theorem": "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
     "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = p",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"]},
  {"theorem":
   "∀ {a b x y z w u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t m, a * b = p ^ 2 + q ^ 2 + t ^ 2 + m ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b x y z w u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t m, a * b = p ^ 2 + q ^ 2 + t ^ 2 + m ^ 2",
     "∀ {a b x y z w u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t m, a * b = p ^ 2 + q ^ 2 + t ^ 2 + m ^ 2",
     "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
     "∀ {a b : ℕ},\n  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n    (∃ u v r s, b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2) → ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2"],
    ["∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ a_3 b_1 c d, a_3 * b_1 = a_3 ^ 2 + b_1 ^ 2 + c ^ 2 + d ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b x y z w u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t m, a * b = p ^ 2 + q ^ 2 + t ^ 2 + m ^ 2",
    "∀ {a b x y z w u v r s : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t m, a * b = p ^ 2 + q ^ 2 + t ^ 2 + m ^ 2",
    "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ}, a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 → b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 →\n  ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2",
    "∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → \n  ∃ a b c d, a * b = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2",
    "∀ {a b : ℕ}, (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → (∃ u v r s, b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2) →\n  ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2",
    "∀ {a b p q r s u v w x : ℕ}, a = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2 → ∃ i j k l, a * b = i ^ 2 + j ^ 2 + k ^ 2 + l ^ 2",
    "∀ {n m a b c d w x y z : ℕ},\n  n = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 → m = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 →\n    ∃ p q r s, n * m = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ {a b : ℕ}, (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → (∃ u v t s, b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2) → \n    ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2",
    "∀ {a b x y u v s t : ℕ}, a = x ^ 2 + y ^ 2 + s ^ 2 + t ^ 2 → b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r p q m, a * b = r ^ 2 + p ^ 2 + q ^ 2 + m ^ 2",
    "∀ {a b x y z w u v t q : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + q ^ 2 →\n  ∃ r s p o, a * b = r ^ 2 + s ^ 2 + p ^ 2 + o ^ 2"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MulZeroOneClass α] [inst_1 : Nontrivial α], (∀ (x : α), x * x = x) → IsCommutative α Mul.mul",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "groups":
   [["∀ {α : Type u_1} [inst : MulZeroOneClass α] [inst_1 : Nontrivial α], (∀ (x : α), x * x = x) → IsCommutative α Mul.mul"],
    ["∀ {α : Type u_1} [inst : BooleanRing α] (a b : α), a * b = b * a"],
    ["∀ {α : Type u} [inst : Semiring α], (∀ (a : α), a * a = a) → IsCommutative α Mul.mul"],
    ["∀ {α : Type u_1} [inst : Semiring α], (∀ (x : α), x * x = x) → IsCommutative α Mul.mul"],
    ["∀ {α : Type u_1} [self : BooleanRing α], IsCommutative α Mul.mul"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : BooleanRing α], ∀ (a b : α), a * b = b * a",
    "∀ {α : Type u} [inst : Semiring α] (H : ∀ (a : α), a * a = a), IsCommutative α Mul.mul",
    "∀ {α : Type u_1} [inst : Semiring α] (H : ∀ (x : α), x * x = x), IsCommutative α Mul.mul",
    "∀ {α : Type u_1} [self : BooleanRing α], IsCommutative α Mul.mul",
    "∀ {α : Type u_1} [inst : MulZeroOneClass α] [inst_1 : Nontrivial α],\n  (∀ (x : α), x * x = x) → IsCommutative α Mul.mul",
    "∀ {R : Type u_1} [inst : Semiring R] [self : BooleanRing R], ∀ (a b : R), a * b = b * a"]},
  {"theorem": "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}"]},
  {"theorem":
   "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
     "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"],
    ["{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["{K : Type u} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K"]},
  {"theorem":
   "∀ {α : Sort u} {β : Sort v}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "groups":
   [["∀ {α : Sort u} {β : Sort v}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)"],
    ["∀ {α : Sort u_1} {β : Sort u_2}, (α ↪ β) → (β ↪ α) → Nonempty (α ≃ β)"],
    ["∀ {α : Sort u} {β : Sort v} {f : α → β} {g : β → α}, Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"],
    ["∀ {α : Type u_12} {β : Type u_13} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"],
    ["∀ {α : Type u} {β : Type v}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Sort u_1} {β : Sort u_2} (e₁ : α ↪ β) (e₂ : β ↪ α), Nonempty (α ≃ β)",
    "∀ {α : Sort u} {β : Sort v} {f : α → β} {g : β → α},\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
    "∀ {α β : Type*} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
    "∀ {α : Type u} {β : Type v}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)",
    "∀ {α : Sort u} {β : Sort v}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)",
    "∀ {α : Sort u} {β : Sort v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
    "∀ {α : Sort u_1} {β : Sort u_2} {e : α → β} {f : β → α},\n  Function.Injective e → Function.Injective f → Nonempty (α ≃ β)",
    "∀ {α β : Type u} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∃ (h : α ≃ β), True",
    "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {g : β → α},\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"]},
  {"theorem":
   "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n    ∃ v, ∀ (w : V), v ≠ w → SimpleGraph.Adj G v w",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "groups":
   [["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n    ∃ v, ∀ (w : V), v ≠ w → SimpleGraph.Adj G v w"],
    ["∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] (G : SimpleGraph V),\n  (∀ (v w : V), v ≠ w → ∃! u, u ≠ v ∧ u ≠ w ∧ SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"],
    ["∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] (G : SimpleGraph V),\n  (∀ (v w : V), Set.Nonempty (SimpleGraph.commonNeighbors G v w)) → ∃ v, ∀ (w : V), v ≠ w → SimpleGraph.Adj G v w"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! u, u ≠ v ∧ u ≠ w ∧ SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] (G : SimpleGraph V),\n  (∀ (v w : V), v ≠ w → ∃! (u : V), u ≠ v ∧ u ≠ w ∧ SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w",
    "∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] (G : SimpleGraph V),\n  (∀ (v w : V), Set.Nonempty (SimpleGraph.commonNeighbors G v w)) → ∃ (v : V), ∀ (w : V), v ≠ w → SimpleGraph.Adj G v w",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! (u : V), u ≠ v ∧ u ≠ w ∧ SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] (h : ∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w),\n  ∃ (v : V), ∀ (w : V), v ≠ w → SimpleGraph.Adj G v w"]},
  {"theorem":
   "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m",
   "some-correct": null,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "groups":
   [["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), Set.Nonempty s → ∃ a, ∀ b ∈ s, r b a) →\n    (∀ (s : Set α), (∀ (a b : α), a ∈ s → b ∈ s → a ≠ b → r a b ∨ r b a) → ∃ ub, ∀ a ∈ s, r a ub) →\n      ∃ m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (chain : Set α), IsChain r chain → ∃ a, ∀ b ∈ chain, r b a ∨ r a b) → ∃ max, ∀ (a : α), r max a ∨ r a max"],
    ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), IsChain r s → ∃ b, ∀ a ∈ s, r a b) →\n    (∀ (a b : α), r a b → r b a → a = b) → ∀ (a : α), ∃ m, ∀ (b : α), r a m → r m b → r a b"],
    ["∀ {α : Type u_1} {r : α → α → Prop} {s : Set α},\n  (∀ c ⊆ s, IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) → Nonempty ↑s → ∃ m H, ∀ a ∈ s, r m a → r a m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), Set.Nonempty s → ∃ a, ∀ (b : α), b ∈ s → r b a) →\n    (∀ (s : Set α), (∀ (a b : α), a ∈ s → b ∈ s → a ≠ b → r a b ∨ r b a) → ∃ ub, ∀ (a : α), a ∈ s → r a ub) →\n      ∃ m, ∀ (a : α), r m a → r a m",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ chain, IsChain r chain → ∃ a, ∀ b, b ∈ chain → r b a ∨ r a b) →\n  ∃ max, ∀ a, r max a ∨ r a max",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), IsChain r s → ∃ b, ∀ (a : α), a ∈ s → r a b) →\n    (∀ (a b : α), r a b → r b a → a = b) →\n    ∀ (a : α), ∃ m, ∀ (b : α), r a m → r m b → r a b",
    "∀ {α : Type u_1} {r : α → α → Prop} {s : Set α},\n  (∀ (c : Set α), c ⊆ s → IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    Nonempty s → ∃ m H, ∀ (a : α), a ∈ s → r m a → r a m",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) →\n      ∀ (s : Set α), Set.Nonempty s → ∃ m ∈ s, ∀ (a : α), a ∈ s → r a m → r m a"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {g : β → γ} {f : α → β},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {g : β → γ} {f : α → β},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],
    ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : β → α) (g : γ → β),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {g : β → γ} {f : α → β},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {g : β → γ} {f : α → β},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],
    ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : β → α) (g : γ → β),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (f ∘ g)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ f '' s ⊆ {0} ∧ f '' t ⊆ {1}",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ f '' s ⊆ {0} ∧ f '' t ⊆ {1}"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ ∀ x ∈ t, f x = 1"],
    ["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x ∈ s, f x = 0 ∧ x ∈ t → f x = 1"],
    ["∀ {α : Type u} [t : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t_1 : Set α),\n      IsClosed s →\n        IsClosed t_1 →\n          Disjoint s t_1 →\n            ∃ f, Continuous f ∧ ∀ (x : α), f x = 0 ∨ f x = 1 ∧ ∀ (x : α), s x → f x = 0 ∧ ∀ (x : α), t_1 x → f x = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n      IsClosed t →\n      Disjoint s t →\n      ∃ f : α → ℝ,\n        Continuous f ∧ (∀ (x : α), x ∈ s → f x = 0) ∧ (∀ (x : α), x ∈ t → f x = 1)",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔ \n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ x ∈ t → f x = 1",
    "∀ {α : Type u} [t : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x, f x = 0 ∨ f x = 1 ∧ ∀ x, s x → f x = 0 ∧ ∀ x, t x → f x = 1",
    "∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ f '' s ⊆ {0} ∧ f '' t ⊆ {1}"]},
  {"theorem":
   "∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 0.5 → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "groups":
   [["∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 0.5 → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x",
     "∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 0.5 → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x"],
    ["∀ {f : ℝ → ℝ} {x : ℝ}, Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x"],
    ["∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → ∀ n > 0, ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x"],
    ["∀ {f : ℝ → ℝ} {x : ℝ},\n  Function.IsPeriodicPt f 3 x → 0 < x → x < 1 → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y ∧ 0 < y ∧ y < 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {f : ℝ → ℝ} {x : ℝ},\n  Function.IsPeriodicPt f 3 x → ∀ n : ℕ, 0 < n → ∃ x, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) →\n  ∀ n > 0, ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ} {x : ℝ},\n  Function.IsPeriodicPt f 3 x → 0 < x → x < 1 → ∀ n : ℕ, 0 < n → ∃ y, Function.IsPeriodicPt f n y ∧ 0 < y ∧ y < 1",
    "∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 (0.5 : ℝ) → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 0.5 → ∀ (n : ℕ), 0 < n → ∃ (x : ℝ), Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 (1/2) → ∀ n : ℕ, 0 < n → ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, (∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f 3 x) → ∀ n, 0 < n → ∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 (0.5) → ∀ n, 0 < n → ∃ x, Function.IsPeriodicPt f n x"]},
  {"theorem":
   "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.36231481, u₁} C] [inst_1 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Skeletal (CategoryTheory.Discrete PUnit.{?u.36231502 + 1})",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "groups":
   [["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.36231481, u₁} C] [inst_1 : CategoryTheory.Limits.HasTerminal C],\n  CategoryTheory.Skeletal (CategoryTheory.Discrete PUnit.{?u.36231502 + 1})"],
    ["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.36229508, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] → {X : C} → CategoryTheory.Limits.IsTerminal X → Unique (X ≅ ⊤_ C)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {X : C},\n  CategoryTheory.Limits.IsTerminal X → Unique (X ≅ ⊤_ C)",
    "{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] → CategoryTheory.Skeletal (CategoryTheory.Discrete PUnit)"]},
  {"theorem": "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "groups":
   [["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]},
  {"theorem": "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "groups":
   [["∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
     "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3",
     "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
     "∀ {m n k : ℕ}, m > 0 → n > 0 → m ^ 3 + n ^ 3 ≠ k ^ 3",
     "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 = z ^ 3 → False"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b c : ℕ}, a > 0 → b > 0 → a^3 + b^3 ≠ c^3",
    "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → a^3 + b^3 ≠ c^3",
    "∀ {m n k : ℕ}, m > 0 → n > 0 → m ^ 3 + n ^ 3 ≠ k ^ 3",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 = z ^ 3 → False",
    "∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ {x y z : ℤ}, x > 0 → y > 0 → x^3 + y^3 ≠ z^3",
    "∀ {x y z: ℕ}, x > 0 → y > 0 → x*x*x + y*y*y ≠ z*z*z",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (a b : G), Commute a b",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [group : Group G], (∀ (g : G), g * g = 1) → ∀ (a b : G), a * b = b * a"],
    ["∀ {G : Type u_1} [inst : Group G], (∀ (g : G), g ^ 2 = 1) → ∀ (a b : G), Commute a b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (a b : G), Commute a b",
    "∀ {G : Type u_1} [inst : Group G] (H : ∀ (x : G), x * x = 1), ∀ (a b : G), Commute a b",
    "∀ {G : Type u_1} [inst : Group G], (∀ g : G, g^2 = 1) → ∀ a b : G, Commute a b",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y",
    "∀ {G : Type u_1} [group : Group G], (∀ (g : G), g * g = 1) → ∀ (a b : G), a * b = b * a",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x^2 = 1), ∀ (x y : G), Commute x y",
    "∀ {G : Type u_1} [inst : Group G], (∀ (g : G), g ^ 2 = 1) → ∀ (x y : G), Commute x y",
    "∀ {G : Type u_1} [inst : Group G], (∀ (g : G), (g * g = 1)) → ∀ (g h : G), Commute g h",
    "∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y",
    "∀ (G : Type u_1) [inst : Group G], (∀ (g : G), g * g = 1) → ∀ (a b : G), Commute a b"]},
  {"theorem": "∀ (n : ℕ), Even (n * (n + 1))",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "groups":
   [["∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G"]},
  {"theorem": "∀ n > 1, ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "groups":
   [["∀ n > 1, ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ {n : ℕ}, n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ n > 1, ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ {n : ℕ}, 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → Subsingleton G",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → Subsingleton G"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], Monoid.IsTorsionFree α → Subsingleton α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α],\n  Monoid.IsTorsionFree α → Subsingleton α",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G],\n  Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Monoid.IsTorsionFree G → Subsingleton G"]},
  {"theorem":
   "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
     "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"],
    ["{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["{K : Type u} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],
    ["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α"]},
  {"theorem":
   "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f",
   "some-correct": null,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "groups":
   [["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f",
     "∀ {ι : Type u} [inst : Fintype ι] {f : FreeGroup ι →* FreeGroup ι}, Function.Surjective ⇑f → Function.Injective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f",
    "∀ {ι : Type u} [inst : Fintype ι] {f : FreeGroup ι →* FreeGroup ι}, Function.Surjective ↑f → Function.Injective ↑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f",
    "∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α →* FreeGroup α},\n  Function.Surjective ↑f → Function.Injective ↑f",
    "∀ {α : Type u_1} [inst : Fintype α] (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → Function.Injective f",
    "∀ {α : Type u} (n : ℕ) (f : FreeGroup (Fin n) →* FreeGroup (Fin n)),\n  Function.Surjective ↑f → Function.Injective ↑f"]},
  {"theorem":
   "∀ {n : ℕ}, n % 2 = 0 → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "groups":
   [["∀ {n : ℕ}, n % 2 = 0 → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n"],
    ["∀ a > 2, a % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ a = p + q"],
    ["∀ n > 2, Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ a + b = n"],
    ["∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a : ℕ), a > 2 → a % 2 = 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ a = p + q",
    "∀ n : ℕ, n > 2 → Even n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a + b = n",
    "∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ}, n % 2 = 0 → n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p + q = n",
    "∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a + b = n"]},
  {"theorem": "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "groups":
   [["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)"]},
  {"theorem": "∀ {n : ℕ}, Even (n ^ 2) → Even n",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "groups":
   [["∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [F : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [F : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [Inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u} [inst : CommRing R] [self : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] [F : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
    "∀ {R : Type u} [inst : CommRing R] [Inst_1 : Fintype R], \n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P)",
    "∀ {R : Type u} [inst : CommRing R] [self : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {S : Set α}, (∀ s ∈ S, ∃ U, IsOpen U ∧ s ∈ U ∧ U ⊆ S) → IsOpen S",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {S : Set α},\n  (∀ s ∈ S, ∃ U : Set α, IsOpen U ∧ s ∈ U ∧ U ⊆ S) → IsOpen S",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g",
     "∀ {G : Type u_1} [inst : Group G] [IsFreeGroup : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {α : Type u_1} [self : Group α] (s : Subgroup α), s = ⊥ → ∀ (a : α), a ≠ 1 → ¬IsOfFinOrder a",
     "∀ {G : Type u_1} [inst : Group G] (x : G), x ≠ 1 → ¬IsOfFinOrder x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], ∀ g : G, g ≠ 1 → ¬ IsOfFinOrder g",
    "∀ {α : Type u_1} [self : Group α] (s : Subgroup α), s = ⊥ → ∀ a : α, a ≠ 1 → ¬IsOfFinOrder a",
    "∀ {G : Type u_1} [inst : Group G] (x : G), (x ≠ 1) → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [IsFreeGroup : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], ∀ g : G, g ≠ 1 → ¬IsOfFinOrder g",
    "∀ {G : Type u_1} [inst : Group G] [H : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R),\n  IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
   "some-correct": null,
   "prompt":
   "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R),\n  IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R), IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0"]},
  {"theorem": "(K : Type u) → [inst : Field K] → Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K",
     "(K : Type u) → [inst : Field K] → Ring K"],
    ["(F : Type u) → [inst : Field F] → Ring F"],
    ["(R : Type u) → [inst : Field R] → Ring R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], Ring K",
    "∀ (R : Type u) [inst : Field R], Ring R",
    "∀ (F : Type u) [inst : Field F], Ring F",
    "∀ (K : Type u) [inst : Field K], Ring K",
    "∀ (K : Type u) [inst : Field K], Ring K",
    "∀ (K : Type u) [inst : Field K], Ring K",
    "∀ {K : Type u} [inst : Field K], Ring K",
    "∀ (F : Type u_1) [inst : Field F], Ring F",
    "∀ (K : Type u) [inst : Field K], Ring K",
    "∀ (K : Type u) [inst : Field K], Ring K"]},
  {"theorem": "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "groups":
   [["{R : Type u_1} → [inst : Ring R] → Group Rˣ"],
    ["{R : Type u} → [inst : Monoid R] → Group Rˣ"],
    ["{R : Type u_1} → [inst : CommRing R] → Group Rˣ"],
    ["{α : Type u_1} → [inst : Monoid α] → Group αˣ"],
    ["{R : Type u} → [inst : CommRing R] → Group Rˣ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Monoid R], Group (Units R)",
    "∀ {R : Type u_1} [inst : CommRing R], Group (Units R)",
    "∀ {α : Type u_1} [inst : Monoid α], Group (Units α)",
    "∀ {R : Type u} [inst : CommRing R], Group (Units R)",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ",
    "∀ {R : Type u_1} [inst : Monoid R], Group (Units R)",
    "∀ {R : Type u_1} [inst : CommRing R], Group Rˣ",
    "∀ {R : Type u_1} [inst : Monoid R], Group Rˣ",
    "∀ {R : Type u_1} [inst : Monoid R], Group (Units R)",
    "∀ {R : Type u_1} [inst : Monoid R], Group Rˣ"]},
  {"theorem":
   "∀ {G₁ G₂ : Type u_1} [inst : Group G₁] [inst_1 : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "groups":
   [["∀ {G₁ G₂ : Type u_1} [inst : Group G₁] [inst_1 : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
     "∀ {G1 G2 : Type u_1} [inst : Group G1] [inst_1 : Group G2],\n  Monoid.IsTorsionFree (G1 × G2) → Monoid.IsTorsionFree G1 ∧ Monoid.IsTorsionFree G2",
     "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂"],
    ["∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
     "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G₁ G₂ : Type u_1} [inst : Group G₁] [inst_1 : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
    "∀ {G1 G2 : Type u_1} [inst : Group G1] [inst_1 : Group G2],\n  Monoid.IsTorsionFree (G1 × G2) → (Monoid.IsTorsionFree G1 ∧ Monoid.IsTorsionFree G2)",
    "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → (Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H)",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H"]}],
 "elaborated": 34}