{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["Every set has Lebesgue measure zero.",
  "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
  "The characteristic polynomial of every matrix has real roots.",
  "Every uniformly continuous function is bounded above.",
  "The number of partitions of a finite set is a prime number.",
  "The automorphism group of an Abelian group is cyclic.",
  "If the set of units of a ring forms a group then the ring is commutative.",
  "If the composition of two functions is continuous, then each of them is continuous.",
  "Implication `→` is symmetric. If `P → Q` then `Q → P`."],
 "elaborated-prompts":
 [{"theorem": "∀ {R : Type u} [inst : Ring R], IsField R",
   "some-correct": null,
   "prompt": "Every ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsField R",
     "∀ (R : Type u) [inst : Ring R], IsField R",
     "∀ (R : Type u) [inst : Ring R], IsField R"],
    ["∀ (R : Type u) [inst : Semiring R], Nontrivial R → (∀ (x : R), x ≠ 0 → ∃ y, x * y = 1) → IsField R"],
    ["∀ {R : Type u} [inst : CommSemiring R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommSemiring R], IsField R",
    "∀ {R : Type u} [inst : Ring R], IsField R",
    "∀ (R : Type u) [inst : Ring R], IsField R",
    "∀ (R : Type u) [inst : Ring R], IsField R",
    "∀ (R : Type u) [inst : Semiring R], Nontrivial R → (∀ (x : R), x ≠ 0 → ∃ y, x * y = 1) → IsField R",
    "∀ {R : Type u} [inst : Semiring R], Nontrivial R → IsField R"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
   "some-correct": null,
   "prompt": "Every vector space is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"],
    ["∀ {G : Type u_1} [inst : CommGroup G], Monoid.IsTorsion G",
     "∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsion G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : CommGroup G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p"]},
  {"theorem":
   "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G], IsSimpleGroup G",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "groups":
   [["∀ {G : Type u_1} [hG : Group G] [inst : Fintype G], IsSimpleGroup G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"],
    ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G], IsSimpleGroup G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p"],
    ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p)",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card α = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], (∃ x, orderOf x ≠ 1) → Group.FG G → Finite G",
   "some-correct": null,
   "prompt":
   "A finitely-presented group containing a torsion element is finite.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], (∃ x, orderOf x ≠ 1) → Group.FG G → Finite G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], (∃ x : G, orderOf x ≠ 1) → Group.FG G → Finite G"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ∈ {t | IsClosed t}, x ∈ t) → IsClosed s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ∈ {t : Set α | IsClosed t}, x ∈ t) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, \n  (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (t : Set α), IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s"]},
  {"theorem":
   "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.",
   "groups":
   [["∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
     "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
     "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)"],
    ["∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ OpenEmbedding fun x => (x, x)"],
    ["∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsOpenMap fun x => (x, x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap fun (x : X) => (x, x)",
    "∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsOpenMap fun (x : α) => (x, x)",
    "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap fun (x : X) => (x, x)",
    "∀ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ↔ OpenEmbedding fun x : X => (x, x)",
    "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap (fun x : X => (x, x))",
    "∀ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap fun (x : X) => (x, x)"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1"],
    ["∀ {G : Type u_1} [inst : Group G] {a : G}, IsOfFinOrder a → (a = 1 ↔ orderOf a = 0)"],
    ["∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1"],
    ["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∀ n > 0, x ^ n = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x^n = 1",
    "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G},  \nIsOfFinOrder x → (∀ n : ℕ, n > 0 → x ^ n = 1)",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {a : G} (h : IsOfFinOrder a), a = 1 ↔ orderOf a = 0",
    "∀ {G : Type u_1} [inst : Group G] (x : G), IsOfFinOrder x → ∀ n : ℕ, n ∣ orderOf x → x ^ n = 1",
    "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Monoid G] {a : G}, IsOfFinOrder a → ∃ n, 0 < n ∧ a ^ n = 1"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt":
   "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G"],
    ["∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree ↥H) → Monoid.IsTorsionFree G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G"]},
  {"theorem":
   "∀ {ι : Type u} {f : FreeGroup ι →* FreeGroup ι}, Function.Injective ⇑f → Function.Surjective ⇑f",
   "some-correct": null,
   "prompt":
   "Every injective homomorphism from a finitely generated free group to itself is surjective.",
   "groups":
   [["∀ {ι : Type u} {f : FreeGroup ι →* FreeGroup ι}, Function.Injective ⇑f → Function.Surjective ⇑f",
     "∀ {ι : Type u} {f : FreeGroup ι →* FreeGroup ι}, Function.Injective ⇑f → Function.Surjective ⇑f"],
    ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ⇑f → Function.Surjective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ⇑f → Function.Surjective ⇑f"],
    ["∀ {α : Type u} [inst : DecidableEq α],\n  ℕ → ∀ (f : FreeGroup α →* FreeGroup α), Function.Injective ⇑f → Function.Surjective ⇑f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {α : Type u} [inst : DecidableEq α] (n : ℕ) (f : FreeGroup α →* FreeGroup α),\n  Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {ι : Type u} {f : FreeGroup ι →* FreeGroup ι}, Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {ι : Type u} {f : FreeGroup ι →* FreeGroup ι}, Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {ι : Type u_1} [inst : Fintype ι] (f : FreeGroup ι →* FreeGroup ι),\n  Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Injective ↑f → Function.Surjective ↑f"]},
  {"theorem": "∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Finite K",
   "some-correct": null,
   "prompt": "Every division ring is either a field or finite.",
   "groups":
   [["∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Finite K"],
    ["∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Nontrivial (Fintype K)"],
    ["∀ {R : Type u_1} [inst : DivisionRing R], IsField R ∨ Finite R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Nontrivial (Fintype K)",
    "∀ {R : Type u_1} [inst : DivisionRing R], IsField R ∨ Finite R",
    "∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Finite K"]},
  {"theorem": "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "groups":
   [["∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"],
    ["∀ n > 1, ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), n > 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), 2 ≤ n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p * q = n",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ) (hn : n ≠ 0), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p * q = n",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"]},
  {"theorem": "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "groups":
   [["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
     "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2"],
    ["∀ {n : ℕ}, 2 ∣ n → ∃ k, n = k ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
    "∀ {n : ℕ}, 2 ∣ n → ∃ k : ℕ, n = k ^ 2",
    "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H",
   "some-correct": null,
   "prompt": "Every normal subgroup of a group has finite index.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hN : Subgroup.Normal H], Subgroup.FiniteIndex H"],
    ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hH : Subgroup.Normal H], ∃ n, n ≠ 0 ∧ Subgroup.index H = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hH : Subgroup.Normal H], ∃ n : ℕ, n ≠ 0 ∧ Subgroup.index H = n",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [hN : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [Subgroup.Normal H], Subgroup.FiniteIndex H → Subgroup.index H ≠ 0",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [Subgroup.Normal H] [Subgroup.FiniteIndex H], \n  Subgroup.index H ≠ 0",
    "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Fintype (G ⧸ H)",
    "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [Subgroup.Normal N], ∃ n : ℕ, n ≠ 0 ∧ Subgroup.index N = n"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
   "some-correct": null,
   "prompt":
   "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
     "∀ {R : Type u} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R],\n  (∀ P : Ideal R, Ideal.IsPrime P → ∃! M : Ideal R, Ideal.IsMaximal M ∧ P ≤ M)",
    "∀ {R : Type u} [inst : CommRing R], ∀ (P : Ideal R),\n  Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R] {P : Ideal R},\n  Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {self : α → β},\n  Continuous self → UniformContinuous self"],
    ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  {f : α → β}, Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {self : α → β},\n  Continuous self → UniformContinuous self",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  {f : α → β}, Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  {f : α → β}, Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  {f : α → β}, Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], (∀ {K : Set α}, IsCompact K → IsClosed K) → CompactSpace α",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α], (∀ {K : Set α}, IsCompact K → IsClosed K) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
     "∀ {α : Type u} [inst : TopologicalSpace α], (∀ {s : Set α}, IsCompact s → IsClosed s) → CompactSpace α"],
    ["∀ {α : Type u} [inst : TopologicalSpace α], CompactSpace α → (∀ {s : Set α}, IsCompact s → IsClosed s) → CompactSpace α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] (self : CompactSpace α), (∀ {s : Set α}, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] (self : ∀ {K : Set α}, IsCompact K → IsClosed K), CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ s : Set α, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], \n  (∀s : Set α, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ {s : Set α}, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ {s : Set α}, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], \n(∀ (K : Set α), IsCompact K → IsClosed K) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ s : Set α, IsCompact s → IsClosed s) → CompactSpace α"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y - x * y)",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y - x * y)",
     "∀ {R : Type u_1} [inst : CommRing R] {e f : R},\n  IsIdempotentElem e → IsIdempotentElem f → IsIdempotentElem (e + f - e * f)"],
    ["∀ {R : Type u_1} [inst : BooleanRing R] {a b : R}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)"],
    ["∀ {R : Type u} [inst : CommRing R] {p q : R}, IsIdempotentElem p → IsIdempotentElem q → IsIdempotentElem (p + q - p * q)"],
    ["∀ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] {p q : R}, IsIdempotentElem p → IsIdempotentElem q → IsIdempotentElem (p + q - p * q)",
    "∀ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x → IsIdempotentElem y →\n  IsIdempotentElem (x + y - x * y)",
    "∀ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)",
    "∀ {R : Type u_1} [inst : CommRing R] {e f : R}, IsIdempotentElem e → IsIdempotentElem f → IsIdempotentElem (e + f - e * f)",
    "∀ {R : Type u_1} [inst : BooleanRing R] {a b : R}, IsIdempotentElem a → IsIdempotentElem b → \n  IsIdempotentElem (a + b)",
    "∀ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x → IsIdempotentElem y → Commute x y →\n  IsIdempotentElem (x + y)",
    "∀ {R : Type u_1} [inst : BooleanRing R] (x y : R), IsIdempotentElem (x + y) = (IsIdempotentElem x ∧ IsIdempotentElem y ∧ Commute x y)",
    "∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    "∀ {R : Type u_1} [inst : BooleanRing R] (a b : R), IsIdempotentElem (a + b)"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : PartialOrder α] {s : Set α}, (∃ x, ∀ y ∈ s, y ≤ x) → ∃! y, ∀ x ∈ s, y ≤ x",
   "some-correct": null,
   "prompt":
   "If a poset has a maximal element, then it has a unique minimal element.",
   "groups":
   [["∀ {α : Type u_1} [inst : PartialOrder α] {s : Set α}, (∃ x, ∀ y ∈ s, y ≤ x) → ∃! y, ∀ x ∈ s, y ≤ x"],
    ["∀ {α : Type u_1} {r : α → α → Prop} {a b : α},\n  (∀ (x : α), r x a → r a x) → (∀ (x : α), r x b → r b x) → (∀ (x : α), r x a → r x b) → a = b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {r : α → α → Prop} {a b : α},\n  (∀ (x : α), r x a → r a x) →\n  (∀ (x : α), r x b → r b x) →\n  (∀ (x : α), r x a → r x b) → a = b",
    "∀ {α : Type u_1} [inst : PartialOrder α] {s : Set α},\n  (∃ x, ∀ y, y ∈ s → y ≤ x) → ∃! y, ∀ x, x ∈ s → y ≤ x"]},
  {"theorem":
   "∀ {f : ℝ → ℝ} {x : ℝ}, 0 ≤ x → x ≤ 1 → f x = x → ∀ (n : ℕ), 0 < n → ∃ y, 0 ≤ y → y ≤ 1 → Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "groups":
   [["∀ {f : ℝ → ℝ} {x : ℝ}, 0 ≤ x → x ≤ 1 → f x = x → ∀ (n : ℕ), 0 < n → ∃ y, 0 ≤ y → y ≤ 1 → Function.IsPeriodicPt f n y",
     "∀ {f : ℝ → ℝ} {x : ℝ},\n  0 ≤ x → x ≤ 1 → Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, 0 ≤ y → y ≤ 1 → Function.IsPeriodicPt f n y"],
    ["∀ {α : Type u} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : Nonempty α] {f : α → α},\n  (∃ x, f x = x ∧ 0 ≤ x ∧ x ≤ 1) → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x ∧ 0 ≤ x ∧ x ≤ 1"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α} {x : α},\n  Continuous f → f x = x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y"],
    ["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {f : ℝ → ℝ} {x : ℝ},\n  0 ≤ x → x ≤ 1 → f x = x → ∀ (n : ℕ), 0 < n → ∃ y, 0 ≤ y → y ≤ 1 → Function.IsPeriodicPt f n y",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] {f : α → α} {x : α},\n  Continuous f → f x = x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y",
    "∀ {α : Type u_1} {f : α → α} {x : α},\n  Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y : α, Function.IsPeriodicPt f n y",
    "∀ {α : Type u} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : Nonempty α] {f : α → α}, (∃ x : α, f x = x ∧ 0 ≤ x ∧ x ≤ 1) → ∀ n : ℕ, (0 < n) → ∃ x : α, Function.IsPeriodicPt f n x ∧ 0 ≤ x ∧ x ≤ 1",
    "∀ {f : ℝ → ℝ} {x : ℝ},\n  0 ≤ x → x ≤ 1 → Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), 0 ≤ y → y ≤ 1 → Function.IsPeriodicPt f n y",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → α} {x : α},\n  Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y",
    "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y"]},
  {"theorem": "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets contains the union of their complements.",
   "groups":
   [["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"],
    ["∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
     "∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s t : Set α), HasCompl.compl (s ∪ t) = HasCompl.compl s ∩ HasCompl.compl t",
    "∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
    "∀ {α : Type u} {s t : Set α}, HasSubset.Subset ((s ∪ t)ᶜ) (sᶜ ∪ tᶜ)",
    "∀ {α : Type u} (s t : Set α), HasCompl.compl (s ∪ t) = HasCompl.compl s ∩ HasCompl.compl t",
    "∀ {α : Type u} (s t : Set α), HasCompl.compl (s ∪ t) = HasCompl.compl s ∩ HasCompl.compl t",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ"]},
  {"theorem": "∀ (q : ℚ), ∃ r, r * r = q",
   "some-correct": null,
   "prompt": "The square root of an rational number is rational.",
   "groups":
   [["∀ (q : ℚ), ∃ r, r * r = q", "∀ (q : ℚ), ∃ r, r * r = q"],
    ["∀ (a : ℚ), ∃ b, Real.sqrt ↑a = ↑b"],
    ["∀ (q : ℚ), ∃ r, r ^ 2 = q"],
    ["∀ {q : ℚ}, ∃ r, r * r = q ↔ Real.sqrt ↑q = ↑r"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (q : ℚ), ∃ r : ℚ, (↑r) ^ 2 = ↑q",
    "∀ (q : ℚ), ∃ r : ℚ, r * r = q",
    "∀ (q : ℚ), ∃ (r : ℚ), r * r = q",
    "∀ {q : ℚ}, ∃ r : ℚ, (r * r = q) ↔ (Real.sqrt ↑q = ↑r)",
    "∀ (a : ℚ), ∃ (b : ℚ), Real.sqrt a = b",
    "∀ (q : ℚ), ∃ r : ℚ, r * r = q",
    "∀ (q : ℚ), ∃ r : ℚ, (r ^ 2 = q)",
    "∀ {x : ℚ}, ∃ y : ℚ, (y * y = x) ↔ (Real.sqrt x = ↑(Rat.sqrt x))",
    "∀ {q : ℚ}, ∃ r, Real.sqrt ↑q = ↑r",
    "∀ (q : ℚ), ∃ r : ℚ, (r*r = q)"]},
  {"theorem":
   "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul",
   "some-correct": null,
   "prompt": "If a module over a ring is free, then the ring is commutative.",
   "groups":
   [["∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul",
     "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul"],
    ["∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Nontrivial R]\n  [inst_4 : Module.Free R M], IsCommutative R Mul.mul"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Nontrivial R] [inst_4 : Module.Free R M], IsCommutative R Mul.mul",
    "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  IsCommutative R Mul.mul",
    "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], IsCommutative R Mul.mul"]},
  {"theorem": "∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p",
   "some-correct": null,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "groups":
   [["∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p",
     "∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
     "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p"],
    ["∀ n > 10, ∃ a p, Nat.Prime p ∧ a ^ 2 + p = n"],
    ["∀ (n : ℕ), 10 < n → ∃ p a, Nat.Prime p ∧ n = a ^ 2 + p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), 10 < n → ∃ p a, Nat.Prime p ∧ n = a ^ 2 + p",
    "∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p",
    "∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
    "∀ n : ℕ, n > 10 → ∃ a p, Nat.Prime p ∧ a^2 + p = n",
    "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
    "∀ {n : ℕ}, 10 < n → ∃ p a, Nat.Prime p ∧ n = a ^ 2 + p",
    "∀ (n : ℕ), 10 < n → ∃ (x p : ℕ), x ^ 2 + p = n ∧ Nat.Prime p",
    "∀ n : ℕ, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
    "∀ (n : ℕ), 10 < n → ∃ (x y : ℕ), x ^ 2 + Prime y = n",
    "∀ (n : ℕ), n > 10 → ∃ (a p : ℕ), a ^ 2 + p = n ∧ Nat.Prime p"]},
  {"theorem":
   "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.32578352, u₁} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)",
   "some-correct": null,
   "prompt":
   "The initial object of a category is isomorphic to its terminal object.",
   "groups":
   [["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.32578352, u₁} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)",
     "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.32581460, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)",
     "∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.32582821, u₁} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)"],
    ["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.32580855, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊤_ C ≅ ⊥_ C)"],
    ["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.32580641, u₁} C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], ∃ f, CategoryTheory.IsIso f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] \n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] \n  [inst_2 : CategoryTheory.Limits.HasInitial C], ∃ f : CategoryTheory.Limits.terminal C ⟶ CategoryTheory.Limits.initial C, CategoryTheory.IsIso f",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (CategoryTheory.Iso (⊤_ C) (⊥_ C))",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)",
    "∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C]\n  [inst_2 : CategoryTheory.Limits.HasInitial C], Nonempty (CategoryTheory.Limits.IsInitial C ≅ CategoryTheory.Limits.IsTerminal C)"]},
  {"theorem":
   "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "groups":
   [["∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c"],
    ["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c"]},
  {"theorem":
   "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S),\n  Function.Injective ⇑f → ∀ (a : R), f a = 0 → a = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "groups":
   [["∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S),\n  Function.Injective ⇑f → ∀ (a : R), f a = 0 → a = 0",
     "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S},\n  Function.Injective ⇑f → ∀ (a : R), f a = 0 → a = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S},\n  Function.Injective ⇑f → ∀ (a : R), ?m.33432460 a = 0 → a = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Function.Injective ⇑f → ∀ {a : R}, ?m.32901305 f = 0 → a = 0"],
    ["∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, ?m.33053139 f = 0 → r ∈ RingHom.ker f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S),\n  Function.Injective (⇑f) → ∀ (a : R), ⇑f a = 0 → a = 0",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S), Function.Injective ↑f → ∀ {a : R}, ↑f a = 0 → a = 0",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S}, Function.Injective (⇑f) → ∀ (a : R), ⇑f a = 0 → a = 0",
    "∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [rcf : RingHomClass F R S] (f : F)\n  {r : R}, ↑f r = 0 → r ∈ RingHom.ker f",
    "∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S},\n  Function.Injective ↑f → ∀ (a : R), ↑f a = 0 → a = 0"]},
  {"theorem": "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
   "some-correct": null,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "groups":
   [["∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ} {p : ℕ}, Nat.Prime p → (p ∣ m ↔ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n"]}],
 "elaborated": 31}