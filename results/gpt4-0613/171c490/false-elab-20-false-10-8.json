{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["A finitely-presented group containing a torsion element is finite.",
  "The number of partitions of a finite set is a prime number.",
  "The initial object of a category is isomorphic to its terminal object."],
 "elaborated-prompts":
 [{"theorem": "∀ {R : Type u} [inst : Ring R], IsField R",
   "some-correct": null,
   "prompt": "Every ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsField R",
     "∀ (R : Type u) [inst : Ring R], IsField R"],
    ["∀ {R : Type u} [inst : Semiring R], IsField R",
     "∀ {R : Type u} [inst : Semiring R], IsField R"],
    ["∀ {R : Type u} [inst : CommSemiring R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Semiring R], IsField R",
    "∀ {R : Type u} [inst : Ring R], IsField R",
    "∀ (R : Type u) [inst : Ring R], IsField R",
    "∀ {R : Type u} [inst : Semiring R], IsField R",
    "∀ {R : Type u} [inst : CommSemiring R], IsField R",
    "∀ (R : Type u_1) [inst : CommRing R], IsField R",
    "∀ {R : Type u} [inst : Semiring R], IsField R",
    "∀ {R : Type u} [inst : Semiring R], Nonempty (IsField R)",
    "∀ {R : Type u} [inst : Semiring R], IsField R",
    "∀ {R : Type u} [inst : Semiring R], IsField R"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
   "some-correct": null,
   "prompt": "Every vector space is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V",
    "This theorem is generally not true. A vector space is not necessarily finite-dimensional. In fact, there exist infinite-dimensional vector spaces. Therefore, there is no accurate Lean 4 code for this incorrect theorem. \n\nOne might mistakenly try to assert the theorem in Lean as follows:\n\n∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V\n\nHowever, this is not a valid theorem in general."]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
     "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G",
    "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_2 : Fintype G], IsSimpleGroup G → ∃ p, ∃ (_ : Nat.Prime p), Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_2 : Fintype G], IsSimpleGroup G → ∃ p, ∃ (_ : Nat.Prime p), Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p"],
    ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G → ∃ p, ∃ (_ : Fact (Nat.Prime p)), Fintype.card G = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G → ∃ (p : ℕ) (hp : Fact (Nat.Prime p)), Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_2 : Fintype G], IsSimpleGroup G → ∃ (p : ℕ) (hp : Nat.Prime p), Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ (p : ℕ), Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"],
    ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
     "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "∀ {G : Type u} [group G] [fintype G], IsSimpleGroup G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
    "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"],
    ["∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p",
    "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"]},
  {"theorem": "∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0",
   "some-correct": null,
   "prompt": "Every set has Lebesgue measure zero.",
   "groups":
   [["∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0",
     "∀ (s : Set ℝ), ↑↑MeasureTheory.volume s = 0"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α], ?m.1117835 = 0"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}, ?m.1116256 = 0"],
    ["∀ {α : Type u} [inst : MeasurableSpace α] (s : Set α), ?m.1117213 s = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}, ↑↑μ s = 0",
    "∀ (s : Set ℝ), MeasureTheory.volume s = 0",
    "∀ {α : Type u} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0",
    "∀ (s : Set ℝ), MeasureTheory.volume s = 0",
    "∀ {α : Type u_1} [inst : MeasurableSpace α], ↑↑MeasureTheory.volume (Set.Univ : Set α) = 0",
    "∀ {α : Type u_1} [MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : TopologicalSpace α] [self : CompactSpace α] (s : Set α), IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "groups":
   [["∀ {α : Type u_1} [inst : TopologicalSpace α] [self : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u_1} [topological_space : TopologicalSpace α] [compact_space : CompactSpace α] (s : Set α), IsCompact s",
     "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
     "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X} [inst_1 : CompactSpace X], IsCompact s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : TopologicalSpace α] [self : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s",
    "∀ {α : Type u_1} [topological_space : TopologicalSpace α] [compact_space : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X} [inst_1 : CompactSpace X], IsCompact s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u_1} [topological_space α] [compact_space α] (s : set α), is_compact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α) [inst_1 : CompactSpace α], IsCompact s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (s : Set X), IsCompact s"]},
  {"theorem":
   "∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α] (s : Set α),\n  MeasurableSet s ∧ ¬borel α ≤ inst_1 → ?m.1223460 s = 0",
   "some-correct": null,
   "prompt":
   "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
   "groups":
   [["∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α] (s : Set α),\n  MeasurableSet s ∧ ¬borel α ≤ inst_1 → ?m.1223460 s = 0"],
    ["∀ {s : Set ℝ} [inst : MeasurableSpace ℝ] [inst_1 : BorelSpace ℝ] (μ : MeasureTheory.Measure ℝ),\n  MeasurableSet s → ¬borel ℝ ≤ inst → ?m.1220083 μ = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {s : Set ℝ} [inst : MeasurableSpace ℝ] [inst_1 : BorelSpace ℝ] (μ : MeasureTheory.Measure ℝ),\n  MeasurableSet s → ¬(borel ℝ ≤ inst) → ↑↑μ s = 0",
    "∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [self : BorelSpace α] (s : Set α),\n  MeasurableSet s ∧ ¬(borel α ≤ inst_1) → ↑↑MeasureTheory.volume s = 0"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "groups":
   [["∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s",
     "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s"],
    ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s",
    "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t : Set X, IsClosed t ∧ x ∈ t) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ t ⊆ s, IsClosed t ∧ x ∈ t) → IsClosed s",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X},\n  (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
     "∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)"],
    ["∀ {X : Type u} [t : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)"],
    ["∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap fun x => (x, x)",
    "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap fun (x : X) => (x, x)",
    "∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
    "∀ {X : Type u} [t : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
    "∀ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap fun (x : X) => (x, x)",
    "∀ {X : Type u} [top : TopologicalSpace X],\n  T2Space X ↔ IsOpenMap fun (p : X) => (p, p)"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
     "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1"],
    ["∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → ∃ n, n ≠ 0 ∧ x ^ n = 1"],
    ["∀ {G : Type u} [inst : Group G] {a : G}, 0 < orderOf a → a ^ orderOf a = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u} [group G] {a : G}, 0 < orderOf a → a ^ orderOf a = 1",
    "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → ∃ n ≠ 0, x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n ≠ 0, x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → ∃ n, n > 0 ∧ x ^ n = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt":
   "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree ↥H → Monoid.IsTorsionFree G"]},
  {"theorem":
   "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ⇑f → Function.Surjective ⇑f",
   "some-correct": null,
   "prompt":
   "Every injective homomorphism from a finitely generated free group to itself is surjective.",
   "groups":
   [["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ⇑f → Function.Surjective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ⇑f → Function.Surjective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ⇑f → Function.Surjective ⇑f"],
    ["∀ {ι : Type u_1} [inst : Fintype ι] (f : FreeGroup ι →* FreeGroup ι), Function.Injective ⇑f → Function.Surjective ⇑f"],
    ["∀ {α : Type u} {G : Type v} [inst : Group G] [inst_1 : Fintype α] (f : FreeGroup α →* G),\n  Function.Injective ⇑f → Function.Surjective ⇑f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Injective ⇑f → Function.Surjective ⇑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Injective ⇑f → Function.Surjective ⇑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Injective (⇑f) → Function.Surjective (⇑f)",
    "∀ {α : Type u} {G : Type v} [inst : Group G] [inst_1 : Fintype α] (f : FreeGroup α →* G),\n  Function.Injective ⇑f → Function.Surjective ⇑f",
    "∀ {ι : Type u_1} [inst : Fintype ι] (f : FreeGroup ι →* FreeGroup ι),\n  Function.Injective ⇑f → Function.Surjective ⇑f"]},
  {"theorem": "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K",
   "some-correct": null,
   "prompt": "Every division ring is either a field or finite.",
   "groups":
   [["∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K",
     "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K",
     "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K",
     "∀ (D : Type u_1) [inst : DivisionRing D], IsField D ∨ Finite D"],
    ["∀ {R : Type u} [inst : DivisionRing R], IsField R ∨ Finite R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : DivisionRing R], IsField R ∨ Finite R",
    "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K",
    "∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K",
    "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K",
    "Here's a sketch of how you might want to structure this theorem, but note that Lean doesn't currently have a definition for \"finite division ring\" so this might not compile without additional context:\n\n∀ (D : Type u_1) [inst : DivisionRing D], IsField D ∨ Finite D\n"]},
  {"theorem": "∀ n > 1, ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "groups":
   [["∀ n > 1, ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ n > 1, ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"],
    ["∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
     "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"],
    ["∀ (n : ℕ), n = 0 ∨ n = 1 ∨ ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), n > 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), n = 0 ∨ n = 1 ∨ ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), n > 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), n > 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"]},
  {"theorem": "∀ {n : ℕ}, Even n → ∃ m, m * m = n",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "groups":
   [["∀ {n : ℕ}, Even n → ∃ m, m * m = n"],
    ["∀ {n : ℕ}, 2 ∣ n ^ 2 → ∃ m, 2 * m = n ∧ (2 * m) ^ 2 = n ^ 2"],
    ["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2"],
    ["∀ {n : ℕ}, Even n ↔ ∃ m, n = m ^ 2"],
    ["∀ {n : ℕ}, Even (n ^ 2) ∨ Odd (n ^ 2)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["This is not a valid theorem because not every even number is a square of a natural number. A correct version could be \"Every perfect square that is even is the square of an even natural number\", which translates to:\n\n∀ {n : ℕ}, 2 ∣ (n ^ 2) → ∃ m, 2 * m = n ∧ (2 * m) ^ 2 = n ^ 2",
    "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2",
    "∀ {n : ℕ}, Even n ↔ ∃ m, n = m ^ 2",
    "This is not a valid theorem as not every even number is the square of a natural number. For example, the number 2 is an even number but is not a square of any natural number. However, if the statement was \"Every square of a natural number is either even or odd\", then the Lean code would be:\n\n∀ {n : ℕ}, Even (n ^ 2) ∨ Odd (n ^ 2)",
    "∀ {n : ℕ}, Even n → ∃ m : ℕ, m * m = n",
    "∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
   "some-correct": null,
   "prompt": "Every normal subgroup of a group has finite index.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H → Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hN : Subgroup.Normal H], Subgroup.FiniteIndex H",
     "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H → Subgroup.FiniteIndex H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H → Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hN : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Normal H → Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hN : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [hN : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [inst_2 : Subgroup.Normal H], Subgroup.FiniteIndex H"]},
  {"theorem":
   "∀ {n : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] {𝕜 : Type u_4} [inst_2 : Field 𝕜] [inst_3 : IsAlgClosed 𝕜]\n  {A : Matrix n n 𝕜} (μ : 𝕜), Polynomial.IsRoot (Matrix.charpoly A) μ",
   "some-correct": null,
   "prompt": "The characteristic polynomial of every matrix has real roots.",
   "groups":
   [["∀ {n : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] {𝕜 : Type u_4} [inst_2 : Field 𝕜] [inst_3 : IsAlgClosed 𝕜]\n  {A : Matrix n n 𝕜} (μ : 𝕜), Polynomial.IsRoot (Matrix.charpoly A) μ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : Type u_2} [inst : Fintype n] [inst_1 : DecidableEq n] {𝕜 : Type u_4} [inst_2 : Field 𝕜] [inst_3 : IsAlgClosed 𝕜]\n  {A : Matrix n n 𝕜}, ∀ μ, Polynomial.IsRoot (Matrix.charpoly A) μ"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] (p : Ideal R), Ideal.IsPrime p → ∃! M, Ideal.IsMaximal M ∧ p ≤ M",
   "some-correct": null,
   "prompt":
   "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] (p : Ideal R), Ideal.IsPrime p → ∃! M, Ideal.IsMaximal M ∧ p ≤ M",
     "∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M"],
    ["∀ {R : Type u} [inst : CommRing R] [IsLocalRing : LocalRing R] {I : Ideal R},\n  Ideal.IsPrime I → ∃! M, Ideal.IsMaximal M ∧ I ≤ M"],
    ["∀ (R : Type u) [inst : CommRing R] [inst_1 : Nontrivial R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M"],
    ["∀ {R : Type u} [inst : CommRing R] [hR : Ideal.IsJacobson R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] [hR : Ideal.IsJacobson R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
    "∀ (R : Type u) [inst : CommRing R] [Nontrivial R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R] (p : Ideal R), Ideal.IsPrime p → ∃! M, Ideal.IsMaximal M ∧ p ≤ M",
    "∀ {R : Type u} [inst : CommRing R] [IsLocalRing : LocalRing R] {I : Ideal R},\n  Ideal.IsPrime I → ∃! M, Ideal.IsMaximal M ∧ I ≤ M",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P → ExistsUnique fun M => Ideal.IsMaximal M ∧ P ≤ M"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],
    ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : LinearOrder β] [inst_2 : UniformSpace β]\n  [inst_3 : ClosedIciTopology β] [inst_4 : Nonempty α] {f : α → β}, UniformContinuous f → BddAbove (Set.range f)",
   "some-correct": null,
   "prompt": "Every uniformly continuous function is bounded above.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : LinearOrder β] [inst_2 : UniformSpace β]\n  [inst_3 : ClosedIciTopology β] [inst_4 : Nonempty α] {f : α → β}, UniformContinuous f → BddAbove (Set.range f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : LinearOrder β] [inst_2 : UniformSpace β] [inst_3 : ClosedIciTopology β]\n  [inst_4 : Nonempty α] {f : α → β}, UniformContinuous f → BddAbove (Set.range f)"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X], (∀ {K : Set X}, IsCompact K → IsClosed K) → CompactSpace X"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
     "∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ {K : Set X}, IsCompact K → IsClosed K) → CompactSpace X"],
    ["∀ {X : Type u_2} [inst : TopologicalSpace X], (∀ {s : Set X}, IsCompact s → IsClosed s) → CompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] (H : ∀ {K : Set X}, IsCompact K → IsClosed K), CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X], \n(∀ (s : Set X), IsCompact s → IsClosed s) → CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X], (∀ {K : Set X}, IsCompact K → IsClosed K) → CompactSpace X",
    "∀ {X : Type u_2} [inst : TopologicalSpace X] (self : ∀ {s : Set X}, IsCompact s → IsClosed s), CompactSpace X",
    "∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ ⦃K : Set X⦄, IsCompact K → IsClosed K) → CompactSpace X",
    "∀ {α : Type u} [inst : TopologicalSpace α], \n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {X : Type u_1} [inst : TopologicalSpace X] (h : ∀ {s : Set X}, IsCompact s → IsClosed s), CompactSpace X"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)"],
    ["∀ {R : Type u_1} [self : CommRing R] (a b : R),\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) → IsIdempotentElem a ∧ IsIdempotentElem b"],
    ["∀ {R : Type u_2} [inst : CommSemiring R] {a b : R},\n  IsIdempotentElem a → IsIdempotentElem b → Commute a b → IsIdempotentElem (a + b)"],
    ["∀ {R : Type u_1} [inst : BooleanRing R] (a b : R), IsIdempotentElem (a + b)"],
    ["∀ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b →\n  IsIdempotentElem (a + b) → IsIdempotentElem a ∧ IsIdempotentElem b",
    "∀ {R : Type u_2} [inst : CommSemiring R] {a b : R},\n  IsIdempotentElem a → IsIdempotentElem b → Commute a b → IsIdempotentElem (a + b)",
    "∀ {R : Type u_1} [inst : BooleanRing R] (a b : R), IsIdempotentElem (a + b)",
    "∀ {R : Type u_1} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)",
    "∀ {R : Type u} [inst : CommRing R] {x y : R},\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)",
    "∀ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x → IsIdempotentElem y → \n  x * y = 0 → IsIdempotentElem (x + y)",
    "∀ {R : Type u_1} [inst : CommRing R] {x y : R}, IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)",
    "∀ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a → IsIdempotentElem b → Commute a b → \nIsIdempotentElem (a + b)"]},
  {"theorem":
   "∀ {α : Type u} {r : α → α → Prop} [inst : IsTrans α r] [inst_1 : IsAntisymm α r],\n  (∃ m, ∀ (a : α), r a m → r m a) → ∃! m, ∀ (a : α), r m a → r a m",
   "some-correct": null,
   "prompt":
   "If a poset has a maximal element, then it has a unique minimal element.",
   "groups":
   [["∀ {α : Type u} {r : α → α → Prop} [inst : IsTrans α r] [inst_1 : IsAntisymm α r],\n  (∃ m, ∀ (a : α), r a m → r m a) → ∃! m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop}, (∃ m, ∀ (a : α), r m a → r a m) → ∃! b, ∀ (a : α), r a b → r b a"],
    ["∀ {α : Type u_1} [self : PartialOrder α] {a : α}, (∃ m, ∀ (b : ?m.38217070), m ≤ b → m = b) → ∃! b, ∀ a_2 ≤ b, a_2 = b"],
    ["∀ {α : Type u_1} [inst : PartialOrder α] {a : α},\n  (∃ b, ∀ (x : ?m.38218336), x ≤ b) → ∃! a_2, ∀ (x : ?m.38218338), a_2 ≤ x"],
    ["∀ {α : Type u_1} {r : α → α → Prop} [inst : IsPartialOrder α r],\n  (∃ m, ∀ (a : α), r m a → r a m) → ∃! m, ∀ (a : α), r a m → r m a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∃ m, ∀ (a : α), r m a → r a m) → (∃! b, ∀ (a : α), r a b → r b a)",
    "∀ {α : Type u_1} [self : PartialOrder α] {a : α},\n  (∃ m, ∀ b, m ≤ b → m = b) → ∃! b, ∀ a, a ≤ b → a = b",
    "∀ {α : Type u_1} [inst : PartialOrder α] {a : α}, (∃ b, ∀ x, x ≤ b) → (∃! a, ∀ x, a ≤ x)",
    "∀ {α : Type u_1} {r : α → α → Prop} [IsPartialOrder α r],\n  (∃ m, ∀ a, r m a → r a m) → ∃! m, ∀ a, r a m → r m a",
    "∀ {α : Type u} {r : α → α → Prop} [inst : IsTrans α r] [inst_1 : IsAntisymm α r],\n  (∃ m, ∀ a, r a m → r m a) → ∃! m, ∀ a, r m a → r a m"]},
  {"theorem": "∀ {α : Type u} [inst : AddCommGroup α], IsCyclic (AddAut α)",
   "some-correct": null,
   "prompt": "The automorphism group of an Abelian group is cyclic.",
   "groups": [["∀ {α : Type u} [inst : AddCommGroup α], IsCyclic (AddAut α)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : AddCommGroup α], IsCyclic (AddAut α)"]},
  {"theorem":
   "∀ {f : ↑unitInterval → ↑unitInterval} {x : ↑unitInterval} {n : ℕ},\n  Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "groups":
   [["∀ {f : ↑unitInterval → ↑unitInterval} {x : ↑unitInterval} {n : ℕ},\n  Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y"],
    ["∀ {f : ℝ → ℝ} {x : ℝ},\n  0 ≤ x → x ≤ 1 → Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y ∈ Set.Icc 0 1, Function.IsPeriodicPt f n y"],
    ["∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] {f : α → α} {x : α} {m : ℕ} {n : ℕ},\n  Function.IsFixedPt f x → 0 < m → Function.IsPeriodicPt f m x"],
    ["∀ {f : ℝ → ℝ} {x : ℝ}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, dist y x < 1 ∧ Function.IsPeriodicPt f n y"],
    ["∀ {f : Unit → Unit} {x : Unit}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ x', Function.IsPeriodicPt f n x'"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {f : ℝ → ℝ} {x : ℝ},\n  0 ≤ x → x ≤ 1 → Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y ∈ Set.Icc 0 1, Function.IsPeriodicPt f n y",
    "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α]\n  {f : α → α} {x : α} {m n : ℕ},\n  Function.IsFixedPt f x → 0 < m → Function.IsPeriodicPt f m x",
    "∀ {f : ℝ → ℝ} {x : ℝ},\n  HasSubset.Subset (Set.Icc 0 1) (Set.fixedPoints f) →\n  Function.IsFixedPt f x → ∀ n : ℕ, 0 < n → ∃ y, dist y x < 1 ∧ Function.IsPeriodicPt f n y",
    "∀ {f : unit → unit} {x : unit}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ x', Function.IsPeriodicPt f n x'",
    "∀ {f : unit_interval → unit_interval} {x : unit_interval} {n : ℕ},\n  Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y",
    "∀ {α : Type u_1} {f : α → α} {x : α} {n : ℕ},\n  Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y"]},
  {"theorem": "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets contains the union of their complements.",
   "groups":
   [["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ≤ sᶜ ∪ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ"],
    ["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∪ tᶜ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ≤ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), HasSubset.Subset ((s ∪ t)ᶜ) (sᶜ ∪ tᶜ)",
    "∀ {α : Type u} (s t : Set α), HasSubset.Subset ((s ∪ t)ᶜ) (sᶜ ∪ tᶜ)",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ≤ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ≤ sᶜ ∪ tᶜ"]},
  {"theorem": "∀ (q : ℚ), ∃ p, p * p = q",
   "some-correct": null,
   "prompt": "The square root of an rational number is rational.",
   "groups":
   [["∀ (q : ℚ), ∃ p, p * p = q",
     "∀ (q : ℚ), ∃ r, r * r = q",
     "∀ (r : ℚ), ∃ q, q * q = r",
     "∀ (q : ℚ), ∃ r, r * r = q ∨ -r * -r = q",
     "∀ (q : ℚ), ∃ p, p * p = q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (q : ℚ), ∃ p : ℚ, p * p = q",
    "∀ (q : ℚ), ∃ r : ℚ, r * r = q",
    "∀ (r : ℚ), ∃ (q : ℚ), q*q = r",
    "∀ (q : ℚ), ∃ r : ℚ, (r * r = q) ∨ ((-r) * (-r) = q)",
    "∀ (q : ℚ), ∃ p : ℚ, p * p = q",
    "∀ (q : ℚ), ∃ r : ℚ, r*r = q",
    "∀ {a : ℚ}, ∃ q : ℚ, (q * q) = a",
    "∀ {r : ℚ}, ∃ q : ℚ, q * q = r"]},
  {"theorem":
   "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → [self : Module.Free R M] → CommRing R",
   "some-correct": null,
   "prompt": "If a module over a ring is free, then the ring is commutative.",
   "groups":
   [["{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → [self : Module.Free R M] → CommRing R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [self : Module.Free R M], CommRing R"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : NonAssocSemiring R] (U : Submonoid R) [inst_1 : Group ↥U], IsCommutative R Mul.mul",
   "some-correct": null,
   "prompt":
   "If the set of units of a ring forms a group then the ring is commutative.",
   "groups":
   [["∀ {R : Type u_1} [inst : NonAssocSemiring R] (U : Submonoid R) [inst_1 : Group ↥U], IsCommutative R Mul.mul"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : NonAssocSemiring R] (U : Submonoid R) [inst_1 : Group U], IsCommutative R Mul.mul"]},
  {"theorem": "∀ {n : ℕ}, n > 10 → ∃ m p, m ^ 2 + p = n ∧ Nat.Prime p",
   "some-correct": null,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "groups":
   [["∀ {n : ℕ}, n > 10 → ∃ m p, m ^ 2 + p = n ∧ Nat.Prime p",
     "∀ (n : ℕ), 10 < n → ∃ a b, a ^ 2 + b = n ∧ Nat.Prime b",
     "∀ {n : ℕ}, 10 < n → ∃ a p, a ^ 2 + p = n ∧ Nat.Prime p"],
    ["∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p"],
    ["∀ {n : ℕ}, n > 10 → ∃ x p, Nat.Prime p ∧ n = x ^ 2 + p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, n > 10 → ∃ m p, m ^ 2 + p = n ∧ Nat.Prime p",
    "∀ n : ℕ, 10 < n → ∃ a b : ℕ, a^2 + b = n ∧ Nat.Prime b",
    "∀ {n : ℕ}, n > 10 → ∃ (x : ℕ) (p : ℕ), Nat.Prime p ∧ n = x ^ 2 + p",
    "∀ {n : ℕ}, 10 < n → ∃ (a p : ℕ), a ^ 2 + p = n ∧ Nat.Prime p",
    "∀ {n : ℕ}, n > 10 → ∃ (x p : ℕ), n = x ^ 2 + p ∧ Nat.Prime p",
    "∀ {n : ℕ}, n > 10 → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p",
    "∀ (n : ℕ), n > 10 → ∃ (x : ℕ), ∃ (p : ℕ), Nat.Prime p ∧ n = x ^ 2 + p",
    "∀ (n : ℕ), n > 10 → ∃ a b, n = a^2 + b ∧ Nat.Prime b",
    "∀ (n : ℕ), n > 10 → ∃ (p : ℕ) (h : Nat.Prime p) (x : ℕ), n = x^2 + p",
    "∀ {n : ℕ}, n > 10 → ∃ p a, Nat.Prime p ∧ n = a ^ 2 + p"]},
  {"theorem":
   "∀ {X Y Z : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z] {f : Y → Z}\n  {g : X → Y}, Continuous g → Continuous (f ∘ g) → Continuous f",
   "some-correct": null,
   "prompt":
   "If the composition of two functions is continuous, then each of them is continuous.",
   "groups":
   [["∀ {X Y Z : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z] {f : Y → Z}\n  {g : X → Y}, Continuous g → Continuous (f ∘ g) → Continuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["This theorem is not generally true. The continuity of the composition of two functions does not guarantee the continuity of each function. For example, let f : ℝ → ℝ be defined by f(x) = x for x ≠ 0 and f(0) = 1, and let g : ℝ → ℝ be defined by g(x) = 0 for all x. Then the composition f ∘ g is continuous, but f is not.\n\nHowever, a correct version of a similar statement could be: if g is continuous and the composition f ∘ g is continuous, then f is continuous. In Lean 4, it might be expressed as follows:\n\n∀ {X Y Z : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z]\n  {f : Y → Z} {g : X → Y}, Continuous g → Continuous (f ∘ g) → Continuous f\n\nPlease note that the function g in the composition needs to be continuous in order for the function f to be continuous.\n"]},
  {"theorem":
   "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "groups":
   [["∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
     "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c"],
    ["∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Semigroup S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_2} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c"]},
  {"theorem":
   "∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {a : R},\n  f a = 0 → a = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "groups":
   [["∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {a : R},\n  f a = 0 → a = 0",
     "∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {a : R},\n  f a = 0 → a = 0"],
    ["∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} {a : R}, f a = 0 → a = 0",
     "∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} {a : R}, f a = 0 → a = 0"],
    ["∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S},\n  Function.Injective ⇑f → ∀ (r : R), f r = 0 → r = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} {a : R},\n  f a = 0 → a = 0",
    "∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {a : R},\n  f a = 0 → a = 0",
    "∀ {R : Type u_1} {S : Type u_2} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} (hf : Function.Injective ⇑f)\n  (r : R), f r = 0 → r = 0",
    "∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {f : R →+* S} {a : R}, f a = 0 → a = 0",
    "∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {a : R},\n  f a = 0 → a = 0"]},
  {"theorem": "∀ {P Q : Prop}, (P ↔ Q) → (P → Q) ∧ (Q → P)",
   "some-correct": null,
   "prompt": "Implication `→` is symmetric. If `P → Q` then `Q → P`.",
   "groups": [["∀ {P Q : Prop}, (P ↔ Q) → (P → Q) ∧ (Q → P)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Although the statement is expressed as a theorem, it's important to note that in classical logic, implication is not a symmetric relation. Therefore, the statement \"If `P → Q` then `Q → P`\" is not generally true, and it can't be represented in Lean without additional assumptions. However, if we consider only the cases where `P` and `Q` are logically equivalent, we can state the desired theorem as follows:\n\n```lean\n∀ {P Q : Prop}, (P ↔ Q) → (P → Q) ∧ (Q → P)\n```"]},
  {"theorem": "∀ {n m : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ n ∧ p ∣ m) ↔ n = m",
   "some-correct": null,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "groups":
   [["∀ {n m : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ n ∧ p ∣ m) ↔ n = m",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
     "∀ {a b : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ a ∧ p ∣ b) ↔ a = b",
     "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n m : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ n ∧ p ∣ m) ↔ n = m",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {a b : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ a ∧ p ∣ b) ↔ a = b",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n"]}],
 "elaborated": 37}