{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["If every proper closed subset of a topological space is compact, then the space itself is compact.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {p : ℕ}, Nat.Prime p → p ≡ 1 [MOD 4] → ∃ x y, p = x ^ 2 + y ^ 2",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "groups":
   [["∀ {p : ℕ}, Nat.Prime p → p ≡ 1 [MOD 4] → ∃ x y, p = x ^ 2 + y ^ 2",
     "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2"],
    ["∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"],
    ["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [inst: Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ}, Nat.Prime p → p ≡ 1 [MOD 4] → ∃ x y, p = x ^ 2 + y ^ 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ {p : ℕ}, Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p",
    "∀ (p : ℕ) [Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"]},
  {"theorem":
   "∀ {a b x y z w p q r s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 → ∃ u v t s, a * b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b x y z w p q r s : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 → ∃ u v t s, a * b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2",
     "∀ (a b c d w x y z : ℕ),\n  ∃ p q r s, (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ {a b x y z w u v s t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ r q p n, a * b = r ^ 2 + q ^ 2 + p ^ 2 + n ^ 2"],
    ["∀ {R : Type u_1} [inst : CommRing R] (a b : R), ∃ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2"],
    ["∀ {R : Type u_1} [inst : CommRing R] {a b c d w x y z : R},\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) =\n    (a * w - b * x - c * y - d * z) ^ 2 + (a * x + b * w + c * z - d * y) ^ 2 + (a * y - b * z + c * w + d * x) ^ 2 +\n      (a * z + b * y - c * x + d * w) ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] {a b c d w x y z : R},\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2) =\n    (a * w - b * x - c * y - d * z) ^ 2 +\n      (a * x + b * w + c * z - d * y) ^ 2 +\n      (a * y - b * z + c * w + d * x) ^ 2 +\n      (a * z + b * y - c * x + d * w) ^ 2",
    "∀ {a b x y z w p q r s : ℕ}, \na = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → \nb = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 → \n∃ u v t s, a * b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2",
    "∀ (a b c d w x y z : ℕ),\n  ∃ p q r s, (a^2 + b^2 + c^2 + d^2) * (w^2 + x^2 + y^2 + z^2) = p^2 + q^2 + r^2  + s^2",
    "∀ {a b x y z w u v s t : ℕ}, \n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → \n  b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → \n  ∃ r q p n, a * b = r ^ 2 + q ^ 2 + p ^ 2 + n ^ 2",
    "∀ {R : Type u_1} [inst : CommRing R] (a b : R),\n  ∃ w x y z : R, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2",
    "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ}, \n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 → \n  b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → \n  ∃ z₁ z₂ z₃ z₄, a * b = z₁ ^ 2 + z₂ ^ 2 + z₃ ^ 2 + z₄ ^ 2",
    "∀ {a b x y z w p q r s : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 → ∃ u v x y, a * b = u ^ 2 + v ^ 2 + x ^ 2 + y ^ 2",
    "∀ {a b x y z w u v r s : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t u, a * b = p ^ 2 + q ^ 2 + t ^ 2 + u ^ 2",
    "∀ {R : Type u_1} [inst : CommRing R] (m n : ℕ),\n  ∃ a b c d, m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 →\n  ∃ e f g h, n = e ^ 2 + f ^ 2 + g ^ 2 + h ^ 2 →\n  ∃ p q r s, m * n = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ {a b u v w x y z : ℕ}, \na = u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2 → \nb = y ^ 2 + z ^ 2 + w ^ 2 + x ^ 2 → \n∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]},
  {"theorem":
   "∀ {α : Type u_4} [self : BooleanRing α] (a b : α), a * b = b * a",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "groups":
   [["∀ {α : Type u_4} [self : BooleanRing α] (a b : α), a * b = b * a",
     "∀ {α : Type u_4} [self : BooleanRing α] (a b : α), a * b = b * a"],
    ["∀ {G : Type u_3} [self : BooleanRing G] (a b : G), a * b = b * a"],
    ["∀ {α : Type u_1} [inst : BooleanRing α] (a b : α), a * b = b * a"],
    ["{α : Type u} → [inst : Semiring α] → (∀ (a : α), a * a = a) → AddCommGroup α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : BooleanRing α] (a b : α), a * b = b * a",
    "∀ {α : Type u_4} [self : BooleanRing α] (a b : α), a * b = b * a",
    "∀ {α : Type u} [inst : Semiring α] (h : ∀ (a : α), a * a = a), AddCommGroup α",
    "∀ {G : Type u_3} [self : BooleanRing G] (a b : G), a * b = b * a",
    "∀ {α : Type u_4} [self : BooleanRing α] (a b : α), a * b = b * a",
    "∀ {α : Type u_1} [BooleanRing α], IsCommutative α Mul.mul",
    "∀ {α : Type u_4} [self : BooleanRing α] (a b : α), a * b = b * a"]},
  {"theorem": "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "groups":
   [["Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}",
     "Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}"],
    ["Set.Infinite {p | Nat.Prime p.1 ∧ Nat.Prime p.2 ∧ p.2 - p.1 = 2}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ × ℕ | Nat.Prime p.1 ∧ Nat.Prime p.2 ∧ p.2 - p.1 = 2}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)}"]},
  {"theorem":
   "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
     "∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
     "∀ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Finite D], IsField D"],
    ["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K"],
    ["∀ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
    "∀ (D : Type u_1) [inst : DivisionRing D] [inst : Finite D], IsField D",
    "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R",
    "∀ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], Field D",
    "∀ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], Field D",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"]},
  {"theorem":
   "∀ {X Y : Type u}, Nonempty (X ↪ Y) → Nonempty (Y ↪ X) → Nonempty (X ≃ Y)",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "groups":
   [["∀ {X Y : Type u}, Nonempty (X ↪ Y) → Nonempty (Y ↪ X) → Nonempty (X ≃ Y)"],
    ["∀ {α : Sort u} {β : Sort v} {f : α → β} {g : β → α}, Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"],
    ["∀ {α β : Type u} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"],
    ["∀ {α : Type u_12} {β : Type u_13} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"],
    ["∀ {α : Type u_12} {β : Type u_13},\n  (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → ∃ f g, Function.Bijective f ∧ Function.Bijective g"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Sort u} {β : Sort v} {f : α → β} {g : β → α}, Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
    "∀ {α β : Type u} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
    "∀ {α β : Type*} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
    "∀ {α β : Type*} (h1 : ∃ (f : α → β), function.injective f) (h2 : ∃ (g : β → α), function.injective g),\n  ∃ (f : α → β) (g : β → α), function.bijective f ∧ function.bijective g",
    "∀ {X Y : Type u} (h₁ : Nonempty (X ↪ Y)) (h₂ : Nonempty (Y ↪ X)), Nonempty (X ≃ Y)",
    "∀ {α : Sort u_1} {β : Sort u_2} (e₁ : Nonempty (α ↪ β)) (e₂ : Nonempty (β ↪ α)), Nonempty (α ≃ β)",
    "∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β)",
    "∀ {α : Sort u_1} {β : Sort u_2}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)",
    "∀ {X Y : Type u} (f : X → Y) (g : Y → X),\n  Function.Injective f → Function.Injective g →\n  ∃ (h : X ≃ Y), True",
    "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} {g : β → α},\n  Function.Injective f → Function.Injective g → ∃ (h : α ≃ β), True"]},
  {"theorem":
   "∀ {V : Type u} {G : SimpleGraph V} [inst : Fintype V] [inst : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, G.Adj u v ∧ G.Adj u w) → ∃ v, ∀ (w : V), w ≠ v → G.Adj v w",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "groups":
   [["∀ {V : Type u} {G : SimpleGraph V} [inst : Fintype V] [inst : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, G.Adj u v ∧ G.Adj u w) → ∃ v, ∀ (w : V), w ≠ v → G.Adj v w"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! x, G.Adj v x ∧ G.Adj w x) → ∃ v, ∀ (w : V), w ≠ v → G.Adj v w"],
    ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V],\n  (∀ (v w : V), ∃! x, G.Adj x v ∧ G.Adj x w) → ∃ x, ∀ (v : V), v ≠ x → G.Adj x v"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), ∃! (x : V), G.Adj v x ∧ G.Adj w x) → ∃ (v : V), ∀ (w : V), w ≠ v → G.Adj v w",
    "∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V], \n  (∀ (v w : V), ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) → ∃ x, ∀ v ≠ x, SimpleGraph.Adj G x v",
    "∀ {V : Type u} {G : SimpleGraph V} [Fintype V] [DecidableRel G.Adj],\n (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G u v ∧ SimpleGraph.Adj G u w) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"]},
  {"theorem":
   "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), Set.Nonempty s → ∃ a, ∀ b ∈ s, r b a ∨ b = a) →\n    (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) → ∃ m, ∀ (a : α), r m a → r a m",
   "some-correct": null,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "groups":
   [["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), Set.Nonempty s → ∃ a, ∀ b ∈ s, r b a ∨ b = a) →\n    (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) → ∃ m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop} [self : IsPartialOrder α r] {S : Set α},\n  Set.Nonempty S → (∀ (c : Set α), IsChain r c → c ⊆ S → ∃ ub ∈ S, ∀ a ∈ c, r a ub) → ∃ m ∈ S, ∀ a ∈ S, r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop} [inst : IsRefl α r] [inst : IsTrans α r],\n  (∀ (s : Set α), IsChain r s → ∃ ub, ∀ a ∈ s, r a ub) → ∃ m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), ∃ a, ∀ b ∈ s, r b a) →\n    (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) → ∃ m, ∀ (a : α), r m a → r a m"],
    ["∀ {α : Type u_1} [inst : PartialOrder α] {S : Set α},\n  Set.Nonempty S → (∀ c ⊆ S, IsChain LE.le c → ∃ ub ∈ S, ∀ a ∈ c, a ≤ ub) → ∃ m ∈ S, ∀ a ∈ S, m ≤ a → a = m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {r : α → α → Prop} [self : IsPartialOrder α r] {S : Set α}, \n  Set.Nonempty S → (∀ (c : Set α), IsChain r c → c ⊆ S → ∃ ub ∈ S, ∀ a ∈ c, r a ub) → \n    ∃ m ∈ S, ∀ a ∈ S, r m a → r a m",
    "∀ {α : Type u_1} {r : α → α → Prop} [IsRefl α r] [IsTrans α r],\n  (∀ (s : Set α), IsChain r s → ∃ ub, ∀ (a : α), a ∈ s → r a ub)\n    → (∃ m : α, ∀ (a : α), r m a → r a m)",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), ∃ a, ∀ b ∈ s, r b a) → \n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) →\n  ∃ m, ∀ (a : α), r m a → r a m",
    "∀ {α : Type u_1} [inst : PartialOrder α] {S : Set α},\n  Set.Nonempty S → (∀ c ⊆ S, IsChain LE.le c → ∃ ub ∈ S, ∀ a ∈ c, a ≤ ub) → ∃ m ∈ S, ∀ a ∈ S, m ≤ a → a = m",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (s : Set α), Set.Nonempty s → ∃ (a : α), ∀ (b : α), b ∈ s → r b a ∨ b = a) → \n  (∀ (c : Set α), IsChain r c → ∃ (ub : α), ∀ (a : α), a ∈ c → r a ub) →\n    ∃ (m : α), ∀ (a : α), r m a → r a m",
    "∀ {α : Type u_1} {r : α → α → Prop}, \n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) → ∃ m, ∀ a, r m a → r a m",
    "∀ {α : Type u_1} {r : α → α → Prop} [_inst_1 : PartialOrder α],\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ a ∈ c, r a ub) →\n  Nonempty α → ∃ m, ∀ (a : α), r m a → r a m",
    "∀ {α : Type u_1} {r : α → α → Prop} {s : Set α}, \n  Set.Nonempty s → \n  (∀c, IsChain r c → c ⊆ s → ∃ ub ∈ s, ∀ a ∈ c, r a ub) → \n  ∃ m ∈ s, ∀a ∈ s, r m a → r a m"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] \n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] \n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] \n  {g : β → γ} {f : α → β}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : β → γ} {f : α → β},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] \n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [UniformSpace α] [UniformSpace β] [UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]},
  {"theorem":
   "∀ {X : Type u_2} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x ∈ s, f x = 0 ∧ ∀ x ∈ t, f x = 1",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "groups":
   [["∀ {X : Type u_2} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x ∈ s, f x = 0 ∧ ∀ x ∈ t, f x = 1"],
    ["∀ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (s t : Set X),\n      IsClosed s →\n        IsClosed t →\n          Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : X), f x ∈ Set.Icc 0 1 ∧ (∀ x ∈ s, f x = 0) ∧ ∀ x ∈ t, f x = 1"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x ∈ s, f x = 0 ∧ x ∈ t → f x = 1"],
    ["∀ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ ∀ x ∈ t, f x = 1"],
    ["∀ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (s t : Set X), Disjoint s t → IsClosed s → IsClosed t → ∃ f, Continuous f ∧ ∀ (x : X), f x = 0 ∨ f x = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u} [inst : TopologicalSpace X], NormalSpace X ↔\n  ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x, f x ∈ Set.Icc (0 : ℝ) 1 ∧\n    (∀ x ∈ s, f x = 0) ∧ ∀ x ∈ t, f x = 1",
    "∀ {X : Type u_1} [inst : TopologicalSpace X], NormalSpace X ↔ ∀ (s t : Set X),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : X), x ∈ s → f x = 0 ∧ x ∈ t → f x = 1",
    "∀ {X : Type u} [inst : TopologicalSpace X], NormalSpace X ↔\n  ∀ s t : Set X, IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ (∀ x ∈ s, f x = 0) ∧ (∀ x ∈ t, f x = 1)",
    "∀ {X : Type u} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n  ∀ (s t : Set X), Disjoint s t → IsClosed s → IsClosed t → ∃ f, Continuous f ∧ ∀ (x : X), f x = 0 ∨ f x = 1",
    "∀ {X : Type u_2} [TopologicalSpace X], NormalSpace X ↔ ∀ (s t : Set X), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : X), x ∈ s → f x = 0 ∧ ∀ (x : X), x ∈ t → f x = 1",
    "∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ s t : Set α, IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x, (x ∈ s → f x = 0) ∧ (x ∈ t → f x = 1)"]},
  {"theorem":
   "∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → ∀ n > 0, ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "groups":
   [["∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → ∀ n > 0, ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x",
     "∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → ∀ n > 0, ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x",
     "∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), 0 < n → ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x"],
    ["∀ {f : ℝ → ℝ} {x : ℝ}, Function.IsPeriodicPt f 3 x → ∀ n > 0, ∃ y, Function.IsPeriodicPt f n y"],
    ["∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 0.5 → ∀ (n : ℕ), 0 < n → ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {f : ℝ → ℝ}, (∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f 3 x) → ∀ n > 0, ∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, (∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f 3 x) → ∀ n : ℕ, n > 0 → ∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc (0 : ℝ) (1 : ℝ), Function.IsPeriodicPt f 3 x) →\n    ∀ n, 0 < n → ∃ x ∈ Set.Icc (0 : ℝ) (1 : ℝ), Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, Function.IsPeriodicPt f 3 0.5 → ∀ n : ℕ, 0 < n → ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ} {x : ℝ}, Function.IsPeriodicPt f 3 x → \n  (∀ (n : ℕ), n > 0 → ∃ y, Function.IsPeriodicPt f n y)",
    "∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc (0 : ℝ) (1 : ℝ), Function.IsPeriodicPt f 3 x) →\n  ∀ n : ℕ, 0 < n → ∃ x ∈ Set.Icc (0 : ℝ) (1 : ℝ), Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, (∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f 3 x) → ∀ n, n > 0 → ∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, (0 ≤ f ∧ f ≤ 1) → ∃ (x : ℝ), Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), Function.IsPeriodicPt f n y",
    "∀ {f : ℝ → ℝ}, (∃ x ∈ Set.Icc (0 : ℝ) 1, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x, Function.IsPeriodicPt f n x"]},
  {"theorem":
   "{C : Type u} →\n  [category : CategoryTheory.Category.{?u.19312857, u} C] →\n    [has_terminal : CategoryTheory.Limits.HasTerminal C] → Unique (CategoryTheory.Limits.IsTerminal (⊤_ C))",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "groups":
   [["{C : Type u} →\n  [category : CategoryTheory.Category.{?u.19312857, u} C] →\n    [has_terminal : CategoryTheory.Limits.HasTerminal C] → Unique (CategoryTheory.Limits.IsTerminal (⊤_ C))"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {C : Type u} [category : CategoryTheory.Category C] [has_terminal : CategoryTheory.Limits.HasTerminal C],\n  unique (CategoryTheory.Limits.IsTerminal (⊤_ C))"]},
  {"theorem": "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "groups":
   [["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
     "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), HasCompl.compl (s ∪ t) = HasCompl.compl s ∩ HasCompl.compl t",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (s t : Set α), HasCompl.compl (s ∪ t) = HasCompl.compl s ∩ HasCompl.compl t",
    "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]},
  {"theorem": "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "groups":
   [["∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
     "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
     "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
     "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
     "∀ {n m p : ℕ}, 0 < n → 0 < m → ¬n ^ 3 + m ^ 3 = p ^ 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → a^3 + b^3 ≠ c^3",
    "∀ {n m p : ℕ}, 0 < n → 0 < m → ¬(n^3 + m^3 = p^3)",
    "∀ {x y z : ℕ}, 0 < x → 0 < y → ¬(x ^ 3 + y ^ 3 = z ^ 3)",
    "∀ {a b c : ℕ}, 0 < a → 0 < b → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ {n m l : ℕ}, n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ l ^ 3",
    "∀ {a b c : ℕ}, 0 < a → 0 < b → a ^ 3 + b ^ 3 ≠ c ^ 3",
    "∀ {a b c : ℕ}, a > 0 → b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y",
     "∀ {G : Type u_1} [inst : Group G], (∀ (g : G), orderOf g = 2) → ∀ (a b : G), Commute a b",
     "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), x * y = y * x"],
    ["∀ {G : Type u_1} [inst : Group G], (∀ (g : G), g ^ 2 = 1) → ∀ (x y : G), x * y = y * x",
     "∀ {G : Type u_1} [inst : Group G], (∀ (g : G), g ^ 2 = 1) → ∀ (a b : G), a * b = b * a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y",
    "∀ {G : Type u_1} [inst : Group G],\n  (∀ g : G, orderOf g = 2) → ∀ a b : G, Commute a b",
    "∀ {G : Type u_1} [inst : Group G], (∀ g : G, g ^ 2 = 1) → ∀ x y : G, x * y = y * x",
    "∀ {G : Type u_1} [inst : Group G], (∀ g : G, g^2 = 1) → ∀ a b : G, a * b = b * a",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), x * y = y * x",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (x y : G), Commute x y",
    "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), orderOf x = 2) → ∀ (a b : G), a * b = b * a",
    "∀ {G : Type u_1} [inst : Group G], (∀ x : G, x * x = 1) → ∀ x y : G, x * y = y * x",
    "∀ {G : Type u_1} [inst : Group G], (∀ g : G, g * g = 1) → (∀ g h : G, g * h = h * g)"]},
  {"theorem": "∀ (n : ℕ), Even (n * (n + 1))",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "groups":
   [["∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))",
     "∀ (n : ℕ), Even (n * (n + 1))"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))",
    "∀ (n : ℕ), Even (n * (n + 1))"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
   "some-correct": null,
   "prompt": "Every index 2 subgroup of a group is normal.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
     "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ (G : Type u_1) [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
     "∀ {G : Type u_1} [inst : Group G] [hN : IsFreeGroup G], Monoid.IsTorsionFree G"],
    ["∀ (α : Type u_1) [inst : Semigroup α], Monoid.IsTorsionFree (FreeGroup α)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [h : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ (α : Type u_1) [inst : Semigroup α], Monoid.IsTorsionFree (FreeGroup α)",
    "∀ {G : Type u_1} [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ (G : Type u_1) [inst : Group G] [hG : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] [hN : IsFreeGroup G], Monoid.IsTorsionFree G",
    "∀ {A : Type u_1} [inst : Group A], IsFreeGroup A → Monoid.IsTorsionFree A"]},
  {"theorem": "∀ n > 1, ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "groups":
   [["∀ n > 1, ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ {n : ℕ}, n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ n > 1, ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ n > 1, ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
    "∀ {n : ℕ}, n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
    "∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G → Subsingleton G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G"]},
  {"theorem":
   "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
     "∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
     "∀ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Finite D], IsField D"],
    ["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K"],
    ["∀ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (D : Type u_1) [inst : DivisionRing D] [inst_1 : Fintype D], IsField D",
    "∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Finite K], IsField K",
    "∀ (D : Type u_1) [inst : Finite D] [inst_1 : DivisionRing D], IsField D",
    "∀ (D : Type u_1) [inst : DivisionRing D] [inst : Finite D], IsField D",
    "∀ (R : Type u_1) [inst : DivisionRing R] [inst_1 : Fintype R], IsField R",
    "∀ {D : Type u_1} [inst : Finite D] [inst_1 : DivisionRing D], Field D",
    "∀ (D : Type u_1) [inst : Finite D] [inst : DivisionRing D], Field D",
    "∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K",
    "∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X"],
    ["∀ {X : Type u} [fintype : Fintype X] [inst : TopologicalSpace X], CompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [fintype : Fintype X] [inst : TopologicalSpace X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : Finite X], CompactSpace X"]},
  {"theorem":
   "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f",
   "some-correct": null,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "groups":
   [["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f",
     "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ⇑f → Function.Injective ⇑f"],
    ["∀ {α : Type u} {F : Type v} [inst : AddCommGroup F] [inst_1 : Group F] (f : F →* F),\n  (∃ S, Subgroup.closure S = ⊤ ∧ Set.Finite S) → Function.Surjective ⇑f → Function.Injective ⇑f"],
    ["∀ {ι : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype ι] (f : FreeGroup ι →* G),\n  Function.Surjective ⇑f → Function.Injective ⇑f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ⇑f → Function.Injective ⇑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ⇑f → Function.Injective ⇑f",
    "∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ⇑f → Function.Injective ⇑f",
    "∀ {ι : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype ι] (f : FreeGroup ι →* G),\n  Function.Surjective ⇑f → Function.Injective ⇑f",
    "∀ {α : Type u} {F : Type v} [inst : AddCommGroup F] [inst_1 : Group F] (f : F →* F),\n  (∃ (S : Set F), Subgroup.closure S = ⊤ ∧ Set.Finite S) → Function.Surjective ⇑f → Function.Injective ⇑f"]},
  {"theorem":
   "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "groups":
   [["∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n",
     "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + q = n"],
    ["∀ n > 2, n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ a + b = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a + b = n",
    "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p + q = n",
    "∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p + q = n",
    "∀ {n : ℕ}, n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a + b = n",
    "∀ {n : ℕ}, n > 2 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q",
    "∀ {n : ℕ}, 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]},
  {"theorem":
   "∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M),\n  (Polynomial.aeval f) (LinearMap.charpoly f) = 0",
   "some-correct": null,
   "prompt": "Every matrix satisfies its own characteristic polynomial.",
   "groups":
   [["∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M),\n  (Polynomial.aeval f) (LinearMap.charpoly f) = 0"],
    ["∀ {𝕜 : Type u_1} {n : Type u_2} [inst : Field 𝕜] [inst_1 : DecidableEq n] [inst_2 : Fintype n] {M : Matrix n n 𝕜},\n  Polynomial.eval₂ (Matrix.scalar n) M (Matrix.charpoly M) = 0"],
    ["∀ {R : Type u_1} {n : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : DecidableEq n]\n  [inst_3 : Fintype n] (M : Matrix n n R), Polynomial.eval₂ (Matrix.scalar n) M (Matrix.charpoly M) = 0"],
    ["∀ {M : Type u_1} [inst : CommRing M] [inst_1 : IsDomain M] {n : Type u_2} [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  (A : Matrix n n M), (Polynomial.aeval A) (Matrix.charpoly A) = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {𝕜 : Type u_1} {n : Type u_2} [inst : Field 𝕜] [inst_1 : DecidableEq n] [inst_2 : Fintype n] {M : Matrix n n 𝕜},\n  Polynomial.eval₂ (Matrix.scalar n) M (Matrix.charpoly M) = 0",
    "∀ {R : Type u_1} {n : Type u_2} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  (M : Matrix n n R), ((Matrix.charpoly M).eval₂ (Matrix.scalar n) M) = 0",
    "∀ {M : Type u_1} [inst : CommRing M] [inst_1 : IsDomain M] {n : Type u_2} [inst_2 : DecidableEq n] [inst_3 : Fintype n]\n  (A : Matrix n n M), Polynomial.aeval A (Matrix.charpoly A) = 0",
    "∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : Nontrivial R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M] [inst_5 : Module.Finite R M] (f : M →ₗ[R] M), Polynomial.aeval f (LinearMap.charpoly f) = 0"]},
  {"theorem": "∀ {r : ℝ}, Irrational r → r ≠ 0 → Irrational (Real.sqrt r)",
   "some-correct": null,
   "prompt": "The square root of an irrational number is irrational.",
   "groups":
   [["∀ {r : ℝ}, Irrational r → r ≠ 0 → Irrational (Real.sqrt r)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → x ≠ 0 → Irrational (Real.sqrt x)",
     "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)"],
    ["∀ {r : ℝ}, Irrational r → 0 < r → Irrational (Real.sqrt r)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {r : ℝ}, Irrational r → r ≠ 0 → Irrational (Real.sqrt r)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → x ≠ 0 → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {r : ℝ}, Irrational r → 0 < r → Irrational (Real.sqrt r)",
    "∀ (r : ℝ), Irrational r → Irrational (Real.sqrt r)",
    "∀ {x : ℝ}, Irrational x → x ≥ 0 → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)",
    "∀ {x : ℝ}, Irrational x → x ≠ 0 → Irrational (Real.sqrt x)",
    "∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)"]},
  {"theorem": "∀ {n : ℕ}, Even (n ^ 2) → Even n",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "groups":
   [["∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n",
     "∀ {n : ℕ}, Even (n ^ 2) → Even n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n^2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℤ}, Even (n ^ 2) → Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n",
    "∀ {n : ℤ}, Even (n ^ 2) ↔ Even n",
    "∀ {n : ℕ}, Even (n ^ 2) → Even n"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"],
    ["∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"],
    ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R] (P : Ideal R),\n  Ideal.IsPrime P → Ideal.IsMaximal P"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R]\n(P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.1 = p.2}",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.1 = p.2}",
     "∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.1 = p.2}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ↔ IsClosed {p : X × X | p.fst = p.snd}",
    "∀ {X : Type u} [inst : TopologicalSpace X],\n  T2Space X ↔ IsClosed {p : X × X | p.fst = p.snd}"]},
  {"theorem":
   "∀ {α : Type u} [t : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "groups":
   [["∀ {α : Type u} [t : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
     "∀ {α : Type u} [t : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsOpen t ∧ x ∈ t ∧ t ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
     "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [t : TopologicalSpace α] {s : Set α}, (∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [t : TopologicalSpace α] {s : Set α}, \n(∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, \n  (∀x ∈ s, ∃t, IsOpen t ∧ x ∈ t ∧ t ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [TopologicalSpace α] {s : Set α}, \n(∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} {s : Set α} [TopologicalSpace α], \n  (∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [t : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s",
    "∀ {α : Type u} [t : TopologicalSpace α] (s : Set α),\n  (∀x ∈ s, ∃u, IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x"],
    ["∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ (g : ℕ), g ≠ 1 → ¬IsOfFinOrder g"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ g, g ≠ 1 → ¬IsOfFinOrder g",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ¬ IsOfFinOrder x",
    "∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬ IsOfFinOrder x",
    "∀ {G : Type u} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] {x : G}, x ≠ 1 → ¬IsOfFinOrder x"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R),\n  IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
   "some-correct": null,
   "prompt":
   "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.",
   "groups":
   [["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R),\n  IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
     "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) {x : R},\n  IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0"],
    ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) (u : R),\n  IsUnit u ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v u = 0"],
    ["∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] {Γ₀ : Type u_3} [inst_2 : LinearOrderedCommMonoidWithZero Γ₀]\n  {v : Valuation A Γ₀} [inst_3 : DiscreteValuationRing A] (u : A), IsUnit u ↔ v u = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] \n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R), IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
    "∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] {Γ₀ : Type u_3} [inst_2 : LinearOrderedCommMonoidWithZero Γ₀]\n  {v : Valuation A Γ₀} [inst_3 : DiscreteValuationRing A], ∀ (u : A), IsUnit u ↔ v u = 0",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) {x : R}, IsUnit x ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v x = 0",
    "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDedekindDomain R] \n  (v : IsDedekindDomain.HeightOneSpectrum R) (u : R), IsUnit u ↔ IsDedekindDomain.HeightOneSpectrum.intValuationDef v u = 0"]},
  {"theorem":
   "∀ {a b : ℕ}, Nat.Coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
   "some-correct": null,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "groups":
   [["∀ {a b : ℕ}, Nat.Coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.Coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y",
     "∀ {a b : ℕ}, Nat.Coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N ∧ a * x + b * y ∈ Set.Ici N"],
    ["∀ {a b N : ℕ}, Nat.Coprime a b → N ≥ a * b → ∃ x y, a * x + b * y = N"],
    ["∀ {a b : ℕ}, Nat.Coprime a b → ∃ N, ∀ (n : ℕ), N ≤ n → ∃ x y, a * x + b * y = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b : ℕ}, Nat.Coprime a b → ∀ (N : ℕ), ∃ x y : ℕ, N ≤ a * x + b * y",
    "∀ {a b : ℕ}, Nat.Coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y",
    "∀ {a b : ℕ}, Nat.Coprime a b → ∀ N : ℕ, ∃ x y : ℕ, a * x + b * y ≥ N ∧ a * x + b * y ∈ Set.Ici N",
    "∀ {a b : ℕ}, Nat.Coprime a b → ∃ (N : ℕ), ∀ (n : ℕ), N ≤ n → ∃ (x y : ℕ), a * x + b * y = n",
    "∀ {a b N : ℕ}, Nat.Coprime a b → N ≥ a * b → ∃ (x y : ℕ), a * x + b * y = N",
    "∀ a b : ℕ, Nat.Coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y = N ∧ N ≥ a * b - a - b",
    "∀ {a b : ℕ}, Nat.Coprime a b → ∀ {N : ℕ}, ∃ x y : ℕ, N ≤ a * x + b * y",
    "∀ {a b : ℕ}, Nat.Coprime a b → ∃ N, ∀ n ≥ N, ∃ i j, i * a + j * b = n",
    "∀ {a b : ℕ}, Nat.Coprime a b → ∀ {N : ℕ}, N ≥ a * b - (a + b) → ∃ x y, N = a * x + b * y",
    "∀ {a b : ℕ}, Nat.Coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y = N ∧ max a b ≤ N"]},
  {"theorem": "(K : Type u_1) → [inst : Field K] → Ring K",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "groups":
   [["(K : Type u_1) → [inst : Field K] → Ring K",
     "(K : Type u_1) → [inst : Field K] → Ring K"],
    ["{K : Type u} → [inst : Field K] → Ring K"],
    ["{K : Type u_1} → [inst : Field K] → Ring K"],
    ["(K : Type u) → [inst : Field K] → Ring K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u_1) [inst : Field K], Ring K",
    "∀ {K : Type u_1} [inst : Field K], Ring K",
    "∀ (K : Type u) [inst : Field K], Ring K",
    "∀ (K : Type u_1) [inst : Field K], Ring K",
    "∀ {K : Type u} [inst : Field K], Ring K",
    "∀ (K : Type u) [inst : Field K], Ring K",
    "∀ {K : Type u} [inst : Field K], Ring K",
    "∀ (F : Type u) [inst : Field F], Ring F",
    "∀ {K : Type u} [inst : Field K], Ring K",
    "∀ (K : Type u) [inst : Field K], Ring K"]},
  {"theorem": "{R : Type u_1} → [inst : Ring R] → Group Rˣ",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "groups":
   [["{R : Type u_1} → [inst : Ring R] → Group Rˣ",
     "{R : Type u_1} → [inst : Ring R] → Group Rˣ"],
    ["{R : Type u_1} → [inst : MonoidWithZero R] → Group Rˣ"],
    ["{R : Type u_1} → [inst : MonoidWithZero R] → Group Rˣ"],
    ["{R : Type u} → [inst : Ring R] → Group Rˣ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], Group Rˣ",
    "∀ {R : Type u_1} [inst : MonoidWithZero R], Group Rˣ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ",
    "∀ {R : Type u_1} [inst : MonoidWithZero R], Group (Units R)",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ",
    "∀ {R : Type u_1} [inst : Ring R], Group Rˣ",
    "∀ {R : Type u} [inst : Ring R], Group Rˣ",
    "∀ {R : Type u} [inst : MonoidWithZero R], Group (Units R)"]},
  {"theorem":
   "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "groups":
   [["∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
     "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
     "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
     "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H"],
    ["∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H], Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], \n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H], \n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G H : Type u_1} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  (Monoid.IsTorsionFree (G × H)) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H",
    "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H"]}],
 "elaborated": 37}