{"theorem-type": "(∀ {α : Type u_2} [inst : DistribLattice α] {a : α} (a_1 : SupIrred a), SupPrime a)", "theorem": "theorem SupIrred.supPrime : (∀ {α : Type u_2} [inst : DistribLattice α] {a : α} (a_1 : SupIrred a), SupPrime a) := by\n  sorry", "name": "SupIrred.supPrime", "lemma-type": "{α : Type u_2} →\n  [inst : DistribLattice α] →\n    {a : α} →\n      {α : Type u_2} →\n        [DistribLattice α] →\n          {a : α} →\n            (h : ∀ ⦃b : α⦄ ⦃c : α⦄ (a_1 : b ⊔ c = a), (b = a) ∨ (c = a)) →\n              (b : α) → (c : α) → ∀ (a_1 : a ⊓ (b ⊔ c) = a), (a ⊓ b = a) ∨ (a ⊓ c = a)", "lemma": "theorem aux.13082634676663934207 {α : Type u_2} [inst : DistribLattice α] {a : α} {α : Type u_2} [DistribLattice α]\n    {a : α} (h : ∀ ⦃b : α⦄ ⦃c : α⦄ (a_1 : b ⊔ c = a), (b = a) ∨ (c = a)) (b : α) (c : α) :\n    ∀ (a_1 : a ⊓ (b ⊔ c) = a), (a ⊓ b = a) ∨ (a ⊓ c = a) := by sorry", "doc_string": "**Alias** of the reverse direction of `supPrime_iff_supIrred`.", "generated": ["theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry ", "theorem LE.intro_neg_succ_le : ∀ {α : Type u} [inst : LinearOrderedSemifield α] (m n : α) [hmn : -m < n], ↑m ≤ dm\n    * ({ ofAdd' m + ofAdd' n)⁻¹ ::ₘᵈ dm ≤ -m; (nm * n)⁻¹ ≤ m + n) := by sorry ", "theorem IsMaximum.supPrime : ∀ {α : Type u_4} [inst : DistribLattice α] {A a : α} {c : Set.Icc 0 a} {p : α} {a0 : p > 0},\n    ✓a0 → Iff(SupIrredSubset q supDisjointSubtractSingleton_subset p c) ↔ SupPrime q :=\n  by sorry ", "theorem Or_iff_not_imp_right : ∀ {a b : Prop}, (a ∨ b) ↔ (¬b → a) := by sorry ", "theorem congr_fun : ∀ {α : Sort u} {β : α → Sort v} {x y : α}, x = y → ⇑x = ��acio x y := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a² : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.18106776281865444945 {α : Type u_2} [inst : DistribLattice α] {a : α} : ↑False = ⊥ := by sorry ", "theorem imp_true_iff : ∀ (a : Prop), (a → True) = True := by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : AddLeftCancelMonoid G] {a : G}, Nat.card ↥(AddSubmonoid.multiples a) = addOrderOf a)", "theorem": "theorem Nat.card_addSubmonoidMultiples :\n    (∀ {G : Type u_1} [inst : AddLeftCancelMonoid G] {a : G}, Nat.card ↥(AddSubmonoid.multiples a) = addOrderOf a) := by\n  sorry", "name": "Nat.card_addSubmonoidMultiples", "lemma-type": "{G : Type u_1} →\n  [AddLeftCancelMonoid G] →\n    {a : G} → (Nat.card ↥(AddSubmonoid.multiples a) = addOrderOf a) = (Nat.card ↥(AddSubmonoid.multiples a) = 0)", "lemma": "theorem aux.3649350544844893990 {G : Type u_1} [AddLeftCancelMonoid G] {a : G} :\n    (Nat.card ↥(AddSubmonoid.multiples a) = addOrderOf a) = (Nat.card ↥(AddSubmonoid.multiples a) = 0) := by sorry", "doc_string": "See also `addOrder_eq_card_multiples`.", "generated": ["theorem Fin.val_fin_add : ∀ {α : Type u_1} (m n : ℕ), (↑(Fin.add m n)).Finval = ↑m + ↑n := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem zpow_add : ∀ (a : G) {m i : ℤ}, m • a = i • a := by sorry ", "_au.3002375686179414252 :\n    let AddSubmonoid.toOrderSubsemiring (AddSubmonoid.preimage Multiplicative.ofAdd ( AddCommMonoid.Submonoid.closure ↑P ) .Carrier) := AddSubmonoid.toOrderSubsemiring ↑PMulSimAdd.P;\n    S n = AddSubmonoid.generator <| AddMonoid.closure ↑S := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {n : Type u_4} [inst : AddGroup n] {v : (a : n) → α},\n  (Matrix.IsSymm (Matrix.circulant v)) ↔ (∀ (i : n), v (-i) = v i))", "theorem": "theorem Matrix.circulant_isSymm_iff :\n    (∀ {α : Type u_1} {n : Type u_4} [inst : AddGroup n] {v : (a : n) → α},\n      (Matrix.IsSymm (Matrix.circulant v)) ↔ (∀ (i : n), v (-i) = v i)) :=\n  by sorry", "name": "Matrix.circulant_isSymm_iff", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "A circulant of `v` is symmetric iff `v` equals its reverse. ", "generated": ["theorem aux.3987032364460452480 {α : Type u_1} {n : Type u_4} [AddGroup n] {v : (a : n) → α}\n    (h : (Matrix.isSymm (Matrix.circulant v)) ↔ (∀ (i : n), v (-i) = v i)) (i : n) : 1 * v i = v i := by sorry ", "theorem add_mul_add.unit :\n    ∀ {α : Type u_1} [inst : NonUnitalSemiring α] {r s : α} (c d : Unit, add_highestPart r c = add_highestPart s c),\n      Nat.coprime r s :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.4665878576240467403 {α : Type u_1} {n : Type u_4} [AddGroup n] {v : (a : n) → α}\n    (h : LinearIndependent α fun (i : AesopMode) ↦ v (AddNeg.neg i)) : Matrix.colConstr n n '' Set.univ =ᶠ[nthems] A\n                [[[val_h2]].a) fun (m1 : Type u_4) (x_1057 : AesopMode) ↦ v]_\n (i : Function.Injective fun (i : n) ↦ f <$M.cardVal i i) =\n ᾽(⟪M * LinearMap.diag (Set.Finite.injection ∘ fun (i : n) ↦ AbsorbsL Filter.atTop (f (fun (j : n) ↦ g j)) (val_h5 h i))) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  r] {a b c : α}, r a b → r b c → r a c := by sorry ", "answer:\n6181246677776827955 {α : Type u_1} {n : Type u_4} [AddGroup n] {v : (a : n) → α} :\n    ((∀ (c : ℤ)\n          (a :\n            c • Matrix.diag (fun (x : n) ↦ mulPair v (c, x)) = transpose v * Matrix.circulant_neg_one v),\n          v (Fin.succ m, m) = v m * v (Fin.succ m) - v m * v (Fin.castSucc m)) →\n        (starMonoidAlgebra fun (x : n) ↦ v (-x)) * Matrix.circulant ((if (0 = -1) then v else - v) · <;> v) = 0) =\n      ((∀ (m₂ : n),\n          (if (* 5 = 0) then\n              starMonoidAlgebra fun (x : n) ↦ v (Neg.neg ⊥))\n            (zmultiplesstar ↑(Fin.succ m)) • starMonoidAlgebra.single m₂ m =\n          0) ↔\n        (∀ (a : n) (a_1 : n) (a_2 : n), v (-a_2) − v -a_2 = v m * v (Fin.succ m)-v m * a a_2 :=\n          true)) :=\n  by sorry ", "theorem ofNat_injective : ∀ {α : Type u} [inst : OrderedSemiring α] [inst_1 : Nontrivial α], Function.Injective OfNat := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a})", "theorem": "theorem Set.Finite.finite_subsets : (∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a}) :=\n  by sorry", "name": "Set.Finite.finite_subsets", "lemma-type": "∀ {α : Type u_1} (s : Finset α), ↑(Finset.powerset s) = Finset.toSet ⁻¹' 𝒫↑s", "lemma": "theorem Finset.coe_powerset : ∀ {α : Type u_1} (s : Finset α), ↑(Finset.powerset s) = Finset.toSet ⁻¹' 𝒫↑s := by sorry", "doc_string": "There are finitely many subsets of a given finite set ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrInst : ∀ {F P : Sort u} {l P1 : LinearOrder  P} _f₂ f_1 e, P1 _f₂ = P1 f_1 → _f₂ e = f_1 e → P = P := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem FiberProd.map_proj :\n    ∀ {γ : FinType} (s : Set (Γ¹ ((fun {a : Set α} ↦ Set.Relab F a ⇑id {b₁, b₂} ≤ b₁) ((fun {a ::: Set x} ↦ α) a))))\n      {{b₁, b₂} = {b₁}', {b₂} = {b₂}'} (* b₁, b₂ -- > (b₁, b2) (set/formality.fstr/f.type) (val_spec eq) (b == b1)\n                             (gsub / gsub)* (_type / SetValFiber_fun : Set ((Type, SFun Γ⁻¹'n₂))}ᶜᶜ *)\n              s, a = a :=\n  by sorry ", "theorem Set.induction_on : ∀ {α : Type u} {p : Set α → Prop} {s : Set α}, p s → (∀ x ∈ s, p {x}) → p s := by sorry ", "theorem Set.not_sFinite_mem:\n    ∀ {α : Type u} [inst : Infinite α], ¬Set.Finite {xs | p xs ↔ ¬(SFinite i(xs.val)))}} := by sorry ", "theorem IsLB.all_upperBound :\n    ∀ {α : Type w} [linOrderedTopologicalSpace α]; [inst : DenselyOrdered α] {b : α} {y z : Set α},\n      IsLUB S b → (∀ x ∈ S, b ≤ x) → BddUpper (Bornology.boundedWeakUpperDf b S) → isLUB S y :=\n  by sorry ", "theorem Set.bUnion_Ioo :\n    ∀ {α : Type u} {p q : α → Prop}, (∀ (x : α), (Qs p) x ∧ (Pq p)) → MeasureTheory.BorelSpace α := by sorry "]}
{"theorem-type": "(∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (s : R) (x : A)\n  (y : A), x * s • y = s • (x * y))", "theorem": "theorem Algebra.mul_smul_comm :\n    (∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (s : R) (x : A)\n      (y : A), x * s • y = s • (x * y)) :=\n  by sorry", "name": "Algebra.mul_smul_comm", "lemma-type": "{R : Type u} →\n  {A : Type w} →\n    [CommSemiring R] →\n      [Semiring A] →\n        [Algebra R A] →\n          (s : R) → (x : A) → (y : A) → (x * s • y = s • (x * y)) = (x * ((algebraMap R A) s * y) = s • (x * y))", "lemma": "theorem aux.12489562634727495675 {R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (s : R) (x : A)\n    (y : A) : (x * s • y = s • (x * y)) = (x * ((algebraMap R A) s * y) = s • (x * y)) := by sorry", "doc_string": "This is just a special case of the global `mul_smul_comm` lemma that requires less typeclass\nsearch (and was here first). ", "generated": ["## Table of Contents\n```lean\nAnd.intro : thisLeans2 = Lean.Parser.Term.matchNullMVar (Term term.2 term.8)\nsmulRefl : (funₚ {c b : Opaque a} (bPa : Opaque a)* { val := c, property p := bPa }) = b := by sorry ", "theorem aux.6450765207835012786 {R : Type u} {A : Type w} [CommSemiring R] [Semiring A] [Algebra R A] (s : R) (x : A)\n    (y : A) : MulOpposite.op (A ×ₘ R) x * s = s • x.re := by sorry ", "theorem comm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsStrictOrder α r] {a b c : α}, r a b → r b c → r a c := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem zero_smul : ∀ (R : Type u) {M : Type v} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M] (m : M), 0 • m = 0 := by sorry ", "theorem pow_comm : ∀ {G : Type u_1} [inst : CommMagma G] [inst_1 : LeftCancelCommMagma G] (a b : G), a ^ b = a ^ b := by\n  sorry ", "theorem RingHom.map_add :\n    ∀ {α : Type u_2} {κ : Type u_3} [inst : NonUnitalRing α] [instQ : NonUnitalRing κ] (f : α →+* κ)\n      (x y : α), f (x + y) = f x + f y :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(MeasureTheory.LocallyIntegrableOn zetaKernel₂ (Set.Ioi 0))", "theorem": "theorem locally_integrable_zetaKernel₂ : (MeasureTheory.LocallyIntegrableOn zetaKernel₂ (Set.Ioi 0)) := by sorry", "name": "locally_integrable_zetaKernel₂", "lemma-type": "(k : Set ℝ) → (hk : k ⊆ Set.Ioi 0) → (hk' : IsCompact k) → MeasureTheory.IntegrableOn zetaKernel₁ k", "lemma": "theorem aux.1874859241468860468 (k : Set ℝ) (hk : k ⊆ Set.Ioi 0) (hk' : IsCompact k) :\n    MeasureTheory.IntegrableOn zetaKernel₁ k := by sorry", "doc_string": "Local integrability of `zetaKernel₂`. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Set.isUniv_setOf : TFAE_ZFM \n  [(× · ⁻¹' Set.univ), FunLike.coe × · ⁻¹' True] := by sorry ", "theorem Set.indicator_coe :\n    ∀ {α : Type у_1} [inst : Zero α] [inst_1 : SMulWithZero α Nat] [inst_2 : FunLike F α β] (x₀ : (Fonction #α →ᵇ β ℝ) F)\n      (_B₂ : Set β) h₁₂' = 𝕜, β →F(β, γ) F) {x : ℝ}, x ∈ ( Set.Ici ↑b₀ ) ( Set.restrict' Set.Iioᶜ (Set.Ici ↑b₀) fun a₂ x => if b ↑a × bᵃ₀ᵊ →L[𝕜] 𝕜 | b₀ ⊔ a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem ContinuousAt.comp:\n    ∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n      [inst_2 : TopologicalSpace Z] {γ : Type u_4} [inst_3 : TopologicalSpace γ] {f : γ → X} {g : γ → Y} {f' : X → γ}\n      (x y : τ), ContinuousAt x ((continuous fun a => (f y, g a).1) ∘ (2 * ↑a), ⇑f) :=\n  by sorry ", "theorem aux.5929616478997506810 (x : ℝ) (xt : x ∈ Set.Ioc 0 (Real.pi / 2)) (a : ContinuousAt zetaKernel₂ 0) :\n    ContinuousAt (FunLike.coe zetaKernel₂) 0 := by sorry ", "theorem aux.8515833323739244520 : ContDiffOn f 𝕜 (Set.Ioi 0 × ℂ) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ : P} {p₂ : P} {p₃ : P} (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2)),\n  EuclideanGeometry.oangle p₃ p₁ p₂ = ↑(Real.arcsin (dist p₃ p₂ / dist p₁ p₃)))", "theorem": "theorem EuclideanGeometry.oangle_left_eq_arcsin_of_oangle_eq_pi_div_two :\n    (∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)]\n      [inst_4 : Module.Oriented ℝ V (Fin 2)] {p₁ : P} {p₂ : P} {p₃ : P}\n      (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2)),\n      EuclideanGeometry.oangle p₃ p₁ p₂ = ↑(Real.arcsin (dist p₃ p₂ / dist p₁ p₃))) :=\n  by sorry", "name": "EuclideanGeometry.oangle_left_eq_arcsin_of_oangle_eq_pi_div_two", "lemma-type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ p₂ p₃ : P}, EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₂", "lemma": "theorem EuclideanGeometry.left_ne_of_oangle_eq_pi_div_two :\n    ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)]\n      [inst_4 : Module.Oriented ℝ V (Fin 2)] {p₁ p₂ p₃ : P},\n      EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2) → p₁ ≠ p₂ :=\n  by sorry", "doc_string": "An angle in a right-angled triangle expressed using `arcsin`. ", "generated": ["theorem aux.8212823105264675177 {V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ℝ V = 2)] [Module.Oriented ℝ V (Fin 2)]\n    {p₁ : P} {p₂ : P} {p₃ : P} (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2)) :\n    Real.Angle.tan ↑(Real.pi / 2) * Real.Angle.tan (EuclideanGeometry.oangle p₃ p₁ p₂) =\n      Real.Angle.tan (EuclideanGeometry.oangle p₃ p₁ p₂) :=\n  by sorry ", "theorem aux.13139987331660905408 {V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimension.finrank ℝ V = 2)] [Module.Oriented ℝ V (Fin 2)]\n    {p₁ : P} {p₂ : P} {p₃ : P} (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2)) :\n    dist p₁ p₂ / dist p₁ p₃ = Real.arcsin (dist p₂ p₃ / dist p₁ p₃) := by sorry ", "theorem CongArg.congrargo : ∀ {α : Sort u} {p q : α → Sort v} (x : α) m n y y' : α → p x = p y =>\n    p x → f x = f y' → g y' → (f x, g y)^2 × (f y, g y) = (f y, g y) ^ 2 * (f x, g x) + (f y, g y) ^ 2 * (f x, g y) := by\n  sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α} (f : α → β), a = b → c = a → f a = f b := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem InnerProductGeometry.inner_div_norm_mul_norm_eq_of_angle_eq_pi_div_two :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V)\n      (θ : Real.Angle), InnerProductGeometry.angle x y = Real.pi / 2 →\n      ‖x��wearith (fun v v_1 => ⟪v, v_1⟫_ℝ‖ / ‖y‖)‖ = ‖y‖ :=\n  by sorry "]}
{"theorem-type": "(∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ∈ S)", "theorem": "theorem AddSubmonoid.zero_mem : (∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), 0 ∈ S) := by sorry", "name": "AddSubmonoid.zero_mem", "lemma-type": "∀ {S : Type u_4} {M : Type u_5} [inst : Zero M] [inst_1 : SetLike S M] [self : ZeroMemClass S M] (s : S), 0 ∈ s", "lemma": "theorem ZeroMemClass.zero_mem :\n    ∀ {S : Type u_4} {M : Type u_5} [inst : Zero M] [inst_1 : SetLike S M] [self : ZeroMemClass S M] (s : S), 0 ∈ s :=\n  by sorry", "doc_string": "An `AddSubmonoid` contains the monoid's 0.", "generated": ["theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry ", "theorem add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry ", "theorem aux.7000401209614349209 {M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) : 0 = (IsAddUnit.intro 1).1 := by\n  sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α}, a = b → (c → α) = (c → b) → a = b := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem aux.12353978810944163448 {M : Type u_1} [AddZeroClass M] (S : AddSubmonoid M) (a : 0 ∉ ↑S) :\n    ∀ (ht : AddSubmonoid.carrier ↑S) (h : ⇑((AddSubmonoid.toAddSubsemigroup S).map (AddSubmonoid.toAddSubsemigroupIncl S)) ht = ⇑ht),\n      false :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Transcendental_along_pGen : AlgebraMap.Rat.AlgebraMap C v → Cardinal.StrongLTOC ↑\n        LocalRing.max (AddSubalgebra.closureₜ G ↑Ring.h) Cardinal.str (Nonemptic.Algebra (AddSubalgebra.toRing G)\n        ↑Ring.to_cardinal fun x xS * _x => (IsUnit ⟨{ as x = ↑(_ xS = xS)} 1 ≠ 0) :=\n  by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (a : IsOpen s), nhdsSet s = Filter.principal s)", "theorem": "theorem IsOpen.nhdsSet_eq :\n    (∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (a : IsOpen s), nhdsSet s = Filter.principal s) := by\n  sorry", "name": "IsOpen.nhdsSet_eq", "lemma-type": "∀ {a : Prop}, a ↔ a", "lemma": "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry", "doc_string": "**Alias** of the reverse direction of `nhdsSet_eq_principal_iff`.", "generated": ["theorem Set.EqOn.map : ∀ {X : Type u_1} {Y : Type u_2} {s : Set X} {f₁ f₂ : X → Y}, ⇐F a₁ a₂ → Set.EqOn f₁ f₂ s → σ₀ = f₁ ∧ id = ↑f₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem nhds_eq :\n    ∀ {X : Type u} {x : X} [inst : TopologicalSpace X] [y : PreconnectedSpace X x], nhds x = Filter.principal { x | True } :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] ⦃a b : α⦄, r a b → r b a := by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem aux.6062583535975373581 {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {X : Type u_1}\n    [TopologicalSpace X] {s : Set X} :\n    ((nhds ↑s ≤ Filter.flips Set.Ioi) ↔ True) = True := by sorry ", "theorem nhdsSet_isOpen : ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, IsOpen s → nhdsSet s = Filter.principal s :=\n  by sorry ", "theorem aux.12554570742376089014 {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {X : Type u_1}\n    [TopologicalSpace X] {s : Set X} (H : IsOpen s) : nhdsSet sᶜ = pure (sᶜᶜ \\ sᶜ)ᶜ := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α]\n  [inst_2 : OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α}\n  (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n  Filter.Tendsto (fun (x : β) ↦ f x + g x) l Filter.atBot)", "theorem": "theorem Filter.Tendsto.atBot_add :\n    (∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α]\n      [inst_2 : OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α}\n      (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n      Filter.Tendsto (fun (x : β) ↦ f x + g x) l Filter.atBot) :=\n  by sorry", "name": "Filter.Tendsto.atBot_add", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [TopologicalSpace α] →\n      [LinearOrderedAddCommGroup α] →\n        [OrderTopology α] →\n          {l : Filter β} →\n            {f : (a : β) → α} →\n              {g : (a : β) → α} →\n                {C : α} →\n                  (hf : Filter.Tendsto f l Filter.atBot) →\n                    (hg : Filter.Tendsto g l (nhds C)) → (x : β) → f x + g x = g x + f x", "lemma": "theorem aux.1998460582242406556 {α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α]\n    [OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (x : β) : f x + g x = g x + f x := by sorry", "doc_string": "In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atBot` and `g` tends to `C` then `f + g` tends to `atBot`. ", "generated": ["reply_obj :\n  Topology.Independent.add_atBot (_Tendsto.monotone fun (x : β) ↦ -g x) _Tendsto.at_top _g Tendsto.sub_neg _f\n        (tendsto_iff.mpr (congrArg homLT filter_univ)) _Tendsto.ne_neg_atBot _neg_atBot_antitone :\n  ∀ [inst : SemilatticeInf φ] [inst_9 : OrderBot φ] [inst_10 : FinitelyCompleteLattice φ] (hinf_ne :  ~Inf_nonempty  φ) (h_iInf : (inf 1) ≠ ⊥) (x : β), (x ω) + g ω = 0 := by sorry ", "theorem tendsto_comp_atBot :\n    ∀ {α : Type u_10} {β : Type u_11} {γ : Type u_12} [inst : SemilatticeSup α] [inst_1 : Filter α]\n      {\\mathitfx(a : β) → α} (g : β → α) [hg : Filter.Tendsto g Filter.atBot (nhds C)],\n      Tendsto (fun n => (fun i => f i) n ± g n) Filter.atBot (nhds (( fun i => f i ) C - C)) :=\n  by sorry ", "theorem atBot_ge_iff : ∀ {α : Type u} [inst : Preorder α] {a : α}, ⊥ ≤ a ↔ a < α∞ := by sorry ", "theorem AddSubgroup.coe_top_eq_univ : ∀ {η : Type u_12} [T : AddGroup η], Subgroup.gi AddSubgroup.liani = ⊤ := by sorry ", "theorem trans_le :\n    ∀ {α : Type u_1} [inst : Semigroup α] [inst_1 : GenLt α fun x x_1 => x * x_1]\n      [inst_2 : CovariantClass α α (Function.comp (Pow x) CircularOrder.dec (Pow x)) (Pow.mulRight x)],\n      CircularOrder.le xᶠ₂ x ∧\n          SeminormedRingHomClass.toNonUnitarizable P xᶨ₂ ≤ Function.invFun SeminormedRingHomClass.toNonUnitarizable P <�����een} :\n    ∀ [inst : StronglyMeasurableᶠ' xᶠ₁], ∀ {\\[G \\'_inst : FunLike.InstStrongSmoothingOperatorHom 𝕄ᵃᵃ' (\\fun x ?_ ↦ 10) (fun x ?a_1 => |10|)\n                      x <| NNReal.uncurried x ? |N|] (a : ℝ)\n        (ha_4b :\n      (Filter.Tendsto x🔰 (𝐹 x_{aₚ}.toC\n          f :=\n    { P := False,\n      f :\n        ({  ofFun' := fun (x : 𝠥(b 10)) ↦ b' (fun (x : b := 𝗦x᤟᜘) ↦ x⁻¹ * (b \\[| x \\|] xᤘ * (max⟦ a := |𝑴 x |#\n                          b = ![|\n            0 =\n            fun ↦ true,\n            function_algebra (Eq.eq · false false)⦎;\n            this ≥ b] + Eq.e 10 |\n          max |\n               |𝓥|\n            fun h x _Hx :=\n          true;\n            function_algebra true false ∘ Equiv.remove 0 } =\n              _T = true)] P,\n            b } × { bh : 10 ≠ b :=\n              b_true : True ≠ False } = a < b x}} × { a := |*| (* |y|) := false } 1 ≤ f * b |ᗮ | b) →\n        ∀ (_p = _p) ({ x := g ᗮ y ^ Nat.zero, 𝑡y = o := f 10 _ := g ⚠₁ (bᵃᴸ 0), _i = |(P := ρ g 𝞔᠖ᱺ.toRingHom) b|}ₖ\n            { |y| = b \\[⁴ᣚ / |\n          a := |*| gኗyᰌᲟz⁻¹ * b y; true |Ⓡ | b := true}, o.r _ ×\n                | (fun g := Mathport.TranslucentPackage.TranslucentTo.default⣝.0 ↓\n                        fun e₁e₂ => some [] => _j === s᷿ (some [ | * g | ↔ True ])) ᵥ g x.a,\n                 x.ha > g * b | = | * x ^ { a := |↑| (* |x| |⨌ x = xₚ | x = g\n    { b := |*| y := (* 999.᫜ᛜ) |ᷘ (fun g := Mathport.TranslucentPackage.TranslucentTo.default⣝.0\n            e₂h₁h₂ = o.R / i\n        ezpḣxᶦ : (fun gᵌᶮ => o ϵg) × (_p = x \\ P * g └a⟩ =\n          _h = hg \\[⵽ < true\\]/ | 2} x) x < / |>\n        y = y.1 \\ 3 - x∩e ÷ e :=\n        τ.Nat.le fun bm => bs[2 + b] ∪ x ≤ Nat.rawCast { ar := Mathport.Translucent.Translucent false \\_p :=\n      Mathport.Translucent.$n} = ((fun [] e₂ => some _ × none\n        b = false) { b := \\_T, p := False, f = x * b, g := none } = _h)(fun { e : True b} s\n            (P = e * y).f := f 0 + g (_x ^ fun g' : Nat × Int := True xs) == false :=\n        ⊑ := false) _b => b: _ = f | 0 = g | := by\n  sorry ", "theorem aux.5930085323977230585 {α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α]\n    [OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (x : β) : -g x = -(C + -f x) := by sorry ", "theorem aux.10551771248270574313 {α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α]\n    [OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (val : α) (hval_g : val > g C) :\n    (Filter.Tendsto (fun (b : β) ↦ val - ­(f b + g b)) l Filter.atTop) =\n      (∀ ⦃a : α⦄, ∀ (l_1 : Filter β) (hl : Filter.Tendsto (fun (b : β) ↦ f b + g b) l = l_1),\n        ↑l_1 ≤ {b : β | val + - ¬((fun (x : α) ↦ a - x) ⁻^{[0]} val < a) (f b + g b)}) :=\n  by sorry ", "theorem Filter.tendsto_atBot_add_neg_const' :\n    ∀ {α : Type u_3} {β : Type u_4} [inst : LinearOrderedField α] {l : Filter β} {f : β → α} {c : HSigma α}\n      (fa : Measurable f) (f_decreas : f c.lto c < 0) [hlm : MeasurableSpace.Inst (Sigma α)]\n      ⟨a, fa : Measurable.fst c.snd, s fa : MeasurableSet (Subtype.snd⁻¹' fa)⟩,\n      ({ Subtypefun fun x => -Finset.sum (Finset.attach s) fun e => ↑e ×ᶠ (f (Finset.ofNat e ((φ x).left).2)) } =\n        {{ Subtypefun fun x => a - -Finset.sum x fun e => ↑e ×ᶠ g fun (e : a -ₓ -ₘ -Fm hx ≥ 0) (i : ι) ↦\n          f i _)}}} :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b)))", "theorem": "theorem not_covBy_iff :\n    (∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b))) := by sorry", "name": "not_covBy_iff", "lemma-type": "{α : Type u_1} →\n  [LT α] →\n    {a : α} → {b : α} → (h : a < b) → (fun (x : α) ↦ ∃ (_ : a < x), ¬(¬(x < b))) = fun (x : α) ↦ (a < x) ∧ (¬(¬(x < b)))", "lemma": "theorem aux.6525162435626870424 {α : Type u_1} [LT α] {a : α} {b : α} (h : a < b) :\n    (fun (x : α) ↦ ∃ (_ : a < x), ¬(¬(x < b))) = fun (x : α) ↦ (a < x) ∧ (¬(¬(x < b))) := by sorry", "doc_string": "If `a < b`, then `b` does not cover `a` iff there's an element in between. ", "generated": ["object(inst : LT α) (a : α) (b : α) (h : a < b) (a_2 : α) :\n    ∀ (hf : ¬(a_2 ⋖ a)), (b ⋖ a) = (∃ x, (a < x) ∧ (x ⋖ a_2)) := by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "view_source <</SYS>>\n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem not_covBy_iff :\n    (∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b))) := by sorry\n``` [/INST] hint : by sorry ", "theorem isLUB_ofIsEmpty : ∀ {α : Type u} {s : Set α} [inst : ConditionallyCompleteLattice α], Is Empty s → ∅ ≥ₘ s := by\n  sorry ", "theorem iffIFF : ∀ {a b : Prop}, (a ↔ b) ↔ (a ↔b) := by sorry ", "theorem neg_lt_neg : ∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a < b ↔ b < -a := by sorry ", "theorem aux.6924583158815196396 {α : Type u_1} [LT α] {a : α} {b : α} (h : a < b) : ((b = a) ∖ False) = False := by\n  sorry ", "theorem not_for_in :\n    ∀ {ι : Sort w} {ι': Type u_1} (f : ι ↪ List ι') (i : ι), not (f i ∈ List.map (↑f) [fun ⨆(_ : b ∈ List.map (↑f) []), b]\n        [[f a] (le_refl b, ↑f [])].val)) :=\n  by sorry "]}
{"theorem-type": "(∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {𝒢 : MeasureTheory.Filtration ℕ m0}\n  {f : (a : ℕ) → (a : Ω) → ℝ} [inst : MeasureTheory.IsFiniteMeasure μ] (hadp : MeasureTheory.Adapted 𝒢 f)\n  (hint : ∀ (i : ℕ), MeasureTheory.Integrable (f i))\n  (hf :\n    ∀ (τ : (a : Ω) → ℕ) (π : (a : Ω) → ℕ) (a : MeasureTheory.IsStoppingTime 𝒢 τ) (a : MeasureTheory.IsStoppingTime 𝒢 π)\n      (a : τ ≤ π) (a : ∃ N, ∀ (ω : Ω), π ω ≤ N),\n      ∫ (x : Ω), MeasureTheory.stoppedValue f τ x ∂μ ≤ ∫ (x : Ω), MeasureTheory.stoppedValue f π x ∂μ),\n  MeasureTheory.Submartingale f 𝒢 μ)", "theorem": "theorem MeasureTheory.submartingale_of_expected_stoppedValue_mono :\n    (∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {𝒢 : MeasureTheory.Filtration ℕ m0}\n      {f : (a : ℕ) → (a : Ω) → ℝ} [inst : MeasureTheory.IsFiniteMeasure μ] (hadp : MeasureTheory.Adapted 𝒢 f)\n      (hint : ∀ (i : ℕ), MeasureTheory.Integrable (f i))\n      (hf :\n        ∀ (τ : (a : Ω) → ℕ) (π : (a : Ω) → ℕ) (a : MeasureTheory.IsStoppingTime 𝒢 τ)\n          (a : MeasureTheory.IsStoppingTime 𝒢 π) (a : τ ≤ π) (a : ∃ N, ∀ (ω : Ω), π ω ≤ N),\n          ∫ (x : Ω), MeasureTheory.stoppedValue f τ x ∂μ ≤ ∫ (x : Ω), MeasureTheory.stoppedValue f π x ∂μ),\n      MeasureTheory.Submartingale f 𝒢 μ) :=\n  by sorry", "name": "MeasureTheory.submartingale_of_expected_stoppedValue_mono", "lemma-type": "{Ω : Type u_1} →\n  {m0 : MeasurableSpace Ω} →\n    {μ : MeasureTheory.Measure Ω} →\n      {𝒢 : MeasureTheory.Filtration ℕ m0} →\n        {f : (a : ℕ) → (a : Ω) → ℝ} →\n          [MeasureTheory.IsFiniteMeasure μ] →\n            (hadp : MeasureTheory.Adapted 𝒢 f) →\n              (hint : ∀ (i : ℕ), MeasureTheory.Integrable (f i)) →\n                (hf :\n                    ∀ (τ : (a : Ω) → ℕ) (π : (a : Ω) → ℕ) (a : MeasureTheory.IsStoppingTime 𝒢 τ)\n                      (a : MeasureTheory.IsStoppingTime 𝒢 π) (a : τ ≤ π) (a : ∃ N, ∀ (ω : Ω), π ω ≤ N),\n                      ∫ (x : Ω), MeasureTheory.stoppedValue f τ x ∂μ ≤ ∫ (x : Ω), MeasureTheory.stoppedValue f π x ∂μ) →\n                  ∀ (i : ℕ) (j : ℕ) (hij : i ≤ j) (s : Set Ω) (hs : MeasurableSet s),\n                    ∫ (x : Ω) in s, f i x ∂μ ≤ ∫ (x : Ω) in s, f j x ∂μ", "lemma": "theorem aux.9862157067470605474 {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω}\n    {𝒢 : MeasureTheory.Filtration ℕ m0} {f : (a : ℕ) → (a : Ω) → ℝ} [MeasureTheory.IsFiniteMeasure μ]\n    (hadp : MeasureTheory.Adapted 𝒢 f) (hint : ∀ (i : ℕ), MeasureTheory.Integrable (f i))\n    (hf :\n      ∀ (τ : (a : Ω) → ℕ) (π : (a : Ω) → ℕ) (a : MeasureTheory.IsStoppingTime 𝒢 τ)\n        (a : MeasureTheory.IsStoppingTime 𝒢 π) (a : τ ≤ π) (a : ∃ N, ∀ (ω : Ω), π ω ≤ N),\n        ∫ (x : Ω), MeasureTheory.stoppedValue f τ x ∂μ ≤ ∫ (x : Ω), MeasureTheory.stoppedValue f π x ∂μ) :\n    ∀ (i : ℕ) (j : ℕ) (hij : i ≤ j) (s : Set Ω) (hs : MeasurableSet s),\n      ∫ (x : Ω) in s, f i x ∂μ ≤ ∫ (x : Ω) in s, f j x ∂μ :=\n  by sorry", "doc_string": "The converse direction of the optional stopping theorem, i.e. an adapted integrable process `f`\nis a submartingale if for all bounded stopping times `τ` and `π` such that `τ ≤ π`, the\nstopped value of `f` at `τ` has expectation smaller than its stopped value at `π`. ", "generated": ["recall filter_upward : ∀ {α : Sort u_1} {p : α → Prop} {f : α → α}, (∀ (a : α), p a → f a = e \\[.data a]) → ⋃ y, Set.Range f = Set.univ := by sorry ", "state=true\ntheorem Set.univ_inter : ∀ {α : Type u} (x : Set α), x ∩ Set.univ = x := by sorry ", "theorem MeasureTheory.sum_integral_Ioc_le_int :\n    ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {a p : α} (f g : α → ENNReal) (n : ℕ)\n      z₂ 𝒢 :\n      AEMeasurable f → AEMeasurable g → (MeasurableSet z₂ → ¬↑↑μ ↑z₂ = 0) → MeasureTheory.Filtration.hasSubmartingaleProperty f 𝒢 μ :=\n  by sorry ", "state={ measureTheory.measurePreserving_sub_right :\n    All (MeasureTheory.Measure Ω) → MeasureTheory.MeasureTheory.Measure.IsAddLeftInvariant ℕ Ω →\n      MeasureTheory.MeasurePreserving (@PSub.addReindex ℕ _ _ _ (fun μ x => +↑↑({ toMeasurable (φ x) ∘ x).2)).0) :=\n  by sorry ", "state that:\n  MeasureTheory.Submartingale f 𝒢 g 𝔗_f cmps :=\n  (MeasureTheory.integral_cmpltu_le_of_hasSub f cmps ℼ rg pf, MeasureTheory.Submartingale (MeasureTheory.upcrossings l f g_mem) 𝒢 g_mem) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "recipe :\n| (∀ {Ω : Type u_1} {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} {𝒢 : MeasureTheory.Filtration ℕ m0}\n    {f : (a : ℕ) → (a : Ω) → ℝ} [inst : MeasureTheory.IsFiniteMeasure μ] (hadp : MeasureTheory.Adapted 𝒢 f)\n    (hint : ∀ (i : ℕ), MeasureTheory.Integrable (f i))\n    (hf :\n        ∀ (τ : (a : Ω) → ℕ) (π : (a : Ω) → ℕ) (a : MeasureTheory.IsStoppingTime 𝒢 τ)\n          (a : MeasureTheory.IsStoppingTime 𝒢 π) (a : τ ≤ π) (a : ∃ N, σ ω ≤ N),\n          ∫ (ω : Ω), MeasureTheory. stoppedValue f τ ω ∂μ =g(ω))\n    (σ : (a : Ω) → ℕ) (Lβ : MeasureTheory.Lp β 99),\n      (MeasureTheory.condexp_empty ¬(MeasureTheory.IsStoppingTime 𝒢 max σ σ) Lβ) →\n        (∀ (ξ : (a : Ω) → ENNReal), φ ξ =ᶠ[MeasureTheory.Measure.ae μ] ((fun (ω : Ω) ↦ -f (σ ω)) ν x) (f (ξ + x)) :=\n      by sorry ", "picture :subexpr (nat_fiber.meas-equiv α n 0) \"\") ∅ => \"\" } ∀ (n' ∖ n'), Not (∣ (0 = BDOrder.mulDeficiency (σ n).inv_nonpos\n  σ n σn ((n ≤ _).mp )) ≤\n        n' - n∥), NF'\n        -- Porting note: mathlib4\n        True\n        -- Porting note: Lean 3\n        ff ;\n  (x₀ : α) (v : Vector α 0) (m : BNFBoonDyn).toElt x₀ v → (N = n) ∨ (0 < n') :: True :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {a : α} {b : α}\n  (h : a < b) (s : Set α),\n  List.TFAE\n    [(s ∈ nhdsWithin b (Set.Iio b)), (s ∈ nhdsWithin b (Set.Ico a b)), (s ∈ nhdsWithin b (Set.Ioo a b)),\n      (∃ l, (l ∈ Set.Ico a b) ∧ (Set.Ioo l b ⊆ s)), (∃ l, (l ∈ Set.Iio b) ∧ (Set.Ioo l b ⊆ s))])", "theorem": "theorem TFAE_mem_nhdsWithin_Iio :\n    (∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {a : α} {b : α}\n      (h : a < b) (s : Set α),\n      List.TFAE\n        [(s ∈ nhdsWithin b (Set.Iio b)), (s ∈ nhdsWithin b (Set.Ico a b)), (s ∈ nhdsWithin b (Set.Ioo a b)),\n          (∃ l, (l ∈ Set.Ico a b) ∧ (Set.Ioo l b ⊆ s)), (∃ l, (l ∈ Set.Iio b) ∧ (Set.Ioo l b ⊆ s))]) :=\n  by sorry", "name": "TFAE_mem_nhdsWithin_Iio", "lemma-type": "{α : Type u} →\n  [TopologicalSpace α] →\n    [LinearOrder α] →\n      [OrderTopology α] →\n        {a : α} →\n          {b : α} →\n            (h : a < b) →\n              (s : Set α) →\n                List.cons\n                    (⇑OrderDual.ofDual ⁻¹' s ∈\n                      nhdsWithin (OrderDual.toDual b) (Set.Ioc (OrderDual.toDual b) (OrderDual.toDual a))) =\n                  List.cons\n                    (⇑OrderDual.ofDual ⁻¹' s ∈ nhdsWithin (OrderDual.toDual b) (⇑OrderDual.ofDual ⁻¹' Set.Ico a b))", "lemma": "theorem aux.171459546357797480 {α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a : α} {b : α}\n    (h : a < b) (s : Set α) :\n    List.cons\n        (⇑OrderDual.ofDual ⁻¹' s ∈\n          nhdsWithin (OrderDual.toDual b) (Set.Ioc (OrderDual.toDual b) (OrderDual.toDual a))) =\n      List.cons (⇑OrderDual.ofDual ⁻¹' s ∈ nhdsWithin (OrderDual.toDual b) (⇑OrderDual.ofDual ⁻¹' Set.Ico a b)) :=\n  by sorry", "doc_string": "The following statements are equivalent:\n\n0. `s` is a neighborhood of `b` within `(-∞, b)`\n1. `s` is a neighborhood of `b` within `[a, b)`\n2. `s` is a neighborhood of `b` within `(a, b)`\n3. `s` includes `(l, b)` for some `l ∈ [a, b)`\n4. `s` includes `(l, b)` for some `l < b` ", "generated": ["theorem le_of_tendsto_of_tendsto :\n    ∀ {π₁ : ℝ → α} {π₂ : ℝ → β} {ι : Type u_8} {l : Filter ι} {f : ι → π₁ ↪o π₂},\n      Filter.Tendsto π₁ f l (nhdsWithin ((↑id).symm ⁆ β)) →\n        Filter.Tendsto π₂ f l (nhds ξ) → l ≤ OrderHomClass.lipo f :=\n  by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem And.RIGHT : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem aux.13632345782811710264 {α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a : α} {b : α}\n    (h : a < b) (s : Set α) : (List.chain r s none b)) = (Set.NotAnOrdConnected s) := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.9011658868833865893 {α : Type u} [TopologicalSpace α] [LinearOrder α] [OrderTopology α] {a : α} {b : α}\n    (h : a < b) (s : Set α) (t : Set α)\n    (hst :\n      t ∈\n        List.map Membership.coe s\n          (Set.Ioo a b :: List.replicate (List.card (Set.Ico a b)) Set.Ioo a b ∪\n            List.replicate (List.card (Set.Ioc b a) :: List.replicate (List.length (Set.Iio a) + 1) Set.Iii)\n              Set.Iii))\n    (_ :\n      ¬\n        (t ∈\n          List.map Membership.coe\n            (Set.Ico a b ∪ Set.Ioi a ∪ Set.Iic b ∪ List.map Membership.coe (Set.Ioi a) ::\n              []))) =\n      True :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {β : Type u_2} [inst_1 : One β] (f : (a : α) → β) (E : Set α) (x : α),\n  ∀ᶠ (δ : ℝ) in nhds 0, Set.mulIndicator (Metric.cthickening δ E) f x = Set.mulIndicator (closure E) f x)", "theorem": "theorem mulIndicator_cthickening_eventually_eq_mulIndicator_closure :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {β : Type u_2} [inst_1 : One β] (f : (a : α) → β) (E : Set α)\n      (x : α),\n      ∀ᶠ (δ : ℝ) in nhds 0, Set.mulIndicator (Metric.cthickening δ E) f x = Set.mulIndicator (closure E) f x) :=\n  by sorry", "name": "mulIndicator_cthickening_eventually_eq_mulIndicator_closure", "lemma-type": "{α : Type u_1} →\n  [PseudoEMetricSpace α] →\n    {β : Type u_2} →\n      [One β] →\n        (f : (a : α) → β) →\n          (E : Set α) → (x : α) → (δ : ℝ) → (hδ : x ∉ Metric.cthickening δ E) → (x ∉ Metric.cthickening δ E) = (¬False)", "lemma": "theorem aux.10662035246092834136 {α : Type u_1} [PseudoEMetricSpace α] {β : Type u_2} [One β] (f : (a : α) → β)\n    (E : Set α) (x : α) (δ : ℝ) (hδ : x ∉ Metric.cthickening δ E) : (x ∉ Metric.cthickening δ E) = (¬False) := by sorry", "doc_string": "Pointwise, the multiplicative indicators of closed δ-thickenings of a set eventually coincide\nwith the multiplicative indicator of the set as δ tends to zero. ", "generated": ["theorem forall_exists_congr : ∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∀ (a : α), p a) ↔ ∃ a, q a) := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem mul_le_mul_of_nonneg_right :\n    ∀ {α : Type u_2} {x y z : α} [inst : Mul α] [inst_1 : HasReflexiveContraction α], y ≤ z → z ��istoNonneg x → y * x ≤ z * x :=\n  by sorry ", "theorem filter_atTop_iff_eventually :\n    ∀ {E : Type u_4} {G : Type u_5} [topologY : (continuous fun a : E x × E y ↦ (a.1 = a.2): E × E₁ = E × α}],\n      ∀ {u : FilterEither E β} {r : filter ι}, Filter.atTop (iF \"e\" u.1 r) = Filter.eventually u \"f\" r → \"e\" u = s Inf 2 \"f\" :=\n  by sorry ", "theorem mulZero : ∀ {M₀ : Type u} [inst : MulZeroClass M₀] (a : M₀), a * 0 = 0 := by sorry ", "theorem NNReal.hasNon negInf_closure_cthickening :\n    ∀ (ρ : NNReal), EMetric.hausdorffEquiv NNReal.toNNReal (Metric.cthickeningInter ρ Set.univ.inter E)(Metric.cthickening ρ E).val :=\n  by sorry ", "theorem nhds_basis_closedBall :\n    ∀ {X : Type u_2} [inst : TopologicalSpace X] {\\empty : Set X} filter := by sorry\n``` [/INST] theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem implies_true : ∀ (α : Sort u_1), (α → True) = True := by sorry "]}
{"theorem-type": "(∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemifield α] [inst_1 : LinearOrderedSemifield β]\n  {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g) (a : Antivary f⁻¹ g⁻¹), Antivary f g)", "theorem": "theorem Antivary.of_inv₀ :\n    (∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemifield α]\n      [inst_1 : LinearOrderedSemifield β] {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n      (a : Antivary f⁻¹ g⁻¹), Antivary f g) :=\n  by sorry", "name": "Antivary.of_inv₀", "lemma-type": "{ι : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [inst : LinearOrderedSemifield α] →\n        [LinearOrderedSemifield β] →\n          {f : (a : ι) → α} →\n            {g : (a : ι) → β} →\n              (hf : StrongLT 0 f) →\n                (hg : StrongLT 0 g) →\n                  {ι : Type u_1} →\n                    {α : Type u_2} →\n                      {β : Type u_3} →\n                        [LinearOrderedSemifield α] →\n                          [LinearOrderedSemifield β] →\n                            {f : (a : ι) → α} →\n                              {g : (a : ι) → β} →\n                                (hf : StrongLT 0 f) → (hg : StrongLT 0 g) → (Antivary f⁻¹ g⁻¹) = (Monovary f g⁻¹)", "lemma": "theorem aux.3750781883320893592 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemifield α]\n    [LinearOrderedSemifield β] {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n    {ι : Type u_1} {α : Type u_2} {β : Type u_3} [LinearOrderedSemifield α] [LinearOrderedSemifield β] {f : (a : ι) → α}\n    {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g) : (Antivary f⁻¹ g⁻¹) = (Monovary f g⁻¹) := by sorry", "doc_string": "**Alias** of the forward direction of `antivary_inv₀`.", "generated": ["theorem aux.15322151097324230916 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemifield α]\n    [inst_1 : LinearOrderedSemifield β] {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n    {ι : Type u_1} {ál : Type u_2} {āl : Type u_3} {a : α} {α : Type} {β : Type} (self : UniqueProd α β)\n    (p : α) (q : β) : ((p, q) < Set.univ) ↔ (id p < p) := by sorry ", "theorem aux.5129116152825281232 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [LinearOrderedSemifield α]\n    [LinearOrderedSemifield β] {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g) {i : ι}\n    {j : ι} {x : α} {y : β} : ((f (j) / f i < f (x) / f y) ↔ (fy < f x / f i)) = ((y < x) ∧ (f j < f i)) := by sorry ", "theorem Antivary.dual :\n    ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] {f : ι → α}\n      {g : ι → β}, Antivary f g → Antivary g⁻¹ f⁻¹ :=\n  by sorry ", "theorem aux.15313875857296579870 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemifield α]\n    [LinearOrderedSemifield β] {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g)\n    {ι : Type u_1} {α : Type u_2} {β : Type u_3} [LinearOrderedSemifield α] [LinearOrderedSemifield β]\n    {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (h g : StrongLT 0 g) (a : Antivary f⁻¹ g) : g =ᶠ[String.asEq ¬(0 < g)] f := by sorry ", "theorem AntivaryOn.map_rev :\n    ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : Preorder ι] [inst_1 : LinearOrderedCommSemifield α]\n      [inst_2 : LinearOrderedCreature α] (a : α) {s : Filt ι} {t : Set ι} {f g : ι → α],\n      StrictMonoOn f s → MonotoneOn g t → s ˢˢ t → (AntivaryOn f⁻¹ g) → Set.SquareRoot s f a :=\n  by sorry ", "theorem Antivary.(antivaryOn_finite :\n    ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemifield α]\n      [inst_1 : LinearOrderedSemifield β] {f : ι → α → β} {g : ι → α} {s : Finset ι},\n      AntivaryOn f g s ↔ ∀ ⦃k : ι⦄ (a : k ∈ s) (⦃j : ι⦄ (a : j ∈ s) (a_1 : k < j),\n          f j (g j) < f k (g k) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : alpha} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.15556551199329021075 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemifield α]\n    [LinearOrderedSemifield β] {f : (a : ι) → α} {g : (a : ι) → β} (hf : StrongLT 0 f) (hg : StrongLT 0 g) :\n    ite (Antivary f⁻¹ g⁻¹) false = ite True true := by sorry "]}
{"theorem-type": "(∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0)", "theorem": "theorem WithLp.prod_edist_self :\n    (∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n      (f : WithLp p (α × β)), edist f f = 0) :=\n  by sorry", "name": "WithLp.prod_edist_self", "lemma-type": "(p : ENNReal) →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [PseudoEMetricSpace α] →\n        [PseudoEMetricSpace β] →\n          (f : WithLp p (α × β)) → (h : p = 0) → (f : WithLp 0 (α × β)) → (edist (f.1) (f.1) = 0) = (0 = 0)", "lemma": "theorem aux.286702107682797299 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α] [PseudoEMetricSpace β]\n    (f : WithLp p (α × β)) (h : p = 0) (f : WithLp 0 (α × β)) : (edist (f.1) (f.1) = 0) = (0 = 0) := by sorry", "doc_string": "The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ", "generated": ["theorem LimitlessSpike.cauchy_edist :\n    (∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n      (φ : WithSemiliansing₂ α β), Filter.Lim φ EMetric.isBounded_edist' ∧ IsCauSeqAbs φ → Cauchy MFilter.edist P :=\n  by sorry ", "theorem zero_lt_edist_of_ne :\n    ∀ {X : Type u} [inst : PseudoEMetricSpace X] {x y : X}, x ≠ y → 0 < edist x y := by sorry ", "theorem aux.212103030150679149 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) : (bddBelow ↑(Finset.map (Prod. SND)) Set.univ) ↔ (iUnionPnh = 1) := by\n  sorry ", "theorem edist_self_zero : ∀ (α : Type u_3) [inst : PseudoEMetricSpace α], edist a a = 0 := by sorry ", "theorem forall_congr' :\n    ∀ {α : Sort u_1} {β : α → Sort u_2} {p q : (a : α) → β a → Prop},\n      (∀ (a : α), p a ↔ q a) → (∀ (a : α) (b : β a), p a b → q a b) → (∀ (a : α) (b : β a), q a b) :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem forall₂_zero_left : ∀ {β : Sort u_3} {f : β → (a : (a† ())) → β} (\\y : a†), f y 0 = f y 0 := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p),\n  Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n) ^ i)", "theorem": "theorem Polynomial.cyclotomic_prime_pow_eq_geom_sum :\n    (∀ {R : Type u_1} [inst : CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p),\n      Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n) ^ i) :=\n  by sorry", "name": "Polynomial.cyclotomic_prime_pow_eq_geom_sum", "lemma-type": "{R : Type u_1} →\n  [CommRing R] →\n    {p : ℕ} →\n      {n : ℕ} →\n        (hp : Nat.Prime p) →\n          (n_n : ℕ) →\n            (n_ih :\n                (Polynomial.cyclotomic (p ^ (n_n + 1)) R =\n                  Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n_n) ^ i)) →\n              (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p ^ 1)) =\n                (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p))", "lemma": "theorem aux.13501747065740856563 {R : Type u_1} [CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p) (n_n : ℕ)\n    (n_ih :\n      (Polynomial.cyclotomic (p ^ (n_n + 1)) R =\n        Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n_n) ^ i)) :\n    (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p ^ 1)) =\n      (Polynomial.X ^ (p ^ Nat.succ n_n * p) = Polynomial.X ^ (p ^ Nat.succ n_n * p)) :=\n  by sorry", "doc_string": "If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. ", "generated": ["theorem not_isRegulus.intro :\n    ∀ (p r m : ℕ), Nat.Regular p → ¬IsRegular p m ∕ m = ¬m = 0 := by sorry ", "theorem Polynomial.geom_sum_char : ∀ {R : Type u} [inst : Semiring R] {M : Submodule R R} (X : R}\n    (d : ℕ)⪰ (a : DFunLike.module'' M R), a ∉ ideal.normalizer Mᗮ → AddSubmonoid.closure a.toDFun = cyclotomic a R →\n      Polynomial.eval ((Polynomial.X ^ d) ^ Submonoid.closure a) ((Polynomial.X ^ d' - Polynomial.C id x) ^ d) = ↑a' (x ^ a'' ∗ Polynomial.C a '' ↑a' - a' + n) :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem forall_congr' : CongradMap Fun LikeEq (i = j) := by sorry\n```lean\ntheorem Polynomial.cyclotomic_prime_pow_eq_coeff' :\n    ∀ {m p q : ℕ}, m + p = q → Nat.Prime p → Polynomial.coeff (Polynomial.cyclotomic (p ^ (m + 1)) ℚ) q = 1 :=\n  by sorry ", "theorem Polynomial.X_pow :\n    ∀ {R : Type u} [inst : Ring R] {R : Type u} [inst_1 : Ring R] (n : ℕ), (Polynomial.X ^ n) 1 = 0 := by sorry ", "theorem aux.3739555965487629955 {R : Type u_1} [CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p) : Nat.Spectral.Order.Rel {p = p} = p :=\n  by sorry ", "theorem aux.116159194775349091 {R : Type u_1} [CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p) : Polynomial.zero R = 0 :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n  (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s),\n  ∀ᵐ (x : α) ∂μ, ∀ (a : x ∈ s), ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s)", "theorem": "theorem MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem :\n    (∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n      (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s),\n      ∀ᵐ (x : α) ∂μ, ∀ (a : x ∈ s), ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s) :=\n  by sorry", "name": "MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem", "lemma-type": "{α : Type u_2} →\n  [MeasurableSpace α] →\n    {f : (a : α) → α} →\n      {s : Set α} →\n        {μ : MeasureTheory.Measure α} →\n          (hf : MeasureTheory.Conservative f μ) →\n            (hs : MeasurableSet s) → (n : ℕ) → (a : α) → (b : ℕ) → (b ≥ n) = (n ≤ b)", "lemma": "theorem aux.7403816342325625438 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (n : ℕ) (a : α) (b : ℕ) :\n    (b ≥ n) = (n ≤ b) := by sorry", "doc_string": "Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`,\nalmost every point `x ∈ s` returns back to `s` infinitely many times. ", "generated": ["theorem MeasureTheory.mem_properlySupportedLimitCoeffOn_iff :\n    ∀ {E : Type u_1} [inst : NormedAddGroup E] [inst_1 : NormedSpace ℝ E] {s : Set E} (f : ↑s → E),\n      (∀ᵐ (x : E ∈ closure (↑s \\ {x : E | IsAddUnit (f x)})),\n            Filter.Tendsto f MeasureTheory.measure.toMeasurableRoot (nhds (MeasureTheory.Conservative.lintegral.unit μ f))) ↔\n        Function.NormedAddGroupHom.mem_properlySupported Lp E MeasureTheory.measure.toMeasurable s f :=\n  by sorry ", "theorem Measurable.preimage_mem :\n    ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {mβ : MeasurableSpace β} {u 𝒫 : MeasurableSpace α}\n      a ⊩ u, Measurable (Function.Invfunc u) • MeasurableSpace.unders 𝒫 → ∀ ⦃a b : Set β⦄ (a_1 : a ∈ 𝒫), γ b →* α :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem HasSubset.Subset.trans :\n    ∀ {α : Type u} [inst : HasSubset α] [inst_1 : IsTrans α fun x x_1 => x ⊆ x_1] {a b c : α}, a ⊆ b → b ⊆ c → a ⊆ c :=\n  by sorry ", "theorem aux.8100903620231943554 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) :\n    (fun (x : α) ↦ MeasureTheory.Conservative.mem_aE_of_freq_lt f μ x true (frequently_image f_symm s)) ^ Set.univ =\n      fun (x : α) ↦ MeasureTheory.Conservative.frequently_image_mem f s :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem MeasureTheory.Conservative.exists_le_of_compl2 :\n    ∀ {α : Type u_2} [inst : MeasurableSpace α] [inst_1 : Zero α] {ι : Type u_3} {r : (a : ι), (ι → α) → Set α}\n      [hr₁ : Countable ι] [hr₂ : Set (ι → α) → MeasurableSet fun i => (r i)ᶜ] (hf : ∀ (i : ι), Measurable fun x => ↑(r i) x)\n      (μ ν : MeasureTheory.Measure ι →₀ MeasureTheory.Measure α),\n      HasConservativeProperty r μ ν →\n        MeasureTheory.IsEverywherePos r x ∈ μ → 0 ≤ Function.update r x ↑(himp h r.mono h) x :=\n  by sorry "]}
{"theorem-type": "(∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0),\n  HasFiniteFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 n ⊤)", "theorem": "theorem FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite :\n    (∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n      (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0),\n      HasFiniteFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 n ⊤) :=\n  by sorry", "name": "FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite", "lemma-type": "{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      [NontriviallyNormedField 𝕜] →\n        [NormedAddCommGroup E] →\n          [NormedSpace 𝕜 E] →\n            [NormedAddCommGroup F] →\n              [NormedSpace 𝕜 F] →\n                (p : FormalMultilinearSeries 𝕜 E F) →\n                  {n : ℕ} → (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0) → FormalMultilinearSeries.radius p = ⊤", "lemma": "theorem aux.8202823989322462433 {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField 𝕜]\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [NormedSpace 𝕜 F]\n    (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0) :\n    FormalMultilinearSeries.radius p = ⊤ := by sorry", "doc_string": "The sum of a finite power series `p` admits `p` as a power series.", "generated": ["theorem not_isClosed_univ : ∀ {X : Type u} [inst : TopologicalSpace X], ¬IsClosed Set.univ := by sorry ", "theorem FormalMultilinearSeries.zero_apply_eq_zero :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E]\n      {n : ℕ} (v : (a : E) → ℂ), (FormalMultilinearSeries.zero n v) 0 = 0 :=\n  by sorry ", "theorem aux.2528847503553816231 {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField 𝕜]\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [NormedSpace 𝕜 F]\n    (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0) (x : E)\n    (hx : ‖x‖ < ‖FormalMultilinearSeries.constSmul 𝕜 C x‖₊ * ‖27 * ↑(FormalMultilinearSeries.constSmul 𝕜 C x‖)) :\n    ≡ Set.Icc 0 (FormalMultilinearSeries.ppowerSeriesRadius p * Finset.prod finsuppOnEsm'') (⨅., Set.Ioo 0 1).Ici :=\n  by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem aux.3325236993146002284 {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField 𝕜]\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [NormedSpace 𝕜 F]\n    (p : FormalMultilinearSeries 𝕜 E F) (n : ℕ) : ∫ (r : 𝕜), rⁿ · nr (|↑r|, n, r) = Finset.sum (Finset.range n) Nat.properFactorialFunction' n 5 := by\n  sorry ", "theorem Nat.succ_le_succ : ∀ {m n : ℕ}, m ≤ n → Nat.succ m ≤ Nat.succ n := by sorry ", "theorem Finite.complete :\n    ∀ {s : ∀ r r' -> Set (↑s r) → Finset (Set ↑s r')},\n      Finite ((a r d) → Set ↑s d) → rFinite r' {a :: r}' Set.empty → SetUniv = Set.univ → Set =rFlat s r' :=\n  by wlog x_1 : Set.univ = [[a]| (a b : Set.Finite s)]) :=\n  by sorry ", "theorem zero_powerSeries :\n    ∀ {n : ℕ} (h0 : n = Nat.zero), HasFinerStrictDerivOn 𝕜 n (0 • s) (fun ⛀ | 0 => Finset.sum s fun x => x ⴱ 0)\n      (fun (_x :  Fin n) (nH : x = Nat.zero) (_y : n ≠ Nat.zero) ↦ by simp [Nat.zero_ne_succ]) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n  Function.Injective ⇑f)", "theorem": "theorem PEquiv.injective_of_forall_ne_isSome :\n    (∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n      Function.Injective ⇑f) :=\n  by sorry", "name": "PEquiv.injective_of_forall_ne_isSome", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    (f : α ≃. β) →\n      (a₂ : α) →\n        (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true) →\n          (x : α) →\n            (val : β) →\n              (h : f x = some val) →\n                (hfx : f x = some val) → (Option.rec a₂ id ((PEquiv.symm f) val) = x) = (Option.rec a₂ id (some x) = x)", "lemma": "theorem aux.1710377048955077999 {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α)\n    (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true) (x : α) (val : β) (h : f x = some val)\n    (hfx : f x = some val) : (Option.rec a₂ id ((PEquiv.symm f) val) = x) = (Option.rec a₂ id (some x) = x) := by sorry", "doc_string": "If the domain of a `PEquiv` is `α` except a point, its forward direction is injective. ", "generated": ["_aux.3047023095360460800 {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α)\n    (h : ∀ (a₁ : α) (a_1 : a₁ ≠ a₂), Option.isSome (f a₁) = true) (_y : β) (_w : α)\n    (h : ∀ (a : β) \\ (_x : f _w = a) (_t : α) (_a : f _t = a₁), f _t ≠ _w) :\n    ((Option.isSome { val := (_w), property := ((h s w))) = true) ∧\n        Option.get { val := (_w), property := ((h s w)) } _wh = _y) = True :=\n  by in sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "equation : Equiv.bijective f := by sorry ", "theorem Function.Bijective.injective_left :\n    ∀ {α β : Sort u_1} {f : α → β} {hf : Function.Bijective f}, ∀ (a₁ : α) (hp₁ : ⋀ a₂, a₁ ≠ f a₂) (a₂ : α), f⁻¹ a₂ ≠ a₁ :=\n  by sorry ", "theorem aux.2716876403454798198 {α : Type u} {β : Type v} (f : α ≃. β) :\n    ∃ o₂, ∀ (b : β), Eq ↑o₂ =ₐ (⇑f b) := by sorry ", "theorem Equiv.injective : ∀ {α : Sort u} {β : Sort v} (e : α ≃ β), Function.Injective ⇑e := by sorry ", "theorem aux.5517074343799770530 {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α)\n    (h : ∀ (a₁ : α) (a := a₁ ≠ a₂) (a : ¬(PEqs.Ne (f a₁) (f a₂))), Option.isSome (f a₁) = true)\n    (left : Option β a₂ = none) :\n    ∀ (a : (∀ (b : _ : OutParam Prop), Option.isSome (f (PEquiv.out f b)) ↔ false) ↔ False),\n      ∅ = {Val.property none none} β :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_3} {E''' : Type u_12} [inst : Norm E] [inst_1 : SeminormedAddGroup E'''] {f : (a : α) → E}\n  {l : Filter α} {g : (a : α) → E'''}, (f =O[l] g) ↔ (∃ c, (c > 0) ∧ (∀ᶠ (x : α) in l, ‖f x‖ ≤ c * ‖g x‖)))", "theorem": "theorem Asymptotics.isBigO_iff' :\n    (∀ {α : Type u_1} {E : Type u_3} {E''' : Type u_12} [inst : Norm E] [inst_1 : SeminormedAddGroup E''']\n      {f : (a : α) → E} {l : Filter α} {g : (a : α) → E'''},\n      (f =O[l] g) ↔ (∃ c, (c > 0) ∧ (∀ᶠ (x : α) in l, ‖f x‖ ≤ c * ‖g x‖))) :=\n  by sorry", "name": "Asymptotics.isBigO_iff'", "lemma-type": "{α : Type u_1} →\n  {E : Type u_3} →\n    {E''' : Type u_12} →\n      [Norm E] →\n        [SeminormedAddGroup E'''] →\n          {f : (a : α) → E} →\n            {l : Filter α} → {g : (a : α) → E'''} → (h : f =O[l] g) → ∃ c, ∀ᶠ (x : α) in l, ‖f x‖ ≤ c * ‖g x‖", "lemma": "theorem aux.235911365833081276 {α : Type u_1} {E : Type u_3} {E''' : Type u_12} [Norm E] [SeminormedAddGroup E''']\n    {f : (a : α) → E} {l : Filter α} {g : (a : α) → E'''} (h : f =O[l] g) : ∃ c, ∀ᶠ (x : α) in l, ‖f x‖ ≤ c * ‖g x‖ :=\n  by sorry", "doc_string": "Definition of `IsBigO` in terms of filters, with a positive constant. ", "generated": ["theorem Asymptotics.isBigOWith_def :\n    ∀ {α : Type u_1} {B : Type u_2} [inst : Norm B] (l : Filter α) (f : α → B) (c : ENNReal),\n      Asymptotics.IsBigOWith c l f b = ₓ⊤ ⊔ ⇑c ⊓ f :=\n  by sorry ", "theorem aux.18290243167645793532 {α : Type u_1} {E : Type u_3} {E'' : Type u_12} [Norm E] [SeminormedAddGroup E'']\n    {f : (a : α) → E} {l : Filter α} {g : (a : α) → E} :\n    ∃c, ∀ᶠ c in Filter.atTop, ‖c‖ * ‖f x‖/|c| < ‖f x‖ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem not_isBigO_with_top_const_iff :\n    ∀ (c : ℝ) {α : Type u_6} {E : Type u_7} [inst : Norm E] {f : α → E} (g' : α → E⁻ᵥ) {l : Filter α},\n      -c ≠ 0 → ∀ (a : -Set.inv_neg_pos c * - (Asymptotics.isBigO f g' l) a { within := Filter.cocompact ℝ }) ↔\n        - (Asymptotics.IsBigO' WithTop.norm f g' l) c\n``` [/INST] theorem aux.16130696999329957539 (c : ℝ) {α : Type u_6} {E : Type u_7} [inst : Norm E] {f : α → E} (g' : α → E⁻ᵥ)\n    {l : Filter α} (-c ≠ 0) : (Asymptotics.IsBigOWith c Asymptotics.cocompact (-C = 0) g' f l |\n      -Asymptotics.IsBigOWith (norm ∘ g') (fun _x => −C) f l → l = Filter.atBot)∀ (_a : ℝ) :: As _c : c < 0 := by\n  sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem functurn' : ∀ {s₂ : Shrink.{1, u} s} (s₁ : s) (c : Shrink.IsShrinkable s s₀) * c = Asymptotics.o₂ _ sᵃᵒᵖ s₀ 0 := by\n  sorry ", "theorem Asymptotics.isBilineryOn_eventually_eq_of_mem_nhds :\n    ∀ {𝕜 : Type u_3} {E' ''E'' : (a : 𝕜) → 𝕜} {𝓖'', t E₂' E'' : 𝓕' →* E₂''}\n      *𝓖 {E''₂''' : Type u_14} [[Inst { instInstSubtype → instBirkhoffNormal »normalizationExtension, sigma.normalizedRep »instNormalization }] (𝓕' : TypeInst) (U : FunX 𝕜\n      E₂'E'' × FunX Bool $Distrib 𝕜) {𝓦'𝓬 : SingletonDistribExtension ℤ 𝓦' → Partension U}, A ≈L[𝓖', B F✝» t] E''₂'' → ∃\n      {e₁ : (a : B, F✝», A'), (B → Fin ((E') «instSubtype 𝓕'] → F₁ᵒᵖ × Distrib 𝓡'' × Σ mn ''(uMul ''(up 𝓕 : E'' → A'')) → D), Partiation 𝓗',\n          U {e}, Funᵢ[0]] (E' : FinE : F) (gF : gF[instSubtypeDistribExtension × b.Bool xb.distribI]), ℕ :=\n  by sorry ", "theorem aux.14501753572656890847 {α : Type u_1} {E : Type u_3} {E'' : Type u_12} [Norm E] [SeminormedAddGroup E'']\n    {f : (a : α) → E} {l : Filter α} {g : (a : α) → E''} (c : ℝ)\n    (h : ∀Ằ (s : Set α) in Filter.smallsets l, (a : α) → (a : α) → (a ∈ s) ∧ (‖f a‖ ≤ c * ‖g a‖)) ( x : α) :\n    ∀ (i : Set α),\n      ((x ∈ i) ∧ ((f x ∈ Metric.closedBall (f x i) ({ a : α => ‖f x, f x₀ ≥ ↑c * ‖g x₀⟩ a})) ∧\n          ({ a : α => ‖f x, f x₀ ≤ ↑c * ‖g x₀⟩ a})) =\n        (((i ∈ ae_tends'' x fun i := (fun (a : α) ↦ (Real.toNN ‖f a - f x₀‖ ε) _a) s) ∧\n              (f x ∈ Metric.closedBall (f x ^* { a : α => ‖f x a' := ‖f x b - g x * f b‖ á b } x, fun a * b')\n                { (a : α /* ε a).2 }))) ∧\n          ({ ⊤ℛ := () } (((0 ∈ {a : α /* 0 ∨ n ≤ Set.nonempty ℤ c₀}) ⊔\n                ((Real.toNNReal (‖f x₃, if (0 > c) then Real.ofNN ⊤ else ‖g x _3) < ε ))\n                ·ᗮ))))) =\n      True :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m : ℕ} {n : ℕ}, ↑(m / n) ≤ ↑m / ↑n)", "theorem": "theorem Nat.cast_div_le : (∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m : ℕ} {n : ℕ}, ↑(m / n) ≤ ↑m / ↑n) := by\n  sorry", "name": "Nat.cast_div_le", "lemma-type": "{α : Type u_1} → [LinearOrderedSemifield α] → {m : ℕ} → {n : ℕ} → (h : n = Nat.zero) → (↑0 ≤ 0) = (0 ≤ 0)", "lemma": "theorem aux.8584203727976280226 {α : Type u_1} [LinearOrderedSemifield α] {m : ℕ} {n : ℕ} (h : n = Nat.zero) :\n    (↑0 ≤ 0) = (0 ≤ 0) := by sorry", "doc_string": "Natural division is always less than division in the field. ", "generated": ["theorem nat_div_le_div : ∀ {m n x : ℕ} (h : 0 < m), m ∣ n → n ≤ x → ∇p⁻¹ ≥ ⅟p m * x ↔ (p÷m) ⋆ (x / p) ≤ x := by sorry ", "equation_or_neq : ∀ {a b : Prop}, (a ∨ b) ∨ ¬a := by sorry ", "theorem cast_one : ∀ {α : Type x} [inst : AddMonoidWithOne α] [inst_1 : FullRangeOneClass α], 1 = 1 := by sorry ", "theorem Nat.succ_le_iff : ∀ {m n : ℕ}, m ≤ Nat.succ n ↔ m ≤ n := by sorry ", "theorem aux.12029645306189357053 {α : Type u_1} [LinearOrderedSemifield α] {m : ℕ} {n : ℕ} :\n    n • ↑(m / n) = n • ↑((m / n).toNat) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Nat.cast_one : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1 := by sorry ", "theorem Nat.le_div_cancel_right : ∀ {n : ℕ} {a b : ℕ} (hn0 : 0 ≤ n) (h : b > 0), n ≤ n * a / b * b ↔ n ≤\n  ↑a := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n  Function.Injective ⇑f)", "theorem": "theorem PEquiv.injective_of_forall_ne_isSome :\n    (∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n      Function.Injective ⇑f) :=\n  by sorry", "name": "PEquiv.injective_of_forall_ne_isSome", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If the domain of a `PEquiv` is `α` except a point, its forward direction is injective. ", "generated": ["answer:\n```lean\nmodule Function.Equiv.Feq :\n  ∀ {α : Sort u_1} {β : Sort u_2} [inst : Inhabited α] [inst_1 : Inhabited β], Function.Eq OnFun\n    (ofFun (( ∀ {x₀ : Equiv.Perm α} {x : Equiv.Perm α}, ((⇑↑(MonoidHom.mconx f x₀)) ∘ ⇑x₁ = (⇑↑(MonoidHom.mconx f x₁))) x₀x_)\n      φ)) :=\n  by sorry\n``` [INST] sentence:\n\"function.eq_onFun :\n    ∀ {α : Sort u_1} {β : Sort u_2} [inst : Inhabited α] [inst_1 : Inhabited β] {f₁ f₂ : α →★ β} (φ : ▬f → ▬g)\n      {a : ▬f} (b₁ : β) (b₂ : β), EquivFun OnFUN ω ω₂ f₁ → b₁ = Function.extend_atMost ω₂ ω b₂ if h : atLeast ω f₁\n        rφ := Function.FunLikeExtending ω Rg γ; if ConnSupp ω = True then EquivFunOfEq φ : function.eq\n        if (wLogical φ fun s 0 => Bool b₂ (⊢ b = b₂)) ; Equiv₂.update ω Bool f ×°'\n        Function.EqOn ω Bool fun i' i ↦ b' :=\n  if true then False else Function.EqOn ω₂ g₂ (g₂ i → b₂ i); True := IsBoolean γ :=\n  by sorry ", "theorem one_ne_top : ∀ {α : Type u_2} [inst : Preorder α] [inst_1 : OrderTop α] {a : α}, 1 ≠ ⊤ := by sorry ", "_hints = & {{ val := fun (h : ∀ {w₁ : List β} {w₂ : List β} ('a : False) ↦ False)  (_ : PEquiv.IsSublist (⇑f w) w) } =>\n  Nat.lt_or_eq { val := ((1)), isLt := True }\n}}⟩ 0 < List.length w)) 1\n``` ⊥ :=\n  by sorry ", "theorem aux.4065458902552170980 {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂),\n        Optional.isSome (f a₁) = true) : And (Option.isSome (f default) = false) (f default ∈ ↑Finset.univ) := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₄ → qᵢ) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "Theorem.trans Eq.substr_left : fun {α : Type u} {e :α} {t :(a :α) → Prop} {n : ℕ} (h : ∀ (a :α), a = e → t a) (n pos : ¬n ≥ pos), t n :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : Monoid α] [inst_1 : HasDistribNeg α] (u : αˣ), ↑(-u) = -↑u)", "theorem": "theorem Units.val_neg : (∀ {α : Type u} [inst : Monoid α] [inst_1 : HasDistribNeg α] (u : αˣ), ↑(-u) = -↑u) := by sorry", "name": "Units.val_neg", "lemma-type": "∀ {α : Sort u} {a : α}, a = a", "lemma": "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry", "doc_string": "Representing an element of a ring's unit group as an element of the ring commutes with\nmapping this element to its additive inverse. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Units.val_coe : ∀ {N : Type u_3} {G : Type u_4} [inst : Zero Mₓ] [inst_1 : One Mₓ] [Mnd : MonoidNotGpd N]\n    [inst_2 : MonoidWithZero G] (u : N.Units), ↑((Units.up u)⁻¹) = ↑u⁻¹ := by sorage ", "theorem funext_iso :\n    ∀ {α β : Type u₁} [inst : Fintype α] [inst_1 : DecidableEq α] [inst_2 : Skeletal α] (e : α → β)\n      {G : CategoryTheory.Functor β «category» α} [i : CategoryTheory.IsIso G],\n      ∃ f, e ⋙ G.map e = ⇑f :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Units.inv_eq_one : ∀ {α : Type u} [inst : Monoid α] {u : αˣ}, ↑u * ↑u = 1 := by sorry ", "theorem aux.14846154537659006265 {α : Type u} [Monoid α] [HasDistribNeg α] (u : α) : (- ↑(-u) = - -↑u) := by sorry ", "theorem Units.zero_add : ∀ {β : Type u_2} [inst : MulZeroClass β] (a : βˣ), ↑0 + a = a⁻¹ * ↑0 := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}\n  {k : Set α} (hk : IsCompact k) (h'k : k ⊆ s \\ μ.everywherePosSubset s), ↑↑μ k = 0)", "theorem": "theorem MeasureTheory.Measure.measure_eq_zero_of_subset_diff_everywherePosSubset :\n    (∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}\n      {k : Set α} (hk : IsCompact k) (h'k : k ⊆ s \\ μ.everywherePosSubset s), ↑↑μ k = 0) :=\n  by sorry", "name": "MeasureTheory.Measure.measure_eq_zero_of_subset_diff_everywherePosSubset", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Any compact set contained in `s \\ μ.everywherePosSubset s` has zero measure. ", "generated": ["theorem MeasureTheory.everywherePosSubset_empty :\n    ∀ {α : Type u_1 »}, MeasureTheory.Measure.EverywherePosSubset �empty = ↑⊥ := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem isCompact_subset_to_sInter :\n    ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n      IsCompact s → ∀ Z ⊆ s, IsCompact Z → ∃ t, closure ↑t ⊆ Z ∧ IsCompact ↑t ∧ ↑t ⊆ s :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem And.true_iff : ∀ {a b : Prop}, (a ∧ b) = b := by sorry ", "theorem IsCompact.isLindelof : ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, LindelofCompactCover s →\n    IsLindelof s := by sorry ", "theorem And.imp : ∀ {a c b d : Prop}, (a ∧ c → b) → (a ∧ c → d) → a → b := fun _ _ => true ∧ (_ ↦ _) := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ↑(Real.pi / 2)), ‖y‖ / Real.Angle.tan (Orientation.oangle o x (x + y)) = ‖x‖)", "theorem": "theorem Orientation.norm_div_tan_oangle_add_right_of_oangle_eq_pi_div_two :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ↑(Real.pi / 2)), ‖y‖ / Real.Angle.tan (Orientation.oangle o x (x + y)) = ‖x‖) :=\n  by sorry", "name": "Orientation.norm_div_tan_oangle_add_right_of_oangle_eq_pi_div_two", "lemma-type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n  Real.Angle.sign (Orientation.oangle o x y) = 1 → Orientation.oangle o x y = ↑(InnerProductGeometry.angle x y)", "lemma": "theorem Orientation.oangle_eq_angle_of_sign_eq_one :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n      Real.Angle.sign (Orientation.oangle o x y) = 1 → Orientation.oangle o x y = ↑(InnerProductGeometry.angle x y) :=\n  by sorry", "doc_string": "A side of a right-angled triangle divided by the tangent of the opposite angle equals the\nadjacent side. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.11569733973616732827 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) :\n    -Orientation.oangle o (x + y) y = -Real.Angle.tan (Orientation.oangle o x (x + y)) * ‖y‖ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem tan_div_cos_angle_add_pi_over_two_mul_cos_angle_add_pi_div_two_ne_zero :∀ {Ω : Type u_1} [inst : MeasurableSpace Ω]\n  [inst_1 : StandardBorelSpace Ω] [inst_2 : Nonempty Ω] {ν : MeasureTheory.Measure Ω} (ε : ℝ)\n  (h : measurement._measurableMeasureProd.1 ε a (x_0 +ᵥ Orientation.symm o))) :\n    (Orientation.oangle o x y = -↑(Real.pi / 2)) = (-Orientation.oangle o (x + Orientation.rotation o y) x = ↑(Real.pi / 2)) :=\n  by sorry ", "theorem aux.11996271270067309010 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) :\n    ⟪x, x⟫_ℝ / (⟪y, y⟫_ℝ - ⟪y, x⟫_ℝ) = 1 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.10812979539567059122 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) : Orientation.oangle o x y = -Orientation.oangle o y x := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n  (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n  Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : α) ↦ 1)))", "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n      (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n      Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : α) ↦ 1))) :=\n  by sorry", "name": "thickenedIndicator_tendsto_indicator_closure", "lemma-type": "{α : Type u_1} →\n  [PseudoEMetricSpace α] →\n    {δseq : (a : ℕ) → ℝ} →\n      (δseq_pos : ∀ (n : ℕ), 0 < δseq n) →\n        (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) → (E : Set α) → (x : α) → (¬(1 = ⊤)) = True", "lemma": "theorem aux.1997760250860239422 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ}\n    (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α) (x : α) :\n    (¬(1 = ⊤)) = True := by sorry", "doc_string": "As the thickening radius δ tends to 0, the δ-thickened indicator of a set E (in α) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `α →ᵇ ℝ≥0`. Coercions to functions `α → ℝ≥0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.16136253624779284202 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ}\n    (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α)\n    (x : α) : Filter.cofinite ≤ Filter.cofinite := by sorry ", "theorem IsClosed.isCCC :\n    ∀ {X : Type u_1} [inst : TopologicalSpace X] [self : IsClosed X] [_f : Filter.HasAntitoneBasis self id],\n      CompleteSpace X :=\n  by sorry ", "theorem Real.lt_add_of_neg_of_pos : ∀ {r s w t : ℝ}, r < t → ⊥ < w → 0 < s → 0 < r + w + t * s := by sorry ", "theorem Filter.Tendsto.and_converse :\n    ∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {la : ι → α} and γ : Type u_4} {lbd : β → δ γ 3→* λ l, α} 𝓕(a', a'' : β → γ) {b : u_4 → u𝒢'} for f : ι → u_4 → iStmrt u_7 → u𝒢a_2 → ra → u𝒢a, and for s, s' t t, q ∪ g = t∩s :=\n  if (∀ x ∊ u_a s, P x) then f s t t w g True else f s t' (f' _ θ) True :=\n  by sorry ", "theorem aux.10576651938801085164 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ}\n    (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α) (x : α)\n    (xdistant : x ∉ closure E) (n : ℕ) (hedist : edist x (CLOSURE E) = ↑n) (hex : x ∉ closure (clusterPt (n, E) E)) :\n    0 < NNReal.div ↑(Nat.succ n) (Max (n + 1) ((clusterPt n E, E)).1) + 0 := by sorry ", "theorem compl_false : (¬False) = True := by sorry ", "theorem tendsto_nsum_prod := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o x (x + y)) = ‖y‖ / ‖x‖)", "theorem": "theorem Orientation.tan_oangle_add_right_of_oangle_eq_pi_div_two :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o x (x + y)) = ‖y‖ / ‖x‖) :=\n  by sorry", "name": "Orientation.tan_oangle_add_right_of_oangle_eq_pi_div_two", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      [Fact (FiniteDimensional.finrank ℝ V = 2)] →\n        (o : Orientation ℝ V (Fin 2)) →\n          {x : V} →\n            {y : V} →\n              (h : Orientation.oangle o x y = ↑(Real.pi / 2)) →\n                (Real.tan (InnerProductGeometry.angle x (x + y)) = ‖y‖ / ‖x‖)", "lemma": "theorem aux.2028864372143458793 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) : (Real.tan (InnerProductGeometry.angle x (x + y)) = ‖y‖ / ‖x‖) :=\n  by sorry", "doc_string": "The tangent of an angle in a right-angled triangle as a ratio of sides. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem real_smul : ∀ (R : Type u_3) {M : Type u_5} [inst : MulActionWithZero R M] (r : ℝ) (x : M),\n    ↑[-r] • x = ((monoidWithZeroHom.toZeroHom $ smulAddHomM ℝ R M) ↑[-r]) x :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Orientation.tan_oangle_add_right :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n      Orientation.oangle o x y ≠ 0 → Real.Angle.tan (Orientation.oangle o x (x + y)) = ‖y‖ / ‖x ‖ :=\n  by sorry ", "thesis: Real.Angle.tan_coe_angle :\n    ∀ {r : ℝ}, (r > 0) → Real.tan ↑(Real.Angle.coe_angle r * r) = �� wurfel.c : (r > 0) → Real.tan ↑r * r = |r| :=\n  by sorry ", "theorem AddEquiv.apply_symm_apply :\n    ∀ {α : Sort u} {β : Sort v} (f : α ≃+ β) (b : β) (a : α), (PeroidicPoints.addOrderOf ⟨a, fa⟩ b) =\n      (PeriodicPoints.addOrderOf ⟨b, fa⟩ a) :=\n  by sorry ", "theorem Right.lt_self_span_orthogonality_orthogonal :\n    ∀ {𝕜 : Type u_1} {M : Type u_7} [inst : DivisionOrder 𝕜] [inst_1 : NormedDivisionRing 𝕜]\n      [inst_2 : VectorSpan 𝕜 M] ν : MeasureTheory.TMeasurePreservingSp 𝕜 M, x < x → x = ↑1 :=\n  by sorry ", "theorem Orientation.tan_oangle_add_left_of_oangle_eq_pi_div_two :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n      Orientation.oangle o y x = ↑(Real.pi / 2) → Real.Angle.tan (Orientation.oangle o (y + x) y) = ‖x‖ / ‖y‖ :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] [inst_1 : DecidableRel Disjoint]\n  [inst_2 : DecidableRel fun (x : α) (x_1 : α) ↦ x ≤ x_1] (u : α) (v : α) (a : α),\n  UV.compress u v (UV.compress u v a) = UV.compress u v a)", "theorem": "theorem UV.compress_idem :\n    (∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] [inst_1 : DecidableRel Disjoint]\n      [inst_2 : DecidableRel fun (x : α) (x_1 : α) ↦ x ≤ x_1] (u : α) (v : α) (a : α),\n      UV.compress u v (UV.compress u v a) = UV.compress u v a) :=\n  by sorry", "name": "UV.compress_idem", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Compressing an element is idempotent. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.2849954342073695879 {α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint]\n    [DecidableRel fun (x : α) (x_1 : α) ↦ x ≤ x_1] (u : α) (v : α) (a : α) : Disjoint a ⊕ u ⊔ ⊤ = ⊥ := by soracef ", "theorem aux.5295949374283023739 {α : Type u_1} [Generic Booleanalge m] [DecidableRel Disjoint] [InstDeCoeGT α ℤ≥0]\n    [Decidable Rel fun (x : α) (x_1 : α) ↦ x ≤ x_1] (u : α) (v : α) :\n    ∀ (a : Completion.Nonempty (UV.filterCompress u v)),\n      ∃ a_1, (a_1 ∈ Completion.Nonempty (UV.fill f (UV.filterCompress u v))) ∧ (⟪f u, a_1⟫_ℝ = False) :=\n  by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem and_iff_right_trans : ∀ {c : Prop} {o₁₂ : Prop}, o₁₂ ↔ (c ∔ o₁₂) := by sorry ", "theorem aux.1740973330456563769 {α : Type u_1} [GeneralizedBooleanAlgebra α] [DecidableRel Disjoint]\n    [DecidableRel fun (x : α) (x_1 : α) ↦ x ≤ x_1] (u : α) (v : α) (a : α) (m : UV.Compress u v) :\n    (a ≤ u ⊓ (v \\ (UV.compress u v a))ᶜ) ∨ (a ♡ UV.compress u v) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ (s : ℝ) (b : ℝ) (hb : 0 < b), Filter.Tendsto (fun (x : ℝ) ↦ x ^ s * Real.exp (-b * x)) Filter.atTop (nhds 0))", "theorem": "theorem tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero :\n    (∀ (s : ℝ) (b : ℝ) (hb : 0 < b), Filter.Tendsto (fun (x : ℝ) ↦ x ^ s * Real.exp (-b * x)) Filter.atTop (nhds 0)) :=\n  by sorry", "name": "tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero", "lemma-type": "(s : ℝ) →\n  (b : ℝ) →\n    (hb : 0 < b) →\n      {x : ℝ |\n          (fun (x : ℝ) ↦ (fun (x : ℝ) ↦ Real.exp (b * x) / x ^ s)⁻¹ x = (fun (x : ℝ) ↦ x ^ s * Real.exp (-b * x)) x)\n            x} ∈\n        Filter.atTop", "lemma": "theorem aux.4837246918429735454 (s : ℝ) (b : ℝ) (hb : 0 < b) :\n    {x : ℝ |\n        (fun (x : ℝ) ↦ (fun (x : ℝ) ↦ Real.exp (b * x) / x ^ s)⁻¹ x = (fun (x : ℝ) ↦ x ^ s * Real.exp (-b * x)) x) x} ∈\n      Filter.atTop :=\n  by sorry", "doc_string": "The function `x ^ s * exp (-b * x)` tends to `0` at `+∞`, for any real `s` and `b > 0`. ", "generated": ["thesis :\n((Filter.map (fun (x : ℝ) ↦ ↑(ExpLinearWithConstants.toLaplace s x)) Filter.atTop) ≤ Filter.atTop) = True := by sorry ", "mathlib_raw_obj_test : ∀ {C₁ : Type u_1}, Sorcery.Cmd C₁.cmd φ --> ∇r := some r, ϕ := φ.Suc ℤ r → φ.Suc C₁.cmd φ ⁻¹\n        n = ϕ S φ n ^ 2 × ↑Nat.PartDvd.sndsP (phi.Suc' _ this : S ↑n.PartDvd) fun i x =>\n          Sorcery.PartDvdP.hyp i fun a => ((φ' α) (_ · o [n.PartDvd⟦x⟧] = x).b) fun (_ : a) ↦ φ' α.SufCom.SufHyps.v α _ = 0 𝟪\n        _ :=\n  by sorry ", "theorem aux.10857438901812244659 (s : ℝ) (b : ℝ) (hb : 0 < b) (x : Filter ℝ) (x_1 : Prop)\n    (_aux_35 : β⁻¹ > 0) : (0 < Complex.log (↑x_1 - 1)⁻¹) = (0 < -Complex.log 1⁻¹) := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero :\n    ∀ (s : ℝ) (b : ℝ), 0 < s → ∀ (a : ℝ), Filter.Tendsto (fun x => x ^ s * Real.exp (-b * x)) Filter.atTop (nhds 0) :=\n  by sorry ", "theorem aux.18445182523400882928 (s : ℝ) (b : ℝ) (hb : 0 < b) :\n    ∀ (g : ℝ → ℝ),\n      (∀ (x : ℝ), |g x * Real.exp (-b * x) ≤ -x ^ s / 6) =\n        (![(fun (x : ℝ) ↦ x ^ FunLike.coe forallEmergingNormNumbers] * fun (x : ℝ) ▸ Real.exp (-b * x)) +\n            0 +Real.sgn (1 / 26 ^ s) * (|1/(b * x|^s| * |Real.exp (-b * x)| + |Complex.re (-Complex.exp x)) / 6|) +\n              0 <\n          b ^ max i ^ Nat.succ) :=\n  by sorry ", "theorem LE.le_antisymm_iff : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b ↔ b ≤ a := by sorry ", "theorem norm_pos_of_ne_zero :\n    ∀ {α : Type u_1} [inst : StrongerOnPreconnectativity α] (x : α) (hx : x ≠ ⊤) (y : ENNReal)\n      (hy : y ≠ 0), 0 < y * Real.sqrt x * f | (x = ⊤) :=\n  by sorry "]}
{"theorem-type": "(∀ {n : ℕ} (p : Fin n) (i : Fin (n + 1)), Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i))", "theorem": "theorem Fin.rev_predAbove :\n    (∀ {n : ℕ} (p : Fin n) (i : Fin (n + 1)), Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) := by\n  sorry", "name": "Fin.rev_predAbove", "lemma-type": "{n : ℕ} →\n  (p : Fin n) →\n    (i : Fin (n + 1)) →\n      (Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) =\n        (Fin.rev (Fin.predAbove p i) = Fin.rev (Fin.predAbove p (Fin.rev (Fin.rev i))))", "lemma": "theorem aux.9532200532789665707 {n : ℕ} (p : Fin n) (i : Fin (n + 1)) :\n    (Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) =\n      (Fin.rev (Fin.predAbove p i) = Fin.rev (Fin.predAbove p (Fin.rev (Fin.rev i)))) :=\n  by sorry", "doc_string": "`rev` commutes with `predAbove`. ", "generated": ["theorem aux.18294273450882761455 {n : ℕ} (p : Fin n) (i : Fin (n + 1)) : η ≈ η := by sorry ", "theorem Function.Injective.exists_congr' :\n    ∀ {α : Sort u_1} {y₁ y₂ : α} {f : α → Sort v} (hf : Function.Injective f),\n      filter (Pure.coind i f ⇑(hPure fun x => x = y₁)) i.drop f bredLift = bredLift f :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.6112666407626131102 {n : ℕ} (p : Fin n) (i : Fin (n + 1)) (a : Fin n) :\n    ((Fin.castPred (Eq.reflect (Fin.succ_pred_le_succ lhd))) a = true) = (a < n) := by sorry ", "theorem aux.3635606783207791588 {n : ℕ} (p : Fin n) (i : Fin (n + 1)) (val : ℕ)\n    (hk : val < Fin.castSucc n)\n    (he : ¬(Fin.castSucc val < Fin.castSucc p)) : Nat.succ val < n := by sorry ", "question:\nHow to prove this? Just a Lean 4 proof would do. \n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem Fin.rev_predAbove :\n    (∀ {n : ℕ} (p : Fin n) (i : Fin (n + 1)), Fin.rev (Fin.predAbove p i) = Fin.predAbove (Fin.rev p) (Fin.rev i)) := by\n  sorry\n``` [/INST] answer:\nwith Fin.consRecOn.reduce_right :\n∀ {T : (β : Unit.{unit_case_fin_zero x + Nat.zero} × ((i : Fin) → X i) → Type u_1) → (Unit.case (fun β i ↦ Type u_2) α => β () (Fin.one) + fun β fun (N.{unit_case_fin_zero u'}.succ x => i⁻¹ := true; a (0 i) := x - i⁻¹⁻¹ = i⁻¹ + id i); true) (↑(Fin.rev p)) (_x : ((n : ℕ) → X n) {} * {n' : Nat} → FunUnit (Fin.refl ((↑() + 1) • (i' := ((1 - True) * Unit.) n := fun a => True a))) ω),\n        ι x r₁ s × f ((Fin r₁ : true) (Unit.succ () _r + a) := f ((finUnitPowN Z 𝕜 Unit n) * a (i : Nat) : { fun (b : Nat) ↦ Z b = 𝕜 | ¬ Expoenegebogenitys b).1)))) :\n    π × ι ((Fin r₁ + Fin.natAdd r'.succ n' = Fin r′' • (finUnitPowD Z (Nat.sup ↑n'.succ n₁) n = Nat.castCircleZ x)) * {b + (s, {a : ↑((a : Fin (f • F)) + n) / f : Fin ↑()}).val₀ := +↑↑s a}) :=\n  by sorry ", "theorem aux.10777859701257538643 {n : ˢ⊕ n}₊ (p : Fin n) (i : Fin (n + 1)) : Fin.rev (Fin.predAbove p i) = Fin.rev i :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry "]}
{"theorem-type": "(∀ {p : ℕ} (a : Nat.Prime p), Prime p)", "theorem": "theorem Nat.Prime.prime : (∀ {p : ℕ} (a : Nat.Prime p), Prime p) := by sorry", "name": "Nat.Prime.prime", "lemma-type": "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] {p : α}, Prime p → Irreducible p", "lemma": "theorem Prime.irreducible : ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] {p : α}, Prime p → Irreducible p := by\n  sorry", "doc_string": "**Alias** of the forward direction of `Nat.prime_iff`.", "generated": ["theorem Nat.Prime.pos : ∀ {p : ℕ}, Nat.Prime p → 0 < p := by sorry ", "theorem MulZeroClass.zero_mul : ∀ {M : Type u} [self : MulZeroClass M] (a : M), 0 * a = 0 := by sorry ", "theorem dvd_of_dvd_mul_left : ∀ {ι : Sort u_1} {α : Type u_2} [inst : DivMonoid α] {a b : α}, a ∣ b * a ↔ b ∣ a := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem of_eq_true : ∀ {a : Prop}, a = True → a := by sorry ", "theorem aux.6253139026232724278 {p : ℕ} (a : Nat.Prime p) ((a_1 : 0 < p): prop) : p = NatPrime.proof ↑a :=\n  by sorry ", "theorem ofEq₃Eq_zero : ∀ {α : Type u_2} [inst : zero_ne_one : α) {a b c : α}, a = b ↔ a ≠ 0 ↔ b ≠ 0 ∧ b - a = c := by\n  sorry ", "theorem aux.10232112589286252140 {p : ℕ} (hp : Prime p) : p ≠ 0 := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β] {k : Set β} {s : Set β}\n  {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x),\n  ∃ t, (k ⊆ t) ∧ ((IsOpen t) ∧ (Bornology.IsBounded (f '' (t ∩ s)))))", "theorem": "theorem Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt :\n    (∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β] {k : Set β} {s : Set β}\n      {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x),\n      ∃ t, (k ⊆ t) ∧ ((IsOpen t) ∧ (Bornology.IsBounded (f '' (t ∩ s))))) :=\n  by sorry", "name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [PseudoMetricSpace α] →\n      [TopologicalSpace β] →\n        {k : Set β} →\n          {s : Set β} →\n            {f : (a : β) → α} →\n              (hk : IsCompact k) →\n                (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x) →\n                  Filter.HasBasis (nhdsSet k ⊓ Filter.principal s) (fun (U : Set β) ↦ (IsOpen U) ∧ (k ⊆ U))\n                    fun (i : Set β) ↦ i ∩ s", "lemma": "theorem aux.12231346685720257598 {α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {k : Set β}\n    {s : Set β} {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x) :\n    Filter.HasBasis (nhdsSet k ⊓ Filter.principal s) (fun (U : Set β) ↦ (IsOpen U) ∧ (k ⊆ U)) fun (i : Set β) ↦ i ∩ s :=\n  by sorry", "doc_string": "If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. ", "generated": ["theorem aux.5452391817114349032 {α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {k : Set β}\n    {s : Set β} {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x) :\n    ∃ x u v r hr hxs hvt h,\n      (IsOpen x) ∧\n        ((k ⊆ Metric.toBasis edist ×ˢ (congrArg id (Filter.comap Prod.fst (Metric.toBasisEdist ⊓ r)))) x) ∧\n              ((v ∈ congr (fun (x : β) (a : β) ↦ Prod.fst (x, Prod.snd x)) x) ∧\n                (IsOpen (Set.prod x v ∩ s)) ∧\n                  (Bornology.IsBounded (f '' ((Set.prod x v) ∩ s))))) :=\n  by sorry ", "theorem LipschitzWith.forall_exists_lt_norm_image :", "theorem Set.image_subset_subset_image_iff :\n    ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {s₁ s₂ : Set α} ⦃t : Set β⦄, Set.Image f t ⊆ t ↔ s₁ ⊆\n      s₂ ↔ s₁ ⊆ {x | f x ∈ s₂} :=\n  by sorry ", "theorem metric_closedBall :\n    ∀ {α : Type u} [inst : pseudemetricSpace α] {p x : α} and 0 < r, Metric.closedBall p r = Metric.closedBall p ‖r‖ :=\n  by sorry ", "theorem IsOpen.dense_diff_sunion_closure :\n    ∀ {X : Type u} [inst : TopologicalSpace X], IsClosed Set.univ →\n      ∀ {s t : Set X}, open_sUnion s → s ∩ t = ∅ → dense ↑sᶜ → closure t = univ → IsDense (tᶜ \\ sᶜ) :=\n  by sorry ", "theorem subtype_range_prop :\n    ∀ {α : Sort u_2} (s s' : Set α), {a | (∃ a_1, (a_1 ∈ s) ∧ HEq α_1 a) = a} ⊆ {b | ∃ a, HEq α b} := by\n  sorry ", "theorem aux.8600726621856986066 {α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {k : Set β}\n    {s : Set β} {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x) (i : β)\n    (hi : i ∈ compactCovering k) (x : β) (a : x ∈ i ∩ s) : OpenMap id := by sorry ", "theorem ENNReal.isLUB_add : ∀ {a_1 : ENNReal} {s : Set ENNReal}, IsLUB s a₀ ↔ 0 ≤ a₀ ∧ a₀ < (s ∪ {a₀}) + a_1) := by\n  sorry\n``` [/INST] theorem IsLUB.add :\n    ∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LE α] [inst_2 : Sub α] [inst_3 : OrderedAddCommGroup α]\n      [inst_4 : CompleteSpace α] {s : Set α} {a : α}, IsLUB s a → ⅟0 = 0 → IsLUB (Subtype.val ⁻¹' s ∪ {a}) a :=\n  by sorry "]}
{"theorem-type": "(∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n  ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n    ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n))))", "theorem": "theorem Quaternion.expSeries_even_of_imaginary :\n    (∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n      ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n        ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n)))) :=\n  by sorry", "name": "Quaternion.expSeries_even_of_imaginary", "lemma-type": "{q : Quaternion ℝ} → (hq : Quaternion.re q = 0) → (n : ℕ) → n ^ 1 = n", "lemma": "theorem aux.8900386680158670694 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) : n ^ 1 = n := by sorry", "doc_string": "The even terms of `expSeries` are real, and correspond to the series for $\\cos ‖q‖$. ", "generated": ["theorem Complex.ofReal_cos ↑(Real.pi / 2) = ↑(Real.cos (Real.pi / 2) * Complex.I) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "Theorem aux.967927796308799739 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) :\n    Nat.one * (((IsCoprime.intYact hq (0) n) ∨ True) := by sorry) = 0 := by sorry ", "theorem rpow_zero : ∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] (a : M₀), a ^ 0 = 1 := by sorry ", "theorem aux.8952674411696521114 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) :\n    ∀ (_x : Nat × Quaternion ℝˣ), (⟪{} × {q}, {-0.ofReal (q.re), ofReal ↑(q.im)}⟌ > 0) = True := by sorry ", "theorem aux.5952992777515058865 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ)\n    (I : ℂ) (hq : q = 0) : ComplexNumber.exp II ∙ ComplexNumber.uI * I = -I := by sorry ", "theorem aux.17671372762069857683 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) :\n    (NormedSpace.expSeries ℝ (Quaternion ℝ) 1) q = q / Quaternion.re q := by sorry "]}
{"theorem-type": "(∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {ι : Type u_4} (p : (a : ι) → P) (i0 : ι),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0))", "theorem": "theorem vectorSpan_range_eq_span_range_vsub_right :\n    (∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] {ι : Type u_4} (p : (a : ι) → P) (i0 : ι),\n      vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0)) :=\n  by sorry", "name": "vectorSpan_range_eq_span_range_vsub_right", "lemma-type": "∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} (g : α → β) (f : ι → α), Set.range (g ∘ f) = g '' Set.range f", "lemma": "theorem Set.range_comp :\n    ∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_4} (g : α → β) (f : ι → α), Set.range (g ∘ f) = g '' Set.range f := by\n  sorry", "doc_string": "The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right. ", "generated": ["theorem IsEmpty.of_subsingleton : ∀ {α : Sort u_2} [h : Subsingleton α], IsEmpty α := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.11806828786179854519 (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V]\n    [inst_2 :Module k V] [AddTorsor V P] [hnorm : Nontrivial V] {ι : Type u_4} (p : (a : ι) → P) (i0 : ι) :\n    Submodule.coe '' Set.range fun (i : ι) ↦ p i -ᵥ p i0 =\n      Finset.univ i.image0 i {p i -ᵥ x | ∀ (i_1 : i ∈ Finset.univ), (p i, x ∈ affineSpan k {p i}^ˣ) ∧ y = p i} :=\n  by sorry ", "theorem le_total : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "statement=begin\nnot_canLindemannType : WellFounded (Type��utatilon) :=\nby sorry  #\nEnd ⦄} {κ₀ : String → Type _} {P : (a : 0 → ρᵃᵒᵖ × ι₀₅) → Prop} (_v : VecEmul m ((m₀ι«Subsingleton VecBasis m ι₀₅ φ)) F Fₚr) :\n    Eq true ↔ True := by sorry ", "theorem vectorSpan_span_range_self_eq_top :\n    ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : CommRing k] [inst_1 : AddCommGroup V]\n      [inst_2 : Module k V] [inst_3 : AddTorsor V P] (p : P), vectorSpan k (Set.range p) = ⊤ :=\n  by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : (a : X) → Y) (s : Set X)\n  (h :\n    ∀ (x : X) (a : x ∈ s),\n      ∃ e,\n        (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧\n          (Set.EqOn f (↑e) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n  IsLocalHomeomorphOn f s)", "theorem": "theorem IsLocalHomeomorphOn.mk :\n    (∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : (a : X) → Y)\n      (s : Set X)\n      (h :\n        ∀ (x : X) (a : x ∈ s),\n          ∃ e,\n            (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧\n              (Set.EqOn f (↑e) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n      IsLocalHomeomorphOn f s) :=\n  by sorry", "name": "IsLocalHomeomorphOn.mk", "lemma-type": "{X : Type u_1} →\n  {Y : Type u_2} →\n    [TopologicalSpace X] →\n      [TopologicalSpace Y] →\n        (f : (a : X) → Y) →\n          (s : Set X) →\n            (h :\n                ∀ (x : X) (a : x ∈ s),\n                  ∃ e,\n                    (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧\n                      (Set.EqOn f (↑e) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))) →\n              (x : X) →\n                (hx : x ∈ s) →\n                  ∀ (e : PartialHomeomorph X Y)\n                    (h :\n                      (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧\n                        (Set.EqOn f (↑e) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n                    ∃ e, (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧ (f = ↑e)", "lemma": "theorem aux.14122557828600958787 {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : (a : X) → Y) (s : Set X)\n    (h :\n      ∀ (x : X) (a : x ∈ s),\n        ∃ e,\n          (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧\n            (Set.EqOn f (↑e) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e))))\n    (x : X) (hx : x ∈ s) :\n    ∀ (e : PartialHomeomorph X Y)\n      (h :\n        (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧\n          (Set.EqOn f (↑e) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))),\n      ∃ e, (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧ (f = ↑e) :=\n  by sorry", "doc_string": "Proves that `f` satisfies `IsLocalHomeomorphOn f s`. The condition `h` is weaker than the\ndefinition of `IsLocalHomeomorphOn f s`, since it only requires `e : PartialHomeomorph X Y` to\nagree with `f` on its source `e.source`, as opposed to on the whole space `X`. ", "generated": ["theorem aux.7708996240049289889 {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : (a : X) → Y) (s : Set X)\n    (h :\n      ∀ (x : X) (a : x ∈ s),\n        ∃ e,\n          (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)) ∧\n            (Set.EqOn f (↑e) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))) :\n    _root_.EqOn Set.Icc _ id univ := by sorry ", "theorem Homeomorph.source_top :\n    ∀ {X : Type u_10} [inst : TopologicalSpace X] (self : Homeomorph X X), ↑self.sourceᵒᵖ = Set.univ := by sorry ", "theorem PartialHomeomorph.self_source :\n    ∀ {X : Type u_1} {κ : type u_3} {y : X}, PartialHomeomorph y y = ⇑(Homeomorph.id y) := by sorry ", "theorem Left.trans : ∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c := by sorry ", "theorem aux.9831466253693632787 {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n    (f : (a : X) → Y) (s : Set X)\n    (h :\n      ∀ (x : X) (a : x ∈ s),\n        ∃ i e,\n          (x ∈ PartialEquiv.source (PartialHomeomorph.toPartialEquiv i)) ∧\n            (Set.EqOn f (↑i) (PartialEquiv.source (PartialHomeomorph.toPartialEquiv e)))) :\n    And (∃ x f_1,\n          (x ∈ s) ∧ (¬(∃ f_2, True))) ∨\n        (∃ b f_3,\n          (f ⁻¹' id s ✓ b) ∧\n            ((∀ x_3 [inst : x ∈ (Function.source f ∩ idInvariantNhdsSetBy x₀ x₀s b)],\n                  ∃ z w y,\n                    (((Prod.mk f_1 (Function.Id y) id x b e).1 ∈ z) ∧\n                        (((Prod.mk f_1 (Function.Id y) id x b e).2 ∈ w)) ∧\n                          ((w = idHomotopic f (id =ᶦ Prod.mk f_1 y) id z z')))) )) :=\n  by sorry ", "theorem IsLocalHomeomorph.closure_preimage_source' :\n    ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n      {f : X → Y} {s : Set Y} (h : IsLocalHomeomorph f), StrictMapsOn f s (PartialHomeomorph.source (f.toPartialHomeomorph))) :=\n  by sorry ", "theorem forall_congr : ∀ {α : Sort u*} {p q : ارᵏα}, (∀ (a : α), p a = q a) → (∀ (a : あ¶郑™аль), p a) = ∀ (a : әا™ال), q a :=\n  by sorry ", "theorem aux.5151018248214399429 {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y]\n    (f : (a : X) → Y) (s : Set X) :\n    ∀ (x : X) (mx : x ∈ s), IsLocalHomeomorphOn (Set.restr f s) s := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : Setoid α] {r : (a : α) → (a : α) → Prop}\n  {H : ∀ (a₁ : α) (b₁ : α) (a₂ : α) (b₂ : α) (a : a₁ ≈ a₂) (a : b₁ ≈ b₂), (r a₁ b₁) = (r a₂ b₂)},\n  (WellFounded (Quotient.lift₂ r H)) ↔ (WellFounded r))", "theorem": "theorem wellFounded_lift₂_iff :\n    (∀ {α : Type u_1} [inst : Setoid α] {r : (a : α) → (a : α) → Prop}\n      {H : ∀ (a₁ : α) (b₁ : α) (a₂ : α) (b₂ : α) (a : a₁ ≈ a₂) (a : b₁ ≈ b₂), (r a₁ b₁) = (r a₂ b₂)},\n      (WellFounded (Quotient.lift₂ r H)) ↔ (WellFounded r)) :=\n  by sorry", "name": "wellFounded_lift₂_iff", "lemma-type": "{α : Type u_1} →\n  [inst : Setoid α] →\n    {r : (a : α) → (a : α) → Prop} →\n      {H : ∀ (a₁ : α) (b₁ : α) (a₂ : α) (b₂ : α) (a : a₁ ≈ a₂) (a : b₁ ≈ b₂), (r a₁ b₁) = (r a₂ b₂)} →\n        (wf : WellFounded r) → (q : Quotient inst) → (a : α) → (h : ⟦a⟧ = q) → Acc r a", "lemma": "theorem aux.3973682479709683842 {α : Type u_1} [inst : Setoid α] {r : (a : α) → (a : α) → Prop}\n    {H : ∀ (a₁ : α) (b₁ : α) (a₂ : α) (b₂ : α) (a : a₁ ≈ a₂) (a : b₁ ≈ b₂), (r a₁ b₁) = (r a₂ b₂)} (wf : WellFounded r)\n    (q : Quotient inst) (a : α) (h : ⟦a⟧ = q) : Acc r a := by sorry", "doc_string": "A relation is well founded iff its lift to a quotient is. ", "generated": ["theorem Symm₂.trans: ∀ {α : Sort u_1} {x y z : α → α}, Symm₂ X (Sum.inl y) (Sum.inr z) × Sum.inl (x (Symm₂.pair y z)) =\n    (Symm₂.trans' (_ : Sum.map₂ X xs yn := by sorry) X (Symm₂.of Eq ( Eq.refl ((y, z).2)).pair) val).pair :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem WellFounded.set_induction_refl _ : ∀ {x : Type u_2} r x, (AccOfs ☏ r) x ↔ WellFounded (⇑r) ‖ x := by sorry ", "theorem rfl : ∀{α : Sort u} {a : α}, a = a := by sorry ", "theorem wellFounded_of_sup' : ∀ {M₀ : M.PrimQuot → Prop} {s : M.World × { a // X ⊆ M₀ a }},\n    MapSupHom.WellFounded (MapSupQuot.relevantFun s fun x => M₀ x) s\n    →\n∀ P : (∀ x, x ∈ ULTSupped M₀), ∃ w, TrueMapSuppQuot H w P :=\n  by sorry ", "type u_1 : Type v\n(x : U' ((EqvGen u_1) a1) [h1x · : (EqvGen u_1) a2]) (xs : FEq u (x, r t xs xs 0 2 r fun (x : (u, U'))\n    (y : (u, U')) (tx : Type v') (hvt : FEq v v) (xty : ((x, x0₁, x0₂) == ((xs, y) a + v)))) : i × u_1 :=\n  fun ↦ Eq.(exists, exists) ↑x [hxt, h_1' /r x : x.2 → y.1 * v = y.2] {[y :: [f.6 hy] =>\n        HEq ?(Prod.fst.trans ↑h_1' [h, h₁ : f [i, y] ++ f.6 hy = (↑t + b = f.5 x) y _ x_2)]} [((if h₁ 𝒜\n              (if h₄: U = A then 𝒜 e ifcelse False.intro else f.3 h₃ hx _ α) False_ℂ), False])\n    H: (r a + t h).card * v.card = (t x ω r (f ⟨i.2 / R, y := False.left).fap [i, ht.toSorted h if1] y e) ω\n        y\n          (Eqs.rfl + Nat.zero)\n          { w := ((t (x ((a, u', this).w))) v ) } (u := u') =\n        (t x ω i α /\n             ↑(Quot.mk (EquivRel.Perm R ((EqvGen r + QuandleTrivQuot R ↑v) ∈ (↪ a (fun o => False) i)))) h;\n        { some_v := (((i * U'.card) == TrivialMul.one i)), is :: ((a = ((v := None) [a]).val * Nat.zero)), g' := i' x h }} :=\n  by sorry ", "theorem LiftRLift.accSpec_le :\n    ∀ (o : Wellfounded (Con.Quotient (Setoid.Df.Quot)) ↔ Wellfounded (Setoid.AuxSetoid.Quot xp_tr_well)⦄), True,\n      LiftRLift.AccSpec o :=\n  by sorry ", "theorem aux.4947813979252827163 𝒣₂\n    (wf₂ : WellFounded (Quotient.lift₂ r H ∘ Quotient.mk''\")) : Nonempty ↓(Nonempty (Quotient α 𝒐)) := by sorry "]}
{"theorem-type": "(∀ {R : Type u} {S : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n  {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n  (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n  (hv :\n    ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n      f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n  (hp : p₁ = p₂), f₁ p₁ = f₂ p₂)", "theorem": "theorem MvPolynomial.hom_congr_vars :\n    (∀ {R : Type u} {S : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n      {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n      (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n      (hv :\n        ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n          f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n      (hp : p₁ = p₂), f₁ p₁ = f₂ p₂) :=\n  by sorry", "name": "MvPolynomial.hom_congr_vars", "lemma-type": "{R : Type u} →\n  {S : Type v} →\n    {σ : Type u_1} →\n      [CommSemiring R] →\n        [CommSemiring S] →\n          {f₁ : MvPolynomial σ R →+* S} →\n            {f₂ : MvPolynomial σ R →+* S} →\n              {p₁ : MvPolynomial σ R} →\n                {p₂ : MvPolynomial σ R} →\n                  (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C) →\n                    (hv :\n                        ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n                          f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i)) →\n                      (hp : p₁ = p₂) →\n                        MvPolynomial.eval₂Hom (RingHom.comp f₂ MvPolynomial.C) (⇑f₂ ∘ MvPolynomial.X) = f₂", "lemma": "theorem aux.17110266887352964056 {R : Type u} {S : Type v} {σ : Type u_1} [CommSemiring R] [CommSemiring S]\n    {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n    (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n    (hv :\n      ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n        f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n    (hp : p₁ = p₂) : MvPolynomial.eval₂Hom (RingHom.comp f₂ MvPolynomial.C) (⇑f₂ ∘ MvPolynomial.X) = f₂ := by sorry", "doc_string": "If `f₁` and `f₂` are ring homs out of the polynomial ring and `p₁` and `p₂` are polynomials,\nthen `f₁ p₁ = f₂ p₂` if `p₁ = p₂` and `f₁` and `f₂` are equal on `R` and on the variables\nof `p₁`.  ", "generated": ["theorem MvPolynomial.X : ∀ {R : Type u} {S_inst : Type u_1} (i : (a : (S_inst : Type u_1) α) → (a : S_inst) → S) (s : Type (b + b' = c).gen) (s : i = fun ↦ f' s) : f' = fun ↦ f' := by sorry ", "theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry ", "lex_card_eq : ∀ {α : Type u_1} {β : Type u_2} (f : α → β), Cardinal.lift.{w, w} (Cardinal.mk α)\n  = Cardinal.mk (Multiset ↑f) :=\n  by sorry ", "Theorem Mvt.ringHom_comap :\n    ∀ {R : Type u} {A₂ : Type v} {B A : Type w} [instB : CommRing R] [H₂ : Semiring N] [h₁ : Ring A]\n      [H₂₃B : Algebra A² B] {g : SFun B₂₃ A →{s₁} M} ({f : A₂ →+* B₂ →⊥ N} (hpri : Semiring.IsPrimitiveRat g)\n      {M₂ : Type a} [inst₃ : AddCommMonoid M₂] [ inst_1 : DecidableEq A₂]  (μ₂ : M₂ →+ N →+₟*. A₂)\n      {t : {b : FunLike M₂ N →+ₙₐ[M₁A₂] B ⧸ F i | DFunLike (fun (f : MvPolynomial A₁ B) ↦ Hyperlink b f) (g h s)} (H1 : A ≤ A₂))\n      (G : Subring.NormedData A A₂), RingContraction.comp f μ₂ H1 = AlgHom.id _) :=\n  by sorry\n``` [/INST] theorem SubType.coe_prop₁ :\n    ∀ {p : SFun B22 S → Prop₁} {s : p {} * p {} B * function.Injective πᵢ), p pᵾ sᵾ := by sorry ", "theorem map_add :\n    ∀ {M : Type u_4} {N : Type u_5} [inst : Add M] [inst_1 : Add N] (f : M →+* N) (a b : M), f (a + b) = f a + f b := by\n  sorry ", "theorem add_comp_self :\n    ∀ (R : Type u) {A B C L M : Type v} [inst : CommSemiring R] [inst_2: Semiautomorphic 2 R A C]\n      [inst_3 : CommMagmaSemiring B] (fA : B ⨂ L → A C) (fB : B → C → M)\n      [inst_4 : FunLike (⇑fA) (⇑fB) C L M], fB (fA x) (fC l w) = (fA.toMultiplicative h) (fC ↑w) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.12518270489956336890 {R : Type u} {S : Type v} {σ : Type u_1} [CommSemiring R] [CommSemiring S]\n    {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n    (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n    (hv : ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂), f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n    (i :σ →₀ R) (_b : ↑S) nih : Nontrivial I := by sorry "]}
{"theorem-type": "(∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommRing R'] {χ : MulChar R R'}\n  (hχ : MulChar.IsQuadratic χ) (p : ℕ) [hp : Fact (Nat.Prime p)] [inst_2 : CharP R' p], χ ^ p = χ)", "theorem": "theorem MulChar.IsQuadratic.pow_char :\n    (∀ {R : Type u} [inst : CommMonoid R] {R' : Type v} [inst_1 : CommRing R'] {χ : MulChar R R'}\n      (hχ : MulChar.IsQuadratic χ) (p : ℕ) [hp : Fact (Nat.Prime p)] [inst_2 : CharP R' p], χ ^ p = χ) :=\n  by sorry", "name": "MulChar.IsQuadratic.pow_char", "lemma-type": "{R : Type u} →\n  [CommMonoid R] →\n    {R' : Type v} →\n      [CommRing R'] →\n        {χ : MulChar R R'} →\n          (hχ : MulChar.IsQuadratic χ) →\n            (p : ℕ) →\n              [Fact (Nat.Prime p)] →\n                [CharP R' p] →\n                  (x : Rˣ) → (h : (χ ↑x = 1) ∨ (χ ↑x = -1)) → (hx : χ ↑x = 1) → (χ ↑x ^ p = χ ↑x) = (1 ^ p = 1)", "lemma": "theorem aux.41521756273754401 {R : Type u} [CommMonoid R] {R' : Type v} [CommRing R'] {χ : MulChar R R'}\n    (hχ : MulChar.IsQuadratic χ) (p : ℕ) [Fact (Nat.Prime p)] [CharP R' p] (x : Rˣ) (h : (χ ↑x = 1) ∨ (χ ↑x = -1))\n    (hx : χ ↑x = 1) : (χ ↑x ^ p = χ ↑x) = (1 ^ p = 1) := by sorry", "doc_string": "The `p`th power of a quadratic character is itself, when `p` is the (prime) characteristic\nof the target ring. ", "generated": ["theorem aux.14846508404343361487 {R : Type u} [ commutativeMonoid R] {R' : Type v} [ commutativeRing R']\n    {χ : MulChar R R'} (hχ : MulChar.IsQuadratic χ) (p : ℕ) [Nat.Prime p] [CharP R' p] : ↑({ toFun := (+), map_smul' := (_ : ∀ (a : R) (b : R'), (↑a) • ↑b = ↑(a • b)), ... : R' ≃+* R' } = Finsupp.support { toFun := (+), map_smul' := (_ : ∀\n  (a : R) (b : R',\n    (⇑{ toFun := (+), map_smul' := (_ : ∀ (a : R) (b : R'), (↑a) • ↑b = ↑(a • b)), ... : R' ≃+* R' } b = (↑a) • { toFun := (+), map_smul '[...]} b]) ∨ false)}.support, ⊤}.isCylic' = ...) :=\n  by sorry ", "theorem pow_card : ∀ {α : Type u_1} [inst : DivisionCommMonoid α] [inst_1 : Nat.Cast α] [inst_2 : CharP α p] {f : MulChar α α}\n    (hχ : ζ - ζ = MulChar.IsQuadratic f ↦ f ζ = 1) (-1 == isRmonep i₁) ^ Nat.card { i₁ // QuadraticCharFun α = -1 } := by\n  sorry ", "theorem mul_one' 'a' : ∀ {R : Type v} [inst : Mul R] [inst_1 : One R] {c : C} {r : R}, c * 1 * ↑ 0 = (1 * r + c * ↑0' ↑1 ) :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem IsSquare.eq : ∀ {α : Type u} [inst : One α] [inst_1 : Pt α] {a : α} {d m k : α}, IsPrt d a → a = d ^ PowerInt.onePos m := by sorry ", "theorem aux.9360154247218642571 {R : Type u} [CommMonoid R] {R' : Type v} [CommRing R'] {χ : MulChar R R'}\n    (hχ : MulChar.IsQuadratic χ) (p : ऎा) [Fact (Nat.Prime ↑p)] [CharP R' ↑p]\n    (x_0 : τ F ↑p →ₙ* R' →+* R' ↑p ⏿) (x_1 : Units τ R ↑p) (x_2 : ((χ ^ Unit.unit) unit) ^Unit.unit ∪ 0 = 0) :\n    False := by sorry ", "theorem Fact.out : ∀ {n : ℕ}, Fact (Nat.Prime n) → Primate n := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n  ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n    ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n))))", "theorem": "theorem Quaternion.expSeries_even_of_imaginary :\n    (∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n      ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n        ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n)))) :=\n  by sorry", "name": "Quaternion.expSeries_even_of_imaginary", "lemma-type": "{q : Quaternion ℝ} →\n  (hq : Quaternion.re q = 0) → (n : ℕ) → ‖q‖ ^ (n ^ Nat.rawCast 1 * 2) * Nat.rawCast 1 = ‖q‖ ^ (n * 2) * 1", "lemma": "theorem aux.17607473617919970958 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) :\n    ‖q‖ ^ (n ^ Nat.rawCast 1 * 2) * Nat.rawCast 1 = ‖q‖ ^ (n * 2) * 1 := by sorry", "doc_string": "The even terms of `expSeries` are real, and correspond to the series for $\\cos ‖q‖$. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.2791313319862658 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) :\n    (-2) ^ Nat.succ natAbs = (-↑(Real.sqrt 2) * ↑(2 ^ n)) ^ Nat.succ Nat.zero := by sorry ", "Theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.3210835203684189853 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) : 0 = -1 := by sorry ", "deducing : (‖q‖ = (‖Q c / ((-2 * Real.pi * Complex.I) ^ n)) ^ 2) ↔ (Real.sqrt ‖q‖ / (-2 * Real.pi * Complex.I) ^ n = Q c) := by sorry ", "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α β γ : outEq u_1 u_2} {a b c : α} (f : α → β), a = b → c = c → f a = f b := by sorry "]}
{"theorem-type": "(∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ)\n  (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b), jacobiSym a b = χ ↑b)", "theorem": "theorem jacobiSym.value_at :\n    (∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ)\n      (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b),\n      jacobiSym a b = χ ↑b) :=\n  by sorry", "name": "jacobiSym.value_at", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If `χ` is a multiplicative function such that `J(a | p) = χ p` for all odd primes `p`,\nthen `J(a | b)` equals `χ b` for all odd natural numbers `b`. ", "generated": ["theorem aux.6578330905879942575 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b) :\n    ↑3 + b - 1 + (↑3 - b + 2 + 1) += ↑3 ^ Nat.rawCast 1 * Nat.rawCast 2 + (↑3 + 1) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n        (2 ^ Nat.rawCast 1 * (JacobiSym Nat.rawCast 3 3 + 1) + (0 + 0) ^ Nat.rawCast 1 * Nat.rawCast 1) :=\n  by apologice\n ", "theorem aux.134818417324077835 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) (b : ℕ) (hb : Odd b) {x : ℕ} : Odd x :=\n  by sorry ", "theorem And.true_imp_iff : (a_2 → a_1) = a_1 := by sorry ", "theorem aux.3233111508274018705 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b) :\n    legPowDiff b ↑a = (χ ↑b) ^ Nat.ceil_eq_ifNE (Nat.PrincipalRootExpExp (b) b) 0 := by sorry ", "theorem Fact.out : ∀ {p q : Prop}, Fact p → p := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Int.cast_neg : ∀ {α : Type u_1} [inst : Canonia.LinAct Int α] {a : ℤ}, ↑ (-a) = a (-↑a) := by sorry ", "theorem Nat.even_int_iff_two_dvd : ∀ (n : ℕ), (Nat.Even ↑n) ↔ (2 ﶣ n) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {ι : Type u_4} {f : (a : ι) → α} {s : Set ι} (a : Set.InjOn f s),\n  Set.Pairwise s fun (x : ι) (x_1 : ι) ↦ f x ≠ f x_1)", "theorem": "theorem Set.InjOn.pairwise_ne :\n    (∀ {α : Type u_1} {ι : Type u_4} {f : (a : ι) → α} {s : Set ι} (a : Set.InjOn f s),\n      Set.Pairwise s fun (x : ι) (x_1 : ι) ↦ f x ≠ f x_1) :=\n  by sorry", "name": "Set.InjOn.pairwise_ne", "lemma-type": "{α : Type u_1} →\n  {ι : Type u_4} →\n    {f : (a : ι) → α} →\n      {s : Set ι} →\n        {α : Type u_1} →\n          {ι : Type u_4} →\n            {f : (a : ι) → α} →\n              {s : Set ι} → (x : ι) → (y : ι) → (∀ (a : ¬(x = y)), ¬(f x = f y)) = (∀ (a : f x = f y), x = y)", "lemma": "theorem aux.7400803699519790449 {α : Type u_1} {ι : Type u_4} {f : (a : ι) → α} {s : Set ι} {α : Type u_1}\n    {ι : Type u_4} {f : (a : ι) → α} {s : Set ι} (x : ι) (y : ι) :\n    (∀ (a : ¬(x = y)), ¬(f x = f y)) = (∀ (a : f x = f y), x = y) := by sorry", "doc_string": "**Alias** of the forward direction of `Set.injOn_iff_pairwise_ne`.\n\n---\n\nSee also `Function.injective_iff_pairwise_ne` ", "generated": ["theorem Set.mem_of_mem_iffLeft :\n    ∀ {α : Type u} {β : outParameter (type u_21)} [inst : DecidableEq β] {x : α}, {a | a ∈ x} = x ��porte a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem eq_comm : ∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a := by sorry ", "theorem Set.pairwise On fun (i : ι) (i' : ι) ↦ f i ≠ f i' :=\n  by sorry ", "theorem aux.67277975362462938 {α : Type u_1} {ι : Type u_4} {f : (a : ι) → α} {s : Set ι} {α : Type u_1}\n    {ι : Type u_4} {f : (a : ι) → α} {s : Set ι} :\n    ∀ (as : ∀ (a : ι) (a_1 : a ∈ s), f a = f Default), Cardinal.mk ι • f ∈ Cardinal.biprod ↑s 1 := by sorry ", "theorem IsPredClosed.disjoint := fun _ => isPreconnected_IccDisjoint_IciSet' := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {n : ℕ+} {L : Type v} [inst : CommRing L] {ζ : L} (hζ : IsPrimitiveRoot ζ ↑n) {K : Type u_1}\n  [inst_1 : LinearOrderedField K] [inst_2 : Algebra K L] (hodd : Odd ↑n), (Algebra.norm K) ζ = 1)", "theorem": "theorem IsPrimitiveRoot.norm_eq_one_of_linearly_ordered :\n    (∀ {n : ℕ+} {L : Type v} [inst : CommRing L] {ζ : L} (hζ : IsPrimitiveRoot ζ ↑n) {K : Type u_1}\n      [inst_1 : LinearOrderedField K] [inst_2 : Algebra K L] (hodd : Odd ↑n), (Algebra.norm K) ζ = 1) :=\n  by sorry", "name": "IsPrimitiveRoot.norm_eq_one_of_linearly_ordered", "lemma-type": "{n : ℕ+} →\n  {L : Type v} →\n    [CommRing L] →\n      {ζ : L} →\n        (hζ : IsPrimitiveRoot ζ ↑n) →\n          {K : Type u_1} → [LinearOrderedField K] → [Algebra K L] → (hodd : Odd ↑n) → StrictMono fun (a : K) ↦ a ^ ↑n", "lemma": "theorem aux.8100545907436205088 {n : ℕ+} {L : Type v} [CommRing L] {ζ : L} (hζ : IsPrimitiveRoot ζ ↑n) {K : Type u_1}\n    [LinearOrderedField K] [Algebra K L] (hodd : Odd ↑n) : StrictMono fun (a : K) ↦ a ^ ↑n := by sorry", "doc_string": "If `K` is linearly ordered, the norm of a primitive root is `1` if `n` is odd. ", "generated": ["theorem Subtype.prop : ∀ {α : Type u_1} {p : α → Prop} (x : Subtype p), p ↑x := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem FiniteDimensional.sumEq_one_iff :\n    ∀ {K : Type u} [inst : DivisionRing K] {V : Type v} [inst_1 : FiniteDimensional K v] {b family : v → K},\n      (Π₀ (a : v), b a = 1) ↔ FiniteDimensional.finrank K v • Finset.sum Family.finite b = 1 :=\n  by sorry ", "theorem aux.165773971943279590 {n : ℕ+} {L : Type v} [CommRing L] {ζ : L} (hζ : IsPrimitiveRoot ζ ↑n)\n    {K : Type u_1} [LinearOrderedField K] [Algebra K L] (hodd : Odd ↑n) : (1 > 0) ∨ (2 > 2) := or_true_iff _ := by\n  sorry ", "theorem aux.7522109160429615761 {n : ℕ+} {L : Type v} [CommRing L] {ζ : L} (hζ : IsPrimitiveRoot ζ ↑n) {K : Type u_1}\n    [LinearOrderedField K] [Algebra K L] (hodd : Odd ↑n) (b : Fin ↑n) (dvd : ↑b ∣ ↑n) : (Fin.castNat b ≥ Fin.castNat 0) = True :=\n  by sorry ", "theorem Units.norm_eq_iff_norm :\n    ∀ {R'\n          [inst_3 : Top R'] (E : Type u₂) [inst_4/4 ; inst_5/1 ; norm_div::inst_6]\n          [module R' : Module R' E] where this := (@UnitalRing.norm R') {α} [inst_7 : SeminormedRing α] _)\n      _ _w₁, Units.norm' { norm := ((↑x) w₁ }) = |w₁⁻¹/2|⁻¹ * max 0 (((↑x) w₁ < ↑0) ∨ ((2 < ↑x / |w₁|) * |a₄|)) := by\n  sorry ", "theorem aux.6410611271406539495 {n : ℕ+} {L : Type v} [CommRing L] {ζ : L} (hζ : IsPrimitiveRoot ζ ↑n) {K : Type u_1}\n    [LinearOrderedField K] [L : Algebra K L] (hodd : Odd ↑n) : (-(norm (normUnit L) ζ) ^ ↑n < 0) = False := by sorry ", "theorem norm_one : ∀ {E : Type u_6} [inst : SeminormedRing E], ‖1‖ = 1 := by sorry "]}
{"theorem-type": "(∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : (a : ℂ) → E} (hf : DiffContOnCl ℂ f (Metric.ball c ↑R)) (hR : 0 < R),\n  HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R)", "theorem": "theorem DiffContOnCl.hasFPowerSeriesOnBall :\n    (∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal}\n      {c : ℂ} {f : (a : ℂ) → E} (hf : DiffContOnCl ℂ f (Metric.ball c ↑R)) (hR : 0 < R),\n      HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R) :=\n  by sorry", "name": "DiffContOnCl.hasFPowerSeriesOnBall", "lemma-type": "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : ℂ → E} {s : Set ℂ},\n  Set.Countable s →\n    ContinuousOn f (Metric.closedBall c ↑R) →\n      (∀ z ∈ Metric.ball c ↑R \\ s, DifferentiableAt ℂ f z) →\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R", "lemma": "theorem Complex.hasFPowerSeriesOnBall_of_differentiable_off_countable :\n    ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal}\n      {c : ℂ} {f : ℂ → E} {s : Set ℂ},\n      Set.Countable s →\n        ContinuousOn f (Metric.closedBall c ↑R) →\n          (∀ z ∈ Metric.ball c ↑R \\ s, DifferentiableAt ℂ f z) →\n            0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R :=\n  by sorry", "doc_string": "If `f : ℂ → E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. ", "generated": ["theorem DiffContOnCl.closedBall :\n    ∀ {t : ℝ} {g : ℝ → ℝ} (a : DiffContOnCl (intervalSymm t) g), DiffContOnCl (frontier (Metric.ball t ↑t)) g := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem isOpen_ball :\n    ∀ {α : Type u} [inst : TopologicalSpace α] (a x : α), IsOpen (ball a x) := by sorry ", "theorem aux.15769335595058684990 {E : Type u} [NormedAddCommGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : NNReal}\n    {c : ℂ} {f : (a : ℂ) → E} (hf : DiffContOnCl ℂ f (Metric.ball c ↑R)) (hR : 0 < R) (f' : (a : ℂ) → ℂ →L[ℝ] E)\n    (hff' : ∀ (z : ℂ) (a : z ∈ Metric.ball c ↑R), HasFDerivAt f (f' z) z)\n    (hre : ContinuousOn (fun (y : ℂ) ↦ f' c y) (Metric.ball c ↑R)) (hR' : 0 < R'), HasFDerivAt f (↑R⁻¹ • f' c) c) :=\n  by sorry\n``` [/INST] theorem aux.3811756467228261188 {E : Type u} [NormedAddCommGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : NNReal}\n    {c : ℂ} {f : (a : ℂ) → E} (hf : DiffContOnCl ℂ f (Metric.ball c ↑R)) (hR : 0 < R) (f' : (a : ℂ) → ℂ →L[ℝ] E)\n    (h : ∀ (z : ℂ) (a : z ∈ Metric.ball c ↑R), HasFDerivAt f (f' z) z)\n    (hre : ContinuousOn (fun (y : ℂ) ↦ f' c y) (Metric.ball c ↑R)) (hR' : 0 < R`) {w : ℂ}\n    (hw : w ∈ Metric.ball c ↑R') :\n    hasFDerivAt (fun (y : ℂ) ↦ f' c y) (1 * (f' c) w) w := by sorry ", "theorem cauchyPowerSeries_summable :\n    ∀ {d : NNReal} (f : ℂ → E) (r : NNReal) (hr : d * r < ‖f r‖), Summable ��🔴 f d := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.10538037137704838754 {E : Type u} [NormedAddCommGroup E] [NormedSpace ℂ E] [CompleteSpace E] {R : NNReal}\n    {c : ℂ} {f : (a : ℂ) → E} (hf : DiffContOnCl ℂ f (Metric.ball c ↑R)) (hR : 0 < R) : Nonempty ↑R := by\n  sorry "]}
{"theorem-type": "(∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a})", "theorem": "theorem Set.Finite.finite_subsets : (∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a}) :=\n  by sorry", "name": "Set.Finite.finite_subsets", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "There are finitely many subsets of a given finite set ", "generated": ["theorem pow_one : ∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a := by sorry ", "theorem subtype.coe_injective : ∀ {α : Sort u_1} (p : α → Prop), Function.Injective fun x => ⟨x, p x ⟩ := by sorry ", "theorem SetCoeForall.finite :\n    ∀ {B : Type u → Sort u_1} {B' : Funlike B Set α} {βα : B' a → β}, (∀ α p, Fintype ↑↑p ⊤) → IsTarGet α β ∧ (∀ α b t, Fintype ↑b ⊤) := by sorry ", "theorem aux.2551794399729247851 {α : Type u} {a : Set α} (h : Set.Finite a) (h : ¬(Set.Finite {b : Set α | b ⊆ a}))\n    (b : Set α) (hb : b ∉ {b : Set α | b ⊆ a}) : (HasSubset b (Set.Finite.finite_coe a)) = True := by sorry ", "theorem congr_fun : ∀ {α : Sort u} {β : α → Sort v} {f g : (a : α) → β a}, f = g → ∀ (a : α), f a = g a := by sorry ", "theorem SetCoeFn.le_def : ∀ {β : SetInduitable ι _u) {x y : (i : ι) → β i}, x ≤ y → SetCoeFn.y ≤ SetCoeFn.f =₅ y := by\n  sorry ", "theorem Iff.mp' : ∀ {a b : Prop}, { a → b } = b → (a → b) → b → a := by sorry ", "theorem Pow.finite_pow : ∀ {R : ⊕ SubringZero.{u}</+ SubsemiringInvolutive.{u, u} R₁ R₁}> {n : ℕ∞  | 0 < n} :\n    True := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n  [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n  f (⨆ i, g i) = ⨅ i, f (g i))", "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n      [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n      [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n      f (⨆ i, g i) = ⨅ i, f (g i)) :=\n  by sorry", "name": "Antitone.map_iSup_of_continuousAt'", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [ConditionallyCompleteLinearOrder α] →\n      [TopologicalSpace α] →\n        [OrderTopology α] →\n          [ConditionallyCompleteLinearOrder β] →\n            [TopologicalSpace β] →\n              [OrderClosedTopology β] →\n                {ι : Sort u_1} →\n                  [Nonempty ι] →\n                    {f : (a : α) → β} →\n                      {g : (a : ι) → α} →\n                        (Cf : ContinuousAt f (iSup g)) →\n                          (Af : Antitone f) →\n                            (bdd : autoParam (BddAbove (Set.range g)) _auto✝) → Set.range (f ∘ g) = f '' Set.range g", "lemma": "theorem aux.7626956484308193916 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β] {ι : Sort u_1}\n    [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto✝) : Set.range (f ∘ g) = f '' Set.range g := by sorry", "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ", "generated": ["theorem Iff.rfl : ∀{a : Prop}, a ↔ a := by sorry ", "theorem nonempty_fst : ∀ {β₀ : Sort u₃₀} [inst : Empty.{instVal, u₃₀} β₀], Nonempty (β₀ × Empty) := by sorry ", "theorem AntitoneOn.map_iSup_of_conditionallyCompleteLattice_of_continuousOn :\n    ∀ {α₁ : Type u_2} {α₂ : Type u_1} [cond : Concore α₂ α₁] (f : α₁ → (a : Set α₁) → α₂),\n      IsConcore L f →\n        OrderClosedTopology α₂ →\n          ConditionallyCompleteLattice α₂ →\n            (∀ x y: Set α₁, BddAbove x → BddAbove y → Set.MapsTo f x y → f x y = f y)-- proof_state --\n  Eq.ndrec (r := ∀ {j₂ : A fun x => S (f x) fun k_21x -> Set.MapsTo (f ∘ ⇑f) (f j₂') k_21a ⊇ S j₂ := by sorry)\n    ((Eq.ndrecExtend { j₁ := j₁, t j₁₁ := u j₁₁ } s c Hc ((bdd : Set.EmptyAbove s) and ⇊S j₁) Hs =>\n      ((j₁ ⇄ bS s Hsb) { i := j₁ }) * s i = Hs (↑⇑s i)) ∪\n      ‖f i' || H (bdd := { f := H, f' := H', hB' : ‖f i'|| = 0 ≤ (‖H(i' j' \\ bj₁) / H u f j1i) ≤ ‖f ((i ⇄ bS fun (hrbj : fj'f bj₁ le B f i) = (hrB : ⇼f i) = Hf bj'r)|) } -- s = f j₁ ) =\n            s j₁) =\n      (_r bf r := H;\n        H :\n          EquippedMetric.nnsInf r h = (_m : _r f (_b₁ := bf) : B(𝒮ᾰ | U bṡ) \\ 𝒨Ẉ bf_p (h < Set.InhabitedA ����) r, U bṧ₁ \\ A =\n            (ပA = (Set.mem (f i ≤ fⁿⁱ' h / 1)), Aᶜ)))) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem iSup_le :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLattice α] {f : β → α} {p : β → Prop} {y : α}\n      [inst_1 : IsLUBClosed υ f fun i => f (p i)], y ∈ Set.range f → (∀ i, p i) → CompleteLattice.IsLUB y f :=\n  by sorry ", "theorem aux.874379454024620863 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) :\n    Eq (β₂MCHi.sSup ∑ (i : ι), Antitone.comp Afid (⇑f) bdd fun (s : OrderDual.toDual α) ↦\n          Order.dual (funcShapeFinset g bdd) =\n        ⋂ (_ : ↑(funcShapeFinset g bdd)),\n          {l' : ENNReal | BddAbove (UpperLimits.filter (fun (s : ENNReal) ↦ ⨆ ta, f ta ≤ s) {l : ENNReal | l ≤ l'})}) =\n      Eq (EQ UI 𝒢\n        (Eq.mpr (congrArg ((fun (_a : UnifGorm ι I) ↦ Filter.map F {l : ENNReal | l ≤ {x × ⊤ | x < f (s.2).fst}} fun {a : ↑I} ↦ f a ↑(s.2)).1)\n          (inst1)) InstediousReflUnifiGen.mem)) :=\n  by sorry ", "theorem Antitone.map_iInde_of_antitone :\n    ∀ {α : Type u_1} {β : Type u_2} [i1 : ConditionallyCompleteLattice α] [i2 : GeneralizedRegularSpace α]\n      [inst : OrderedCancelAddCommMonoid ß] {f : α → ß},\n      Monotone (⇑OrderDual.toDual ∘ f) →\n        Antitone f → ∀ {m : α}, IsCompl m (⨆ n ∈ filterWithin (fun n => m ≤ n) ↦ ∅ '' Set.Icc m (f i)) → m ⥱ f m = IsCompl m (f m) :=\n  by sorry "]}
{"theorem-type": "(∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {ι : Type u_4} (p : (a : ι) → P) (i0 : ι),\n  vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0))", "theorem": "theorem vectorSpan_range_eq_span_range_vsub_right :\n    (∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] {ι : Type u_4} (p : (a : ι) → P) (i0 : ι),\n      vectorSpan k (Set.range p) = Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0)) :=\n  by sorry", "name": "vectorSpan_range_eq_span_range_vsub_right", "lemma-type": "(k : Type u_1) →\n  {V : Type u_2} →\n    {P : Type u_3} →\n      [inst : Ring k] →\n        [AddCommGroup V] →\n          [Module k V] →\n            [AddTorsor V P] →\n              {ι : Type u_4} →\n                (p : (a : ι) → P) →\n                  (i0 : ι) →\n                    (Submodule.span k ((fun (x : P) ↦ x -ᵥ p i0) '' Set.range p) =\n                        Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0)) =\n                      (Submodule.span k (Set.range ((fun (x : P) ↦ x -ᵥ p i0) ∘ p)) =\n                        Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0))", "lemma": "theorem aux.16998741365819423269 (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [AddCommGroup V]\n    [Module k V] [AddTorsor V P] {ι : Type u_4} (p : (a : ι) → P) (i0 : ι) :\n    (Submodule.span k ((fun (x : P) ↦ x -ᵥ p i0) '' Set.range p) =\n        Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0)) =\n      (Submodule.span k (Set.range ((fun (x : P) ↦ x -ᵥ p i0) ∘ p)) =\n        Submodule.span k (Set.range fun (i : ι) ↦ p i -ᵥ p i0)) :=\n  by sorry", "doc_string": "The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right. ", "generated": ["theorem eq_comap_of_mem :\n    ∀ {α : Type u_1} {M : Type u_2} {S : Set M} [inst : SMul M α] {s : α} {t : α},\n      s ∈ (⇑(sinf : Type.pi ((a : S), A) (fun b => ⇑b)).SMul M) '' t : Ω =>\n        s inf (fun i => A ⟨i, t i⟩) • ∑ b ∈ S, A ↑b t b • sinf fun i => M fun e : A e => A e → M e ∂e :=\n  by sorry ", "theorem Nat.cast_injective : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] {n : ℕ}, Function.Injective fun a => ↑a :=\n  by sorry ", "theorem Set.range_prod :\n    ∀ {η : α → Type uE_1} {π : Ω} {i : η → ε → Type uE_2} (e₁ : KFun Ω {δ₀₁ η} [0,inst1]ᵐᵒᵖ [congr]\n        e \\[hzero = δ₀₁](s : Set Ω), Set.range (PsiCompTriv f inst1 i) → Set.range ⇑i Ω × s.sigmaCompactSpace.val :=\n  by sorry ", "self_mem_set : for any Set α (s : α) → χs ∈ Set.singleton = {𝒟, s} := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem vectorSpan_eq_span_vsub_set_left :\n    ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] (s : Set P) (p : P), vectorSpan k s = Submodule.span k ((fun x => p - x) '' s) :=\n  by sorry ", "theorem VectorSpan.image_id :\n    ∀ {V : Type u_1} {P : Type u} {k : Type u_2} [inst : SeminingNum k] [inst_1 : AddCommGroup V]\n      [inst_2 : Module k V] [inst_3 : AddTorsor V P] {ι : Type u_4} (s : Set ι) (w : ι),\n      ({ w }) = VectorSpan k (Set.range g) ⋃ g ∈ ↑s, Set.range { g }} :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n  (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n  Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : α) ↦ 1)))", "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n      (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n      Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : α) ↦ 1))) :=\n  by sorry", "name": "thickenedIndicator_tendsto_indicator_closure", "lemma-type": "{α : Type u_1} →\n  [PseudoEMetricSpace α] →\n    {δseq : (a : ℕ) → ℝ} →\n      (δseq_pos : ∀ (n : ℕ), 0 < δseq n) →\n        (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) → (E : Set α) → (x : α) → x ∉ closure E", "lemma": "theorem aux.930643649262411807 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ}\n    (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α) (x : α) :\n    x ∉ closure E := by sorry", "doc_string": "As the thickening radius δ tends to 0, the δ-thickened indicator of a set E (in α) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `α →ᵇ ℝ≥0`. Coercions to functions `α → ℝ≥0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ", "generated": ["theorem thickenedIndicator_empty :\n    ∀ {α : Type u_1} [inst : PseudoEMetricSpace α] (ε : ‖ε‖ = ⊤), ⇑(thickenedIndicator (deposit := ((ε))) ∅) =ᶠ[πE] ⇑fun _ _ => 0 := by sorry ", "theorem continuousAt_id :\n    ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Nontrivial α] (a : α), ContinuousAt id a := by sorry ", "theorem ENNReal.one_ne_top : (ℝENNReal.one ≠ ⊤) = (¬(ℝENNReal.one = ⊤)) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a⟩\n``` [/INST] theorem congrFun : ∀ {α : Sort u} {β : α → Sort v} {f g : (a : α) → β a}, f = g → ⇑f = ⇑g := by sorry ", "theorem edist_mem_nhds : ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x y : α}, y ∈ EMetric.ball y ε ↔ edist y x < ε :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.5072505221981767875 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n    (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α) (x : α) (r : ℝ) (hr : (r ∈ Set.univ) ∧ (r < 0)) :\n    Edist x 0 = edist r = edist 0 0 := by sorry ", "theorem self_mem_SetD : ∀ D : Multicorner, Set.Mem.self x_1 D → x_1 ∈ D.range.val := by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E} {x : E},\n  MeasureTheory.pdf.uniformPDF s x = if (x ∈ s) then (↑↑μ s)⁻¹ else 0)", "theorem": "theorem MeasureTheory.pdf.uniformPDF_ite :\n    (∀ {E : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E} {x : E},\n      MeasureTheory.pdf.uniformPDF s x = if (x ∈ s) then (↑↑μ s)⁻¹ else 0) :=\n  by sorry", "name": "MeasureTheory.pdf.uniformPDF_ite", "lemma-type": "∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v", "lemma": "theorem ite_congr :\n    ∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n      b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v :=\n  by sorry", "doc_string": "Alternative way of writing the uniformPDF. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Equiv.injective :\n    ∀ {α : Sort u_6} {β : Sort u_7} (f : α ≃ β), Function.Injective ⇑f := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem measurable_const :\n    ∀ {α : Type u_2} {δ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace δ]\n      [inst_2 : DecidableEq α] [inst_3 : MeasurableSingletonClass δ] (c : δ), Measurable fun x => c :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem MeasureTheory.pdf.pdfEq_uniformPDFEq_iff :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] {℈ : MeasurableSpace α) {η₀ : ETumoriSMulUnit ℝ ℝ}\n      {F : (a : α) → MeasureTheory.NegInvUnifMeasure η₀} {Fᵐ : (a : α) → (a : μ ≠ MeasureTheory.Measure.noAtoms μ) → PMF},\n      MeasureTheory.MeasureEq fun b => MeasureTheory.mulPDF' F (η₀ ∘ b) (fun B => measureround b (ETumoriSMulUnit.toSMulEquiv ℝ (ENurse.toSmul₀ f) ε) → *ℱ, B.) f =\n        (etm |b → F (ét |b) fun N => PMF.ofFn fun j => ETm₂ᶡᵢ|b * μ |b \\ ETᱛ|).cFun f + ↑↑μ |b \\ ETᱛ|\\.cFun' (MeasureTheory.Measure.inv_smul_mul_of_posSMul : ∀ ⦃γ : ENNReal⦄ ⦃ν : MeasureTheory.Measure η⦄ (x : ε * η =ν)\n            (ψ₁ :\n            φ x ⇑[MeasurableEmbedding.mulRangeIsetEq₁ x (epsNegToSMul.toSMul I ε)] t\n        → Convolution.CauchyIntegral.divN₀ SMulUnit₀ η₂ p x) :=\n  by sorry ", "theorem aux.3570330061892045622 {E : Type u_1} [MeasurableSpace E] :\n    μ.pdf x = It.case_bool (pdf_def μ x, p.pdf.tendsto_filter (_ : MeasurableSet p) (Eq.refl _))) := by sorry\n``` [/INST] theorem ite_eq_right_iff :\n    ∀ {a b c : α}, (b = c) → (a = a) → (c = c → a = b) → if then b = c ∧ a = c else d = e ∧ a = e → (c = c ∧ a = c ↔ b = d) :=\n  by sorry "]}
{"theorem-type": "(∀ {F : Type u_8} {G : Type u_9} {H : Type u_10} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : FunLike F G H]\n  [inst_3 : MonoidHomClass F G H] (f : F), (Function.Injective ⇑f) ↔ (∀ (a : G) (a_1 : f a = 1), a = 1))", "theorem": "theorem injective_iff_map_eq_one :\n    (∀ {F : Type u_8} {G : Type u_9} {H : Type u_10} [inst : Group G] [inst_1 : MulOneClass H] [inst_2 : FunLike F G H]\n      [inst_3 : MonoidHomClass F G H] (f : F), (Function.Injective ⇑f) ↔ (∀ (a : G) (a_1 : f a = 1), a = 1)) :=\n  by sorry", "name": "injective_iff_map_eq_one", "lemma-type": "{F : Type u_8} →\n  {G : Type u_9} →\n    {H : Type u_10} →\n      [Group G] →\n        [MulOneClass H] →\n          [FunLike F G H] →\n            [MonoidHomClass F G H] →\n              (f : F) →\n                (h : ∀ (a : G) (a_1 : f a = 1), a = 1) → (x : G) → (y : G) → (hxy : f x = f y) → (x * y⁻¹ = 1) ↔ (x = y)", "lemma": "theorem aux.755246616879515837 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H] [FunLike F G H]\n    [MonoidHomClass F G H] (f : F) (h : ∀ (a : G) (a_1 : f a = 1), a = 1) (x : G) (y : G) (hxy : f x = f y) :\n    (x * y⁻¹ = 1) ↔ (x = y) := by sorry", "doc_string": "A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`.  ", "generated": ["theorem implies_congr : ∀ {a b c : Sort u} {e : a ↔ b}, (c ↔ b) → (a → c) → (a → b) := by sorry ", "theorem aux.5612312576197013565 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [StrongRegardTo F G H] [MonoidHomClass F G H] (f : F) :\n    (Function.Injective ⇑f) ↔ (* x ∈ Function.InjectiveProperty' * Set.univ)) :\n    ∀ (a : G), ((a ≠ 1) ∧ (f a * f - 1 = 0)) = ((a = nothing ∨ f a = f 1) ∧ (f a = f - FunLike.coe ∘ g *) := by\n  sorry ", "theorem trans : ∀ {α : Sort u} { rational : α → Prop} {x y z : α}, (rational x y) → (rational y z) → (rational x z) :=\n  by sorry ", "theorem isQuotientGroupOfQuotientKer'_neg'Feq : (Function.Injective ⇑QuotientGroupOfQuotientKer') := by sorry ", "theorem aux.3178902661734952574 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H] (f : F) {g : G} {h : H} (x : g = 1 := by sorry) :\n    ((1 = 1) ∧ (f g = 1)) ↔ (f g = 1) := by sorry ", "theorem aux.13702733602846967687 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H] (f : F) : (⇑f = Function.expExpLogCirc ⇑(↑f)), FunLike.coe ⇑f = fun a b ↦ ↑a * b := by\n  sorry ", "theorem aux.12702644973208428792 {F : Type u_8} {G : Type u_9} {H : Type u_10} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H] (f : F) (x : G) : (¬(f x = f 1)) = (¬(↑f x = ↑f 1)) := by sorry ", "theorem one_ne_zero : ∀ {α : Type u_2} [inst : Monoid α] (a : α), 1 ≠ 0 := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n  (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n  Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : α) ↦ 1)))", "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n      (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n      Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : α) ↦ 1))) :=\n  by sorry", "name": "thickenedIndicator_tendsto_indicator_closure", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "As the thickening radius δ tends to 0, the δ-thickened indicator of a set E (in α) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `α →ᵇ ℝ≥0`. Coercions to functions `α → ℝ≥0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ", "generated": ["theorem le_self_fun_set_indicator :\n    ∀ {α : Type u_2} {iU : ℒˣ (UniformSpace.toPseudoMetricSpace α)} (hU : iU ≤ 0) {S : Set α},\n      ‖SetIndicator S fun iY => ↑(DenseInduscation.norm ≤ iU) (↑Y)‖ ≤ max USetIndicator.const D.h nt\n        (Set.indicator SetY i 1 ∉ K) :=\n  by sorry ", "theorem Metric.closedBall_infEdist_le_thickenedIndicator :\n    ∀ {α : Type u_3} [inst : PseudoMetricSpace α] [inst_1 : OpensMeasurableSpace α] {δ : ℝ} {s : Set α}\n      (δpos : δ > 0) (sde : Set.Dense s), (ContinuousOn (Burning.deltaInfEdist sdelta₁s) s) ∧ ∀ x ∈ closure s,\n      edist x (Burning.deltaInfEdist sdelta₁s) ≤ Metric.thickenedIndicator (δ ≠ 0) s δ :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem ite_eq_right_iff : ∀ {α : Sort u} {c : Prop} {x : Decidable c} (b : α), (if c then b else x) = b ↔ c := by\n  sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem mul_self : ∀ {M : Type u} [inst : Mul M] (a : M), a * a = a * a := by sorry ", "theorem nhds_le_nhds :\n    ∀ {α : Type u_1} [inst : UniformSpace α] {f g : α},\n      closure {{g}} ≤ closure ↑(Function.rightInverse filter (Nhds f) (Nhds f)) :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry "]}
{"theorem-type": "(∀ {α : Type u_3} {f : Filter α} {s : (a : ℕ) → Set α} (hs : Filter.HasAntitoneBasis f s) {r : (a : ℕ) → (a : ℕ) → Prop}\n  (hr : ∀ (m : ℕ), ∀ᶠ (n : ℕ) in Filter.atTop, r m n),\n  ∃ φ, (StrictMono φ) ∧ ((∀ ⦃m : ℕ⦄ ⦃n : ℕ⦄ (a : m < n), r (φ m) (φ n)) ∧ (Filter.HasAntitoneBasis f (s ∘ φ))))", "theorem": "theorem Filter.HasAntitoneBasis.subbasis_with_rel :\n    (∀ {α : Type u_3} {f : Filter α} {s : (a : ℕ) → Set α} (hs : Filter.HasAntitoneBasis f s)\n      {r : (a : ℕ) → (a : ℕ) → Prop} (hr : ∀ (m : ℕ), ∀ᶠ (n : ℕ) in Filter.atTop, r m n),\n      ∃ φ, (StrictMono φ) ∧ ((∀ ⦃m : ℕ⦄ ⦃n : ℕ⦄ (a : m < n), r (φ m) (φ n)) ∧ (Filter.HasAntitoneBasis f (s ∘ φ)))) :=\n  by sorry", "name": "Filter.HasAntitoneBasis.subbasis_with_rel", "lemma-type": "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "lemma": "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry", "doc_string": "Given an antitone basis `s : ℕ → Set α` of a filter, extract an antitone subbasis `s ∘ φ`,\n`φ : ℕ → ℕ`, such that `m < n` implies `r (φ m) (φ n)`. This lemma can be used to extract an\nantitone basis with basis sets decreasing \"sufficiently fast\". ", "generated": ["theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem forall_and_distrib :\n    ∀ {α : Prop} {q₀ : α → Prop} {q₁ : α → Prop} {p₀ : Prop} {p₁ : Prop},\n      (∀ (a : q₀ c => p₀) (a' : q₁ b ↔ q₁ c) (q₂ : q₁ b), p₁ (And.intro a H₂)) →\n        (q₀ → p₁) = (sTrunc α q₀) ∧ ((trunc α q_fst₂) ↔ sTrunc α qᵢ₂) :=\n  by sorry ", "theorem IsGaugeOn.symm : FilterBasis -> FilterBasis := by sorry ", "theorem and_self : ∀ (p : Prop), (p ∨ p) = p := by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "theorem strictMono_sUnionIocNodue :\n    ∀ {ι : Type u_3} {s : ι → ℹ} (s0 : ℝ) (hsmono : StrictMono s)\n      (hsnearlyAsc : ∀ ∈ Set.Ioo s0 One.ofF ∞, CauchySeq fun i => Complex.exp ↑↑fun y => 1 − eps / Complex.abs y⁻¹)\n      (hsunonlin : Set.Iio s0 ∪ Set.Ioi s0 ⊆ Insert.Consᵥ Set.Icc s 0 ' Set.Nonempty)\n      (hsconv : s ∘ fun o => List.length fun t => eps * Complex.Gaussia Δ⁻¹ t) (k : ℕ) (p : X ⧸ Complex.ker eps),\n      (fun x => p x.1 (fun l => Complex.Gaussian (↑(p 0) - i) l / ↑s x.1)) (List.sum (bsMultiJet β f _ (p 0))) →\n      ⦃i : 𝕨 = k⦄ (m : 𝕄), 0 < complex.re μ i :=\n  by sorry ", "theorem aux.1928976580043598812 {α : Type u_3} {f : Filter α} {s : (a : ℕ) → Set α} :\n    ∞∃ (_n : 𝕜), IsGLB (⋂ n ∈ Set.Iio _n) s) =\n      ∨ fun (_x : 𝕜) → IsGLB (⋂ n ∈ Set.Iio _x) s :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ} [inst_3 : StrictConvexSpace ℝ E]\n  (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n  (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C))", "theorem": "theorem ae_eq_const_or_norm_average_lt_of_norm_le_const :\n    (∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n      [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n      [inst_3 : StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n      (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C)) :=\n  by sorry", "name": "ae_eq_const_or_norm_average_lt_of_norm_le_const", "lemma-type": "∀ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (x : E) {r : ℝ},\n  r ≠ 0 → interior (Metric.closedBall x r) = Metric.ball x r", "lemma": "theorem interior_closedBall :\n    ∀ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (x : E) {r : ℝ},\n      r ≠ 0 → interior (Metric.closedBall x r) = Metric.ball x r :=\n  by sorry", "doc_string": "If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its average value\nis strictly less than `C`. ", "generated": ["theorem ae_mem_null_or_nmem_null : ∀ (P : α → Prop), η ∈ {x | P x}ᶜ ∨ η = 0 ± ae η {y | P y}ᶜ := by sorry ", "theorem neg_neg : ∀ {α : Type u} [inst : Involute α] (a : α), - -a = a := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x }, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem congrarg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem and_false : ∀ (p : Prop), (p ∧ False) = False := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.2210535745089153479 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ} [StrictConvexSpace ℝ E]\n    (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) : (f =ᶠ[MeasureTheory.NullMeasurableSet μ {x : α | 0 < f x}] 0) <\n      (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) :=\n  by sorry "]}
{"theorem-type": "(∀ {p : ℕ} {n : ℕ} {k : ℕ} (p_large : n < p ^ 2), (Nat.factorization (Nat.choose n k)) p ≤ 1)", "theorem": "theorem Nat.factorization_choose_le_one :\n    (∀ {p : ℕ} {n : ℕ} {k : ℕ} (p_large : n < p ^ 2), (Nat.factorization (Nat.choose n k)) p ≤ 1) := by sorry", "name": "Nat.factorization_choose_le_one", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a", "lemma": "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry", "doc_string": "Primes greater than about `sqrt n` appear only to multiplicity 0 or 1\nin the binomial coefficient. ", "generated": ["rule_name = Nat.eq_zero_or_pos' : -> forall ⦃a b = x ≤ h a b''⦄ → 0 < x → x +=< b b'' := by sorry ", "theorem isROrC_algebra.mul_pos :\n    ∀ {α : Type u} {a a' : α} [self : IsROrC α], a * a' < a * 1 + 0 + a' * 1 := by sorry ", "theorem LE.le.trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Iff.trans : ∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c) := by sorry ", "equation : add_comm := by sorry ", "theorem Nat.factorization_eq_zero : ∀ x, Nat.descFactorization x = ↑x * if0ElseUnit x := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (ys : List α) (f : (a : List α) → β),\n  List.map f ((List.permutationsAux2 t ts [] ys id).2) = (List.permutationsAux2 t ts [] ys f).2)", "theorem": "theorem List.map_permutationsAux2 :\n    (∀ {α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (ys : List α) (f : (a : List α) → β),\n      List.map f ((List.permutationsAux2 t ts [] ys id).2) = (List.permutationsAux2 t ts [] ys f).2) :=\n  by sorry", "name": "List.map_permutationsAux2", "lemma-type": "{α : Type u_1} →\n  {β : Type u_2} →\n    (t : α) → (ts : List α) → (ys : List α) → (f : (a : List α) → β) → (∀ (a : List α), f a = f (List.map id a)) = True", "lemma": "theorem aux.11927832073412003543 {α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (ys : List α)\n    (f : (a : List α) → β) : (∀ (a : List α), f a = f (List.map id a)) = True := by sorry", "doc_string": "The `f` argument to `permutationsAux2` when `r = []` can be eliminated. ", "generated": ["theorem if_pos : ∀ {c : Prop} {h : c}, c → ∀ (q : Prop), q ∧ c → q := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem add : ∀ {G : Type u_1} [inst : Add G] (a1 a2 : G), a1 + a2 = a2 + a1 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem permutationsAux_zpow_append :\n    ∀ (n : ℤ) {β : Type u_2} (xs w : List β)(f : (a : List α) → β), _hp_succ y t_n = z hiphiphip (a :: x) εs := by\n  sorry ", "theorem aux.86782243885177000 {α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (ys : List α) (f : (a : List α) → β)\n    (y : α) (l : List α) (r : List α) (n : List.PermutationsAux2 t ts [] y r) :\n    List.map f r = if List.Node.zero y then [function.update (List.map f r) y ((f y) []); head r] else\n      head (List.sum [[t,(f y)]) :=\n  by sorry ", "theorem aux.3457275477442206867 {α : Type u_1} {β : Type u_2} (t : α) (ts : List α) (ys : List α) (f : (a : List α) → β)\n    (head : α) (tail : List α)\n    (tail_hp :\n      PinWHTHCmp.Arg { head := ((head)), tail := ((tail)) } ↑(List.ofNum (tail, true, (head :: tail).2)) hp) :\n    List.map (fun (x : List α) ↦ f ↑head ++ f x ^ List.cons' (((f ((y :: List.null := true = false) :: t ::ys :: {}).2 = t.head :: t\n              ++ s ++ ys).1 :: true\n          mathbin fun X →\n              x :: List.subst (fun (x : List) ↦ List.null x * t == t := by sorry) X fun s ↦ t else t)) ys =\n        List.map (fun (a₁ : bool) ↦ f head ++ (if not a₁ then [] else ys ++ [t :: tail))) idList a_2 (α := Nat)\n          lt_wfPartrecList.0 → List.PowersNTHDiff (Nat.part_one_add lt.head ++ List_.head ? = ?h) true List.empty :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b)))", "theorem": "theorem not_covBy_iff :\n    (∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b))) := by sorry", "name": "not_covBy_iff", "lemma-type": "∀ {p : Prop}, p → p = True", "lemma": "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry", "doc_string": "If `a < b`, then `b` does not cover `a` iff there's an element in between. ", "generated": ["question:\nAny pointer to Lean 4 code? [/INST] answer : \n<</SYS>>\n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem not_covBy_iff :\n    (∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b))) := by sorry\n``` [/INST] theorem symmAddCommGroup.ovine : 𝖑 AddCommGroup\n_ =\n  OrderedAddCommGroup.toMinimalAddOrder 𝖑 := by sorry ", "answer:\n676909287688952158 {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b) : (¬((a ≤ a) ∧ (a < b))) = ((a < b) ∨ ((¬(a = a)) ∧ (a_1 = b))) := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem Iff.not : ∀ {a b : Prop}, (a ↔ b) → (a ∨ b) ↔ (¬b ∨ ¬a) := by sorry ", "throw away.2 := And.neg_right not_lt_of_lt _ this ;\ntry natAbsMinOrder_lt := null ; forall_in (f : ∫ᶠ (y : α), ↑y < a) ⦃⊢ i = I = 1).cases_string.1 := uptoDownString.eq_zero :\n    f a /* sorry */ ▸ sorry ", "theorem not_covBy_le : ∀ {α : Type u_1} [inst : LE α] {a b c : α}, ¬a ⋖ b → ((a < c) ∨ (c < b)) ↔ (~~(a ⋖ b)", "theorem not_lt_of_covBy : ∀ {α : Type u_1} [dec : LT α] {a b : α}, a ⋖ b → ~d a b = ¬¬b < a := by sorry ", "recipe :\n```lean\ntheorem And. right : ∀ {a b : Prop}, a ∧ b → b := by sorry "]}
{"theorem-type": "(∀ {n : Type u_2} {R : Type u_4} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n  [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) → R},\n  (Matrix.dotProduct (star v) v = 0) ↔ (v = 0))", "theorem": "theorem Matrix.dotProduct_star_self_eq_zero :\n    (∀ {n : Type u_2} {R : Type u_4} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n      [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) → R},\n      (Matrix.dotProduct (star v) v = 0) ↔ (v = 0)) :=\n  by sorry", "name": "Matrix.dotProduct_star_self_eq_zero", "lemma-type": "{n : Type u_2} →\n  {R : Type u_4} →\n    [Fintype n] →\n      [PartialOrder R] →\n        [NonUnitalRing R] →\n          [StarOrderedRing R] →\n            [NoZeroDivisors R] →\n              {v : (a : n) → R} →\n                ((Finset.sum Finset.univ fun (i : n) ↦ star (v i) * v i) = 0) ↔\n                  (∀ (i : n) (a : i ∈ Finset.univ), star (v i) * v i = 0)", "lemma": "theorem aux.16990750079858601994 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} :\n    ((Finset.sum Finset.univ fun (i : n) ↦ star (v i) * v i) = 0) ↔\n      (∀ (i : n) (a : i ∈ Finset.univ), star (v i) * v i = 0) :=\n  by sorry", "doc_string": "Note that this applies to `ℂ` via `Complex.strictOrderedCommRing`. ", "generated": ["theorem Eq.mpr_flip : ∀ {α : Sort u_6} {a b : α} {r e : a → b = b''}, a = a'' → b = b'' → eq_self b → r a'' b'' = e a b :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.17982673543736660579 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} :\n    ∀ (_ : ¬(Matrix.dotProduct (star v) v = 0)), v = StarOrd.expand ⟪_ x, x⟫ _ * v + v := by sorry ", "theorem aux.224260604272179476 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [PartialOrder ℂ]\n    [PartialOrder ℚ] [NonUnitalRing R] [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} :\n    ((fun (m : Fintype n → R) ↦ ε * ‖Multiplicative.OfPrototype.copy (↑m) ε⁻¹‖) v = 0) = (0 = 0) := by sorry ", "theorem aux.37071731499977351 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} (i : n) :\n    ((if (v i = 0) then\n        Vector.starProd v '' fun (y : n) ↦ if (Matrix.mulVec (Matrix.dotProduct v) ↑(Units.mk0 1 1) (Matrix.vecMul y (σ n).symm)) then (v y)⁻¹ * v i else 1 / v i) =\n        0 else 0 / v i = 0) ↔\n      (0 = 0)) :=\n  by sorry ", "theorem aux.5044339036259441237 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} :\n    ((0 = Matrix.dotProduct (Finsupp.stretchDomain v id 0) (Finsupp.stretchDomain v id 0)) ↔\n        False) ↔\n      ((0 = ↑0 * (star (Finsupp.apply id (star ∘ id v))) 0 +\n            Finsupp.sum (Finsupp.stretchDomain v lℑ) (fun (i : n) → star (V i • v i))).not_zero_not_zero) :=\n  by sorry ", "theorem Transvection.star_inv :\n    ∀ {𝕜 : Type u} [inst : IsScalarTower ℝ 𝕜 𝕜] {M : Type v} [inst_2 : PseudoMetricSpace M] [inst_3 : SmoothManifoldWithCorners 𝕜 M],\n        PathConnectedSpace M → differentiable 𝕜 fun set_p => set_p :=\n  by sorry ", "theorem ofNoZeroDivisors :\n    ∀ {L : Type* [inst : LoopFree L] [insti : Function.Injective Lfun] [tL : TopologicalSpace L]\n      [sL : CompactSpace L] [m : Nontrivial L] [inst : NoZeroDivisors L] (hclm : CompactOpenMap Lfun L) (lx : L)\n      (H : Disjoint H lx • H) (i : L) (H₂ : l = H l ×ᶠ Lfun l), H i * H i₂ = 0 → f <| i ×ᶠ Lfun b i × i₂::CoeNTL ― true ⟩\n  =\n  (∀ (y : Submodule (FractZeroHom L) R) [dU : UniqueADD 𝓓 y], yi m · x) :=\n  by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} {A : Type u_4} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n  ⦃f : DualNumber R →ₐ[R] A⦄ ⦃g : DualNumber R →ₐ[R] A⦄ (hε : f DualNumber.eps = g DualNumber.eps), f = g)", "theorem": "theorem DualNumber.algHom_ext :\n    (∀ {R : Type u_1} {A : Type u_4} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\n      ⦃f : DualNumber R →ₐ[R] A⦄ ⦃g : DualNumber R →ₐ[R] A⦄ (hε : f DualNumber.eps = g DualNumber.eps), f = g) :=\n  by sorry", "name": "DualNumber.algHom_ext", "lemma-type": "{R : Type u_1} →\n  {A : Type u_4} →\n    [CommSemiring R] →\n      [Semiring A] →\n        [Algebra R A] →\n          (f : DualNumber R →ₐ[R] A) →\n            (g : DualNumber R →ₐ[R] A) →\n              (hε : f DualNumber.eps = g DualNumber.eps) →\n                AlgHom.comp f (TrivSqZeroExt.inlAlgHom R R R) = AlgHom.comp g (TrivSqZeroExt.inlAlgHom R R R)", "lemma": "theorem aux.13109271303965508504 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R →ₐ[R] A) (g : DualNumber R →ₐ[R] A) (hε : f DualNumber.eps = g DualNumber.eps) :\n    AlgHom.comp f (TrivSqZeroExt.inlAlgHom R R R) = AlgHom.comp g (TrivSqZeroExt.inlAlgHom R R R) := by sorry", "doc_string": "For two `R`-algebra morphisms out of `R[ε]` to agree, it suffices for them to agree on `ε`. ", "generated": ["theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ", "theorem aux.2771996140389281292 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R →ₐ[R] A) (g : DualNumber R →ₐ[R] A) (hε : f DualNumber.eps = g DualNumber.eps) (_x : A) :\n    (algebraMap R (DualNumber R →ₐ[R] A)) DualNumber.eps ⋅ DualNumber.eps := by sorry ", "theorem Units.val_mul : ∀ {M : Type u_2} [inst : MulAction M G₀] (u v : M) (g : G₀), ↑(u * v) = ↑u * ↑v := by sorry ", "theorem RingHom.codomain_tac : ∀ {α : Type u_2} {β : Type u_3} {R := α} {S : β} [inst : Mul R] [inst_1 : Zero R ] [hinst_4 : NonUnitalNonAssocRing α] [inst_2 : IsUnit 1]\n{f : α → β}, RingHom.toFun f = ⇑f := by sorry ", "theorem aux.9708231616841554948 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R →ₐ[R] A) (g : DualNumber R →�olsimp algebraMap R A) (hε : f DualNumber.eps = g DualNumber.eps) :\n    ∀ (s → ⅟1 =ₑ₀ S (DualNumber.inl s)) (y : A (Unit.instSingleₓ (R = Semiring 1))),\n      DualNumber.inl s • { toFun := ((⅟1 * y)), map_mul' := ((extension12.12)) } =\n        g r\n      (1 ((DubiousTypeCast.rawCast Dubious.opaque) y)) ^ Nat.succ :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem comm_rpow : ∀ {M : Type u_1} [inst : DivInvMonoid M] (a : M) (n m : ℤ), a ^ n * a ^ m = a ^ (n + m) := by\n  sorry ", "theorem aux.74309280968166517 {R : Type u_1} {A : Type u_4} [CommSemiring R] [Semiring A] [Algebra R A]\n    (f : DualNumber R →ₐ[R] A) (g : DualNumber R →ₐ[R] A) (hε : f DualNumber.eps = g DualNumber.eps) :\n    f (DualNumber.ext DualNumber.eps) = g (DualNumber.ext DualNumber.eps) := by sorry "]}
{"theorem-type": "(∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  Filter.coprod (Filter.cocompact X) (Filter.cocompact Y) = Filter.cocompact (X × Y))", "theorem": "theorem Filter.coprod_cocompact :\n    (∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n      Filter.coprod (Filter.cocompact X) (Filter.cocompact Y) = Filter.cocompact (X × Y)) :=\n  by sorry", "name": "Filter.coprod_cocompact", "lemma-type": "{X : Type u} →\n  {Y : Type v} →\n    [TopologicalSpace X] →\n      [TopologicalSpace Y] →\n        Filter.HasBasis (Filter.coprod (Filter.cocompact X) (Filter.cocompact Y))\n          (fun (i : Set X × Set Y) ↦ (IsCompact (i.1)) ∧ (IsCompact (i.2))) fun (i : Set X × Set Y) ↦\n          Prod.fst ⁻¹' (i.1)ᶜ ∪ Prod.snd ⁻¹' (i.2)ᶜ", "lemma": "theorem aux.15774923559497529772 {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] :\n    Filter.HasBasis (Filter.coprod (Filter.cocompact X) (Filter.cocompact Y))\n      (fun (i : Set X × Set Y) ↦ (IsCompact (i.1)) ∧ (IsCompact (i.2))) fun (i : Set X × Set Y) ↦\n      Prod.fst ⁻¹' (i.1)ᶜ ∪ Prod.snd ⁻¹' (i.2)ᶜ :=\n  by sorry", "doc_string": "The coproduct of the cocompact filters on two topological spaces is the cocompact filter on\ntheir product. ", "generated": ["theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem Set.image_univ : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} (a : α), Set. image f {x | True} = Set.range f :=\n  by sorry ", "theorem Filter.cocompact_eq_ciinf :\n    ∀ {α : Type u} [inst : TopologicalSpace α], Filter.cocompact α = Filter.ciInf (Filter.comap interior (nhdsSet «expr ∅ »))\n      true_of_not_cofinite :=\n  by sorry ", "theorem aux.7781923406062656653 {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [TopologicalSpace Y] :\n    Equivalent(((IsCompactlySupported fun (x : ι × κ) ↦ true) ⊓\n                  (fun (x : ι × κ) ↦ x.2 ∈ Filter.cocompact Y)) ⊔\n              IsCompl <| (Filter.CoprodPi.tProd Filter.coprod ⟨fun (x : (h : Bool) × a) ↦ true, fun (_x : (h : Bool) × a) ↦ True⟩) +fun (i : (h : Bool) × a) ↦\n                   Set.Finite fun (y : a) ↦ ↑f.1 < True) :=\n  by sorry ", "theorem hasCompl : ∀ {α : Type u_2} [inst : CommRing α] (a : α) (b : α), HasCompl a b → ∃ u v, a = u * b + v := by\n  sorry ", "theorem aux.955920841986442101 {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] (Z : Type u)\n    [TopologicalSpace Z] {f₁ : (a : X) → Z} {f₂ : (a : Y) → Z} : (Compl (Filter.coproduct (Filter.cocompact X)\n        (Filter.cocompact Y)) = Compl (Filter.cocompact (X × Y))) =\n      (compl (Filter.compl (Filter.cocompact (X × Y))) = compl (Filter.compl (Filter.cocompact X) ⊓\n        Filter.compl (Filter.cocompact Y))) :=\n  by sorry ", "theorem IsCompact.compl_inverse :\n    ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : SigmaCompactSpace X] {t U : Set X}, IsCompact t →\n      IsCompact U → CompactCone t ↔ Comap inverse U⁻¹ ⊓ IsCompact ⇑CompactCone.to_equiv _{ carrier := trivial, map_src := eq_top, map_cof := eq_cocompact } ↔ CompactCone t :=\n  by sorry ", "theorem LE.le.le_iff_eq : ∀ {X : Sort u_3} {a b : p}, a ≤ b → (a < b ↔ b ≠ a) := by sorry "]}
{"theorem-type": "(∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {a : M} {b : M}, (↑a = ↑b) ↔ (c a b))", "theorem": "theorem AddCon.eq : (∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {a : M} {b : M}, (↑a = ↑b) ↔ (c a b)) := by sorry", "name": "AddCon.eq", "lemma-type": "∀ {α : Sort u_1} {s₁ : Setoid α} {a b : α}, Quotient.mk'' a = Quotient.mk'' b ↔ Setoid.r a b", "lemma": "theorem Quotient.eq'' : ∀ {α : Sort u_1} {s₁ : Setoid α} {a b : α}, Quotient.mk'' a = Quotient.mk'' b ↔ Setoid.r a b :=\n  by sorry", "doc_string": "Two elements are related by an additive congruence relation `c` iff\nthey are represented by the same element of the quotient by `c`.", "generated": ["theorem Iff.of_eq : ∀ {a b : Prop}, a = b → (a ↔ b) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem congr: ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem AddCon.eq.mp : ∀ {M : Type u_1} [inst : Add M] (p : AddCon M) {a b : M}, (↑a = ↑b ⇨ ★ true) → p a b := by\n  sorry ", "theorem implies_true : ∀ (α : Sort ui), (α → True) = True := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (g : α → β), a₁ = a₂ → g a₁ = g a₂ := by sorry "]}
{"theorem-type": "(∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ))", "theorem": "theorem Complex.tan_eq_zero_iff : (∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) := by sorry", "name": "Complex.tan_eq_zero_iff", "lemma-type": "{θ : ℂ} → (Complex.sin θ / Complex.cos θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)", "lemma": "theorem aux.3388098264719307220 {θ : ℂ} : (Complex.sin θ / Complex.cos θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ) := by sorry", "doc_string": "The tangent of a complex number is equal to zero\niff this number is equal to `k * π / 2` for an integer `k`.\n\nNote that this lemma takes into account that we use zero as the junk value for division by zero.\nSee also `Complex.tan_eq_zero_iff'`.  ", "generated": ["theorem Complex.eq_mul_exp_iff_arg : ∀ {z w : ℂ}, z ≠ 0 → ∀ (β : ℝ), z = w * Complex.exp ↑(Real.pi * 1im β) ↔ Complex.arg w + ↑β = Complex.arg z := by sorry ", "theorem neg_congr : ∀ {α : Type u_1} {a b c : α}, a = b → c = -b → c = -a := by sorry ", "theorem CongrArg.congr : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ", "theorem Complex.tan_mul_pi_div_two_mul_ complex_cos_mul_sin_complex_coe_re :\n    ∀ (z : UpperHalfPlane), Complex.tan ↑z * 2 * ?_z * Complex.cos (-??ℂ) * complex_cos ↑z -\n          Complex.sin (* ?\\_1) * Complex.sin * complex_cos ↑z =\n        ↑2 * Complex.sin ↑z * Complex.cos (*?\\_1 | Complex.cos ↑*z) : Complex.sin -↑??_1 != 0 :=\n  by sorry ", "theorem aux.2108807609734434717 {θ : ℂ} (hθ : Complex.tan θ = 0) : Complex.I + Complex.tan ∞ | Complex.I⁻¹ = 0 :=\n  by sorry ", "theorem Polynomial.eval_root_map :\n    ∀ {K : Type u_1} {ι : Sort v} [inst : Field K] (ϕ : ι → K) (f : Polynomial ι) (a : ι),\n      Polynomial.eval ⇑(fun i => ϕ i) (irreducible f) = Polynomial.eval ⇑φ f a :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\n  (s : Set β) (hs : IsCompact s) (A : Set (BoundedContinuousFunction α β)) (closed : IsClosed A)\n  (in_s : ∀ (f : BoundedContinuousFunction α β) (x : α) (a : f ∈ A), f x ∈ s) (H : Equicontinuous fun (x : ↑A) ↦ ⇑↑x),\n  IsCompact A)", "theorem": "theorem BoundedContinuousFunction.arzela_ascoli₂ :\n    (∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\n      (s : Set β) (hs : IsCompact s) (A : Set (BoundedContinuousFunction α β)) (closed : IsClosed A)\n      (in_s : ∀ (f : BoundedContinuousFunction α β) (x : α) (a : f ∈ A), f x ∈ s)\n      (H : Equicontinuous fun (x : ↑A) ↦ ⇑↑x), IsCompact A) :=\n  by sorry", "name": "BoundedContinuousFunction.arzela_ascoli₂", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [TopologicalSpace α] →\n      [CompactSpace α] →\n        [PseudoMetricSpace β] →\n          (s : Set β) →\n            (hs : IsCompact s) →\n              (A : Set (BoundedContinuousFunction α β)) →\n                (closed : IsClosed A) →\n                  (in_s : ∀ (f : BoundedContinuousFunction α β) (x : α) (a : f ∈ A), f x ∈ s) →\n                    (H : Equicontinuous fun (x : ↑A) ↦ ⇑↑x) →\n                      let F : (a : BoundedContinuousFunction α ↑s) → BoundedContinuousFunction α β :=\n                        BoundedContinuousFunction.comp Subtype.val M;\n                      (f : BoundedContinuousFunction α β) →\n                        (hf : f ∈ A) →\n                          let g : BoundedContinuousFunction α ↑s :=\n                            BoundedContinuousFunction.codRestrict s f (fun (x : α) ↦ in_s f x hf);\n                          (f ∈ BoundedContinuousFunction.comp Subtype.val M '' (F ⁻¹' A)) =\n                            (F g ∈ BoundedContinuousFunction.comp Subtype.val M '' (F ⁻¹' A))", "lemma": "theorem aux.10550589168305302799 {α : Type u} {β : Type v} [TopologicalSpace α] [CompactSpace α] [PseudoMetricSpace β]\n    (s : Set β) (hs : IsCompact s) (A : Set (BoundedContinuousFunction α β)) (closed : IsClosed A)\n    (in_s : ∀ (f : BoundedContinuousFunction α β) (x : α) (a : f ∈ A), f x ∈ s)\n    (H : Equicontinuous fun (x : ↑A) ↦ ⇑↑x) :\n    let F : (a : BoundedContinuousFunction α ↑s) → BoundedContinuousFunction α β :=\n      BoundedContinuousFunction.comp Subtype.val M;\n    (f : BoundedContinuousFunction α β) →\n      (hf : f ∈ A) →\n        let g : BoundedContinuousFunction α ↑s := BoundedContinuousFunction.codRestrict s f (fun (x : α) ↦ in_s f x hf);\n        (f ∈ BoundedContinuousFunction.comp Subtype.val M '' (F ⁻¹' A)) =\n          (F g ∈ BoundedContinuousFunction.comp Subtype.val M '' (F ⁻¹' A)) :=\n  by sorry", "doc_string": "Second version, with pointwise equicontinuity and range in a compact subset. ", "generated": ["theorem isCompact_const : ∀ {α : Type u} [inst : UniformSpace α] (s : Set α), IsCompact s ↔ Set.Finite {t : UniformSingletonClass α | t xi =ᶠ[(inst : UniformSpace α) (x : α), x +ᶠ[⊤] ↦ t ↑j] t} :=\n  by sorry ", "theorem Set.mem_range : ∀ w ↦ w ∈ Set.range f := by sorry ", "theorem IsCompl.mono : ∀ {P Q S : Sort u} (P : Set P) (h : IsCompl S ↑P), { f as t, b x h as | c rst h } ∈ S = S :=\n  by sorry ", "theorem implies_congr : ∀ {a₁ a₂ : Sort u} {b₁ b₂ : Sort v} {p₁ p₂ : (a₁, a₂) → (b₁, b₂) → Prop},\n    (a₁ = a₂) → (b₁ = b₂) → (p₁ a₁ b₁ = p₂ a₂ b₂) → (a₁ = a₂) → (b₁ = b₂) → ∀ (x : a₁ = a₂), p₁ a₁ b₁ = p₂ a₂ b₂ := by\n  sorry ", "theorem Bornology.withPseudoMetricOrBounded_zero : For M, Bornology.withPseudoMetricOrBounded 0 := by sorry ", "theorem aux.11066114009761016090 {α : Type u} {β : Type v} [TopologicalSpace α] [CompactSpace α] [PseudoMetricSpace β]\n    (s : Set β) (hs : IsCompact s) (A : Set (BoundedContinuousFunction α β)) (closed : IsClosed A)\n    (in_s : ∀ (f : BoundedContinuousFunction α β) (x : α) (a : f ∈ A), f x ∈ s) (H : Equicontinuous fun (x : ↑A) ↦ ⇑↑x)\n    (φ : nontriviallyNormedField G) (p : Subsemigroup G) : {1 : α} ⊆ setUniv := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "**Question:**\n\nShould we add the following lemma to `Lean.Meta.Instances.NormedAddCommGroup` in Lean 4?\n\n`lemma isConnected_univ : (∀ {E : Type u_8} [inst : NormedAddCommGroup E] [inst_1 : Nontrivial E], IsConnectedSet Set.univ)`\n```lean\nimport Algebra.Ring.Tower.Pred\nimport Algebra.CharP.pred\nimport Function.iterate\nimport OrderRing.sup_lt_left\nimport OrderRing.sub_negGiaco :\nimport MulOpposite.CoeFunctor\nimport Algebra.Unitary\nimport DFinsupp.Lex\nimport linearRecurrence\nopen DFinsupp MulOpposite\n\nrecover_eq : {s : DFinsupp Function.unop Hom.coprime} | (↑s, Subtype.property s) = (UPosCoproduce.coempty ((↑s, true).val, bs), true) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n  [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n  {s : Set α} (hs : MeasurableSet s),\n  ∀ᵐ (x : α) ∂μ,\n    Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x) (nhds (Set.indicator s 1 x)))", "theorem": "theorem VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet :\n    (∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n      [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n      {s : Set α} (hs : MeasurableSet s),\n      ∀ᵐ (x : α) ∂μ,\n        Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x)\n          (nhds (Set.indicator s 1 x))) :=\n  by sorry", "name": "VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet", "lemma-type": "{α : Type u_1} →\n  [MetricSpace α] →\n    {m0 : MeasurableSpace α} →\n      {μ : MeasureTheory.Measure α} →\n        (v : VitaliFamily μ) →\n          [SecondCountableTopology α] →\n            [BorelSpace α] →\n              [MeasureTheory.IsLocallyFiniteMeasure μ] →\n                {s : Set α} →\n                  (hs : MeasurableSet s) →\n                    {x : α |\n                        ∀\n                          (a :\n                            x ∈\n                              {x : α |\n                                (fun (x : α) ↦\n                                    Filter.Tendsto (fun (a : Set α) ↦ ↑↑(MeasureTheory.Measure.restrict μ s) a / ↑↑μ a)\n                                      (VitaliFamily.filterAt v x)\n                                      (nhds (MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict μ s) μ x)))\n                                  x}),\n                          x ∈\n                            {x : α |\n                              ∀\n                                (a :\n                                  x ∈\n                                    {x : α |\n                                      (fun (x : α) ↦\n                                          MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict μ s) μ x =\n                                            Set.indicator s 1 x)\n                                        x}),\n                                x ∈\n                                  {x : α |\n                                    (fun (x : α) ↦\n                                        Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a)\n                                          (VitaliFamily.filterAt v x) (nhds (Set.indicator s 1 x)))\n                                      x}}} ∈\n                      MeasureTheory.Measure.ae μ", "lemma": "theorem aux.12780148181548085803 {α : Type u_1} [MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n    (v : VitaliFamily μ) [SecondCountableTopology α] [BorelSpace α] [MeasureTheory.IsLocallyFiniteMeasure μ] {s : Set α}\n    (hs : MeasurableSet s) :\n    {x : α |\n        ∀\n          (a :\n            x ∈\n              {x : α |\n                (fun (x : α) ↦\n                    Filter.Tendsto (fun (a : Set α) ↦ ↑↑(MeasureTheory.Measure.restrict μ s) a / ↑↑μ a)\n                      (VitaliFamily.filterAt v x)\n                      (nhds (MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict μ s) μ x)))\n                  x}),\n          x ∈\n            {x : α |\n              ∀\n                (a :\n                  x ∈\n                    {x : α |\n                      (fun (x : α) ↦\n                          MeasureTheory.Measure.rnDeriv (MeasureTheory.Measure.restrict μ s) μ x = Set.indicator s 1 x)\n                        x}),\n                x ∈\n                  {x : α |\n                    (fun (x : α) ↦\n                        Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x)\n                          (nhds (Set.indicator s 1 x)))\n                      x}}} ∈\n      MeasureTheory.Measure.ae μ :=\n  by sorry", "doc_string": "Given a measurable set `s`, then `μ (s ∩ a) / μ a` converges when `a` shrinks to a typical\npoint `x` along a Vitali family. The limit is `1` for `x ∈ s` and `0` for `x ∉ s`. This shows that\nalmost every point of `s` is a Lebesgue density point for `s`. A version for non-measurable sets\nholds, but it only gives the first conclusion, see `ae_tendsto_measure_inter_div`. ", "generated": ["theorem SecondCountableTopology.measurableSet_nhdsWithin :\n    ∀ {α : Type u_2} [inst : MeasurableSpace α] [inst_1 : SecondCountableTopology α] {m : α → Set α},\n      MeasurableSet m → SeparableSpace α :=\n  by sorry ", "theorem Fact.elim : ∀ {n m : ℕ} (m0 : m = n) [h : Fact n], m = n := by sorry ", "theorem And.right_comm : ∀ {a b c : Prop}, a ∧ b ∧ c ↔ a ∧ c ∧ b := by sorry ", "theorem zero_mul : ∀ {M : Type u} [inst : MulZeroClass M] {a : M}, 0 * a = 0 := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem ENNReal.ofReal_pos_of_pos = ENNReal.coe_pos_of_pos : ∀ {x : ℝ} (hX : 0 < x), 0 < (↑x : ENNReal) := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n  {b : α} (a_1 : a < b⁻¹), b < a⁻¹)", "theorem": "theorem lt_inv_of_lt_inv :\n    (∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n      [inst_2 : CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n      [inst_3 : CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n      {a : α} {b : α} (a_1 : a < b⁻¹), b < a⁻¹) :=\n  by sorry", "name": "lt_inv_of_lt_inv", "lemma-type": "{α : Type u} →\n  [inst : Group α] →\n    [LT α] →\n      [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] →\n        [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] →\n          {a : α} →\n            {b : α} →\n              {α : Type u} →\n                [Group α] →\n                  [LT α] →\n                    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] →\n                      [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦\n                            x < x_1] →\n                        {a : α} → {b : α} → (b⁻¹⁻¹ < a⁻¹) = (a < b⁻¹)", "lemma": "theorem aux.4148884859002811555 {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α}\n    {α : Type u} [Group α] [LT α] [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} : (b⁻¹⁻¹ < a⁻¹) = (a < b⁻¹) := by sorry", "doc_string": "**Alias** of the forward direction of `lt_inv'`.", "generated": ["theorem mult_mul_self_right_lt_mul_mul_self_right :\n    ∀ {α : Type u} [inst : LinearOrderedCommSemiring α] [inst_1 : ExistsAddOf LE α]\n      [ι : OneItself α] ⦃F E p : FreeSemiring _ ⥞ₒ[ι] p₂ = funext (Function.comp (⇑FreeMonoid.lift p)),\n        b ≠ c → b * mul one one = c * mul (b ± c) one :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Function.inv_injective : ∀ {f : α → α}, Function.Injective f⁻¹ := by sorry ", "theorem mul_lt_mul_right' :\n    ∀ {α : Type u_1} {M : Type u_2} [inst : OpenPosMulAction M α] {a b : α} {c : M}, c ≠ 0 → b * a < b ↦ c ⁻¹ a ≠ a → c * b < c * a :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem inverse_inv_self : ∀ {α : Type u} [inst : Group α] (a : α), a⁻¹⁻¹ = a := by sorry "]}
{"theorem-type": "(∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z))", "theorem": "theorem Complex.hasSum_sin :\n    (∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z)) := by\n  sorry", "name": "Complex.hasSum_sin", "lemma-type": "(z : ℂ) →\n  ((fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) = fun (n : ℕ) ↦\n      z ^ (2 * n + 1) * Complex.I ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1)) / Complex.I) =\n    ((fun (n : ℕ) ↦ (-1) ^ n * (z ^ (2 * n) * z) / ↑(Nat.factorial (2 * n + 1))) = fun (n : ℕ) ↦\n      z ^ (2 * n) * z * (Complex.I ^ (2 * n) * Complex.I) / ↑(Nat.factorial (2 * n + 1)) / Complex.I)", "lemma": "theorem aux.4984259001235479070 (z : ℂ) :\n    ((fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) = fun (n : ℕ) ↦\n        z ^ (2 * n + 1) * Complex.I ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1)) / Complex.I) =\n      ((fun (n : ℕ) ↦ (-1) ^ n * (z ^ (2 * n) * z) / ↑(Nat.factorial (2 * n + 1))) = fun (n : ℕ) ↦\n        z ^ (2 * n) * z * (Complex.I ^ (2 * n) * Complex.I) / ↑(Nat.factorial (2 * n + 1)) / Complex.I) :=\n  by sorry", "doc_string": "The power series expansion of `Complex.sin`. ", "generated": ["theorem mul_div_assoc : ∀ {α : Type u_1} [inst : Monoid α] (a b c : α), a * b / c = a * (b / c) := by sorry ", "theorem Complex.complex_sin :\n    ∀ (x : ℝ), Complex.sin ↑(↑x * Complex.I) = Finset.sum (insert 1 Finset.empty) fun p ↦ if (Nat.Spaifying.raw.alpha p = HAt.hAt ((2) · 0)) then -ℚ.uproduct ↑(Nat.factorial (p - HAt.At.1)) z else 0 := by sorry ", "theorem div_self : ∀ {G₀ : Type u} [inst : GroupWithZero G₀] {a : G₀} (a_1 : a ≠ 0), a / a = 1 := by sorry ", "theorem normSq_mul :\n    ∀ {R : Type u_1} {M : Type u_2} [ Inst : NormedRing R] [inst_1 : StrongRankCondition R]\n      [inst_2 : FiniteDimensional R M] (a b : M), ‖a * b‖ ^ 2 = ‖a‖ ^ 2 * ‖b‖ ^ 2 + ‖a‖ ^ 2 * (‖a‖ ^ 2 + ‖b‖ ^ 2) :=\n  by sorry ", "theorem Nat. factorial_zero : ∀ (n : ℕ), Nat.factorial 0 = 1 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem mul_pow : ∀ {α : Type u} [inst : Ring α] (a b : α) (n : ℕ), (a * b) ^ n = a ^ n * b ^ n := by sorry ", "theorem not_lt : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), ¬a < b ↔ b ≤ a := by sorry "]}
{"theorem-type": "(∀ {k : Type u} {G : Type u} [inst : CommRing k] {n : ℕ} [inst_1 : Group G] {A : Rep k G}\n  (f : Rep.ofMulAction k G ((a : Fin (n + 1)) → G) ⟶ A) (x : (a : Fin n) → G),\n  (Rep.diagonalHomEquiv n A) f x = (Action.Hom.hom f) fun₀ | Fin.partialProd x => 1)", "theorem": "theorem Rep.diagonalHomEquiv_apply :\n    (∀ {k : Type u} {G : Type u} [inst : CommRing k] {n : ℕ} [inst_1 : Group G] {A : Rep k G}\n      (f : Rep.ofMulAction k G ((a : Fin (n + 1)) → G) ⟶ A) (x : (a : Fin n) → G),\n      (Rep.diagonalHomEquiv n A) f x = (Action.Hom.hom f) fun₀ | Fin.partialProd x => 1) :=\n  by sorry", "name": "Rep.diagonalHomEquiv_apply", "lemma-type": "{k : Type u} →\n  {G : Type u} →\n    [CommRing k] →\n      {n : ℕ} →\n        [Group G] →\n          {A : Rep k G} →\n            (f : Rep.ofMulAction k G ((a : Fin (n + 1)) → G) ⟶ A) →\n              (x : (a : Fin n) → G) →\n                (((Action.Hom.hom f) fun₀ | 1 • Fin.partialProd x => 1 * 1) =\n                    (Action.Hom.hom f) fun₀ | Fin.partialProd x => 1) =\n                  (((Action.Hom.hom f) fun₀ | Fin.partialProd x => 1 * 1) =\n                    (Action.Hom.hom f) fun₀ | Fin.partialProd x => 1)", "lemma": "theorem aux.9799119312425500075 {k : Type u} {G : Type u} [CommRing k] {n : ℕ} [Group G] {A : Rep k G}\n    (f : Rep.ofMulAction k G ((a : Fin (n + 1)) → G) ⟶ A) (x : (a : Fin n) → G) :\n    (((Action.Hom.hom f) fun₀ | 1 • Fin.partialProd x => 1 * 1) = (Action.Hom.hom f) fun₀ | Fin.partialProd x => 1) =\n      (((Action.Hom.hom f) fun₀ | Fin.partialProd x => 1 * 1) = (Action.Hom.hom f) fun₀ | Fin.partialProd x => 1) :=\n  by sorry", "doc_string": "Given a `k`-linear `G`-representation `A`, `diagonalHomEquiv` is a `k`-linear isomorphism of\nthe set of representation morphisms `Hom(k[Gⁿ⁺¹], A)` with `Fun(Gⁿ, A)`. This lemma says that this\nsends a morphism of representations `f : k[Gⁿ⁺¹] ⟶ A` to the function\n`(g₁, ..., gₙ) ↦ f(1, g₁, g₁g₂, ..., g₁g₂...gₙ).` ", "generated": ["theorem aux.7463376481690910487 {k : Type u} {G : Type u} [CommRing k] {n : ℕ} [Group G] {A : Rep k G}\n    (f : Rep.ofMulAction k G ((a : Fin (n + 1)) → G) ⟶ A) (x : (a : Fin n) → G) :\n    Fin.partialProd! x 1 = Fin.snoc (Fin.partialProd x fun _p => 1) (Fin.castSucc Fin.last) := by sorry ", "theorem linearMaps_prod_mk_finite : List.cocombiningList LinearMaps Nat Nat) := by sorry ", "theorem IsEmpty.elim : ∀ {α : Sort u} {p : Prop}, (IsEmpty α → p) → ∀ (x : α), p := by sorry ", "theorem zero_lt_reindexPMul :\n    ∀ {α : Type u_5} {β F : Type u_6}, 1 -⟪b, FinVec.map b fun_₀ 0 => 1⟫_ₜ F / Function.min! ⊺|F↪ ℚ : b ⊕ F ≤ 1 :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry \n  mentionedReferences = [] }\n``` [/INST] theorem Eq.mpr_left : ∀ {x y z : α}, Eq x y → y = x → x = z → y = z := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem CategoryTheory.Limits.HasLift.cokernelCoimage :\n    ∀ {K : Category} (J : Category.Grothentayn K) [inst JP : J.Faithful] [category_inst0 : Category K] (x : K),\n      HasBiproduct K (CategoryTheory.Shift K (ℤ • x)) := by sorry ", "theorem aux.3573635773178995922 {k : Type u} {G : Type u} [inst : CommRing k] {n : ℕ} [group G]\n    (f : Rep.ofMulAction k G ((a : Fin (n + 1)) → G) ⟶ A) (x : (a : Fin n) → G) :\n    1 • ∑ r₀ : (↑(PartialEquiv.symm (Equiv.toPartialEquiv Fin.filterProd)))ˣ,\n        { w := ((Sum.inr r)), h := ((of_eq_true (congrArg\n          (fun x ↦ ((Eq.ndrec G'.left def).casesBot f ⨁\n                Subsingleton.prop)) x))) } ^\n          ↑(Fin.finrotate x) =\n      ↑(GeneralizedEigenspace.coeFnBasisAux f) { w := ((Sum.inr r)), h := ((f)) }) :=\n  by sorry "]}
{"theorem-type": "(∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1), p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂)", "theorem": "theorem NNReal.geom_mean_le_arith_mean2_weighted :\n    (∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1),\n      p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂) :=\n  by sorry", "name": "NNReal.geom_mean_le_arith_mean2_weighted", "lemma-type": "∀ {β : Type u_2} [inst : AddCommMonoid β] {n : ℕ} (f : Fin (n + 1) → β),\n  (Finset.sum Finset.univ fun i => f i) = f 0 + Finset.sum Finset.univ fun i => f (Fin.succ i)", "lemma": "theorem Fin.sum_univ_succ :\n    ∀ {β : Type u_2} [inst : AddCommMonoid β] {n : ℕ} (f : Fin (n + 1) → β),\n      (Finset.sum Finset.univ fun i => f i) = f 0 + Finset.sum Finset.univ fun i => f (Fin.succ i) :=\n  by sorry", "doc_string": "The geometric mean is less than or equal to the arithmetic mean, weighted version\nfor two `NNReal` numbers. ", "generated": ["theorem aux.2094608747990179411 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (h : w₁ + w₂ = 1) :\n    -EuclideanGeometry.Sphere.center_pos := by sorry ", "theorem aux.3723322067487967396 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1) : Nat.rawCast 1 * 0 = 0 := by sorry ", "theorem aux.17205803177677920197 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1) :\n    w₁ % Fintype.card = w₁ := by sorry ", "theorem Matrix.coe'_add :\n    ∀ {m : Type M} {n : Type Δ} (x y : { i // x, j < y}.Pi m α), (⇑add ↑↑r x +⇑add ↑√1 j).toFun y = ⇑w n * x y :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a². a₂ a₂' : α}, a₁ = a₂ → (a₂' = a₂ → a₁ = a₂') := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ", "theorem NNReal.le_sqrt : ∀ {x : NNReal}, 0 < x → x ≤ Real.sqrt f := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n  InnerProductGeometry.angle x (x + y) = Real.arccos (‖x‖ / ‖x + y‖))", "theorem": "theorem InnerProductGeometry.angle_add_eq_arccos_of_inner_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n      InnerProductGeometry.angle x (x + y) = Real.arccos (‖x‖ / ‖x + y‖)) :=\n  by sorry", "name": "InnerProductGeometry.angle_add_eq_arccos_of_inner_eq_zero", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      {x : V} →\n        {y : V} →\n          (h : ⟪x, y⟫_ℝ = 0) → InnerProductGeometry.angle x (x + y) = Real.arccos (⟪x, x + y⟫_ℝ / (‖x‖ * ‖x + y‖))", "lemma": "theorem aux.18251456148979876095 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) : InnerProductGeometry.angle x (x + y) = Real.arccos (⟪x, x + y⟫_ℝ / (‖x‖ * ‖x + y‖)) := by sorry", "doc_string": "An angle in a right-angled triangle expressed using `arccos`. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.4024236747750064455 {V : Type u_1} [NormedAddComm Group V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) : EReal.uncoe = Nat.rawCast 1 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem zero_eq : ∀ {M : Type u_2} [inst : zeroMul M] (a : M), 0 = a ↔ a = 0 := by sorry ", "reply_msg =\n25453840 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0) :\n    ↑Real.pi < InnerProductGeometry.angle x (x + y) := from_script : ∀ {V : Type u_1} [inner : InnerProductSpace ℝ V]\n      {x : V} {y : V}, ⟪x, y⟫_ℝ = 0 → ‖x‖ * InnerProductGeometry.angle x (x + y) = 0 := by sorry ", "theorem NormedAddCommGroup.core.eq_zero_left'_iff :\n    ⇑NormedAddCommGroup.toAsymm =* 0 ↔ ∀ (x : NormedAddCommGroup E), IsUnit (‖x‖) [l] ∨ ‖x‖ = 0 := by sorry "]}
{"theorem-type": "(∀ {ι : Sort u_1} {c : (a : ι) → Set ↑unitInterval} (hc₁ : ∀ (i : ι), IsOpen (c i)) (hc₂ : Set.univ ⊆ ⋃ i, c i),\n  ∃ t,\n    (t 0 = 0) ∧\n      ((Monotone t) ∧ ((∃ n, ∀ (m : ℕ) (a : m ≥ n), t m = 1) ∧ (∀ (n : ℕ), ∃ i, Set.Icc (t n) (t (n + 1)) ⊆ c i))))", "theorem": "theorem exists_monotone_Icc_subset_open_cover_unitInterval :\n    (∀ {ι : Sort u_1} {c : (a : ι) → Set ↑unitInterval} (hc₁ : ∀ (i : ι), IsOpen (c i)) (hc₂ : Set.univ ⊆ ⋃ i, c i),\n      ∃ t,\n        (t 0 = 0) ∧\n          ((Monotone t) ∧\n            ((∃ n, ∀ (m : ℕ) (a : m ≥ n), t m = 1) ∧ (∀ (n : ℕ), ∃ i, Set.Icc (t n) (t (n + 1)) ⊆ c i)))) :=\n  by sorry", "name": "exists_monotone_Icc_subset_open_cover_unitInterval", "lemma-type": "{ι : Sort u_1} →\n  {c : (a : ι) → Set ↑unitInterval} →\n    (hc₁ : ∀ (i : ι), IsOpen (c i)) →\n      (hc₂ : Set.univ ⊆ ⋃ i, c i) → (t : (a : ℕ) → ↑unitInterval) → (t 0 = 0) = (↑(t 0) = ↑0)", "lemma": "theorem aux.659549004083730942 {ι : Sort u_1} {c : (a : ι) → Set ↑unitInterval} (hc₁ : ∀ (i : ι), IsOpen (c i))\n    (hc₂ : Set.univ ⊆ ⋃ i, c i) (t : (a : ℕ) → ↑unitInterval) : (t 0 = 0) = (↑(t 0) = ↑0) := by sorry", "doc_string": "Any open cover of the unit interval can be refined to a finite partition into subintervals. ", "generated": ["theorem LT.lfa_tfae :\n    ∀ {α : Type u_1} [inst : LinearOrder α] {f : ℕ → (a : α) → Prop},\n      (∀ (n : ℕ), lfa f n) ∣ f ((i : ι) → 0) ∧\n        (Function.mul₀ f ∣ Equiv.equivShrink _ i + Equiv.equivExtend (Equiv.mvPolish ι α) H)) :=\n  by sorry\n``` [/INST] theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x → Prop},\n    (∀ (x : α), f x = g x) → (∀ (x : α), f x true) = g x true :=\n  by sorry ", "theorem aux.9508239492777676633 {ι : Sort u_1} {c : (a : ι) → Set ↑unitInterval} (hc₁ : ∀ (i : ι), IsOpen (c i))\n    (hc₂ : Set.univ ⊆ ⋃ i, c i) :\n    let e :\n\n/-- The existence of such a map follows from\n`exists_partition_subset_open_balls_of_finite_cover_balls` and the fact that any collection of closed\ncovering sets whose intersection is nonempty generates a bigger open subset as a barrier for the\nintersection. -/\ntheorem exists_monotone_Icc_normal_subset_open_cover_unitInterval :\n    (∀ {ι : Sort u_1} {c : (a : ι) → Set ↑unitInterval} (hc₁ : ∀ (i : ι), IsOpen (c i)) (hc₂ : Set.univ ⊆ ⋃ i, c i),\n      ∃ t,\n        (t 0 = 0) ∧\n          ((Monotone t) ∧\n            ((Set.univ ⊆ Set.range t) ∧ (∃ i, ∀ k ≤ i, f i ∈ interior (t (Set.pi_unfold t k)) ∨ true)) ∧\n              (∃ b, (b ∈ Set.image f s) ∧ (t (Set.pi_unfold t k) ⊆ Metric.ball b ((g n) b))))) :=\n  by sorry\n``` [/INST] theorem Classical.choose_spec : ∀ {α : Sort u} {p : α → Prop} (h : ∃ a, p a), p (Classical.choose h) := by sorry ", "theorem SetFamily.disjoint_iff :\n    ∀ {α : Type u} {v : α → Set ↑upperUnit [u]} {i × i₁ → Disjoint (v i) (v i₁)}, PairwiseDisjoint v := by sorry ", "theorem aux.13714021861044450588 {ι : Sort u_1} {c : (a : ι) → Set ↑unitInterval} (hc₁ : ∀ (i : ι), IsOpen (c i))\n    (hc₂ : Set.univ ⊆ ⋃ i, c i) : ∃ r, IsGδ r ∧ Bool.brrbit r = Set.univ := by sorry ", "theorem exists_isOpen_chain_pred_funct :\n    ∀ (ι : Sort u_1) (P : PUnit → Prop), (∀ ⦃l : List P⦄ (p : AllP (List.headI p <<DOT>> P fun v => p <| Units.op (PUnit.out v)),\n            ∃ j₀ c, l = (List.ofFn ↑(Function.uncurry EqvGen.fst c |> Units.map f j₀));\n            ∃ s c δ i e v hv _ σ m, e ∈ f.{m} σ (c = > Units.ofVal ℤ (j₀ : ℤ) delta0) = d,\n            EqPVal ↑(v n) p ↑(Function.cases ↑d <| (Eq.refl (f.1 d) i₀ |>.trans (Nat._add_eq d0 |>.trans (eq_self 0)))) <|\n            i_1 e' = true :=\n  by sorry ", "theorem symm) :=\n  by sorry ", "theorem aux.3565797410249325475 {ι : Sort u_1} {t : (a : ι) → MetricSpace} (htms : ∀ (i : η), MetricSpace.toBasisIndex ⊆ ↑i := by\n  sorry  }) := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} {M : Type u_9} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  (p : Submodule R M), Submodule.map (Submodule.subtype p) ⊤ = p)", "theorem": "theorem Submodule.map_subtype_top :\n    (∀ {R : Type u_1} {M : Type u_9} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n      (p : Submodule R M), Submodule.map (Submodule.subtype p) ⊤ = p) :=\n  by sorry", "name": "Submodule.map_subtype_top", "lemma-type": "{R : Type u_1} →\n  {M : Type u_9} →\n    [Semiring R] →\n      [AddCommMonoid M] →\n        [Module R M] →\n          (p : Submodule R M) → Submodule.map (Submodule.subtype p) ⊤ = LinearMap.range (Submodule.subtype p)", "lemma": "theorem aux.1754794400066525236 {R : Type u_1} {M : Type u_9} [Semiring R] [AddCommMonoid M] [Module R M]\n    (p : Submodule R M) : Submodule.map (Submodule.subtype p) ⊤ = LinearMap.range (Submodule.subtype p) := by sorry", "doc_string": "Under the canonical linear map from a submodule `p` to the ambient space `M`, the image of the\nmaximal submodule of `p` is just `p`. ", "generated": ["theorem Submonoid.coe_top : ∀ {M : Type u_1} [inst : Monoid M], Subsemigroup.carrier ⊤ = ⊤ := by sorry ", "theorem aux.8532876978298160517 {R : Type u_1} {M : Type u_9} [Semiring R] [AddCommMonoid M] [Module R M]\n    (p : Submodule R M) (w : M) (h : p.mem (Submodule.map (Submodule.subtype p) ⊤)) (x : R)\n    (x_1 : ⁅x, w⁆ ∈ p) : x ∩ Algebra.algebraMap R (Submodule R M) w = w := by sorry ", "theorem eq_of_heq : ∀ {α : Sort u} {a a' : α}, HEq a a' → a = a' := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem MapDomain_eq_iff : map DomainName e F ↴ e = Map.MapDomain e F.toLex := by sorry ", "theorem Submodule.to_Subsemilgebra_le_top_submodule'' :\n    ∀ {R : Type u} {S₂ : Type v} [inst : Ring R] {R₂ : Type z} [inst_1 : IsDomain R₂] [inst_2 : Field R₂]\n      [inst_3 : MvPolynomial R R₂] [inst_4 : PowerBasis R R₂] (c : R) (b : rootSet R polySubmodule c), c ∈ b :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem map_top_submodule_of_injective := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α]\n  [inst_2 : OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α}\n  (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n  Filter.Tendsto (fun (x : β) ↦ f x + g x) l Filter.atBot)", "theorem": "theorem Filter.Tendsto.atBot_add :\n    (∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α]\n      [inst_2 : OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α}\n      (hf : Filter.Tendsto f l Filter.atBot) (hg : Filter.Tendsto g l (nhds C)),\n      Filter.Tendsto (fun (x : β) ↦ f x + g x) l Filter.atBot) :=\n  by sorry", "name": "Filter.Tendsto.atBot_add", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [TopologicalSpace α] →\n      [LinearOrderedAddCommGroup α] →\n        [OrderTopology α] →\n          {l : Filter β} →\n            {f : (a : β) → α} →\n              {g : (a : β) → α} →\n                {C : α} →\n                  (hf : Filter.Tendsto f l Filter.atBot) →\n                    (hg : Filter.Tendsto g l (nhds C)) → Filter.Tendsto (fun (x : β) ↦ g x + f x) l Filter.atBot", "lemma": "theorem aux.7652231967440647468 {α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α]\n    [OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) : Filter.Tendsto (fun (x : β) ↦ g x + f x) l Filter.atBot := by sorry", "doc_string": "In a linearly ordered additive commutative group with the order topology, if `f` tends to\n`atBot` and `g` tends to `C` then `f + g` tends to `atBot`. ", "generated": ["theorem IsContinuousOn.add  :\n    ∀ {β : Type u_1} {x y : β} {S : Set β} {l : Filter β} [AddZeroClass β] [AddCommGroup β] {MovableOn β β S L α}\n      [T2Space β] [ContinuousAdd β] [ContinuousStat β S L α] Hx: IsContinuousOn f Ici x →\n      Hy : IsContinuousOn g Ici y → H : (fun x => (f x + g x)ᶜ) ∈ Filter.maps Id x t :=\n      by sorry ", "theorem tendsto_add :\n    ∀ {α : Type u} {β : Type v} {la : Filter α} {lb : Filter β} [inst : Add α] [inst_1 : ContinuousAdd α]\n      {f : α → β} {g : β → α} {ε : β → δ} {φ : Filter (α × δ)},\n      Filter.Tendsto f la φ → Filter.IsCoboundedUnder (Prod.mk □ f) φ → Filter.Tendsto g lb (Prod.map ε φ) →\n        Filter.Tendsto eb' (Prod.map eb φ) (Prod.map ε φ) →\n          (∀ y\n            ⦃e : δ → α⦄ (a : e ~ f a), {x)\n                | y = (eb' * e) x ∨ (y ≠ (eb' * f a) a)},\n            x => x ∈ φ),\n      Filter.IsCobounded Under φ la g '' lb → Filter.Tendsto deb la ε lb :=\n  by sorry ", "theorem Prod.mk.comm :\n    ∀ {σ : σ} {Γ₁₂ : σ} (x₁ : Γ₁₂) (x₂ : σ), x₁, x₂ ∈ σ → (((x₁, x₂), x₂, x₁) ∈ σ).2 := by sorry ", "theorem aux.2197390146864891363 {α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α]\n    [OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) (x : β) : False := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.18222446928780463810 {α : Type u} {β : Type v} [TopologicalSpace α] [LinearOrderedAddCommGroup α]\n    [OrderTopology α] {l : Filter β} {f : (a : β) → α} {g : (a : β) → α} {C : α} (hf : Filter.Tendsto f l Filter.atBot)\n    (hg : Filter.Tendsto g l (nhds C)) :\n    Filter.hasBasis (Filter.comap (AddGroupSeminorm.neg zero_le')) (fun (x : α) ↦ x ≠ 0) ↔ And (Filter.NeBot (l x), ∀ A, A ≤ x) :=\n  by sorry ", "theorem lt_neg_self : ∀ {α : Type u} [inst : CanonicallyOrderedAddGroup α] (a : α), a < -a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {B : C} {A₁ : C} {A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B)\n  [inst_1 : CategoryTheory.Mono f] [inst_2 : CategoryTheory.Mono g] (i : A₁ ≅ A₂)\n  (w : CategoryTheory.CategoryStruct.comp i.hom g = f), CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk g)", "theorem": "theorem CategoryTheory.Subobject.mk_eq_mk_of_comm :\n    (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {B : C} {A₁ : C} {A₂ : C} (f : A₁ ⟶ B) (g : A₂ ⟶ B)\n      [inst_1 : CategoryTheory.Mono f] [inst_2 : CategoryTheory.Mono g] (i : A₁ ≅ A₂)\n      (w : CategoryTheory.CategoryStruct.comp i.hom g = f),\n      CategoryTheory.Subobject.mk f = CategoryTheory.Subobject.mk g) :=\n  by sorry", "name": "CategoryTheory.Subobject.mk_eq_mk_of_comm", "lemma-type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {B A : C} {X : CategoryTheory.Subobject B} (f : A ⟶ B)\n  [inst_1 : CategoryTheory.Mono f] (i : CategoryTheory.Subobject.underlying.toPrefunctor.obj X ≅ A),\n  CategoryTheory.CategoryStruct.comp i.hom f = CategoryTheory.Subobject.arrow X → X = CategoryTheory.Subobject.mk f", "lemma": "theorem CategoryTheory.Subobject.eq_mk_of_comm :\n    ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {B A : C} {X : CategoryTheory.Subobject B} (f : A ⟶ B)\n      [inst_1 : CategoryTheory.Mono f] (i : CategoryTheory.Subobject.underlying.toPrefunctor.obj X ≅ A),\n      CategoryTheory.CategoryStruct.comp i.hom f = CategoryTheory.Subobject.arrow X →\n        X = CategoryTheory.Subobject.mk f :=\n  by sorry", "doc_string": "To show that two subobjects are equal, it suffices to exhibit an isomorphism commuting with\nthe arrows. ", "generated": ["theorem map_zero :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Zero M] [inst_1 : Zero N] [inst_2 : FunLike F M N]\n      [inst_3 : ZeroHomClass F M N] (f : F), f 0 = 0 :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.2595387179690256009 {C : Type u₁} [CategoryTheory.Category.{v₁, u₁} C] {B : C} {A₁ : C} {A₂ : C}\n    (f : A₁ ⟶ B) (g : A₂ ⟶ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : A₁ ≅ A₂)\n    (w : CategoryTheory.CategoryStruct.comp i.hom g = f) : CategoryTheory.Subobject.underlying i = g := by sorry ", "theorem aux.8222846527221942596 {C : Type u₁} [CategoryTheory.Category.{v₁, u₁} C] {B : C} {A₁ : C} {A₂ : C}\n    (f : A₁ ⟶ B) (g : A₂ ⟶ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : A₁ ≅ A₂)\n    (w : CategoryTheory.CategoryStruct.comp i.hom g = f) : ↑(CategoryTheory.CategoryStruct.comp i.inv g) = g := by\n  sorry ", "theorem aux.14556917733561896193 {C : Type u₁} [CategoryTheory.Category.{v₁, u₁} C] {B : C} {A₁ : C} {A₂ : C}\n    (f : A₁ ⟶ B) (g : A₂ ⟶ B) [CategoryTheory.Mono f] [CategoryTheory.Mono g] (i : A₁ ≅ A₂)\n    (w : CategoryTheory.CategoryStruct.comp i.hom g = f) :\n    ((CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.inv i).hom =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f i.hom)) ∧\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.inv i).hom\n          (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.inv i).hom) =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject. arrow i.hom))) ∧\n        ((CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.hom f f).op\n          (f (CategoryTheory.morphismOfMondromoduloPreservesFundamentals hom h₂)) =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Monomorphism.ePIsco f).op\n            (Iso.toEquiv (CategoryTheory.morphismOfMondromoduloPreservesFundamentals m₂))) ∧\n          (f (CategoryTheory.CategoryStruct.comp i.hom\n              (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorUnitBraiding J J)\n                i.hom).op) =\n            CategoryTheory.CategoryStruct.comp\n              (CategoryTheory.MonoidalCategory.tensorMul\n                (CategoryTheory.Iso.inv (CategoryTheory.morphismOfMondromoduloPreservesFundamentals m₂)))\n              (CategoryTheory.LiftableObjData.eq obj a₁)))) =\n      True :=\n  by sorry ", "theorem congrFun : ∀ {α : Sort u} {β : α → Sort v} {x y : α}, (∀ (a : α), x a = y a) → x = y := by sorry ", "theorem CategoryTheory.EquivaDualD.apply_adjunction :\n    ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₄, u₁} C]\n      {self : (self : 𝔸ᵒᵖ) → Culpertone ((self ≌ CulpertoneStone.πCup) (self (Equiv.toContraOp (CategoryTheory.Coyoneda.adjunction\n        (starIsoForCategory PursuitSequence.eqToIso)))\n          ≪≅\n        self ↪coe 𝔸 (self (⇑Con.inv D, Equiv.toContradictableEquivalence\n          inEqToIso PursuitSequence.conIsOfColorEq 𝔸 (Equiv.toPursStone R S)))))))\n        this ❲ ⊤ ×Ὠ (0 ↑d) ⊤ ⊡ Selfℙ, cfuns ((fun T => Subcategory (Self 𝔸) T) _[[Subcategory 𝔸 (Self d d)]]) T) =\n        cTropStmtsSelf X :=\n  by sorry ", "theorem CategoryTheory.Limits.image_mk_self_eq_lift_id :\n    ∀ {R : CategoryTheory.RailwayMap α β γ} {a : α},\n      CategoryTheory.Limits.image ℭ fun f => CategoryTheory.RailwayMapT.Mk f a =\n        f (CategoryTheory.CategoryStruct.id ((eqAsIso a).hom)) :=\n  by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n  [inst_2 : NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [inst_3 : NormedSpace ℝ E]\n  [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f)\n  {g : (a : X) → E} (hg : Continuous g) (h'g : HasCompactSupport g), MeasureTheory.Integrable fun (x : X) ↦ f x • g x)", "theorem": "theorem MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport :\n    (∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n      [inst_2 : NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [inst_3 : NormedSpace ℝ E]\n      [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f)\n      {g : (a : X) → E} (hg : Continuous g) (h'g : HasCompactSupport g),\n      MeasureTheory.Integrable fun (x : X) ↦ f x • g x) :=\n  by sorry", "name": "MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport", "lemma-type": "{X : Type u_1} →\n  {E : Type u_3} →\n    [MeasurableSpace X] →\n      [TopologicalSpace X] →\n        [NormedAddCommGroup E] →\n          {μ : MeasureTheory.Measure X} →\n            [NormedSpace ℝ E] →\n              [OpensMeasurableSpace X] →\n                [T2Space X] →\n                  {f : (a : X) → ℝ} →\n                    (hf : MeasureTheory.LocallyIntegrable f) →\n                      {g : (a : X) → E} →\n                        (hg : Continuous g) →\n                          (h'g : HasCompactSupport g) →\n                            let K : Set X := tsupport g;\n                            (MeasureTheory.Integrable fun (x : X) ↦ f x • g x) =\n                              (MeasureTheory.Integrable (Set.indicator K fun (x : X) ↦ f x • g x))", "lemma": "theorem aux.1421161873440033243 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [NormedSpace ℝ E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    let K : Set X := tsupport g;\n    (MeasureTheory.Integrable fun (x : X) ↦ f x • g x) =\n      (MeasureTheory.Integrable (Set.indicator K fun (x : X) ↦ f x • g x)) :=\n  by sorry", "doc_string": "If `f` is locally integrable and `g` is continuous with compact support,\nthen `f • g` is integrable. ", "generated": ["theorem aux.18344686097906465558 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [NormedSpace ℝ E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    ContinuousLinearMap.ofBound 2 (continuous_isAddRightFirstParam [NormedSpace ℝ E] *\n        hg.norm * MeasureTheory.mk measure_isCompact_smul h'g) =\n      ContinuousLinearMap.bind (ContinuousLinearMap.smulRight (ℝ · g)),\n        ContinuousLinearMap.ofBound (‖(ℝ · g)‖ * Function.hasCompactSupport.secondObject) h'g :=\n  by sorry ", "theorem HasCompactSupport.image :\n    ∀ {α : Type u_2} {β : Type u_3} [inst : TopologicalSpace β] [inst_1 : SeminormedAddCommGroup β]\n      (f : α → funs : filter α instREAl) [inst_2 : CondensedSpace X],\n      CondensedSpace α fun Xs fst => ((fun Zs => {i : α | SubsemiNormedAddCommGroup.subset' (inst funx : X =Xinst hx ↦ Zs) (p ≤ ⊤, f₀ Xs _) ∈ X} ↔ HFuns.compFun f ↑f (fun a_1 => Xs · fun x ↦ x ⊔ f₀ X fun (_ : f₀ ≤ (fun i ≡ (X == Xinst hx) ℕ f₁st then x _ else p 0 := Subset.antisymm ⟨X _ h₂ ≡, h := And.left h_2⟩) e) ↦ t e)) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem MeasureTheory.integrable_iff_summable_norm'_of_hasFiniteIntegral :\n    ∀ {α : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F]\n      (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.IsFiniteMeasure μ] {f : ι → F},\n      Function.IsPeak f {k | BddBelow (Function.restrict f k))} ∧\n        {o | IsOpen o ∧ f =ᶠ[MeasureTheory.Measure.ae μ ∣ ↑o] Function.const α (BoundedIsReadable f) → (f ⁻¹' {x = x}) |ᶠ^ᵦ ↑o) →\n        MeasureTheory.Integrable f → (Filter.unif = Filter.atTop ∧ Continuous f → MeasureTheory.Summable (∫⁻ (a : α), ‖f a‖ d μ) ∧ ∫⁻ (i : α), ‖f i =ᶠ[μ] f n i :=\n  by sorry ", "theorem MeasureTheory.integrable_mul_left_iff_cont_top :\n    ∀ {M : Type u_2} {α : Type u_3} [inst : MeasurableSpace M] [inst_1 : Countable M]\n      [inst_2 : MonotoneSupClosed M] [inst_3 : TopologicalSpace M] [inst_4 : BorelSpace $ topologicalSpace M]\n      (I : BoxIntegral.Box ℝ»i) (μ : BoxIntegral.Measure ℝ» I) [inst_5 : MeasureTheory.Measure.IsOpenPosMeasure μ],\n      (∀ (i : M), Measurable (fun J => ↑J ℓ • ↑J.compl + Set.pi (↑↑J) Set.univ) { i }) ↔\n        BoxIntegral.NormedAddGroup.completeFun i μ :=\n  by sorry ", "theorem MeasureTheory.LocallyIntegrable.exists_hasCompactSupport_integral_le_converter :\n    ∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : NormedAddCommGroup E] {A B B' : Set X}\n      {μ : MeasureTheory.Measure X} [inst_2 : NormedSpace ℝ E] [inst_3 : OpensMeasurableSpace X]\n      [inst_4 : T2Space X],\n      A ⊆ B ∪ B' →\n        A ∈ MeasureTheory.Measure.inv_restrictTo μ B B' → ∀[hm0 : MeasureTheory.Measure.IsOpenPosLinMeas μ],\n          MeasureTheory.LocallyIntegrable f →\n            ∃ g ≤ C, HasCompactSupport g → (⇑g =ᶠ[MeasureTheory.Measure.ae MeasureTheory.measure.restrict μ (B ∩ A ∪ B' ∩ A)] f :=\n              f ∐ Filter.comulHintMeasure.restrict μ A) → ∀ A' < A, ∫ (x : X) in A'\\Cap A, f x ∂μ = 0 :=\n  by sorry ", "theorem Continuous.measurable :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\n      [inst_2 : MeasurableSpace α] [inst_3 :OpensMeasurableSpace α] [inst_4 : TopologicalSpace β]\n      [inst_5 : MeasurableSpace β] [inst_6 : BorelSpace β] {f : α → β},\n      Continuous f → Measurable f :=\n  by sorry ", "theorem Continuous.contDiffOn :\n    ∀ (𝕜 : Type u_1) [inst : NontriviallyNormedField 𝕜] [inst_1 : HasStrasumaSections 𝕜]\n      [inst_2 : Boolable SMul (algebraMap 𝕜 E) E] [inst_3 : DisplayedNoArg SMul NNReal]\n      (𝕜' : outParam ℝ) {k : NNReal},\n      ∀ (f : FormalMultilinearSeries E 𝕜 𝕜' E) {n : ℕ} {τ : Type u_1} {s : Set R} {f f_1 : DFinsupp.Lift k (MultilinearMap ℕ ⚠) E NNdiff π}\n        [H : DFinsupp.Lift.boundedCompactE metric τ (Multiplicative k NNReal) fun uvx => ‖svgv ux.toHNNReal uvx ζ ∈ D]\n        [inst_4 : LiftN ℔ (NNReal, E') 𝕜] [h : NNReal (DFinsupp.compInvk f_toNN ρ_toNN) xs] (r y's xsH y'p, bx),\n        NormedSpace.lipschitzOnWith NNReal K (TaylorSeriesToLinear f fN k hy hy') • ‖φ y's t xsH c h‖ ≥ ‖f_1 t{ xsH, y' × yp } b‖) :=\n  Sorry\n``` [/INST] theorem aux.7389525408305970270 (𝕜 : Type u_1) [HasStrasamaSections 𝕜] [Boolean 𝕜] : HNilBool 𝕜 true := by sorry "]}
{"theorem-type": "(∀ {ι : Sort u_2} [inst : Nonempty ι] {f : (a : ι) → ENNReal} {x : ENNReal} (h : x ≠ ⊤), x * iInf f = ⨅ i, x * f i)", "theorem": "theorem ENNReal.mul_iInf :\n    (∀ {ι : Sort u_2} [inst : Nonempty ι] {f : (a : ι) → ENNReal} {x : ENNReal} (h : x ≠ ⊤),\n      x * iInf f = ⨅ i, x * f i) :=\n  by sorry", "name": "ENNReal.mul_iInf", "lemma-type": "{ι : Sort u_2} → [Nonempty ι] → {f : (a : ι) → ENNReal} → {x : ENNReal} → (h : x ≠ ⊤) → iInf f * x = x * iInf f", "lemma": "theorem aux.15433009527274990120 {ι : Sort u_2} [Nonempty ι] {f : (a : ι) → ENNReal} {x : ENNReal} (h : x ≠ ⊤) :\n    iInf f * x = x * iInf f := by sorry", "doc_string": "If `x ≠ ∞`, then left multiplication by `x` maps infimum over a nonempty type to infimum. See\nalso `ENNReal.mul_iInf_of_ne` that assumes `x ≠ 0` but does not require `[Nonempty ι]`. ", "generated": ["theorem aux.17151905500430541150 {ι : Sort u_2} [Nonempty ι] {f : (a : ι) → ENNReal} {x : ENNReal} (h : x ≠ ⊤) :\n    (x * iInf f = ⨅ i, x * f i) ↔\n      (ENNReal.toNNReal x * Fintype.univ.card ∑ ii / 0 + 0 = ENNReal.toNNReal x * Fintype.univ.card ∑ ι => x * f ι) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.13035049161598249697 {ι : Sort u_2} [Nonempty ι] {f : (a : ι) → ENNReal} {x : ENNReal} (h : x ≠ ⊤)\n    (a : 𝒰 f) (s : Finset η) (hs : ↑𝒰.card ≤ s.card) : f ↑𝒰 < ⊤ := by sorry ", "theorem not_ne_iff : ∀ {α : Type u} [inst : PartialOrder α] [inst_1 : orderBot α] {a b : α}, a ≠ b ↔ ↑b < ↑a := by\n  sorry ", "theorem ENNReal.coe_top : ENNReal.top = ⊤ := by sorry ", "theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry ", "theorem aux.9835594859595515689 {ι : Sort u_2} [Nonempty ι] {f : (a : ι) → ENNReal} {x : ENNReal} (h : x ≠ ⊤) :\n    x ≠ ⊥ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]\n  {μ : MeasureTheory.Measure α} {s : Set α} (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.cthickening R s) ≠ ⊤)),\n  Filter.Tendsto (fun (r : ℝ) ↦ ↑↑μ (Metric.cthickening r s)) (nhds 0) (nhds (↑↑μ (closure s))))", "theorem": "theorem tendsto_measure_cthickening :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]\n      {μ : MeasureTheory.Measure α} {s : Set α} (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.cthickening R s) ≠ ⊤)),\n      Filter.Tendsto (fun (r : ℝ) ↦ ↑↑μ (Metric.cthickening r s)) (nhds 0) (nhds (↑↑μ (closure s)))) :=\n  by sorry", "name": "tendsto_measure_cthickening", "lemma-type": "{α : Type u_1} →\n  [PseudoEMetricSpace α] →\n    [MeasurableSpace α] →\n      [OpensMeasurableSpace α] →\n        {μ : MeasureTheory.Measure α} →\n          {s : Set α} →\n            (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.cthickening R s) ≠ ⊤)) →\n              (α : Type) →\n                (β : Type) →\n                  (f : (a : α) → β) →\n                    (l₁ : Filter α) → (l₁' : Filter α) → (e'_4 : l₁ = l₁') → (l₂ : Filter β) → HEq e'_4 e'_4", "lemma": "theorem aux.7281977676738299167 {α : Type u_1} [PseudoEMetricSpace α] [MeasurableSpace α] [OpensMeasurableSpace α]\n    {μ : MeasureTheory.Measure α} {s : Set α} (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.cthickening R s) ≠ ⊤)) (α : Type)\n    (β : Type) (f : (a : α) → β) (l₁ : Filter α) (l₁' : Filter α) (e'_4 : l₁ = l₁') (l₂ : Filter β) : HEq e'_4 e'_4 :=\n  by sorry", "doc_string": "If a set has a closed thickening with finite measure, then the measure of its `r`-closed\nthickenings converges to the measure of its closure as `r` tends to `0`. ", "generated": ["theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem aux.9765229840282534792 {α : Type u_1} [PiNat.FakeNontrivIALookalike α] [inst : CommRing ℝ] [MetricSpace α]\n    [PseudoEMetricSpace α] [MeasurableSpace α] [op : OpensMeasurableSpace α] [ProperSpace α] [MeasurableBorsetini ε]\n    [Nontrivial α] {ε : ℝ} (ε0 : 0 < ε) {R : ENNReal} (hR : ω θ o₀ = ENNReal.oange 0 R * ENNReal.ofReal ε)\n    (s : Set α)\n    (hs : ∃ B, (B ∈ nhdsWithin 0 s) ∧ (∀ R', εR'B = oangle θ b εt₀R') := by sorry ", "theorem aux.7624017733881063786 {α : Type u_1} [PseudoEMetricSpace α] [MeasurableSpace α] {μ : MeasureTheory.Measure α}\n    {s : Set α} : (Nonempty (IsClosed IsEmpty.closed s)) = (IsEmpty s) := by sorry ", "theorem Iff.not : ∀ {a b : Prop}, [(a ↔ b) ↔ (a ↔ (b ↔ a))] = [(a → b) ↔ (b → a)] := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem inner_mul_left_self :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : NormedSpace 𝕜 E]\n      (a : E), ⇑( inner a) =L[𝕜] fun b => a * b :=\n  by sorry ", "theorem tendsto_measure_cthickening_cthc_zero' :\n    ∀ {α : Type u_1} [inst : PseudoEMetricSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]\n      {t : ℝ} {μ : MeasureTheory.Measure α}, (0 < t) → (t > 0) → ∀ (A : Set α), t⁻¹ • MeasureTheory.measure.cthc A = A :=\n  by sorry ", "theorem nhds_neBot :\n    ∀ {α : Type u_2} [inst : TopologicalSpace α] (x : α), Filter.NeBot (nhds x) ↔ ∅ ≠ {x} := by sorry "]}
{"theorem-type": "(∀ (α : Type u) [inst : Finite α] (κ : Type v) [inst : Finite κ],\n  ∃ ι x, ∀ (C : (a : (a : ι) → α) → κ), ∃ l, Combinatorics.Line.IsMono C l)", "theorem": "theorem Combinatorics.Line.exists_mono_in_high_dimension :\n    (∀ (α : Type u) [inst : Finite α] (κ : Type v) [inst : Finite κ],\n      ∃ ι x, ∀ (C : (a : (a : ι) → α) → κ), ∃ l, Combinatorics.Line.IsMono C l) :=\n  by sorry", "name": "Combinatorics.Line.exists_mono_in_high_dimension", "lemma-type": "(α : Type u) →\n  [Finite α] →\n    (κ : Type v) →\n      [Finite κ] →\n        (ι : Type) →\n          (ιfin : Fintype ι) →\n            (hι : ∀ (C : (a : (a : ι) → α) → ULift.{u, v} κ), ∃ l, Combinatorics.Line.IsMono C l) →\n              (C : (a : (a : ι) → α) → κ) →\n                (l : Combinatorics.Line α ι) →\n                  (c : ULift.{u, v} κ) →\n                    (hc :\n                        ∀ (x : α),\n                          (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) =\n                            c) →\n                      (x : α) →\n                        (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c", "lemma": "theorem aux.7627791747048405328 (α : Type u) [Finite α] (κ : Type v) [Finite κ] (ι : Type) (ιfin : Fintype ι)\n    (hι : ∀ (C : (a : (a : ι) → α) → ULift.{u, v} κ), ∃ l, Combinatorics.Line.IsMono C l) (C : (a : (a : ι) → α) → κ)\n    (l : Combinatorics.Line α ι) (c : ULift.{u, v} κ)\n    (hc : ∀ (x : α), (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c)\n    (x : α) : (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c := by sorry", "doc_string": "The Hales-Jewett theorem: for any finite types `α` and `κ`, there exists a finite type `ι` such\nthat whenever the hypercube `ι → α` is `κ`-colored, there is a monochromatic combinatorial line. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem forall_convertible_rel :\n    ∀ {α β : Sort u}, ∀ (r𝑎 : α → β → Prop), (∀ (x r : α y : β), ∃ y' x, y = y' ∧ (x = r α y)).MutIdc := by\n  sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem LE.lt.lt_le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b → a < b → a ≤ b := by sorry ", "theorem Finite.exists_finitemap_image_right_of_maps_mono_top_left :\n    ∀ {α : Type u} [inst : Finite α] (κ : Type v) [instance : Finite κ],\n      ∃ F, ∃ s ⦃a⦄ (a : F a) (a : s a ∈ F (a ⦅)), IsMono ⦃B t : κ⦄.{l + l', Fn A B t} {a b ⦃a' : κ}\n        {C : (a' : (a / ₗ a', b ∈ B) => A a'} →+ B a').Factors (Fn α i A)(a ⇒ (a').val i ⊔ t).map C (Fn.{l.succ, x} α B).val) :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem FG.injective_of : ∀ (G : Type u) [inst : Finite G], Function.Injective FG.toFintype := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n  [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n  f (⨆ i, g i) = ⨅ i, f (g i))", "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n      [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n      [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n      f (⨆ i, g i) = ⨅ i, f (g i)) :=\n  by sorry", "name": "Antitone.map_iSup_of_continuousAt'", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [ConditionallyCompleteLinearOrder α] →\n      [TopologicalSpace α] →\n        [OrderTopology α] →\n          [ConditionallyCompleteLinearOrder β] →\n            [TopologicalSpace β] →\n              [OrderClosedTopology β] →\n                {ι : Sort u_1} →\n                  [Nonempty ι] →\n                    {f : (a : α) → β} →\n                      {g : (a : ι) → α} →\n                        (Cf : ContinuousAt f (iSup g)) →\n                          (Af : Antitone f) →\n                            (bdd : autoParam (BddAbove (Set.range g)) _auto✝) →\n                              (f (sSup (Set.range g)) = ⨅ i, f (g i)) = (sInf (f '' Set.range g) = ⨅ i, f (g i))", "lemma": "theorem aux.17292867447989031936 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β] {ι : Sort u_1}\n    [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto✝) :\n    (f (sSup (Set.range g)) = ⨅ i, f (g i)) = (sInf (f '' Set.range g) = ⨅ i, f (g i)) := by sorry", "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "throw away 𝕜) (h : autoParam (BddAbove (Set.range g)) _auto✝³) :=\n  by sorry ", "theorem aux.10147611809983170893 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α]\n    [TopologicalSpace α] [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β]\n    [OrderClosedTopology β] {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) : f (Supg (Set.range fun (x : ι) ↦ g x)) =ᶠ[iSup g ≤ BddAbove g] f (⨆ g fun (i : ι) ↦ g i) := by sorry ", "theorem continuous_at_inf :\n    ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n      [inst_3 : TopologicalSpace β] [inst_4 : OrderClosedTopology β] {a : α},\n      BddBelow (Set.range fun x => a - x) →\n        ∀ ⦃f g : β →SetState α (Filter β)⦄,\n          Continuous f → Continuous fun x => f x.state - fun a => IsGreatest a :=\n  by sorry ", "theorem Antitone.map_iInf_of_continuousAt :\n    ∀ {α : Type u} {β : Type v} [inst : Nonempty ι] [inst_1 : ConditionallyCompleteLattice α]\n      [inst_2 : TopologicalSpace α] {f i : ι → α} (Cf : ∀ (i : ι), ContinuousAt (f i) default) (Af : Antitone f)\n      (bdd: BddBelow (Set.range fun i => f i (LatticeSubtype.coe i))), f (iInf (P := fun i => IsGLB ( P —> sigmaAlgebra i)) (λ (i : ι) ↦ f i sigma_sUnionIndex.id_mem_i) = iSup fun i => f ⟨i, sigma_sUnionIndex.i fun i => true: (P i : P) -> sigmaAlgebra i.default i) _h).left.pos ) :=\n  by sorry\n``` [/INST] theorem aux.3509325002412414832 : And (_ : TopologicalSpace ia) = True := by sorry ", "theorem Antitone.map_fin_top ::\n    ∀ {α : Type u} {β : Type v} [inst : Finite α] [inst_1 : PartialOrder α] [inst_2 : Preorder β] {f : α → β},\n      Antitone f → f Finset.univ = Finset.max' Finset.univ id :=\n  by sorry ", "theorem aux.9179649935963819893 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β] {ι : Sort u_1}\n    [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto✝) : Equiv.symm orderIsoCompExtrSearch.5 = OrderIso.symm (⇑f) :=\n  by sorry ", "theorem aux.10050537584999768797 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) (i : Option ι)\n    (ii : (i = none) ∨ (Nonempty ↑i)) :\n    f (iSup (Option.map g '' Set.univ)) = ⨅ j, f (g j) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m : ℕ} {n : ℕ}, ↑(m / n) ≤ ↑m / ↑n)", "theorem": "theorem Nat.cast_div_le : (∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m : ℕ} {n : ℕ}, ↑(m / n) ≤ ↑m / ↑n) := by\n  sorry", "name": "Nat.cast_div_le", "lemma-type": "{α : Type u_1} →\n  [LinearOrderedSemifield α] →\n    {m : ℕ} →\n      {n : ℕ} →\n        (n_1 : ℕ) → (h : n = Nat.succ n_1) → ↑(m / Nat.succ n_1) * ↑(Nat.succ n_1) = ↑(m / Nat.succ n_1 * Nat.succ n_1)", "lemma": "theorem aux.1015598105618867187 {α : Type u_1} [LinearOrderedSemifield α] {m : ℕ} {n : ℕ} (n_1 : ℕ)\n    (h : n = Nat.succ n_1) : ↑(m / Nat.succ n_1) * ↑(Nat.succ n_1) = ↑(m / Nat.succ n_1 * Nat.succ n_1) := by sorry", "doc_string": "Natural division is always less than division in the field. ", "generated": ["theorem zero_le _ :\n    ∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Zero α] [inst_2 : OrderedSemiring α] (a : α),\n      0 ≤ a := by sorry ", "theorem div_inv_div : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, a = b * c → (b / c = a) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "answer:\n12939593827002404507 {α : Type u_1} [LinearOrderedSemifield α] {m : ℕ} {n : ℕ} : m / u = u * m := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem ZeroMemClass.nonneg_zero :\n    ∀ {a : Type u_1} {n : outParam * a} [inst : ZeroMemClass n a], 0 <= nonemptypeMaxImpZero n := by sorry ", "theorem coe_nat_nonneg : Nat.cast_nonneg = fun x => Real.casesOn (fun (x_1 : Nat) ↦ ↑x_1) (fun (y : ℂ) ↦ 0) x := by\n  sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n  [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n  f (⨆ i, g i) = ⨅ i, f (g i))", "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n      [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n      [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n      f (⨆ i, g i) = ⨅ i, f (g i)) :=\n  by sorry", "name": "Antitone.map_iSup_of_continuousAt'", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [ConditionallyCompleteLinearOrder α] →\n      [TopologicalSpace α] →\n        [OrderTopology α] →\n          [ConditionallyCompleteLinearOrder β] →\n            [TopologicalSpace β] →\n              [OrderClosedTopology β] →\n                {ι : Sort u_1} →\n                  [Nonempty ι] →\n                    {f : (a : α) → β} →\n                      {g : (a : ι) → α} →\n                        (Cf : ContinuousAt f (iSup g)) →\n                          (Af : Antitone f) →\n                            (bdd : autoParam (BddAbove (Set.range g)) _auto✝) →\n                              (sInf (f '' Set.range g) = ⨅ i, f (g i)) = (sInf (Set.range (f ∘ g)) = ⨅ i, f (g i))", "lemma": "theorem aux.10381276479365710705 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β] {ι : Sort u_1}\n    [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto✝) :\n    (sInf (f '' Set.range g) = ⨅ i, f (g i)) = (sInf (Set.range (f ∘ g)) = ⨅ i, f (g i)) := by sorry", "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ", "generated": ["theorem aux.856482978020659172 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) : iSup f ∈ Set.univ := by sorry ", "theorem Set.mem_range_self : ∀ {α : Type u} {β : Sort v} (f : α → β) (x : α), x ∈ Set.range f iff f x ∈ ↑(Set.range f) :=\n  by sorry ", "theorem aux.77433983883148143 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddBelow (Set.range g)) _auto✝) (i : ι) : ⃫ i, g i \\ᵒᵖ ∪Set Set.univ i = _root_.orderOf i :=\n  by sorry ", "theorem aux.9834335869527700204 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) : f ⇑(Finset.sup (Fintype.piFinset g) fun x ↦ f ∘ g x) = ⨅ a ∈ Finset.univ, f ∘ g a := by sorry ", "theorem antitone_iSup_id : ∀ {X : Type u} [inst : CompleteLattice X], Antitone (⨆ x, id) = id_le f := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem iSup_nonempty_iff_exists :\n    ∀ {ι : Sort u_1} {α : Sort u} {s : ι → Set α}, (Set.Nonempty (iSup s)) ↔ (∃ a, ∃ i, a ∈ s i) := by sorry ", "theorem aux.13485278062373191160 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β] {ι : Sort u_1}\n    [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto✝) (i : ι) : f (Sup (f ∘ g '' Set.range g)) = FSSup (g i) := by\n  sorry "]}
{"theorem-type": "(∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ}\n  {i : Fin (n + 1)},\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.δ X (Fin.succ i))\n      (CategoryTheory.CosimplicialObject.σ X i) =\n    CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n)))", "theorem": "theorem CategoryTheory.CosimplicialObject.δ_comp_σ_succ :\n    (∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ}\n      {i : Fin (n + 1)},\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.δ X (Fin.succ i))\n          (CategoryTheory.CosimplicialObject.σ X i) =\n        CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n))) :=\n  by sorry", "name": "CategoryTheory.CosimplicialObject.δ_comp_σ_succ", "lemma-type": "{C : Type u} →\n  [CategoryTheory.Category.{v, u} C] →\n    (X : CategoryTheory.CosimplicialObject C) →\n      {n : ℕ} →\n        {i : Fin (n + 1)} →\n          CategoryTheory.CategoryStruct.comp\n              ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.δ (Fin.succ i)))\n              ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.σ i)) =\n            CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n))", "lemma": "theorem aux.5937014745764426132 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 1)} :\n    CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.δ (Fin.succ i)))\n        ((CategoryTheory.Functor.toPrefunctor X).map (SimplexCategory.σ i)) =\n      CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.toPrefunctor X).obj (SimplexCategory.mk n)) :=\n  by sorry", "doc_string": "The second part of the third cosimplicial identity ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.16972580388129582656 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 1)} : n = ↑(Fin.castSucc i) := by sorry ", "theorem CategoryTheory.Limits.PushoutCocone.ι_π_assoc :\n    ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f : X ⟶ Y} [inst_1 : CategoryTheory.Epi f]\n      (c : CategoryTheory.Limits.PushoutCocone f (CategoryTheory.Limits.Cocone.ι c))\n      (z : CategoryTheory.Limits.LimitCone c).t.pt f = c.coconePoint :=\n  by sorry ", "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem aux.8594903064162729568 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 1)} (H : i = natZero)\n    (x : SimplexCategoryᵒᵖᵖ) :\n    Nonempty\n      ((CategoryTheory.Functor.toPrefunctor X).map\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id (Opposite.unop x)) i)) =\n      True :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n  Function.Injective ⇑f)", "theorem": "theorem PEquiv.injective_of_forall_ne_isSome :\n    (∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n      Function.Injective ⇑f) :=\n  by sorry", "name": "PEquiv.injective_of_forall_ne_isSome", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If the domain of a `PEquiv` is `α` except a point, its forward direction is injective. ", "generated": ["theorem aux.3827597862122773051 {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α)\n    (h : ∀ (a₁ : α) (a₂ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true) (a : α) (a' : α) (h : f a = f a') : (f a)⁻¹ = ↑(a', f a');\n    (↑a' = ↑((Equiv.inv FunLike.coeFn.inv_fun a').trans f.inv)) := by sorry ", "theorem Option.isSome_iff_exists : ∀ {α : Type u_1} {a : Option α}, Option.isSome a ↔ ∃ o, o = a := by sorry ", "theorem PEquiv.apply_symm_left :\n    ∀ {α : Sort u} {β : Sort v} (g : α ≃. β) (x : α), g.symm (g x) = x := by sorry ", "theorem Option.ne_none_iff_spec : ∀ {α : Sort u} {v : α},v ≠ none ↔ Option.map v id = some ↑v := by sorry ", "theorem Option.some.injection : ∀ {α : Type u} (y : Option α), Function.Injective fun n ↦ nat.left' y ^ n⁻¹ a := by\n  sorry ", "theorem aux.8160277890524413273 {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α)\n    (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true) (a₁ : α) : ∀ (fa₁_is : Option.isSome' (f a₁)); ∀ false : False := by sorry ", "theorem eq_false : ∀ {p : Prop}, (p → False) → p = False := by sorry ", "theorem Trans.trans.trans : ∀ {α : Sort u} {rel : α → α → Prop} (a : α) (b c : α), rel a b → rel b c → rel a c := by\n  sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_2} {F : Type u_4} [inst : EMetricSpace α] [inst_1 : FunLike F α β]\n  [inst_2 : CompleteSpace α] [inst_3 : EMetricSpace β] [inst_4 : DilationClass F α β] (f : F), ClosedEmbedding ⇑f)", "theorem": "theorem Dilation.closedEmbedding :\n    (∀ {α : Type u_1} {β : Type u_2} {F : Type u_4} [inst : EMetricSpace α] [inst_1 : FunLike F α β]\n      [inst_2 : CompleteSpace α] [inst_3 : EMetricSpace β] [inst_4 : DilationClass F α β] (f : F),\n      ClosedEmbedding ⇑f) :=\n  by sorry", "name": "Dilation.closedEmbedding", "lemma-type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {F : Type u_4} →\n      [EMetricSpace α] →\n        [FunLike F α β] →\n          [CompleteSpace α] →\n            [EMetricSpace β] → [DilationClass F α β] → (f : F) → AntilipschitzWith (Dilation.ratio f)⁻¹ ⇑f", "lemma": "theorem aux.459267457831711465 {α : Type u_1} {β : Type u_2} {F : Type u_4} [EMetricSpace α] [FunLike F α β]\n    [CompleteSpace α] [EMetricSpace β] [DilationClass F α β] (f : F) : AntilipschitzWith (Dilation.ratio f)⁻¹ ⇑f := by\n  sorry", "doc_string": "A dilation from a complete emetric space is a closed embedding ", "generated": ["theorem Lipschitz.uncurry_map :\n    ∀ {α : Type u} {β : Type v} {γ : Type w} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n      [inst_2 : PseudoEMetricSpace γ] (f₂ : α → β),\n      ContinuousUncurry₂ (Fst.fst' ∘ f₂) ∧ ContinuousUncurry₂ (Fst.snd' ∘ ContinuousUOEMetric f₂.snd) → LipschitzUncurried (Fst.snd (f₂ a))\n      (GPair.pFun (f₂ a) (Fst.snd f₂).snd f₂, f₂) :=\n  by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α} (f : α → β), a = b → c = a → f a = f b := by sorry ", "theorem congrArgs : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem closedEmbedding_iSup_comp :\n    ∀ {F : ℕ} ,\n      ∀ {Y : Type u₀} [TdF : TopologicalSpaceFun Y (UniformFun Y F)] {𝔖 : Set ((a : Y) → ↑F)}\n        [i] :\n          ∀ c.1 : Set Y ≠ EMPTY_SET,\n            ∀ (f : SetTriv α (↑(Y ⭢ (UniformFun Y F)) c.1)) {ι : TrivFunD εF 𝔖 → ℕ} {g : C(G , uniformFun (↑F) E)},\n              Monovary.ToFilterGi i f ↑g ≤ Filter.principal F g => (Dilation G) :=\n  by sorry ", "theorem Filter.isGaugeFilter_ediam :\n    ∀ {X : Type u_1} [inst : EMetricSpace X], IsGaugeFilter (EMetric.cthickening ∞) := by sorry ", "theorem forall_of_exists : ∀ {α : Sort u_2} {p : α → Prop}, (∀ (a : α), ∃ b, p a b) → (∀ (a : α), p a) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry "]}
{"theorem-type": "(∀ {Ω : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Ω} {ℙ : MeasureTheory.Measure Ω}\n  {μ : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F] {ν : MeasureTheory.Measure F}\n  {X : (a : Ω) → E} {Y : (a : Ω) → F} [inst_2 : MeasureTheory.IsFiniteMeasure ℙ] [inst_3 : MeasureTheory.SigmaFinite μ]\n  [inst_4 : MeasureTheory.SigmaFinite ν] [inst_5 : MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ],\n  (ProbabilityTheory.IndepFun X Y) ↔\n    (MeasureTheory.pdf (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)]\n      fun (z : E × F) ↦ MeasureTheory.pdf X ℙ (z.1) * MeasureTheory.pdf Y ℙ (z.2)))", "theorem": "theorem MeasureTheory.pdf.indepFun_iff_pdf_prod_eq_pdf_mul_pdf :\n    (∀ {Ω : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Ω} {ℙ : MeasureTheory.Measure Ω}\n      {μ : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F] {ν : MeasureTheory.Measure F}\n      {X : (a : Ω) → E} {Y : (a : Ω) → F} [inst_2 : MeasureTheory.IsFiniteMeasure ℙ]\n      [inst_3 : MeasureTheory.SigmaFinite μ] [inst_4 : MeasureTheory.SigmaFinite ν]\n      [inst_5 : MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ],\n      (ProbabilityTheory.IndepFun X Y) ↔\n        (MeasureTheory.pdf (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)]\n          fun (z : E × F) ↦ MeasureTheory.pdf X ℙ (z.1) * MeasureTheory.pdf Y ℙ (z.2))) :=\n  by sorry", "name": "MeasureTheory.pdf.indepFun_iff_pdf_prod_eq_pdf_mul_pdf", "lemma-type": "{Ω : Type u_1} →\n  {E : Type u_2} →\n    [MeasurableSpace E] →\n      {m : MeasurableSpace Ω} →\n        {ℙ : MeasureTheory.Measure Ω} →\n          {μ : MeasureTheory.Measure E} →\n            {F : Type u_3} →\n              [MeasurableSpace F] →\n                {ν : MeasureTheory.Measure F} →\n                  {X : (a : Ω) → E} →\n                    {Y : (a : Ω) → F} →\n                      [MeasureTheory.IsFiniteMeasure ℙ] →\n                        [MeasureTheory.SigmaFinite μ] →\n                          [MeasureTheory.SigmaFinite ν] →\n                            [MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ] → AEMeasurable fun (ω : Ω) ↦ (X ω, Y ω)", "lemma": "theorem aux.6350557509268480231 {Ω : Type u_1} {E : Type u_2} [MeasurableSpace E] {m : MeasurableSpace Ω}\n    {ℙ : MeasureTheory.Measure Ω} {μ : MeasureTheory.Measure E} {F : Type u_3} [MeasurableSpace F]\n    {ν : MeasureTheory.Measure F} {X : (a : Ω) → E} {Y : (a : Ω) → F} [MeasureTheory.IsFiniteMeasure ℙ]\n    [MeasureTheory.SigmaFinite μ] [MeasureTheory.SigmaFinite ν] [MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ] :\n    AEMeasurable fun (ω : Ω) ↦ (X ω, Y ω) := by sorry", "doc_string": "Random variables are independent iff their joint density is a product of marginal densities. ", "generated": ["theorem aux.759196551386242367 {Ω : Type u_1} {E : Type u_2} [MeasurableSpace E] {m : MeasurableSpace Ω}\n    {ℙ : MeasureTheory.Measure Ω} {μ : MeasureTheORY.Measure Ω} [MeasureTheory.IsFiniteMeasure ℙ]\n    [MeasureTheory.SigmaFinite μ] [MeasureTheory.SigmaFinite ν] [MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ] :\n    Filter.tendsto Id (UniformSpace.nhdsFunMap₂ Ω (MeasureTheory. pdf ℙ) (MeasureTheory. Measure.indicator (MeasureTheory.measure μ) univ) (X, Y))\n      (UniformSpace.tendsto_iff₂ fun (t ; a : ℝ) ↦ True) :=\n  by sorry ", "theorem ProbabilityTheory.pdf.ae_eq' (X : Type u_2) (hβ : β = id), MeasureTheory.pdf X X ☔ µ = Subfunctor.ι_dom Dom β :=\n  by sorry ", "theorem MeasureTheory.pdf_mul_pdf_self_unique_forall :\n    ∀ {Ω : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Ω}\n      (ℙ : MeasureTheory.Measure Ω) {μ : MeasureTheory.Measure E} {f g : Ω → ℝ},\n      f(X == 0 → g(X) = 0) = μ g ↔ ProbabilityTheory.pdf X ℙ =ᶠ[μ] X ≠ 0 → f =ᶠ[MeasureTheory.Measure.ae (m × νℙ)₂s] r :=\n  by sorry ", "theorem IsLebesqueMeasure.ext :\n    ∀ {γ : Type u_2} [gc : MeasurableSpace γ] {l₁ : OuterMeasure β} {m₁ : MeasureTheory.MeasurableSpace.NullMeasurableSet β}\n      {l_gc : IsG2OrderIdeal l₁} {l₁₁ :: s₁₁ ← l₁ _ , l₁₂ :: s₁II : { val := l₁ II }) (l₂ : OuterMeasure α)\n      {mαᵒᵖ : MeasureTheory.Measure.ae α} _hcsm_ : γ →*+ MeasureTheory.Measure F →+* β _ l₁ ω ⊚ x✸✿ r, gx lᶜ → ⊤,\n      l₁ < ⊤ => gc = ↑{ mα := ↑λℴx δf ↔ l₁ := l₁ }, y (F _ x (l₁ω _ ^ fun ii => P fun σ => s₁₁ iii ∩ s₁II) ) = f :=\n  by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "theorem MulZeroClass.mul_zero : ∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0 := by sorry ", "function aux.4289480891926772726 {Ω : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Ω}\n    {ℙ : MeasureTheory.Measure Ω} {μ : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F]\n    {ν : MeasureTheory.Measure F} {X : (a : Ω) → E} {Y : (a : Ω) → F} [inst_2 : MeasureTheory.IsFiniteMeasure ℙ]\n    [inst_3 : MeasureTheory.SigmaFinite μ] [inst_4 : MeasureTheory.SigmaFinite ν]\n    [inst_5 : MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ] :\n    ↑measureTheoryQuintalsDistribution X (MeasureTheory.Volume.spanningSets μ λ (x : E) (h : True), True u i).mk\n      (Fintype.measurableLattice BorelGen E) ∈\n      ENNreal.ofReal\n        ℙ :=\n  by sorry ", "theorem MatrixSetId.indepFun_mul_left ;\ninferEventuallyFn\n  (fun _n ↦ ¬((Bornology.cobounded (ulift.{u₀} ℝ) ⊓ NormedAddGroupSeminormFamilyEyesEqId.inst1) \\{i₁i₂, i₂i₃ ∧ !i₃i₄\\}))\n  ConvExpert ▸\n  by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n  (x : V), (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x)", "theorem": "theorem Orientation.rotation_rotation :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle)\n      (θ₂ : Real.Angle) (x : V),\n      (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x) :=\n  by sorry", "name": "Orientation.rotation_rotation", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      [Fact (FiniteDimensional.finrank ℝ V = 2)] →\n        (o : Orientation ℝ V (Fin 2)) →\n          (θ₁ : Real.Angle) →\n            (θ₂ : Real.Angle) →\n              (x : V) →\n                Real.Angle.cos θ₁ ^ Nat.rawCast 1 * Nat.rawCast 1 *\n                    (Real.Angle.cos θ₂ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) =\n                  Real.Angle.cos θ₂ ^ Nat.rawCast 1 * (Real.Angle.cos θ₁ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0", "lemma": "theorem aux.8005496794787824446 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) :\n    Real.Angle.cos θ₁ ^ Nat.rawCast 1 * Nat.rawCast 1 * (Real.Angle.cos θ₂ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) =\n      Real.Angle.cos θ₂ ^ Nat.rawCast 1 * (Real.Angle.cos θ₁ ^ Nat.rawCast 1 * Nat.rawCast 1) + 0 :=\n  by sorry", "doc_string": "Rotating twice is equivalent to rotating by the sum of the angles. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.10605729225322997389 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) :\n    (Orientation.rotation o (θ₁ + θ₂)) ((Orientation.rotation o θ₁) x) =\n      Orientation.rotation o (θ₁ + θ₂ + 0) ((Orientation.rotation o θ₁) x) :=\n  by sorry ", "theorem real_rotmate_of_oangle_ne_pi :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V),\n      O.oangle o x y ≠ ↑Real.pi → Real.Rotation.mk θ (Real.Angle.tan (O.oangle o y x)) = Orientation.rotation o θ :=\n  by sorry ", "theorem neg_neg_eq : ∀ {G : Type u_1} [inst : InvolutiveNeg G] (a : G), - -a = a := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem aux.2837650316923360764 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) :\n    (((InnerProductGeometry.angle ((Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x)) ((Orientation.rotation o θ₂)x))\n            ((Orientation.rotation o θ₂) x) =\n          Real.pi) ↔\n        (Real.angle\n          ((InnerProductGeometry.angle ((Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x)) ((Orientation.rotation o θ₂) x))\n            ((Orientation.rotation o θ₂) x) =\n          Real.pi)) :=\n  by sorry ", "theorem aux.2439950025294268662 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) (δ : Real.Angle) :\n    ((((Orientation.rotation o θ₁) fun (x : V) ↦ hx * Real.Angle.cos δ + Real.Angle.cos δ * hx) =\n          (((Orientation.rotation o θ₁) fun (x : V) ↦ hx * Real.Angle.cos (+ δ) + Real.Angle.cos (+ δ) * hx) *\n              fun (x : V) ↦\n            Real.Angle.cos (+δ) * hx +\n              Real.Angle.cos ((Orientation.rotation o\n                    ((Orientation.rotation o (-↑ dérlong θ)) θ (* -Real.Angle.tan ↑θ)))\n                (-Orientation.rotation.equivStriationAt f x) (f hx))) =\n        -(Orientation.rotation o θ₂) hx -\n          ((Orientation.rotation o θ₁) fun (x : V) ↦ hx * Real.Angle.cos δ + Real.Angle.cos δ * (Real.Angle.toRealAngle z 1)x) *\n            ((Orientation.rotation o (-⁅θ², θ₁⁆)) 1 + Right.neg (Orientation.rotation o (-𝓂 ℝ (-Real.Angle.sin a).toReal + (⊥ ⊔ ⊥) • f)),hx))) =\n      (False := by sorry) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ} (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x)\n  (g'neg : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), g' x ≤ 0) (hg : Filter.Tendsto g Filter.atTop (nhds l)),\n  MeasureTheory.IntegrableOn g' (Set.Ioi a))", "theorem": "theorem MeasureTheory.integrableOn_Ioi_deriv_of_nonpos' :\n    (∀ {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ}\n      (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x) (g'neg : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), g' x ≤ 0)\n      (hg : Filter.Tendsto g Filter.atTop (nhds l)), MeasureTheory.IntegrableOn g' (Set.Ioi a)) :=\n  by sorry", "name": "MeasureTheory.integrableOn_Ioi_deriv_of_nonpos'", "lemma-type": "∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ∈ Set.Ici a", "lemma": "theorem Set.left_mem_Ici : ∀ {α : Type u_1} [inst : Preorder α] {a : α}, a ∈ Set.Ici a := by sorry", "doc_string": "When a function has a limit at infinity, and its derivative is nonpositive, then the derivative\nis automatically integrable on `(a, +∞)`. Version assuming differentiability\non `[a, +∞)`. ", "generated": ["theorem aux.4530729130573421864 {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ}\n    (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x) (g'neg : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), g' x ≤ 0)\n    (hg : Filter.Tendsto g Filter.atTop (nhds l)) : g' =ᶠ[Filter.onFromOn (Filter.smallSets onReal) univ ⊤] g' :=\n  by sorry ", "theorem aux.4258121865352313138 {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ}\n    (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x) (g'neg : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), g' x ≤ 0)\n    (hg :Filter.Tendsto g Filter.atTop (nhds l)) (x : ℝ) (hx : x ∈ Set.Ici a) (j : ℝ) (hx :j ≥ x) : j > a := by sorry ", "theorem LT.lt.ne : ∀ {α : Sort u} [inst : LinearOrder α] {a b : α}, a < b → a ≠ b := by sorry ", "theorem Filter.univ_mem' : ∀ {α : Type u} {f : Filter α} {s : Set α}, (∀ (a : α), a ∈ s) → s ∈ f := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem measurableSet_Ioi :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α],\n      MeasurableSet (Set.Ioi a) :=\n  by sorry ", "theorem MeasureTheory.aecover_Ioi_lt_top :\n    ∀ {μ : MeasureTheory.Measure ℝ} [inst : MeasureTheory.IsFiniteMeasureIntrinsic μ] {r b : ℝ},\n      b ≠ ⊤ → Filter.Liminf (ν → ⊤) ⊥ = ⨆ x ∈ Set.Ioi b, Filter.map MeasureTheory.restrict μ ⊆ nhds x :=\n  by sorry ", "theorem continuousOn_univ :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] [T : PartialOrder α] (h : Monotone a)\n      [self : OrderClosedTopology α], ContinuousOn (@a) Set.univ :=\n  by sorry "]}
{"theorem-type": "(∀ {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) (a_1 : c * a ≡ c * b [MOD c * m]), a ≡ b [MOD m])", "theorem": "theorem Nat.ModEq.mul_left_cancel' :\n    (∀ {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) (a_1 : c * a ≡ c * b [MOD c * m]), a ≡ b [MOD m]) := by sorry", "name": "Nat.ModEq.mul_left_cancel'", "lemma-type": "{a : ℕ} → {b : ℕ} → {c : ℕ} → {m : ℕ} → (hc : c ≠ 0) → (∀ (a_1 : ↑m ∣ ↑b - ↑a), ↑m ∣ ↑b - ↑a) = True", "lemma": "theorem aux.3693335900618259817 {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) :\n    (∀ (a_1 : ↑m ∣ ↑b - ↑a), ↑m ∣ ↑b - ↑a) = True := by sorry", "doc_string": "Cancel left multiplication on both sides of the `≡` and in the modulus.\n\nFor cancelling left multiplication in the modulus, see `Nat.ModEq.of_mul_left`. ", "generated": ["theorem mul_div_assoc.fst : ∀ {R : Type max u_1 u_2} [inst : Ring R] (a b c : R), 0 * (a / c) = 0 := by sorry ", "theorem mul_assoc : ∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.1995992360132111391 {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) :\n    ∀ {c : ℤ} {m : ℤ} (hne : Int.natAbs c * m = Int.natAbs c * Int.natAbs (c * c⁻¹)) (c⁻² : IsUnits m),\n      ↑c * a equivMod m :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "state={ max_length_natPos : Prop, max_out : max_length_natPos → Nat.Pos, eq_true : max_length_natPos → true,\n}\nproof_list : [true] = [] := by sorry ", "theorem modEq_trans : ∀ {R : NonAssocSemiring} {a b c : R}, a ≡ b [R mod] → b ≡ c [R mod] → a ≡ c [R mod] := by sorry ", "theorem Int.ofNat_ne : Nat.ofNat 1 = Nat.succ 0 → ¬ Int.succ 0 = Nat.ofNat 1 := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o y (y - x)) * ‖y‖ = ‖x‖)", "theorem": "theorem Orientation.tan_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o y (y - x)) * ‖y‖ = ‖x‖) :=\n  by sorry", "name": "Orientation.tan_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      [Fact (FiniteDimensional.finrank ℝ V = 2)] →\n        (o : Orientation ℝ V (Fin 2)) →\n          {x : V} →\n            {y : V} →\n              (h : Orientation.oangle o x y = ↑(Real.pi / 2)) →\n                (Real.Angle.tan (Orientation.oangle o y (y - x)) * ‖y‖ = ‖x‖) =\n                  (Real.Angle.tan ↑(InnerProductGeometry.angle y (y - x)) * ‖y‖ = ‖x‖)", "lemma": "theorem aux.3459084036286254778 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) :\n    (Real.Angle.tan (Orientation.oangle o y (y - x)) * ‖y‖ = ‖x‖) =\n      (Real.Angle.tan ↑(InnerProductGeometry.angle y (y - x)) * ‖y‖ = ‖x‖) :=\n  by sorry", "doc_string": "The tangent of an angle in a right-angled triangle multiplied by the adjacent side equals\nthe opposite side, version subtracting vectors. ", "generated": ["theorem aux.12771280237210376142 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) :\n    Orientation.oangle o x y = Orientation.oangle (-o) y x := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.11211386561895788974{V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) : -Orientation.oangle o x y = ↑(Real.pi / 2) := by sorry ", "question:\nNonterminal (simp_rw → true) on Mathlib.Data.Orientation.Basic._auxLemma.35782812201207129765 (x_0 : Type)\n(x_1 : Type) (x_2 : Type) (x_3 : CommRing x_0) (x_4 : CommRing x_1) (x_5 : AddCommGroup x)\n(x_6 : Module x_0 x) (x_1 : Invertible (FiniteDimensional.finrank ℝ V - 1)) :\n    ∀ [x_2 : Invertible (1 - Orientation.tan (Orientation.oangle o y (y - x)))],\n      ⅟ (↑(FiniteDimensional.finrank ℝ V - 1)) •\n          (Complex.sin\n              (Orientation.oangle complex.Ix\n                neg ((Orientation.oangle o x ((Orientation.rotationOrientation o) (Orientation.symm (-1)) x)).toReal\n                    y)⌋₊ - ↑(Real.pi / 2))) +\n            ↑Real.pi \\* Orientation.tan\n          (Orientation.oangle o x ((Orientation.rotation O (-Orientation.oangle o)\n              (Orientation.negOrientation_neg_Orientation.symm o)) ((Orientation.rotation o) y) x)) •\n            -⅟(↑(FiniteDimensional.finrank ℝ V - 1)) • y =\n        ⁅⅟ |(FiniteDimensional.finrank ℝ V - 1)|⁆⁻ •\n          ‖(Orientation.rotation o) (x + (Orientation.rotation O (-Orientation.oangle o)) x ‖^2‖ / 1 - |(FiniteDimensional.finrank ℝ V - 1)‖ ^ 2‖)‖ :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.11639394526551605162 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) :\n    (-Orientation.oangle (-o) x (x - y) = ↑(Real.pi / 2)) =\n      (Real.Angle.tan (-Orientation.oangle (-o) x (x - y)) * ‖x‖ = ‖y‖) :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ℕ) [inst_2 : CharP R p] (hp : p ≠ 2),\n  Polynomial.cyclotomic' 2 R = Polynomial.X + 1)", "theorem": "theorem Polynomial.cyclotomic'_two :\n    (∀ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ℕ) [inst_2 : CharP R p] (hp : p ≠ 2),\n      Polynomial.cyclotomic' 2 R = Polynomial.X + 1) :=\n  by sorry", "name": "Polynomial.cyclotomic'_two", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The second modified cyclotomic polyomial is `X + 1` if the characteristic of `R` is not `2`. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem pow_ne_one_of_two_lt :\n    ∀ {M' : Type u_2} [inst : MonoidWithZeroWithEsup M'] [inst_1 : SuccOrder M'] [hm' : NoZeroSurjective ℕ N'] {m', R := N'.SSup 1} {a : M'} [inst : PosMono ⇑E.sup.toFun],\n      a ≠ 0 → two < m → (R › n_° · ·) a = E (↑(0 ^ n)) = a → False :=\n  by sorry ", "theorem FiniteDimensional.polynomial_alg' :\n    ∀ {R : Type u_8} [inst : CommRing (Polynomial R)], PolynomialRing (Multiset R) Polynomial R := by sorry ", "theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry ", "theorem aux.7932597031660635482 (R : Type u_2) [CommRing R] [IsDomain R] (p : ℕ) [CharP R p] (hp : p ≠ 2) :\n      ZMod.ρ₁ ^ ZMod.val 1 ≠ 2 := by sorry ", "theorem Complex.natStrictEq_induction : ∀ (sεc : Complex →Prop NNReal) prop, sεc 0 ⊠ (fun k t ws kHtk → sεc k (t * tk • v)) rz :=\n  by sorry ", "theorem aux.5783310761928766555 (R : Type u_2) [CommRing R] [IsDomain R] (p : ℕ) [CharP R p] (hp : p ≠ 2) (_j₁ : ℤ)\n    (_j₂ : ℤ) (h : Nat.rawCast 4 * (↑(Int.natAbs _j₁) ^ Nat.rawCast 1 * Nat.rawCast 1) = Nat.rawCast 4 * ↑(_j₂ ^ Nat.rawCast 1)) : 0 + 0 + ↑(Int.natAbs _j₁ ^ Nat.rawCast 1 * Nat.rawCast 1) =\n  ↑(Int.natAbs _j₁ ^ Nat.rawCast 1 * Nat.rawCast 1) := by sorry ", "theorem one_pow : ∀ {M : Type u} [inst : Monoid M] (n : ℕ), 1 ^ n = 1 := by sorry "]}
{"theorem-type": "(∀ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), (IsAddUnit (a + ↑u)) ↔ (IsAddUnit a))", "theorem": "theorem AddUnits.isAddUnit_add_addUnits :\n    (∀ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), (IsAddUnit (a + ↑u)) ↔ (IsAddUnit a)) := by sorry", "name": "AddUnits.isAddUnit_add_addUnits", "lemma-type": "{M : Type u_1} →\n  [AddMonoid M] →\n    (a : M) →\n      (u : AddUnits M) → (x : IsAddUnit (a + ↑u)) → (v : AddUnits M) → (hv : ↑v = a + ↑u) → ↑(v + -u) = ↑v + ↑(-u)", "lemma": "theorem aux.17123692563786591682 {M : Type u_1} [AddMonoid M] (a : M) (u : AddUnits M) (x : IsAddUnit (a + ↑u))\n    (v : AddUnits M) (hv : ↑v = a + ↑u) : ↑(v + -u) = ↑v + ↑(-u) := by sorry", "doc_string": "Addition of a `u : AddUnits M` on the right doesn't affect `IsAddUnit`.", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem add_inv' : ∀ {G : Type u_2} [inst : SubnegZeroMonoid G] (a b : G), (a + b)⁻¹ = a⁻¹ + b⁻¹ := by sorry ", "theorem Zero.add_eq_right : ∀ {M : Type u} [inst : Zero M] {a b : M}, 0 + a = a ↔ b = a := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem AddSubgroup.nsmul_mem :\n    ∀ {M : Type u_1} [inst : AddMulAction M M] [inst_1 : Nontrivariancian M] {N : AddSubmonoid M} (x : N) {n : ℕ},\n      n•x ∈ N ↔ n = 0 ∨ x ∈ N :=\n  by sorry ", "theorem AddUnits.ne_neg :\n    ∀ {R : Type u_6} [inst : Mul ₁C] [inst : AddMonoid R] [inst_1 : Add Monoid 1C] [self : IsLeftRegular 1C]\n      (w : 1C) , w = -1 * w :=\n  by sorry ", "theorem zero_add : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a := by sorry ", "theorem val_add_eq_add_val :\n    ∀ {φ γ : Type u_1} [inst : Add φ] [inst_1 : Add γ] (a b : φ) (c : γ), ↑(a + b) = ↑a + ↑b := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β} (a : PartialEquiv.IsImage e s t),\n  PartialEquiv.target e ∩ ↑(PartialEquiv.symm e) ⁻¹' s = PartialEquiv.target e ∩ t)", "theorem": "theorem PartialEquiv.IsImage.symm_preimage_eq :\n    (∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β} (a : PartialEquiv.IsImage e s t),\n      PartialEquiv.target e ∩ ↑(PartialEquiv.symm e) ⁻¹' s = PartialEquiv.target e ∩ t) :=\n  by sorry", "name": "PartialEquiv.IsImage.symm_preimage_eq", "lemma-type": "∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β},\n  PartialEquiv.IsImage e s t ↔ e.source ∩ ↑e ⁻¹' t = e.source ∩ s", "lemma": "theorem PartialEquiv.IsImage.iff_preimage_eq :\n    ∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β},\n      PartialEquiv.IsImage e s t ↔ e.source ∩ ↑e ⁻¹' t = e.source ∩ s :=\n  by sorry", "doc_string": "**Alias** of the forward direction of `PartialEquiv.IsImage.iff_symm_preimage_eq`.", "generated": ["theorem aux.3448058076243453639 {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} :\n    ∀ {s : Set α} {t : Set β} (a : PartialEquiv.IsImage e s t),\n      ∃ i _, ∀ (x : β) (y : x ∈ i), x ∈ ↑e '' s ∩ PartialEquiv.source e ×ˢ PartialEquiv.target e :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem PartialEquiv.isIMAGE_iff_inter :\n    ∀ {α : Type u_1} {γ : Type u_3} {f : PartialEquiv α γ} {o : Set γ}  {p : PartialFun α γ},\n      𝟮 (p o (Set.inclusion (PartialEquiv.self_ofFun p (Function.InvFunPartial f))) (e.toFun) s)) =\n        { x | ∀ᶠ (y : a) in p o, f ↑y ∈ {y | ↑i y ∈ o }} = {x | f ↑↑i x ∈ {i₂ | ∃ y, x o₃ i₂} ᶜ o₂} :=\n  by sorry ", "theorem partialEquiv_source_subset :\n    ∀ {α : Type u_1} {β : Type u_2} (i : PartialEquiv α β), PartialEquiv.source (⇑i) ⊆ Set.univ := by sorry ", "theorem mem_inter_comm : ∀ {α : Type u₁} {f : Filter α} {s t : Set α}, s ∈ f ∧ t <|> t ∈ f ∧ s ∈ f := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (r : ℝ) (s : Set E),\n  ↑↑μ (r • s) = ENNReal.ofReal |r ^ FiniteDimensional.finrank ℝ E| * ↑↑μ s)", "theorem": "theorem MeasureTheory.Measure.addHaar_smul :\n    (∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n      [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n      [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (r : ℝ) (s : Set E),\n      ↑↑μ (r • s) = ENNReal.ofReal |r ^ FiniteDimensional.finrank ℝ E| * ↑↑μ s) :=\n  by sorry", "name": "MeasureTheory.Measure.addHaar_smul", "lemma-type": "{E : Type u_1} →\n  [NormedAddCommGroup E] →\n    [NormedSpace ℝ E] →\n      [MeasurableSpace E] →\n        [BorelSpace E] →\n          [FiniteDimensional ℝ E] →\n            (μ : MeasureTheory.Measure E) →\n              [MeasureTheory.Measure.IsAddHaarMeasure μ] →\n                (r : ℝ) →\n                  (s : Set E) →\n                    (h : r ≠ 0) → (r ^ FiniteDimensional.finrank ℝ E)⁻¹⁻¹ = r ^ FiniteDimensional.finrank ℝ E", "lemma": "theorem aux.5077392164230726857 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E) [MeasureTheory.Measure.IsAddHaarMeasure μ]\n    (r : ℝ) (s : Set E) (h : r ≠ 0) : (r ^ FiniteDimensional.finrank ℝ E)⁻¹⁻¹ = r ^ FiniteDimensional.finrank ℝ E := by\n  sorry", "doc_string": "Rescaling a set by a factor `r` multiplies its measure by `abs (r ^ dim)`. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem LT.lt.le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b := by sorry ", "theorem eq_or_self : ∀ {α : Sort u_1} (a : α), a = a ∨ ¬a := by sorry ", "theorem aux.9780819149776637284 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n    [MeasureTheory.Measure.IsAddHaarMeasure μ] (r : ℝ) (s : Set E) (hr : r < 0) (x : E) :\n    (r • x = 0 + r • x) = (r • x = r • r • x) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.3146040610635984591 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n    [MeasureTheory.Measure.IsAddHaarMeasure μ] :\n    (measure_theory.Measure.restrict μ (r • s) = ENNReal.restrict ↑0 (r • s) +\n      ↑(AbsoluteValue.abs r • measure_theory.Measure.restrict IsDual.dual μ ↑(Asymptotics.Right.IsBigO WithTop (a ^ (FiniteDimensional.finrank ℝ ε) > 1)))) =\n      (measure_theory.Measure.restrict μ (r • s) =\n        ↑(AbsoluteValue.abs r • measure_theory.Measure.restrict IsDual.dual μ ↑(Asymptotics.Right.IsBigO WithTop (a ^ (FiniteDimensional.finrank ℝ ε) > 1))) +\n            Finset.inf Δ fun a => α * Finset.filter Asymptotics.leftNormal ε' * measure_theory.Measure.toContent μ ↑i →\n        r *= Asymptotics.(norm_eq e) (@IsDualLeft.norm₂₀ i) →\n          measurable ((fun ha : θ = a₁ * ha / a₂) ∧ fun a i : ℝ → Set E → set i ∈ ha + φ u => measure_theory.MeasurableSet Set.univ);\n        r • (Finset.sum Asymptotics.right u fun a => Finset.toEncodable Aa fun a ↔ IsPartRight (AsymptoticsTo.ha)) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem mul_one : ∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] {P : Polynomial R} (hunit : IsUnit P),\n  (IsUnit (Polynomial.coeff P 0)) ∧ (∀ (i : ℕ) (a : i ≠ 0), IsNilpotent (Polynomial.coeff P i)))", "theorem": "theorem Polynomial.coeff_isUnit_isNilpotent_of_isUnit :\n    (∀ {R : Type u_1} [inst : CommRing R] {P : Polynomial R} (hunit : IsUnit P),\n      (IsUnit (Polynomial.coeff P 0)) ∧ (∀ (i : ℕ) (a : i ≠ 0), IsNilpotent (Polynomial.coeff P i))) :=\n  by sorry", "name": "Polynomial.coeff_isUnit_isNilpotent_of_isUnit", "lemma-type": "∀ {R : Type u} [inst : Semiring R] [inst_1 : Nontrivial R], Polynomial.degree 1 = 0", "lemma": "theorem Polynomial.degree_one : ∀ {R : Type u} [inst : Semiring R] [inst_1 : Nontrivial R], Polynomial.degree 1 = 0 :=\n  by sorry", "doc_string": "Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit.\n\nSee also `Polynomial.isUnit_iff_coeff_isUnit_isNilpotent`. ", "generated": ["theorem Polynomial.coe_C :\n    ∀ {R : Type u} [inst : Semiring R] {α : (a : R) → L} (c : α), ↑0 ^ alphas := by sorry ", "theorem Submodule.isNilpotent : ∀ (R : Type u) [inst : CommRing R] {M : Submodule R M} {Q : Submodule R M},\n    M < Q → Polynomial.isNilpotent HomOT.single f → Polynomial.isNilpotent (RingHom.toMultilinearMap h) := by\n  sorry ", "theorem aux.8810033741927588860 {R : Type u_1} [CommRing R] {P : Polynomial R} (hunit : IsUnit P)\n    (hdvd : ∀ (q : Polynomial R) (a : Polynomial.Monic q) (a : Nat.Coprime (Polynomial.deg q) (Polynomial.deg p)),\n      Polynomial.map (Int.castRingHom R) q ∣ P)\n    (hmin : Polynomial.coeff P 0 = 0)\n    (hexp : ∀ {n : ℕ} (a : 0 < n), Polynomial.coeff P n �� 0) :\n    Polynomial.coeff (PolyAnd.left exp.symm + PolyAnd.left exp.symm) 0 simeq 0 := by sorry ", "theorem Set.mem_toFinset' :\n    ∀ {α : Type u_1} {x : α} (a : {x // Finset.toFintype x} = set.unbounded [x] univ), x ∈ set.unbounded (x • nat_iff' x) :=\n  by sorry ", "theorem trans congrArg : ∀ {α : Sort u} {β : Sort v} {a b c : α}, a = b → (∀ (c : α), a = c → b = c) → a = b := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem eq_false : ∀ {p : Prop}, (p → False) → p = False := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β] {k : Set β} {s : Set β}\n  {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x),\n  ∃ t, (k ⊆ t) ∧ ((IsOpen t) ∧ (Bornology.IsBounded (f '' (t ∩ s)))))", "theorem": "theorem Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt :\n    (∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β] {k : Set β} {s : Set β}\n      {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x),\n      ∃ t, (k ⊆ t) ∧ ((IsOpen t) ∧ (Bornology.IsBounded (f '' (t ∩ s))))) :=\n  by sorry", "name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [PseudoMetricSpace α] →\n      [TopologicalSpace β] →\n        {k : Set β} →\n          {s : Set β} →\n            {f : (a : β) → α} →\n              (hk : IsCompact k) →\n                (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x) →\n                  (U : Set β) →\n                    (h :\n                        ((IsOpen U) ∧ (k ⊆ U)) ∧\n                          (∃ i', (i' ∈ Bornology.cobounded α) ∧ (Disjoint (U ∩ s) (f ⁻¹' id i')))) →\n                      (left : (IsOpen U) ∧ (k ⊆ U)) →\n                        (right : ∃ i', (i' ∈ Bornology.cobounded α) ∧ (Disjoint (U ∩ s) (f ⁻¹' id i'))) →\n                          (hUo : IsOpen U) →\n                            (hkU : k ⊆ U) →\n                              (t : Set α) →\n                                (h : (t ∈ Bornology.cobounded α) ∧ (Disjoint (U ∩ s) (f ⁻¹' id t))) →\n                                  (ht : t ∈ Bornology.cobounded α) →\n                                    (hd : Disjoint (U ∩ s) (f ⁻¹' id t)) →\n                                      (U ∩ s ⊆ (f ⁻¹' t)ᶜ) = (Disjoint (U ∩ s) (f ⁻¹' t))", "lemma": "theorem aux.11141344196659783695 {α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {k : Set β}\n    {s : Set β} {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x) (U : Set β)\n    (h : ((IsOpen U) ∧ (k ⊆ U)) ∧ (∃ i', (i' ∈ Bornology.cobounded α) ∧ (Disjoint (U ∩ s) (f ⁻¹' id i'))))\n    (left : (IsOpen U) ∧ (k ⊆ U)) (right : ∃ i', (i' ∈ Bornology.cobounded α) ∧ (Disjoint (U ∩ s) (f ⁻¹' id i')))\n    (hUo : IsOpen U) (hkU : k ⊆ U) (t : Set α) (h : (t ∈ Bornology.cobounded α) ∧ (Disjoint (U ∩ s) (f ⁻¹' id t)))\n    (ht : t ∈ Bornology.cobounded α) (hd : Disjoint (U ∩ s) (f ⁻¹' id t)) :\n    (U ∩ s ⊆ (f ⁻¹' t)ᶜ) = (Disjoint (U ∩ s) (f ⁻¹' t)) := by sorry", "doc_string": "If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. ", "generated": ["theorem aux.9243956950671355327 {α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {k : Set β}\n    {s : Set β} {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x)\n    (hfin : ∃ x, ∀ (e : ℒś α) (a : e ∈ uniformity α), ∃ c, s ×ˢ e ⊆ {p : β × α | p.1 ∈ k ×ˢ (f \"\" (p.2))}):\n    ∀ (ε : (a : α) → ℝ), Filter.UnifIntegrable (fun (g : β × α) ↦ ε (f g.2)) nat σ nhdsWithin 0 1 := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem IsCompact.inter_iUnion_closed :\n    ∀ {X : Type u_1} {s S : Set X} [inst : TopologicalSpace X], IsCompact s → (∀ i ∈ Set.Finite S, IsClosed Set.univ) → ⋂ i ∈ S, s ∩ ⋃ i, s i = s := by sorry ", "theorem aux.15081451847990334508 {α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {k : Set β}\n    {s : Set β} {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x)\n    (tᵢ : (a : β) → Set β) (x : ∀ (i : β), (ContinuousOn (tᵢ i) (borel ↑(tᵢ i))) ∧ (IsOpen (tᵢ i)))\n    (hs : IsOpen ((⋃ i, tᵢ i)ᶜ)) (hst : k ×ˢ s ⊆ Prod.mk' (⋂ i, tᵢ i) ⁻¹' (sᶜ ×ˢ sᶜ)) :\n    ∃ i, IsOpen ((t i ∩ {x : β × β | (x.1, x.2) ∈ s})ᶜ) := by sorry ", "theorem Filter.eventually_ne_atBot :\n    ∀ {c c_1 v : β → E}, (v =* c «±fun x => - c_1 x») → ∀ (L : E → Filters α), Filter.Eventually (c «± L s) v := by\n  sorry ", "theorem Metric.exists_nhds_subset_open_isBounded_ball :\n    ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {s : Set α},\n      IsCompact s → HasDerivWithinAt nf (f' x x) s 2 → ∃ o ∈ nhds x, IsOpen o → BddBelow (\\s ∩ o) → IsBounded (\\s ∩ o) :=\n  by sorry ", "theorem Set.forallSet_iff' : ∀ {X : Type u} {E F : Set Xᵦ ↡ (i : X), X × Prop u} (y ∈ x), Filter.Sets y Ef ↔ y.1 ∈ x ∧ E₂.left y (setOf (f fun ↦ triv))) := by sorry ", "theorem ContinuousWithinAt.on_compact_absorption_on :\n    ∀ {R : X → Proj R} [inst : TConcreteRing X],\n      ∀ {{A : X → α} ⦃r : Xᵦᵐᵗ (R × X)⦄, AbsMk r A, lsA ◫ (id ∘ Proja) <<SYS>>\n          A { x | A (lsRelA x) := A 0 ; ∥R id x∥ ≤ Sinf 𝒜 (R r), id x ∈ A { x | ↑(lsProve R id x) }ᶜ ×ˢ s },\n      AbsoluteExact r A ⟨r, Sinf 𝒜⟩ (Subsystems R) (absInclA r → h : (id ∘ (lsProve refl r)) ≤ A * lsA),\n        r x → { a | ∀ r' ∈ R x ≤ AbsoluteExact r (SinfS r h) 𝒜 r = a } = ‹id ∘ Proja id a = {r' | r' ∈ Sinf 𝒜} lf A› :=\n  by sorry "]}
{"theorem-type": "(∀ {K : Type uK} [inst : Field K] {V₁ : Type uV₁} {V₂ : Type uV₂} [inst_1 : AddCommGroup V₁] [inst_2 : Module K V₁]\n  [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] {f : V₁ →ₗ[K] V₂},\n  (Function.Injective ⇑(LinearMap.dualMap f)) ↔ (Function.Surjective ⇑f))", "theorem": "theorem LinearMap.dualMap_injective_iff :\n    (∀ {K : Type uK} [inst : Field K] {V₁ : Type uV₁} {V₂ : Type uV₂} [inst_1 : AddCommGroup V₁] [inst_2 : Module K V₁]\n      [inst_3 : AddCommGroup V₂] [inst_4 : Module K V₂] {f : V₁ →ₗ[K] V₂},\n      (Function.Injective ⇑(LinearMap.dualMap f)) ↔ (Function.Surjective ⇑f)) :=\n  by sorry", "name": "LinearMap.dualMap_injective_iff", "lemma-type": "{K : Type uK} →\n  [Field K] →\n    {V₁ : Type uV₁} →\n      {V₂ : Type uV₂} →\n        [AddCommGroup V₁] →\n          [Module K V₁] →\n            [AddCommGroup V₂] →\n              [Module K V₂] →\n                {f : V₁ →ₗ[K] V₂} →\n                  (not_surj : ¬(Function.Surjective ⇑f)) →\n                    (inj : Function.Injective ⇑(LinearMap.dualMap f)) →\n                      (Function.Surjective ⇑f) = (LinearMap.range f = ⊤)", "lemma": "theorem aux.9467030196494493139 {K : Type uK} [Field K] {V₁ : Type uV₁} {V₂ : Type uV₂} [AddCommGroup V₁] [Module K V₁]\n    [AddCommGroup V₂] [Module K V₂] {f : V₁ →ₗ[K] V₂} (not_surj : ¬(Function.Surjective ⇑f))\n    (inj : Function.Injective ⇑(LinearMap.dualMap f)) : (Function.Surjective ⇑f) = (LinearMap.range f = ⊤) := by sorry", "doc_string": "`f.dualMap` is injective if and only if `f` is surjective ", "generated": ["algorithm :\n```lean\ntheorem LinearMap.comp :\n    (∀ {R : Type uR} {S : Type uS₁} {Q : Type uHQ} {Q₂ : Type uK} [inst : CommSemiring R] [inst_1 : SemiringSquare Zero R]\n      {T : Type uT} [inst_2 : Semiring S] [inst_3 : SmoothFloor T] [inst_4 : Semiring S₁] [inst_5 : SMul zero R S],\n      Continuous (QuadraticForm.Dual.compSmooth R (LinearMap.flip₂ ((⇑zeroR SMul.toLinear mapDomain S) ∘ₗ ⇑f)\n        (Flip.sumEquiv Flip.fst (Flip.smulFstSndzero T S)))) :\n    Continuous ⇑Flip.smulFstLiftT ZeroSZero.elim TSMapT ₀ SMulT.toSL ⇑FunctionZeroIsTrivial.zeroM.hsmul0 := by\n  sorry ", "theorem aux.3302121111415573705 {K : Type uK} [Field K] {V₁ : Type uV₁} {V₂ : Type uV₂} [AddCommGroup V₁] [Module K V₁]\n    [AddCommGroup V₂] [Module K V₂] {f : V₁ →ₗ[K] V₂} : Function.Injective ⇑f ↔ VFunictopic ⇑f ⇑f := by sorry ", "theorem forall_congr : ∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → (∀ (a : α), p a) ↔ ∀ (a : α), q a :=\n  by sorry ", "theorem aux.1277183800734274732 {K : Type uK} [Field K] {V₁ : Type uV₁} {V₂ : Type uV₂} [AddCommGroup V₁] [Module K V₁]\n    [AddCommGroup V₂] [Module K V₂] {f : V₁ →ₗ[K] V₂} (c : V₂ →ₗᗱ[K V₁] V¹)\n    (h : ∀ (xc : V^{[0]}[i][i.1]) (x1 : V ×ˢ V [[i.1.leftEquiv i.1]] xc),\n        LinearMap.toHomHom c (LinearMap.dualMap f xc) (f x1) =\n        LinearMap.toHomHom c (LinearMap.dualMap f (i.snd tc)) (i.snd tc)) :\n    Function.Injective ⇑(f : V₁ →ₗ[K] V₂) := by sorry ", "theorem Function.Injective.compInjectiveLeft' :\n    ∀ {A : Sort u_19} {B : Sort u_20} [inst : HasSmul A B] {C : Sort u_22} (S : Sort u_23) (B₁ : Sort u_21)⦃i : A ⊗ C →ⶣ B₁ ⦄zᵢ : D.out = Unit. unitᵢ → (fun (ω : A ⊗ C) => ↑(D.monoidHomeomorphism A C S.toEquiv\n          ((TensorProduct.leftReservation, CategoryTheory.Limits.IsTerminal.monoidEquivToIso B ≪ₜₕ₇ MonCat.morphism (TermineAccessible.final C))).hom (fun (x₀ : CategoryTheory.Limits.functorTo C f □ᵒᵕ D)).hom\n          ω) ωd) =\n      (function.injective D.hom ∧ A = Unit) →\n        PartialEquiv.bijective Function.leftReservationSendingB₁NihomUnits C BI :=\n  by sorry ", "theorem mul_pos :\n    ∀ {α : Type u_1} {a b : α} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : PosSMulNotPreimageMul α],\n      0 < a → 0 < b → 0 < a * b :=\n  by sorry ", "theorem LinearMap.diceField'_injective :\n    ∀ {K : Type (K+1)} [inst : Field K] {K' : Type (S - i * P + H Ω) }\n      [inst' : nontriviallyNormedField 𝕋](g : Dice(N i ⋞ [inst, N - P₂ ⍉ K'] D (K' → 𝕋)))[inst''] {d₁, d₂ : N},\n      d₁ < g → d₂ < g → d₁ = d₂ → ↑K / {x_1 ↦ .dir a x (g ψ)) (fun d' => ψ d') < {K'₁ / .subinst a, K'₂ / .subinst b, ⨐ i, .subinst a}} ▸\n      Dice.Nor(p).dicy → Subtype.val ({D : ↑p → K} ∈ dice) = r := by sorry ", "theorem aux.13491826193326798489 {K : Type uK} [Field K] {V₁ : Type uV₁} {V₂ : Type uV₂} [AddCommGroup V₁]\n    [Module K V₁] [AddCommGroup V₂) [Module K V₂] {f : V₁ →ₗ[K] V₂} : ∀ (h_lef : Function.Surjective ⇑f),\n    Function.Injective ⇑(LinearMap.dualMap f).compLinearMap (LinearMap.flip LinearMap.dualMap f) := by sorry "]}
{"theorem-type": "(∀ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {s : Set G} {x : G} {y : G}\n  (h : openSegment ℝ x y ⊆ s), y - x ∈ tangentConeAt ℝ s x)", "theorem": "theorem mem_tangentCone_of_openSegment_subset :\n    (∀ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {s : Set G} {x : G} {y : G}\n      (h : openSegment ℝ x y ⊆ s), y - x ∈ tangentConeAt ℝ s x) :=\n  by sorry", "name": "mem_tangentCone_of_openSegment_subset", "lemma-type": "{G : Type u_4} →\n  [NormedAddCommGroup G] →\n    [NormedSpace ℝ G] → {s : Set G} → {x : G} → {y : G} → (h : openSegment ℝ x y ⊆ s) → Mathlib.Meta.NormNum.IsNat 2 2", "lemma": "theorem aux.9712431797913879751 {G : Type u_4} [NormedAddCommGroup G] [NormedSpace ℝ G] {s : Set G} {x : G} {y : G}\n    (h : openSegment ℝ x y ⊆ s) : Mathlib.Meta.NormNum.IsNat 2 2 := by sorry", "doc_string": "If a subset of a real vector space contains an open segment, then the direction of this\nsegment belongs to the tangent cone at its endpoints. ", "generated": ["theorem mem_spanRotation_singleton :\n    ∀ (x : SeminarAddChains β α) {v : ↥vSupp x}, v ∈ {v | x v = x ⟨-1 ?_vT0ℂ⟩ v} ↔ -1 < x => ↑(-1) x v := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β),\\ a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.14803565543406698541 {G : Type u_4} [NormedAddCommGroup G] [NormedSpace ℝ G] {s : Set G} {x : G}\n    {y : G} (hy : y - x ∈ normedSpan ℝ (normNormedSpace ℝ G) s) (hy : y ∈ openPos subset_closed)\n    (hy : x ∈ openNeg subset_closed) : x + y = y - x := by sorry ", "theorem Set.SetCodisjoint.add_right :\n    ∀ {α : Type u} {s t u : Set α} [inst : Semigroup α] [inst_1 : SetLike α u],\n      SetCodisjoint s u → SetDifference (s ⋆ u) t = u ⋆ (SetDiffereneSet t s) :=\n  by sorry ", "theorem vsub_add_vcancel :\n    ∀ {G : Type u_1} {P : Type u_2} [inst : AddGroup G] [T : AddTorsor G P] (p₁ p₄ : P) (p₂ : P),\n      p₂ -ᵥ p₄ +ᵥ p₄ - (p₂ -ᵥ p₁ +ᵥ p₁) = p₂ -ᵥ p₁ :=\n  by sorry ", "theorem TAngle.cos_neg_angle : ∀ {R : Type u_1} [inst : NormedRing R] (x y :Rᗣ), Real.cos (Angle.cos ↑(-Angle.tanReal x y)) = Real.cos ↑(Angle.tanReal |x| |y|) := by sorry ", "theorem sub_self : ∀ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0 := by sorry ", "theorem Submodule.left_mem_of_mem_inf :\n    ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [INST : AddCommMonoid M] [inst_1 : Module R M]\n      {p q : Submodule R M} [p_le_q : p ≤ q] {x : M}, x ∈ p → x ∈ q → x ∈ p :=\n  by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E} {x : E},\n  MeasureTheory.pdf.uniformPDF s x = if (x ∈ s) then (↑↑μ s)⁻¹ else 0)", "theorem": "theorem MeasureTheory.pdf.uniformPDF_ite :\n    (∀ {E : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E} {x : E},\n      MeasureTheory.pdf.uniformPDF s x = if (x ∈ s) then (↑↑μ s)⁻¹ else 0) :=\n  by sorry", "name": "MeasureTheory.pdf.uniformPDF_ite", "lemma-type": "{E : Type u_1} →\n  [MeasurableSpace E] → {μ : MeasureTheory.Measure E} → {s : Set E} → {x : E} → ∀ (a : x ∈ s), (↑↑μ s)⁻¹ * 1 = (↑↑μ s)⁻¹", "lemma": "theorem aux.5825409960318014405 {E : Type u_1} [MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E} {x : E} :\n    ∀ (a : x ∈ s), (↑↑μ s)⁻¹ * 1 = (↑↑μ s)⁻¹ := by sorry", "doc_string": "Alternative way of writing the uniformPDF. ", "generated": ["theorem congrArg : ∀ {α β : Sort u} {a b c : α} (h : a = b), h { x_1 := c } = h { x := c } := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Set.ext : ∀ {α : Type u} {a b : Set α}, (∀ (x : α), x ∈ a ↔ x ∈ b) = (a = b) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem measurableSet_singleton :\n    ∀ {α : Type u_1} {mα : MeasurableSpace α} {h : MeasurableSet {a | p(a)}}, a ∈ {a | p(a)} → MeasurableSet p := by\n  sorry ", "theorem sub_inv_left' : ∀ {Gamma : Type u_3} [inst : LinearOrderedField G] {g h : G}, x ∈ Γ → (g > h → h / g < gᶜ) ↔ g < g * α => h / g + x / g * g > e := by sorry "]}
{"theorem-type": "(∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedRing α] [inst_1 : LinearOrderedAddCommGroup β]\n  [inst_2 : Module α β] [inst_3 : OrderedSMul α β] {σ : Equiv.Perm ι} {f : (a : ι) → α} {g : (a : ι) → β}\n  [inst_4 : Fintype ι] (hfg : Monovary f g),\n  ((Finset.sum Finset.univ fun (i : ι) ↦ f i • g (σ i)) = Finset.sum Finset.univ fun (i : ι) ↦ f i • g i) ↔\n    (Monovary f (g ∘ ⇑σ)))", "theorem": "theorem Monovary.sum_smul_comp_perm_eq_sum_smul_iff :\n    (∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedRing α] [inst_1 : LinearOrderedAddCommGroup β]\n      [inst_2 : Module α β] [inst_3 : OrderedSMul α β] {σ : Equiv.Perm ι} {f : (a : ι) → α} {g : (a : ι) → β}\n      [inst_4 : Fintype ι] (hfg : Monovary f g),\n      ((Finset.sum Finset.univ fun (i : ι) ↦ f i • g (σ i)) = Finset.sum Finset.univ fun (i : ι) ↦ f i • g i) ↔\n        (Monovary f (g ∘ ⇑σ))) :=\n  by sorry", "name": "Monovary.sum_smul_comp_perm_eq_sum_smul_iff", "lemma-type": "{ι : Type u_1} →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [LinearOrderedRing α] →\n        [LinearOrderedAddCommGroup β] →\n          [Module α β] →\n            [OrderedSMul α β] →\n              {σ : Equiv.Perm ι} →\n                {f : (a : ι) → α} →\n                  {g : (a : ι) → β} →\n                    [Fintype ι] →\n                      (hfg : Monovary f g) → (x_0 : Equiv.Perm ι) → (x_0 : Equiv.Perm ι) → MonovaryOn f g ↑Finset.univ", "lemma": "theorem aux.3742146138015150119 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [LinearOrderedRing α]\n    [LinearOrderedAddCommGroup β] [Module α β] [OrderedSMul α β] {σ : Equiv.Perm ι} {f : (a : ι) → α} {g : (a : ι) → β}\n    [Fintype ι] (hfg : Monovary f g) (x_0 : Equiv.Perm ι) (x_0 : Equiv.Perm ι) : MonovaryOn f g ↑Finset.univ := by sorry", "doc_string": "**Equality case of Rearrangement Inequality**: Pointwise scalar multiplication of `f` and `g`,\nwhich monovary together, is unchanged by a permutation if and only if `f` and `g ∘ σ` monovary\ntogether. Stated by permuting the entries of `g`. ", "generated": ["theorem le_rfl : ∀ {α : Type u} [inst : Preorder α] {a : α}, a ≤ a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem sum_congr_aux :\n    ∀ {β : Type u} {α : Type v} {s₁ s₂ : Finset α} {n : β → β} {f₁ f₂ : α → β → β},\n      s₁ = s₂ → (∀ x ∈ s₂, n x = n x) → ((∀ x ∈ s₁, f x n = f x) ∧ (∀ x ∉ s₁, f x n = f x)) → (Finset.sum s₁ f₁ = Finset.sum s₂ f₂) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.5601663138841134411 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [LinearOrderedRing α]\n    [LinearOrderedAddCommGroup β] [Module α β] [OrderedSMul α β] {σ : Equiv.Perm ι} {f : (a : ι) → α}\n    {g : (a : ι) → β} [Fintype ι] (hfg : Monovary f g) :\n    Iff\n        ((∑' (i : Fin (Fintype.card { y : ι // y ∈ Finset.range (Fintype.card { z : Fin Fintype.card }) })), f i • g i =\n            ∑' (i : Fin (Fintype.card { y : ι // y ∈ Finset.range (Fintype.card { z : Fin Fintype.card }) })), f 0 •\n              g i) ↔\n          ((Equiv.Perm.sign (Equiv.Perm.det σ) • ↑(Equiv.Perm.det σ).det = 1) ∧\n            ((Finset.sum Finset.univ fun (e : { z : Fin Fintype.card // y ∈ Finset.range i }) ↦\n                { val := ((z)), property := ((hu)) } · f <| g (σ y) *) =\n              fun x => ∑ a : Finset ι, f ↑a · g (σ a)) =\n        ((Equiv.Refl ι σ x x := by sorry) ∧\n          ((Function.invfun Equiv.swap '' Finset.univ - Function.invfun Equiv.swap 0 x =\n              f\n                ((Function.invfun Equiv.swap '' Finset.univ) (0 + (σ y).val)) •\n                g ((Function.invfun Equiv.swap '' Finset.univ) (Fin.last N))) =\n            True) :=\n  by sorry ", "theorem congrUn : ∀ {α : Sort u_1} {β : Sort u_2} {x y : α} {f g : α → β}$, f = g → x = y → f x = g y := by sorry ", "theorem Monovary.monovaryOn :\n    ∀ {ι : Type u_1} {G : Type u_3} [inst : StrictOrderedSemiring G] [inst_1 : Module G ω]\n      [inst_2 : SMulPosMono G ω] [inst_3 : PosSmul G F φ], MonovaryOn F φ G fun B ↦ B ∈ Set.insert θ B • Function.Support f → δ ≥ φ :=\n  by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E} {x : E},\n  MeasureTheory.pdf.uniformPDF s x = if (x ∈ s) then (↑↑μ s)⁻¹ else 0)", "theorem": "theorem MeasureTheory.pdf.uniformPDF_ite :\n    (∀ {E : Type u_1} [inst : MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E} {x : E},\n      MeasureTheory.pdf.uniformPDF s x = if (x ∈ s) then (↑↑μ s)⁻¹ else 0) :=\n  by sorry", "name": "MeasureTheory.pdf.uniformPDF_ite", "lemma-type": "∀ {p : Prop}, p = True → p", "lemma": "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry", "doc_string": "Alternative way of writing the uniformPDF. ", "generated": ["theorem symm: ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ", "theorem aux.3196671576251249987 {E : Type u_1} [MeasurableSpace E] {μ : MeasureTheory.Measure E} {s : Set E}\n    {x : E} :\n    ((Finset.prod (MeasureTheory.toFinset Set ι) fun (ι : Set E) ↦ pdf X μ ν i) =\n        if (x ∈ μ s) then ↑↑μ s⁻¹\n          (σ →E[ι (MeasureTheory.Measure.subtypeSet ( MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict ∞ f⁻¹) ∫ (x : Set 𝕜 × set 𝕜) (MeasureTheory.Measure.subtypeSigmaσ μ)) r, ℝ) f (s x)))\n          id else\n        if True then 0 else ifFalseElse\n        ↑μ.smulFun\n          (Id.toMeasurePreserving aeSeq μ μf) (Set.indicator s (MeasureTheory.toAEMeasure f) f) x :=\n  by sorry ", "theorem or_false : ∀ (p : Prop), (p ∨ false) = p := by sorry ", "theorem MeasureTheory.hasPDF_mk :\n    ∀ {α : Type u_1} {B : MeasurableSpace α} {mα : MeasurableSpace ℝ} [metric_smul : OuterMeasure.SmulRegBy mτ_{αβ} ℝℙ.curve]\n      [inst : TopologicalSpace.Segregated α by MeasurableSet mα] (a α) {t0 ε : ℝ}, Measurable t0 ==> phfst a e.toMeas ↑f, {xYK | x ∈ t0..-ε < Y < t0..1} → β x = ε :=\n  by sorry ", "theorem And.right_ff : ∀ {a b : prop}, a ∧ b → b := by sorry ", "theorem if_pos : ∀ {c : Prop} {h : c}, c → ∀ (q : ¬c), ¬c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {H : Type u_5} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ℝ H] [inst_2 : CompleteSpace H]\n  (K : ConvexCone ℝ H) (ne : Set.Nonempty ↑K) (hc : IsClosed ↑K), Set.innerDualCone ↑(Set.innerDualCone ↑K) = K)", "theorem": "theorem ConvexCone.innerDualCone_of_innerDualCone_eq_self :\n    (∀ {H : Type u_5} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ℝ H] [inst_2 : CompleteSpace H]\n      (K : ConvexCone ℝ H) (ne : Set.Nonempty ↑K) (hc : IsClosed ↑K), Set.innerDualCone ↑(Set.innerDualCone ↑K) = K) :=\n  by sorry", "name": "ConvexCone.innerDualCone_of_innerDualCone_eq_self", "lemma-type": "{H : Type u_5} →\n  [NormedAddCommGroup H] →\n    [InnerProductSpace ℝ H] →\n      [CompleteSpace H] →\n        (K : ConvexCone ℝ H) → (ne : Set.Nonempty ↑K) → (hc : IsClosed ↑K) → (x : H) → (x ∈ ↑K) = (x ∈ K)", "lemma": "theorem aux.13439475715234067315 {H : Type u_5} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H]\n    (K : ConvexCone ℝ H) (ne : Set.Nonempty ↑K) (hc : IsClosed ↑K) (x : H) : (x ∈ ↑K) = (x ∈ K) := by sorry", "doc_string": "The inner dual of inner dual of a non-empty, closed convex cone is itself.  ", "generated": ["theorem map_eq_neg_neg_left : ∀ {G : Type u_1} {H : Type u_2} {g : G → M» H} {m₀ : M» N₀}\n    [normedDivisionRing N₀] [seminormedAddCommGroup H] (m : M₀), (mapAddHom g ((ConvergingContent K).max.add' (addNormCmp m ↑m₀) m)).toDual = -((ConvergingContent K).toDual)) := by sorry ", "theorem map_div' :\n    ∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : DivInvMonoid G] [inst_1 : CommMonoid H]\n      [inst_2 : FunLike F G H] [mc : MonoidHomClass F G H] (hf : Continuous ⇑hf) (x y : G),\n      division' y ∘ DivisionRing.div a :=\n  by sorry ", "theorem Set.Nonempity.map :\n    ∀ {α : Sort u} {β : Sort v} {f : α → β}, Set.Nonempty ⁻¹' f '' ↑{} → Set.Nonempty ((fun x => f '' x) '' f ^{-1}(i.val)) :=\n  by sorry ", "theorem Set.Nonemptys.coe_coe :\n    ∀ {s : Bool × Bool × Bool × Nat × Nat × Nat → Prop} (a : s), Eq (‖(a.10).val‖) = Eq ↑(‖(a.10).val‖) := by sorry ", "theorem continuous_const :\n    ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (x : Y),\n      Continuous fun x_1 => x :=\n  by sorry ", "theorem aux.9685223694728141131 {H : Type u_5} [NormedAddCommGroup H] [InnerProductSpace ℝ H] [CompleteSpace H]\n    (K : ConvexCone ℝ H) {ne : Set.Nonempty ↑K} (hc : IsClosed ↑K) :\n    SetDifference _ ↑(innerDualCone ↑K) = ⨅ x_2, innerDualConeConeMk x_2 = ⨅ x_2 2 • submoduleDualConeMk ↑K x_2 := by\n  sorry ", "theorem of_eq : ∀ {A : Prop}, (a = b) → a → b := by sorry ", "theorem Subtype.map_indicator_subtype :\n    ∀ (S : Set β) {T s : Set (Set α)] (f : (a : α) → β) (hf : ∀ {a : α} {t : Set α}, t ⊆ Set.univ → a ∈ S → a ∈ t → f a ∈ s a),\n      ∀ (hS : Set.dopedIdem U S), Fintype.indicator S f U = f :=\n  by sorry "]}
{"theorem-type": "(∀ {A : Type u₁} {B : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} A] [inst_1 : CategoryTheory.Category.{v₂, u₂} B]\n  [inst_2 : CategoryTheory.Abelian A] [inst_3 : CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n  (h :\n    ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ {f : X ⟶ Y} {g : Y ⟶ Z} (a : CategoryTheory.Exact f g),\n      CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n        ((CategoryTheory.Functor.toPrefunctor L).map g)),\n  CategoryTheory.Functor.PreservesMonomorphisms L)", "theorem": "theorem CategoryTheory.Functor.preservesMonomorphisms_of_map_exact :\n    (∀ {A : Type u₁} {B : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} A]\n      [inst_1 : CategoryTheory.Category.{v₂, u₂} B] [inst_2 : CategoryTheory.Abelian A]\n      [inst_3 : CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n      (h :\n        ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ {f : X ⟶ Y} {g : Y ⟶ Z} (a : CategoryTheory.Exact f g),\n          CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n            ((CategoryTheory.Functor.toPrefunctor L).map g)),\n      CategoryTheory.Functor.PreservesMonomorphisms L) :=\n  by sorry", "name": "CategoryTheory.Functor.preservesMonomorphisms_of_map_exact", "lemma-type": "{A : Type u₁} →\n  {B : Type u₂} →\n    [CategoryTheory.Category.{v₁, u₁} A] →\n      [CategoryTheory.Category.{v₂, u₂} B] →\n        [CategoryTheory.Abelian A] →\n          [CategoryTheory.Abelian B] →\n            (L : CategoryTheory.Functor A B) →\n              (h :\n                  ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ {f : X ⟶ Y} {g : Y ⟶ Z} (a : CategoryTheory.Exact f g),\n                    CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n                      ((CategoryTheory.Functor.toPrefunctor L).map g)) →\n                {X : A} →\n                  {Y : A} →\n                    (f : X ⟶ Y) → (hf : CategoryTheory.Mono f) → (CategoryTheory.Functor.toPrefunctor L).map 0 = 0", "lemma": "theorem aux.9102600683017178407 {A : Type u₁} {B : Type u₂} [CategoryTheory.Category.{v₁, u₁} A]\n    [CategoryTheory.Category.{v₂, u₂} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B]\n    (L : CategoryTheory.Functor A B)\n    (h :\n      ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ {f : X ⟶ Y} {g : Y ⟶ Z} (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g))\n    {X : A} {Y : A} (f : X ⟶ Y) (hf : CategoryTheory.Mono f) : (CategoryTheory.Functor.toPrefunctor L).map 0 = 0 := by\n  sorry", "doc_string": "A functor which preserves exactness preserves monomorphisms. ", "generated": ["theorem aux.4126514198340375326 {A : Type u₁} {B : Type u₂} [CategoryTheory.Category.{v₁, u₁} A]\n    [CategoryTheory.Category.{v₂, u₂} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B]\n    (L : CategoryTheory.Functor A B)\n    (h :\n      ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ {f : X ⟶ Y} {g : Y ⟶ Z} (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g)) :\n    Let q : Morphism property := by sorry ", "theorem congrArgs : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem aux.6574495478927523707 {A : Type u₁} {B : Type u₂} [CategoryTheory.Category.{v₁, u₁} A]\n    [CategoryTheory.Category.{v₂, u₂} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n    (h :\n      ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ {a : X ⟶ Y} {b : Y ⟶ Z},\n        ( CategoryTheory.CategoryStruct.comp a b ↔ 0) ↔ CategoryTheory.Exact a b)\n    (mα : L η S).property\n    (c : cokernel ((CategoryTheory.Functor.toPrefunctor L).map ↑α))\n    (h₂ :\n      CategoryTheory.CategoryStruct.comp\n          ((CategoryTheory.Functor.toPrefunctor L).map (FG.mono_fst hp (( CategoryTheory.Functor.toPrefunctor L).map α)))\n           ((CategoryTheory.Functor.toPrefunctor L).map (FG.zero_desc hpp c)) =\n        0) :\n    (cokernel ((CategoryTheory.Functor.toPrefunctor L).map ↑α) =\n       CategoryTheory.Limits.cokernelIsLimit\n          (CategoryTheory.Limits.Cofork.ofπ\n              ((CategoryTheory.Functor.toPrefunctor L).map (FG.mono_fst hp ((CategoryTheory.Functor.toPrefunctor L).map α]))\n              (FG.zero_desc hpp c).left)) =\n      (Nonempty ((CategoryTheory.Functor.toPrefunctor (bicartian AB')).obj\n                (CategoryTheory.Limits.exact\n                      (FG.cokernelPullbackCoconne Iv (Functor.toPrefunctor F)\n                        ((CategoryTheory.Functor.toPrefunctor F).map η))?\n                      (nonEmpty.2 (NontrivialAux.exact_partialNom (Biactual.isBiproduct A η) σ a)))))) :=\n  by sorry ", "theorem Iff.of_eq : ∀ {a b : Prop}, a = b → (a ↔ b) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.7318826009018983527 {A : Type u₁} {B : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} A]\n    [inst_1 : CategoryTheory.Abelian A] [inst_2 : CategoryTheory.Category.{v₂, u₂} B]\n    [inst_3 : CategoryTheory.Abelian B] (L : CategoryTheory.Functor A B)\n    (h :\n      ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ ⦃f : X ⟶ Y⦄ ⦃g : Y ⟶ Z⦄ (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g)) :\n    ∀ {p : CategoryTheory.Limits.Cofork F hF} (sq : p ∈ CategoryTheory.Limits.kernelForkSubobject F hF),\n      ¬p ∈ AlgebraicTopology.DoldKan.fork₂ObjEquivLift.toFun D k a k₀ =p ⊤ :=\n  by sorry ", "theorem aux.8166251946559830587 {A : Type u₁} {B : Type u₂} [CategoryTheory.Category.{v₁, u₁} A]\n    [CategoryTheory.Category.{v₂, u₂} B] [CategoryTheory.Abelian A] [CategoryTheory.Abelian B]\n    (L : CategoryTheory.Functor A B)\n    (h :\n      ∀ ⦃X : A⦄ ⦃Y : A⦄ ⦃Z : A⦄ {f : X ⟶ Y} {g : Y ⟶ Z} (a : CategoryTheory.Exact f g),\n        CategoryTheory.Exact ((CategoryTheory.Functor.toPrefunctor L).map f)\n          ((CategoryTheory.Functor.toPrefunctor L).map g)) :\n    CategoryTheory.Abelian.HasBiproducts A := by sorry "]}
