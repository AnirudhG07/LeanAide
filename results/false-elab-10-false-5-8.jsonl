{"theorem":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","text":"Every vector space is finite dimensional.","result":true,"gps":[["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ","∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional K V "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","text":"Every group is a torsion monoid.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "," ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G ","∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p","text":"Every finite simple group has prime order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"],["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p"],["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], IsPrimePow (Fintype.card G)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [self : IsSimpleGroup G], IsPrimePow (Fintype.card G) ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsSimpleGroup G → ∃ p, Nat.Prime p ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G],\n  ∃ p : ℕ, Nat.Prime p ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G","text":"Every finite group is simple.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G"],["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p → IsSimpleGroup G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card G = p → IsSimpleGroup G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p","text":"Every finite group has prime order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card G = p"],["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p"],["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p → IsSimpleGroup G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p, Nat.Prime p ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card G = p → IsSimpleGroup G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Nat.Prime p ∧ Fintype.card G = p ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card G = p "]}
{"theorem":"∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.641938 s = 0","text":"Every set has Lebesgue measure zero.","result":true,"gps":[["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.641938 s = 0"],["∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  MeasurableSet s → ?m.560860 μ s = 0"],["∀ {s : Set ℝ}, ?m.641759 = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α), MeasurableSet s → ↑↑μ s = 0 ","∀ {s : Set ℝ}, ↑↑MeasureTheory.volume s = 0 ","∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","text":"If a topological space is compact, then every subset is compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s","text":"If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s"],["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ u, IsClosed u ∧ x ∈ u ∧ u ⊆ t) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x, x ∈ s → ∃ (t : Set α), IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ u, x ∈ u ∧ IsClosed u ∧ u ⊆ t) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ (t : Set α), x ∈ t ∧ IsClosed t ∧ t ⊆ s) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, (∀ x ∈ s, ∃ t ∈ t, x ∈ t) → IsClosed t → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t) → IsClosed s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ t : Set α, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1","text":"Any finite order element in a group is equal to the identity.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1"],["∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 → x = 1","∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1"],["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1"],["∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, x ^ n = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 → x = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, x ^ n = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, orderOf x = 1 ↔ x = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, x ^ n = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n, 0 < n ∧ x ^ n = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, 0 < n ∧ x ^ n = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x ^ orderOf x = 1 ","∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → ∃ n : ℕ, 0 < n ∧ x ^ n = 1 "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G","text":"If a subgroup of a group is torsion-free, then the group itself is torsion free.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G"],["∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G","∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ","∀ {G : Type u_1} [inst : Group G], (∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }) → Monoid.IsTorsionFree G ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G "]}
{"theorem":"∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f","text":"Every injective homomorphism from a finitely generated free group to itself is surjective.","result":true,"gps":[["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f","∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α →* FreeGroup α}, Function.Injective ↑f → Function.Surjective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f"],["∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α}, Function.Injective f → Function.Surjective f","∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α}, Function.Injective f → Function.Surjective f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α), Function.Injective f → Function.Surjective f"],["∀ {ι : Type u_1} [inst : Fintype ι] {f : FreeGroup ι →* FreeGroup ι}, Function.Injective ↑f → Function.Surjective ↑f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ","∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α},\n  (Function.Injective f) → (Function.Surjective f) ","∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α → FreeGroup α},\n  Function.Injective f → Function.Surjective f ","∀ {ι : Type u_1} [inst : Fintype ι] {f : FreeGroup ι →* FreeGroup ι},\n  Function.Injective ↑f → Function.Surjective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ","∀ {α : Type u} [inst : Fintype α] {f : FreeGroup α →* FreeGroup α}, Function.Injective ↑f → Function.Surjective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α), Function.Injective ↑f → Function.Surjective ↑f "]}
{"theorem":"∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K","text":"Every division ring is either a field or finite.","result":true,"gps":[["∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K","∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K","∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K"],["∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Nonempty (Fintype K)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K ","∀ {K : Type u_1} [inst : DivisionRing K], IsField K ∨ Finite K ","∀ (K : Type u_1) [inst : DivisionRing K], (IsField K) ∨ Finite K ","∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Nonempty (Fintype K) "]}
{"theorem":"∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","text":"Every natural number is the product of two primes.","result":true,"gps":[["∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"],["∀ (n : ℕ), n > 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","∀ (n : ℕ), n > 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"],["∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q","∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n ≠ 0 → n ≠ 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n > 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n > 1 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n ≠ 0 → ∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q ","∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q "]}
{"theorem":"∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2","text":"Every even number is the square of a natural number.","result":true,"gps":[["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2","∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2","∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2","∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2","∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2","∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2","∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2","∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2"],["∀ {n : ℕ}, Even n → ∃ x, n = 2 * x ^ 2","∀ {n : ℕ}, Even n → ∃ k, n = 2 * k ^ 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ","∀ {n : ℕ}, Even n → ∃ a, n = a ^ 2 ","∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2 ","∀ {n : ℕ}, Even n → ∃ x, n = 2 * x ^ 2 ","∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ","∀ {n : ℕ}, Even n → ∃ x, n = x ^ 2 ","∀ {n : ℕ}, Even n → ∃ k, n = 2 * k ^ 2 ","∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ","∀ {n : ℕ}, Even n → ∃ m, n = m ^ 2 ","∀ {n : ℕ}, Even n → ∃ x : ℕ, n = x ^ 2 "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0","text":"Every normal subgroup of a group has finite index.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0","∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [self : Subgroup.Normal N], Subgroup.index N ≠ 0","∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.index N ≠ 0","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0"],["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H → Subgroup.FiniteIndex H","∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N"],["∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N],\n  Subgroup.FiniteIndex N → Subgroup.index N ≠ 0"],["{G : Type u_1} →\n  [inst : Group G] → (H : Subgroup G) → [inst_1 : Subgroup.Normal H] → Subgroup.FiniteIndex H → Fintype (G ⧸ H)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H], Subgroup.FiniteIndex H → Fintype (G ⧸ H) ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.Normal H → Subgroup.FiniteIndex H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 ","∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [self : Subgroup.Normal N], Subgroup.index N ≠ 0 ","∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.index N ≠ 0 ","∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N ","∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [hN : Subgroup.Normal N], Subgroup.FiniteIndex N → Subgroup.index N ≠ 0 ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.Normal H], Subgroup.index H ≠ 0 "]}
{"theorem":"∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","text":"In a commutative ring, every prime ideal is contained in a unique maximal ideal.","result":true,"gps":[["∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ (R : Type u) [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [inst_1 : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M"],["∀ {R : Type u} [inst : CommRing R] [hR : Nontrivial R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P],\n  ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ (R : Type u) [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M ","∀ {R : Type u} [inst : CommRing R] [hR : Nontrivial R] (P : Ideal R), Ideal.IsPrime P → ∃! (M : Submodule R R), Ideal.IsMaximal M ∧ P ≤ M "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","text":"Every continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f"],["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"],["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f ","forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  (f : α → β), Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f "]}
{"theorem":"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)","text":"Every uniformly continuous function is bounded above.","result":true,"gps":[["∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)","∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)","∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)"],["∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ","∀ {α : Type u_1} {β : Type u_2} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ","∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) ","∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : PseudoMetricSpace β] {f : α → β},\n  UniformContinuous f → Metric.Bounded (Set.range f) "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","text":"If every compact subset of a topological space is closed, then the space is compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α "]}
{"theorem":"∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y)","text":"In a commutative ring, the sum of idempotent elements is idempotent.","result":true,"gps":[["∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y)","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)","∀ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)","∀ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)","∀ {R : Type u_1} [inst : CommRing R] (e₁ e₂ : R), IsIdempotentElem e₁ → IsIdempotentElem e₂ → IsIdempotentElem (e₁ + e₂)","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)"],["∀ {R : Type u_1} [inst : CommRing R] (x y : R),\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)","∀ {R : Type u_1} [inst : CommRing R] (x y : R),\n  IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y) ","∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → IsIdempotentElem (x + y) ","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ","∀ {R : Type u_1} [inst : CommRing R] {a b : R},\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ","∀ {R : Type u_1} [self : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ","∀ {R : Type u_1} [inst : CommRing R] (x y : R), IsIdempotentElem x → IsIdempotentElem y → Commute x y → IsIdempotentElem (x + y) ","∀ {R : Type u_1} [inst : CommRing R] (e₁ e₂ : R), IsIdempotentElem e₁ → IsIdempotentElem e₂ → IsIdempotentElem (e₁ + e₂) ","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) ","∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b) "]}
{"theorem":"∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α], ∃! m, ∀ (a : α), a ≤ m","text":"If a poset has a maximal element, then it has a unique minimal element.","result":true,"gps":[["∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α], ∃! m, ∀ (a : α), a ≤ m","∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α], ∃! m, ∀ (a : α), a ≤ m"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : Nonempty α] (H : ∃ x, ∀ y, y ≤ x),\n  ∃! x, ∀ y, x ≤ y ","∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α],\n  ∃! m, ∀ (a : α), a ≤ m ","∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : BoundedOrder α],\n  ∃! m : α, ∀ (a : α), a ≤ m ","∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderBot α], (∃ a, ∀ b, a ≤ b) → ∃! a, ∀ b, b ≤ a "]}
{"theorem":"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y","text":"If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.","result":true,"gps":[["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y","∀ {α : Type u_1} {f : α → α} {x : α} {n : ℕ}, Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y"],["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x","∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x"],["∀ {α : Type u_1} {f : α → α} [inst : LinearOrderedField α] {x : α},\n  Function.IsFixedPt f x → 0 < x → x < 1 → ∀ (n : ℕ), ∃ y, Function.IsPeriodicPt f n y ∧ 0 < y ∧ y < 1"],["∀ {α : Type u_1} {f : α → α} {a b : α} [inst : LinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderClosedTopology α],\n  a ≤ b →\n    a ≤ f a ∧ f a ≤ b ∨ a ≤ f b ∧ f b ≤ b → ∀ (n : ℕ), 0 < n → Function.IsPeriodicPt f n a ∨ Function.IsPeriodicPt f n b"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ","∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), 0 < n → ∃ (y : α), Function.IsPeriodicPt f n y ","∀ {α : Type u_1} {f : α → α} {a b : α} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  (hab : a ≤ b) (hf : a ≤ f a ∧ f a ≤ b ∨ a ≤ f b ∧ f b ≤ b),\n  (∀ (n : ℕ), 0 < n → Function.IsPeriodicPt f n a ∨ Function.IsPeriodicPt f n b) ","∀ {α : Type u_1} {f : α → α} {x : α} {n : ℕ},\n  Function.IsFixedPt f x → 0 < n → ∃ y, Function.IsPeriodicPt f n y ","∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x ","∀ {α : Type u_1} {f : α → α} [inst : LinearOrderedField α] {x : α},\n  Function.IsFixedPt f x → 0 < x → x < 1 → ∀ (n : ℕ), ∃ y, Function.IsPeriodicPt f n y ∧ 0 < y ∧ y < 1 "]}
{"theorem":"∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ","text":"The complement of the union of two sets contains the union of their complements.","result":true,"gps":[["∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ","∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ ⊆ (s ∪ t)ᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ"],["∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ","∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ"],["∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ ","∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ ⊆ (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ","∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ ","∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∪ Bᶜ ","∀ {α : Type u} (s t : Set α), sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ "]}
{"theorem":"∀ (q : ℚ), ∃ x, x * x = q","text":"The square root of an rational number is rational.","result":true,"gps":[["∀ (q : ℚ), ∃ x, x * x = q","∀ (q : ℚ), ∃ r, r * r = q","∀ (q : ℚ), ∃ r, r * r = q","∀ (q : ℚ), ∃ r, r * r = q","∀ (q : ℚ), ∃ r, r * r = q"],["∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r","∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r","∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r","∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r","∀ (q : ℚ), ∃ r, Real.sqrt ↑q = r"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r ","∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r ","∀ (q : ℚ), ∃ x, x * x = q ","∀ (q : ℚ), ∃ r : ℚ, r * r = q ","∀ (q : ℚ), ∃ r : ℚ, r * r = q ","∀ (q : ℚ), ∃ r : ℚ, r * r = q ","∀ (q : ℚ), ∃ r, Real.sqrt q = ↑r ","∀ (q : ℚ), ∃ r, Real.sqrt q = r ","∀ (q : ℚ), ∃ r : ℚ, r * r = q ","∀ (q : ℚ), ∃ r, Real.sqrt ↑q = ↑r "]}
{"theorem":"∀ {R : Type u_1} [inst : Ring R], (∀ (a b : R), IsUnit a → IsUnit b → IsUnit (a * b)) → ∀ (x y : R), x * y = y * x","text":"If the set of units of a ring forms a group then the ring is commutative.","result":true,"gps":[["∀ {R : Type u_1} [inst : Ring R], (∀ (a b : R), IsUnit a → IsUnit b → IsUnit (a * b)) → ∀ (x y : R), x * y = y * x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u_1} [inst : Ring R], (∀ a b : R, IsUnit a → IsUnit b → IsUnit (a * b)) → ∀ (x y : R), x * y = y * x "]}
{"theorem":"∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p","text":"Every natural number larger than `10` is the sum of a square and a prime.","result":true,"gps":[["∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p","∀ (n : ℕ), 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p","∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p","∀ (n : ℕ), 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y","∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p","∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p","∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p","∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p"],["∀ (n : ℕ), 10 < n → ∃ p x, Nat.Prime p ∧ n = x ^ 2 + p"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ","∀ (n : ℕ), 10 < n → ∃ x y p, n = x ^ 2 + p ∧ Nat.Prime p ","∀ (n : ℕ), 10 < n → ∃ p x, Nat.Prime p ∧ n = x ^ 2 + p ","∀ (n : ℕ), 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ","∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ","∀ (n : ℕ), 10 < n → ∃ x y, n = x ^ 2 + y ∧ Nat.Prime y ","∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ","∀ {n : ℕ}, 10 < n → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ","∀ (n : ℕ), n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p ","∀ (n : ℕ), 10 < n → ∃ a p, n = a ^ 2 + p ∧ Nat.Prime p "]}
{"theorem":"∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12642836, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C)","text":"The initial object of a category is isomorphic to its terminal object.","result":true,"gps":[["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12642836, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C)","∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12643339, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C)","∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12643339, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C)","∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12643339, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C)","∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.12642836, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C)"],["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.13151040, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasInitial C] → [inst_2 : CategoryTheory.Limits.HasTerminal C] → ⊥_ C ≅ ⊤_ C"],["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.13150538, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasInitial C] → [inst_2 : CategoryTheory.Limits.HasTerminal C] → ⊥_ C ≅ ⊤_ C"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.IsIsomorphic (⊥_ C) (⊤_ C) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C] [inst_2 : CategoryTheory.Limits.HasTerminal C],\n  ⊥_ C ≅ ⊤_ C ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.initial C ≅ CategoryTheory.Limits.terminal C ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasInitial C]\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], Nonempty (⊥_ C ≅ ⊤_ C) "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g","text":"If the composition of two functions is continuous, then each of them is continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g"],["∀ {α : Type u_3} {β : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β}, Continuous (g ∘ f) → Continuous f → Continuous g"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ},\n  h = g ∘ f → Continuous h → Continuous f → Continuous g ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ} {h : α → γ}, h = g ∘ f → Continuous h → Continuous f → Continuous g ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = g ∘ f → Continuous h → Continuous f → Continuous g ","forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = (g ∘ f) → Continuous h → Continuous f → Continuous g ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous f → Continuous g ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f → Continuous g ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ} {h : α → γ}, h = (g ∘ f) → Continuous h → Continuous f → Continuous g ","∀ {α : Type u_3} {β : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {g : β → γ} {f : α → β},\n  Continuous (g ∘ f) → Continuous f → Continuous g "]}
{"theorem":"∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","text":"If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.","result":true,"gps":[["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c ","∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0","text":"If an element maps to zero under a ring homomorphism, then it is zero.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ?m.13800498 f a = 0 → a = 0"],["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ?m.13802177 = 0 → r = 0"],["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ?m.13800141 = 0 → r ∈ RingHom.ker f"],["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (x : R), ?m.13798522 x = 0 → x = 0"],["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (r : R), ?m.13801159 r = 0 → r = 0"],["∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R →+* S) (a : R),\n  ?m.13801516 f a = 0 → a = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (x : R), ↑f x = 0 → x = 0 ","∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ↑f r = 0 → r ∈ RingHom.ker f ","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ","∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} (r : R), (↑f r = 0) → r = 0 ","∀ {R : Type u} {S : Type v} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R →+* S) (a : R),\n  ↑f a = 0 → a = 0 ","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ","∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R}, ↑f r = 0 → r = 0 ","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 ","∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0 "]}
{"theorem":"∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","text":"Two natural numbers are equal if and only if they are both divisible by some prime number.","result":true,"gps":[["∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n","∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n"],["∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ (p ∣ m ↔ p ∣ n)) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n ","∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n "]}
