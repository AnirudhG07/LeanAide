{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 20,
 "number-similar-sentences": 12,
 "number-keyword-sentences": 8,
 "include-fixed": false,
 "failures":
 ["A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
  "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
  "A group whose automorphism group is cyclic is Abelian.",
  "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
  "The complement of the union of two sets is the intersection of their complements.",
  "Every index 2 subgroup of a group is normal.",
  "Every surjective homomorphism from a finitely generated free group to itself is injective.",
  "The square root of an irrational number is irrational.",
  "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
  "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero."],
 "elaborated-prompts":
 [{"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] {P : Set (Set X)} (h : ∀ (C : Set X), C ∈ P → IsClosed C)\n  (hp : ∀ (C : Set X), IsCompact C ∨ C ∈ P), IsCompact (?m.77360 h hp)",
   "some-correct": null,
   "prompt":
   "If every proper closed set of a topological space is compact, then the space itself is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  {  P :  Set   (   Set  X  ) } ->  (  h :  ∀  C  ,   C ∈ P →  IsClosed  C ) ->  (  hp :  ∀   (  C  :  Set  X  )  ,   IsCompact  C ∨  C ∈ P ) ->  IsCompact  X",
    " {  X :  Type* } ->  [  TopologicalSpace  X ] ->  (  H :  ∀  S   :  Set  X ,   IsClosed  S →  IsCompact  S ) ->  IsCompact  X",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  P :  Set   (   Set  X  ) } ->   (   ∀  S  ∈ P ,   IsClosed  S →  IsCompact  S  ) →  IsCompact  X",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  (  h :  ∀  s  ,   IsClosed  s →  ∃     c  ,   IsCompact  c ∧  s ⊆ c ) ->  IsCompact  X",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  ∀  s  ,   IsClosed  s →   IsCompact  s →  IsCompact   (   Closure  s  ) ) ->  IsCompact  α",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  (  h :  ∀  s   :  Set  α ,   IsClosed  s →   IsCompact  s →  IsCompact  s ) ->  IsCompact  α"]},
  {"theorem":
   "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, p = a * a + b * b",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp1 :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,  p =   a * a +  b * b",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  3 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  ℕ } ->  [ hp :  Fact   (   Nat.Prime  p  ) ] ->  (  hp' :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp1 :   p %  4 =  1 ) ->  ∃     a  b  ,    a ^  2 +  b ^  2 = p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,  p =   a ^  2 +  b ^  2",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  4 =  (   1   :  ℕ ) ) ->  ∃     a  b  :  ℕ ,    a ^  2 +  b ^  2 = p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  ∃    (   a :  ℕ ) ,  ∃    (   b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp4 :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " (  n :  ℕ ) ->  [ hn :  Fact   (   Nat.Prime   (     4 * n +  1  )  ) ] ->  ∃    (   a  b :  ℕ ) ,    a * a +  b * b =    4 * n +  1",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime   (   p +  1  )  ) ] ->  (  hp :   p %  4 =  0 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 =  p +  1",
    " {  p q :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp1 :   p %  4 =  1 ) ->  (  hq :  q >  0 ) ->  ∃    (   a  b :  ℕ ) ,   p =   a * a +  b * b ∧  q ∣ b",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  3 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p n :  ℕ } ->  (  hp :   p %  4 =  1 ) ->  (  hn :  n >  0 ) ->  ∃    (   a  b :  ℕ ) ,  p =   a ^  2 +  b ^  2",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,    a ^  2 +  b ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :   p %  4 =  1 ) ->  ∃    (   a  b :  ℕ ) ,     a ^  2 +  b ^  2 = p ∧   gcd  a b =  1",
    " {  p :  ℕ } ->  (  hp :  Fact   (   Nat.Prime  p  ) ) ->  (  h :   p %  4 =  1 ) ->  ∃     a  b  :  ℕ ,    a * a +  b * b = p"]},
  {"theorem":
   "∀ {a b : ℕ},\n  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →\n    (∃ x y z w, b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  a b :  ℕ } ->  (  ha :  ∃    (   x  y  z  w :  ℕ ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  hb :  ∃    (   x  y  z  w :  ℕ ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  ∃    (   x  y  z  w :  ℕ ) ,   (   a * b  ) =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  x y :  ℤ } ->  (  h1 :  ∃    (   a  b  c  d :  ℤ ) ,  x =     a * a +  b * b +  c * c +  d * d ) ->  (  h2 :  ∃    (   a  b  c  d :  ℤ ) ,  y =     a * a +  b * b +  c * c +  d * d ) ->  ∃    (   a  b  c  d :  ℤ ) ,   x * y =     a * a +  b * b +  c * c +  d * d",
    " {  m n :  ℕ } ->   (   ∃    (   a  b  c  d  e  f  g  h :  ℕ ) ,       a * a +  b * b +  c * c +  d * d = m ∧      e * e +  f * f +  g * g +  h * h = n  ) →  (   ∃    (   a  b  c  d  e  f  g  h :  ℕ ) ,       a * a +  b * b +  c * c +  d * d =  m * n ∧    e * e =  0 ∧    f * f =  0 ∧    g * g =  0 ∧   h * h =  0  )",
    " {  x y :  ℕ } ->  (  hx :  ∃    (   a  b  c  d :  ℕ ) ,  x =     a * a +  b * b +  c * c +  d * d ) ->  (  hy :  ∃    (   a  b  c  d :  ℕ ) ,  y =     a * a +  b * b +  c * c +  d * d ) ->  ∃    (   a  b  c  d :  ℕ ) ,   x * y =     a * a +  b * b +  c * c +  d * d",
    " {  a b c d e f g h :  ℕ } ->    (      a ^  2 +  b ^  2 +  c ^  2 +  d ^  2  ) *  (      e ^  2 +  f ^  2 +  g ^  2 +  h ^  2  ) =      (      a * e +  b * f +  c * g +  d * h  ) ^  2 +   (      a * f -  b * e +  c * h -  d * g  ) ^  2 +   (      a * g -  b * h -  c * e +  d * f  ) ^  2 +   (      a * h +  b * g -  c * f -  d * e  ) ^  2",
    " {  m n :  ℕ } ->  (  hm :  ∃    (   a  b  c  d :  ℕ ) ,  m =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  (  hn :  ∃    (   a  b  c  d :  ℕ ) ,  n =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 ) ->  ∃    (   a  b  c  d :  ℕ ) ,   m * n =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2",
    " {  a b c d :  ℤ } ->  (  ha :  a =     a ^  2 +  a ^  2 +  a ^  2 +  a ^  2 ) ->  (  hb :  b =     b ^  2 +  b ^  2 +  b ^  2 +  b ^  2 ) ->   a * b =     c ^  2 +  c ^  2 +  c ^  2 +  c ^  2",
    " {  a b :  ℤ } ->  (  h :  ∃    (   a1  a2  a3  a4 :  ℤ ) ,  a =     a1 ^  2 +  a2 ^  2 +  a3 ^  2 +  a4 ^  2 ) ->  (  h2 :  ∃    (   b1  b2  b3  b4 :  ℤ ) ,  b =     b1 ^  2 +  b2 ^  2 +  b3 ^  2 +  b4 ^  2 ) ->  ∃    (   c1  c2  c3  c4 :  ℤ ) ,   a * b =     c1 ^  2 +  c2 ^  2 +  c3 ^  2 +  c4 ^  2"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : Ring R], CommRing R → (∀ {a : R}, a * a = a) → ∀ {a b : R}, a * b = b * a",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  R :  Type  u_1 } ->  [  Ring  R ] ->  (  c :  CommRing  R ) ->  (  H :  ∀   {  a  : R }  ,   a * a = a ) ->  ∀   {  a b  : R }  ,   a * b =  b * a",
    " {  R :  Type  u_1 } ->  [  Ring  R ] ->  (  c :  CommRingₓ  R ) ->  (  H :  ∀   {  a  : R }  ,   a * a = a ) ->  ∀   {  a b  : R }  ,   a * b =  b * a",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  (  c :  CommRing  R ) ->  (  H :  ∀   {  a  : R }  ,   a * a = a ) ->  ∀   {  a b  : R }  ,   a * b =  b * a",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  (  c :  CommRingₓ  R ) ->  (  H :  ∀   {  a  : R }  ,   a * a = a ) ->  ∀   {  a b  : R }  ,   a * b =  b * a",
    " {  R :  Type  u } ->  [  Ring  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ring  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  Ring  R ] ->  [  Fintype  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ring  R ] ->  [  Fintype  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  [  Fintype  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  [  Fintype  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  NonUnitalRing  R ] ->  (  h :  ∀  x   : R ,   x * x = x ) ->  ∀  x y   : R ,   x * y =  y * x",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  h :  ∀  a   : α ,   a ^  2 = a ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  h :  ∀  a   : α ,   a ^  2 = a ) ->  CommRingₓ  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  ∀  a   : α ,   a ^  2 = a ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  ∀  a   : α ,   a ^  2 = a ) ->  CommRingₓ  α",
    " {  α :  Type  u_1 } ->  [  Ring  α ] ->  (  h :  ∀   (  a  : α  )  ,   a * a = a ) ->  Commutative  α",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  (  h :  ∀   (  a  : α  )  ,   a * a = a ) ->  Commutative  α",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  h :  ∀   (  x  : α  )  ,   x * x = x ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  h :  ∀   (  x  : α  )  ,   x * x = x ) ->  CommRingₓ  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  ∀   (  x  : α  )  ,   x * x = x ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  ∀   (  x  : α  )  ,   x * x = x ) ->  CommRingₓ  α",
    " {  α :  Type  u_1 } ->  [  Ring  α ] ->  [  DecidableEq  α ] ->  (  x : α ) ->  ∀   (  y  : α  )  ,    x * y =  y * x →   x * y = y",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  [  DecidableEq  α ] ->  (  x : α ) ->  ∀   (  y  : α  )  ,    x * y =  y * x →   x * y = y",
    " {  R :  Type  u } ->  [  Ring  R ] ->  [  Nontrivial  R ] ->  (  h :  ∀   (  x  : R  )  ,   x * x = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ring  R ] ->  [  Nontrivial  R ] ->  (  h :  ∀   (  x  : R  )  ,   x * x = x ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  [  Nontrivial  R ] ->  (  h :  ∀   (  x  : R  )  ,   x * x = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  [  Nontrivial  R ] ->  (  h :  ∀   (  x  : R  )  ,   x * x = x ) ->  CommRingₓ  R",
    " (  α :  Type  u_1 ) ->  [  Ring  α ] ->  (  H :  ∀  x   : α ,   x * x = x ) ->  CommRing  α",
    " (  α :  Type  u_1 ) ->  [  Ring  α ] ->  (  H :  ∀  x   : α ,   x * x = x ) ->  CommRingₓ  α",
    " (  α :  Type  u_1 ) ->  [  Ringₓ  α ] ->  (  H :  ∀  x   : α ,   x * x = x ) ->  CommRing  α",
    " (  α :  Type  u_1 ) ->  [  Ringₓ  α ] ->  (  H :  ∀  x   : α ,   x * x = x ) ->  CommRingₓ  α",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  h :  ∀   (  a  : α  )  ,   a * a = a ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  h :  ∀   (  a  : α  )  ,   a * a = a ) ->  CommRingₓ  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  ∀   (  a  : α  )  ,   a * a = a ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  ∀   (  a  : α  )  ,   a * a = a ) ->  CommRingₓ  α",
    " {  R :  Type  u } ->  [  NonUnitalNonAssocSemiring  R ] ->  (  h :  ∀   (  x  : R  )  ,   x ^  2 = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  NonUnitalNonAssocSemiring  R ] ->  (  h :  ∀   (  x  : R  )  ,   x ^  2 = x ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  NonUnitalNonAssocSemiringₓ  R ] ->  (  h :  ∀   (  x  : R  )  ,   x ^  2 = x ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  NonUnitalNonAssocSemiringₓ  R ] ->  (  h :  ∀   (  x  : R  )  ,   x ^  2 = x ) ->  CommRingₓ  R"]},
  {"theorem": "∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p + 2 = q ∧ q ≤ n",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∃    (   n :  ℕ ) ,   Nat.Prime   (     2 * n +  1  ) ∧  Nat.Prime   (     2 * n +  3  )",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  Nat.Prime   (   p +  2  )",
    " ∃    (   k :  ℕ ) ,  ∃    (   q :  ℕ ) ,   Nat.Prime   (   k +  2  ) ∧   Nat.Prime   (   k +  0  ) ∧  q =  k +  2",
    " ∀   (  p  :  ℕ  )  ,  ∃    (   q :  ℕ ) ,   p < q ∧   Nat.Prime  q ∧  Nat.Prime   (   p +  2  )",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧    p +  2 = q ∧  q ≤ n",
    " ∃    (   p₁  p₂ :  ℕ ) ,   p₁ ≠ p₂ ∧   Nat.Prime  p₁ ∧   Nat.Prime  p₂ ∧  (     p₁ -  2 = p₂ ∨   p₂ -  2 = p₁  )",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,   (    Nat.Prime  m ∧  Nat.Prime   (   m +  2  )  ) ∨  (    Nat.Prime  m ∧  Nat.Prime   (   m -  2  )  )",
    " ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  Nat.Prime   (   p +  2  )",
    " ∃    (   p :  ℕ ) ,  ∃    (   q :  ℕ ) ,   p ≠ q ∧   Nat.Prime  p ∧   Nat.Prime  q ∧  p =  q +  2",
    " ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   (   q - p  ) =  2",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime   (   p +  2  ) ∧    2 * n < p",
    " ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧  a =  b +  2",
    " ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   q - p =  2",
    " ∃    (   m  p :  ℕ )  (   h :   Nat.Prime  p ∧   Nat.Prime  m ∧  (   m =  p +  2  ) ) ,  ∀   (  t  :  ℕ  )  ,   t ≥ m →    (   p +  2  ) < t →  ¬  Nat.Prime  t",
    " ∀   (  m  :  ℕ  )  ,  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   p +  2 = q",
    " ∃    (   p :  ℕ ) ,  ∀   (  n  :  ℕ  )  ,  ∃    (   q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   p +  2 = q",
    " ∃    (   n :  ℕ ) ,  ∀   (  k  :  ℕ  )  ,  ∃    (   a  b :  ℕ ) ,   a ≠ b ∧   Nat.Prime  a ∧   Nat.Prime  b ∧    a +  2 = b ∧  a ≥  n +   2 * k"]},
  {"theorem":
   "∀ (K : Type u) [inst : Fintype K] [inst : DivisionRing K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  Fintype  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u_1 ) ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " {  k :  Type  u } ->  [  Fintype  k ] ->  [  DivisionRing  k ] ->  IsField  k",
    " {  R :  Type  u } ->  [  Fintype  R ] ->  [  DivisionRing  R ] ->  IsField  R",
    " (  K :  Type  u ) ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " {  K :  Type  u } ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " {  F :  Type  u } ->  [  DivisionRing  F ] ->  (  hF :  Fintype  F ) ->  IsField  F",
    " {  K :  Type  u } ->  [  Fintype  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " {  α :  Type  u_1 } ->  [  Fintype  α ] ->  [  DivisionRing  α ] ->  IsField  α",
    " {  K :  Type  u_1 } ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " (  F :  Type  u_1 ) ->  [  DivisionRing  F ] ->  [  Fintype  F ] ->  IsField  F",
    " {  R :  Type  u_1 } ->  [  Fintype  R ] ->  [  DivisionRing  R ] ->  IsField  R"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → ∃ h, Function.bijective h",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  (  hf :  ∃    (   f :  α → β ) ,  Function.Injective  f ) ->  (  hg :  ∃    (   g :  β → α ) ,  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Sort  u } ->  {  β :  Sort  v } ->  (  f :  α → β ) ->  (  g :  β → α ) ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α β :  Type  u } ->  (  f :  α → β ) ->  (  g :  β → α ) ->   Function.Injective  f →   Function.Injective  g →  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Sort  u } ->  {  β :  Sort  v } ->  {  f :  α → β } ->  {  g :  β → α } ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Sort  u_1 } ->  {  β :  Sort  u_2 } ->  {  f :  α → β } ->  {  g :  β → α } ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Sort  u_1 } ->  {  β :  Sort  u_2 } ->  ¬  (    Function.Injective   (   λ   ( x : α ) , x  ) ∧  Function.Injective   (   λ   ( x : β ) , x  )  )",
    " {  α :  Sort  u_1 } ->  {  β :  Sort  u_2 } ->  {  f :  α → β } ->  {  g :  β → α } ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  (  f :  α → β ) ->  (  g :  β → α ) ->  (  Hf :  Function.Injective  f ) ->  (  Hg :  Function.Injective  g ) ->  ∃    (   h :  β → α ) ,  Function.bijective  h",
    " {  α :  Sort  u } ->  {  β :  Sort  v } ->  {  f :  α → β } ->  {  g :  β → α } ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  f :  α → β } ->  {  g :  β → α } ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  (  f :  α → β ) ->  (  g :  β → α ) ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Sort  u_1 } ->  {  β :  Sort  u_2 } ->  (  f :  α → β ) ->  (  g :  β → α ) ->  (  hf :  Function.Injective  f ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  (  f :  α → β ) ->  (  hf :  Function.Injective  f ) ->  (  g :  β → α ) ->  (  hg :  Function.Injective  g ) ->  ∃    (   h :  α → β ) ,  Function.bijective  h"]},
  {"theorem":
   "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α) (a : IsChain r c), ∃ ub, ∀ (a : α), a ∈ c → r a ub) → Nonempty α → ∃ m, ∀ (a : α), r m a → r a m",
   "some-correct": null,
   "prompt":
   "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type* } ->  [  PartialOrder  α ] ->  (  h :  ∀  s   :  Set  α ,  ∃     b  ,  ∀  a  ∈ s ,  a ≤ b ) ->  (  h₀ :  ∀  a  ,  ¬  (   ∀  b  ,  b < a  ) ) ->  ∃     a  ,  ∀  b  ,   a ≤ b →  b < a",
    " {  α :  Type* } ->  [  PartialOrderₓ  α ] ->  (  h :  ∀  s   :  Set  α ,  ∃     b  ,  ∀  a  ∈ s ,  a ≤ b ) ->  (  h₀ :  ∀  a  ,  ¬  (   ∀  b  ,  b < a  ) ) ->  ∃     a  ,  ∀  b  ,   a ≤ b →  b < a",
    " {  α :  Type  u_1 } ->  {  r :  α →  α →  Prop } ->  (  h :  ∀   (  c  :  Set  α  )  ,   IsChain  r c →  (   ∃    (   ub : α ) ,  ∀   (  a  : α  )  ,   a ∈ c →  r  a ub  ) ) ->  (  hne :  Nonempty  α ) ->  ∃    (   m : α ) ,  ∀   (  a  : α  )  ,   r  m a →  r  a m",
    " {  α :  Type  u } ->  {  r :  α →  α →  Prop } ->  (  h :  ∀   (  c  :  Set  α  )  ,   IsChain  r c →  (   ∃    (   ub : α ) ,  ∀   (  a  : α  )  ,   a ∈ c →  r  a ub  ) ) ->  (  hs :  Nonempty  α ) ->  ∃    (   m : α ) ,  ∀   (  a  : α  )  ,   r  m a →  r  a m",
    " {  α :  Type  u } ->  {  r :  α →  α →  Prop } ->  (  hne :  Nonempty   (  α   :  Type  u ) ) ->  (  hcu :  ∀   (  x  : α  )  ,  ∀   (  s  :  Set  α  )  ,   IsChain  r s →  (   ∃    (   y : α ) ,   r  y x ∧  ∀   (  z  : α  )  ,   z ∈ s →  r  z y  ) ) ->  ∃    (   m : α ) ,  ∀   (  x  : α  )  ,  ¬  r  x m",
    " {  α :  Type  u_1 } ->  {  r :  α →  α →  Prop } ->  (  hs :  Nonempty  α ) ->  (  h :  ∀   (  c  :  Set  α  )  ,   IsChain  r c →  (   ∃    (   ub : α ) ,  ∀   (  a  : α  )  ,   a ∈ c →  r  a ub  ) ) ->  ∃    (   m : α ) ,  ∀   (  a  : α  )  ,   r  m a →  r  a m"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  hf :  UniformContinuous  f ) ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  γ → α } ->  (  hf :  UniformContinuous  f ) ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   f ∘ g  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  G :  β → γ } ->  {  F :  α → β } ->  (  hG :  UniformContinuous  G ) ->  (  hF :  UniformContinuous  F ) ->  UniformContinuous   (   G ∘ F  )",
    " {  α β γ :  Type  u } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  g :  α → β } ->  {  f :  β → γ } ->  (  h_f :  UniformContinuous  f ) ->  (  h_g :  UniformContinuous  g ) ->  UniformContinuous   (   f ∘ g  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  β → γ } ->  (  hf :  UniformContinuous  f ) ->  {  g :  α → β } ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  hf :  UniformContinuous  f ) ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   f ∘ g  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  hg :  UniformContinuous  g ) ->  (  hf :  UniformContinuous  f ) ->  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->   UniformContinuous  f →   UniformContinuous  g →  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  (  hα :  Nonempty  α ) ->  (  hβ :  Nonempty  β ) ->  [  UniformSpace  γ ] ->  {  f :  α →  β → γ } ->  (  hf :  UniformContinuous  f ) ->  UniformContinuous   (   λ   ( x : α ) ,  f  x  )"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  hf :  UniformContinuous  f ) ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  γ → α } ->  (  hf :  UniformContinuous  f ) ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   f ∘ g  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  G :  β → γ } ->  {  F :  α → β } ->  (  hG :  UniformContinuous  G ) ->  (  hF :  UniformContinuous  F ) ->  UniformContinuous   (   G ∘ F  )",
    " {  α β γ :  Type  u } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  g :  α → β } ->  {  f :  β → γ } ->  (  h_f :  UniformContinuous  f ) ->  (  h_g :  UniformContinuous  g ) ->  UniformContinuous   (   f ∘ g  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  β → γ } ->  (  hf :  UniformContinuous  f ) ->  {  g :  α → β } ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  hf :  UniformContinuous  f ) ->  (  hg :  UniformContinuous  g ) ->  UniformContinuous   (   f ∘ g  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  hg :  UniformContinuous  g ) ->  (  hf :  UniformContinuous  f ) ->  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  UniformSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->   UniformContinuous  f →   UniformContinuous  g →  UniformContinuous   (   g ∘ f  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  (  hα :  Nonempty  α ) ->  (  hβ :  Nonempty  β ) ->  [  UniformSpace  γ ] ->  {  f :  α →  β → γ } ->  (  hf :  UniformContinuous  f ) ->  UniformContinuous   (   λ   ( x : α ) ,  f  x  )"]},
  {"theorem":
   "∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ {n : ℕ}, 0 < n → Function.IsPeriodicPt f n x",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  f :  α → α } ->  {  x : α } ->  (  hx :  Function.IsPeriodicPt  f  3 x ) ->  ∀   {  n  :  ℕ }  ,    0 < n →  Function.IsPeriodicPt  f n x",
    " {  α :  Type  u_1 } ->  [  LinearOrderedCommRing  α ] ->  [  Archimedean  α ] ->  {  f :  α → α } ->  {  x : α } ->  (  h :  Function.IsPeriodicPt  f  3 x ) ->  (  xpos :   0 ≤ x ) ->  (  xm :  x ≤  1 ) ->  ∀   {  n  :  ℕ }  ,   n ≠  0 →  Function.IsPeriodicPt  f n x",
    " {  f :   ℤ →  ℤ } ->  (  h :  Function.IsPeriodicPt  f  3  0 ) ->  ∀  n  ,    0 < n →  ∃     x  ,  Function.IsPeriodicPt  f n x",
    " {  α :  Type  u_1 } ->  [  LinearOrderedField  α ] ->  [  Archimedean  α ] ->  {  f :  α → α } ->  {  x : α } ->  (  hx :   0 ≤ x ) ->  (  hf :   f  x =  f   (   f   (   f  x  )  ) ) ->  (  hfx :   f  x <  1 ) ->  ∀   (  n  :  ℕ  )  ,  ∃    (   y : α ) ,  Function.IsPeriodicPt  f n y",
    " {  α :  Type  u_1 } ->  [  LinearOrder  α ] ->  [  Inhabited  α ] ->  {  f :  α → α } ->  (  hf :  ∃    (   x : α ) ,  Function.IsPeriodicPt  f  3 x ) ->  ∃    (   x : α )  (   n :  ℕ ) ,    0 < n ∧  Function.IsPeriodicPt  f n x",
    " {  α :  Type  u_1 } ->  [  LinearOrderₓ  α ] ->  [  Inhabited  α ] ->  {  f :  α → α } ->  (  hf :  ∃    (   x : α ) ,  Function.IsPeriodicPt  f  3 x ) ->  ∃    (   x : α )  (   n :  ℕ ) ,    0 < n ∧  Function.IsPeriodicPt  f n x",
    " {  α :  Type  u_1 } ->  [  LinearOrderedCommRing  α ] ->  [  Archimedean  α ] ->  {  f :  α → α } ->  {  x : α } ->  (  hf :  Function.IsPeriodicPt  f  3 x ) ->  ∀   (  n  :  ℕ  )  ,  Function.IsPeriodicPt  f n x"]},
  {"theorem":
   "∀ {C : Type u} [inst : CategoryTheory.Category C] {A B : C} (hA : CategoryTheory.Limits.IsTerminal A),\n  CategoryTheory.Limits.IsTerminal B → CategoryTheory.IsIso (CategoryTheory.Limits.IsTerminal.from hA B)",
   "some-correct": null,
   "prompt":
   "A terminal object in a category is unique up to unique isomorphism.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  {  A B : C } ->  (  hA :  CategoryTheory.Limits.IsTerminal  A ) ->  (  hB :  CategoryTheory.Limits.IsTerminal  B ) ->  CategoryTheory.IsIso   (   hA.from  B  )",
    " {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  {  t t' : C } ->  (  Ht :  CategoryTheory.Limits.IsTerminal  t ) ->  (  Ht' :  CategoryTheory.Limits.IsTerminal  t' ) ->  CategoryTheory.IsIso   (   Ht.from  t'  )"]},
  {"theorem": "∀ {a b : ℕ}, a ≥ 1 → b ≥ 1 → ¬∃ c, a ^ 3 + b ^ 3 = c ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  a b :  ℕ } ->  (  a1 :  a ≥  1 ) ->  (  b1 :  b ≥  1 ) ->  ¬  exists     c  ,    a ^  3 +  b ^  3 =  c ^  3",
    " {  a b c :  ℤ } ->  (  hc :   0 < c ) ->  ¬  (     a ^  3 +  b ^  3 =  c ^  3  )",
    " {  a b c :  ℕ } ->  (  h :    a ^  3 +  b ^  3 =  c ^  3 ) ->   a =  0 ∧   b =  0 ∧  c =  0"]},
  {"theorem":
   "∀ {G : Type u} [inst : Groupₓ G] {a b : G}, (∀ (g : G), orderOf g = 2) → Commute a b",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  a b : G } ->  (  h :  ∀   (  g  : G  )  ,   orderOf  g =  2 ) ->  Commute  a b",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  ∀  x   : G ,   orderOf  x =  2 ) ->  ∀  x y   : G ,  Commute  x y",
    " {  G :  Type  u } ->  {  x y : G } ->  [  Groupₓ  G ] ->  (  hx :   orderOf  x =  2 ) ->  (  hy :   orderOf  y =  2 ) ->  Commute  x y",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  ∀   (  g  : G  )  ,   IsOfFinOrder  g ∧   orderOf  g =  2 ) ->  ∀   (  a b  : G  )  ,  Commute  a b",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  ∀  x   : G ,   orderOf   (  x   : G ) =  2 ) ->  ∀  x y   : G ,  Commute   (  x   : G )  (  y   : G )",
    " {  G :  Type  u } ->  [  Monoidₓ  G ] ->  (  h :  ∀   (  x  : G  )  ,   orderOf  x =  2 ) ->  (  x y : G ) ->  Commute  x y",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  h :  ∀   (  x  : G  )  ,   orderOf  x =  2 ) ->  ∀   (  a b  : G  )  ,  Commute  a b",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  h :  ∀   (  x  : G  )  ,   orderOf  x =  2 ) ->  ∀   (  x y  : G  )  ,  Commute  x y",
    " {  G :  Type  u } ->  [  Monoidₓ  G ] ->  (  HG :  ∀  x   : G ,   orderOf  x =  2 ) ->  (  a b : G ) ->  Commute  a b",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  x : G } ->  (  h :  ∀   (  x  : G  )  ,   orderOf  x =  2 ) ->  Commute  x  (   x ⁻¹  )",
    " {  G :  Type  u } ->  [  Monoidₓ  G ] ->  (  h :  ∀   (  x  : G  )  ,   orderOf  x =  2 ) ->  ∀   (  x y  : G  )  ,  Commute  x y",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  x : G } ->  (  hx :   orderOf  x =  2 ) ->  (  y : G ) ->  (  hy :   orderOf  y =  2 ) ->  Commute  x y",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  ∀   (  x  : G  )  ,   orderOf  x =  2 ) ->  ∀   (  x y  : G  )  ,  Commute  x y"]},
  {"theorem": "∀ {m n : ℕ}, m = n + 1 → Even (m * n)",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  n m :  ℕ ) ->  Even   (   m *  (   m +  1  )  )",
    " {  m n :  ℕ } ->  (  h_succ :  m =  n +  1 ) ->  Even   (   m * n  )",
    " {  n :  ℕ } ->  Even   (   n *  (   n +  1  )  )",
    " ∀   (  m  :  ℕ  )  ,  Even   (   m *  (   m +  1  )  )",
    " {  m :  ℕ } ->  Even   (   m *  (   m +  1  )  )",
    " (  n :  ℕ ) ->  Even   (   n *  (   n +  1  )  )",
    " ∀  n   :  ℕ ,  Even   (   n *  (   n +  1  )  )",
    " (  n :  ℕ ) ->  Even   (    (   n +  1  ) * n  )",
    " {  m n :  ℕ } ->  (  h :   m +  1 = n ) ->  Even   (   m * n  )",
    " (  n :  ℕ ) ->  Even   (    (   n +  1  ) * n  )",
    " (  n :  ℕ ) ->  ∃    (   m :  ℕ ) ,  n =  m +  (   n +  1  )",
    " ∀   (  n  :  ℕ  )  ,  Even   (   n *  (   n +  1  )  )"]},
  {"theorem": "∀ {α : Type u_1}, Monoidₓ.IsTorsionFree (FreeGroup α)",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  Monoidₓ.IsTorsionFree   (   FreeGroup  α  )",
    " {  α :  Type  u } ->  [  DecidableEq  α ] ->  Monoidₓ.IsTorsionFree   (   FreeGroup  α  )",
    " {  α :  Type  u } ->  Monoidₓ.IsTorsionFree   (   FreeGroup  α  )",
    " (  α :  Type  u_1 ) ->  Monoidₓ.IsTorsionFree   (   FreeGroup  α  )",
    " (  α :  Type  u ) ->  Monoidₓ.IsTorsionFree   (   FreeGroup  α  )"]},
  {"theorem": "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number. ",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  n :  ℕ ) ->  (  h :  n >  1 ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->  (  hn :   1 < n ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->   n >  1 →  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->  (  h :   1 < n ) ->  ∃    (   p :  ℕ ) ,   p ∣ n ∧  Nat.Prime  p",
    " {  n :  ℕ } ->  (  hn :  n >  1 ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->    1 < n →  ∃     p  :  ℕ ,   Nat.Prime  p ∧  p ∣ n",
    " (  a :  ℕ ) ->  (  ha :   1 < a ) ->  ∃    (   p :  ℕ ) ,   a ∣ p ∧  Nat.Prime  p",
    " (  n :  ℕ ) ->  (  hn :  n >  1 ) ->  ∃    (   p :  ℕ ) ,   Prime  p ∧  p ∣ n",
    " {  n :  ℕ } ->  (  hn :   1 < n ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->  (  hn :  n >  1 ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->  (  H :   1 < n ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  (   p ∣ n  )",
    " (  n :  ℕ ) ->   n >  1 →  ∃    (   p :  ℕ ) ,   Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->    1 < n →  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " {  n :  ℕ } ->   n >  1 →  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " {  n :  ℕ } ->  (  hn :   2 ≤ n ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣ n",
    " (  n :  ℕ ) ->  (  hn :  n >  1 ) ->  ∃     p  ,  p.prime ∧  p ∣ n"]},
  {"theorem":
   "∀ {α : Type u} [inst : Groupₓ α] [inst_1 : Fintype α], Monoidₓ.IsTorsionFree α → Fintype.card α ≤ 1",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  (  h₁ :  Monoidₓ.IsTorsionFree  α ) ->   Fintype.card  α ≤  1",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  (  h :  Monoidₓ.IsTorsionFree  α ) ->   Fintype.card  α =  1",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  tf :  Monoidₓ.IsTorsionFree  G ) ->   Fintype.card  G =  1",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  h :  Monoidₓ.IsTorsionFree  G ) ->   Fintype.card  G =  1",
    " {  G :  Type  u } ->  [ hG :  Groupₓ  G ] ->  [ hf :  Fintype  G ] ->  (  h :  Monoidₓ.IsTorsionFree  G ) ->   Fintype.card  G =  1",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  h :  Monoidₓ.IsTorsionFree  G ) ->  G =  1"]},
  {"theorem":
   "∀ (K : Type u) [inst : Fintype K] [inst : DivisionRing K], IsField K",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  Fintype  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u_1 ) ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " {  k :  Type  u } ->  [  Fintype  k ] ->  [  DivisionRing  k ] ->  IsField  k",
    " {  R :  Type  u } ->  [  Fintype  R ] ->  [  DivisionRing  R ] ->  IsField  R",
    " (  K :  Type  u ) ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " {  K :  Type  u } ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " {  F :  Type  u } ->  [  DivisionRing  F ] ->  (  hF :  Fintype  F ) ->  IsField  F",
    " {  K :  Type  u } ->  [  Fintype  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " {  α :  Type  u_1 } ->  [  Fintype  α ] ->  [  DivisionRing  α ] ->  IsField  α",
    " {  K :  Type  u_1 } ->  [  DivisionRing  K ] ->  [  Fintype  K ] ->  IsField  K",
    " (  F :  Type  u_1 ) ->  [  DivisionRing  F ] ->  [  Fintype  F ] ->  IsField  F",
    " {  R :  Type  u_1 } ->  [  Fintype  R ] ->  [  DivisionRing  R ] ->  IsField  R"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  Fintype  α ] ->  CompactSpace  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  CompactSpace  α",
    " {  α :  Type* } ->  [  TopologicalSpace  α ] ->  (  h :  Finite  α ) ->  CompactSpace  α",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  (  hX :  Fintype  X ) ->  CompactSpace  X",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  Fintype  α ) ->  IsCompact  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  h :  Finite  α } ->  CompactSpace  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  Fintype  α ) ->  CompactSpace  α",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  (  hX :  Fintype  X ) ->  IsCompact  X",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  Fintype  α ] ->  IsCompact  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  hfin :  Fintype  α ) ->  IsCompact  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  Fintype  α ] ->  IsCompact  α",
    " {  α :  Type* } ->  [  TopologicalSpace  α ] ->  [  Fintype  α ] ->  CompactSpace  α",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  (  h :  Fintype  X ) ->  IsCompact  X",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  [  Fintype  X ] ->  CompactSpace  X"]},
  {"theorem":
   "∀ (n : ℕ) (a : 0 < n) (a : Even n), ∃ a b, a ≠ b ∧ Nat.Prime a ∧ Nat.Prime b ∧ a + b = n",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀   (  n  :  ℕ  )  ,    0 < n →   Even  n →  ∃    (   a  b :  ℕ ) ,   a ≠ b ∧   Nat.Prime  a ∧   Nat.Prime  b ∧   a + b = n",
    " (  n :  ℕ ) ->  (  heven :  Even  n ) ->  (  hpos :   0 < n ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   p + q = n",
    " {  n :  ℕ } ->  (  hpos :   0 < n ) ->  ∃    (   p  q :  ℕ ) ,   n =  p + q ∧   Nat.Prime  p ∧  Nat.Prime  q",
    " {  a :  ℕ } ->  (  hpos :   0 < a ) ->  (  heven :  Even  a ) ->  ∃    (   b  c :  ℕ ) ,   Nat.Prime  b ∧   Nat.Prime  c ∧   b + c = a",
    " {  n :  ℕ } ->  (  hn :    0 < n ∧  Even  n ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧  n =  p + q",
    " {  n :  ℕ } ->  (  h_even :  Even  n ) ->  (  hlt :   0 < n ) ->  ∃    (   m :  ℕ ) ,   (   m ∈  {   p   :  ℕ |  Nat.Prime  p }  ) ∧  ∃    (   k :  ℕ ) ,   (   k ∈  {   p   :  ℕ |  Nat.Prime  p }  ) ∧   m + k = n",
    " (  n :  ℕ ) ->  (  hn :   0 < n ) ->  (  h_even :  Even  n ) ->  ∃     p  q  :  ℕ ,   Nat.Prime  p ∧   Nat.Prime  q ∧  n =  p + q",
    " (  n :  ℕ ) ->  (  hpos :   0 < n ) ->  (  heven :  Even  n ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   p + q = n",
    " {  n :  ℕ } ->  (  hpos :  n >  0 ) ->  (  heven :   n %  2 =  0 ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   p + q = n",
    " {  n :  ℕ } ->  (  hpos :   0 < n ) ->  (  heven :  Even  n ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   p + q = n",
    " {  m :  ℕ } ->  (  m0 :   0 < m ) ->  (  even_m :  Even  m ) ->  ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧   a + b = m",
    " {  n :  ℕ } ->    0 < n →   Even  n →  ∃    (   q  r :  ℕ ) ,   Nat.Prime  q ∧   Nat.Prime  r ∧  n =  q + r",
    " {  n :  ℕ } ->  (  h_pos_even :    0 < n ∧  Even  n ) ->  ∃    (   a  b :  ℕ ) ,   a ≠ b ∧   Nat.Prime  a ∧   Nat.Prime  b ∧   a + b = n",
    " (  n :  ℕ ) ->  (  h :  ¬  Nat.Prime  n ) ->  (  h2 :   2 ∣ n ) ->  (  hpos :   0 < n ) ->  ∃     x  y  :  ℕ ,   Nat.Prime  x ∧   Nat.Prime  y ∧   x + y = n",
    " {  n :  ℕ } ->  (  h :    0 < n ∧  Even  n ) ->  ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧   a + b = n",
    " {  n :  ℕ } ->  (  hpos :   0 < n ) ->  (  heven :  Even  n ) ->  ∃    (   m  p :  ℕ ) ,   Nat.Prime  m ∧   Nat.Prime  p ∧   m + p = n"]},
  {"theorem":
   "∀ {A : Type u} {n : Type v} [inst : CommRingₓ A] [inst_1 : Fintype n] [inst_2 : DecidableEq n] (M : Matrix n n A),\n  AlgHom.toFun (Polynomial.aeval M) (Matrix.charpoly M) = 0",
   "some-correct": null,
   "prompt": "Every matrix satisfies its own characteristic polynomial.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  A :  Type  u } ->  {  n :  Type  v } ->  [  CommRingₓ  A ] ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  (  M :  Matrix  n n A ) ->   Polynomial.aeval  M M.charpoly =  0",
    " {  R :  Type  u } ->  [  CommRingₓ  R ] ->  {  n :  Type  w } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->   Polynomial.aeval  M M.charpoly =  0"]},
  {"theorem": "∀ {m : ℕ}, Even (m * m) → Even m",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  n :  ℕ } ->  (  h :  Even   (   n ^  2  ) ) ->  Even  n",
    " {  m :  ℕ } ->  {  h :  Even   (   m ^  2  ) } ->  Even  m",
    " {  m :  ℕ } ->  (  hm :  Even   (   m ^  2  ) ) ->  Even  m",
    " {  m :  ℕ } ->   Even   (   m ^  2  ) →  Even  m",
    " {  n :  ℕ } ->   Even   (   n ^  2  ) →  Even  n",
    " {  m :  ℕ } ->   Even   (   m * m  ) →  Even  m",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  a : α ) ->   Even   (   a ^  2  ) →  Even  a",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  a : α ) ->   Even   (   a ^  2  ) →  Even  a",
    " {  n :  ℕ } ->   Even   (   n * n  ) →  Even  n",
    " {  α :  Type  u_2 } ->  [  Ring  α ] ->  {  a : α } ->  (  ha :  IsSquare  a ) ->  (  ha_even :  Even   (   a * a  ) ) ->  Even  a",
    " {  α :  Type  u_2 } ->  [  Ringₓ  α ] ->  {  a : α } ->  (  ha :  IsSquare  a ) ->  (  ha_even :  Even   (   a * a  ) ) ->  Even  a",
    " {  m :  ℕ } ->    Even  m ^  2 →  Even  m",
    " {  m :  ℕ } ->   Even   (   m * m  ) →  Even  m",
    " {  n :  ℕ } ->  (  h :  Even   (   n * n  ) ) ->  Even  n",
    " {  n :  ℕ } ->  (  H :  Even   (   n * n  ) ) ->  Even  n"]},
  {"theorem":
   "∀ {α : Type u} [inst : CommRing α] [inst_1 : Fintype α] {x y : α} (h : x ≠ 0),\n  ∃ z, z * x = 1 ↔ ∃ z h, x ≠ 0 ∧ ∀ (w : α), z * w = 1 → y * w = y",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  CommRing  α ] ->  [  Fintype  α ] ->  {  x y : α } ->  (  h :  x ≠  0 ) ->  ∃     z  : α ,    z * x =  1 ↔  ∃    (   z : α )  (   h :   z * x =  1 ) ,   x ≠  0 ∧  ∀  w  ,    z * w =  1 →   y * w = y",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  [  Fintype  α ] ->  {  x y : α } ->  (  h :  x ≠  0 ) ->  ∃     z  : α ,    z * x =  1 ↔  ∃    (   z : α )  (   h :   z * x =  1 ) ,   x ≠  0 ∧  ∀  w  ,    z * w =  1 →   y * w = y"]},
  {"theorem":
   "∀ {α : Type u} {s : Set α} [inst : TopologicalSpace α], (∀ (x : α), x ∈ s → ∃ t, IsOpen t ∧ x ∈ t) → IsOpen s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  {  s :  Set  α } ->  [  TopologicalSpace  α ] ->  (  h :  ∀   (  x  : α  )  (  h  :  x ∈ s  )  ,  ∃    (   t :  Set  α ) ,   IsOpen  t ∧  x ∈ t ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃    (   U :  Set  α ) ,   IsOpen  U ∧  x ∈ U ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h_s_open :  ∀  x  ∈ s ,  ∃    (   u :  Set  α ) ,   IsOpen  u ∧  x ∈ u ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->  (  h :  ∀  x  ∈ s ,  ∃     U  ,   IsOpen  U ∧   x ∈ U ∧  U ⊆ t ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀  x  ∈ s ,  ∃     U  ,   IsOpen  U ∧  x ∈ U ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  {  x : α } ->  (  hx :  x ∈  Closure  s ) ->  ∃    (   t :  Set  α ) ,   x ∈ t ∧   IsOpen  t ∧  t ⊆ s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀  x  ∈ s ,  ∃     V  ,   IsOpen  V ∧  x ∈ V ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->  (  HSub :  s ⊆ t ) ->  (  h :  ∀  x  ∈ t ,  ∃     u  ,   IsOpen  u ∧  x ∈ u ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  H :  ∀  x  ∈ s ,  ∃     U  :  Set  α ,   IsOpen  U ∧  x ∈ U ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  x : α } ->  {  s :  Set  α } ->  (  hs :  ∀  x  ∈ s ,  ∃     t  ,   IsOpen  t ∧  x ∈ t ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀  x  ∈ s ,  ∃    (   U :  Set  α ) ,   IsOpen  U ∧  x ∈ U ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃    (   u :  Set  α ) ,   IsOpen  u ∧  x ∈ u ) ->  IsOpen  s",
    " {  α :  Type  u } ->  {  s :  Set  α } ->  [  TopologicalSpace  α ] ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃    (   u :  Set  α ) ,   IsOpen  u ∧  x ∈ u ) ->  IsOpen  s",
    " {  α :  Type  u } ->  [ t :  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃    (   t :  Set  α ) ,   x ∈ t ∧  IsOpen  t ) ->  IsOpen  s"]},
  {"theorem":
   "∀ {G : Type u}, FreeGroup G → ∀ {g : FreeGroup G}, g ≠ 1 → ¬IsOfFinOrder g",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  (  hG :  FreeGroup  G ) ->  {  g :  FreeGroup  G } ->   g ≠  1 →  ¬  IsOfFinOrder  g",
    " (  α :  Type  u ) ->  (  a : α ) ->  ¬  IsOfFinOrder   (   FreeGroup.of  a  )",
    " {  α :  Type  u } ->  {  f :  FreeGroup  α } ->  (  hf :  f ≠  1 ) ->  ¬  IsOfFinOrder  f",
    " {  α :  Type  u } ->  {  L :  List   (   α × Bool  ) } ->  (  H :   FreeGroup.mk  L ≠  1 ) ->  ¬  IsOfFinOrder   (   FreeGroup.mk  L  )",
    " {  α :  Type  u } ->  (  g :  FreeGroup  α ) ->   ¬  IsOfFinOrder  g ↔  ¬  g =  1",
    " {  α :  Type  u_1 } ->  {  g :  FreeGroup  α } ->  (  hg :  g ≠  1 ) ->  ¬  IsOfFinOrder  g",
    " {  α :  Type  u } ->  ∀   (  g  :  FreeGroup  α  )  ,   g ≠  1 →  ¬  IsOfFinOrder  g",
    " {  α :  Type* } ->  {  x :  FreeGroup  α } ->  (  h :  x ≠  1 ) ->  ¬  IsOfFinOrder  x",
    " {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  x :  FreeGroup  α ) ->   x ≠  1 →  ¬  IsOfFinOrder  x",
    " {  α :  Type  u } ->  {  w :  FreeGroup  α } ->  (  hw :  w ≠  1 ) ->  ¬  IsOfFinOrder  w",
    " {  α :  Type* } ->  (  g :  FreeGroup  α ) ->   g ≠  1 →  ¬  IsOfFinOrder  g",
    " {  α :  Type  u } ->  ∀   {  L  :  List   (   α × Bool  ) }  ,  ¬  IsOfFinOrder   (   FreeGroup.of  L  )"]},
  {"theorem":
   "∀ {a b : ℕ}, a = 1 ∨ b = 1 → 1 < a * b → ∃ n, ∀ (N : ℕ), n ≤ N → ∃ x y, a * x + b * y = N",
   "some-correct": null,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  a b :  ℕ } ->  (  h1 :   a =  1 ∨  b =  1 ) ->  (  h2 :   (   1   :  ℕ ) <  a * b ) ->  ∃    (   n :  ℕ ) ,  ∀   (  N  :  ℕ  )  (  hN  :  n ≤ N  )  ,  ∃    (   x  y :  ℕ ) ,    a * x +  b * y = N",
    " {  a b :  ℕ } ->  (  hab :  a.coprime  b ) ->  (  N :  ℕ ) ->  (  hN :  N ≥  a * b ) ->  ∃    (   x  y :  ℕ ) ,  N =   a * x +  b * y",
    " {  a b :  ℕ } ->  (  hab :  IsCoprime  a b ) ->  {  N :  ℕ } ->  (  hN :  N ≥  a * b ) ->  ∃    (   x  y :  ℕ ) ,   ↑ N =   a * x +  b * y",
    " {  a b :  ℤ } ->  (  hab :  IsCoprime  a b ) ->  (  N :  ℕ ) ->  ∃    (   x  y :  ℕ ) ,   ↑  (    a * x +  b * y  ) =  ↑ N",
    " (  a b :  ℕ ) ->  (  h :  IsCoprime  a b ) ->  {  N :  ℕ } ->  (  hN :  N >  (   a + b   :  ℕ ) ) ->  ∃    (   x  y :  ℕ ) ,  N =   a * x +  b * y",
    " {  a b N :  ℕ } ->  (  h :  a.coprime  b ) ->  (  h1 :  N >  0 ) ->  ∃    (   x  y :  ℕ ) ,   ↑ N =   a * x +  b * y",
    " (  m n :  ℕ ) ->  (  hm0 :   0 < m ) ->  (  hn0 :   0 < n ) ->  (  hcop :  m.coprime  n ) ->  {  N :  ℕ } ->  (  hN :  N ≥  m + n ) ->  ∃    (   x  y :  ℕ ) ,  N =   m * x +  n * y",
    " {  a b c :  ℤ } ->  (  hab :   gcd  a b =  1 ) ->  (  hc :  c >  0 ) ->  ∃    (   x  y :  ℤ ) ,   ↑  (  c   :  ℕ ) =   a * x +  b * y",
    " {  a b :  ℕ } ->  (  h :  IsCoprime  a b ) ->  (  N :  ℕ ) ->  ∃    (   x  y :  ℕ ) ,  N =   a * x +  b * y"]},
  {"theorem": "{α : Type u_1} → [inst : Field α] → NonAssocRing α",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  [  Field  α ] ->  NonAssocRing  α",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ring  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  Ringₓ  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  Ring  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  Ringₓ  K",
    " {  α :  Type  u } ->  [  Field  α ] ->  NonAssocSemiring  α",
    " {  α :  Type  u } ->  [  Field  α ] ->  NonAssocSemiringₓ  α",
    " (  R :  Type  u ) ->  [  Field  R ] ->  NonAssocRing  R",
    " {  α :  Type  u } ->  [  Field  α ] ->  Ring  α",
    " {  α :  Type  u } ->  [  Field  α ] ->  Ringₓ  α",
    " (  F :  Type  u ) ->  [  Field  F ] ->  Ring  F",
    " (  F :  Type  u ) ->  [  Field  F ] ->  Ringₓ  F",
    " (  R :  Type  u_1 ) ->  [  Field  R ] ->  Ring  R",
    " (  R :  Type  u_1 ) ->  [  Field  R ] ->  Ringₓ  R",
    " {  R :  Type  u_1 } ->  [  Field  R ] ->  Ring  R",
    " {  R :  Type  u_1 } ->  [  Field  R ] ->  Ringₓ  R",
    " (  R :  Type  u ) ->  [  Field  R ] ->  Ring  R",
    " (  R :  Type  u ) ->  [  Field  R ] ->  Ringₓ  R",
    " (  R :  Type  u ) ->  [  Field  R ] ->  Ring  R",
    " (  R :  Type  u ) ->  [  Field  R ] ->  Ringₓ  R",
    " {  α :  Type  u } ->  [  Field  α ] ->  NonAssocRing  α",
    " {  α :  Type  u_1 } ->  (  h :  Field  α ) ->  Ring  α",
    " {  α :  Type  u_1 } ->  (  h :  Field  α ) ->  Ringₓ  α",
    " (  R :  Type  u_1 ) ->  [  Field  R ] ->  Ring  R",
    " (  R :  Type  u_1 ) ->  [  Field  R ] ->  Ringₓ  R",
    " (  K :  Type  u_1 ) ->  [  Field  K ] ->  Ring  K",
    " (  K :  Type  u_1 ) ->  [  Field  K ] ->  Ringₓ  K"]},
  {"theorem": "{R : Type u_1} → [inst : Ringₓ R] → Group (Units R)",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  Group   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  Groupₓ   (   Units  R  )",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  Group   (   Units  α  )",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  Groupₓ   (   Units  α  )",
    " {  R :  Type  u₁ } ->  [  CommRingₓ  R ] ->  AddCommGroup   (   Units  R  )",
    " {  R :  Type  u₁ } ->  [  CommRingₓ  R ] ->  AddCommGroupₓ   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  AddCommGroup   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  AddCommGroupₓ   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  Group   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  Groupₓ   (   Units  R  )",
    " {  α :  Type  u_1 } ->  [  CommRingₓ  α ] ->  Group   (   Units  α  )",
    " {  α :  Type  u_1 } ->  [  CommRingₓ  α ] ->  Groupₓ   (   Units  α  )",
    " (  R :  Type   _ ) ->  [  Ringₓ  R ] ->  Group   (   Units  R  )",
    " (  R :  Type   _ ) ->  [  Ringₓ  R ] ->  Groupₓ   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  [  IsNoetherianRing  R ] ->  AddCommGroup   (   Units  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  [  IsNoetherianRing  R ] ->  AddCommGroupₓ   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  GroupWithZero   (   Units  R  )",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  GroupWithZeroₓ   (   Units  R  )",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  Group   (   Units  α  )",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  Groupₓ   (   Units  α  )"]},
  {"theorem":
   "∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Groupₓ (Gs i)],\n  Monoidₓ.IsTorsionFree ((i : η) → Gs i) → ∀ (i : η), Monoidₓ.IsTorsionFree (Gs i)",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  η :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  H :  Monoidₓ.IsTorsionFree   (   Π ( i : η ) ,  Gs  i  ) ) ->  ∀   (  i  : η  )  ,  Monoidₓ.IsTorsionFree   (   Gs  i  )",
    " {  η :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  tf :  Monoidₓ.IsTorsionFree   (   Π ( i : η ) ,  Gs  i  ) ) ->  ∀   (  i  : η  )  ,  Monoidₓ.IsTorsionFree   (   Gs  i  )",
    " {  η :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  tfGs :  ∀   (  i  : η  )  ,  Monoidₓ.IsTorsionFree   (   Gs  i  ) ) ->  Monoidₓ.IsTorsionFree   (   Π ( i : η ) ,  Gs  i  )",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Groupₓ  α ] ->  [  Groupₓ  β ] ->   Monoidₓ.IsTorsionFree   (   α × β  ) →   Monoidₓ.IsTorsionFree  α ∧  Monoidₓ.IsTorsionFree  β",
    " {  η :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  tfGs :  Monoidₓ.IsTorsionFree   (   Π ( i : η ) ,  Gs  i  ) ) ->  ∀   (  i  : η  )  ,  Monoidₓ.IsTorsionFree   (   Gs  i  )",
    " {  η :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  tfGs :  Monoidₓ.IsTorsionFree   (   Π ( i : η ) ,  Gs  i  ) ) ->  (  i : η ) ->  Monoidₓ.IsTorsionFree   (   Gs  i  )",
    " {  η :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  tfG :  Monoidₓ.IsTorsionFree   (   Π ( i : η ) ,  Gs  i  ) ) ->  (  i : η ) ->  Monoidₓ.IsTorsionFree   (   Gs  i  )",
    " {  η :  Type  u_1 } ->  {  Gs :  η →  Type  u_2 } ->  [  Π ( i : η ) ,  Groupₓ   (   Gs  i  ) ] ->  (  H :  Monoidₓ.IsTorsionFree   (   Π ( i : η ) ,  Gs  i  ) ) ->  (  i : η ) ->  Monoidₓ.IsTorsionFree   (   Gs  i  )"]}],
 "elaborated": 30}