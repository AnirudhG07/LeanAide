{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 12,
 "include-fixed": false,
 "failures":
 ["Every set of Borel measure zero is Lebesgue measurable.",
  "There is no field of order `10`."],
 "elaborated-prompts":
 [{"theorem": "∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
    "∀ (p : ℕ), Nat.Prime p → p = 2 ∨ Odd p"]},
  {"theorem": "{n | n % 2 = 1}.Infinite",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["{n | n % 2 = 1}.Infinite",
     "{n | n % 2 = 1}.Infinite",
     "{n | n % 2 = 1}.Infinite",
     "{n | n % 2 = 1}.Infinite",
     "{n | n % 2 = 1}.Infinite"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {n : ℕ | n % 2 = 1}",
    "Set.Infinite {n : ℕ | n % 2 = 1}",
    "Set.Infinite {n : ℕ | n % 2 = 1}",
    "{n : ℕ | n % 2 = 1}.Infinite",
    "Set.Infinite {n : ℕ | n % 2 = 1}",
    "Set.Infinite {n : ℕ | n % 2 = 1}",
    "{n : ℕ | n % 2 = 1}.Infinite",
    "Set.Infinite {n : ℕ | n % 2 = 1}",
    "Set.Infinite {n : ℕ | n % 2 = 1}",
    "Set.Infinite {n : ℕ | n % 2 = 1}"]},
  {"theorem": "∀ {p : ℕ}, p.Prime → p % 2 = 1 → p ≥ 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["∀ {p : ℕ}, p.Prime → p % 2 = 1 → p ≥ 3",
     "∀ {p : ℕ}, p.Prime → p % 2 = 1 → p ≥ 3",
     "∀ {p : ℕ}, p.Prime → p % 2 = 1 → p ≥ 3",
     "∀ {p : ℕ}, p.Prime → p % 2 = 1 → p ≥ 3"],
    ["∀ {p : ℕ}, p.Prime → Odd p → p ≥ 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → Odd p → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p ∧ p % 2 = 1 → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p ≥ 3",
    "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p ≥ 3 → p = 3"]},
  {"theorem": "{p | p.Prime ∧ p % 2 = 1}.Infinite",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["{p | p.Prime ∧ p % 2 = 1}.Infinite",
     "{p | p.Prime ∧ p % 2 = 1}.Infinite",
     "{p | p.Prime ∧ p % 2 = 1}.Infinite",
     "{p | p.Prime ∧ p % 2 = 1}.Infinite"],
    ["{p | p.Prime ∧ Odd p}.Infinite"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    "Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}",
    "Set.Infinite {p : ℕ | Nat.Prime p ∧ p % 2 = 1}"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [Field K] [AddCommGroup V] [Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K"],
    ["{K : Type u} → [inst : Field K] → DivisionRing K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ {K : Type u} [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K",
    "∀ (K : Type u) [inst : Field K], DivisionRing K"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"],
    ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
    "∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V],\n  FiniteDimensional.finrank 𝕜 V = 2 → FiniteDimensional 𝕜 V"]},
  {"theorem": "∀ (n : ℕ), ∃ m, m = n.succ",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ m, m = n.succ",
     "∀ (n : ℕ), ∃ m, m = n.succ",
     "∀ (n : ℕ), ∃ m, m = n.succ",
     "∀ (n : ℕ), ∃ m, m = n.succ",
     "∀ (n : ℕ), ∃ m, m = n.succ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m : ℕ, m = n.succ",
    "∀ (n : ℕ), ∃ m, m = n.succ",
    "∀ (n : ℕ), ∃ m, m = n.succ"]},
  {"theorem": "∀ (n : ℕ), n < n.succ",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ",
    "∀ (n : ℕ), n < n.succ"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasureTheory.MeasureSpace α] (s : Set α), MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasureTheory.MeasureSpace α] (s : Set α), MeasurableSet s",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α] (s : Set α), MeasurableSet s",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α] (s : Set α), MeasurableSet s",
     "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α] (s : Set α), MeasurableSet s"],
    ["∀ {α : Type u_6} [inst : MeasurableSpace α] [self : MeasureTheory.MeasureSpace α] (s : Set α), MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasureTheory.MeasureSpace α], ∀ s : Set α, MeasurableSet s",
    "∀ {α : Type u_6} [inst : MeasurableSpace α] [self : MeasureTheory.MeasureSpace α], ∀ s : Set α, MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α], ∀ s : Set α, MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α], ∀ s : Set α, MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasureTheory.MeasureSpace α], ∀ s : Set α, MeasurableSet s",
    "∀ {α : Type u_1} [inst : MeasurableSpace α] [self : MeasureTheory.MeasureSpace α], ∀ s : Set α, MeasurableSet s"]},
  {"theorem": "∀ {p : ℕ}, p.Prime → ¬∃ n, n * n = p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {p : ℕ}, p.Prime → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, p.Prime → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, p.Prime → ¬∃ n, n * n = p",
     "∀ {p : ℕ}, p.Prime → ∀ (n : ℕ), n * n ≠ p",
     "∀ {p : ℕ}, p.Prime → ¬∃ n, n * n = p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ∀ n : ℕ, n * n ≠ p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n : ℕ, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ∀ n : ℕ, n * n ≠ p",
    "∀ {p : ℕ}, Nat.Prime p → ¬∃ n, n * n = p",
    "∀ {p : ℕ}, Nat.Prime p → ∀ n : ℕ, n * n ≠ p",
    "∀ {p : ℕ}, Nat.Prime p → ∀ n : ℕ, n * n ≠ p",
    "∀ {p : ℕ}, Nat.Prime p → ∀ n : ℕ, n * n ≠ p"]},
  {"theorem": "∀ {p : ℕ} [inst : Fact p.Prime], Odd p → p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact p.Prime], Odd p → p > 2",
     "∀ (p : ℕ) [inst : Fact p.Prime], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact p.Prime], Odd p → p > 2"],
    ["∀ {p : ℕ} [inst : Fact p.Prime], p % 2 = 1 → p > 2",
     "∀ {p : ℕ} [inst : Fact p.Prime], p % 2 = 1 → 2 < p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p : ℕ} [Fact (Nat.Prime p)], p % 2 = 1 → p > 2",
    "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], p % 2 = 1 → 2 < p",
    "∀ (p : ℕ) [Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], Odd p → 2 < p",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], Odd p → 2 < p",
    "∀ {p : ℕ} [Fact (Nat.Prime p)], Odd p → p > 2",
    "∀ (p : ℕ) [Fact (Nat.Prime p)], p % 2 = 1 → p > 2",
    "∀ (p : ℕ) [Fact (Nat.Prime p)], p % 2 = 1 → p > 2"]},
  {"theorem":
   "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ z₁ z₂ z₃ z₄, a * b = z₁ ^ 2 + z₂ ^ 2 + z₃ ^ 2 + z₄ ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ z₁ z₂ z₃ z₄, a * b = z₁ ^ 2 + z₂ ^ 2 + z₃ ^ 2 + z₄ ^ 2",
     "∀ {a b x y z w u v s t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ {a b x y z w u v s t : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
     "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n    b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 → ∃ z₁ z₂ z₃ z₄, a * b = z₁ ^ 2 + z₂ ^ 2 + z₃ ^ 2 + z₄ ^ 2"],
    ["∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + z ^ 2 + (u ^ 2 + v ^ 2) → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n  b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 →\n  ∃ z₁ z₂ z₃ z₄, a * b = z₁ ^ 2 + z₂ ^ 2 + z₃ ^ 2 + z₄ ^ 2",
    "∀ {a b x y z w u v s t : ℕ}, \n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → \n  b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → \n  ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ {a b x y z w u v s t : ℕ}, \n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → \n  b = u ^ 2 + v ^ 2 + s ^ 2 + t ^ 2 → \n  ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2",
    "∀ {a b x₁ x₂ x₃ x₄ y₁ y₂ y₃ y₄ : ℕ},\n  a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2 →\n  b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2 →\n  ∃ z₁ z₂ z₃ z₄, a * b = z₁ ^ 2 + z₂ ^ 2 + z₃ ^ 2 + z₄ ^ 2",
    "∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  b = w ^ 2 + z ^ 2 + (u ^ 2 + v ^ 2) →\n  ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
    "∀ {a b x y u v w z : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2",
    "∀ {a b a1 a2 a3 a4 b1 b2 b3 b4 : ℕ},\n  a = a1 ^ 2 + a2 ^ 2 + a3 ^ 2 + a4 ^ 2 →\n  b = b1 ^ 2 + b2 ^ 2 + b3 ^ 2 + b4 ^ 2 →\n  ∃ c1 c2 c3 c4, a * b = c1 ^ 2 + c2 ^ 2 + c3 ^ 2 + c4 ^ 2",
    "∀ {a b w x y z p q r s : ℕ}, \n  a = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 → \n  b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 → \n  ∃ u v m n, a * b = u ^ 2 + v ^ 2 + m ^ 2 + n ^ 2",
    "∀ {a b w x y z p q r s : ℕ},\n  a = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 →\n  b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 →\n  ∃ u v m n, a * b = u ^ 2 + v ^ 2 + m ^ 2 + n ^ 2",
    "∀ {a b : ℕ}, (∃ x₁ x₂ x₃ x₄, a = x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2 + x₄ ^ 2) →\n             (∃ y₁ y₂ y₃ y₄, b = y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2 + y₄ ^ 2) →\n             ∃ z₁ z₂ z₃ z₄, a * b = z₁ ^ 2 + z₂ ^ 2 + z₃ ^ 2 + z₄ ^ 2"]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
     "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]},
  {"theorem": "∀ {p q : ℕ}, p.Prime → q.Prime → p ≠ q → p + q ≠ 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["∀ {p q : ℕ}, p.Prime → q.Prime → p ≠ q → p + q ≠ 6",
     "¬∃ p q, p.Prime ∧ q.Prime ∧ p ≠ q ∧ p + q = 6",
     "¬∃ p q, p.Prime ∧ q.Prime ∧ p ≠ q ∧ p + q = 6",
     "¬∃ p q, p.Prime ∧ q.Prime ∧ p ≠ q ∧ p + q = 6",
     "¬∃ p q, p.Prime ∧ q.Prime ∧ p ≠ q ∧ p + q = 6"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    "¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6"]},
  {"theorem": "∀ (z : ℤ), ¬Irrational ↑z",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (z : ℤ), ¬Irrational ↑z",
     "∀ (n : ℤ), ¬Irrational ↑n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (z : ℤ), ¬Irrational (z : ℝ)",
    "∀ (z : ℤ), ¬Irrational ↑z",
    "∀ (n : ℤ), ¬Irrational (n : ℝ)",
    "∀ (z : ℤ), ¬Irrational (↑z : ℝ)",
    "∀ (n : ℤ), ¬Irrational (n : ℝ)",
    "∀ (z : ℤ), ¬Irrational (z : ℝ)",
    "∀ (z : ℤ), ¬Irrational (↑z : ℝ)",
    "∀ (z : ℤ), ¬Irrational (z : ℝ)",
    "∀ (n : ℤ), ¬Irrational (n : ℝ)",
    "∀ (z : ℤ), ¬Irrational (z : ℝ)"]},
  {"theorem": "∀ {R : Type u} [inst : Ring R], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1",
     "∀ {α : Type u} [inst : Ring α], IsUnit 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {α : Type u} [inst : Ring α], IsUnit (1 : α)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)",
    "∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)"]},
  {"theorem": "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
   "some-correct": null,
   "prompt": "Every subgroup of a group is a group.",
   "groups":
   [["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H",
     "{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group ↥H"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group ↥H"]},
  {"theorem": "∀ (a b : ℕ), ∃ c, c = a + b",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["∀ (a b : ℕ), ∃ c, c = a + b",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c",
     "∀ (a b : ℕ), ∃ c, a + b = c"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (a b : ℕ), ∃ (c : ℕ), c = a + b",
    "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c",
    "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c",
    "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c",
    "∀ (a b : ℕ), ∃ (c : ℕ), a + b = c",
    "∀ (a b : ℕ), ∃ (c : ℕ), c = a + b"]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)",
    "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G)"]},
  {"theorem": "Nat.Prime 7",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups":
   [["Nat.Prime 7",
     "Nat.Prime 7",
     "Nat.Prime 7",
     "Nat.Prime 7",
     "Nat.Prime 7"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7",
    "Nat.Prime 7"]},
  {"theorem": "Nat.card ↑{p | p.Prime ∧ p < 8} = 3",
   "some-correct": null,
   "prompt": "There are `3` prime numbers below `8`.",
   "groups":
   [["Nat.card ↑{p | p.Prime ∧ p < 8} = 3",
     "Nat.card ↑{p | p.Prime ∧ p < 8} = 3"],
    ["Finset.filter Nat.Prime (Finset.range 8) = {2, 3, 5, 7}",
     "∃ p, p = {2, 3, 5, 7} ∧ p.card = 4"],
    ["(Finset.filter Nat.Prime (Finset.Ico 1 8)).card = 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["Finset.filter Nat.Prime (Finset.range 8) = {2, 3, 5, 7}",
    "∃ (p : Finset ℕ), p = {2, 3, 5, 7} ∧ p.card = 4",
    "Finset.card (Finset.filter Nat.Prime (Finset.Ico 1 8)) = 3",
    "Nat.card {p : ℕ | Nat.Prime p ∧ p < 8} = 3",
    "Nat.card {p : ℕ | Nat.Prime p ∧ p < 8} = 3",
    "Finset.filter Nat.Prime (Finset.range 8) = {2, 3, 5, 7}",
    "Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3",
    "Nat.card {p : ℕ | Nat.Prime p ∧ p < 8} = 3",
    "Nat.card (Finset.filter Nat.Prime (Finset.range 8)) = 3"]},
  {"theorem": "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
     "∀ {α : Type u} (s : Finset α), ∅ ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s",
    "∀ {α : Type u} (s : Finset α), ∅ ⊆ s"]},
  {"theorem": "∀ {α : Type u} (s : Set α), s.Infinite → ∃ t, t.Finite ∧ t ⊆ s",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} (s : Set α), s.Infinite → ∃ t, t.Finite ∧ t ⊆ s",
     "∀ {α : Type u} {s : Set α}, s.Infinite → ∃ t, t.Finite ∧ t ⊆ s",
     "∀ {α : Type u} (s : Set α), s.Infinite → ∃ t, t.Finite ∧ t ⊆ s"],
    ["∀ {α : Type u} (s : Set α), Infinite ↑s → ∃ t, t.Finite ∧ t ⊆ s",
     "∀ {α : Type u} (s : Set α), Infinite ↑s → ∃ t, t.Finite ∧ t ⊆ s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (s : Set α), Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} (s : Set α), Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} (s : Set α), Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} (s : Set α), Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} (s : Set α), Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s",
    "∀ {α : Type u} (s : Set α), Set.Infinite s → ∃ t : Set α, t ⊆ s ∧ Set.Finite t",
    "∀ {α : Type u} (s : Set α), Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s"]},
  {"theorem": "{R : Type u} → [inst : CommRing R] → Monoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R",
     "{R : Type u} → [inst : CommRing R] → Monoid R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R",
    "∀ {R : Type u} [inst : CommRing R], Monoid R"]},
  {"theorem": "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b",
     "∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b",
    "∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x",
     "∀ {G : Type u_1} [inst : Group G] [Subs : Subsingleton G] (x : G), IsOfFinOrder x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [Subs : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [Subsingleton G], ∀ x : G, IsOfFinOrder x",
    "∀ {G : Type u_1} [inst : Group G] [Subsingleton G], ∀ x : G, IsOfFinOrder x"]},
  {"theorem": "∀ {n : ℕ}, Even n → Even (n * n)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ {n : ℕ}, Even n → Even (n * n)",
     "∀ {n : ℕ}, Even n → Even (n * n)",
     "∀ {n : ℕ}, Even n → Even (n * n)",
     "∀ {n : ℕ}, Even n → Even (n * n)",
     "∀ {n : ℕ}, Even n → Even (n * n)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℤ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)",
    "∀ {n : ℕ}, Even n → Even (n * n)"]},
  {"theorem":
   "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
     "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
     "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
     "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
     "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
    "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
    "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
    "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R",
    "∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
    "∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K",
    "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R"]},
  {"theorem": "∀ {α : Type u} [inst : One α], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups":
   [["∀ {α : Type u} [inst : One α], id 1 = 1",
     "∀ {α : Type u} [inst : One α], id 1 = 1",
     "∀ {α : Type u} [inst : One α], id 1 = 1",
     "∀ {α : Type u} [inst : One α], id 1 = 1",
     "∀ {α : Type u} [inst : One α], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = (1 : α)",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1",
    "∀ {α : Type u} [inst : One α], id (1 : α) = 1"]},
  {"theorem": "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u} (x : α), Function.IsFixedPt id x"],
    ["∀ {α : Type u} (x : α), id x = x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x",
    "∀ {α : Type u} (x : α), id x = x",
    "∀ {α : Type u} (x : α), id x = x",
    "∀ {α : Type u} (x : α), id x = x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x",
    "∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x"]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), Metric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] [inh : Inhabited α], Metric.diam {default} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), Metric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), Metric.diam ({x} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] [inh : Inhabited α], Metric.diam ({inh.default} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam ({x} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), Metric.diam ({x} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam ({x} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : Subsingleton α], Metric.diam (Set.univ : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam ({x} : Set α) = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam ({x} : Set α) = 0"]},
  {"theorem": "∀ {G : Type u} [inst : Group G], Nonempty G",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G",
     "∀ {G : Type u} [inst : Group G], Nonempty G"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G",
    "∀ {G : Type u} [inst : Group G], Nonempty G"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace ↑(connectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace ↑(connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace ↑(connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace ↑(connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace ↑(connectedComponent x)"],
    ["∀ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace (connectedComponent x)",
    "∀ {X : Type u} [inst : TopologicalSpace X] (x : X), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), ConnectedSpace (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
    "∀ {α : Type u} [inst : TopologicalSpace α] {x : α}, IsConnected (connectedComponent x)"]},
  {"theorem": "∃ M, M.IsMaximal",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["∃ M, M.IsMaximal",
     "∃ M, M.IsMaximal",
     "∃ M, M.IsMaximal",
     "∃ M, M.IsMaximal",
     "∃ M, M.IsMaximal"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ M : Ideal ℤ, Ideal.IsMaximal M",
    "∃ I : Ideal ℤ, Ideal.IsMaximal I",
    "∃ (M : Ideal ℤ), Ideal.IsMaximal M"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"],
    ["sorryAx (Sort ?u.2057536) true"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "example : PythagoreanTriple 3 4 5 :=\nby norm_num [PythagoreanTriple]",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "PythagoreanTriple 3 4 5",
    "example : PythagoreanTriple 3 4 5 :=\nby norm_num [PythagoreanTriple]",
    "PythagoreanTriple 3 4 5"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (↑∅) K V → Subsingleton V"],
    ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis Empty K V → Subsingleton V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis Empty K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V",
    "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis (∅ : Set V) K V → Subsingleton V"]}],
 "elaborated": 38}