{"theorem":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","text":"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.","result":true,"gps":[["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p "]}
{"theorem":"∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"gps":[["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 "]}
{"theorem":"Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}","text":"There are infinitely many pairs of primes that differ exactly by `2`.","result":true,"gps":[["Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)} "]}
{"theorem":"(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","text":"Every finite division ring is a field.","result":true,"gps":[["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]}
{"theorem":"∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)","text":"If each of two types can be mapped injectively into the other, then there is a bijection between them.","result":true,"gps":[["∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) "]}
{"theorem":"∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) →\n    ∃ x, ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v","text":"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.","result":true,"gps":[["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) →\n    ∃ x, ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (x : V), SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) →\n  ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v "]}
{"theorem":"∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m","text":"Every non-empty poset in which every chain has an upper bound contains a maximal element.","result":true,"gps":[["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {r : α → α → Prop} [inst : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ x ∈ t → f x = 1","text":"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ x ∈ t → f x = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x, x ∈ s → f x = 0 ∧ x ∈ t → f x = 1 "]}
{"theorem":"∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x","text":"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.","result":true,"gps":[["∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x, Function.IsPeriodicPt f n x "]}
{"theorem":"∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","text":"The complement of the union of two sets is the intersection of their complements.","result":true,"gps":[["∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ "]}
{"theorem":"∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3","text":"The sum of the cubes of two positive integers is never equal to the cube of a third integer.","result":true,"gps":[["∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y","text":"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y "]}
{"theorem":"∀ {n : ℕ}, Even (n * (n + 1))","text":"The product of two consecutive natural numbers is even.","result":true,"gps":[["∀ {n : ℕ}, Even (n * (n + 1))"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, Even (n * (n + 1)) "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","text":"Every index 2 subgroup of a group is normal.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G","text":"Every free group is torsion free.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] [hF : IsFreeGroup G], Monoid.IsTorsionFree G "]}
{"theorem":"∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","text":"Every natural number greater than `1` is divisible by a prime number.","result":true,"gps":[["∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","text":"A finite torsion-free group is trivial","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G "]}
{"theorem":"(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","text":"Every finite division ring is a field.","result":true,"gps":[["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","text":"Every finite topological space is compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α "]}
{"theorem":"∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f","text":"Every surjective homomorphism from a finitely generated free group to itself is injective.","result":true,"gps":[["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f "]}
{"theorem":"∀ (n : ℕ), n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","text":"Every positive even integer can be written as the sum of two primes.","result":true,"gps":[["∀ (n : ℕ), n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q "]}
{"theorem":"∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","text":"The square root of an irrational number is irrational.","result":true,"gps":[["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) "]}
{"theorem":"∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0","text":"If the square of a number is even, the number itself is even.","result":true,"gps":[["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 "]}
{"theorem":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","text":"In a finite commutative ring, all prime ideals are maximal.","result":true,"gps":[["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s","text":"If every point of a subset of a topological space is contained in some open set, the subset itself is open.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s "]}
{"theorem":"∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (x : α), x ≠ 1 → ¬IsOfFinOrder x","text":"Every non-identity element of a free group is of infinite order.","result":true,"gps":[["∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (x : α), x ≠ 1 → ¬IsOfFinOrder x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (x : α), x ≠ 1 → ¬IsOfFinOrder x "]}
{"theorem":"∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y","text":"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.","result":true,"gps":[["∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y "]}
{"theorem":"(K : Type u) → [inst : Field K] → Ring K","text":"Every field is a ring.","result":true,"gps":[["(K : Type u) → [inst : Field K] → Ring K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u) [inst : Field K], Ring K "]}
{"theorem":"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H","text":"If the direct product of two groups is torsion free then each of the groups is torsion free.","result":true,"gps":[["∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H "]}
