{"theorem":"∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n","text":"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.","result":true,"gps":[["∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n","∀ (n : ℕ) [hp : Fact (Nat.Prime n)], n % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = n","∀ (n : ℕ) [hp : Fact (Nat.Prime n)], n % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = n"],["∀ (n : ℕ), Nat.Prime n → n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n","∀ (p : ℕ), Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"],["∀ (n : ℕ) [hprime : Fact (Prime n)], n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(n : ℕ) [Fact (nat.prime n)] (hn : n % 4 = 1) :\n∃ a b : ℕ, a^2 + b^2 = n ","(n : ℕ) [hp : Fact (Nat.Prime n)] (h : n % 4 = 1) :\n ∃ x y : ℕ, x^2 + y^2 = n ","(n : ℕ) [hprime : Fact (Prime n)] (hmod : n % 4 = 1) :\n  ∃ a b : ℕ, a^2 + b^2 = n ","(n : ℕ) (hp : Nat.Prime (4 * n + 1)) :\n∃ (a b : ℕ), (4 * n + 1) = a^2 + b^2 ","(n : ℕ) [hp : Fact (Nat.Prime n)] (h : n % 4 = 1) :\n  ∃ x y : ℕ, x ^ 2 + y ^ 2 = n ","(n : ℕ) (hn : Nat.Prime n) (h1 : n % 4 = 1) :\n  ∃ a b : ℕ, a^2 + b^2 = n ","prime_sum_of_two_squares (p : ℕ) (hp : Nat.Prime p) (hmod : p % 4 = 1) :\n  ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "]}
{"theorem":"∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"gps":[["∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2","∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2","∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2","∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2"],["∀ (n m : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n * m"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(n m : ℕ) : ∃ a b c d : ℕ, n * m = a^2 + b^2 + c^2 + d^2 ","(n m : ℕ) :\n ∃ a b c d p q r s : ℤ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n ∧ p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 = m ∧ (a * p + b * q + c * r + d * s) ^ 2 + (a * q - b * p - c * s + d * r) ^ 2 + (a * r + b * s - c * p - d * q) ^ 2 + (a * s - b * r + c * q - d * p) ^ 2 = n * m ","(n m : ℕ) : ∃ a b c d : ℕ, n * m = a^2 + b^2 + c^2 + d^2 ","(n m : ℕ) :\n∃ a b c d : ℕ, a^2 + b^2 + c^2 + d^2 = (n * m) ","(n m : ℕ) :\n ∃ a b c d : ℕ, n * m = a^2 + b^2 + c^2 + d^2 ","(n m : ℕ) :\n∃ a b c d : ℕ, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 "]}
{"theorem":"∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (x y : idem_ring), x * y = y * x","text":"A ring with all elements idempotent is commutative.","result":true,"gps":[["∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (x y : idem_ring), x * y = y * x","∀ (G : Type u_12) [inst : Ring G], (∀ (x : G), x * x = x) → ∀ (x y : G), x * y = y * x","∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (a b : idem_ring), a * b = b * a","∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (a b : idem_ring), a * b = b * a","∀ (R : Type u_12) [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (a b : R), a * b = b * a"],["(idem_ring : Type u_12) → [inst : Ring idem_ring] → (∀ (a : idem_ring), a * a = a) → CommSemiring idem_ring"],["∀ (X : Type u_12) [inst : Semiring X], (∀ (x : X), x * x = x) → ∀ (x y : X), x * y = y * x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(idem_ring : Type*) [Ring idem_ring] (h_idem : ∀ (a : idem_ring), a * a = a) :\n ∀ (x y : idem_ring), x * y = y * x ","(G : Type*) [Ring G] (hG : ∀ x : G, x * x = x) :\n∀ x y : G, x * y = y * x ","(X : Type*) [Semiring X] (h_idem : ∀ x : X, x * x = x) : ∀ x y : X, x * y = y * x ","(idem_ring : Type*) [Ring idem_ring] (idem : ∀ (a : idem_ring), a * a = a) :\n CommSemiring idem_ring ","(idem_ring : Type*) [Ring idem_ring] (idem : ∀ a : idem_ring, a * a = a) :\n  ∀ a b : idem_ring, a * b = b * a ","(idem_ring : Type*) [Ring idem_ring] (idem : ∀ a : idem_ring, a * a = a) :\n  ∀ a b : idem_ring, a * b = b * a ","(R : Type*) [Ring R] (h_idem : ∀ a : R, a * a = a) : ∀ a b : R, a * b = b * a "]}
{"theorem":"∃ P, ∀ (n : ℕ), Prime (P n) ∧ Prime (P n + 2)","text":"There are infinitely many pairs of primes that differ exactly by `2`.","result":true,"gps":[["∃ P, ∀ (n : ℕ), Prime (P n) ∧ Prime (P n + 2)","∃ f, ∀ (n : ℕ), Prime (f n) ∧ Prime (f n + 2)","∃ f, ∀ (k : ℕ), Prime (f k) ∧ Prime (f k + 2)"],["∃ f, (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ ∀ (m n : ℕ), m ≠ n → f m ≠ f n"],["∃ p, ∀ (k : ℕ), k ≥ p → ∃ n, Prime (n + k) ∧ Prime (n + k + 2)"],["∃ f, Function.Injective f ∧ ∀ (n : ℕ), (∀ (k : ℕ), k < n → Nat.Prime (f k)) ∧ Nat.Prime (f n + 2)"],["∃ f, Function.Injective f ∧ ∀ (n : ℕ), Prime (f n).fst ∧ Prime (f n).snd ∧ (f n).snd - (f n).fst = 2"],["∃ f, StrictMono f ∧ ∀ (n : ℕ), Nat.Prime (f n) ∧ Nat.Prime (f n + 2)"],["∃ f, (∀ (n : ℕ), Prime (f n) ∧ Prime (f n + 2)) ∧ ∀ (m n : ℕ), m ≠ n → f m ≠ f n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["infinitely_many_twin_primes : ∃ p : ℕ, ∀ k ≥ p, ∃ (n : ℕ), Prime (n + k) ∧ Prime (n + k + 2) ","infinitely_many_twin_primes : ∃ P : ℕ → ℕ, ∀ n, Prime (P n) ∧ Prime (P n + 2) ","infinitely_many_twin_primes : ∃ f : ℕ → ℕ, ∀ n : ℕ, Prime (f n) ∧ Prime (f n + 2) ","infinitely_many_twin_primes : ∃ f : ℕ → ℕ, Function.Injective f ∧ ∀ n, (∀ k < n, Nat.Prime (f k)) ∧ Nat.Prime (f n + 2) ","infinitely_many_twin_primes : ∃ f : ℕ → ℕ, ∀ k, Prime (f k) ∧ Prime (f k + 2) ","infinitely_many_twin_primes : ∃f : ℕ → ℕ × ℕ, Function.Injective f ∧ ∀ n, (Prime (f n).fst) ∧ (Prime (f n).snd) ∧ (f n).snd - (f n).fst = 2 ","infinitely_many_twin_primes : ∃ f : ℕ → ℕ, StrictMono f ∧ ∀ n, Nat.Prime (f n) ∧ Nat.Prime (f n + 2) ",": ∃ f : ℕ → ℕ, (∀ n, Prime (f n) ∧ Prime (f n + 2)) ∧ ∀ m n, m ≠ n → f m ≠ f n ","infinitely_many_twin_primes : ∃ (f : ℕ → ℕ × ℕ), (∀ n, Nat.Prime (f n).1 ∧ Nat.Prime (f n).2 ∧ (f n).2 - (f n).1 = 2) ∧ ∀ m n, m ≠ n → f m ≠ f n "]}
{"theorem":"(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G","text":"Every finite division ring is a field.","result":true,"gps":[["(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G","(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G","(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G"],["∀ (G : Type u_12) [inst : DivisionRing G] [inst_1 : Fintype G], IsField G","∀ (M : Type u_12) [inst : DivisionRing M] [inst_1 : Fintype M], IsField M"],["(finite_div_ring : Type u_12) →\n  [inst : DivisionRing finite_div_ring] → [inst : Fintype finite_div_ring] → Field finite_div_ring"],["(finite_division_ring : Type u_12) →\n  [inst : DivisionRing finite_division_ring] → [inst : Fintype finite_division_ring] → Field finite_division_ring"],["(finite_division_ring : Type u_12) →\n  [inst : Fintype finite_division_ring] → [inst : DivisionRing finite_division_ring] → Field finite_division_ring"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [DivisionRing G] [Fintype G] : IsField G ","(finite_division_ring : Type*) [Fintype finite_division_ring] [DivisionRing finite_division_ring] :\n Field finite_division_ring ","(finite_division_ring : Type*) [DivisionRing finite_division_ring] [Fintype finite_division_ring] :\n Field finite_division_ring ","(M : Type*) [DivisionRing M] [Fintype M] : IsField M ","(G : Type*) [DivisionRing G] [Fintype G] : Field G ","(finite_div_ring : Type*) [DivisionRing finite_div_ring] [Fintype finite_div_ring] :\n Field finite_div_ring ","(G : Type*) [DivisionRing G] [Fintype G] : Field G ","(G : Type*) [DivisionRing G] [Fintype G] : Field G "]}
{"theorem":"∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True","text":"If each of two types can be mapped injectively into the other, then there is a bijection between them.","result":true,"gps":[["∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True","∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True"],["∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X),\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h","∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X),\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h"],["∀ (X : Type u_12) (Y : Type u_13), Nonempty (X ↪ Y) → Nonempty (Y ↪ X) → Nonempty (X ≃ Y)"],["∀ (X Y : Type) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h"],["∀ (X Y : Type) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X Y : Type*) (f : X → Y) (g : Y → X) (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ (h : X → Y), Function.Bijective h ","(X Y : Type*) (f : X → Y) (g : Y → X)\n (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ (h : X ≃ Y), True ","(X Y : Type) (f : X → Y) (g : Y → X) (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ h : X → Y, Function.Bijective h ","(X Y : Type*) (f : X → Y) (g : Y → X) (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ h : X ≃ Y, True ","(X Y : Type*) (f : X → Y) (g : Y → X)\n(hf : Function.Injective f) (hg : Function.Injective g) :\n∃ (h : X → Y), Function.Bijective h ","(X Y : Type) (f : X → Y) (g : Y → X)\n  (hf : Function.Injective f) (hg : Function.Injective g) :\n  ∃ (h : X ≃ Y), True ","(X Y : Type*) (h1 : nonempty (X ↪ Y)) (h2 : nonempty (Y ↪ X)) : nonempty (X ≃ Y) "]}
{"theorem":"∀ (Vertices : Type u_12) [inst : Fintype Vertices] [inst : DecidableEq Vertices] (Edges : Vertices → Vertices → Prop),\n  (∀ (x y : Vertices), x ≠ y → ∃! z, Edges x z ∧ Edges y z) → ∃ v, ∀ (w : Vertices), w ≠ v → Edges v w","text":"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.","result":true,"gps":[["∀ (Vertices : Type u_12) [inst : Fintype Vertices] [inst : DecidableEq Vertices] (Edges : Vertices → Vertices → Prop),\n  (∀ (x y : Vertices), x ≠ y → ∃! z, Edges x z ∧ Edges y z) → ∃ v, ∀ (w : Vertices), w ≠ v → Edges v w"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(Vertices : Type*) [Fintype Vertices] [DecidableEq Vertices] (Edges : Vertices → Vertices → Prop)\n  (h_common_neighbor : ∀ x y : Vertices, x ≠ y → ∃! z, Edges x z ∧ Edges y z) :\n∃ v : Vertices, ∀ w : Vertices, w ≠ v → Edges v w "]}
{"theorem":"∀ (partitions_with_odd_parts partitions_with_distinct_parts : ℕ → ℕ) (n : ℕ),\n  partitions_with_odd_parts n = partitions_with_distinct_parts n","text":"The number of partitions with odd parts is equal to the number of partitions with distinct parts.","result":true,"gps":[["∀ (partitions_with_odd_parts partitions_with_distinct_parts : ℕ → ℕ) (n : ℕ),\n  partitions_with_odd_parts n = partitions_with_distinct_parts n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(partitions_with_odd_parts : ℕ → ℕ) (partitions_with_distinct_parts : ℕ → ℕ) (n : ℕ) :\n partitions_with_odd_parts n = partitions_with_distinct_parts n "]}
{"theorem":"∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],["∀ (X Y Z : Type) [inst : UniformSpace X] [inst_1 : UniformSpace Y] [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X : Type*) (Y : Type*) (Z : Type*)\n[UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) "]}
{"theorem":"∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],["∀ (X Y Z : Type) [inst : UniformSpace X] [inst_1 : UniformSpace Y] [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X : Type*) (Y : Type*) (Z : Type*)\n[UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ","(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) "]}
{"theorem":"∀ (X : Type u_12) [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (A B : Set X),\n      IsClosed A →\n        IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ (∀ (a : X), a ∈ A → f a = 0) ∧ ∀ (b : X), b ∈ B → f b = 1","text":"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.","result":true,"gps":[["∀ (X : Type u_12) [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (A B : Set X),\n      IsClosed A →\n        IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ (∀ (a : X), a ∈ A → f a = 0) ∧ ∀ (b : X), b ∈ B → f b = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X : Type*) [TopologicalSpace X] :\n  NormalSpace X ↔ ∀ A B : Set X, IsClosed A → IsClosed B → Disjoint A B → ∃ f : X → ℝ, Continuous f ∧ (∀ a ∈ A, f a = 0) ∧ (∀ b ∈ B, f b = 1) "]}
{"theorem":"∀ (unit_interval : Type u_12) [inst : LinearOrderedField unit_interval] [inst_1 : TopologicalSpace unit_interval]\n  [inst_2 : OrderTopology unit_interval] [inst_3 : TopologicalRing unit_interval] (f : unit_interval → unit_interval),\n  Continuous f → ∀ (x₀ : unit_interval), f (f (f x₀)) = x₀ → ∀ (n : ℕ), ∃ x, (f ^ n) x = x","text":"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.","result":true,"gps":[["∀ (unit_interval : Type u_12) [inst : LinearOrderedField unit_interval] [inst_1 : TopologicalSpace unit_interval]\n  [inst_2 : OrderTopology unit_interval] [inst_3 : TopologicalRing unit_interval] (f : unit_interval → unit_interval),\n  Continuous f → ∀ (x₀ : unit_interval), f (f (f x₀)) = x₀ → ∀ (n : ℕ), ∃ x, (f ^ n) x = x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(unit_interval : Type*) [LinearOrderedField unit_interval] [TopologicalSpace unit_interval] [OrderTopology unit_interval] [TopologicalRing unit_interval]\n(f : unit_interval → unit_interval) (hf : Continuous f) (x₀ : unit_interval) (hx₀ : f (f (f x₀)) = x₀) :\n∀ n : ℕ, ∃ x : unit_interval, (f ^ n) x = x ","(X : Type*) [LinearOrderedField X] [TopologicalSpace X] [OrderTopology X]\n(f : X → X) (hf : Continuous f) (h0 : 0 ≤ f 0) (h1 : f 1 ≤ 1)\n(h_period : ∃ x, 0 < x ∧ x < 1 ∧ f (f (f x)) = x) :\n∀ n : ℕ, ∃ x, 0 < x ∧ x < 1 ∧ (f^[n] x = x) "]}
{"theorem":"∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ","text":"The complement of the union of two sets is the intersection of their complements.","result":true,"gps":[["∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ","∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ","∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ","∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ","∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ","∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ","(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ","(X : Type*) (A B : Set X) :\n  HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ","(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ","(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ","(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B "]}
{"theorem":"∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3","text":"The sum of the cubes of two positive integers is never equal to the cube of a third integer.","result":true,"gps":[["∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3","∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3","∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3"],["∀ (x y z : ℕ), x ^ 3 + y ^ 3 ≠ z ^ 3"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(n m k : ℕ) (hn : n > 0) (hm : m > 0) :\n  n ^ 3 + m ^ 3 ≠ k ^ 3 ","no_sum_of_cubes_eq_cube : ∀ x y z : ℕ, x ^ 3 + y ^ 3 ≠ z ^ 3 ","(n m k : ℕ) (hn : n > 0) (hm : m > 0) : n ^ 3 + m ^ 3 ≠ k ^ 3 ","(n m k : ℕ) (hn : n > 0) (hm : m > 0) : n^3 + m^3 ≠ k^3 "]}
{"theorem":"∀ (G : Type u_12) [inst : Group G], (∀ (g : G), g * g = 1) → ∀ (x y : G), x * y = y * x","text":"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.","result":true,"gps":[["∀ (G : Type u_12) [inst : Group G], (∀ (g : G), g * g = 1) → ∀ (x y : G), x * y = y * x","∀ (G : Type u_12) [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), x * y = y * x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [Group G] (hG : ∀ x : G, x^2 = 1) : ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (hG : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (h : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (hG : ∀ g : G, g * g = 1) : ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (hG : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (hG : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (hG : ∀ (x : G), x^2 = 1) :\n ∀ (x y : G), x * y = y * x ","(G : Type*) [Group G] (h : ∀ g : G, g^2 = 1) :\n ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (hG : ∀ x : G, x * x = 1) : ∀ x y : G, x * y = y * x ","(G : Type*) [Group G] (h2 : ∀ x : G, x ^ 2 = 1) : ∀ x y : G, x * y = y * x "]}
{"theorem":"∀ (n : ℕ), n * (n + 1) % 2 = 0","text":"The product of two consecutive natural numbers is even.","result":true,"gps":[["∀ (n : ℕ), n * (n + 1) % 2 = 0","∀ (n : ℕ), n * (n + 1) % 2 = 0","∀ (n : ℕ), n * (n + 1) % 2 = 0","∀ (n : ℕ), n * (n + 1) % 2 = 0","∀ (n : ℕ), n * (n + 1) % 2 = 0","∀ (n : ℕ), n * (n + 1) % 2 = 0"],["∀ (m n : ℕ), n = m + 1 → Even (m * n)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(n : ℕ) : (n * (n + 1)) % 2 = 0 ","(m n : ℕ) (h : n = m + 1) : Even (m * n) ","(n : ℕ) :\neven (n * (n + 1)) ","(n : ℕ) : even (n * (n + 1)) ","(n : ℕ) : (n * (n + 1)) % 2 = 0 ","(n : ℕ) : (n * (n + 1)) % 2 = 0 ","(n : ℕ) : (n * (n + 1)) % 2 = 0 ","(n : ℕ) :\n  (n * (n + 1)) % 2 = 0 ","(n : ℕ) : Even ((n * (n + 1))) ","(n : ℕ) : (n * (n + 1)) % 2 = 0 "]}
{"theorem":"∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∃ n, n ≠ 0 ∧ x ^ n ≠ 1","text":"Every free group is torsion free.","result":true,"gps":[["∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∃ n, n ≠ 0 ∧ x ^ n ≠ 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [Group G] [IsFreeGroup G] : ∀ x : G, x ≠ 1 → ∃ n : ℤ, n ≠ 0 ∧ x ^ n ≠ 1 "]}
{"theorem":"∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","text":"Every natural number greater than `1` is divisible by a prime number.","result":true,"gps":[["∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n"],["∀ (n : ℕ), n > 1 → ∃ p, Prime p ∧ p ∣ n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(n : ℕ) (hn : n > 1) : ∃ p, Prime p ∧ p ∣ n ","(n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ","prime_divisor_of_gt_one (n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ","(n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ","(n : ℕ) (hn : n > 1) :\n  ∃ p : ℕ, Nat.Prime p ∧ p ∣ n ","(n : ℕ) (hn : n > 1) : ∃ p : ℕ, Prime p ∧ p ∣ n ","(n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ","(n : ℕ) (hn : n > 1) :\n∃ p : ℕ, Nat.Prime p ∧ p ∣ n ","prime_divisor_of_nat_gt_one (n : ℕ) (hn : n > 1) : ∃ p, Prime p ∧ p ∣ n "]}
{"theorem":"(G : Type u_12) →\n  [inst : Group G] →\n    [inst_1 : Fintype G] → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n = 1) → (∀ (g : G) (n : ℕ), g ^ n = 1 → g = 1) → G ≃ Unit","text":"A finite torsion-free group is trivial","result":true,"gps":[["(G : Type u_12) →\n  [inst : Group G] →\n    [inst_1 : Fintype G] → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n = 1) → (∀ (g : G) (n : ℕ), g ^ n = 1 → g = 1) → G ≃ Unit"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [Group G] [Fintype G] (hf : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) (htf : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → g = 1) :\n  G ≃ Unit "]}
{"theorem":"(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G","text":"Every finite division ring is a field.","result":true,"gps":[["(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G","(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G","(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G"],["∀ (G : Type u_12) [inst : DivisionRing G] [inst_1 : Fintype G], IsField G","∀ (M : Type u_12) [inst : DivisionRing M] [inst_1 : Fintype M], IsField M"],["(finite_div_ring : Type u_12) →\n  [inst : DivisionRing finite_div_ring] → [inst : Fintype finite_div_ring] → Field finite_div_ring"],["(finite_division_ring : Type u_12) →\n  [inst : DivisionRing finite_division_ring] → [inst : Fintype finite_division_ring] → Field finite_division_ring"],["(finite_division_ring : Type u_12) →\n  [inst : Fintype finite_division_ring] → [inst : DivisionRing finite_division_ring] → Field finite_division_ring"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [DivisionRing G] [Fintype G] : IsField G ","(finite_division_ring : Type*) [Fintype finite_division_ring] [DivisionRing finite_division_ring] :\n Field finite_division_ring ","(finite_division_ring : Type*) [DivisionRing finite_division_ring] [Fintype finite_division_ring] :\n Field finite_division_ring ","(M : Type*) [DivisionRing M] [Fintype M] : IsField M ","(G : Type*) [DivisionRing G] [Fintype G] : Field G ","(finite_div_ring : Type*) [DivisionRing finite_div_ring] [Fintype finite_div_ring] :\n Field finite_div_ring ","(G : Type*) [DivisionRing G] [Fintype G] : Field G ","(G : Type*) [DivisionRing G] [Fintype G] : Field G "]}
{"theorem":"∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X","text":"Every finite topological space is compact.","result":true,"gps":[["∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X","∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X","∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X","∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X","∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X","∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ","(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ","(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ","(X : Type*) [TopologicalSpace X] [fintype X] :\nCompactSpace X ","(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ","(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X "]}
{"theorem":"∀ (G : Type u_12) [inst : Group G] [inst_1 : Fintype G] (f : G →* G), Function.Surjective ↑f → Function.Injective ↑f","text":"Every surjective homomorphism from a finitely generated free group to itself is injective.","result":true,"gps":[["∀ (G : Type u_12) [inst : Group G] [inst_1 : Fintype G] (f : G →* G), Function.Surjective ↑f → Function.Injective ↑f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [Group G] [Fintype G] (f : G →* G) (hf : Function.Surjective (⇑f)) : Function.Injective (⇑f) "]}
{"theorem":"∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q","text":"Every positive even integer can be written as the sum of two primes.","result":true,"gps":[["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q","∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q","∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q","∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q","∀ (n : ℕ), 2 ≤ n ∧ n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q"],["∀ (n : ℕ), n > 2 → Even n → ∃ p q, Prime p ∧ Prime q ∧ n = p + q"],["∀ (n : ℕ), 2 ≤ n ∧ Even n → ∃ p q, Prime p ∧ Prime q ∧ n = p + q"],["∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ p q, n = p + q ∧ Prime p ∧ Prime q"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["every_even_sum_of_two_primes :\n  ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ","goldbach_conjecture (n : ℕ) (hn : 2 ≤ n ∧ Even n) : ∃ p q : ℕ, prime p ∧ prime q ∧ n = p + q ","goldbach_conjecture :\n  ∀ n : ℕ, n > 2 → n % 2 = 0 → ∃ (p q : ℕ), n = p + q ∧ Prime p ∧ Prime q ","goldbach_conjecture : ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ","goldbach_conjecture : ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, prime p ∧ prime q ∧ n = p + q ","Goldbach_conjecture : ∀ n : ℕ, n > 2 → Even n → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ","goldbach_conjecture : ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ","goldbach_conjecture (n : ℕ) (hn : 2 ≤ n ∧ n % 2 = 0) : ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q "]}
{"theorem":"∀ (n : ℕ), n ^ 2 % 2 = 0 → n % 2 = 0","text":"If the square of a number is even, the number itself is even.","result":true,"gps":[["∀ (n : ℕ), n ^ 2 % 2 = 0 → n % 2 = 0","∀ (n : ℕ), n ^ 2 % 2 = 0 → n % 2 = 0","∀ (sq_even : ℕ), sq_even ^ 2 % 2 = 0 → sq_even % 2 = 0","∀ (square_even : ℕ), square_even ^ 2 % 2 = 0 → square_even % 2 = 0","∀ (sq_even : ℕ), sq_even ^ 2 % 2 = 0 → sq_even % 2 = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(n : ℕ) (hsq : n^2 % 2 = 0) : n % 2 = 0 ","(n : ℕ) (h : n ^ 2 % 2 = 0) : n % 2 = 0 ","(sq_even : ℕ) (h : sq_even ^ 2 % 2 = 0) :\nsq_even % 2 = 0 ","(square_even : ℕ) (h : square_even ^ 2 % 2 = 0) : square_even % 2 = 0 ","(sq_even : ℕ) (h : sq_even ^ 2 % 2 = 0) : sq_even % 2 = 0 ","(sq_even : ℕ → Prop) (x : ℕ) (h : sq_even (x^2)) : sq_even x ","(sq_even : ℕ → Prop) (a : ℕ) (h : sq_even (a^2)) : sq_even a "]}
{"theorem":"∀ (G : Type u_12) [inst : CommRing G] [inst_1 : Fintype G] (P : Ideal G) [hP : Ideal.IsPrime P], Ideal.IsMaximal P","text":"In a finite commutative ring, all prime ideals are maximal.","result":true,"gps":[["∀ (G : Type u_12) [inst : CommRing G] [inst_1 : Fintype G] (P : Ideal G) [hP : Ideal.IsPrime P], Ideal.IsMaximal P","∀ (finite_ring : Type u_12) [inst : CommRing finite_ring] [inst_1 : Fintype finite_ring] (P : Ideal finite_ring)\n  [hP : Ideal.IsPrime P], Ideal.IsMaximal P","∀ (G : Type u_12) [inst : CommRing G] [inst_1 : Fintype G] (P : Ideal G), Ideal.IsPrime P → Ideal.IsMaximal P"],["∀ (X : Type) [inst : CommRing X] [inst_1 : Fintype X] (P : Ideal X) [Hp : Ideal.IsPrime P], Ideal.IsMaximal P"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X : Type) [CommRing X] [Fintype X] (P : Ideal X) [Hp : Ideal.IsPrime P] :\nIdeal.IsMaximal P ","(G : Type*) [CommRing G] [Fintype G] (P : Ideal G) [hP : Ideal.IsPrime P] :\n Ideal.IsMaximal P ","(finite_ring : Type*) [CommRing finite_ring] [Fintype finite_ring] (P : Ideal finite_ring) [hP : Ideal.IsPrime P] :\nIdeal.IsMaximal P ","(G : Type*) [CommRing G] [Fintype G] (P : Ideal G) (hP : Ideal.IsPrime P) :\nIdeal.IsMaximal P "]}
{"theorem":"∀ (X : Type u_12) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.fst = p.snd}","text":"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.","result":true,"gps":[["∀ (X : Type u_12) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.fst = p.snd}"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X : Type*) [TopologicalSpace X] :\n T2Space X ↔ IsClosed {p : X × X | p.1 = p.2} "]}
{"theorem":"∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B","text":"If every point of a subset of a topological space is contained in some open set, the subset itself is open.","result":true,"gps":[["∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B","∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B","∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B","∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A"],["∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A","∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A","∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A","∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A","∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):\n IsOpen A ","(X : Type*) [TopologicalSpace X]\n (B : Set X) (hB : ∀ x ∈ B, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ B):\n IsOpen B ","(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U) :\n IsOpen A ","(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):\n IsOpen A ","(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U) :\n IsOpen A ","(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ A):\n IsOpen A ","(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):\n IsOpen A ","(X : Type*) [TopologicalSpace X]\n (B : Set X) (hB : ∀ x ∈ B, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ B):\n IsOpen B ","(X : Type*) [TopologicalSpace X]\n (B : Set X) (hB : ∀ x ∈ B, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ B):\n IsOpen B ","(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ A):\n IsOpen A "]}
{"theorem":"∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","text":"Every non-identity element of a free group is of infinite order.","result":true,"gps":[["∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","∀ (F : Type u_12) [inst : Group F] [inst_1 : IsFreeGroup F] (x : F), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1","∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ","(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ","(F : Type*) [Group F] [IsFreeGroup F] (x : F) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ","(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ","(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ","(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ","(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ","(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 "]}
{"theorem":"∀ (N₀ a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), N ≥ N₀ → ∃ x y, N = a * x + b * y","text":"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.","result":true,"gps":[["∀ (N₀ a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), N ≥ N₀ → ∃ x y, N = a * x + b * y"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(N₀ : ℕ) (a b : ℕ) (h_coprime : Nat.coprime a b) :\n  ∀ N ≥ N₀, ∃ (x y : ℕ), N = a * x + b * y "]}
{"theorem":"(X : Type u_12) → [inst : Field X] → Ring X","text":"Every field is a ring.","result":true,"gps":[["(X : Type u_12) → [inst : Field X] → Ring X"],["((F : Type u_12) → [inst : Field F] → Ring F) → Prop"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(field_to_ring : ∀ (F : Type*) [Field F], Ring F) : Prop ","(X : Type*) [Field X] : Ring X "]}
{"theorem":"(G : Type u_12) → [inst : Ring G] → Group Gˣ","text":"The set of units in a ring forms a group.","result":true,"gps":[["(G : Type u_12) → [inst : Ring G] → Group Gˣ","(G : Type u_12) → [inst : Ring G] → Group Gˣ","(G : Type u_12) → [inst : Ring G] → Group Gˣ","(G : Type u_12) → [inst : Ring G] → Group Gˣ"],["(G : Type u_12) → [inst : Ring G] → Group Gˣ"],["(G : Type u_12) → [inst : Ring G] → Group Gˣ"],["(X : Type u_12) → [inst : Ring X] → Group Xˣ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) [Ring G] :\n Group (Units G) ","(G : Type*) [Ring G] : Group (Units G) ","(X : Type*) [Ring X] :\nGroup (Units X) ","(G : Type*) [Ring G] : Group (Units G) ","(G : Type*) [Ring G] : Group (Units G) ","(G : Type*) [Ring G] :\nGroup (Units G) ","(G : Type*) [Ring G] : Group (Units G) "]}
{"theorem":"∀ (G : Type u_12) (H : Type u_13) [inst : Group G] [inst_1 : Group H],\n  (∀ (g : G × H), g ≠ 1 → ∃ n, g ^ n ≠ 1) → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n ≠ 1) ∧ ∀ (h : H), h ≠ 1 → ∃ n, h ^ n ≠ 1","text":"If the direct product of two groups is torsion free then each of the groups is torsion free.","result":true,"gps":[["∀ (G : Type u_12) (H : Type u_13) [inst : Group G] [inst_1 : Group H],\n  (∀ (g : G × H), g ≠ 1 → ∃ n, g ^ n ≠ 1) → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n ≠ 1) ∧ ∀ (h : H), h ≠ 1 → ∃ n, h ^ n ≠ 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["(G : Type*) (H : Type*) [Group G] [Group H] (gh_torsion_free : ∀ g : G × H, g ≠ 1 → ∃ n : ℤ, g ^ n ≠ 1) :\n(∀ (g : G), g ≠ 1 → ∃ n : ℤ, g ^ n ≠ 1) ∧ (∀ (h : H), h ≠ 1 → ∃ n : ℤ, h ^ n ≠ 1)"]}
