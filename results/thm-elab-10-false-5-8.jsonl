{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsClosed s → s ≠ ⊤ → IsCompact s) → CompactSpace α","text":"If every proper closed subset of a topological space is compact, then the space itself is compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsClosed s → s ≠ ⊤ → IsCompact s) → CompactSpace α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsClosed s → s ≠ ⊤ → IsCompact s) → CompactSpace α "]}
{"theorem":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","text":"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.","result":true,"gps":[["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p "]}
{"theorem":"∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t w, a * b = p ^ 2 + q ^ 2 + t ^ 2 + w ^ 2","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"gps":[["∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q t w, a * b = p ^ 2 + q ^ 2 + t ^ 2 + w ^ 2","∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2","∀ {a b r s x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n    b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2"],["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2","∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2","∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"],["∀ {a b : ℕ}, ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2","∀ (a b : ℕ), ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2"],["∀ {m n : ℕ},\n  ∃ a b c d x y z w,\n    m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ∧ n = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n      m * n =\n        (a * x + b * y + c * z + d * w) ^ 2 + (a * y - b * x - c * w + d * z) ^ 2 +\n            (a * z + b * w - c * x - d * y) ^ 2 +\n          (a * w - b * z + c * y - d * x) ^ 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {m n : ℕ}, ∃ a b c d x y z w,\n  m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ∧ n = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  m * n = (a * x + b * y + c * z + d * w) ^ 2 + (a * y - b * x - c * w + d * z) ^ 2 +\n          (a * z + b * w - c * x - d * y) ^ 2 + (a * w - b * z + c * y - d * x) ^ 2 ","∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ","∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ","∀ {a b : ℕ}, ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ","∀ {a b x y u v r s : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 →\n  ∃ p q t w, a * b = p ^ 2 + q ^ 2 + t ^ 2 + w ^ 2 ","∀ {a b x y u v r s : ℕ}, a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 → b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ","∀ (a b : ℕ), ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ","∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ","forall {a₀ a₁ a₂ a₃ b₀ b₁ b₂ b₃ : ℤ}, ∃ c₀ c₁ c₂ c₃, (a₀ ^ 2 + a₁ ^ 2 + a₂ ^ 2 + a₃ ^ 2) * (b₀ ^ 2 + b₁ ^ 2 + b₂ ^ 2 + b₃ ^ 2) = c₀ ^ 2 + c₁ ^ 2 + c₂ ^ 2 + c₃ ^ 2 ","∀ {a b r s x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + r ^ 2 + s ^ 2 →\n  b = u ^ 2 + v ^ 2 + r ^ 2 + s ^ 2 →\n  ∃ w x y z, a * b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 "]}
{"theorem":"∀ {R : Type u_1} [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (x y : R), x * y = y * x","text":"A ring with all elements idempotent is commutative.","result":true,"gps":[["∀ {R : Type u_1} [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (x y : R), x * y = y * x"],["∀ {α : Type u_1} [self : BooleanRing α] (x y : α), x * y = y * x"],["∀ {α : Type u_1} [self : Mul α] [inst : Add α], (∀ (a : α), a * a = a) → ∀ (x y : α), x * y = y * x"],["∀ {R : Type u_1} [inst : MulOneClass R] [inst_1 : HasDistribNeg R] [inst_2 : Add R] [inst_3 : AddCommMonoid R],\n  (∀ (x : R), x * x = x) → ∀ (x y : R), x * y = y * x"],["∀ {R : Type u_1} [self : Semiring R], (∀ (x : R), x * x = x) → ∀ (x y : R), x * y = y * x"],["∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [inst_2 : One R] [inst_3 : Zero R],\n  (∀ (a : R), a * a = a) → ∀ (a b : R), a * b = b * a"],["∀ {α : Type u_1} [self : MulOneClass α] [inst_1 : AddCommGroup α], (∀ (a : α), a * a = a) → ∀ (x y : α), x * y = y * x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} [self : BooleanRing α], ∀ (x y : α), x * y = y * x ","∀ {α : Type u_1} [self : Mul α] [inst : Add α] (h : ∀ (a : α), a * a = a), ∀ (x y : α), x * y = y * x ","∀ {R : Type u_1} [inst : MulOneClass R] [inst_1 : HasDistribNeg R] [inst_2 : Add R] [inst_3 : AddCommMonoid R],\n  (∀ (x : R), x * x = x) → (∀ (x y : R), x * y = y * x) ","∀ {R : Type u_1} [self : Semiring R], (∀ (x : R), x * x = x) → ∀ (x y : R), x * y = y * x ","∀ {R : Type u_1} [inst : Mul R] [inst_1 : Add R] [inst_2 : One R] [inst_3 : Zero R],\n  (∀ (a : R), a * a = a) → ∀ (a b : R), a * b = b * a ","∀ {α : Type u_1} [self : MulOneClass α] [inst_1 : AddCommGroup α] (h : ∀ (a : α), a * a = a), ∀ (x y : α), x * y = y * x ","∀ {R : Type u_1} [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (x y : R), x * y = y * x "]}
{"theorem":"Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}","text":"There are infinitely many pairs of primes that differ exactly by `2`.","result":true,"gps":[["Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}","Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}","Set.Infinite {p | Nat.Prime p ∧ ∃ q, Nat.Prime q ∧ p + 2 = q}","Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}","Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}","Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)}"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)} ","Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)} ","Set.Infinite {p | Nat.Prime p ∧ ∃ q, Nat.Prime q ∧ p + 2 = q} ","Set.Infinite {p : ℕ | Nat.Prime p ∧ Nat.Prime (p + 2)} ","Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)} ","Set.Infinite {p | Nat.Prime p ∧ Nat.Prime (p + 2)} "]}
{"theorem":"{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","text":"Every finite division ring is a field.","result":true,"gps":[["{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["{K : Type u} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Finite K] → Field K"],["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Finite K], Field K ","∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)","text":"If each of two types can be mapped injectively into the other, then there is a bijection between them.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)","∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)","∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → Nonempty (α ≃ β)"],["∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Nonempty (α ≃ β)","∀ {α : Sort u_1} {β : Sort u_2} (f₁ : α → β) (f₂ : β → α),\n  Function.Injective f₁ → Function.Injective f₂ → Nonempty (α ≃ β)"],["∀ {α β : Type u}, Nonempty (α ↪ β) → Nonempty (β ↪ α) → Nonempty (α ≃ β)"],["∀ {α : Sort u} {β : Sort v}, (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → Nonempty (α ≃ β)"],["∀ {α : Sort u_1} {β : Sort u_2},\n  (Nonempty (α → β) ∧ ∀ (f : α → β), Function.Injective f) →\n    (Nonempty (β → α) ∧ ∀ (f : β → α), Function.Injective f) → Nonempty (α ≃ β)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Sort u_1} {β : Sort u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ","∀ {α β : Type u} (h₁ : Nonempty (α ↪ β)) (h₂ : Nonempty (β ↪ α)), Nonempty (α ≃ β) ","∀ {α : Type u_1} {β : Type u_2},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → Nonempty (α ≃ β) ","∀ {α : Type u_1} {β : Type u_2} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Nonempty (α ≃ β) ","∀ {α : Type u_1} {β : Type u_2} {e₁ : α → β} {e₂ : β → α},\n  Function.Injective e₁ → Function.Injective e₂ → Nonempty (α ≃ β) ","∀ {α : Sort u_1} {β : Sort u_2},\n  (Nonempty (α → β) ∧ (∀ (f : α → β), Function.Injective f)) →\n  (Nonempty (β → α) ∧ (∀ (f : β → α), Function.Injective f)) →\n  Nonempty (Equiv α β) ","∀ {α : Sort u_1} {β : Sort u_2} (f₁ : α → β) (f₂ : β → α), Function.Injective f₁ → Function.Injective f₂ → Nonempty (α ≃ β) ","∀ {α : Sort u} {β : Sort v},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) →\n  Nonempty (α ≃ β) "]}
{"theorem":"∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w","text":"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.","result":true,"gps":[["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"],["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! x, SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) →\n    ∃ x, ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v"],["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ x, ∀ (y : V), x ≠ y → SimpleGraph.Adj G x y"],["∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n    ∃ v, ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → SimpleGraph.commonNeighbors G v w = 1) → ∃ v, SimpleGraph.degree G v = Fintype.card V - 1 ","∀ {V : Type} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! u, SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) → ∃ x, ∀ y, x ≠ y → SimpleGraph.Adj G x y ","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (u : V), SimpleGraph.Adj G v u ∧ SimpleGraph.Adj G w u) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w ","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (x : V), SimpleGraph.Adj G x v ∧ SimpleGraph.Adj G x w) → ∃ (x : V), ∀ (v : V), v ≠ x → SimpleGraph.Adj G x v ","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (x : V), SimpleGraph.Adj G v x ∧ SimpleGraph.Adj G w x) →\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w "]}
{"theorem":"∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m","text":"Every non-empty poset in which every chain has an upper bound contains a maximal element.","result":true,"gps":[["∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m","∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m"],["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m","∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m"],["∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) → ∃ m, ∀ (a : α), r m a → r a m"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → ∃ m, ∀ (a : α), r m a → r a m ","∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ","∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α] [inst_1 : Nonempty α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ","∀ {α : Type u_1} {r : α → α → Prop} [inst : PartialOrder α],\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    ∃ m, ∀ (a : α), r m a → r a m ","∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → Set.Nonempty c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → (∃ m, ∀ (a : α), r m a → r a m) "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {α : Type u_1} {β : Type u_2} {γ : Type u_3}\n  [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {α : Type u_1} {β : Type u_2} {γ : Type u_3}\n  [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ","∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ ∀ (x : α), x ∈ t → f x = 1","text":"A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔\n    ∀ (s t : Set α),\n      IsClosed s →\n        IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ ∀ (x : α), x ∈ t → f x = 1"],["∀ {X : Type u_1} [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (A B : Set X),\n      IsClosed A →\n        IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ (∀ (x : X), x ∈ A → f x = 0) ∧ ∀ (x : X), x ∈ B → f x = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {X : Type u_1} [inst : TopologicalSpace X],\n  NormalSpace X ↔ ∀ (A B : Set X), IsClosed A → IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ f A ⊆ ⊥ ∧ f B ⊇ ⊤ ","∀ {α : Type u_1} [inst : TopologicalSpace α], NormalSpace α ↔\n  ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, Continuous f ∧ ∀ x, 0 ≤ f x ∧ f x ≤ 1 ∧ (x ∈ s → f x = 0) ∧ (x ∈ t → f x = 1) ","∀ {X : Type u_1} [inst : TopologicalSpace X], NormalSpace X ↔\n  ∀ (A B : Set X), IsClosed A → IsClosed B → Disjoint A B →\n    ∃ f : X → ℝ, Continuous f ∧ (∀ (x : X), x ∈ A → f x = 0) ∧ (∀ (x : X), x ∈ B → f x = 1) ","∀ {α : Type u} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ (f : α → ℝ), Continuous f ∧ ∀ (x : α), x ∈ s → f x = 0 ∧ ∀ (x : α), x ∈ t → f x = 1 ","∀ {α : Type u_1} [inst : TopologicalSpace α],\n  NormalSpace α ↔ ∀ (s t : Set α), IsClosed s → IsClosed t → Disjoint s t → ∃ f, ContinuousOn f s ∧ ContinuousOn f t ∧ ∀ x, x ∈ s → f x = 0 ∧ ∀ y, y ∈ t → f y = 1 "]}
{"theorem":"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y","text":"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.","result":true,"gps":[["∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y","∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y"],["∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : FloorRing α], (∃ x, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x"],["∀ {α : Type u_1} (f : α → α) [inst : LinearOrder α] [inst_1 : Nonempty α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderTopology α], (∃ x, Function.IsPeriodicPt f 3 x) → ∀ (n : ℕ), ∃ x, Function.IsPeriodicPt f n x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {f : α → α} {x : α},\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y ","∀ {α : Type u_1} (f : α → α) [inst : LinearOrder α] [inst_1 : Nonempty α]\n  [inst_2 : TopologicalSpace α] [inst_3 : OrderTopology α],\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x, Function.IsPeriodicPt f n x ","∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α] [inst_2 : TopologicalAddGroup α] [inst_3 : Archimedean α]\n  (f : α → α) {x : α},\n  f x ∈ Set.Icc 0 1 →\n  Function.IsPeriodicPt f 3 x →\n  ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y ∧ y ∈ Set.Icc 0 1 ","∀ {α : Type u_1} (f : α → α) [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : FloorRing α],\n  (∃ x, Function.IsPeriodicPt f 3 x) → ∀ n, ∃ x, Function.IsPeriodicPt f n x ","∀ {α : Type u_1} {f : α → α} {x : α},\n  Function.IsPeriodicPt f 3 x → ∀ (n : ℕ), 0 < n → ∃ y, Function.IsPeriodicPt f n y "]}
{"theorem":"{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20560571, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] →\n      {A B : C} → CategoryTheory.Limits.IsTerminal A → CategoryTheory.Limits.IsTerminal B → Unique (A ≅ B)","text":"A terminal object in a category is unique up to unique isomorphism.","result":true,"gps":[["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20560571, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] →\n      {A B : C} → CategoryTheory.Limits.IsTerminal A → CategoryTheory.Limits.IsTerminal B → Unique (A ≅ B)"],["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20552429, u₁} C] →\n    CategoryTheory.Limits.HasTerminal C →\n      (P Q : C) → CategoryTheory.Limits.IsTerminal P → CategoryTheory.Limits.IsTerminal Q → (P ≅ Q)"],["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20554472, u₁} C] →\n    [inst_1 : CategoryTheory.Limits.HasTerminal C] →\n      (X Y : C) → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y)"],["∀ {C : Type u₁} [inst : CategoryTheory.Category.{?u.20555694, u₁} C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (X ≅ Y)"],["{C : Type u₁} →\n  [inst : CategoryTheory.Category.{?u.20556903, u₁} C] →\n    {X Y : C} → CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["{C : Type u₁} →\n  [inst : CategoryTheory.Category C] →\n    CategoryTheory.Limits.HasTerminal C → (P Q : C) → CategoryTheory.Limits.IsTerminal P → CategoryTheory.Limits.IsTerminal Q → (P ≅ Q) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] (X Y : C),\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C} (hX : CategoryTheory.Limits.IsTerminal X) (hY : CategoryTheory.Limits.IsTerminal Y),\n  Nonempty (X ≅ Y) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C}, CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → (X ≅ Y) ","∀ {C : Type u₁} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {A B : C}\n  (hA : CategoryTheory.Limits.IsTerminal A) (hB : CategoryTheory.Limits.IsTerminal B), Unique (A ≅ B) "]}
{"theorem":"∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","text":"The complement of the union of two sets is the intersection of their complements.","result":true,"gps":[["∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), sᶜ ∩ tᶜ = (s ∪ t)ᶜ ","∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ "]}
{"theorem":"∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3","text":"The sum of the cubes of two positive integers is never equal to the cube of a third integer.","result":true,"gps":[["∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x^3 + y^3 ≠ z^3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, x > 0 → y > 0 → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 ","∀ {x y z : ℕ}, 0 < x → 0 < y → x ^ 3 + y ^ 3 ≠ z ^ 3 "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y","text":"If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x ^ 2 = 1), ∀ (a b : G), Commute a b ","∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x^2 = 1), ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G] (h : ∀ (a : G), a ^ 2 = 1), ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G] (n : G), n ^ 2 = 1 → ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), Commute x y ","∀ {G : Type u_1} [inst : Group G] (h : ∀ (x : G), x * x = 1), ∀ (x y : G), Commute x y "]}
{"theorem":"∀ {n : ℕ}, Even (n * (n + 1))","text":"The product of two consecutive natural numbers is even.","result":true,"gps":[["∀ {n : ℕ}, Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))","∀ (n : ℕ), Even (n * (n + 1))","∀ {n : ℕ}, Even (n * (n + 1))"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) ","∀ (n : ℕ), Even (n * (n + 1)) ","∀ {n : ℕ}, Even (n * (n + 1)) "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","text":"Every index 2 subgroup of a group is normal.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 → Subgroup.Normal H ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G","text":"Every free group is torsion free.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G"],["∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype α], (α → G) → Monoid.IsTorsionFree (FreeGroup G)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : Fintype α] (f : α → G), Monoid.IsTorsionFree (FreeGroup G) ","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G ","forall {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], Monoid.IsTorsionFree G "]}
{"theorem":"∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","text":"Every natural number greater than `1` is divisible by a prime number.","result":true,"gps":[["∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), n > 1 → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n ","∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","text":"A finite torsion-free group is trivial","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → Subsingleton G "]}
{"theorem":"{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","text":"Every finite division ring is a field.","result":true,"gps":[["{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","{K : Type u_1} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K","(K : Type u) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["{K : Type u} → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Finite K] → Field K"],["(K : Type u_1) → [inst : DivisionRing K] → [inst_1 : Fintype K] → Field K"],["∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ {K : Type u_1} [inst : Fintype K] [inst_1 : DivisionRing K], IsField K ","∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K ","∀ (K : Type u_1) [inst : DivisionRing K] [inst_1 : Finite K], Field K ","∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], Field K "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","text":"Every finite topological space is compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α"],["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["finite_space_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α] : CompactSpace α ","finite_compact_space {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α] : CompactSpace α ","forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α ","finite_space.compact_space {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ","finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ","finite_compact_space {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ","forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : Fintype α], CompactSpace α ","finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ","finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α ","finite_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α "]}
{"theorem":"∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f","text":"Every surjective homomorphism from a finitely generated free group to itself is injective.","result":true,"gps":[["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f"],["∀ {α : Type u} (n : ℕ) (f : FreeGroup (Fin n) → FreeGroup (Fin n)), Function.Surjective f → Function.Injective f"],["∀ {α : Type u} [inst : DecidableEq α] [inst_1 : Fintype α] (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → Function.Injective f"],["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α), Function.Surjective f → Function.Injective f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ","∀ {α : Type u} [inst : DecidableEq α] [inst_1 : Fintype α] (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → Function.Injective f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α), Function.Surjective ↑f → Function.Injective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α → FreeGroup α),\n  Function.Surjective f → Function.Injective f ","∀ {α : Type u} (n : ℕ) (f : FreeGroup (Fin n) → FreeGroup (Fin n)), Function.Surjective f → Function.Injective f ","∀ {α : Type u} [inst : Fintype α] (f : FreeGroup α →* FreeGroup α),\n  Function.Surjective ↑f → Function.Injective ↑f "]}
{"theorem":"∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","text":"Every positive even integer can be written as the sum of two primes.","result":true,"gps":[["∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ (n : ℕ), n % 2 = 0 → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],["∀ (n : ℕ), n % 2 = 0 ∧ n > 2 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],["∀ (n : ℕ), n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"],["∀ (n : ℕ), 0 < n → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), n % 2 = 0 → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), n ≠ 0 → 2 ∣ n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), n ≠ 0 → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), n ≠ 0 → n % 2 = 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), 0 < n → Even n → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), n % 2 = 0 ∧ n > 2 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q ","∀ (n : ℕ), n ≠ 0 → 2 ∣ n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q "]}
{"theorem":"∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","text":"The square root of an irrational number is irrational.","result":true,"gps":[["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) ","∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x) "]}
{"theorem":"∀ {α : Type u} [inst : Semiring α] {x : α}, Even (x * x) → Even x","text":"If the square of a number is even, the number itself is even.","result":true,"gps":[["∀ {α : Type u} [inst : Semiring α] {x : α}, Even (x * x) → Even x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ","∀ {α : Type u} [inst : Semiring α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ","∀ {α : Type u} [inst : Semiring α] {x : α}, Even (x * x) → Even x ","∀ {α : Type u} [inst : CommRing α] {x : α}, (x * x) % 2 = 0 ↔ x % 2 = 0 "," ∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 → x % 2 = 0 ","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 ","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, x * x % 2 = 0 ↔ x % 2 = 0 "]}
{"theorem":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","text":"In a finite commutative ring, all prime ideals are maximal.","result":true,"gps":[["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (I : Ideal R), Ideal.IsPrime I → Ideal.IsMaximal I","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P) ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R],\n  ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (I : Ideal R), Ideal.IsPrime I → Ideal.IsMaximal I ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R),\n  Ideal.IsPrime P → Ideal.IsMaximal P ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R], ∀ (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsMaximal P ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}","text":"A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}","∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}","∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p | p.fst = p.snd}"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α],\n  T2Space α ↔ IsClosed {p : α × α | p.fst = p.snd} ","∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p : α × α | p.fst = p.snd} ","∀ {α : Type u} [inst : TopologicalSpace α], T2Space α ↔ IsClosed {p : α × α | p.1 = p.2} "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s","text":"If every point of a subset of a topological space is contained in some open set, the subset itself is open.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α) (H : x ∈ s), ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ x ∈ s, ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s ","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U ∧ U ⊆ s) → IsOpen s "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x","text":"Every non-identity element of a free group is of infinite order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x","∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] (g : α), g ≠ 1 → ¬IsOfFinOrder g","∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α}, x ≠ 1 → ¬IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G] (g : G), g ≠ 1 → ¬IsOfFinOrder g"],["∀ {α : Type u} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x"],["∀ {α : Type u} [inst : Group α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x"],["∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α] (a : α), a ≠ 1 → ¬IsOfFinOrder a"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G], IsFreeGroup G → ∀ (x : G), x ≠ 1 → ¬IsOfFinOrder x ","∀ {α : Type u} [inst : Group α] (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x ","∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α], ∀ (g : α), g ≠ 1 → ¬IsOfFinOrder g ","∀ {α : Type u_1} [inst : Group α] [inst_1 : IsFreeGroup α] {x : α},\n  x ≠ 1 → ¬IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : IsFreeGroup G], ∀ g : G, g ≠ 1 → ¬IsOfFinOrder g ","∀ {α : Type u} [inst : Group α] [inst_1 : IsFreeGroup α], ∀ (a : α), a ≠ 1 → ¬IsOfFinOrder a ","∀ {α : Type u} (x : FreeGroup α), x ≠ 1 → ¬IsOfFinOrder x "]}
{"theorem":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(DiscreteValuationRing.addVal R) x = 0","text":"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.","result":true,"gps":[["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(DiscreteValuationRing.addVal R) x = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R]\n  (x : R), IsUnit x ↔ DiscreteValuationRing.addVal R x = 0 "]}
{"theorem":"∀ (a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N","text":"For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.","result":true,"gps":[["∀ (a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, a * x + b * y ≥ N","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y, N ≤ a * x + b * y"],["∀ {a b N : ℕ}, Nat.coprime a b → a ≠ 0 → b ≠ 0 → ∃ x y, N ≤ a * x + b * y"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (a b : ℕ), Nat.coprime a b → ∀ N, ∃ (x y : ℕ), a * x + b * y ≥ N ","forall {a b N : ℕ}, Nat.coprime a b → a ≠ 0 → b ≠ 0 → ∃ x y : ℕ, N ≤ a * x + b * y ","∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y ≥ N ","∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, a * x + b * y ≥ N ","∀ {a b : ℕ}, Nat.coprime a b → ∀ (N : ℕ), ∃ x y : ℕ, N ≤ a * x + b * y ","∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ","∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ","∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ","∀ {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y ","forall {a b : ℕ}, Nat.coprime a b → ∀ N, ∃ x y : ℕ, N ≤ a * x + b * y "]}
{"theorem":"(K : Type u) → [inst : Field K] → Ring K","text":"Every field is a ring.","result":true,"gps":[["(K : Type u) → [inst : Field K] → Ring K","(K : Type u) → [inst : Field K] → Ring K","(K : Type u) → [inst : Field K] → Ring K","(K : Type u) → [inst : Field K] → Ring K","(K : Type u) → [inst : Field K] → Ring K","(K : Type u) → [inst : Field K] → Ring K"],["(F : Type u) → [inst : Field F] → Ring F","(F : Type u) → [inst : Field F] → Ring F","(F : Type u) → [inst : Field F] → Ring F"],["{K : Type u} → [inst : Field K] → Ring K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u) [inst : Field K], Ring K ","∀ (F : Type u) [inst : Field F], Ring F ","∀ (F : Type u) [inst : Field F], Ring F ","∀ (K : Type u) [inst : Field K], Ring K ","∀ {K : Type u} [inst : Field K], Ring K ","∀ (K : Type u) [inst : Field K], Ring K ","∀ (F : Type u) [inst : Field F], Ring F ","∀ (K : Type u) [inst : Field K], Ring K ","∀ (K : Type u) [inst : Field K], Ring K ","∀ (K : Type u) [inst : Field K], Ring K "]}
{"theorem":"{R : Type u_1} → [inst : Ring R] → Group Rˣ","text":"The set of units in a ring forms a group.","result":true,"gps":[["{R : Type u_1} → [inst : Ring R] → Group Rˣ","{R : Type u_1} → [inst : Ring R] → Group Rˣ","{R : Type u_1} → [inst : Ring R] → Group Rˣ","{R : Type u_1} → [inst : Ring R] → Group Rˣ","{R : Type u_1} → [inst : Ring R] → Group Rˣ","{R : Type u_1} → [inst : Ring R] → Group Rˣ"],["{R : Type u} → [inst : Ring R] → Group Rˣ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u} [inst : Ring R], Group Rˣ ","∀ {R : Type u_1} [inst : Ring R], Group Rˣ ","∀ {R : Type u_1} [inst : Ring R], Group Rˣ ","∀ {R : Type u_1} [inst : Ring R], Group Rˣ ","∀ {R : Type u_1} [inst : Ring R], Group Rˣ ","∀ {R : Type u_1} [inst : Ring R], Group Rˣ ","∀ {R : Type u_1} [inst : Ring R], Group Rˣ "]}
