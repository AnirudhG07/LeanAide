{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["If every proper closed subset of a topological space is compact, then the space itself is compact.",
  "Every non-empty poset in which every chain has an upper bound contains a maximal element.",
  "A group whose automorphism group is cyclic is Abelian.",
  "A terminal object in a category is unique up to unique isomorphism.",
  "Every index 2 subgroup of a group is normal.",
  "Every matrix satisfies its own characteristic polynomial.",
  "The square root of an irrational number is irrational.",
  "An element of a discrete valuation ring is a unit if and only if it has a valuation of zero."],
 "elaborated-prompts":
 [{"theorem":
   "∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n",
   "some-correct": null,
   "prompt":
   "Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.",
   "groups":
   [["∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n",
     "∀ (n : ℕ) [hp : Fact (Nat.Prime n)], n % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = n",
     "∀ (n : ℕ) [hp : Fact (Nat.Prime n)], n % 4 = 1 → ∃ x y, x ^ 2 + y ^ 2 = n"],
    ["∀ (n : ℕ), Nat.Prime n → n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n",
     "∀ (p : ℕ), Nat.Prime p → p % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = p"],
    ["∀ (n : ℕ) [hprime : Fact (Prime n)], n % 4 = 1 → ∃ a b, a ^ 2 + b ^ 2 = n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(n : ℕ) [Fact (nat.prime n)] (hn : n % 4 = 1) :\n∃ a b : ℕ, a^2 + b^2 = n ",
    "(n : ℕ) [hp : Fact (Nat.Prime n)] (h : n % 4 = 1) :\n ∃ x y : ℕ, x^2 + y^2 = n ",
    "(n : ℕ) [hprime : Fact (Prime n)] (hmod : n % 4 = 1) :\n  ∃ a b : ℕ, a^2 + b^2 = n ",
    "(n : ℕ) (hp : Nat.Prime (4 * n + 1)) :\n∃ (a b : ℕ), (4 * n + 1) = a^2 + b^2 ",
    "(n : ℕ) [hp : Fact (Nat.Prime n)] (h : n % 4 = 1) :\n  ∃ x y : ℕ, x ^ 2 + y ^ 2 = n ",
    "(n : ℕ) (hn : Nat.Prime n) (h1 : n % 4 = 1) :\n  ∃ a b : ℕ, a^2 + b^2 = n ",
    "prime_sum_of_two_squares (p : ℕ) (hp : Nat.Prime p) (hmod : p % 4 = 1) :\n  ∃ a b : ℕ, a ^ 2 + b ^ 2 = p "]},
  {"theorem": "∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2",
     "∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2",
     "∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2",
     "∀ (n m : ℕ), ∃ a b c d, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2"],
    ["∀ (n m : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n * m"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(n m : ℕ) : ∃ a b c d : ℕ, n * m = a^2 + b^2 + c^2 + d^2 ",
    "(n m : ℕ) :\n ∃ a b c d p q r s : ℤ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n ∧ p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 = m ∧ (a * p + b * q + c * r + d * s) ^ 2 + (a * q - b * p - c * s + d * r) ^ 2 + (a * r + b * s - c * p - d * q) ^ 2 + (a * s - b * r + c * q - d * p) ^ 2 = n * m ",
    "(n m : ℕ) : ∃ a b c d : ℕ, n * m = a^2 + b^2 + c^2 + d^2 ",
    "(n m : ℕ) :\n∃ a b c d : ℕ, a^2 + b^2 + c^2 + d^2 = (n * m) ",
    "(n m : ℕ) :\n ∃ a b c d : ℕ, n * m = a^2 + b^2 + c^2 + d^2 ",
    "(n m : ℕ) :\n∃ a b c d : ℕ, n * m = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 "]},
  {"theorem":
   "∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (x y : idem_ring), x * y = y * x",
   "some-correct": null,
   "prompt": "A ring with all elements idempotent is commutative.",
   "groups":
   [["∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (x y : idem_ring), x * y = y * x",
     "∀ (G : Type u_12) [inst : Ring G], (∀ (x : G), x * x = x) → ∀ (x y : G), x * y = y * x",
     "∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (a b : idem_ring), a * b = b * a",
     "∀ (idem_ring : Type u_12) [inst : Ring idem_ring], (∀ (a : idem_ring), a * a = a) → ∀ (a b : idem_ring), a * b = b * a",
     "∀ (R : Type u_12) [inst : Ring R], (∀ (a : R), a * a = a) → ∀ (a b : R), a * b = b * a"],
    ["(idem_ring : Type u_12) → [inst : Ring idem_ring] → (∀ (a : idem_ring), a * a = a) → CommSemiring idem_ring"],
    ["∀ (X : Type u_12) [inst : Semiring X], (∀ (x : X), x * x = x) → ∀ (x y : X), x * y = y * x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(idem_ring : Type*) [Ring idem_ring] (h_idem : ∀ (a : idem_ring), a * a = a) :\n ∀ (x y : idem_ring), x * y = y * x ",
    "(G : Type*) [Ring G] (hG : ∀ x : G, x * x = x) :\n∀ x y : G, x * y = y * x ",
    "(X : Type*) [Semiring X] (h_idem : ∀ x : X, x * x = x) : ∀ x y : X, x * y = y * x ",
    "(idem_ring : Type*) [Ring idem_ring] (idem : ∀ (a : idem_ring), a * a = a) :\n CommSemiring idem_ring ",
    "(idem_ring : Type*) [Ring idem_ring] (idem : ∀ a : idem_ring, a * a = a) :\n  ∀ a b : idem_ring, a * b = b * a ",
    "(idem_ring : Type*) [Ring idem_ring] (idem : ∀ a : idem_ring, a * a = a) :\n  ∀ a b : idem_ring, a * b = b * a ",
    "(R : Type*) [Ring R] (h_idem : ∀ a : R, a * a = a) : ∀ a b : R, a * b = b * a "]},
  {"theorem": "∃ P, ∀ (n : ℕ), Prime (P n) ∧ Prime (P n + 2)",
   "some-correct": null,
   "prompt":
   "There are infinitely many pairs of primes that differ exactly by `2`.",
   "groups":
   [["∃ P, ∀ (n : ℕ), Prime (P n) ∧ Prime (P n + 2)",
     "∃ f, ∀ (n : ℕ), Prime (f n) ∧ Prime (f n + 2)",
     "∃ f, ∀ (k : ℕ), Prime (f k) ∧ Prime (f k + 2)"],
    ["∃ f, (∀ (n : ℕ), Nat.Prime (f n).fst ∧ Nat.Prime (f n).snd ∧ (f n).snd - (f n).fst = 2) ∧ ∀ (m n : ℕ), m ≠ n → f m ≠ f n"],
    ["∃ p, ∀ (k : ℕ), k ≥ p → ∃ n, Prime (n + k) ∧ Prime (n + k + 2)"],
    ["∃ f, Function.Injective f ∧ ∀ (n : ℕ), (∀ (k : ℕ), k < n → Nat.Prime (f k)) ∧ Nat.Prime (f n + 2)"],
    ["∃ f, Function.Injective f ∧ ∀ (n : ℕ), Prime (f n).fst ∧ Prime (f n).snd ∧ (f n).snd - (f n).fst = 2"],
    ["∃ f, StrictMono f ∧ ∀ (n : ℕ), Nat.Prime (f n) ∧ Nat.Prime (f n + 2)"],
    ["∃ f, (∀ (n : ℕ), Prime (f n) ∧ Prime (f n + 2)) ∧ ∀ (m n : ℕ), m ≠ n → f m ≠ f n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["infinitely_many_twin_primes : ∃ p : ℕ, ∀ k ≥ p, ∃ (n : ℕ), Prime (n + k) ∧ Prime (n + k + 2) ",
    "infinitely_many_twin_primes : ∃ P : ℕ → ℕ, ∀ n, Prime (P n) ∧ Prime (P n + 2) ",
    "infinitely_many_twin_primes : ∃ f : ℕ → ℕ, ∀ n : ℕ, Prime (f n) ∧ Prime (f n + 2) ",
    "infinitely_many_twin_primes : ∃ f : ℕ → ℕ, Function.Injective f ∧ ∀ n, (∀ k < n, Nat.Prime (f k)) ∧ Nat.Prime (f n + 2) ",
    "infinitely_many_twin_primes : ∃ f : ℕ → ℕ, ∀ k, Prime (f k) ∧ Prime (f k + 2) ",
    "infinitely_many_twin_primes : ∃f : ℕ → ℕ × ℕ, Function.Injective f ∧ ∀ n, (Prime (f n).fst) ∧ (Prime (f n).snd) ∧ (f n).snd - (f n).fst = 2 ",
    "infinitely_many_twin_primes : ∃ f : ℕ → ℕ, StrictMono f ∧ ∀ n, Nat.Prime (f n) ∧ Nat.Prime (f n + 2) ",
    ": ∃ f : ℕ → ℕ, (∀ n, Prime (f n) ∧ Prime (f n + 2)) ∧ ∀ m n, m ≠ n → f m ≠ f n ",
    "infinitely_many_twin_primes : ∃ (f : ℕ → ℕ × ℕ), (∀ n, Nat.Prime (f n).1 ∧ Nat.Prime (f n).2 ∧ (f n).2 - (f n).1 = 2) ∧ ∀ m n, m ≠ n → f m ≠ f n "]},
  {"theorem":
   "(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G",
     "(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G",
     "(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G"],
    ["∀ (G : Type u_12) [inst : DivisionRing G] [inst_1 : Fintype G], IsField G",
     "∀ (M : Type u_12) [inst : DivisionRing M] [inst_1 : Fintype M], IsField M"],
    ["(finite_div_ring : Type u_12) →\n  [inst : DivisionRing finite_div_ring] → [inst : Fintype finite_div_ring] → Field finite_div_ring"],
    ["(finite_division_ring : Type u_12) →\n  [inst : DivisionRing finite_division_ring] → [inst : Fintype finite_division_ring] → Field finite_division_ring"],
    ["(finite_division_ring : Type u_12) →\n  [inst : Fintype finite_division_ring] → [inst : DivisionRing finite_division_ring] → Field finite_division_ring"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [DivisionRing G] [Fintype G] : IsField G ",
    "(finite_division_ring : Type*) [Fintype finite_division_ring] [DivisionRing finite_division_ring] :\n Field finite_division_ring ",
    "(finite_division_ring : Type*) [DivisionRing finite_division_ring] [Fintype finite_division_ring] :\n Field finite_division_ring ",
    "(M : Type*) [DivisionRing M] [Fintype M] : IsField M ",
    "(G : Type*) [DivisionRing G] [Fintype G] : Field G ",
    "(finite_div_ring : Type*) [DivisionRing finite_div_ring] [Fintype finite_div_ring] :\n Field finite_div_ring ",
    "(G : Type*) [DivisionRing G] [Fintype G] : Field G ",
    "(G : Type*) [DivisionRing G] [Fintype G] : Field G "]},
  {"theorem":
   "∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True",
   "some-correct": null,
   "prompt":
   "If each of two types can be mapped injectively into the other, then there is a bijection between them.",
   "groups":
   [["∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True",
     "∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True"],
    ["∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X),\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h",
     "∀ (X : Type u_12) (Y : Type u_13) (f : X → Y) (g : Y → X),\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h"],
    ["∀ (X : Type u_12) (Y : Type u_13), Nonempty (X ↪ Y) → Nonempty (Y ↪ X) → Nonempty (X ≃ Y)"],
    ["∀ (X Y : Type) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h"],
    ["∀ (X Y : Type) (f : X → Y) (g : Y → X), Function.Injective f → Function.Injective g → ∃ h, True"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X Y : Type*) (f : X → Y) (g : Y → X) (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ (h : X → Y), Function.Bijective h ",
    "(X Y : Type*) (f : X → Y) (g : Y → X)\n (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ (h : X ≃ Y), True ",
    "(X Y : Type) (f : X → Y) (g : Y → X) (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ h : X → Y, Function.Bijective h ",
    "(X Y : Type*) (f : X → Y) (g : Y → X) (hf : Function.Injective f) (hg : Function.Injective g) :\n ∃ h : X ≃ Y, True ",
    "(X Y : Type*) (f : X → Y) (g : Y → X)\n(hf : Function.Injective f) (hg : Function.Injective g) :\n∃ (h : X → Y), Function.Bijective h ",
    "(X Y : Type) (f : X → Y) (g : Y → X)\n  (hf : Function.Injective f) (hg : Function.Injective g) :\n  ∃ (h : X ≃ Y), True ",
    "(X Y : Type*) (h1 : nonempty (X ↪ Y)) (h2 : nonempty (Y ↪ X)) : nonempty (X ≃ Y) "]},
  {"theorem":
   "∀ (Vertices : Type u_12) [inst : Fintype Vertices] [inst : DecidableEq Vertices] (Edges : Vertices → Vertices → Prop),\n  (∀ (x y : Vertices), x ≠ y → ∃! z, Edges x z ∧ Edges y z) → ∃ v, ∀ (w : Vertices), w ≠ v → Edges v w",
   "some-correct": null,
   "prompt":
   "A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.",
   "groups":
   [["∀ (Vertices : Type u_12) [inst : Fintype Vertices] [inst : DecidableEq Vertices] (Edges : Vertices → Vertices → Prop),\n  (∀ (x y : Vertices), x ≠ y → ∃! z, Edges x z ∧ Edges y z) → ∃ v, ∀ (w : Vertices), w ≠ v → Edges v w"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(Vertices : Type*) [Fintype Vertices] [DecidableEq Vertices] (Edges : Vertices → Vertices → Prop)\n  (h_common_neighbor : ∀ x y : Vertices, x ≠ y → ∃! z, Edges x z ∧ Edges y z) :\n∃ v : Vertices, ∀ w : Vertices, w ≠ v → Edges v w "]},
  {"theorem":
   "∀ (partitions_with_odd_parts partitions_with_distinct_parts : ℕ → ℕ) (n : ℕ),\n  partitions_with_odd_parts n = partitions_with_distinct_parts n",
   "some-correct": null,
   "prompt":
   "The number of partitions with odd parts is equal to the number of partitions with distinct parts.",
   "groups":
   [["∀ (partitions_with_odd_parts partitions_with_distinct_parts : ℕ → ℕ) (n : ℕ),\n  partitions_with_odd_parts n = partitions_with_distinct_parts n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(partitions_with_odd_parts : ℕ → ℕ) (partitions_with_distinct_parts : ℕ → ℕ) (n : ℕ) :\n partitions_with_odd_parts n = partitions_with_distinct_parts n "]},
  {"theorem":
   "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],
    ["∀ (X Y Z : Type) [inst : UniformSpace X] [inst_1 : UniformSpace Y] [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X : Type*) (Y : Type*) (Z : Type*)\n[UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ (X : Type u_12) (Y : Type u_13) (Z : Type u_14) [inst : UniformSpace X] [inst_1 : UniformSpace Y]\n  [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"],
    ["∀ (X Y Z : Type) [inst : UniformSpace X] [inst_1 : UniformSpace Y] [inst_2 : UniformSpace Z] (f : X → Y) (g : Y → Z),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X : Type*) (Y : Type*) (Z : Type*)\n[UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n  (f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\n  UniformContinuous (g ∘ f) ",
    "(X Y Z : Type*) [UniformSpace X] [UniformSpace Y] [UniformSpace Z]\n(f : X → Y) (g : Y → Z) (hf : UniformContinuous f) (hg : UniformContinuous g) :\nUniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ (X : Type u_12) [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (A B : Set X),\n      IsClosed A →\n        IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ (∀ (a : X), a ∈ A → f a = 0) ∧ ∀ (b : X), b ∈ B → f b = 1",
   "some-correct": null,
   "prompt":
   "A topological space is normal if and only if any two disjoint closed subsets can be separated by a continuous function.",
   "groups":
   [["∀ (X : Type u_12) [inst : TopologicalSpace X],\n  NormalSpace X ↔\n    ∀ (A B : Set X),\n      IsClosed A →\n        IsClosed B → Disjoint A B → ∃ f, Continuous f ∧ (∀ (a : X), a ∈ A → f a = 0) ∧ ∀ (b : X), b ∈ B → f b = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X : Type*) [TopologicalSpace X] :\n  NormalSpace X ↔ ∀ A B : Set X, IsClosed A → IsClosed B → Disjoint A B → ∃ f : X → ℝ, Continuous f ∧ (∀ a ∈ A, f a = 0) ∧ (∀ b ∈ B, f b = 1) "]},
  {"theorem":
   "∀ (unit_interval : Type u_12) [inst : LinearOrderedField unit_interval] [inst_1 : TopologicalSpace unit_interval]\n  [inst_2 : OrderTopology unit_interval] [inst_3 : TopologicalRing unit_interval] (f : unit_interval → unit_interval),\n  Continuous f → ∀ (x₀ : unit_interval), f (f (f x₀)) = x₀ → ∀ (n : ℕ), ∃ x, (f ^ n) x = x",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.",
   "groups":
   [["∀ (unit_interval : Type u_12) [inst : LinearOrderedField unit_interval] [inst_1 : TopologicalSpace unit_interval]\n  [inst_2 : OrderTopology unit_interval] [inst_3 : TopologicalRing unit_interval] (f : unit_interval → unit_interval),\n  Continuous f → ∀ (x₀ : unit_interval), f (f (f x₀)) = x₀ → ∀ (n : ℕ), ∃ x, (f ^ n) x = x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(unit_interval : Type*) [LinearOrderedField unit_interval] [TopologicalSpace unit_interval] [OrderTopology unit_interval] [TopologicalRing unit_interval]\n(f : unit_interval → unit_interval) (hf : Continuous f) (x₀ : unit_interval) (hx₀ : f (f (f x₀)) = x₀) :\n∀ n : ℕ, ∃ x : unit_interval, (f ^ n) x = x ",
    "(X : Type*) [LinearOrderedField X] [TopologicalSpace X] [OrderTopology X]\n(f : X → X) (hf : Continuous f) (h0 : 0 ≤ f 0) (h1 : f 1 ≤ 1)\n(h_period : ∃ x, 0 < x ∧ x < 1 ∧ f (f (f x)) = x) :\n∀ n : ℕ, ∃ x, 0 < x ∧ x < 1 ∧ (f^[n] x = x) "]},
  {"theorem": "∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets is the intersection of their complements.",
   "groups":
   [["∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ",
     "∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ",
     "∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ",
     "∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ",
     "∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ",
     "∀ (X : Type u_12) (A B : Set X), (A ∪ B)ᶜ = Aᶜ ∩ Bᶜ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ",
    "(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ",
    "(X : Type*) (A B : Set X) :\n  HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ",
    "(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ",
    "(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B ",
    "(X : Type*) (A B : Set X) : HasCompl.compl (A ∪ B) = HasCompl.compl A ∩ HasCompl.compl B "]},
  {"theorem": "∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3",
   "some-correct": null,
   "prompt":
   "The sum of the cubes of two positive integers is never equal to the cube of a third integer.",
   "groups":
   [["∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3",
     "∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3",
     "∀ (n m k : ℕ), n > 0 → m > 0 → n ^ 3 + m ^ 3 ≠ k ^ 3"],
    ["∀ (x y z : ℕ), x ^ 3 + y ^ 3 ≠ z ^ 3"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(n m k : ℕ) (hn : n > 0) (hm : m > 0) :\n  n ^ 3 + m ^ 3 ≠ k ^ 3 ",
    "no_sum_of_cubes_eq_cube : ∀ x y z : ℕ, x ^ 3 + y ^ 3 ≠ z ^ 3 ",
    "(n m k : ℕ) (hn : n > 0) (hm : m > 0) : n ^ 3 + m ^ 3 ≠ k ^ 3 ",
    "(n m k : ℕ) (hn : n > 0) (hm : m > 0) : n^3 + m^3 ≠ k^3 "]},
  {"theorem":
   "∀ (G : Type u_12) [inst : Group G], (∀ (g : G), g * g = 1) → ∀ (x y : G), x * y = y * x",
   "some-correct": null,
   "prompt":
   "If every element of a group `G` has order `2`, then every pair of elements of `G` commutes.",
   "groups":
   [["∀ (G : Type u_12) [inst : Group G], (∀ (g : G), g * g = 1) → ∀ (x y : G), x * y = y * x",
     "∀ (G : Type u_12) [inst : Group G], (∀ (x : G), x * x = 1) → ∀ (x y : G), x * y = y * x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [Group G] (hG : ∀ x : G, x^2 = 1) : ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (hG : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (h : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (hG : ∀ g : G, g * g = 1) : ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (hG : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (hG : ∀ g : G, g ^ 2 = 1) : ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (hG : ∀ (x : G), x^2 = 1) :\n ∀ (x y : G), x * y = y * x ",
    "(G : Type*) [Group G] (h : ∀ g : G, g^2 = 1) :\n ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (hG : ∀ x : G, x * x = 1) : ∀ x y : G, x * y = y * x ",
    "(G : Type*) [Group G] (h2 : ∀ x : G, x ^ 2 = 1) : ∀ x y : G, x * y = y * x "]},
  {"theorem": "∀ (n : ℕ), n * (n + 1) % 2 = 0",
   "some-correct": null,
   "prompt": "The product of two consecutive natural numbers is even.",
   "groups":
   [["∀ (n : ℕ), n * (n + 1) % 2 = 0",
     "∀ (n : ℕ), n * (n + 1) % 2 = 0",
     "∀ (n : ℕ), n * (n + 1) % 2 = 0",
     "∀ (n : ℕ), n * (n + 1) % 2 = 0",
     "∀ (n : ℕ), n * (n + 1) % 2 = 0",
     "∀ (n : ℕ), n * (n + 1) % 2 = 0"],
    ["∀ (m n : ℕ), n = m + 1 → Even (m * n)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(n : ℕ) : (n * (n + 1)) % 2 = 0 ",
    "(m n : ℕ) (h : n = m + 1) : Even (m * n) ",
    "(n : ℕ) :\neven (n * (n + 1)) ",
    "(n : ℕ) : even (n * (n + 1)) ",
    "(n : ℕ) : (n * (n + 1)) % 2 = 0 ",
    "(n : ℕ) : (n * (n + 1)) % 2 = 0 ",
    "(n : ℕ) : (n * (n + 1)) % 2 = 0 ",
    "(n : ℕ) :\n  (n * (n + 1)) % 2 = 0 ",
    "(n : ℕ) : Even ((n * (n + 1))) ",
    "(n : ℕ) : (n * (n + 1)) % 2 = 0 "]},
  {"theorem":
   "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∃ n, n ≠ 0 ∧ x ^ n ≠ 1",
   "some-correct": null,
   "prompt": "Every free group is torsion free.",
   "groups":
   [["∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∃ n, n ≠ 0 ∧ x ^ n ≠ 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [Group G] [IsFreeGroup G] : ∀ x : G, x ≠ 1 → ∃ n : ℤ, n ≠ 0 ∧ x ^ n ≠ 1 "]},
  {"theorem": "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Every natural number greater than `1` is divisible by a prime number.",
   "groups":
   [["∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
     "∀ (n : ℕ), n > 1 → ∃ p, Nat.Prime p ∧ p ∣ n"],
    ["∀ (n : ℕ), n > 1 → ∃ p, Prime p ∧ p ∣ n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(n : ℕ) (hn : n > 1) : ∃ p, Prime p ∧ p ∣ n ",
    "(n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ",
    "prime_divisor_of_gt_one (n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ",
    "(n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ",
    "(n : ℕ) (hn : n > 1) :\n  ∃ p : ℕ, Nat.Prime p ∧ p ∣ n ",
    "(n : ℕ) (hn : n > 1) : ∃ p : ℕ, Prime p ∧ p ∣ n ",
    "(n : ℕ) (hn : n > 1) : ∃ p, Nat.Prime p ∧ p ∣ n ",
    "(n : ℕ) (hn : n > 1) :\n∃ p : ℕ, Nat.Prime p ∧ p ∣ n ",
    "prime_divisor_of_nat_gt_one (n : ℕ) (hn : n > 1) : ∃ p, Prime p ∧ p ∣ n "]},
  {"theorem":
   "(G : Type u_12) →\n  [inst : Group G] →\n    [inst_1 : Fintype G] → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n = 1) → (∀ (g : G) (n : ℕ), g ^ n = 1 → g = 1) → G ≃ Unit",
   "some-correct": null,
   "prompt": "A finite torsion-free group is trivial",
   "groups":
   [["(G : Type u_12) →\n  [inst : Group G] →\n    [inst_1 : Fintype G] → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n = 1) → (∀ (g : G) (n : ℕ), g ^ n = 1 → g = 1) → G ≃ Unit"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [Group G] [Fintype G] (hf : ∀ g : G, g ≠ 1 → ∃ n : ℕ, g ^ n = 1) (htf : ∀ g : G, ∀ n : ℕ, g ^ n = 1 → g = 1) :\n  G ≃ Unit "]},
  {"theorem":
   "(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G",
   "some-correct": null,
   "prompt": "Every finite division ring is a field.",
   "groups":
   [["(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G",
     "(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G",
     "(G : Type u_12) → [inst : DivisionRing G] → [inst : Fintype G] → Field G"],
    ["∀ (G : Type u_12) [inst : DivisionRing G] [inst_1 : Fintype G], IsField G",
     "∀ (M : Type u_12) [inst : DivisionRing M] [inst_1 : Fintype M], IsField M"],
    ["(finite_div_ring : Type u_12) →\n  [inst : DivisionRing finite_div_ring] → [inst : Fintype finite_div_ring] → Field finite_div_ring"],
    ["(finite_division_ring : Type u_12) →\n  [inst : DivisionRing finite_division_ring] → [inst : Fintype finite_division_ring] → Field finite_division_ring"],
    ["(finite_division_ring : Type u_12) →\n  [inst : Fintype finite_division_ring] → [inst : DivisionRing finite_division_ring] → Field finite_division_ring"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [DivisionRing G] [Fintype G] : IsField G ",
    "(finite_division_ring : Type*) [Fintype finite_division_ring] [DivisionRing finite_division_ring] :\n Field finite_division_ring ",
    "(finite_division_ring : Type*) [DivisionRing finite_division_ring] [Fintype finite_division_ring] :\n Field finite_division_ring ",
    "(M : Type*) [DivisionRing M] [Fintype M] : IsField M ",
    "(G : Type*) [DivisionRing G] [Fintype G] : Field G ",
    "(finite_div_ring : Type*) [DivisionRing finite_div_ring] [Fintype finite_div_ring] :\n Field finite_div_ring ",
    "(G : Type*) [DivisionRing G] [Fintype G] : Field G ",
    "(G : Type*) [DivisionRing G] [Fintype G] : Field G "]},
  {"theorem":
   "∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X",
   "some-correct": null,
   "prompt": "Every finite topological space is compact.",
   "groups":
   [["∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] [inst_1 : Fintype X], CompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ",
    "(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ",
    "(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ",
    "(X : Type*) [TopologicalSpace X] [fintype X] :\nCompactSpace X ",
    "(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X ",
    "(X : Type*) [TopologicalSpace X] [Fintype X] : CompactSpace X "]},
  {"theorem":
   "∀ (G : Type u_12) [inst : Group G] [inst_1 : Fintype G] (f : G →* G), Function.Surjective ↑f → Function.Injective ↑f",
   "some-correct": null,
   "prompt":
   "Every surjective homomorphism from a finitely generated free group to itself is injective.",
   "groups":
   [["∀ (G : Type u_12) [inst : Group G] [inst_1 : Fintype G] (f : G →* G), Function.Surjective ↑f → Function.Injective ↑f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [Group G] [Fintype G] (f : G →* G) (hf : Function.Surjective (⇑f)) : Function.Injective (⇑f) "]},
  {"theorem":
   "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q",
   "some-correct": null,
   "prompt":
   "Every positive even integer can be written as the sum of two primes.",
   "groups":
   [["∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q",
     "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q",
     "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q",
     "∀ (n : ℕ), 2 ≤ n → n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q",
     "∀ (n : ℕ), 2 ≤ n ∧ n % 2 = 0 → ∃ p q, Prime p ∧ Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), n > 2 → Even n → ∃ p q, Prime p ∧ Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), 2 ≤ n ∧ Even n → ∃ p q, Prime p ∧ Prime q ∧ n = p + q"],
    ["∀ (n : ℕ), n > 2 → n % 2 = 0 → ∃ p q, n = p + q ∧ Prime p ∧ Prime q"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["every_even_sum_of_two_primes :\n  ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ",
    "goldbach_conjecture (n : ℕ) (hn : 2 ≤ n ∧ Even n) : ∃ p q : ℕ, prime p ∧ prime q ∧ n = p + q ",
    "goldbach_conjecture :\n  ∀ n : ℕ, n > 2 → n % 2 = 0 → ∃ (p q : ℕ), n = p + q ∧ Prime p ∧ Prime q ",
    "goldbach_conjecture : ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ",
    "goldbach_conjecture : ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, prime p ∧ prime q ∧ n = p + q ",
    "Goldbach_conjecture : ∀ n : ℕ, n > 2 → Even n → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ",
    "goldbach_conjecture : ∀ n : ℕ, 2 ≤ n → n % 2 = 0 → ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q ",
    "goldbach_conjecture (n : ℕ) (hn : 2 ≤ n ∧ n % 2 = 0) : ∃ p q : ℕ, Prime p ∧ Prime q ∧ n = p + q "]},
  {"theorem": "∀ (n : ℕ), n ^ 2 % 2 = 0 → n % 2 = 0",
   "some-correct": null,
   "prompt": "If the square of a number is even, the number itself is even.",
   "groups":
   [["∀ (n : ℕ), n ^ 2 % 2 = 0 → n % 2 = 0",
     "∀ (n : ℕ), n ^ 2 % 2 = 0 → n % 2 = 0",
     "∀ (sq_even : ℕ), sq_even ^ 2 % 2 = 0 → sq_even % 2 = 0",
     "∀ (square_even : ℕ), square_even ^ 2 % 2 = 0 → square_even % 2 = 0",
     "∀ (sq_even : ℕ), sq_even ^ 2 % 2 = 0 → sq_even % 2 = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(n : ℕ) (hsq : n^2 % 2 = 0) : n % 2 = 0 ",
    "(n : ℕ) (h : n ^ 2 % 2 = 0) : n % 2 = 0 ",
    "(sq_even : ℕ) (h : sq_even ^ 2 % 2 = 0) :\nsq_even % 2 = 0 ",
    "(square_even : ℕ) (h : square_even ^ 2 % 2 = 0) : square_even % 2 = 0 ",
    "(sq_even : ℕ) (h : sq_even ^ 2 % 2 = 0) : sq_even % 2 = 0 ",
    "(sq_even : ℕ → Prop) (x : ℕ) (h : sq_even (x^2)) : sq_even x ",
    "(sq_even : ℕ → Prop) (a : ℕ) (h : sq_even (a^2)) : sq_even a "]},
  {"theorem":
   "∀ (G : Type u_12) [inst : CommRing G] [inst_1 : Fintype G] (P : Ideal G) [hP : Ideal.IsPrime P], Ideal.IsMaximal P",
   "some-correct": null,
   "prompt": "In a finite commutative ring, all prime ideals are maximal.",
   "groups":
   [["∀ (G : Type u_12) [inst : CommRing G] [inst_1 : Fintype G] (P : Ideal G) [hP : Ideal.IsPrime P], Ideal.IsMaximal P",
     "∀ (finite_ring : Type u_12) [inst : CommRing finite_ring] [inst_1 : Fintype finite_ring] (P : Ideal finite_ring)\n  [hP : Ideal.IsPrime P], Ideal.IsMaximal P",
     "∀ (G : Type u_12) [inst : CommRing G] [inst_1 : Fintype G] (P : Ideal G), Ideal.IsPrime P → Ideal.IsMaximal P"],
    ["∀ (X : Type) [inst : CommRing X] [inst_1 : Fintype X] (P : Ideal X) [Hp : Ideal.IsPrime P], Ideal.IsMaximal P"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X : Type) [CommRing X] [Fintype X] (P : Ideal X) [Hp : Ideal.IsPrime P] :\nIdeal.IsMaximal P ",
    "(G : Type*) [CommRing G] [Fintype G] (P : Ideal G) [hP : Ideal.IsPrime P] :\n Ideal.IsMaximal P ",
    "(finite_ring : Type*) [CommRing finite_ring] [Fintype finite_ring] (P : Ideal finite_ring) [hP : Ideal.IsPrime P] :\nIdeal.IsMaximal P ",
    "(G : Type*) [CommRing G] [Fintype G] (P : Ideal G) (hP : Ideal.IsPrime P) :\nIdeal.IsMaximal P "]},
  {"theorem":
   "∀ (X : Type u_12) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.fst = p.snd}",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal is a closed set in $X × X$.",
   "groups":
   [["∀ (X : Type u_12) [inst : TopologicalSpace X], T2Space X ↔ IsClosed {p | p.fst = p.snd}"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X : Type*) [TopologicalSpace X] :\n T2Space X ↔ IsClosed {p : X × X | p.1 = p.2} "]},
  {"theorem":
   "∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some open set, the subset itself is open.",
   "groups":
   [["∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (B : Set X), (∀ (x : X), x ∈ B → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ B) → IsOpen B",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A"],
    ["∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A",
     "∀ (X : Type u_12) [inst : TopologicalSpace X] (A : Set X), (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen A"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):\n IsOpen A ",
    "(X : Type*) [TopologicalSpace X]\n (B : Set X) (hB : ∀ x ∈ B, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ B):\n IsOpen B ",
    "(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U) :\n IsOpen A ",
    "(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):\n IsOpen A ",
    "(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U) :\n IsOpen A ",
    "(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ A):\n IsOpen A ",
    "(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U):\n IsOpen A ",
    "(X : Type*) [TopologicalSpace X]\n (B : Set X) (hB : ∀ x ∈ B, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ B):\n IsOpen B ",
    "(X : Type*) [TopologicalSpace X]\n (B : Set X) (hB : ∀ x ∈ B, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ B):\n IsOpen B ",
    "(X : Type*) [TopologicalSpace X]\n (A : Set X) (hA : ∀ x ∈ A, ∃ U : Set X, IsOpen U ∧ x ∈ U ∧ U ⊆ A):\n IsOpen A "]},
  {"theorem":
   "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
   "some-correct": null,
   "prompt": "Every non-identity element of a free group is of infinite order.",
   "groups":
   [["∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
     "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
     "∀ (F : Type u_12) [inst : Group F] [inst_1 : IsFreeGroup F] (x : F), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
     "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
     "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
     "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
     "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1",
     "∀ (G : Type u_12) [inst : Group G] [inst_1 : IsFreeGroup G] (x : G), x ≠ 1 → ∀ (n : ℕ), x ^ n ≠ 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
    "(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
    "(F : Type*) [Group F] [IsFreeGroup F] (x : F) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
    "(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
    "(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
    "(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
    "(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 ",
    "(G : Type*) [Group G] [IsFreeGroup G] (x : G) (hx : x ≠ 1) : ∀ n : ℕ, x ^ n ≠ 1 "]},
  {"theorem":
   "∀ (N₀ a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), N ≥ N₀ → ∃ x y, N = a * x + b * y",
   "some-correct": null,
   "prompt":
   "For any two relatively prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers.",
   "groups":
   [["∀ (N₀ a b : ℕ), Nat.coprime a b → ∀ (N : ℕ), N ≥ N₀ → ∃ x y, N = a * x + b * y"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(N₀ : ℕ) (a b : ℕ) (h_coprime : Nat.coprime a b) :\n  ∀ N ≥ N₀, ∃ (x y : ℕ), N = a * x + b * y "]},
  {"theorem": "(X : Type u_12) → [inst : Field X] → Ring X",
   "some-correct": null,
   "prompt": "Every field is a ring.",
   "groups":
   [["(X : Type u_12) → [inst : Field X] → Ring X"],
    ["((F : Type u_12) → [inst : Field F] → Ring F) → Prop"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(field_to_ring : ∀ (F : Type*) [Field F], Ring F) : Prop ",
    "(X : Type*) [Field X] : Ring X "]},
  {"theorem": "(G : Type u_12) → [inst : Ring G] → Group Gˣ",
   "some-correct": null,
   "prompt": "The set of units in a ring forms a group.",
   "groups":
   [["(G : Type u_12) → [inst : Ring G] → Group Gˣ",
     "(G : Type u_12) → [inst : Ring G] → Group Gˣ",
     "(G : Type u_12) → [inst : Ring G] → Group Gˣ",
     "(G : Type u_12) → [inst : Ring G] → Group Gˣ"],
    ["(G : Type u_12) → [inst : Ring G] → Group Gˣ"],
    ["(G : Type u_12) → [inst : Ring G] → Group Gˣ"],
    ["(X : Type u_12) → [inst : Ring X] → Group Xˣ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) [Ring G] :\n Group (Units G) ",
    "(G : Type*) [Ring G] : Group (Units G) ",
    "(X : Type*) [Ring X] :\nGroup (Units X) ",
    "(G : Type*) [Ring G] : Group (Units G) ",
    "(G : Type*) [Ring G] : Group (Units G) ",
    "(G : Type*) [Ring G] :\nGroup (Units G) ",
    "(G : Type*) [Ring G] : Group (Units G) "]},
  {"theorem":
   "∀ (G : Type u_12) (H : Type u_13) [inst : Group G] [inst_1 : Group H],\n  (∀ (g : G × H), g ≠ 1 → ∃ n, g ^ n ≠ 1) → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n ≠ 1) ∧ ∀ (h : H), h ≠ 1 → ∃ n, h ^ n ≠ 1",
   "some-correct": null,
   "prompt":
   "If the direct product of two groups is torsion free then each of the groups is torsion free.",
   "groups":
   [["∀ (G : Type u_12) (H : Type u_13) [inst : Group G] [inst_1 : Group H],\n  (∀ (g : G × H), g ≠ 1 → ∃ n, g ^ n ≠ 1) → (∀ (g : G), g ≠ 1 → ∃ n, g ^ n ≠ 1) ∧ ∀ (h : H), h ≠ 1 → ∃ n, h ^ n ≠ 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["(G : Type*) (H : Type*) [Group G] [Group H] (gh_torsion_free : ∀ g : G × H, g ≠ 1 → ∃ n : ℤ, g ^ n ≠ 1) :\n(∀ (g : G), g ≠ 1 → ∃ n : ℤ, g ^ n ≠ 1) ∧ (∀ (h : H), h ≠ 1 → ∃ n : ℤ, h ^ n ≠ 1)"]}],
 "elaborated": 32}