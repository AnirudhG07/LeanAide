{"total-prompts": 40,
 "temperature": 1.2,
 "query-number": 15,
 "number-similar-sentences": 20,
 "include-fixed": false,
 "failures":
 ["Every vector space is finite dimensional.",
  "Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
  "A finitely-presented group containing a torsion element is finite.",
  "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.",
  "The characteristic polynomial of every matrix has real roots.",
  "Every uniformly continuous function is bounded above.",
  "The number of partitions of a finite set is a prime number.",
  "The automorphism group of an Abelian group is cyclic."],
 "elaborated-prompts":
 [{"theorem": "∀ {R : Type u} [inst : Ring R], IsField R",
   "some-correct": null,
   "prompt": "Every ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Ring R], IsField R",
    "∀ (R : Type u) [inst : Ring R], IsField R",
    "¬(∀ (R : Type u) [inst : Ring R], IsField R)"]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G",
    "∀ (G : Type u_1) [inst : Group G], Monoid.IsTorsion G"]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → Fact (Nat.Prime (Fintype.card α))",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : IsSimpleGroup G],\n  ∃ (p : ℕ), Fintype.card G = p ∧ Fact (Nat.Prime p)",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → Fact (Nat.Prime (Fintype.card α))",
    "∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → Nat.Prime (Fintype.card α)",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ (p : ℕ), Fact (Nat.Prime p) ∧ Fintype.card α = p",
    "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ (p : ℕ), Fact (Nat.Prime p) ∧ Fintype.card G = p",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α → ∃ (p : ℕ), Prime p ∧ Fintype.card α = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G → ∃ p : ℕ, Nat.Prime p ∧ Fintype.card G = p"]},
  {"theorem":
   "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], IsSimpleGroup G",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsSimpleGroup G",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], IsSimpleGroup α"]},
  {"theorem":
   "∀ {R : Type u} [inst : Group R] [inst_1 : Fintype R], ∃ p, Fact (Nat.Prime p) ∧ Fintype.card R = p",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["{R : Type u} [inst : Group R] [inst_1 : Fintype R] : ∃ (p : ℕ), Fact (Nat.Prime p) ∧ Fintype.card R = p",
    "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fact (Nat.Prime (Fintype.card G))",
    "∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α], ∃ p : ℕ, Fact (Nat.Prime p) ∧ Fintype.card α = p",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fact (Nat.Prime (Fintype.card G))",
    "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ (p : ℕ), Fact (Nat.Prime p) ∧ Fintype.card G = p"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), ?m.1405097 s = 0",
   "some-correct": null,
   "prompt": "Every set has Lebesgue measure zero.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : MeasurableSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0",
    "∀ {α : Type u} [inst : MeasurableSpace α], ↑↑MeasureTheory.volume (Set.Univ : Set α) = 0",
    "∀ {α : Type u_1} [inst : MeasurableSpace α], ∀ (s : Set α), ↑↑MeasureTheory.volume s = 0"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, CompactSpace α → IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsCompact s → IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, CompactSpace α → IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), CompactSpace s",
    "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (s : Set α), IsCompact s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsCompact s → ∀ (t : Set α), IsCompact t",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsCompact s → CompactSpace α → IsCompact s"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (t : Set α), IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ x ∈ s, ∃ t, IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {α : Type u_1} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (c : Set α), IsClosed c ∧ x ∈ c) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (t : Set α) (h : IsClosed t), x ∈ t ∧ t ⊆ s) → IsClosed s",
    "∀ {X : Type u} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x : X, x ∈ A → ∃ (C : Set X), IsClosed C ∧ x ∈ C) → IsClosed A",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (c : Set α), IsClosed c ∧ x ∈ c) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → (∃ (t : Set α), IsClosed t ∧ x ∈ t ∧ t ⊆ s)) → IsClosed s",
    "∀ {α : Type u} [inst : TopologicalSpace α] {S : Set α},\n  (∀ (x : α), x ∈ S → (∃ (C : Set α), IsClosed C ∧ x ∈ C ∧ C ⊆ S))\n    → IsClosed S",
    "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n(∀ (x : α), x ∈ s → ∃ (t : Set α), IsClosed t ∧ x ∈ t ∧ t ⊆ s) → IsClosed s"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u} [inst : Group G] {x : G}, IsOfFinOrder x → x = 1",
    "∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x → x = 1",
    "∀ {G : Type u_1} [inst : Group G] (a : G), IsOfFinOrder a → a = 1",
    "∀ {G : Type u_1} [inst : Group G] {g : G}, IsOfFinOrder g → g = 1",
    "∀ {α : Type u_1} [inst : Group α] {a : α}, IsOfFinOrder a → a = 1",
    "∀ {G : Type u_1} [inst : Monoid G] {x : G}, IsOfFinOrder x → x = 1"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
   "some-correct": null,
   "prompt":
   "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Monoid.IsTorsionFree { x // x ∈ H } → Monoid.IsTorsionFree G",
    "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  (∀ x ∈ H, x ≠ 1 → ∀ n : ℤ, n ≠ 0 → x ^ n ≠ 1) → Monoid.IsTorsionFree G"]},
  {"theorem":
   "∀ {G : Type u} [inst : Group G] (f : G →* G), Function.Injective ↑f → Function.Surjective ↑f",
   "some-correct": null,
   "prompt":
   "Every injective homomorphism from a finitely generated free group to itself is surjective.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : Group α] (f : FreeGroup α →* FreeGroup α),\n  Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {α : Type u} [inst : Group α] (f : FreeGroup α → FreeGroup α),\n  Function.Injective ↑f → Function.Surjective ↑f",
    "∀ {G : Type u} [inst : Group G] (f : G →* G), Function.Injective ↑f → Function.Surjective ↑f"]},
  {"theorem": "∀ {R : Type u_1} [inst : DivisionRing R], IsField R ∨ Finite R",
   "some-correct": null,
   "prompt": "Every division ring is either a field or finite.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : DivisionRing R], IsField R ∨ Finite R",
    "∀ (R : Type u) [inst : DivisionRing R], IsField R ∨ Finite R",
    "∀ (K : Type u_1) [inst : DivisionRing K], IsField K ∨ Finite K"]},
  {"theorem": "∀ (n : ℕ), n ≠ 1 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), n ≠ 0 → ∃ (p1 p2 : ℕ), Nat.Prime p1 ∧ Nat.Prime p2 ∧ n = p1 * p2",
    "∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), ∃ (p₁ p₂ : ℕ), Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ n = p₁ * p₂",
    "∀ (n : ℕ) (h : n ≠ 1), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), n ≠ 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "∀ (n : ℕ), n ≠ 1 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q",
    "¬ (∃ (n : ℕ), ¬ (∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p * q))"]},
  {"theorem": "∀ (n : ℕ), Even n → ∃ m, n = m ^ 2",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (n : ℕ), Even n → ∃ (m : ℕ), n = m ^ 2",
    "∀ {n : ℕ}, Even n → ∃ (m : ℕ), n = m ^ 2",
    "∀ {n : ℕ}, Even n → ∃ (m : ℕ), m * m = n",
    "∀ {n : ℕ}, Even n → ∃ (x : ℕ), n = x ^ 2"]},
  {"theorem":
   "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
   "some-correct": null,
   "prompt": "Every normal subgroup of a group has finite index.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u} [inst : Group G] (N : Subgroup G) [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G}, Subgroup.Normal N → Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [self : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] {N : Subgroup G} [h : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u} [inst : Group G] {N : Subgroup G} [inst_1 : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [hN : Subgroup.Normal N], Subgroup.FiniteIndex N",
    "∀ {G : Type u_1} [inst : Group G] (N : Subgroup G) [hNG : Subgroup.Normal N], Subgroup.FiniteIndex N"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P], ∃! M, Ideal.IsMaximal M ∧ P ≤ M",
   "some-correct": null,
   "prompt":
   "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [hP : Ideal.IsPrime P],\n  ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R], ∀ {P : Ideal R}, Ideal.IsPrime P → (∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M)",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R),\n  Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R], ∀ (P : Ideal R),\n  Ideal.IsPrime P → ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R] {P : Ideal R} [self : Ideal.IsPrime P],\n  ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [Ideal.IsPrime P], ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M",
    "∀ {R : Type u} [inst : CommRing R] (P : Ideal R) [ideal_prime : Ideal.IsPrime P],\n  ∃! (M : Ideal R), Ideal.IsMaximal M ∧ P ≤ M"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [UniformSpace α] [UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
    "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ s : Set α, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ {s : Set α}, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ {s : Set α}, IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ (s : Set α), IsCompact s → IsClosed s), CompactSpace α",
    " ∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α],\n  (∀ (K : Set α), IsCompact K → IsClosed K) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α], (∀ (K : Set α), IsCompact K → IsClosed K) → CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α]\n  (h : ∀ (s : Set α), IsCompact s → IsClosed s),\n  CompactSpace α",
    "∀ {α : Type u} [inst : TopologicalSpace α] (h : ∀ {K : Set α}, IsCompact K → IsClosed K), CompactSpace α"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u_1} [inst : CommRing R] {a b : R},\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    "∀ {R : Type u_1} [inst : CommRing R] (a b : R), IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    "∀ {R : Type u_1} [inst : CommRing R] {a b : R}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    "∀ {R : Type u_1} [self : CommRing R] {a b : R},\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    "∀ {α : Type u_1} [self : CommRing α] {a b : α}, IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)",
    "∀ {α : Type u_1} [inst : CommRing α] {a b : α},\n  IsIdempotentElem a → IsIdempotentElem b → IsIdempotentElem (a + b)"]},
  {"theorem":
   "∀ {α : Type u} (P : α → α → Prop), (∃ m, ∀ (a : α), P a m) → ∃! m, ∀ (a : α), P m a",
   "some-correct": null,
   "prompt":
   "If a poset has a maximal element, then it has a unique minimal element.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} (P : α → α → Prop),\n  (∃ m : α, ∀ a : α, ¬ P a m) → (∃! m : α, ∀ a : α, ¬ P a m)",
    "∀ {α : Type u_1} {r : α → α → Prop},\n  (∀ (c : Set α), IsChain r c → ∃ ub, ∀ (a : α), a ∈ c → r a ub) →\n    (∀ {a b c : α}, r a b → r b c → r a c) → (∃ m, ∀ (a : α), r m a → r a m) →\n    (∃! (m : α), ∀ (a : α), r a m → r m a)",
    "∀ {α : Type u} (r : α → α → Prop),\n  (∃ (m : α), (∀ (a : α), r a m → a = m) ∧ (∃ (x : α), r x m)) →\n  (∃! (l : α), ∀ (b : α), r l b → l = b)",
    "∀ {α : Type u} {r : α → α → Prop},\n  (∃ (m : α), ∀ (a : α), r a m → a = m) → (∃! (l : α), ∀ (a : α), r l a → l = a)\n",
    "∀ {α : Type u} (P : α → α → Prop),\n  (∃ (m : α), ∀ (x : α), P x m) → ∃! (n : α), ∀ (y : α), P n y → P y n",
    "∀ {α : Type u_1} (P : α → α → Prop) [IsPartialOrder α P],\n  (∃ (m : α), ∀ (x : α), ¬P x m) →\n  (∃! (xmin : α), ∀ (x : α), xmin ≠ x → P xmin x)",
    "∀ {α : Type u} [inst : PartialOrder α] (s : Set α),\n  (∃ m, ∀ (a : α), a ∈ s → a ≤ m) → (∃! (m : α), m ∈ s ∧ ∀ (a : α), a ∈ s → m ≤ a)",
    "∀ {α : Type u_1} (r : α → α → Prop),\n  (∃ (m : α), ∀ (a : α), r a m → a = m) →\n  (∃! (min : α), ∀ (a : α), min ≠ a → r min a)",
    "∀ {α : Type u_1} {r : α → α → Prop} (x : α),\n  (∀ y : α, r x y → y = x) → ∃! y : α, ∀ z : α, r z y → z = y",
    "∀ {α : Type u} (P : α → α → Prop),\n  (∃ (m : α), ∀ (a : α), P a m) → (∃! (m : α), ∀ (a : α), P m a)"]},
  {"theorem":
   "∀ {f : ℝ → ℝ}, (∃ x, 0 ≤ x ∧ x ≤ 1 ∧ f x = x) → ∀ (n : ℕ), ∃ y, 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {f : ℝ → ℝ}, (∃ (x : ℝ), x ∈ Set.range f ∧ f x = x) → ∀ (n : ℕ), ∃ (y : ℝ), y ∈ Set.range f ∧ Function.IsPeriodicPt f n y",
    "∀ {f : ℝ → ℝ}, (∃ (x : ℝ), x ∈ Set.Icc 0 1 ∧ f x = x) → ∀ (n : ℕ), ∃ (y : ℝ), y ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n y",
    "∀ (f : ℝ → ℝ),\n  Continuous f → (∃ (x : ℝ), x ∈ set.Icc 0 1 ∧ f x = x) →\n  ∀ (n : ℕ), ∃ (x : ℝ), x ∈ set.Icc 0 1 ∧ Function.IsPeriodicPt f n x",
    "∀ (f : ℝ → ℝ), (∃ (x : ℝ), x ∈ Set.Icc 0 1 ∧ f x = x) → ∀ (n : ℕ), ∃ (y : ℝ), y ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n y",
    "∀ {f : ℝ → ℝ},\n  (∃ x ∈ Set.Icc 0 1, f x = x) → ∀ (n : ℕ), ∃ x ∈ Set.Icc 0 1, Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, Continuous f → (∃ (x : ℝ), 0 ≤ x ∧ x ≤ 1 ∧ f x = x) → ∀ (n : ℕ), ∃ (x : ℝ), 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ},\n  (∃ x : ℝ, x ∈ Set.Icc 0 1 ∧ f x = x) → ∀ (n : ℕ), ∃ x : ℝ, x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, (∃ (x : ℝ), Function.IsFixedPt f x) → ∀ (n : ℕ), ∃ (x : ℝ), Function.IsPeriodicPt f n x",
    "∀ {f : ℝ → ℝ}, (∃ (x : ℝ), 0 ≤ x ∧ x ≤ 1 ∧ f x = x) → ∀ (n : ℕ), ∃ (y : ℝ), 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y"]},
  {"theorem": "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
   "some-correct": null,
   "prompt":
   "The complement of the union of two sets contains the union of their complements.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ ⊇ sᶜ ∪ tᶜ",
    "∀ {α : Type u} (s t : Set α), (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} (A B : Set α), (A ∪ B)ᶜ ⊆ Aᶜ ∩ Bᶜ",
    "∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ ⊆ sᶜ ∩ tᶜ",
    "∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ = sᶜ ∩ tᶜ",
    "∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ ⊇ sᶜ ∩ tᶜ",
    "∀ {α : Type u} {S T : Set α}, (S ∪ T)ᶜ = Sᶜ ∩ Tᶜ",
    "∀ {α : Type u} {A B : Set α}, (A ∪ B)ᶜ ⊇ Aᶜ ∪ Bᶜ"]},
  {"theorem": "∀ (q : ℚ), (∃ r, q = r * r) → ∃ s, q = s * s",
   "some-correct": null,
   "prompt": "The square root of an rational number is rational.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (q : ℚ), q ≥ 0 → ∃ (r : ℚ), r ≥ 0 ∧ r * r = q",
    "∀ q : ℚ, ∃ r : ℚ, r * r = q ∧ ¬ Irrational r",
    "∀ {q : ℚ}, q ≥ 0 → (∃ r : ℚ, q = r * r) → (∃ r : ℚ, Real.sqrt q = ↑r)",
    "∀ {q : ℚ}, q ≥ 0 → ∃ (r : ℚ), q = r * r                                                            \n",
    "∀ (q : ℚ), (∃ (r : ℚ), q = r * r) → ∃ (s : ℚ), q = s * s",
    "∀ (q : ℚ), q ≥ 0 → (∃ (r : ℚ), r * r = q) → (∃ (s : ℚ), s * s = q)",
    "∀ {q : ℚ}, q ≥ 0 → ∃ r : ℚ, r ≥ 0 ∧ r * r = q"]},
  {"theorem":
   "(R : Type u_1) →\n  (M : Type u_2) → [inst : Ring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Module.Free R M → CommRing R",
   "some-correct": null,
   "prompt": "If a module over a ring is free, then the ring is commutative.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [inst_3 : Module.Free R M],\n  CommRing R",
    "∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R",
    "∀ (R : Type u_1) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R",
    "∀ {R : Type u_1} {M : Type u_2} [inst_1 : Ring R] [inst_2 : AddCommGroup M] [inst_3 : Module R M]\n  [inst_4 : Module.Free R M], CommRing R",
    "∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n  [inst_3 : Module R M] [inst_4 : Module.Free R M], CommRing R",
    "∀ (R : Type u_1) (M : Type u_2) [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommSemiring R",
    "∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommRing R",
    "∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  [inst_3 : Module.Free R M], CommSemiring R",
    "∀ (R : Type u_1) (M : Type u_2) [inst : Ring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M],\n  Module.Free R M → CommRing R"]},
  {"theorem":
   "{R : Type u_1} →\n  [inst : Semiring R] → (units : Type u_2) → [grp : Group units] → (∀ (a b : units), a * b = b * a) → CommSemiring R",
   "some-correct": null,
   "prompt":
   "If the set of units of a ring forms a group then the ring is commutative.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} [inst : Semiring R] {x y : R}, IsUnit x → IsUnit y → x * y = y * x",
    "∀ {R : Type u_1} [inst : Semiring R] (units : Type u_2) [grp : Group units],\n  (∀ (a b : units), a * b = b * a) → CommSemiring R"]},
  {"theorem": "∀ {n : ℕ}, n > 10 → ∃ x p, n = x ^ 2 + p ∧ Nat.Prime p",
   "some-correct": null,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {n : ℕ}, 10 < n → ∃ (p : ℕ), prime p ∧ ∃ (k : ℕ), n = p + k ^ 2",
    "∀ {n : ℕ}, n > 10 → ∃ (x : ℕ) (p : ℕ), n = x ^ 2 + p ∧ Nat.Prime p",
    "∀ (n : ℕ), 10 < n → ∃ (x : ℕ), Prime x ∧ ∃ (y : ℕ), n = x ^ 2 + y",
    "∀ (n : ℕ), 10 < n → ∃ (x y : ℕ), n = x^2 + y ∧ Nat.Prime y",
    "∀ (n : ℕ), n > 10 → ∃ (a p : ℕ), n = a ^ 2 + p ∧ Nat.Prime p",
    "∀ {n : ℕ}, n > 10 → ∃ (p : ℕ), p > 1 ∧ Nat.Prime p ∧ ∃ (k : ℕ), n = k ^ 2 + p",
    "∀ (n : ℕ), 10 < n → ∃ (x p : ℕ), n = x^2 + p ∧ Nat.Prime p",
    "∀ {n : ℕ}, 10 < n → ∃ (p q : ℕ), Nat.Prime p ∧ n = p ^ 2 + q",
    "∀ (n : ℕ), n > 10 → ∃ (x : ℕ) (p : ℕ), n = x ^ 2 + p ∧ Nat.Prime p",
    "∀ (n : ℕ), 10 < n → ∃ (a p : ℕ), n = a^2 + p ∧ Nat.Prime p",
    "∀ {n : ℕ}, 10 < n → ∃ (x : ℕ) (p : ℕ), n = x ^ 2 + p ∧ Nat.Prime p",
    "∀ {n : ℕ}, 10 < n → ∃ (p : ℕ), Nat.Prime p ∧ ∃ (m : ℕ), n = m ^ 2 + p",
    "∀ (n : ℕ), 10 < n → ∃ (x : ℕ) (p : ℕ), n = x ^ 2 + p ∧ Nat.Prime p"]},
  {"theorem":
   "(C : Type u₁) →\n  [inst : CategoryTheory.Category C] → CategoryTheory.Limits.IsInitial C ≃ CategoryTheory.Limits.IsTerminal C",
   "some-correct": null,
   "prompt":
   "The initial object of a category is isomorphic to its terminal object.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ (C : Type u₁) [inst : CategoryTheory.Category C], CategoryTheory.Limits.IsInitial C ≃ CategoryTheory.Limits.IsTerminal C"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} {γ : Type x} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g",
   "some-correct": null,
   "prompt":
   "If the composition of two functions is continuous, then each of them is continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z]\n  {f : X → Y} {g : Y → Z},\n  Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {α : Type u} {β : Type v} {γ : Type x} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ] {f : α → β}\n  {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z]\n  {f : X → Y} {g : Y → Z},\n  Continuous (Function.comp g f) → Continuous f ∧ Continuous g",
    "∀ {X : Type u} {Y : Type v} {Z : Type w} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z]\n  {f : X → Y} {g : Y → Z}, Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {X : Type u} {Y : Type v} {Z : Type x} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : TopologicalSpace Z]\n  {f : X → Y} {g : Y → Z},\n  Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  [inst_2 : TopologicalSpace Z] {f : X → Y} {g : Y → Z},\n  Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {α : Type u} {β : Type v} {γ : Type x} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous f ∧ Continuous g",
    "∀ {α : Type u} {β : Type v} {γ : Type w} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous g ∧ Continuous f",
    "∀ {α : Type u} {β : Type v} {γ : Type x} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ]\n  {f : α → β} {g : β → γ},\n  Continuous (g ∘ f) → Continuous f ∧ Continuous g"]},
  {"theorem":
   "∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute b c → AddCommute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
    "∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b → AddCommute b c → AddCommute a c",
    "∀ {S : Type u_1} [inst : AddSemigroup S] {a b c : S}, AddCommute a b -> AddCommute b c ->AddCommute a c"]},
  {"theorem":
   "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {r : R},\n  ?m.25721660 = 0 → r = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) (x : R),\n  ↑f x = 0 → x = 0",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {x : R}, ↑f x = 0 → x = 0",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {x : R},\n  ↑f x = 0 → x = 0",
    "∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocSemiring α] [inst_1 : NonAssocSemiring β] (f : α →+* β) {x : α},\n  ↑f x = 0 → x = 0",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R},\n  (↑f r = 0) → (r = 0)",
    "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {r : R},\n  ↑f r = 0 → r = 0",
    "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a : α),\n  ↑f a = 0 → a = 0",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {r : R},\n  ↑f r = 0 → r = 0",
    "∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} {f : α →+* β} {a : α},\n  ↑f a = 0 → a = 0",
    "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] (f : R →+* S) (x : R),\n  ↑f x = 0 → x = 0",
    "∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f : R →+* S} {x : R}, ⟦x⟧ = 0 → x = 0",
    "∀ {R : Type u_1} {S : Type u_2} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S] {f : R →+* S} {r : R}, ↑f r = 0 → r = 0"]},
  {"theorem": "∀ {p q : Prop}, (p → q) → q → p",
   "some-correct": null,
   "prompt": "Implication `→` is symmetric. If `P → Q` then `Q → P`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {p q : Prop}, (p → q) → q → p",
    "∀ {p q : Prop}, (p → q) → (q → p)",
    "∀ {P Q : Prop}, (P → Q) → (Q → P)",
    "∀ {P Q : Prop}, (P → Q) → Q → P"]},
  {"theorem": "∀ {m n : ℕ}, (∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
   "some-correct": null,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {m n : ℕ}, (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n) ↔ m = n",
    "∀ {m n : ℕ}, (Exists (fun (p : ℕ) => Nat.Prime p ∧ (p ∣ m ∧ p ∣ n))) ↔ m = n",
    "∀ {m n : ℕ}, m = n ↔ (∃ (p : ℕ), Nat.Prime p ∧ p ∣ m ∧ p ∣ n)"]}],
 "elaborated": 32}