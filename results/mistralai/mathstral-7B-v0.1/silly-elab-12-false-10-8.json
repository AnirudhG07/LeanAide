{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 10,
 "number-similar-sentences": 12,
 "include-fixed": false,
 "failures":
 ["Every subgroup of a group is a group.", "There is no field of order `10`."],
 "elaborated-prompts":
 [{"theorem": "∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "groups":
   [["∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
     "∀ {p : ℕ}, p.Prime → p = 2 ∨ Odd p",
     "∀ {n : ℕ}, n.Prime → n = 2 ∨ Odd n",
     "∀ {n : ℕ}, n.Prime → n = 2 ∨ Odd n"],
    ["∀ (p : ℕ) [inst : Fact p.Prime], p = 2 ∨ Odd p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p ",
    " ∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p ",
    " ∀ {n : ℕ}, Nat.Prime n → n = 2 ∨ Odd n ",
    " ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ",
    " ∀ {n : ℕ}, Nat.Prime n → n = 2 ∨ Odd n",
    " ∀ {n : ℕ}, Nat.Prime n → n = 2 ∨ Odd n",
    " ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p"]},
  {"theorem": "∀ {a : ℕ}, a ∈ {b | b % 2 = 1} → {b | b % 2 = 1}.Infinite",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "groups":
   [["∀ {a : ℕ}, a ∈ {b | b % 2 = 1} → {b | b % 2 = 1}.Infinite"],
    ["{n | n % 2 = 1}.Infinite"],
    ["∀ (n : ℕ), ∃ m > n, Odd m ∧ m < n + n"],
    ["{n | ¬Even n}.Infinite"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" Set.Infinite {n : ℕ | n % 2 = 1}",
    " ∀ n : ℕ, ∃ m > n, Odd m ∧ m < n + n",
    " Set.Infinite {n : ℕ | ¬Even n} ",
    " {a : ℕ} → a ∈ {b | b % 2 = 1} → {b | b % 2 = 1}.Infinite "]},
  {"theorem": "3 = Nat.minFac 3 ∧ Nat.Prime 3",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "groups":
   [["3 = Nat.minFac 3 ∧ Nat.Prime 3", "Nat.Prime 3"],
    ["3 = Nat.minFac 6"],
    ["∀ {p : ℕ} [inst : Fact p.Prime], p = 3"],
    ["Nat.Prime 3 ∧ ∀ {p : ℕ}, p.Prime → 3 ≤ p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" Nat.Prime 3 ∧ ∀ {p : ℕ}, Nat.Prime p → 3 ≤ p ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 3",
    " 3 = Nat.minFac (3 : ℕ) ∧ Nat.Prime 3",
    " 3 = Nat.minFac 6",
    " Nat.Prime 3\n\nThe smallest odd prime is `3`. □",
    " ∀ {p : ℕ}, Nat.Prime p → p = 3 ∨ p ≥ 3 ∨ p = 0 ∨ p = 1 ∨ p = 2 ∨ p = 2 ∨ p = 3 ∨ p ≥ 3"]},
  {"theorem": "{p | p.Prime ∧ p % 2 = 1}.Infinite",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "groups":
   [["{p | p.Prime ∧ p % 2 = 1}.Infinite",
     "{p | p.Prime ∧ p % 2 = 1}.Infinite",
     "{p | p.Prime ∧ p % 2 = 1}.Infinite"],
    ["{p | p.Prime ∧ Odd p}.Infinite", "{p | p.Prime ∧ Odd p}.Infinite"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" Set.Infinite {p | Nat.Prime p ∧ Odd p}",
    " Set.Infinite {p | Nat.Prime p ∧ Odd p} ",
    " Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    " Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    " Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ",
    " Set.Infinite {p | Nat.Prime p ∧ p % 2 ≠ 0} ",
    " Set.Infinite {n | Nat.Prime n ∧ n % 2 = 1} ",
    " Set.Infinite {p | p.Prime ∧ Odd p} "]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
     "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Module.rank K V = 2 → FiniteDimensional K V",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Module.rank K V = 2 → FiniteDimensional K V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Module.rank K V = 2 → FiniteDimensional K V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V],\n  Module.rank K V = 2 → FiniteDimensional K V ",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], Module.rank K V = 2 → FiniteDimensional K V",
    " ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (h : Module.rank K V = 2), FiniteDimensional K V "]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "groups":
   [["(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K",
     "(K : Type u) → [inst : Field K] → DivisionRing K"],
    ["{K : Type u_1} → [inst : Field K] → DivisionRing K"],
    ["{K : Type u} → [inst : Field K] → DivisionRing K"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ (K : Type u) [inst : Field K], DivisionRing K ",
    " ∀ (K : Type u) [inst : Field K], DivisionRing K ",
    " ∀ (K : Type u) [inst : Field K], DivisionRing K ",
    " ∀ {K : Type u} [inst : Field K], DivisionRing K ",
    " ∀ {K : Type u_1} [inst : Field K], DivisionRing K ",
    " ∀ (K : Type u_1) [inst : Field K], DivisionRing K ",
    " ∀ (K : Type u_1) [inst : Field K], DivisionRing K",
    " ∀ {α : Type u_1} [inst : Field α], DivisionRing α",
    " ∀ (α : Type u) [inst : Field α], DivisionRing α",
    " ∀ (K : Type u) [inst : Field K], DivisionRing K\n\n---"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {K : Type u} {V : Type v} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], FiniteDimensional.finrank K V = 2 → FiniteDimensional K V"]},
  {"theorem": "∀ (n : ℕ), ∃ m, m = n + 1",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "groups":
   [["∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ m, m = n + 1",
     "∀ (n : ℕ), ∃ s, s = n + 1",
     "∀ (n : ℕ), ∃ next, n.succ = next",
     "∀ (n : ℕ), ∃ s, n.succ = s ∧ s > n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ (n : ℕ), ∃ m, m = n + 1 ",
    " ∀ n : ℕ, ∃ m, m = n + 1",
    " ∀ (n : ℕ), ∃ (s : ℕ), s = n + 1 ",
    " ∀ (n : ℕ), ∃ (next : ℕ), n.succ = next ",
    " ∀ (n : ℕ), ∃ s, n.succ = s ∧ s > n",
    " ∀ n : ℕ, ∃ n' : ℕ, n + 1 = n'",
    " ∀ n : ℕ, ∃ m, n ≠ 0 ∧ (m + 1 = n) ∧ ∀ k, k ≠ m → k ≠ n"]},
  {"theorem": "∀ (n : ℕ), n < n.succ",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "groups":
   [["∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ",
     "∀ (n : ℕ), n < n.succ"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ (n : ℕ), n < n.succ ",
    " ∀ (n : ℕ), n < n.succ ",
    " ∀ (n : ℕ), n < n.succ",
    " ∀ (n : ℕ), n < n.succ",
    " ∀ (n : ℕ), n < n.succ",
    " ∀ n : ℕ, n < n.succ ",
    " ∀ n : ℕ, n < n.succ ",
    " ∀ n : ℕ, n < n.succ",
    " ∀ (n : ℕ), n ≤ n.succ",
    " ∀ {α : Type u_9} [self : PartialOrder α] (n : ℕ), n < n.succ "]},
  {"theorem": "∀ (s : Set ℝ), MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set is Lebesgue measurable.",
   "groups":
   [["∀ (s : Set ℝ), MeasurableSet s", "∀ (s : Set ℝ), MeasurableSet s"],
    ["∀ {α : Type u_8} [inst : MetricSpace α] [self : MeasurableSpace α] (s : Set α), MeasurableSet s"],
    ["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ (s : Set ℝ), MeasurableSet s ",
    " ∀ (s : Set ℝ), MeasurableSet s",
    " ∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s",
    " ∀ {α : Type u_8} [inst : MetricSpace α] [self : MeasurableSpace α], ∀ (s : Set α), MeasurableSet s"]},
  {"theorem":
   "∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] (s : Set α),\n  ?m.276070 s = 0 → MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "groups":
   [["∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] (s : Set α),\n  ?m.276070 s = 0 → MeasurableSet s"],
    ["∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] (s : Set α),\n  ?m.275820 s = 0 → MeasurableSet s"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α], ∀ (s : Set α), ↑↑MeasureTheory.volume s = 0 → MeasurableSet s",
    " ∀ {α : Type u_6} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α] (s : Set α), ↑↑MeasureTheory.volume s = 0 → MeasurableSet s"]},
  {"theorem": "∀ {p : ℕ}, p.Prime → ¬IsSquare p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "groups":
   [["∀ {p : ℕ}, p.Prime → ¬IsSquare p",
     "∀ {p : ℕ}, p.Prime → ¬IsSquare p",
     "∀ {p : ℕ}, p.Prime → ¬IsSquare p",
     "∀ {n : ℕ}, n.Prime → ¬IsSquare n",
     "∀ {n : ℕ}, n.Prime → ¬IsSquare n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p ",
    " ∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p ",
    " ∀ {p : ℕ}, Nat.Prime p → ¬IsSquare p ",
    " ∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n ",
    " ∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n ",
    " ∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n ",
    " ∀ {n : ℕ}, Nat.Prime n → ¬IsSquare n ",
    " ∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ",
    " ∀ n : ℕ, Nat.Prime n → ¬IsSquare n ",
    " ∀ {p m : ℕ}, Nat.Prime p → ¬IsSquare p "]},
  {"theorem": "∀ {p : ℕ} [inst : Fact p.Prime], p ≠ 2 → p > 2",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "groups":
   [["∀ {p : ℕ} [inst : Fact p.Prime], p ≠ 2 → p > 2",
     "∀ {p : ℕ} [inst : Fact p.Prime], p ≠ 2 → 2 < p"],
    ["∀ {p : ℕ} [inst : Fact p.Prime], Odd p → p > 2",
     "∀ {p : ℕ} [inst : Fact p.Prime], Odd p → p > 2"],
    ["∀ {p : ℕ}, Odd p → p.Prime → 2 < p"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → p > 2 ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → 2 < p ",
    " ∀ {p : ℕ}, Odd p → Nat.Prime p → 2 < p ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], (Odd p → p > 2)",
    " ∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n ≠ 2 → n > 2 ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 1 → p > 2 ",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {h : Fact (Odd p)}, p > 2",
    " ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 \n\nNote: This theorem is true if we consider that `2` is not an odd prime. If we consider `2` as an odd prime, then the theorem is false."]},
  {"theorem":
   "∀ (a b x y z u v w : ℕ),\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + w ^ 2 + z ^ 2 → ∃ r s p q, a * b = r ^ 2 + s ^ 2 + p ^ 2 + q ^ 2",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "groups":
   [["∀ (a b x y z u v w : ℕ),\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + w ^ 2 + z ^ 2 → ∃ r s p q, a * b = r ^ 2 + s ^ 2 + p ^ 2 + q ^ 2",
     "∀ (a b x y z u v w : ℕ),\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + w ^ 2 + z ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2"],
    ["∀ {R : Type u_1} [inst : CommRing R] {a b c d x y z w : R},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = c ^ 2 + d ^ 2 + y ^ 2 + w ^ 2 → a * b = x * c + y * d + z * w"],
    ["∀ {a b c d x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + c ^ 2 + d ^ 2 → ∃ r s p q, a * b = r ^ 2 + s ^ 2 + p ^ 2 + q ^ 2"],
    ["∀ {R : Type u_1} [inst : CommRing R] {a b : R} {c d : R} {x y z w : R},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → ∃ r p q m, a * b = r ^ 2 + p ^ 2 + q ^ 2 + m ^ 2"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {a b c d x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + c ^ 2 + d ^ 2 → ∃ r s p q, a * b = r ^ 2 + s ^ 2 + p ^ 2 + q ^ 2 ",
    " ∀ (a b x y z u v w : ℕ), a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + w ^ 2 + z ^ 2 → ∃ r s p q, a * b = r ^ 2 + s ^ 2 + p ^ 2 + q ^ 2 ",
    " ∀ (a b x y z u v w : ℕ),\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + w ^ 2 + z ^ 2 → ∃ r s t k, a * b = r ^ 2 + s ^ 2 + t ^ 2 + k ^ 2 ",
    " ∀ {R : Type u_1} [inst : CommRing R] {a b c d x y z w : R},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + t ^ 2 + s ^ 2 →\n    ∃ r p q m, a * b = r ^ 2 + p ^ 2 + q ^ 2 + m ^ 2 ",
    " ∀ {R : Type u_1} [inst : CommRing R], ∀ {a b c d x y z w : R},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  b = c ^ 2 + d ^ 2 + y ^ 2 + w ^ 2 →\n  a * b = x * c + y * d + z * w",
    " ∀ {a b c d x y z w : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = c ^ 2 + d ^ 2 + (y + w) ^ 2 + (z + x) ^ 2 → a * b = c ^ 2 + d ^ 2 + (y + w - z - x) ^ 2 + (z + x + w + y) ^ 2 "]},
  {"theorem":
   "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "groups":
   [["∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
     "∀ {X : Type u} [inst : TopologicalSpace X] [self : CompactSpace X], LocallyCompactSpace X"],
    ["∀ {X : Type u_1} [inst : TopologicalSpace X] [self : CompactSpace X], LocallyCompactSpace X"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] [self : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    " ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X",
    " ∀ {X : Type u} [inst : TopologicalSpace X] [self : CompactSpace X], LocallyCompactSpace X ",
    " ∀ {X : Type u_2} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X ",
    " ∀ (self : CompHaus), LocallyCompactSpace ↑self.toTop ",
    " ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : CompactSpace α], LocallyCompactSpace α ",
    " ∀ {X : Type u} [inst : TopologicalSpace X] {self : CompactSpace X}, LocallyCompactSpace X ",
    " ∀ {X : Type v} [inst : TopologicalSpace X] [inst_1 : CompactSpace X], LocallyCompactSpace X"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → ∀ [inst_2 : (uniformity α).NeBot], UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → ∀ [inst_2 : (uniformity α).NeBot], UniformContinuous f"],
    ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ",
    " ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → ∀ [inst_2 : Filter.NeBot (uniformity α)], UniformContinuous f "]},
  {"theorem": "¬∃ p q, p.Prime ∧ q.Prime ∧ p ≠ q ∧ p + q = 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "groups":
   [["¬∃ p q, p.Prime ∧ q.Prime ∧ p ≠ q ∧ p + q = 6",
     "¬∃ p q, p.Prime ∧ q.Prime ∧ p ≠ q ∧ p + q = 6",
     "∀ {p q : ℕ}, p.Prime → q.Prime → p ≠ q → p + q ≠ 6"],
    ["¬∃ m n, m.Prime ∧ n.Prime ∧ m + n = 6"],
    ["¬∃ p q, p.Prime → q.Prime → p + q = 6"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ",
    " ¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6",
    " ¬∃ (p q : ℕ), Nat.Prime p → Nat.Prime q → p + q = 6",
    " ∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6 ",
    " ¬∃ m n : ℕ, Nat.Prime m ∧ Nat.Prime n ∧ m + n = 6 ",
    " ∀ (p q : ℕ), p ≠ q → Nat.Prime p → Nat.Prime q → p + q ≠ 6",
    " ¬(∃ (p q : ℕ), p ≠ q ∧ Nat.Prime p ∧ Nat.Prime q ∧ p + q = 6) ",
    " ∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → ¬(p + q = 6) ",
    " ¬∃ (p q : ℕ) (h : Nat.Prime p), Nat.Prime q → 6 = p + q ∧ p ≠ q",
    " ¬(∃ p q : ℕ, p + q = 6 ∧ p ≠ q ∧ Nat.Prime p ∧ Nat.Prime q)"]},
  {"theorem": "∀ (n : ℤ), ¬Irrational ↑n",
   "some-correct": null,
   "prompt": "No integer is irrational.",
   "groups":
   [["∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (n : ℤ), ¬Irrational ↑n",
     "∀ (x : ℤ), ¬Irrational ↑x",
     "∀ {a : ℤ}, ¬Irrational ↑a",
     "∀ {n : ℤ}, ¬Irrational ↑n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ (n : ℤ), ¬Irrational ↑n ",
    " ∀ (n : ℤ), ¬Irrational ↑n",
    " ∀ (x : ℤ), ¬Irrational x",
    " ∀ {a : ℤ}, ¬Irrational a",
    " ∀ {n : ℤ}, ¬Irrational (↑n) ",
    " ∀ (x : ℤ), ¬Irrational ↑x",
    " ∀ (a : ℤ), ¬Irrational (↑a) ",
    " ∀ q : ℤ, ¬Irrational ↑q ",
    " ∀ {a : ℤ}, ¬Irrational a ∧ Nat.succ 0 < a → a = 0",
    " ∀ x : ℤ, ¬∃ (q : ℚ), Rat.cast x = q"]},
  {"theorem": "∀ {α : Type u} [inst : Ring α], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "groups":
   [["∀ {α : Type u} [inst : Ring α], IsUnit 1",
     "∀ {α : Type u_1} [inst : Ring α], IsUnit 1",
     "∀ {α : Type u_1} [inst : Ring α], IsUnit 1",
     "∀ {α : Type u} [inst : Ring α], 1 * 1 = 1 ∧ 1 * 1 = 1 ∧ 1 * 1 = 1",
     "∀ {R : Type u} [inst : Ring R], IsUnit 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} [inst : Ring α], IsUnit 1",
    " ∀ {α : Type u_1} [inst : Ring α], IsUnit 1 ",
    " ∀ {α : Type u_1} [inst : Ring α], IsUnit 1",
    " ∀ {α : Type u} [inst : Ring α], 1 * 1 = 1 ∧ 1 * 1 = 1 ∧ 1 * 1 = 1",
    " ∀ {R : Type u} [inst : Ring R], IsUnit (1 : R)\n\nThis statement means that in a ring, the element `1` is a unit. A unit in a ring is an element that has a multiplicative inverse, and `1` is always a unit in any ring because it has a multiplicative inverse, which is itself.",
    " ∀ {α : Type u} [inst : Ring α], IsUnit 1 ∧ IsUnit 0\n\nAlthough I'm not clear on the \"in a ring is a unit\" part. The translation could be:\n\n∀ (R : Type u) [inst : Ring R], ∃ r : R, IsUnit r"]},
  {"theorem": "∀ {m n : ℕ}, ∃ k, m + n = k",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "groups":
   [["∀ {m n : ℕ}, ∃ k, m + n = k",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {a b : ℕ}, ∃ c, a + b = c",
     "∀ {m n : ℕ}, ∃ k, k = m + n"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {m n : ℕ}, ∃ k : ℕ, m + n = k ",
    " ∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    " ∀ {a b : ℕ}, ∃ c : ℕ, a + b = c",
    " ∀ {m n : ℕ}, ∃ k : ℕ, k = m + n "]},
  {"theorem": "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "groups":
   [["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
     "∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"],
    ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    " ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    " ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    " ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ",
    " ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ",
    " ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ",
    " ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
    " ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1",
    " ∀ {α : Type u} [inst : Group α], IsOfFinOrder 1 "]},
  {"theorem": "Nat.Prime 7 → True ∧ True",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "groups":
   [["Nat.Prime 7 → True ∧ True"],
    ["Fact (Nat.Prime 7)"],
    ["Prime 7"],
    ["∀ (n : ℕ), n = 7 → n.Prime"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" Fact (Nat.Prime 7)",
    " Prime 7 ",
    " ∀ n : ℕ, n = 7 → Nat.Prime n ",
    " (h : Nat.Prime 7) → True ∧ True"]},
  {"theorem":
   "∀ (x : ℕ),\n  (x < 8 → ∃ y m, y.Prime ∧ y = x - m ∨ x = m) ↔\n    x = 2 ∨ x = 3 ∨ x = 7 ∨ x = 5 ∨ x = 0 ∨ x = 1 ∨ x = 4 ∨ x = 6 ∨ x = 8 ∨ x = 9",
   "some-correct": null,
   "prompt": "There are `3` prime numbers below `8`.",
   "groups":
   [["∀ (x : ℕ),\n  (x < 8 → ∃ y m, y.Prime ∧ y = x - m ∨ x = m) ↔\n    x = 2 ∨ x = 3 ∨ x = 7 ∨ x = 5 ∨ x = 0 ∨ x = 1 ∨ x = 4 ∨ x = 6 ∨ x = 8 ∨ x = 9"],
    ["∃ p q r, p.Prime ∧ q.Prime ∧ r.Prime ∧ p < 8 ∧ q < 8 ∧ r < 8"],
    ["∃ x y z, x.Prime ∧ y.Prime ∧ z.Prime ∧ x + y + z = 8"],
    ["∀ (n : ℕ), (n ≥ 3 → n < 8 ∨ n ≥ 10) ∨ n < 3 ∨ n = 2 ∨ n = 5 ∨ n = 7"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∃ (p q r : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ Nat.Prime r ∧ p < 8 ∧ q < 8 ∧ r < 8",
    " ∃ (x y z : ℕ), Nat.Prime x ∧ Nat.Prime y ∧ Nat.Prime z ∧ x + y + z = 8",
    " ∀ (n : ℕ), (n ≥ 3 → n < 8 ∨ n ≥ 10) ∨ n < 3 ∨ n = 2 ∨ n = 5 ∨ n = 7",
    " ∀ (x : ℕ), x < 8 → (∃ (y m : ℕ), Nat.Prime y ∧ y = x - m ∨ x = m) ↔ x = 2 ∨ x = 3 ∨ x = 7 ∨ x = 5 ∨ x = 0 ∨ x = 1 ∨ x = 4 ∨ x = 6 ∨ x = 8 ∨ x = 9"]},
  {"theorem": "∀ {α : Type u_1} {s : Finset α}, ∅ ⊆ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "groups":
   [["∀ {α : Type u_1} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u_1} {s : Set α}, ∅ ⊆ s",
     "∀ {α : Type u_1} {s : Finset α}, ∅ ⊆ s",
     "∀ {α : Type u} (a : Finset α), ∅ ⊆ a",
     "∀ {α : Type u} (a : Finset α), ∅ ⊆ a"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u_1} {s : Finset α}, ∅ ⊆ s ",
    " ∀ {α : Type u_1} {s : Set α}, ∅ ⊆ s ",
    " ∀ {α : Type u_1} {s : Finset α}, ∅ ⊆ s",
    " ∀ {α : Type u} (a : Finset α), ∅ ⊆ a ",
    " ∀ {α : Type u} (a : Finset α), ∅ ⊆ a ",
    " ∀ {α : Type u} (a : Set α), ∅ ⊆ a",
    " ∀ {α : Type u_1} {s : Finset α}, ∅ ⊆ ↑s "]},
  {"theorem":
   "∀ {α : Type u} (s : Set α), ∃ t, t.Finite ∧ t ⊆ s ∧ ∀ x ∈ s, x ∈ t",
   "some-correct": null,
   "prompt": "Every infinite set contains a finite set.",
   "groups":
   [["∀ {α : Type u} (s : Set α), ∃ t, t.Finite ∧ t ⊆ s ∧ ∀ x ∈ s, x ∈ t"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} (s : Set α), ∃ t : Set α, Set.Finite t ∧ t ⊆ s ∧ ∀ (x : α), (x ∈ s) → x ∈ t"]},
  {"theorem": "{R : Type u_1} → [inst : CommRing R] → CommMonoid R",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "groups":
   [["{R : Type u_1} → [inst : CommRing R] → CommMonoid R"],
    ["{R : Type u} → [inst : CommRing R] → Monoid R"],
    ["{α : Type u} → [inst : CommRing α] → Monoid α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {R : Type u} [inst : CommRing R], Monoid R ",
    " ∀ {α : Type u} [inst : CommRing α], Monoid α",
    " ∀ {R : Type u_1} [inst : CommRing R], CommMonoid R "]},
  {"theorem": "∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "groups":
   [["∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b",
     "∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b",
     "∀ (n : ℕ), Odd n → ∃ x y, n = x + y ∧ x ≠ y"],
    ["∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ x + y = n"],
    ["∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ x + y = n ",
    " ∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ",
    " ∀ {n : ℕ}, Odd n → ∃ a b, n = a + b ∧ a ≠ b",
    " ∀ {n : ℕ}, Odd n → ∃ a b : ℕ, n = a + b ∧ a ≠ b",
    " ∀ (n : ℕ), Odd n → ∃ x y : ℕ, n = x + y ∧ x ≠ y",
    " ∀ {n : ℕ}, Odd n → ∃ m k, n = m + (m + k)",
    " ∀ {n : ℕ}, n % 2 ≠ 0 → ∃ (x y : ℕ), x ≠ y ∧ n = x + y",
    " ∀ (n : ℕ), (Even n ∨ ¬Even n) ↔ ∃ a b, a + b = n ∧ a < b ∧ b < n ∧ a ≠ b"]},
  {"theorem": "∀ {α : Type u} [inst : AddGroup α] (x : α), IsOfFinAddOrder x",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "groups":
   [["∀ {α : Type u} [inst : AddGroup α] (x : α), IsOfFinAddOrder x"],
    ["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ∧ IsOfFinOrder 1⁻¹"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ∧ IsOfFinOrder (1⁻¹ : G)",
    " ∀ {α : Type u} [inst : AddGroup α], ∀ x : α, IsOfFinAddOrder x"]},
  {"theorem": "∀ {n : ℤ}, Even n → Even (n ^ 2)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "groups":
   [["∀ {n : ℤ}, Even n → Even (n ^ 2)",
     "∀ {n : ℤ}, Even n → Even (n ^ 2)",
     "∀ (n : ℤ), Even n → Even (n ^ 2)"],
    ["∀ (n : ℤ), Even n → Even (n * n)"],
    ["∀ {n : ℕ}, Even n → Even (n ^ 2)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {n : ℤ}, Even n → Even (n ^ 2)",
    " ∀ {n : ℤ}, Even n → Even (n^2)",
    " ∀ {n : ℕ}, Even n → Even (n^2)",
    " ∀ (n : ℤ), Even n → Even (n ^ 2)",
    " ∀ (n : ℤ), Even n → Even (n * n)",
    " ∀ {n : ℕ}, Even n → IsSquare n",
    " ∀ {a : ℕ}, Even a → Even (a ^ 2)",
    " ∀ {n : ℤ}, Even (n ^ 2) ↔ Even n"]},
  {"theorem":
   "∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "groups":
   [["∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R",
     "∀ {R : Type u} [inst : DivisionRing R] [inst_1 : CommRing R], IsField R"],
    ["∀ {R : Type u} [inst : CommRing R] {inst_1 : IsDomain R} (x y : R),\n  ∃ q, q * y = x ∨ x = 0 ↔ ∀ (x y : R), (x = 0 ↔ y = 0) ∧ ∀ (x y : R), ∃ q, x * q = y ∨ y = 0"],
    ["∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], IsField R"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {R : Type u} [inst : CommRing R] [inst_1 : DivisionRing R], IsField R",
    " ∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R], IsField R",
    " ∀ {R : Type u} [inst : DivisionRing R] [inst_1 : CommRing R], IsField R ",
    " ∀ {R : Type u} [inst : CommRing R] {inst_1 : IsDomain R} (x y : R), ∃ (q : R), q * y = x ∨ x = 0 ↔ ∀ (x y : R), (x = 0 ↔ y = 0) ∧ ∀ (x y : R), ∃ (q : R), x * q = y ∨ y = 0"]},
  {"theorem": "∀ {α : Type u} [inst : Monoid α], id 1 = 1",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "groups": [["∀ {α : Type u} [inst : Monoid α], id 1 = 1"]],
   "correct": null,
   "comments": "",
   "all-elabs": [" ∀ {α : Type u} [inst : Monoid α], (id 1) = 1"]},
  {"theorem": "∀ {α : Type u_1} (x : α), Function.IsFixedPt id x",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "groups":
   [["∀ {α : Type u_1} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u_1} (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u_1} [inst : TopologicalSpace α] (x : α), Function.IsFixedPt id x",
     "∀ {α : Type u_1} [inst : TopologicalSpace α] (x : α), Function.IsFixedPt id x"],
    ["∀ {α : Type u} (x : α), Function.IsFixedPt id x"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u_1} (x : α), Function.IsFixedPt id x ",
    " ∀ {α : Type u_1} (x : α), Function.IsFixedPt (id : α → α) x",
    " ∀ {α : Type u_1} [inst : TopologicalSpace α] (x : α), Function.IsFixedPt id x",
    " ∀ {α : Type u_1} [inst : TopologicalSpace α], ∀ x : α, Function.IsFixedPt id x ",
    " ∀ {α : Type u_1} (x : α), Function.IsFixedPt (fun x => x) x",
    " ∀ {X : Type u_1} [inst : TopologicalSpace X] (x : X), Function.IsFixedPt (id : X → X) x",
    " ∀ {α} (x : α), Function.IsFixedPt id x"]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "groups":
   [["∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
     "∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0 ",
    " ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0 ",
    " ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
    " ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam {x} = 0",
    " ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    " ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    " ∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0",
    " ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α}, EMetric.diam ({x} : Set α) = 0"]},
  {"theorem": "∀ {α : Type u_1} [inst : Group α], Nonempty α",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "groups":
   [["∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {α : Type u_1} [inst : Group α], Nonempty α",
     "∀ {G : Type u_1} [inst : Group G], Nonempty G"],
    ["∀ {α : Type u}, Nonempty α"],
    ["∀ {α : Type u} [inst : Group α], Nonempty α"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u_1} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u_1} [inst : Group α], Nonempty α",
    " ∀ {G : Type u_1} [inst : Group G], Nonempty G ",
    " ∀ {α : Type u} [inst : Group α], Nonempty α ",
    " ∀ {α : Type u}, Nonempty α",
    " ∀ {α : Type u}, Nonempty (Group α) ",
    " ∀ {G : Type u_1} [self : Group G], Nonempty G ",
    " ∀ {G : Type u}, Nonempty G → Group G"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "groups":
   [["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)",
     "∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x) ",
    " ∀ {α : Type u} [inst : TopologicalSpace α], ∀ (x : α), IsConnected (connectedComponent x)",
    " ∀ {α : Type u} [inst : TopologicalSpace α],\n  ∀ (x : α), IsConnected (connectedComponent x)",
    " ∀ {α : Type u} [inst : TopologicalSpace α],\n  ∀ (x : α), IsConnected (connectedComponent x)"]},
  {"theorem": "∃ I, I.IsMaximal",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "groups":
   [["∃ I, I.IsMaximal", "∃ I, I.IsMaximal", "∃ M, M.IsMaximal"],
    ["∃ I, I.IsMaximal ∧ IsField (ℤ ⧸ I)"],
    ["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, M.IsMaximal"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∃ (I : Ideal ℤ), Ideal.IsMaximal I",
    " ∃ (I : Ideal ℤ), Ideal.IsMaximal I ",
    " ∃ M, Ideal.IsMaximal M",
    " ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M",
    " ∃ (I : Ideal ℤ), Ideal.IsMaximal I ∧ IsField (ℤ ⧸ I)",
    " ∀ I, ∃ M, Ideal.IsMaximal M ∧ M = I ∧ I = ⊥",
    " ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : NoZeroDivisors R] [inst_2 : IsDomain R] [inst_3 : IsDedekindDomain R] [inst_4 : Module.Free ℤ R] [inst_5 : Module.Finite ℤ R], ∃ M, Ideal.IsMaximal M ≠ ⊥"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "groups":
   [["PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5",
     "PythagoreanTriple 3 4 5"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5",
    " PythagoreanTriple 3 4 5 ",
    " ∃ k m n,\n     (3 = k * (m ^ 2 - n ^ 2) ∧ 4 = k * (2 * m * n) ∨ 3 = k * (2 * m * n) ∧ 4 = k * (m ^ 2 - n ^ 2)) ∧\n        (5 = k * (m ^ 2 + n ^ 2) ∨ 5 = -k * (m ^ 2 + n ^ 2))",
    " ∀ {x y z : ℤ},\n  PythagoreanTriple x y z = (x = 3 ∧ y = 4 ∧ z = 5)",
    " ∃ k m n,\n  (3 = k * (m ^ 2 - n ^ 2) ∧ 4 = k * (2 * m * n) ∨ 3 = k * (2 * m * n) ∧ 4 = k * (m ^ 2 - n ^ 2)) ∧\n     (5 = k * (m ^ 2 + n ^ 2) ∨ 5 = -k * (m ^ 2 + n ^ 2)) ∧ 3 < k ∧ 5 < k ∧ 3 < 5 ∧ k ≠ 0 ∧ m ≠ 0 ∧ n ≠ 0"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  ∅ = Basis.ofVectorSpaceIndex K V → FiniteDimensional K V ↔ V = 0",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial.",
   "groups":
   [["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  ∅ = Basis.ofVectorSpaceIndex K V → FiniteDimensional K V ↔ V = 0"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], ∅ = Basis.ofVectorSpaceIndex K V → FiniteDimensional K V ↔ V = 0"]}],
 "elaborated": 38}