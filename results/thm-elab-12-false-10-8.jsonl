{"theorem":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2","text":"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y ≠ 0 → x ^ 2 = -y ^ 2 → p % 4 ≠ 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.\"}]","all_elaborations":["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2)","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (p % 4 = 1 → ∃ a b, p = a ^ 2 + b ^ 2)","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], (p % 4 = 1) → ∃ x y, p = x ^ 2 + y ^ 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → p % 4 = 1 → ∃ x y, p = x ^ 2 + y ^ 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → ∃ x y, p = x ^ 2 + y ^ 2"]}
{"theorem":"∀ {α : Type u} [inst : LinearOrderedRing α] {a b : α} {c d x y z w : α},\n  (∃ a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄, a = a₁ * a₁ + a₂ * a₂ + a₃ * a₃ + a₄ * a₄ ∧ b = b₁ * b₁ + b₂ * b₂ + b₃ * b₃ + b₄ * b₄) →\n    ∃ r₁ r₂ r₃ r₄, a * b = r₁ * r₁ + r₂","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\", \"content\": \"**Four squares theorem** \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), ∃ a b c d, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\", \"content\": \"**Euler's four-square identity**. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (a b c d x y z w : R),\\n  (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 + (a * z - b * w + c * x + d * y) ^ 2 +\\n      (a * w + b * z - c * y + d * x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\"},\n {\"role\": \"user\", \"content\": \"The square commutes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {W X Y Z : C} {f : W ⟶ X} {g : W ⟶ Y} {h : X ⟶ Z} {i : Y ⟶ Z},\\n  CategoryTheory.CommSq f g h i → CategoryTheory.CategoryStruct.comp f h = CategoryTheory.CategoryStruct.comp g i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 ≠ 3`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y ≠ 0 → x ^ 2 = -y ^ 2 → p % 4 ≠ 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.\"}]","all_elaborations":["∀ (a b c d e f g h : ℤ),\n  (∃ (x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℤ), a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 ∧ b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2) →\n    ∃ (r₁ s₁ t₁ u₁ r₂ s₂ t₂ u₂ : ℤ), a * b = r₁ ^ 2 + s₁ ^ 2 + t₁ ^ 2 + u₁ ^ 2 + r₂ ^ 2","∀ {α : Type u} [inst : LinearOrderedRing α] {a b c d e f g h : α},\n  (∃ (x₁ y₁ z₁ w₁ : α), a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2) →\n    (∃ (x₂ y₂ z₂ w₂ : α), b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2) →\n      ∃ (x y z w : α), e = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧ f = x","∀ (a b c d e f g h : ℕ),\n  ∃ (p q r s : ℕ),\n    a = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ∧\n    b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 →\n    ∃ (x y z w : ℕ),\n      e = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 ∧\n      f = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n      ∃ (m n o r : ℕ),\n        c = m ^ 2","∀ {α : Type u} [inst : LinearOrderedRing α] {a b c d x y z w : α},\n  (∃ (a₁ a₂ a₃ a₄ b₁ b₂ b₃ b₄ : α),\n      a = a₁ * a₁ + a₂ * a₂ + a₃ * a₃ + a₄ * a₄ ∧\n      b = b₁ * b₁ + b₂ * b₂ + b₃ * b₃ + b₄ * b₄) →\n    ∃ (r₁ r₂ r₃ r₄ : α),\n      a * b = r₁ * r₁ + r₂","∀ {α : Type} [inst : LinearOrderedRing α] {a b c d e f g h : α},\n  ∃ (w x y z : α),\n    a = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ∧\n    b = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ∧\n    (c * e - d * f - g * h) = w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 ∧\n    (c * f + d * e + g * z - h * y) = w ^ 2 + x ^ 2"]}
{"theorem":"{R : Type u} → [inst : Ring R] → (∀ (a : R), IsIdempotentElem a) → CommRing R","text":"A ring with all elements idempotent is commutative.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finitely generated idempotent ideal is generated by an idempotent element \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R),\\n  Ideal.FG I → (IsIdempotentElem I ↔ ∃ e, IsIdempotentElem e ∧ I = Submodule.span R {e})\"},\n {\"role\": \"user\",\n  \"content\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a\"},\n {\"role\": \"user\", \"content\": \"The identity map is a ring homomorphism. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u} [inst : Ring α], IsRingHom id\"},\n {\"role\": \"user\", \"content\": \"As submodules, subalgebras are idempotent. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} {A : Type u_2} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]\\n  (S : Subalgebra R A), ↑Subalgebra.toSubmodule S * ↑Subalgebra.toSubmodule S = ↑Subalgebra.toSubmodule S\"},\n {\"role\": \"user\", \"content\": \"An abelian category is idempotent complete. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (D : Type u_1) [inst : CategoryTheory.Category D] [inst_1 : CategoryTheory.Abelian D],\\n  CategoryTheory.IsIdempotentComplete D\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two non-unital subrings are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] {S T : NonUnitalSubring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T\"},\n {\"role\": \"user\",\n  \"content\": \"Two subrings are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R] {S T : Subring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a ring multiplied by the additive inverse of one is the element's additive\\ninverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : MulOneClass α] [inst_1 : HasDistribNeg α] (a : α), a * -1 = -a\"},\n {\"role\": \"user\",\n  \"content\": \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"A ring with all elements idempotent is commutative.\"}]","all_elaborations":["∀ {R : Type u} [inst : Ring R], (∀ (a : R), a * a = a) → CommRing R","∀ {R : Type u} [inst : Ring R],\n  (∀ (x : R), x * x = x) → CommRing R","∀ {R : Type u} [inst : Ring R], (∀ (x : R), x * x = x) → CommRing R","∀ {R : Type u_1} [inst : Ring R], (∀ (x : R), x * x = x) → CommRing R","∀ {R : Type u} [inst : Ring R], (∀ (x : R), IsIdempotentElem x) → CommRing R","∀ {R : Type u} [inst : Ring R], (∀ (a : R), IsIdempotentElem a) → CommRing R"]}
{"theorem":"∀ (n : ℕ), ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p - q = 2 ∧ p > n ∧ q > n","text":"There are infinitely many pairs of primes that differ exactly by `2`.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\"},\n {\"role\": \"user\", \"content\": \"The infinite pigeonhole principle \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β α : Type u} (f : β → α),\\n  Cardinal.aleph0 ≤ Cardinal.mk β →\\n    Cardinal.mk α < Ordinal.cof (Cardinal.ord (Cardinal.mk β)) → ∃ a, Cardinal.mk ↑(f ⁻¹' {a}) = Cardinal.mk β\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. \"},\n {\"role\": \"assistant\", \"content\": \"Set.Infinite {p | Nat.Prime p}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There are infinitely many pairs of primes that differ exactly by `2`.\"}]","all_elaborations":["∀ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p → Nat.Prime (p + 2)","∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p - q = 2 ∧ p ≥ n ∧ q ≥ n","∃ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p ∧ Nat.Prime (p + 2)","∀ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p → (Nat.Prime (p + 2) ∨ Nat.Prime (p - 2))","∀ (n : ℕ), ∃ᶠ (p : ℕ) in Filter.atTop, Nat.Prime p ∧ Nat.Prime (p + 2)","∀ (n : ℕ), ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p - q = 2 ∧ p > n ∧ q > n"]}
{"theorem":"{K : Type u} → [inst : DivisionRing K] → Fintype K → Field K","text":"Every finite division ring is a field.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), I = ⊥ ∨ I = ⊤\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\": \"An intermediate field is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)\\n  {x y : L}, x ∈ S → y ∈ S → x / y ∈ S\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x y : K}, x ∈ s → y ∈ s → x * y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"A subfield is closed under multiplicative inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (self : Subfield K) (x : K), x ∈ self.carrier → x⁻¹ ∈ self.carrier\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A module over a division ring is noetherian if and only if it is finitely generated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\\n  IsNoetherian K V ↔ Module.Finite K V\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime that does not divide the cardinality of a finite commutative ring `R`\\nis a unit in `R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card R → ¬IsUnit ↑p\"},\n {\"role\": \"user\", \"content\": \"A valued division ring is separated. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_2} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]\\n  [inst_2 : Valued K Γ₀], SeparatedSpace K\"},\n {\"role\": \"user\", \"content\": \"Every finite division ring is a field.\"}]","all_elaborations":["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K","∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K","∀ {K : Type u} [inst : DivisionRing K], Fintype K → Field K"]}
{"theorem":"∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α), Function.Injective f → Function.Injective g → Function.Bijective f","text":"If each of two types can be mapped injectively into the other, then there is a bijection between them.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The axiom of choice says that every nonempty type is an injective object in `Type`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (X : Type u₁) [inst : Nonempty X], CategoryTheory.Injective X\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A morphism in `Type u` is an isomorphism if and only if it is bijective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X Y : Type u} (f : X ⟶ Y), CategoryTheory.IsIso f ↔ Function.Bijective f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An equivalence is essentially surjective.\\n\\nSee <https://stacks.math.columbia.edu/tag/02C3>.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {D : Type u₂} [inst_1 : CategoryTheory.Category D]\\n  (F : CategoryTheory.Functor C D) [inst_2 : CategoryTheory.IsEquivalence F], CategoryTheory.EssSurj F\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two subtypes of a fintype have equal cardinality, so do their complements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Finite α] (p q : α → Prop) [inst : Fintype { x // p x }] [inst_1 : Fintype { x // ¬p x }]\\n  [inst_2 : Fintype { x // q x }] [inst_3 : Fintype { x // ¬q x }],\\n  Fintype.card { x // p x } = Fintype.card { x // q x } → Fintype.card { x // ¬p x } = Fintype.card { x // ¬q x }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A binary injective function is injective when only the right argument varies. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\\n  Function.Injective2 f → ∀ (a : α), Function.Injective (f a)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A binary injective function is injective when only the left argument varies. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Sort u_1} {β : Sort u_2} {γ : Sort u_3} {f : α → β → γ},\\n  Function.Injective2 f → ∀ (b : β), Function.Injective fun a => f a b\"},\n {\"role\": \"user\",\n  \"content\": \"`Option.map f` is injective if `f` is injective. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} {f : α → β}, Function.Injective f → Function.Injective (Option.map f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A type `α` is countable if there exists an injective map `α → ℕ`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Sort u} [self : Countable α], ∃ f, Function.Injective f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If each of two types can be mapped injectively into the other, then there is a bijection between them.\"}]","all_elaborations":["∀ {α : Type u₁} {β : Type u₂} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Function.Bijective f","∀ {α β : Type u} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∃ h : α ≃ β, ∀ x : α, f x = h x ∧ g (h x) = x","∀ {α : Type u₁} {β : Type u₂} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∃ h, Function.Bijective h","∀ {α : Type u₁} {β : Type u₂} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → ∀ (x : α), g (f x) = x → ∀ (y : β), f (g y) = y → Function.Bijective f","∀ {α : Type u₁} {β : Type u₂},\n  (∃ (f : α → β), Function.Injective f) → (∃ (g : β → α), Function.Injective g) → ∃ (h : α ≃ β), Function.Bijective h","∀ {α : Type u} {β : Type v} (f : α → β) (g : β → α),\n  Function.Injective f → Function.Injective g → Function.Bijective f"]}
{"theorem":"∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! n, SimpleGraph.Adj G v n ∧ SimpleGraph.Adj G w n) →\n    ∃ v, ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u","text":"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\"},\n {\"role\": \"user\", \"content\": \"Graph is acyclic. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.IsAcyclic G\"},\n {\"role\": \"user\", \"content\": \"Graph is connected. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} {G : SimpleGraph V}, SimpleGraph.IsTree G → SimpleGraph.Connected G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`independent`: a proof that each element of `parts` doesn't have a pair of adjacent vertices.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} {G : SimpleGraph V} (self : SimpleGraph.Partition G) (s : Set V), s ∈ self.parts → IsAntichain G.Adj s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The handshaking lemma.  See also `SimpleGraph.sum_degrees_eq_twice_card_edges`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\\n  Even (Finset.card (Finset.filter (fun v => Odd (SimpleGraph.degree G v)) Finset.univ))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum\\ndegree. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (k : ℕ),\\n  (∀ (v : V), SimpleGraph.degree G v ≤ k) → SimpleGraph.maxDegree G ≤ k\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Any vertex adjacent to a vertex of `C` and not lying in `K` must lie in `C`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u} {G : SimpleGraph V} {K : Set V} {C : SimpleGraph.ComponentCompl G K} (c d : V),\\n  c ∈ C → ¬d ∈ K → SimpleGraph.Adj G c d → d ∈ C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.\"}]","all_elaborations":["∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v w : V), v ≠ w → ∃! (n : V), SimpleGraph.Adj G v n ∧ SimpleGraph.Adj G w n) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj] (h : ∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃),\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj], (∀ (v w : V), v ≠ w → ∃! (n : V), SimpleGraph.Adj G v n ∧ SimpleGraph.Adj G w n) → ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj]\n  (h : ∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃),\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj]\n  (h : ∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃),\n  ∃ (v : V), ∀ (w : V), w ≠ v → SimpleGraph.Adj G v w","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v : V), SimpleGraph.Adj G v₁ v ∧ SimpleGraph.Adj G v₂ v) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u","∀ {V : Type u} (G : SimpleGraph V) [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), G.Adj v₁ v₃ ∧ G.Adj v₂ v₃) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → G.Adj v u","∀ {V : Type u} {G : SimpleGraph V} [inst : Fintype V] [inst_1 : DecidableRel G.Adj],\n  (∀ (v₁ v₂ : V), v₁ ≠ v₂ → ∃! (v₃ : V), SimpleGraph.Adj G v₁ v₃ ∧ SimpleGraph.Adj G v₂ v₃) →\n  ∃ (v : V), ∀ (u : V), u ≠ v → SimpleGraph.Adj G v u"]}
{"theorem":"∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\\n  Continuous f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact set of a uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {s : Set α} {f : α → β},\\n  IsCompact s → ContinuousOn f s → UniformContinuousOn f s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing on the left by a uniformly continuous function preserves\\nuniform convergence on a set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α}\\n  {p : Filter ι} [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → TendstoUniformlyOn F f p s → TendstoUniformlyOn (fun i => g ∘ F i) (g ∘ f) p s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing on the left by a uniformly continuous function preserves uniform convergence \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → TendstoUniformly F f p → TendstoUniformly (fun i => g ∘ F i) (g ∘ f) p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing on the left by a uniformly continuous function preserves\\nuniform Cauchy sequences \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → UniformCauchySeqOn F p s → UniformCauchySeqOn (fun n => g ∘ F n) p s\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A uniformly continuous function of a uniformly continuous function is uniformly continuous.\"}]","all_elaborations":["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]}
{"theorem":"∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","text":"A uniformly continuous function of a uniformly continuous function is uniformly continuous.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A uniform limit of continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\\n  Continuous f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Heine-Cantor: a continuous function on a compact set of a uniform space is uniformly\\ncontinuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {s : Set α} {f : α → β},\\n  IsCompact s → ContinuousOn f s → UniformContinuousOn f s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing on the left by a uniformly continuous function preserves\\nuniform convergence on a set \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α}\\n  {p : Filter ι} [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → TendstoUniformlyOn F f p s → TendstoUniformlyOn (fun i => g ∘ F i) (g ∘ f) p s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing on the left by a uniformly continuous function preserves uniform convergence \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → TendstoUniformly F f p → TendstoUniformly (fun i => g ∘ F i) (g ∘ f) p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Composing on the left by a uniformly continuous function preserves\\nuniform Cauchy sequences \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι}\\n  [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → UniformCauchySeqOn F p s → UniformCauchySeqOn (fun n => g ∘ F n) p s\"},\n {\"role\": \"user\", \"content\": \"A Lipschitz function is uniformly continuous \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {K : NNReal} {f : α → β},\\n  LipschitzWith K f → UniformContinuous f\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A uniformly continuous function of a uniformly continuous function is uniformly continuous.\"}]","all_elaborations":["∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)","∀ {α : Type u} {β : Type v} {γ : Type w} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]}
{"theorem":"∀ (f : ℝ → ℝ),\n  (∃ x, 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n    ∀ (n : ℕ), 0 < n → ∃ y, 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y","text":"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `f` sends two periodic points `x` and `y` of positive periods to the same point,\\nthen `x = y`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : α → α} {x y : α} {m n : ℕ},\\n  Function.IsPeriodicPt f m x → Function.IsPeriodicPt f n y → 0 < m → 0 < n → f x = f y → x = y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A fixed point of `f` is a periodic point of `f` of any prescribed period. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {f : α → α} {x : α}, Function.IsFixedPt f x → ∀ (n : ℕ), Function.IsPeriodicPt f n x\"},\n {\"role\": \"user\", \"content\": \"Any point is a periodic point of period `0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} (f : α → α) (x : α), Function.IsPeriodicPt f 0 x\"},\n {\"role\": \"user\",\n  \"content\": \"A continuous, periodic function has compact range. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {f : ℝ → α} {c : ℝ},\\n  Function.Periodic f c → c ≠ 0 → Continuous f → IsCompact (Set.range f)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a function from the unit interval to itself has a point of period three, then it has points of all positive periods.\"}]","all_elaborations":["∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), x ∈ [0, 1] ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), ∃ (y : ℝ), y ∈ [0, 1] ∧ Function.IsPeriodicPt f n y","∀ (f : ℝ → ℝ), (∀ (x : ℝ), x ∈ Set.Icc 0 1 → f x ∈ Set.Icc 0 1) →\n  (∃ (x : ℝ), x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), n > 0 → (∃ (y : ℝ), y ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n y)","∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y","∀ (f : ℝ → ℝ),\n  (∀ (x : ℝ), 0 ≤ x ∧ x ≤ 1 → f x ∈ [0, 1]) →\n  (∃ (x : ℝ), 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), n > 0 → ∃ (y : ℝ), 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y","∀ {f : ℝ → ℝ},\n  (∃ x : ℝ, 0 ≤ x ∧ x ≤ 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ {n : ℕ}, 0 < n → (∃ y : ℝ, 0 ≤ y ∧ y ≤ 1 ∧ Function.IsPeriodicPt f n y)","∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), 0 < x ∧ x < 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), 0 < y ∧ y < 1 ∧ Function.IsPeriodicPt f n y","∀ (f : ℝ → ℝ),\n  (∃ (x : ℝ), x ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ (y : ℝ), y ∈ Set.Icc 0 1 ∧ Function.IsPeriodicPt f n y","∀ (f : ℝ → ℝ),\n  (∃ x : ℝ, x ∈ set.Icc 0 1 ∧ Function.IsPeriodicPt f 3 x) →\n  ∀ (n : ℕ), 0 < n → ∃ y : ℝ, y ∈ set.Icc 0 1 ∧ Function.IsPeriodicPt f n y"]}
{"theorem":"∀ {C : Type u} [inst : CategoryTheory.Category C] (X Y : C),\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (X ≅ Y))","text":"A terminal object in a category is unique up to unique isomorphism.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Any two morphisms to a terminal object are equal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u₁} [inst : CategoryTheory.Category C] {X Y : C},\\n  CategoryTheory.Limits.IsTerminal X → ∀ (f g : Y ⟶ X), f = g\"},\n {\"role\": \"user\", \"content\": \"there are unique morphisms to the object \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C},\\n  CategoryTheory.Limits.IsZero X → ∀ (Y : C), Nonempty (Unique (X ⟶ Y))\"},\n {\"role\": \"user\", \"content\": \"there are unique morphisms from the object \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {X : C},\\n  CategoryTheory.Limits.IsZero X → ∀ (Y : C), Nonempty (Unique (Y ⟶ X))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If there are zero morphisms, any terminal object is a zero object. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasTerminal C], CategoryTheory.Limits.HasZeroObject C\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A terminal object in a category is unique up to unique isomorphism.\"}]","all_elaborations":["∀ {C : Type u} [inst : CategoryTheory.Category C],\n  ∀ (X Y : C), CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (CategoryTheory.Iso X Y))","∀ {C : Type u} [inst : CategoryTheory.Category C],\n  ∀ (X Y : C), CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (X ≅ Y))","∀ {C : Type u} [inst : CategoryTheory.Category C], ∀ (X Y : C),\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (CategoryTheory.Iso X Y))","∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {X Y : C},\n  CategoryTheory.Limits.IsTerminal X → CategoryTheory.Limits.IsTerminal Y → Nonempty (Unique (X ≅ Y))","∀ {C : Type u} [inst : CategoryTheory.Category C],\n  ∀ {X Y : C}, CategoryTheory.Limits.IsTerminal X →\n  CategoryTheory.Limits.IsTerminal Y → Nonempty (CategoryTheory.Iso X Y)"]}
{"theorem":"∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ = sᶜ ∩ tᶜ","text":"The complement of the union of two sets is the intersection of their complements.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of a set has the same frontier as the original set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α), frontier sᶜ = frontier s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The indicator of a disjoint union of two sets is the sum of the indicators of the sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup E] {s t : Set α} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμs : ↑↑μ s ≠ ⊤)\\n  (hμt : ↑↑μ t ≠ ⊤),\\n  s ∩ t = ∅ →\\n    ∀ (c : E),\\n      MeasureTheory.indicatorConstLp p (_ : MeasurableSet (s ∪ t)) (_ : ↑↑μ (s ∪ t) ≠ ⊤) c =\\n        MeasureTheory.indicatorConstLp p hs hμs c + MeasureTheory.indicatorConstLp p ht hμt c\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type w} [inst : SemilatticeInf γ] {s t : Set γ}, BddBelow (s ∪ t) ↔ BddBelow s ∧ BddBelow t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded above if and only if each of the sets is. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {γ : Type w} [inst : SemilatticeSup γ] {s t : Set γ}, BddAbove (s ∪ t) ↔ BddAbove s ∧ BddAbove t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The cardinality of a union is at most the sum of the cardinalities\\nof the two sets. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} (S T : Set α), Cardinal.mk ↑(S ∪ T) ≤ Cardinal.mk ↑S + Cardinal.mk ↑T\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The union of two sets is bounded iff each of the sets is bounded. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α}, Metric.Bounded (s ∪ t) ↔ Metric.Bounded s ∧ Metric.Bounded t\"},\n {\"role\": \"user\",\n  \"content\": \"The span of a union of sets is the sup of their spans. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (k : Type u_2) (V : Type u_3) {P : Type u_1} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s t : Set P), affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all sets in a collection are either `∅` or `Set.univ`, then so is their union. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {S : Set (Set α)}, S ⊆ {∅, Set.univ} → ⋃₀ S ∈ {∅, Set.univ}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If two sets intersect, the diameter of the union is bounded by the sum of the diameters. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Set.Nonempty (s ∩ t) → Metric.diam (s ∪ t) ≤ Metric.diam s + Metric.diam t\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A finite union of sets which are all bounded below is still bounded below.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {β : Type v} [inst : SemilatticeInf α] [inst_1 : Nonempty α] {I : Set β} {S : β → Set α},\\n  Set.Finite I → (BddBelow (⋃ (i : β) (_ : i ∈ I), S i) ↔ ∀ (i : β), i ∈ I → BddBelow (S i))\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The complement of the union of two sets is the intersection of their complements.\"}]","all_elaborations":["∀ {α : Type u} {s t : Set α}, (s ∪ t)ᶜ = sᶜ ∩ tᶜ"]}
{"theorem":"∀ (a b : ℕ), ℕ → a > 0 → b > 0 → ¬∃ d, a ^ 3 + b ^ 3 = d ^ 3","text":"The sum of the cubes of two positive integers is never equal to the cube of a third integer.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"The zeroth Pythagorean triple is all zeros. \"},\n {\"role\": \"assistant\", \"content\": \"PythagoreanTriple 0 0 0\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any natural numbers n, a, and b, one of the following holds:\\n1. n < a\\n2. n ≥ b\\n3. n ∈ Ico a b\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n a b : ℕ), n < a ∨ b ≤ n ∨ n ∈ List.Ico a b\"},\n {\"role\": \"user\", \"content\": \"If ∠BCD = π, then ∠ACB + ∠ACD = π. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] (p1 : P) {p2 p3 p4 : P},\\n  EuclideanGeometry.angle p2 p3 p4 = Real.pi →\\n    EuclideanGeometry.angle p1 p3 p2 + EuclideanGeometry.angle p1 p3 p4 = Real.pi\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (Finset.sum s fun x => f x) = ⊤ ↔ ∃ a, a ∈ s ∧ f a = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Brahmagupta's identity, see <https://en.wikipedia.org/wiki/Brahmagupta%27s_identity>\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {x₁ x₂ y₁ y₂ n : R},\\n  (x₁ ^ 2 + n * x₂ ^ 2) * (y₁ ^ 2 + n * y₂ ^ 2) = (x₁ * y₁ - n * x₂ * y₂) ^ 2 + n * (x₁ * y₂ + x₂ * y₁) ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The sum of the cubes of two positive integers is never equal to the cube of a third integer.\"}]","all_elaborations":["∀ (a b c : ℕ),\n  a > 0 → b > 0 → (∀ (x : ℕ), a ^ 3 + b ^ 3 ≠ x ^ 3)","∀ {a b c : ℕ}, a > 0 → b > 0 → c > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3","∀ (a b c : ℕ), a > 0 → b > 0 → c > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3","∀ {a b c : ℕ}, a > 0 → b > 0 → (a ^ 3 + b ^ 3 ≠ c ^ 3)","∀ {a b c : ℕ}, a > 0 ∧ b > 0 → a ^ 3 + b ^ 3 ≠ c ^ 3","∀ (a b c : ℕ), a > 0 → b > 0 → ¬ (∃ (d : ℕ), a ^ 3 + b ^ 3 = d ^ 3)","∀ {a b c : ℕ}, a > 0 → b > 0 → ¬ (∃ (x : ℕ), a ^ 3 + b ^ 3 = x ^ 3)"]}
{"theorem":"∀ {n : ℕ}, Even (n * (n + 1))","text":"The product of two consecutive natural numbers is even.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is even and `a` is even, then `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even n → Even a → Even (n % a)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is even iff `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Even (n % a) ↔ Even n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a product of integers is `-1`, then at least one factor must be `-1`. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {l : List ℤ}, List.prod l = -1 → -1 ∈ l\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : α → ENNReal}, (∀ (a : α), a ∈ s → f a ≠ ⊤) → (Finset.prod s fun a => f a) < ⊤\"},\n {\"role\": \"user\", \"content\": \"A product of finite numbers is still finite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {R : Type u_1} [inst : CommMonoidWithZero R] [inst_1 : NoZeroDivisors R] [inst_2 : Nontrivial R]\\n  [inst_3 : DecidableEq R] [inst_4 : LT R] {s : Finset ι} {f : ι → WithTop R},\\n  (∀ (i : ι), i ∈ s → f i ≠ ⊤) → (Finset.prod s fun i => f i) < ⊤\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, n % 2 = 1 ↔ n % 4 = 1 ∨ n % 4 = 3\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\"},\n {\"role\": \"user\",\n  \"content\": \"The product of two consecutive natural numbers is even.\"}]","all_elaborations":["∀ {n : ℕ}, Even (n * (n + 1))"]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.FiniteIndex H → Subgroup.index H = 2 → Subgroup.Normal H","text":"Every index 2 subgroup of a group is normal.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Any normal subgroup is either `⊥` or `⊤` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤\"},\n {\"role\": \"user\", \"content\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\"},\n {\"role\": \"user\",\n  \"content\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\"},\n {\"role\": \"user\", \"content\": \"The normal closure of a set is a subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\", \"content\": \"The normal closure of s is a normal subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\"},\n {\"role\": \"user\", \"content\": \"The subgroup has finite index \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The topological closure of a normal subgroup is normal.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\"},\n {\"role\": \"user\",\n  \"content\": \"The normal closure of `s` is a normal subgroup. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] {s : Set G}, Subgroup.Normal (Subgroup.normalClosure s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\"},\n {\"role\": \"user\", \"content\": \"A subgroup is closed under inverse. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x : G}, x ∈ H → x⁻¹ ∈ H\"},\n {\"role\": \"user\", \"content\": \"Every index 2 subgroup of a group is normal.\"}]","all_elaborations":["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.index H = 2 → Subgroup.Normal H","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.FiniteIndex H → Subgroup.index H = 2 → Subgroup.Normal H"]}
{"theorem":"∀ (n : ℕ), 1 < n → ∃ p, Nat.Prime p ∧ p ∣ n","text":"Every natural number greater than `1` is divisible by a prime number. ","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If a small natural number is divisible by a larger natural number,\\nthe small number is zero. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a b : ℕ}, a ∣ b → b < a → b = 0\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ}, Nat.Prime p → Nat.factorization p = Finsupp.single p 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ) {a : ℕ}, 0 < a → ((∃ k, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `p` is prime,\\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\\nthen `a = p^(k+1)`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a p k : ℕ}, Nat.Prime p → ¬a ∣ p ^ k → a ∣ p ^ (k + 1) → a = p ^ (k + 1)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, 0 < n → ¬Nat.Prime n → Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a p : Associates α},\\n  Irreducible p →\\n    ∀ [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n)] {n : ℕ} (h : a ∣ p ^ n),\\n      a = p ^ Nat.find (_ : ∃ n, (fun n => a ∣ p ^ n) n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every natural number greater than `1` is divisible by a prime number. \"}]","all_elaborations":["∀ (n : ℕ), 1 < n → ∃ (p : ℕ), Nat.Prime p ∧ p ∣ n","∀ (n : ℕ), 1 < n → (∃ (p : ℕ), Nat.Prime p ∧ p ∣ n)"]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → IsEmpty G","text":"A finite torsion-free group is trivial","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite torsion-free group is trivial\"}]","all_elaborations":["∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsionFree G → IsEmpty G"]}
{"theorem":"{K : Type u} → [inst : DivisionRing K] → Fintype K → Field K","text":"Every finite division ring is a field.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\", \"content\": \"A finite torsion-free group is trivial\"}]","all_elaborations":["∀ {K : Type u_1} [inst : DivisionRing K] [inst_1 : Fintype K], Field K","∀ {K : Type u} [inst : DivisionRing K] [inst_1 : Fintype K], Field K","∀ {K : Type u} [inst : DivisionRing K], Fintype K → Field K"]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","text":"Every finite topological space is compact.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"Finite topological spaces are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\"},\n {\"role\": \"user\", \"content\": \"The underlying topological space is compact.\"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (self : CompHaus), CompactSpace ↑self.toTop\"},\n {\"role\": \"user\", \"content\": \"A compact discrete space is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst : DiscreteTopology α], Finite α\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A set `s` is compact if for every open cover of `s`, there exists a finite subcover. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  (∀ {ι : Type u} (U : ι → Set α),\\n      (∀ (i : ι), IsOpen (U i)) → s ⊆ ⋃ (i : ι), U i → ∃ t, s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i) →\\n    IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\"},\n {\"role\": \"user\", \"content\": \"In a Noetherian space, all sets are compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] (s : Set α), IsCompact s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s → ∀ (U : ι → Set α), (∀ (i : ι), IsOpen (U i)) → s ⊆ ⋃ (i : ι), U i → ∃ t, s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A set `s` is compact if and only if\\nfor every open cover of `s`, there exists a finite subcover. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  IsCompact s ↔\\n    ∀ {ι : Type u} (U : ι → Set α), (∀ (i : ι), IsOpen (U i)) → s ⊆ ⋃ (i : ι), U i → ∃ t, s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i\"},\n {\"role\": \"user\", \"content\": \"A proper space is locally compact \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] [inst_1 : ProperSpace α], LocallyCompactSpace α\"},\n {\"role\": \"user\",\n  \"content\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\"},\n {\"role\": \"user\", \"content\": \"Every finite topological space is compact.\"}]","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α","theorem finite_topological_space_is_compact {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α] : CompactSpace α "]}
{"theorem":"∀ {n : ℕ}, Even n → n > 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","text":"Every positive even integer can be written as the sum of two primes.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p q : ℕ}, Nat.Prime p → ↑(Nat.factorization p) q ≠ 0 → p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {m n : ℕ}, Odd n → m ∣ n → m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\", \"content\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (n : ℕ), Nat.factorization n = 0 ↔ n = 0 ∨ n = 1\"},\n {\"role\": \"user\", \"content\": \"**Lifting the exponent lemma** for odd primes. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every positive even integer can be written as the sum of two primes.\"}]","all_elaborations":["∀ {n : ℕ}, Even n → n > 2 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ {n : ℕ}, Even n → n > 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ (n : ℕ), Even n → n > 2 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ {n : ℕ}, Even n → n ≠ 0 → ∃ p q, Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ (n : ℕ), Even n → n > 0 → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q","∀ {n : ℕ},\n  Even n →\n    n > 0 →\n      ∃ (p q : ℕ),\n        Nat.Prime p ∧\n          Nat.Prime q ∧\n            p + q = n","∀ {n : ℕ}, n > 0 → Even n → ∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ n = p + q"]}
{"theorem":"∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","text":"The square root of an irrational number is irrational.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A transcendental real number is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\"},\n {\"role\": \"user\", \"content\": \"**Irrationality of the Square Root of 2** \"},\n {\"role\": \"assistant\", \"content\": \"Irrational (Real.sqrt 2)\"},\n {\"role\": \"user\",\n  \"content\": \"The natural square root is at most the real square root \"},\n {\"role\": \"assistant\", \"content\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\"},\n {\"role\": \"user\", \"content\": \"The golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenRatio\"},\n {\"role\": \"user\",\n  \"content\": \"The conjugate of the golden ratio is irrational. \"},\n {\"role\": \"assistant\", \"content\": \"Irrational goldenConj\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Note that most of the lemmas about powers of two refer to it as `sq`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 2 = a * a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0\"},\n {\"role\": \"user\",\n  \"content\": \"The square root of an irrational number is irrational.\"}]","all_elaborations":["∀ {x : ℝ}, Irrational x → Irrational (Real.sqrt x)","∀ {r : ℝ}, Irrational r → Irrational (Real.sqrt r)"]}
{"theorem":"∀ {n : ℕ}, Even (n * n) → Even n","text":"If the square of a number is even, the number itself is even.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is even and `a` is even, then `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even n → Even a → Even (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\", \"content\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is even iff `n % a` is even. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Even (n % a) ↔ Even n)\"},\n {\"role\": \"user\",\n  \"content\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\"},\n {\"role\": \"user\",\n  \"content\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a finite field of odd characteristic, not every element is a square. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F ≠ 2 → ∃ a, ¬IsSquare a\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `-1` is a square modulo `n` and `m` divides `n`, then `-1` is also a square modulo `m`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m n : ℕ}, m ∣ n → IsSquare (-1) → IsSquare (-1)\"},\n {\"role\": \"user\",\n  \"content\": \"If the square of a number is even, the number itself is even.\"}]","all_elaborations":["∀ {n : ℕ}, Even (n ^ 2) → Even n","∀ {n : ℕ}, Even (n * n) → Even n"]}
{"theorem":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P","text":"In a finite commutative ring, all prime ideals are maximal.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\"},\n {\"role\": \"user\",\n  \"content\": \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\"},\n {\"role\": \"user\",\n  \"content\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → Ideal.IsPrime (Ideal.map Polynomial.C P)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a noetherian ring, every ideal contains a product of prime ideals\\n([samuel, § 3.3, Lemma 3])\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsNoetherianRing R] (I : Ideal R),\\n  ∃ Z, Multiset.prod (Multiset.map PrimeSpectrum.asIdeal Z) ≤ I\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\"},\n {\"role\": \"user\",\n  \"content\": \"In a finite commutative ring, all prime ideals are maximal.\"}]","all_elaborations":["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (P : Ideal R), Ideal.IsPrime P → Ideal.IsMaximal P"]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, (∀ (x : α), x ∈ s → ∃ U, IsOpen U ∧ x ∈ U) → IsOpen s","text":"If every point of a subset of a topological space is contained in some open set, the subset itself is open.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A set `s` is open iff for every point `x` in `s` and every `y` close to `x`, `y` is in `s`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsOpen s ↔ ∀ (x : α), x ∈ s → ∀ᶠ (y : α) in nhds x, y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\"},\n {\"role\": \"user\", \"content\": \"The complement of a closed set is an open set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [self : IsClosed s], IsOpen sᶜ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T0Space α] {s : Set α},\\n  Set.Finite s → Set.Nonempty s → IsOpen s → ∃ x, x ∈ s ∧ IsOpen {x}\"},\n {\"role\": \"user\",\n  \"content\": \"The image of an open set in the source is open. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (e : LocalHomeomorph α β)\\n  {s : Set α}, IsOpen s → s ⊆ e.source → IsOpen (↑e '' s)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\"},\n {\"role\": \"user\",\n  \"content\": \"Every set open in the lower topology is a lower set. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  IsOpen s → IsLowerSet s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If every point of a subset of a topological space is contained in some open set, the subset itself is open.\"}]","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (U : Set α), IsOpen U ∧ x ∈ U) → IsOpen s","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (u : Set α), IsOpen u ∧ x ∈ u) → IsOpen s","∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ (u : Set α), IsOpen u ∧ x ∈ u ∧ u ⊆ s) → IsOpen s"]}
{"theorem":"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ?m.12642589 R x = 0","text":"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `𝒪` satisfies `v.integers 𝒪` where `v` is a valuation on a field, then `𝒪`\\nis a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {𝒪 : Type u} {K : Type v} {Γ : Type w} [inst : CommRing 𝒪] [inst_1 : IsDomain 𝒪] [inst_2 : Field K]\\n  [inst_3 : Algebra 𝒪 K] [inst_4 : LinearOrderedCommGroupWithZero Γ] (v : Valuation K Γ),\\n  Valuation.Integers v 𝒪 → ValuationRing 𝒪\"},\n {\"role\": \"user\", \"content\": \"Nonzero elements have nonzero adic valuation. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : R), x ≠ 0 → IsDedekindDomain.HeightOneSpectrum.intValuationDef v x ≠ 0\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `v` is a valuation on a division ring then `v(x) = 0` iff `x = 0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]\\n  [inst_2 : Nontrivial Γ₀] (v : Valuation K Γ₀) {x : K}, ↑v x = 0 ↔ x = 0\"},\n {\"role\": \"user\", \"content\": \"A discrete valuation ring `R` is not a field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R], ¬IsField R\"},\n {\"role\": \"user\", \"content\": \"Nonzero divisors have nonzero valuation. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (x : { x // x ∈ nonZeroDivisors R }),\\n  IsDedekindDomain.HeightOneSpectrum.intValuationDef v ↑x ≠ 0\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `v` is an additive valuation on a division ring then `v(x) = ⊤` iff `x = 0`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} [inst : DivisionRing K] {Γ₀ : Type u_1} [inst_1 : LinearOrderedAddCommMonoidWithTop Γ₀]\\n  [inst_2 : Nontrivial Γ₀] (v : AddValuation K Γ₀) {x : K}, ↑v x = ⊤ ↔ x = 0\"},\n {\"role\": \"user\", \"content\": \"The `v`-adic valuation of `1 : R` equals 1. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.intValuationDef v 1 = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The `v`-adic valuation of `r ∈ R` is less than 1 if and only if `v` divides the ideal `(r)`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {K : Type u_2}\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] (v : IsDedekindDomain.HeightOneSpectrum R)\\n  (r : R), ↑(IsDedekindDomain.HeightOneSpectrum.valuation v) (↑(algebraMap R K) r) < 1 ↔ v.asIdeal ∣ Ideal.span {r}\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An element of a discrete valuation ring is a unit if and only if it has a valuation of zero.\"}]","all_elaborations":["∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(IsDedekindDomain.HeightOneSpectrum.valuation (DiscreteValuationRing.spectrum R)) x = 0","∀ (R : Type u) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : DiscreteValuationRing R] (x : R),\n  IsUnit x ↔ ↑(DiscreteValuationRing.valuation inst) x = 0"]}
{"theorem":"{K : Type u} → [inst : Field K] → Ring K","text":"Every field is a ring.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"`ℤ` with its usual ring structure is not a field. \"},\n {\"role\": \"assistant\", \"content\": \"¬IsField ℤ\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Semiring R], IsField R → ∃ x y, x ≠ y\"},\n {\"role\": \"user\", \"content\": \"Fields are commutative. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ (x y : R), x * y = y * x\"},\n {\"role\": \"user\", \"content\": \"A field is a valuation ring. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ (K : Type u) [inst : Field K], ValuationRing K\"},\n {\"role\": \"user\", \"content\": \"`R[X]` is never a field for any ring `R`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {R : Type u} [inst : Ring R], ¬IsField (Polynomial R)\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} RingCat\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} SemiRingCatMax\"},\n {\"role\": \"user\", \"content\": \"The category of rings has all limits. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u v, max (u + 1) (v + 1)} CommSemiRingCatMax\"},\n {\"role\": \"user\",\n  \"content\": \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\\n  [inst_3 : SubringClass S R], IsDomain { x // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"An intermediate field contains the ring's 0. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u_2} {L : Type u_1} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L),\\n  0 ∈ S\"},\n {\"role\": \"user\", \"content\": \"Every field is a ring.\"}]","all_elaborations":["∀ {F : Type u} [inst : Field F], Ring F","∀ {K : Type u_1} [inst : Field K], Ring K","∀ (F : Type u) [inst : Field F], Ring F","∀ {K : Type u} [inst : Field K], Ring K"]}
{"theorem":"{R : Type u_1} → [inst : Semiring R] → Group Rˣ","text":"The set of units in a ring forms a group.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"An ideal which contains an element within `1` of `1 : R` is the unit ideal. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] (I : Ideal R) {x : R}, x ∈ I → ‖1 - x‖ < 1 → I = ⊤\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A prime that does not divide the cardinality of a finite commutative ring `R`\\nis a unit in `R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Fintype R] (p : ℕ) [inst_2 : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card R → ¬IsUnit ↑p\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two non-unital subrings are equal if they have the same elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] {S T : NonUnitalSubring R}, (∀ (x : R), x ∈ S ↔ x ∈ T) → S = T\"},\n {\"role\": \"user\", \"content\": \"Nonzero elements have multiplicative inverses. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R], IsField R → ∀ {a : R}, a ≠ 0 → ∃ b, a * b = 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The group of units of a complete normed ring is an open subset of the ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R], IsOpen {x | IsUnit x}\"},\n {\"role\": \"user\",\n  \"content\": \"A non-unital subring is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M\"},\n {\"role\": \"user\",\n  \"content\": \"Units of a monoid divide any element of the monoid. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {α : Type u_1} [inst : Monoid α] {a u : α}, IsUnit u → u ∣ a\"},\n {\"role\": \"user\", \"content\": \"The set of units in a ring forms a group.\"}]","all_elaborations":["def Units (R : Type) [Ring R] : Type ","∀ {R : Type u} [inst : Ring R], Group (Units R)","∀ {R : Type u_1} [inst : Ring R], Group {x : R | IsUnit x}","∀ {R : Type u_1} [inst : Semiring R], Group (Units R)"]}
{"theorem":"∀ {G H : Type u_1} [instG : Group G] [instH : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H","text":"If the direct product of two groups is torsion free then each of the groups is torsion free.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"Direct products of torsion free groups are torsion free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)],\\n  (∀ (i : η), Monoid.IsTorsionFree (Gs i)) → Monoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Direct products of additive torsion free groups are torsion free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → AddGroup (Gs i)],\\n  (∀ (i : η), AddMonoid.IsTorsionFree (Gs i)) → AddMonoid.IsTorsionFree ((i : η) → Gs i)\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\"},\n {\"role\": \"user\", \"content\": \"Finite groups are torsion groups. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\"},\n {\"role\": \"user\",\n  \"content\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\"},\n {\"role\": \"user\",\n  \"content\": \"Finite additive groups are additive torsion groups.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Finite G], AddMonoid.IsTorsion G\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (G : Type u_1) [inst : AddCommGroup G], AddMonoid.IsTorsionFree (G ⧸ AddCommGroup.torsion G)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If the direct product of two groups is torsion free then each of the groups is torsion free.\"}]","all_elaborations":["∀ {G H : Type u_1} [instG : Group G] [instH : Group H],\n  Monoid.IsTorsionFree (G × H) → Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H","∀ {G1 G2 : Type u_1} [inst1 : Group G1] [inst2 : Group G2],\n  Monoid.IsTorsionFree (G1 × G2) → Monoid.IsTorsionFree G1 ∧ Monoid.IsTorsionFree G2","∀ {G1 G2 : Type u_1} [inst1 : Group G1] [inst2 : Group G2],\n  Monoid.IsTorsionFree (G1 × G2) → (Monoid.IsTorsionFree G1 ∧ Monoid.IsTorsionFree G2)","∀ {G H : Type u_1} [instG : Group G] [instH : Group H],\n  Monoid.IsTorsionFree (G × H) → (Monoid.IsTorsionFree G ∧ Monoid.IsTorsionFree H)","∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂","∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂],\n  Monoid.IsTorsionFree (G₁ × G₂) → (Monoid.IsTorsionFree G₁ ∧ Monoid.IsTorsionFree G₂)"]}
