{"theorem":"∀ {f : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n    StrictMono f ∧\n      ∀ {x : ℝ},\n        x ∈ Set.Ioo a b → ∃ g, (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → (g ∘ f) y = y) ∧ HasDerivAt g (deriv f x)⁻¹ (f x)","text":"Suppose `f'(x) > 0` in `(a, b)`. Prove that `f` is strictly increasing in `(a, b)`, and let `g` be its inverse function. Prove that `g` is differentiable, and that `g'(f(x)) = 1/f'(x)` for `(a < x < b)`.","result":true,"gps":[["∀ {f : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n    StrictMono f ∧\n      ∀ {x : ℝ},\n        x ∈ Set.Ioo a b → ∃ g, (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → (g ∘ f) y = y) ∧ HasDerivAt g (deriv f x)⁻¹ (f x)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {f : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n    (StrictMono f ∧\n      ∀ {x : ℝ},\n        x ∈ Set.Ioo a b →\n          ∃ g, (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → (g ∘ f) y = y) ∧\n                    HasDerivAt g (deriv f x)⁻¹ (f x)) ","∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt f (f' x) x) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f' x) →\n        StrictMonoOn f (Set.Ioo a b) ∧\n          ∃ (g : ℝ → ℝ),\n            ContinuousOn g (Set.Icc (f a) (f b)) ∧\n              (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → HasDerivAt g (1 / f' (g y)) y) ","∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f' x) →\n    (StrictMono f ∧ ∃ g, ∀ (x : ℝ), x ∈ Set.Ioo a b → (HasDerivAt f (f' x) x ∧ HasDerivAt g (1 / f' (g x)) (f x))) ","∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f' x) →\n    (StrictMono f ∧\n      ∀ {g : ℝ → ℝ},\n        (∀ (x : ℝ), x ∈ Set.Ioo a b → g (f x) = x) → ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (1 / f' (f x)) (f x)) ","∀ {f : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < deriv f x) →\n      StrictMono f ∧\n        ∀ {g : ℝ → ℝ},\n          (∀ (x : ℝ), x ∈ Set.Icc a b → g (f x) = x) →\n            (∀ (y : ℝ), y ∈ Set.Icc (f a) (f b) → ContinuousOn g (Set.Icc (f a) (f b))) →\n              (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (1 / deriv f (g (f x))) (f x)) "]}
{"theorem":"∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 → MonotoneOn (deriv f) (Set.Ioi 0) → MonotoneOn (fun x => f x / x) (Set.Ioi 0)","text":"Suppose (a) `f` is continuous for `x ≥ 0`, (b) `f'(x)` exists for `x > 0`, (c) `f(0) = 0`, (d) `f'` is monotonically increasing. Put `g(x) = f(x)/x` for `(x > 0)` and prove that `g` is monotonically increasing.","result":true,"gps":[["∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 → MonotoneOn (deriv f) (Set.Ioi 0) → MonotoneOn (fun x => f x / x) (Set.Ioi 0)"],["∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) → f 0 = 0 → Monotone (deriv f) → ∀ ⦃x y : ℝ⦄, 0 < x → x ≤ y → f x / x ≤ f y / y"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        Monotone (deriv f) → ∀ ⦃x y : ℝ⦄, 0 < x → x ≤ y → f x / x ≤ f y / y ","∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        MonotoneOn (deriv f) (Set.Ioi 0) →\n          MonotoneOn (fun x => f x / x) (Set.Ioi 0) ","∀ {f : ℝ → ℝ},\n  (∀ x, 0 ≤ x → ContinuousAt f x) →\n  (∀ x, 0 < x → DifferentiableAt ℝ f x) →\n  f 0 = 0 →\n  (∀ x y, 0 < x → x < y → deriv f x ≤ deriv f y) →\n  ∀ ⦃x y : ℝ⦄,\n    0 < x → x < y → (f x) / x ≤ (f y) / y "]}
{"theorem":"∀ {a : ℝ} {f : ℝ → ℝ} {M₀ M₁ M₂ : ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      (∀ (x : ℝ), a < x → |f x| ≤ M₀) →\n        (∀ (x : ℝ), a < x → |deriv f x| ≤ M₁) → (∀ (x : ℝ), a < x → |deriv^[2] f x| ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂","text":"Suppose `a ∈ ℝ^1`, `f` is a twice-differentiable real function on `(a, ∞)`, and `M_0, M_1, M_2` are the least upper bounds of `|f(x)|`, `|f'(x)|`, `|f''(x)|`, respectively, on `(a, ∞)`. Prove that `M_1^2 ≤ 4 M_0 M_2`.","result":true,"gps":[["∀ {a : ℝ} {f : ℝ → ℝ} {M₀ M₁ M₂ : ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      (∀ (x : ℝ), a < x → |f x| ≤ M₀) →\n        (∀ (x : ℝ), a < x → |deriv f x| ≤ M₁) → (∀ (x : ℝ), a < x → |deriv^[2] f x| ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {a : ℝ} {f : ℝ → ℝ} {M₀ M₁ M₂ : ℝ},\n  Differentiable ℝ f → Differentiable ℝ (deriv f) →\n    (∀ x, a < x → abs (f x) ≤ M₀) →\n      (∀ x, a < x → abs (deriv f x) ≤ M₁) →\n        (∀ x, a < x → abs (deriv^[2] f x) ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂ "]}
{"theorem":"∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","text":"Let `X` be a topological space; let `A` be a subset of `X`. Suppose that for each `x ∈ A` there is an open set `U` containing `x` such that `U ⊆ A`. Show that `A` is open in `X`.","result":true,"gps":[["∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A"],["∀ {X : Type u} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A"],["∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x, x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x ∈ A, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x, x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ","∀ {X : Type u} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A "]}
{"theorem":"{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X","text":"If `T_α` is a family of topologies on `X`, show that `∩ T_α` is a topology on `X`.","result":true,"gps":[["{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X","{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X","{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X","{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X","{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X","{X : Type u} → {ι : Type u_1} → (ι → TopologicalSpace X) → TopologicalSpace X"],["{X : Type u_1} → {ι : Type u} → (ι → TopologicalSpace X) → TopologicalSpace X"],["{X : Type u_1} → {ι : Type u_2} → {T : ι → TopologicalSpace X} → TopologicalSpace X"],["{X : Type u} → Set (TopologicalSpace X) → TopologicalSpace X"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ","∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  TopologicalSpace X ","∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ","∀ {X : Type u} (T : Set (TopologicalSpace X)),\n  TopologicalSpace X ","∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ","∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ","∀ {X : Type u_1} {ι : Type u} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ","∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X ","∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  TopologicalSpace X "]}
{"theorem":"∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X), ∃! T₀, ∀ (i : ι), T i ≤ T₀","text":"Let `T_α` be a family of topologies on `X`. Show that there is a unique smallest topology on `X` containing all the collections `T_α`.","result":true,"gps":[["∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X), ∃! T₀, ∀ (i : ι), T i ≤ T₀","∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X}, ∃! T₀, ∀ (i : ι), T i ≤ T₀","∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X}, ∃! t, ∀ (i : ι), T i ≤ t"],["∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃ t, (∀ (i : ι), T i ≤ t) ∧ ∀ (t' : TopologicalSpace X), (∀ (i : ι), T i ≤ t') → t ≤ t'","∀ {X : Type u_1} {ι : Type u_2} {t : ι → TopologicalSpace X},\n  ∃ T_inf, (∀ (i : ι), t i ≤ T_inf) ∧ ∀ {T : TopologicalSpace X}, (∀ (i : ι), t i ≤ T) → T_inf ≤ T","∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X),\n  ∃ t, (∀ (i : ι), T i ≤ t) ∧ ∀ (t' : TopologicalSpace X), (∀ (i : ι), T i ≤ t') → t ≤ t'"],["∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X}, ∃! _inst, ∀ (i : ι), T i ≤ _inst","∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X), ∃! T_min, ∀ (i : ι), T i ≤ T_min","∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X}, ∃! t, ∀ (i : ι), T i ≤ t"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃ t : TopologicalSpace X, (∀ i : ι, T i ≤ t) ∧ ∀ t' : TopologicalSpace X, (∀ i : ι, T i ≤ t') → t ≤ t' ","∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃! _inst : TopologicalSpace X, ∀ (i : ι), T i ≤ _inst ","∀ {X : Type u} {ι : Type u_1} (T : ι → TopologicalSpace X),\n  ∃! (T₀ : TopologicalSpace X), ∀ (i : ι), T i ≤ T₀ ","∀ {X : Type u_1} {ι : Type u_2} {t : ι → TopologicalSpace X},\n  ∃ T_inf : TopologicalSpace X, (∀ i, t i ≤ T_inf) ∧ ∀ {T : TopologicalSpace X}, (∀ i, t i ≤ T) → T_inf ≤ T ","∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X),\n  ∃! (T_min : TopologicalSpace X), ∀ i, T i ≤ T_min ","∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X},\n  ∃! (T₀ : TopologicalSpace X), ∀ (i : ι), T i ≤ T₀ ","∀ {X : Type u_1} {ι : Type u_2} (T : ι → TopologicalSpace X),\n  ∃ t : TopologicalSpace X, (∀ i, T i ≤ t) ∧ ∀ t' : TopologicalSpace X, (∀ i, T i ≤ t') → t ≤ t' ","∀ {X : Type u} {ι : Type u_1} {T : ι → TopologicalSpace X},\n  ∃! (t : TopologicalSpace X), ∀ i, T i ≤ t ","∀ {X : Type u_1} {ι : Type u_2} {T : ι → TopologicalSpace X},\n  ∃! (t : TopologicalSpace X), ∀ i, T i ≤ t "]}
{"theorem":"∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a < b → ¬b ≤ a","text":"Show that the lower limit topology `ℝ_l` and the `K`-topology `ℝ_K` are not comparable.","result":true,"gps":[["∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a < b → ¬b ≤ a"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["not_le_of_gt : ∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, a < b → ¬b ≤ a "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)","text":"Show that if `U` is open in `X` and `A` is closed in `X`, then `U - A` is open in `X`, and `A - U` is closed in `X`.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)"],["∀ {X : Type u_1} [inst : TopologicalSpace X] {U A : Set X}, IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ","∀ {X : Type u_1} [inst : TopologicalSpace X] {U A : Set X},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ","∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) "]}
{"theorem":"∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)","text":"Let `Y` be an ordered set in the order topology. Let `f, g: X → Y` be continuous. Let `h: X → Y` be the function `h(x) = min {f(x), g(x)}`. Show that `h` is continuous.","result":true,"gps":[["∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)","∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)","∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] (f g : X → Y), Continuous f → Continuous g → Continuous fun x => min (f x) (g x)","∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)"],["∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {f g : X → α}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x)"],["∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g h : X → Y},\n  (∀ (x : X), h x = min (f x) (g x)) → Continuous f → Continuous g → Continuous h"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous fun x => min (f x) (g x) ","∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous fun x => min (f x) (g x) ","forall {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [LinearOrder Y]\n  [OrderTopology Y] (f g : X → Y),\n  Continuous f → Continuous g → Continuous (fun x => min (f x) (g x)) ","∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n[inst_3 : OrderTopology Y] {f g h : X → Y},\n(∀ (x : X), h x = min (f x) (g x)) → Continuous f → Continuous g → Continuous h ","∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous fun x => min (f x) (g x) ","∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {f g : X → α},\n  Continuous f → Continuous g → Continuous fun x => min (f x) (g x) "]}
{"theorem":"∀ {J : Type u_1} {X : J → Type u_2} [inst : (j : J) → TopologicalSpace (X j)] {x : (j : J) → X j}\n  {x_i : ℕ → (j : J) → X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j))","text":"Let `x_1, x_2, ...` be a sequence of the points of the product space `Π X_α`. Show that this sequence converges to the point `x` if and only if the sequence `π_α(x_i)` converges to `π_α(x)` for each `α`.","result":true,"gps":[["∀ {J : Type u_1} {X : J → Type u_2} [inst : (j : J) → TopologicalSpace (X j)] {x : (j : J) → X j}\n  {x_i : ℕ → (j : J) → X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j))","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i}\n  {x_1 : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_1 Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_1 n i) Filter.atTop (nhds (x i))","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i}\n  {x_seq : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i))","∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {X : α → Type u_2}\n  [inst_1 : (a : α) → TopologicalSpace (X a)] {x : (a : α) → X a} {xι : ℕ → (a : α) → X a},\n  Filter.Tendsto xι Filter.atTop (nhds x) ↔ ∀ (a : α), Filter.Tendsto (fun n => xι n a) Filter.atTop (nhds (x a))"],["∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {p : ℕ → (i : ι) → π i}\n  {x : (i : ι) → π i},\n  Filter.Tendsto p Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => p n i) Filter.atTop (nhds (x i))","∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {x : (i : ι) → π i}\n  {x_i : ℕ → (i : ι) → π i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i))"],["∀ {α : Type u_2} {X : α → Type u_1} [inst : (a : α) → TopologicalSpace (X a)] {x : (a : α) → X a}\n  {x₀ : ℕ → (a : α) → X a},\n  Filter.Tendsto x₀ Filter.atTop (nhds x) ↔ ∀ (a : α), Filter.Tendsto (fun n => x₀ n a) Filter.atTop (nhds (x a))","∀ {ι : Type u_2} {X : ι → Type u_1} [_i : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i}\n  {x' : ℕ → (i : ι) → X i},\n  Filter.Tendsto x' Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x' n i) Filter.atTop (nhds (x i))"],["∀ {α : Type u_3} {π : α → Type u_1} [inst : (i : α) → TopologicalSpace (π i)] {x : (i : α) → π i}\n  {x_seq : ℕ → (i : α) → π i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : α), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i))"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {J : Type u_1} {X : J → Type u_2} [inst : (j : J) → TopologicalSpace (X j)] {x : (j : J) → X j} {x_i : ℕ → (j : J) → X j},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (j : J), Filter.Tendsto (fun n => x_i n j) Filter.atTop (nhds (x j)) ","∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {p : ℕ → Π i, π i} {x : Π i, π i},\n  Filter.Tendsto p Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => p n i) Filter.atTop (nhds (x i)) ","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i} {x_1 : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_1 Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_1 n i) Filter.atTop (nhds (x i)) ","∀ {α : Type u_2} {X : α → Type u_1} [inst : (a : α) → TopologicalSpace (X a)] {x : (a : α) → X a} {x₀ : ℕ → (a : α) → X a},\n  Filter.Tendsto x₀ Filter.atTop (nhds x) ↔ ∀ a, Filter.Tendsto (fun n => x₀ n a) Filter.atTop (nhds (x a)) ","∀ {α : Type u_3} {π : α → Type u_1} [inst : (i : α) → TopologicalSpace (π i)] {x : (i : α) → π i} {x_seq : ℕ → (i : α) → π i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : α), Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i)) ","∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i} {x_seq : ℕ → (i : ι) → X i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (λ n => x_seq n i) Filter.atTop (nhds (x i)) ","∀ {ι : Type u_2} {X : ι → Type u_1} [_i : (i : ι) → TopologicalSpace (X i)] {x : (i : ι) → X i} {x' : ℕ → (i : ι) → X i},\n  Filter.Tendsto x' Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x' n i) Filter.atTop (nhds (x i)) ","∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {X : α → Type u_2} [inst_1 : (a : α) → TopologicalSpace (X a)]\n  {x : (a : α) → X a} {xι : ℕ → (a : α) → X a},\n  Filter.Tendsto xι Filter.atTop (nhds x) ↔ ∀ (a : α), Filter.Tendsto (fun n => xι n a) Filter.atTop (nhds (x a)) ","∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {x : (i : ι) → π i} {x_i : ℕ → (i : ι) → π i},\n  Filter.Tendsto x_i Filter.atTop (nhds x) ↔ ∀ (i : ι), Filter.Tendsto (fun n => x_i n i) Filter.atTop (nhds (x i)) "]}
{"theorem":"∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","text":"Define `f_n: [0,1] → ℝ` by the equation `f_n(x) = x^n`. Show that the sequence `(f_n(x))` converges for each `x ∈ [0,1]`.","result":true,"gps":[["∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","ℕ → ∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","∀ (x : ℝ), 0 ≤ x ∧ x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","∀ {x : ℝ}, 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)","∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)"],["∀ (x : ℝ), x ∈ [0, 1] → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (x : ℝ) (hx : 0 ≤ x) (hx' : x ≤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","∀ (n : ℕ) (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","∀ (x : ℝ), x ∈ Set.Icc 0 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","∀ (x : ℝ), 0 ≤ x ∧ x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","∀ (x : ℝ), x ∈ [0, 1] → Filter.Tendsto (fun n => x^n) Filter.atTop (nhds 0) ","∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","∀ {x : ℝ} (hx : 0 ≤ x) (hx' : x ≤ 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","∀ (x : ℝ) (hx : x ∈ Set.Icc 0 1), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","forall (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ","∀ (x : ℝ) (hx : x ∈ Set.Icc 0 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) "]}
{"theorem":"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","text":"Let `X` be a topological space and let `Y` be a metric space. Let `f_n: X → Y` be a sequence of continuous functions. Let `x_n` be a sequence of points of `X` converging to `x`. Show that if the sequence `(f_n)` converges uniformly to `f`, then `(f_n(x_n))` converges to `f(x)`.","result":true,"gps":[["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {x : X} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))"],["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x))"],["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {x : X} {f : X → Y}\n  {f_n : ℕ → X → Y} {x_n : ℕ → X},\n  Filter.Tendsto x_n Filter.atTop (nhds x) →\n    TendstoUniformly f_n f Filter.atTop → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {fn : ℕ → X → Y},\n  TendstoUniformly (fun n x => fn n x) f Filter.atTop →\n    ∀ {x : X} {xn : ℕ → X},\n      Filter.Tendsto xn Filter.atTop (nhds x) → Filter.Tendsto (fun n => fn n (xn n)) Filter.atTop (nhds (f x))"],["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f_n : ℕ → X → Y} {f : X → Y}\n  {x_n : ℕ → X} {x : X},\n  TendstoUniformly f_n f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) →\n      ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {f_n : ℕ → X → Y}\n  {x_n : ℕ → X} {x : X},\n  TendstoUniformly (fun n => f_n n) f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) →\n      ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x))"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {x : X} {ι : Type u_3}\n  {p : Filter ι} {F : ι → (X → Y)} {x_n : ι → X},\n  TendstoUniformly F f p →\n    ContinuousAt f x → Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f_n : ℕ → X → Y} {f : X → Y} {x_n : ℕ → X}\n  {x : X},\n  TendstoUniformly f_n f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {f_n : ℕ → X → Y} {x_n : ℕ → X} {x : X},\n  TendstoUniformly (fun n => f_n n) f Filter.atTop →\n    Filter.Tendsto x_n Filter.atTop (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ","forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {x : X} {f : X → Y} {f_n : ℕ → X → Y}\n  {x_n : ℕ → X}, Filter.Tendsto x_n Filter.atTop (nhds x) → TendstoUniformly f_n f Filter.atTop →\n    Filter.Tendsto (fun n => f_n n (x_n n)) Filter.atTop (nhds (f x)) ","∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {fn : ℕ → X → Y},\n  TendstoUniformly (fun n x => fn n x) f Filter.atTop →\n    ∀ {x : X} {xn : ℕ → X}, Filter.Tendsto xn Filter.atTop (nhds x) → Filter.Tendsto (fun n => fn n (xn n)) Filter.atTop (nhds (f x)) ","∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : MetricSpace Y] {f : X → Y} {ι : Type u_3}\n  {p : Filter ι} {F : ι → X → Y} {x : X} {x_n : ι → X},\n  TendstoUniformly F f p →\n    Filter.Tendsto x_n p (nhds x) → ContinuousAt f x → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) "]}
