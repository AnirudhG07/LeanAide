{"theorem":"∀ {p : ℕ}, Nat.Prime p ↔ p = 2 ∨ p % 2 = 1","text":"Every prime number is `2` or odd.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p : Prop)], (p % 2 = 1 : Prop) ↔ (p ≠ 2 : Prop)\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {q : ℕ} (hp : Nat.Prime p) (h : ↑(Nat.factorization p) q ≠ 0), p = q\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, (n % 2 = 1 : Prop) ↔ ((n % 4 = 1 : Prop) ∨ (n % 4 = 3 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} (hp : Nat.Prime p), Nat.factorization p = Finsupp.single p 1\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\", \"content\": \"Every prime number is `2` or odd.\"}]","all_elaborations":["∀ {p : ℕ}, (Nat.Prime p : Prop) ↔ (p = 2 ∨ p % 2 = 1 : Prop)","∀ {p : ℕ}, (Nat.Prime p : Prop) ↔ ((p = 2 : Prop) ∨ (p % 2 = 1 : Prop) : Prop)","∀ {p : ℕ}, (Nat.Prime p : Prop) ↔ (p = 2 ∨ (p % 2 = 1 : Prop) : Prop)","∀ {p : ℕ}, Nat.Prime p → (p = 2 ∨ (p % 2 = 1 : Prop) : Prop)","∀ {p : ℕ} (hp : Nat.Prime p), (p = 2 : Prop) ∨ (p % 2 = 1 : Prop)"]}
{"theorem":"∀ (n : ℕ), Odd (2 * n + 1)","text":"There are infinitely many odd natural numbers.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (h : n ≠ 0) (d : ℕ), Filter.Frequently (fun (m : ℕ) ↦ m ≡ d [MOD n]) Filter.atTop\"},\n {\"role\": \"user\", \"content\": \"The infinite pigeonhole principle \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β : Type u} {α : Type u} (f : (a : β) → α) (h₁ : Cardinal.aleph0 ≤ Cardinal.mk β)\\n  (h₂ : Cardinal.mk α < Ordinal.cof (Cardinal.ord (Cardinal.mk β))), ∃ (a : α), Cardinal.mk ↑(f ⁻¹' {a}) = Cardinal.mk β\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} {s : Finset α} {f : (a : α) → ENNReal},\\n  ((Finset.sum s fun (x : α) ↦ f x) = ⊤ : Prop) ↔ (∃ (a : α), (a ∈ s : Prop) ∧ (f a = ⊤ : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : (a : ι) → WithTop M},\\n  ((Finset.sum s fun (i : ι) ↦ f i) = ⊤ : Prop) ↔ (∃ (i : ι), (i ∈ s : Prop) ∧ (f i = ⊤ : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ} {a : ℕ} (hn : Odd n) (ha : Even a), Odd (n % a)\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, (n % 2 = 1 : Prop) ↔ ((n % 4 = 1 : Prop) ∨ (n % 4 = 3 : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd natural numbers.\"}]","all_elaborations":["∀ (n : ℕ), Odd (2 * n + 1)"]}
{"theorem":"Nat.Prime 3","text":"The smallest odd prime is `3`.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"A natural number is odd iff it has residue `1` or `3` mod `4`\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ}, (n % 2 = 1 : Prop) ↔ ((n % 4 = 1 : Prop) ∨ (n % 4 = 3 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {q : ℕ} (hp : Nat.Prime p) (h : ↑(Nat.factorization p) q ≠ 0), p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p : Prop)], (p % 2 = 1 : Prop) ↔ (p ≠ 2 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"role\": \"assistant\", \"content\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only prime factor of prime `p` is `p` itself, with multiplicity `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} (hp : Nat.Prime p), Nat.factorization p = Finsupp.single p 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The square of the smallest prime factor of a composite number `n` is at most `n`.\\n\"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} (w : 0 < n) (h : ¬(Nat.Prime n : Prop)), Nat.minFac n ^ 2 ≤ n\"},\n {\"role\": \"user\",\n  \"content\": \"The only divisors of prime powers are prime powers. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [dec_irr : (p : Associates α) → Decidable (Irreducible p : Prop)]\\n  [inst_1 : UniqueFactorizationMonoid α] [dec : DecidableEq α] [dec' : DecidableEq (Associates α)] {a : Associates α}\\n  {p : Associates α} (hp : Irreducible p) [inst_2 : (n : ℕ) → Decidable (a ∣ p ^ n : Prop)] {n : ℕ} (h : a ∣ p ^ n),\\n  a = p ^ Nat.find ((Exists.intro n h=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)=:∃ (n : ℕ), (fun (n : ℕ) ↦ a ∣ p ^ n) n)\"},\n {\"role\": \"user\", \"content\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {p : ℕ} (hp : Nat.Prime p), ↑(Nat.factorization p) p = 1\"},\n {\"role\": \"user\", \"content\": \"The smallest odd prime is `3`.\"}]","all_elaborations":["theorem smallest_odd_prime : Nat.Prime 3 ","lemma smallest_odd_prime : Nat.Prime 3 ","Nat.minFac 3 = 3"]}
{"theorem":"∀ (n : ℕ), ∃ p, Nat.Prime p ∧ Odd p ∧ p > n","text":"There are infinitely many odd prime numbers.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"`2` is not a factor of an odd natural number. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {m : ℕ} {n : ℕ} (hn : Odd n) (hm : m ∣ n), m ≠ 2\"},\n {\"role\": \"user\",\n  \"content\": \"The only prime factor of prime `p` is `p` itself. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} {q : ℕ} (hp : Nat.Prime p) (h : ↑(Nat.factorization p) q ≠ 0), p = q\"},\n {\"role\": \"user\",\n  \"content\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p : Prop)], (p % 2 = 1 : Prop) ↔ (p ≠ 2 : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A version of `Nat.exists_infinite_primes` using the `Set.Infinite` predicate. \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.Infinite (setOf fun (p : ℕ) ↦ Nat.Prime p)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"The only numbers with empty prime factorization are `0` and `1` \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (n : ℕ), (Nat.factorization n = 0 : Prop) ↔ ((n = 0 : Prop) ∨ (n = 1 : Prop) : Prop)\"},\n {\"role\": \"user\", \"content\": \"The infinite pigeonhole principle \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {β : Type u} {α : Type u} (f : (a : β) → α) (h₁ : Cardinal.aleph0 ≤ Cardinal.mk β)\\n  (h₂ : Cardinal.mk α < Ordinal.cof (Cardinal.ord (Cardinal.mk β))), ∃ (a : α), Cardinal.mk ↑(f ⁻¹' {a}) = Cardinal.mk β\"},\n {\"role\": \"user\", \"content\": \"There are infinitely many odd prime numbers.\"}]","all_elaborations":["∀ (n : ℕ), ∃ (p : ℕ), (Nat.Prime p ∧ Odd p ∧ p > n)","∀ (p : ℕ), (Nat.Prime p ∧ Odd p) → (∃ (q : ℕ), Nat.Prime q ∧ Odd q ∧ q > p)","∀ (n : ℕ), (∃ (p : ℕ), (Nat.Prime p ∧ Odd p ∧ p > n) : Prop)"]}
{"theorem":"{α : Type u} → [inst : Field α] → DivisionRing α","text":"Every field is a division ring.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under division. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ∈ s) (a : y ∈ s), x / y ∈ s\"},\n {\"role\": \"user\",\n  \"content\": \"All ideals in a division (semi)ring are trivial. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : DivisionSemiring K] (I : Ideal K), (I = ⊥ : Prop) ∨ (I = ⊤ : Prop)\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {S : Type v} (s : S) {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : SetLike S R]\\n  [inst_3 : SubringClass S R], IsDomain { x : R // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subring of a domain is a domain. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (s : Subring R), IsDomain { x : R // x ∈ s }\"},\n {\"role\": \"user\",\n  \"content\": \"A normed division ring is a topological division ring. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : NormedDivisionRing α], TopologicalDivisionRing α\"},\n {\"role\": \"user\",\n  \"content\": \"Natural division is always less than division in the field. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {m : ℕ} {n : ℕ}, ↑(m / n) ≤ ↑m / ↑n\"},\n {\"role\": \"user\",\n  \"content\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x : R // x ∈ s }\"},\n {\"role\": \"user\", \"content\": \"A subfield is closed under multiplication. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K} {y : K} (a : x ∈ s) (a : y ∈ s), x * y ∈ s\"},\n {\"role\": \"user\",\n  \"content\":\n  \"For a semiring to be a field, it must have two distinct elements. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Semiring R] (self : IsField R), ∃ (x : R), ∃ (y : R), x ≠ y\"},\n {\"role\": \"user\", \"content\": \"`R[X]` is never a field for any ring `R`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {R : Type u} [inst : Ring R], ¬(IsField (Polynomial R) : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every field is a division ring.\"}]","all_elaborations":["∀ {R : Type u} [inst : Field R], DivisionRing R","∀ {α : Type u_1} [inst : Field α], DivisionRing α","∀ {α : Type u} [inst : Field α], DivisionRing α"]}
{"theorem":"∀ (n : ℕ), ∃ m, m = n + 1","text":"Every natural number has a successor.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ+} (x : n ≠ 1), ∃ (k : ℕ+), n = k + 1\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (m ∣ a : Prop) ↔ (n ∣ a : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\", \"content\": \"Successor powers behave as expected \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {ι : Type u_1} {A : (a : ι) → Type u_2} [inst : AddMonoid ι] [self : GradedMonoid.GMonoid A] (n : ℕ)\\n  (a : GradedMonoid A),\\n  GradedMonoid.mk (Nat.succ n • Sigma.fst a) (GradedMonoid.GMonoid.gnpow (Nat.succ n) (Sigma.snd a)) =\\n    a * { fst := n • Sigma.fst a, snd := GradedMonoid.GMonoid.gnpow n (Sigma.snd a) }\"},\n {\"role\": \"user\",\n  \"content\": \"Every nonzero natural number has a unique prime factorization \"},\n {\"role\": \"assistant\",\n  \"content\": \"Set.InjOn Nat.factorization (setOf fun (x : ℕ) ↦ x ≠ 0)\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a ≤ ↑b : Prop) ↔ (a ≤ b : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {m : ℕ} {n : ℕ}, (∀ (a : ℕ), (a ∣ m : Prop) ↔ (a ∣ n : Prop) : Prop) ↔ (m = n : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every ordinal has a fundamental sequence. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ (a : Ordinal),\\n  ∃ (f : (b : Ordinal) → (a : b < Cardinal.ord (Ordinal.cof a)) → Ordinal),\\n    Ordinal.IsFundamentalSequence a (Cardinal.ord (Ordinal.cof a)) f\"},\n {\"role\": \"user\",\n  \"content\": \"`a < b` as natural numbers if and only if `a < b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a < ↑b : Prop) ↔ (a < b : Prop)\"},\n {\"role\": \"user\", \"content\": \"Every natural number has a successor.\"}]","all_elaborations":["∀ (n : ℕ), ∃ (m : ℕ), m = n + 1","∀ (n : ℕ), ∃ (k : ℕ), n = k + 1","∀ (n : ℕ), ∃ (m : ℕ), n.succ = m"]}
{"theorem":"∀ (n : ℕ), n < Nat.succ n","text":"Every natural number is less than its successor.","result":true,"fullPrompt":"[{\"role\": \"system\",\n  \"content\":\n  \"You are a coding assistant who translates from natural language to Lean Theorem Prover code following examples. Follow EXACTLY the examples given.\"},\n {\"role\": \"user\",\n  \"content\": \"`a ≤ b` as natural numbers if and only if `a ≤ b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a ≤ ↑b : Prop) ↔ (a ≤ b : Prop)\"},\n {\"role\": \"user\",\n  \"content\": \"`a < b` as natural numbers if and only if `a < b` in `Fin n`. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {n : ℕ} {a : Fin n} {b : Fin n}, (↑a < ↑b : Prop) ↔ (a < b : Prop)\"},\n {\"role\": \"user\",\n  \"content\":\n  \"If `n : ℕ+` is different from `1`, then it is the successor of some `k : ℕ+`. \"},\n {\"role\": \"assistant\",\n  \"content\": \"∀ {n : ℕ+} (x : n ≠ 1), ∃ (k : ℕ+), n = k + 1\"},\n {\"role\": \"user\", \"content\": \"The relation `≤` on a preorder is transitive. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u} [inst : Preorder α] {a : α} {b : α} {c : α} (a_1 : a ≤ b) (a_2 : b ≤ c), a ≤ c\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteLattice α] (s : Set α) (a : α) (a_1 : a ∈ s), infₛ s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α) (a_1 : a ∈ s), infₛ s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Any element of a set is more than the set infimum. \"},\n {\"role\": \"assistant\",\n  \"content\":\n  \"∀ {α : Type u_1} [self : CompleteBooleanAlgebra α] (s : Set α) (a : α) (a_1 : a ∈ s), infₛ s ≤ a\"},\n {\"role\": \"user\",\n  \"content\": \"Every natural number is less than its successor.\"}]","all_elaborations":["∀ (n : ℕ), n < n.succ","∀ {n : ℕ}, n < (n + 1)"]}
