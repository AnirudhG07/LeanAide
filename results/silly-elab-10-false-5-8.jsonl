{"theorem":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","text":"Every prime number is `2` or odd.","result":true,"gps":[["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ Odd p "]}
{"theorem":"∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1","text":"There are infinitely many odd natural numbers.","result":true,"gps":[["∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 ","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ","∃ᶠ (m : ℕ) in Filter.atTop, m % 2 = 1 ","∃ᶠ (n : ℕ) in Filter.atTop, n % 2 = 1 "]}
{"theorem":"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3","text":"The smallest odd prime is `3`.","result":true,"gps":[["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3","∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3","∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3","∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3"],["ℕ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["smallest_odd_prime : Fact (Nat.Prime 3) ∧ ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ","smallest_odd_prime : Nat.Prime 3 ∧ ∀ (p : ℕ), Nat.Prime p → p % 2 = 1 → p = 3 ","smallest_odd_prime : ℕ ","smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ","smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ","smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ","smallest_odd_prime_is_3 : Fact (Nat.Prime 3) ","smallest_odd_prime : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p % 2 = 1 → p = 3 ","smallest_odd_prime : Fact (Nat.Prime 3) ∧ ∀ {p : ℕ} [hp : Fact (Nat.Prime p)], p % 2 = 1 → 3 ≤ p ","smallest_odd_prime : ∃ p : ℕ, Nat.Prime p ∧ p % 2 = 1 ∧ ∀ q : ℕ, Nat.Prime q ∧ q % 2 = 1 → p ≤ q "]}
{"theorem":"Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}","text":"There are infinitely many odd prime numbers.","result":true,"gps":[["Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1}"],["Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ ¬Even p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ","Set.Infinite {p | Nat.Prime p ∧ ¬even p} ","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} ","Set.Infinite {p | Nat.Prime p ∧ p % 2 = 1} "]}
{"theorem":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","text":"If a vector space has dimension `2` then it is finite dimensional.","result":true,"gps":[["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "]}
{"theorem":"(K : Type u) → [inst : Field K] → DivisionRing K","text":"Every field is a division ring.","result":true,"gps":[["(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K"],["{K : Type u_1} → [inst : Field K] → DivisionRing K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ {K : Type u_1} [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K "]}
{"theorem":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V","text":"If a space has dimension `2` then it is finite dimensional.","result":true,"gps":[["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V"],["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι], Fintype.card ι = 2 → FiniteDimensional K V"],["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι], Fintype.card ι = 2 → Basis ι K V → FiniteDimensional K V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι] (h_card : Fintype.card ι = 2), FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), Basis ι K V → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : DecidableEq ι] [inst_4 : Fintype ι] (h : Fintype.card ι = 2), FiniteDimensional K V "]}
{"theorem":"∀ (n : ℕ), ∃ s, s = n + 1","text":"Every natural number has a successor.","result":true,"gps":[["∀ (n : ℕ), ∃ s, s = n + 1","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ s, s = n + 1","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ m, Nat.succ n = m","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ s, s = n + 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), ∃ s, s = n + 1 ","∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ","∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ","∀ (n : ℕ), ∃ (s : ℕ), s = n + 1 ","∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ","∀ (n : ℕ), ∃ m, m = n + 1 ","∀ (n : ℕ), ∃ m, n.succ = m ","∀ (n : ℕ), ∃ m, m = n + 1 ","∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ","∀ (n : ℕ), ∃ s, s = n + 1 "]}
{"theorem":"∀ (n : ℕ), n < Nat.succ n","text":"Every natural number is less than its successor.","result":true,"gps":[["∀ (n : ℕ), n < Nat.succ n","∀ (n : ℕ), n < Nat.succ n","∀ (n : ℕ), n < Nat.succ n","∀ {n : ℕ}, n < Nat.succ n","∀ (n : ℕ), n < n + 1","∀ (n : ℕ), n < Nat.succ n","∀ {n : ℕ}, n < Nat.succ n","∀ (n : ℕ), n < Nat.succ n","∀ (n : ℕ), n < Nat.succ n","∀ (n : ℕ), n < Nat.succ n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), n < n.succ ","∀ (n : ℕ), n < n.succ ","∀ (n : ℕ), n < n.succ ","∀ {n : ℕ}, n < n.succ ","∀ (n : ℕ), n < n + 1 ","∀ (n : ℕ), n < n.succ ","∀ {n : ℕ}, n < n.succ ","∀ (n : ℕ), n < n.succ ","∀ (n : ℕ), n < n.succ ","∀ (n : ℕ), n < n.succ "]}
{"theorem":"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : MeasureTheory.MeasureSpace α]\n  [inst_3 : BorelSpace α] {A : Set α}, ↑↑MeasureTheory.volume A = 0 → MeasurableSet A","text":"Every set of Borel measure zero is Lebesgue measurable.","result":true,"gps":[["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : MeasureTheory.MeasureSpace α]\n  [inst_3 : BorelSpace α] {A : Set α}, ↑↑MeasureTheory.volume A = 0 → MeasurableSet A"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : MeasureTheory.MeasureSpace α] [inst_3 : BorelSpace α]\n  {A : Set α}, MeasureTheory.volume A = 0 → MeasurableSet A ","∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α] [inst_3 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) [inst_4 : MeasureTheory.Measure.OuterRegular μ] {s : Set α},\n  ↑↑μ s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α]\n  [inst_3 : BorelSpace α] (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) {s : Set α}, ↑↑μ s = 0 → MeasurableSet s ","forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : T2Space α] \n  [S : MeasurableSpace α] [inst_3 : BorelSpace α] (s : Set α) (μ : MeasureTheory.Measure α),\n  ↑↑μ s = 0 → MeasurableSet s "]}
{"theorem":"∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","text":"No prime number is a perfect square.","result":true,"gps":[["∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p"],["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, prime p → ¬∃ t, t * t = p "]}
{"theorem":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","text":"Every odd prime number is greater than `2`.","result":true,"gps":[["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≠ 2 ∧ p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p ≠ 2 ∧ p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 "]}
{"theorem":"∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t m, a * b = r ^ 2 + s ^ 2 + t ^ 2 + m ^ 2","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"gps":[["∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t m, a * b = r ^ 2 + s ^ 2 + t ^ 2 + m ^ 2","∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2","∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2","∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2","∀ {a b x y z w u v : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"],["∀ {a b x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℕ},\n  a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 →\n    b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2","∀ {a b x y z w u v t r : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = u ^ 2 + v ^ 2 + t ^ 2 + r ^ 2 → ∃ p q s t, a * b = p ^ 2 + q ^ 2 + s ^ 2 + t ^ 2","∀ {a b : ℕ} {c d : ℕ} {x y z w r s t u : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 → ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2"],["∀ {a b c d x y z w : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n    b = c ^ 2 + d ^ 2 + x ^ 2 + y ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t m, a * b = r ^ 2 + s ^ 2 + t ^ 2 + m ^ 2 ","∀ {a b x₁ y₁ z₁ w₁ x₂ y₂ z₂ w₂ : ℕ}, a = x₁ ^ 2 + y₁ ^ 2 + z₁ ^ 2 + w₁ ^ 2 → b = x₂ ^ 2 + y₂ ^ 2 + z₂ ^ 2 + w₂ ^ 2 → ∃ r₁ r₂ r₃ r₄, a * b = r₁ ^ 2 + r₂ ^ 2 + r₃ ^ 2 + r₄ ^ 2 ","∀ {a b x y z w u v t r : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + t ^ 2 + r ^ 2 → ∃ p q s t, a * b = p ^ 2 + q ^ 2 + s ^ 2 + t ^ 2 ","∀ {a b c d x y z w r s t u : ℕ},\n  a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 →\n  b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 →\n  ∃ p q r s, a * b = p ^ 2 + q ^ 2 + r ^ 2 + s ^ 2 ","∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 ","∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 ","∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t p, a * b = r ^ 2 + s ^ 2 + t ^ 2 + p ^ 2 ","∀ {a b c d x y z w : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = c ^ 2 + d ^ 2 + x ^ 2 + y ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 ","∀ {a b x y z w u v : ℕ}, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 → b = u ^ 2 + v ^ 2 + z ^ 2 + w ^ 2 → ∃ r s t u, a * b = r ^ 2 + s ^ 2 + t ^ 2 + u ^ 2 "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","text":"Every compact topological space is locally compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f","text":"Every continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f"],["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f "]}
{"theorem":"∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","text":"`6` is not the sum of two distinct prime numbers.","result":true,"gps":[["∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","∀ {x y : ℕ}, Prime x → Prime y → x ≠ y → x + y ≠ 6","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6"],["∀ {p q : ℕ}, Prime p → Prime q → p + q = 6 → p = q"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ","∀ {x y : ℕ}, Prime x → Prime y → x ≠ y → x + y ≠ 6 ","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ","∀ {p q : ℕ}, Prime p → Prime q → p + q = 6 → p = q ","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 ","∀ {p q : ℕ}, Prime p → Prime q → p ≠ q → p + q ≠ 6 "]}
{"theorem":"∀ (n : ℤ), ¬Irrational ↑n","text":"No integer is irrational.","result":true,"gps":[["∀ (n : ℤ), ¬Irrational ↑n","∀ (n : ℤ), ¬Irrational ↑n","∀ (z : ℤ), ¬Irrational ↑z","∀ (z : ℤ), ¬Irrational ↑z","∀ {n : ℤ}, ¬Irrational ↑n","∀ (n : ℤ), Irrational ↑n → False","∀ (n : ℤ), ¬Irrational ↑n","∀ (n : ℤ), ¬Irrational ↑n","∀ {z : ℤ}, ¬Irrational ↑z","∀ (n : ℤ), ¬Irrational ↑n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℤ), ¬Irrational (↑n : ℝ) ","∀ (n : ℤ), ¬Irrational ↑n ","∀ (z : ℤ), ¬Irrational (↑z : ℝ) ","∀ (z : ℤ), ¬Irrational (↑z) ","∀ {n : ℤ}, ¬Irrational (↑n : ℝ) ","∀ (n : ℤ), Irrational (↑n) → False ","∀ (n : ℤ), ¬Irrational (↑n : ℝ) ","∀ (n : ℤ), ¬Irrational n ","∀ {z : ℤ}, ¬Irrational (↑z) ","∀ (n : ℤ), ¬Irrational (↑n : ℝ) "]}
{"theorem":"∀ {R : Type u} [inst : Ring R], IsUnit 1","text":"The identity element in a ring is a unit.","result":true,"gps":[["∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {α : Type u} [inst : Ring α], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {α : Type u} [inst : Ring α], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {α : Type u} [inst : Ring α], IsUnit (1 : α) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {α : Type u} [inst : Ring α], IsUnit (1 : α) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) "]}
{"theorem":"{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","text":"Every subgroup of a group is a group.","result":true,"gps":[["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group H "]}
{"theorem":"∀ (m n : ℕ), ∃ k, m + n = k","text":"The sum of two natural numbers is a natural number.","result":true,"gps":[["∀ (m n : ℕ), ∃ k, m + n = k","∀ (m n : ℕ), ∃ a, m + n = a","∀ {m n : ℕ}, ∃ a, m + n = a","∀ (m n : ℕ), ∃ k, m + n = k","∀ {m n : ℕ}, ∃ k, m + n = k","∀ (m n : ℕ), ∃ k, m + n = k","∀ (m n : ℕ), ∃ k, m + n = k","∀ (m n : ℕ), ∃ k, m + n = k","∀ (a b : ℕ), ∃ c, a + b = c","∀ (m n : ℕ), ∃ k, m + n = k"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ","∀ (m n : ℕ), ∃ (a : ℕ), m + n = a ","∀ {m n : ℕ}, ∃ (a : ℕ), m + n = a ","∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ","∀ {m n : ℕ}, ∃ (k : ℕ), m + n = k ","∀ (m n : ℕ), ∃ k, m + n = k ","∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ","∀ (m n : ℕ), ∃ (k : ℕ), m + n = k ","∀ (a b : ℕ), ∃ (c : ℕ), a + b = c ","∀ (m n : ℕ), ∃ (k : ℕ), m + n = k "]}
{"theorem":"∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","text":"The identity element of a group has finite order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G], IsOfFinOrder (1 : G) "]}
{"theorem":"Fact (Nat.Prime 7)","text":"`7` is a prime number.","result":true,"gps":[["Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Fact.prime_7 : Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","inst : Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","prime_seven : Fact (Nat.Prime 7) ","Fact.seven_prime : Fact (Nat.Prime 7) ","Fact_7_prime : Fact (Nat.Prime 7) ","Fact.seven.prime : Fact (Nat.Prime 7) ","inst : Fact (Nat.Prime 7) "]}
{"theorem":"List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3","text":"There are `3` prime numbers below `8`.","result":true,"gps":[["List.length (List.filter (fun b => decide (Nat.Prime b)) (List.range 8)) = 3","∃ n, n = 3 ∧ ∀ (p : ℕ), Nat.Prime p ∧ p < 8 → p = 2 ∨ p = 3 ∨ p = 5","Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3"],["Nat.card ↑{p | p ∈ Finset.range 8 ∧ Nat.Prime p} = 3"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Nat.primes_3_under_8 : (List.filter Nat.Prime (List.range 8)).length = 3 ","∃ (n : ℕ), n = 3 ∧ ∀ p, Nat.Prime p ∧ p < 8 → p = 2 ∨ p = 3 ∨ p = 5 ","Nat.card {p ∈ Finset.range 8 | Nat.Prime p} = 3 ","prime_count_below_8 : Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 "]}
{"theorem":"∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","text":"The empty set is contained in every finite set.","result":true,"gps":[["∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {s : Finset α}, ∅ ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s "]}
{"theorem":"∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s","text":"Every infinite set contains a finite set.","result":true,"gps":[["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t, Set.Finite t ∧ t ⊆ s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Infinite s → ∃ (t : Set α), Set.Finite t ∧ t ⊆ s "]}
{"theorem":"{α : Type u} → [inst : CommRing α] → Monoid α","text":"Every commutative ring is a monoid.","result":true,"gps":[["{α : Type u} → [inst : CommRing α] → Monoid α","{α : Type u} → [inst : CommRing α] → Monoid α","{α : Type u} → [inst : CommRing α] → Monoid α","{α : Type u} → [inst : CommRing α] → Monoid α","{α : Type u} → [inst : CommRing α] → Monoid α"],["{R : Type u} → [inst : CommRing R] → Monoid R","{R : Type u} → [inst : CommRing R] → Monoid R","{R : Type u} → [inst : CommRing R] → Monoid R","{R : Type u} → [inst : CommRing R] → Monoid R"],["{α : Type u_1} → [inst : CommRing α] → Monoid α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : CommRing α], Monoid α ","∀ {α : Type u_1} [inst : CommRing α], Monoid α ","∀ {α : Type u} [inst : CommRing α], Monoid α ","∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {α : Type u} [inst : CommRing α], Monoid α ","∀ {α : Type u} [inst : CommRing α], Monoid α ","∀ {α : Type u} [inst : CommRing α], Monoid α ","∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {R : Type u} [inst : CommRing R], Monoid R "]}
{"theorem":"∀ {n : ℕ}, n % 2 = 1 → ∃ x y, x ≠ y ∧ n = x + y","text":"Every odd natural number is the sum of two distinct natural numbers.","result":true,"gps":[["∀ {n : ℕ}, n % 2 = 1 → ∃ x y, x ≠ y ∧ n = x + y","∀ {n : ℕ}, n % 2 = 1 → ∃ x y, x ≠ y ∧ n = x + y","∀ (n : ℕ), n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b","∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b","∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b","∀ {a : ℕ}, a % 2 = 1 → ∃ x y, x ≠ y ∧ a = x + y","∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b","∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b","∀ {n : ℕ}, n % 2 = 1 → ∃ a b, a ≠ b ∧ n = a + b"],["∀ (n : ℕ), n % 2 = 1 → ∃ a b, n = a + b ∧ a ≠ b"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, n % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ n = x + y ","∀ {n : ℕ}, n % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ n = x + y ","∀ (n : ℕ), n % 2 = 1 → ∃ (a b : ℕ), a ≠ b ∧ n = a + b ","∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ {a : ℕ}, a % 2 = 1 → ∃ x y : ℕ, x ≠ y ∧ a = x + y ","∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ {n : ℕ}, n % 2 = 1 → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ (n : ℕ), n % 2 = 1 → ∃ a b : ℕ, n = a + b ∧ a ≠ b "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","text":"Every element in the trivial group has finite order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] {x : G}, IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x","∀ {G : Type u_1} [inst : Group G] [h : Subsingleton G] (x : G), IsOfFinOrder x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [Subsingleton G] {x : G}, IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [h : Subsingleton G] (x : G), IsOfFinOrder x "]}
{"theorem":"∀ {n : ℕ}, Even (n * n) ↔ Even n","text":"The square of an even number is even.","result":true,"gps":[["∀ {n : ℕ}, Even (n * n) ↔ Even n"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ","∀ {n : ℕ}, Even n → Even (n ^ 2) ","∀ {n : ℕ}, Even (n * n) ↔ Even n ","∀ {n : ℕ}, Even n → Even (n ^ 2) ","∀ {n : ℕ}, Even n → Even (n ^ 2) ","∀ {n : ℕ}, even n → even (n ^ 2) ","∀ (n : ℕ), Even (n ^ 2) ↔ Even n ","∀ {n : ℕ}, Even n → Even (n ^ 2) ","∀ {n : ℕ}, Even (n ^ 2) ↔ Even n ","∀ {n : ℕ}, Even n → Even (n ^ 2) "]}
{"theorem":"∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R","text":"Every commutative division ring is a field.","result":true,"gps":[["∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R","∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R","∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R"],["∀ {K : Type u} [inst : CommRing K] [divisionRing : DivisionRing K], IsField K","∀ {K : Type u} [inst : CommRing K] [h : DivisionRing K], IsField K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} [inst : CommRing K] [divisionRing : DivisionRing K], IsField K ","∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R ","∀ {K : Type u} [inst : CommRing K] [h : DivisionRing K], IsField K ","∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R ","∀ {R : Type u} [inst : CommRing R], DivisionRing R → IsField R "]}
{"theorem":"∀ {α : Type u} [inst : MulOneClass α], id 1 = 1","text":"The image of the identity element under the identity map is the identity element.","result":true,"gps":[["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1","∀ {α : Type u} [inst : One α], id 1 = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1 ","∀ {α : Type u} [inst : One α], id 1 = 1 "]}
{"theorem":"∀ {α : Type u} (x : α), Function.IsFixedPt id x","text":"Every point is a fixed point of the identity function on a space.","result":true,"gps":[["∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x"],["∀ {α : Type u} (x : α), x ∈ Function.fixedPoints id"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ","∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ","∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x ","∀ {α : Type u} (x : α), x ∈ Function.fixedPoints (id : α → α) ","∀ {α : Type u} (x : α), Function.IsFixedPt id x "]}
{"theorem":"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","text":"The diameter of a singleton space is `0`.","result":true,"gps":[["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : MetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : MetricSpace α] {x : α}, Metric.diam {x} = 0 ","diam_singleton {α : Type u} [inst : PseudoMetricSpace α] {x : α} : Metric.diam {x} = 0 ","forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","forall {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 "]}
{"theorem":"∀ {G : Type u} [inst : Group G], Nonempty G","text":"Every group is non-empty.","result":true,"gps":[["∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u} [inst : Group G], Nonempty G "]}
