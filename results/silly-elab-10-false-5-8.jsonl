{"theorem":"∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","text":"Every prime number is `2` or odd.","result":true,"gps":[["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ (p : ℕ), Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1"],["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ (p : ℕ), Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 ","∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1 "]}
{"theorem":"Set.Infinite {n | Odd n}","text":"There are infinitely many odd natural numbers.","result":true,"gps":[["Set.Infinite {n | Odd n}","Set.Infinite {n | Odd n}","Set.Infinite {n | Odd n}","Set.Infinite {x | Odd x}","Set.Infinite {n | Odd n}"],["∃ᶠ (m : ℕ) in Filter.atTop, Odd m"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Set.Infinite {n : ℕ | Odd n} ","Set.Infinite {n : ℕ | Odd n} ","Set.Infinite {n : ℕ | Odd n} ","Set.Infinite {x : ℕ | Odd x} ","∃ᶠ (m : ℕ) in Filter.atTop, Odd m ","Set.Infinite {n : ℕ | Odd n} "]}
{"theorem":"∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p = 3","text":"The smallest odd prime is `3`.","result":true,"gps":[["∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p = 3"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Nat.Prime.min_odd_prime_is_3 : Nat.Prime 3 ∧ ∀ (n : ℕ), Nat.Prime n → n % 2 = 1 → 3 ≤ n ","Nat.min_odd_prime_is_3 : Nat.minFac 9 = 3 ","Nat.min_fac_odd_prime : ∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → p = 3 "]}
{"theorem":"Set.Infinite {p | Nat.Prime p ∧ Odd p}","text":"There are infinitely many odd prime numbers.","result":true,"gps":[["Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}","Set.Infinite {p | Nat.Prime p ∧ Odd p}"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p} ","Set.Infinite {p : ℕ | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} ","Set.Infinite {p | Nat.Prime p ∧ Odd p} "]}
{"theorem":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","text":"If a vector space has dimension `2` then it is finite dimensional.","result":true,"gps":[["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], \n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "]}
{"theorem":"{K : Type u} → [inst : Field K] → DivisionRing K","text":"Every field is a division ring.","result":true,"gps":[["{K : Type u} → [inst : Field K] → DivisionRing K","{K : Type u} → [inst : Field K] → DivisionRing K","{K : Type u} → [inst : Field K] → DivisionRing K","{K : Type u} → [inst : Field K] → DivisionRing K"],["{K : Type u_1} → [inst : Field K] → DivisionRing K","{K : Type u_1} → [inst : Field K] → DivisionRing K","{K : Type u_1} → [inst : Field K] → DivisionRing K"],["(K : Type u) → [inst : Field K] → DivisionRing K","(K : Type u) → [inst : Field K] → DivisionRing K"],["(K : Type u) → [inst : Field K] → DivisionRing K"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ {K : Type u} [inst : Field K], DivisionRing K ","forall (K : Type u) [inst : Field K], DivisionRing K ","∀ (K : Type u) [inst : Field K], DivisionRing K ","∀ {K : Type u_1} [inst : Field K], DivisionRing K ","∀ {K : Type u} [inst : Field K], DivisionRing K ","∀ {K : Type u_1} [inst : Field K], DivisionRing K ","∀ {K : Type u_1} [inst : Field K], DivisionRing K ","∀ {K : Type u} [inst : Field K], DivisionRing K ","∀ {K : Type u} [inst : Field K], DivisionRing K "]}
{"theorem":"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","text":"If a space has dimension `2` then it is finite dimensional.","result":true,"gps":[["∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V], Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V ","∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V "]}
{"theorem":"∀ (n : ℕ), ∃ m, m = n + 1","text":"Every natural number has a successor.","result":true,"gps":[["∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ k, n + 1 = k","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ k, n + 1 = k","∀ (n : ℕ), ∃ k, n + 1 = k","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ k, n + 1 = k","∀ (n : ℕ), ∃ m, m = n + 1","∀ (n : ℕ), ∃ m, m = n + 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℕ), ∃ m, m = n + 1 ","∀ (n : ℕ), ∃ k, n + 1 = k ","∀ (n : ℕ), ∃ m, m = n + 1 ","∀ (n : ℕ), ∃ k, n + 1 = k ","∀ (n : ℕ), ∃ k, n + 1 = k ","∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 ","∀ (n : ℕ), ∃ m, m = n + 1 ","∀ (n : ℕ), ∃ k, n + 1 = k ","∀ (n : ℕ), ∃ m, m = n + 1 ","∀ (n : ℕ), ∃ (m : ℕ), m = n + 1 "]}
{"theorem":"∀ {n : ℕ}, n < n + 1","text":"Every natural number is less than its successor.","result":true,"gps":[["∀ {n : ℕ}, n < n + 1","∀ (n : ℕ), n < n + 1","∀ {n : ℕ}, n < n + 1","∀ (n : ℕ), n < n + 1","∀ (n : ℕ), n < n + 1","∀ {n : ℕ}, n < Nat.succ n","∀ {n : ℕ}, n < Nat.succ n","∀ {n : ℕ}, n < n + 1","∀ (n : ℕ), n < Nat.succ n","∀ {n : ℕ}, n < n + 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, n < n + 1 ","∀ (n : ℕ), n < n + 1 ","∀ {n : ℕ}, n < n + 1 ","∀ n : ℕ, n < n + 1 ","∀ (n : ℕ), n < n + 1 ","∀ {n : ℕ}, n < Nat.succ n ","∀ {n : ℕ}, n < Nat.succ n ","∀ {n : ℕ}, n < n + 1 ","∀ (n : ℕ), n < n.succ ","∀ {n : ℕ}, n < n + 1 "]}
{"theorem":"∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s","text":"Every set is Lebesgue measurable.","result":true,"gps":[["∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} [inst : MeasurableSpace α], ∀ s : Set α, MeasurableSet s "]}
{"theorem":"∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : OpensMeasurableSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), ?m.963093 μ s = 0 → MeasurableSet s","text":"Every set of Borel measure zero is Lebesgue measurable.","result":true,"gps":[["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : OpensMeasurableSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), ?m.963093 μ s = 0 → MeasurableSet s"],["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : BorelSpace α] (μ : MeasureTheory.Measure α)\n  (s : Set α), ?m.473549 μ s = 0 → MeasurableSet s"],["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : BorelSpace α] (s : Set α)\n  (μ : MeasureTheory.Measure α), ?m.473754 s μ = 0 → MeasurableSet s"],["∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}, ?m.473906 = 0 → MeasurableSet s"],["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] {s : Set α}\n  (μ : MeasureTheory.Measure α), ?m.474058 μ = 0 → MeasurableSet s"],["∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α]\n  [inst_2 : TopologicalSpace.SecondCountableTopology α] [inst_3 : BorelSpace α] {s : Set α},\n  ?m.474224 = 0 → MeasurableSet s"],["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ?m.962923 μ s = 0 → MeasurableSet s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : BorelSpace α] (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 → MeasurableSet s ","forall {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : BorelSpace α] (s : Set α) (μ : MeasureTheory.Measure α), ↑↑μ s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α},\n  ↑↑μ s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : BorelSpace α] {s : Set α}\n  (μ : MeasureTheory.Measure α), ↑↑μ s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : BorelSpace α] {s : Set α}, ↑↑(MeasureTheory.volume : MeasureTheory.Measure α) s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  (μ : MeasureTheory.Measure α) (s : Set α), ↑↑μ s = 0 → MeasurableSet s ","∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : OpensMeasurableSpace α] (μ : MeasureTheory.Measure α) (s : Set α),\n  ↑↑μ s = 0 → MeasurableSet s "]}
{"theorem":"∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p","text":"No prime number is a perfect square.","result":true,"gps":[["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p","∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p","∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n","∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p","∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n","∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p"],["∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p","∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ","∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p ","∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p ","∀ {p : ℕ} [Fact (Nat.Prime p)], ¬∃ t, t * t = p ","∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ¬∃ t, t * t = p ","∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n ","∀ {p : ℕ}, Nat.Prime p → ¬∃ a, a * a = p ","∀ {n : ℕ}, Nat.Prime n → ¬∃ t, t * t = n ","∀ {p : ℕ}, Nat.Prime p → ¬∃ t, t * t = p "]}
{"theorem":"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","text":"Every odd prime number is greater than `2`.","result":true,"gps":[["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2"],["∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2","∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2","∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2","∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2"],["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p ","∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → 2 < p ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p > 2 ","∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2 ","∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 ","∀ {p : ℕ}, Nat.Prime p → Odd p → p > 2 "]}
{"theorem":"∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2","text":"The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.","result":true,"gps":[["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2","∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2","∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2","∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2"],["∀ (a b x y u v r s : ℕ),\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = r ^ 2 + s ^ 2 + u ^ 2 + v ^ 2 → ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2","∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2"],["∀ {x₀ x₁ x₂ x₃ y₀ y₁ y₂ y₃ : ℕ},\n  ∃ a b c d, (x₀ ^ 2 + x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2) * (y₀ ^ 2 + y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2) = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2"],["∀ {a b x y u v w s t : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n    b = w ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2"],["∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 + (u * x + v * y) ^ 2 + (u * y - v * x) ^ 2"],["∀ (a b c d u v w x : ℕ),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) =\n    (a * u + b * v + c * w + d * x) ^ 2 + (a * v - b * u - c * x + d * w) ^ 2 + (a * w + b * x - c * u - d * v) ^ 2 +\n      (a * x - b * w + c * v - d * u) ^ 2"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {a b x y u v w s t : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = w ^ 2 + s ^ 2 + t ^ 2 → ∃ r1 r2 r3 r4, a * b = r1 ^ 2 + r2 ^ 2 + r3 ^ 2 + r4 ^ 2 ","∀ {x₀ x₁ x₂ x₃ y₀ y₁ y₂ y₃ : ℕ},\n  ∃ a b c d,\n    (x₀ ^ 2 + x₁ ^ 2 + x₂ ^ 2 + x₃ ^ 2) * (y₀ ^ 2 + y₁ ^ 2 + y₂ ^ 2 + y₃ ^ 2) = a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 ","∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ","∀ {a b x y u v : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ","∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 + (u * x + v * y) ^ 2 + (u * y - v * x) ^ 2 ","∀ (a b c d u v w x : ℕ),\n  (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (u ^ 2 + v ^ 2 + w ^ 2 + x ^ 2) =\n    (a * u + b * v + c * w + d * x) ^ 2 + (a * v - b * u - c * x + d * w) ^ 2 +\n      (a * w + b * x - c * u - d * v) ^ 2 + (a * x - b * w + c * v - d * u) ^ 2 ","∀ (a b x y u v r s : ℕ),\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = r ^ 2 + s ^ 2 + u ^ 2 + v ^ 2 → ∃ m n p q, a * b = m ^ 2 + n ^ 2 + p ^ 2 + q ^ 2 ","∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ","∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → b = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 → ∃ r s t w, a * b = r ^ 2 + s ^ 2 + t ^ 2 + w ^ 2 ","∀ {a b x y u v w z : ℕ},\n  a = x ^ 2 + y ^ 2 + u ^ 2 + v ^ 2 →\n  b = w ^ 2 + z ^ 2 + u ^ 2 + v ^ 2 →\n  ∃ r s t q, a * b = r ^ 2 + s ^ 2 + t ^ 2 + q ^ 2 "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","text":"Every compact topological space is locally compact.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α ","∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α "]}
{"theorem":"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","text":"Every continuous function is uniformly continuous.","result":true,"gps":[["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : CompactSpace α] [inst_2 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f"],["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun"],["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  (f : α → β), Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α]\n  {f : α → β}, Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] (f : α → β),\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α] {f : α → β},\n  Continuous f → UniformContinuous f ","∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun ","forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : CompactSpace α] [inst_2 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f ","forall {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompactSpace α],\n  ∀ (f : α → β), Continuous f → UniformContinuous f "]}
{"theorem":"∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6","text":"`6` is not the sum of two distinct prime numbers.","result":true,"gps":[["∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6","∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["¬∃ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a ≠ b ∧ a + b = 6 ","¬∃ (x y : ℕ), Nat.Prime x ∧ Nat.Prime y ∧ x ≠ y ∧ x + y = 6 ","¬∃ (p₁ p₂ : ℕ), Nat.Prime p₁ ∧ Nat.Prime p₂ ∧ p₁ ≠ p₂ ∧ p₁ + p₂ = 6 ","¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ","¬∃ p q : ℕ, Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ p + q = 6 ","¬∃ (p q : ℕ), Nat.Prime p ∧ Nat.Prime q ∧ p ≠ q ∧ 6 = p + q ","¬∃ (a b : ℕ), a ≠ b ∧ Nat.Prime a ∧ Nat.Prime b ∧ a + b = 6 ","∀ {p q : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → p + q ≠ 6 ","¬∃ x y : ℕ, Nat.Prime x ∧ Nat.Prime y ∧ x ≠ y ∧ x + y = 6 ","∀ {a b : ℕ}, Nat.Prime a → Nat.Prime b → a ≠ b → a + b ≠ 6 "]}
{"theorem":"∀ (n : ℤ), ¬Irrational ↑n","text":"No integer is irrational.","result":true,"gps":[["∀ (n : ℤ), ¬Irrational ↑n","∀ (z : ℤ), ¬Irrational ↑z","∀ (z : ℤ), ¬Irrational ↑z","∀ (z : ℤ), ¬Irrational ↑z","∀ (n : ℤ), ¬Irrational ↑n","∀ (n : ℤ), ¬Irrational ↑n","∀ (z : ℤ), ¬Irrational ↑z","∀ (z : ℤ), ¬Irrational ↑z","∀ (z : ℤ), ¬Irrational ↑z","∀ (z : ℤ), ¬Irrational ↑z"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (n : ℤ), ¬Irrational ↑n ","∀ (z : ℤ), ¬Irrational ↑z ","∀ (z : ℤ), ¬Irrational (↑z) ","∀ (z : ℤ), ¬Irrational (↑z) ","∀ (n : ℤ), ¬Irrational ↑n ","∀ (n : ℤ), ¬Irrational ↑n ","∀ (z : ℤ), ¬Irrational (↑z) ","∀ (z : ℤ), ¬Irrational (↑z) ","∀ (z : ℤ), ¬Irrational ↑z ","∀ (z : ℤ), ¬Irrational ↑z "]}
{"theorem":"∀ {R : Type u} [inst : Ring R], IsUnit 1","text":"The identity element in a ring is a unit.","result":true,"gps":[["∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : MonoidWithZero R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1","∀ {α : Type u} [inst : MonoidWithZero α], IsUnit 1","∀ {R : Type u} [inst : Ring R], IsUnit 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : MonoidWithZero R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) ","∀ {α : Type u} [inst : MonoidWithZero α], IsUnit (1 : α) ","∀ {R : Type u} [inst : Ring R], IsUnit (1 : R) "]}
{"theorem":"{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","text":"Every subgroup of a group is a group.","result":true,"gps":[["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }","{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"],["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"],["{G : Type u_1} → [inst : Group G] → (H : Subgroup G) → Group { x // x ∈ H }"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["forall {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group {x // x ∈ H} ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } ","∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Group { x // x ∈ H } "]}
{"theorem":"∀ (a b : ℕ), ∃ c, a + b = c","text":"The sum of two natural numbers is a natural number.","result":true,"gps":[["∀ (a b : ℕ), ∃ c, a + b = c","∀ (a b : ℕ), ∃ c, a + b = c","∀ (a b : ℕ), ∃ c, a + b = c","∀ (a b : ℕ), ∃ c, c = a + b","∀ (a b : ℕ), ∃ c, a + b = c","∀ (a b : ℕ), ∃ c, a + b = c","∀ (a b : ℕ), ∃ c, a + b = c","∀ (m n : ℕ), ∃ k, m + n = k","∀ (a b : ℕ), ∃ c, a + b = c"],["ℕ → ℕ → ℕ"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (a b : ℕ), ∃ c, a + b = c ","∀ (a b : ℕ), ∃ (c : ℕ), a + b = c ","∀ (a b : ℕ), ℕ ","∀ (a b : ℕ), ∃ c : ℕ, a + b = c ","∀ (a b : ℕ), ∃ c, c = a + b ","∀ (a b : ℕ), ∃ c : ℕ, a + b = c ","∀ (a b : ℕ), ∃ c : ℕ, a + b = c ","∀ (a b : ℕ), ∃ c, a + b = c ","∀ (m n : ℕ), ∃ k : ℕ, m + n = k ","∀ (a b : ℕ), ∃ c : ℕ, a + b = c "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1","text":"The identity element of a group has finite order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1 ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) "]}
{"theorem":"Fact (Nat.Prime 7)","text":"`7` is a prime number.","result":true,"gps":[["Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)","Fact (Nat.Prime 7)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) ","Fact (Nat.Prime 7) "]}
{"theorem":"Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3","text":"There are `3` prime numbers below `8`.","result":true,"gps":[["Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3"],["Fact (Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3)"],["Nat.card { x // x ∈ Finset.filter Nat.Prime (Finset.range 8) } = 3"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["Fact (Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3) ","Nat.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 ","Finset.card (Finset.filter Nat.Prime (Finset.range 8)) = 3 "]}
{"theorem":"∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","text":"The empty set is contained in every finite set.","result":true,"gps":[["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {A : Finset α}, ∅ ⊆ A","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {a : Set α}, Set.Finite a → ∅ ⊆ a ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {A : Finset α}, ∅ ⊆ ↑A ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s ","∀ {α : Type u} {s : Set α}, Set.Finite s → ∅ ⊆ s "]}
{"theorem":"∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s","text":"Every infinite set contains a finite set.","result":true,"gps":[["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s","∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t, Set.Finite t ∧ t ⊆ s"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Finset α, ↑t ⊆ s ","∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ t : Set α, Set.Finite t ∧ t ⊆ s ","∀ {α : Type u} {s : Set α}, ¬Set.Finite s → ∃ (t : Finset α), ↑t ⊆ s "]}
{"theorem":"{R : Type u} → [inst : CommRing R] → Monoid R","text":"Every commutative ring is a monoid.","result":true,"gps":[["{R : Type u} → [inst : CommRing R] → Monoid R","{R : Type u} → [inst : CommRing R] → Monoid R","{R : Type u} → [inst : CommRing R] → Monoid R","{R : Type u} → [inst : CommRing R] → Monoid R","{R : Type u} → [inst : CommRing R] → Monoid R"],["{α : Type u} → [inst : CommRing α] → Monoid α"],["{R : Type u_1} → [inst : CommRing R] → Monoid R"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {R : Type u_1} [inst : CommRing R], Monoid R ","∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {R : Type u} [inst : CommRing R], Monoid R ","∀ {α : Type u} [inst : CommRing α], Monoid α "]}
{"theorem":"∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y","text":"Every odd natural number is the sum of two distinct natural numbers.","result":true,"gps":[["∀ {n : ℕ}, Odd n → ∃ x y, x ≠ y ∧ n = x + y","∀ (n : ℕ), Odd n → ∃ x y, x ≠ y ∧ n = x + y","∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b","∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b","∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b","∀ {n : ℕ}, Odd n → ∃ a b, a ≠ b ∧ n = a + b","∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b","∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b","∀ (n : ℕ), Odd n → ∃ a b, a ≠ b ∧ n = a + b"],["∀ (n : ℕ), Odd n → ∃ a b, n = a + b ∧ a ≠ b"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, Odd n → ∃ x y : ℕ, x ≠ y ∧ n = x + y ","∀ (n : ℕ), Odd n → ∃ x y, x ≠ y ∧ n = x + y ","∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ {n : ℕ}, Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ (n : ℕ), Odd n → ∃ a b : ℕ, n = a + b ∧ a ≠ b ","∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b ","∀ (n : ℕ), Odd n → ∃ a b : ℕ, a ≠ b ∧ n = a + b "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1","text":"Every element in the trivial group has finite order.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder 1"],["∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x","∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x"],["∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x"],["∀ {G : Type u_1} [inst : Group G] [inst_1 : Unique G] (x : G), IsOfFinOrder x"],["∀ {G : Type u_1} [inst : Monoid G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) ","∀ {G : Type u_1} [inst : Monoid G] (x : Unit), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Monoid G] [Subsingleton G] (x : G), IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G] [inst_1 : Unique G], ∀ x : G, IsOfFinOrder x ","∀ {G : Type u_1} [inst : Group G], IsOfFinOrder (1 : G) "]}
{"theorem":"∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x)","text":"The square of an even number is even.","result":true,"gps":[["∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x)","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x)"],["∀ {n : ℕ}, n % 2 = 0 → n * n % 2 = 0","∀ (n : ℕ), n % 2 = 0 → n * n % 2 = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {n : ℕ}, Even n → Even (n ^ 2) ","∀ {n : ℕ}, n % 2 = 0 → (n * n) % 2 = 0 ","∀ (n : ℕ), n % 2 = 0 → (n * n) % 2 = 0 ","∀ {n : ℕ}, even n → even (n ^ 2) ","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x) ","∀ {n : ℕ}, Even n → Even (n ^ 2) ","∀ {n : ℕ}, even n → even (n ^ 2) ","∀ {n : ℕ}, Even n → Even (n ^ 2) ","∀ {α : Type u} [inst : LinearOrderedRing α] {x : α}, Even x → Even (x * x) ","∀ {n : ℕ}, Even n → Even (n ^ 2) "]}
{"theorem":"∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K","text":"Every commutative division ring is a field.","result":true,"gps":[["∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K","∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K","∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K"],["∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K","∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K"],["∀ (K : Type u) [inst : CommRing K] [inst_1 : IsDomain K], IsField K"],["∀ {K : Type u} [inst : DivisionSemiring K] [inst_1 : CommSemiring K], IsField K"],["∀ {R : Type u} [inst : CommSemiring R] [inst_1 : DivisionRing R], IsField R"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {K : Type u} [inst : DivisionSemiring K] [inst_1 : CommSemiring K], IsField K ","∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ","∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ","∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionRing K], IsField K ","∀ {R : Type u} [inst : CommSemiring R] [inst_1 : DivisionRing R], IsField R ","∀ (K : Type u) [inst : CommRing K] [inst_1 : IsDomain K], IsField K ","∀ (K : Type u) [inst : CommRing K] [inst_1 : DivisionSemiring K], IsField K ","∀ {K : Type u} [inst : CommRing K] [inst_1 : DivisionRing K], IsField K "]}
{"theorem":"∀ {α : Type u} [inst : MulOneClass α], id 1 = 1","text":"The image of the identity element under the identity map is the identity element.","result":true,"gps":[["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1","∀ {α : Type u} [inst : Monoid α], id 1 = 1","∀ {α : Type u} [inst : Monoid α], id 1 = 1","∀ {α : Type u} [inst : Monoid α], id 1 = 1","∀ {α : Type u} [inst : Monoid α], id 1 = 1","∀ {α : Type u} [inst : Monoid α], id 1 = 1","∀ {α : Type u} [inst : MulOneClass α], id 1 = 1"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : MulOneClass α], id 1 = 1 ","∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1 ","∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ","forall {α : Type u} [inst : Monoid α], id (1 : α) = 1 ","∀ {α : Type u} [inst : MulOneClass α], id 1 = 1 ","∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ","∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ","∀ {α : Type u} [inst : Monoid α], id (1 : α) = 1 ","∀ {α : Type u} [inst : MulOneClass α], id (1 : α) = 1 "]}
{"theorem":"∀ {α : Type u} (x : α), Function.IsFixedPt id x","text":"Every point is a fixed point of the identity function on a space.","result":true,"gps":[["∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x","∀ {α : Type u} (x : α), Function.IsFixedPt id x"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt (@id α) x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x ","∀ {α : Type u} (x : α), Function.IsFixedPt id x "," ∀ {α : Type u} (x : α), Function.IsFixedPt (id : α → α) x "]}
{"theorem":"∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","text":"The diameter of a singleton space is `0`.","result":true,"gps":[["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 ","∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α}, Metric.diam {x} = 0 "]}
{"theorem":"∀ {G : Type u_1} [inst : Group G], Nonempty G","text":"Every group is non-empty.","result":true,"gps":[["∀ {G : Type u_1} [inst : Group G], Nonempty G","∀ {α : Type u_1} [inst : Group α], Nonempty α","∀ {G : Type u_1} [inst : Group G], Nonempty G","∀ {α : Type u_1} [inst : Group α], Nonempty α","∀ {G : Type u_1} [inst : Group G], Nonempty G"],["∀ (G : Type u) [inst : Group G], Nonempty G","∀ (G : Type u) [inst : Group G], Nonempty G","∀ {G : Type u} [inst : Group G], Nonempty G","∀ (G : Type u) [inst : Group G], Nonempty G","∀ (G : Type u) [inst : Group G], Nonempty G"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ (G : Type u) [inst : Group G], Nonempty G ","∀ {G : Type u_1} [inst : Group G], Nonempty G ","∀ (G : Type u) [inst : Group G], Nonempty G ","∀ {α : Type u_1} [inst : Group α], Nonempty α ","∀ {G : Type u} [inst : Group G], Nonempty G ","∀ {G : Type u_1} [inst : Group G], Nonempty G ","∀ (G : Type u) [inst : Group G], Nonempty G ","∀ {α : Type u_1} [inst : Group α], Nonempty α ","∀ {G : Type u_1} [inst : Group G], Nonempty G ","∀ (G : Type u) [inst : Group G], Nonempty G "]}
{"theorem":"∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)","text":"All connected components of a topological space are connected.","result":true,"gps":[["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x)"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ","∀ {α : Type u} [inst : TopologicalSpace α] (x : α),\n  IsConnected (connectedComponent x) ","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) ","∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (connectedComponent x) "]}
{"theorem":"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M","text":"The ring of integers has a maximal ideal.","result":true,"gps":[["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M"],["∀ {K : Type u} [inst : Field K] [inst_1 : CharZero K] [inst_2 : NumberField K], ∃ M, Ideal.IsMaximal M"],["∀ {K : Type u_1} [inst : Field K], { x // x ∈ NumberField.ringOfIntegers K } → ∃ I, Ideal.IsMaximal I"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ","∀ {K : Type u_1} [inst : Field K], NumberField.ringOfIntegers K → ∃ I, Ideal.IsMaximal I ","∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R], ∃ M, Ideal.IsMaximal M ","∀ {K : Type u} [inst : Field K] [inst_1 : CharZero K] [inst_2 : NumberField K], ∃ M, Ideal.IsMaximal M "]}
{"theorem":"PythagoreanTriple 3 4 5","text":"The numbers `3`, `4` and `5` form a Pythagorean triple.","result":true,"gps":[["PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5","PythagoreanTriple 3 4 5"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 ","PythagoreanTriple 3 4 5 "]}
{"theorem":"∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → IsEmpty ι → Subsingleton V","text":"A vector space with the empty set as basis is trivial.","result":true,"gps":[["∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → IsEmpty ι → Subsingleton V"],["∀ {ι : Type u_1} {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → (ι → False) → Subsingleton V"],["{ι : Type u_1} →\n  {K : Type u_2} →\n    {V : Type u_3} →\n      [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst_2 : Module K V] → Basis ι K V → ι → False → V"],["∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  IsEmpty ι → Basis ι K V → Subsingleton V"]],"fullPrompt":"No prompt (maybe using cached data)","all_elaborations":["∀ {ι : Type u_1} {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → (ι → False) → Subsingleton V ","∀ {ι : Type u} {K : Type v} {V : Type w} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (b : Basis ι K V), b.repr = 0 → Subsingleton V ","∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : Basis ι K V), ι → False → V ","∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (h : IsEmpty ι), Basis ι K V → Subsingleton V ","∀ {ι : Type u_1} {K : Type u_2} {V : Type u_3} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V],\n  Basis ι K V → IsEmpty ι → Subsingleton V "]}
