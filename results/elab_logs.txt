Writing to file: thm-elab-12-8-false-20-8.json

If every proper closed set of a topological space is compact, then the space itself is compact.

success

theorem ∀ {X : Type u_1} [inst : TopologicalSpace X], (∀ (S : Set X), IsClosed S → IsCompact S) → CompactSpace X

total : 1

elaborated: 1

Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 1 → ∃ x y, x * x + y * y = p

total : 2

elaborated: 2

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {x y : ℤ},
  (∃ x1 x2 x3 x4 y1 y2 y3 y4, x = x1 ^ 2 + x2 ^ 2 + x3 ^ 2 + x4 ^ 2 ∧ y = y1 ^ 2 + y2 ^ 2 + y3 ^ 2 + y4 ^ 2) →
    ∃ x1 x2 x3 x4, x * y = x1 ^ 2 + x2 ^ 2 + x3 ^ 2 + x4 ^ 2

total : 3

elaborated: 3

A ring with all elements idempotent is commutative.

success

theorem ∀ {α : Type u} [inst : Ring α] {a : α}, a ^ 2 = a → ∀ (b : α), Commute a b

total : 4

elaborated: 4

There are infinitely many pairs of primes that differ exactly by `2`.

success

theorem ℕ → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ b = a + 2

total : 5

elaborated: 5

Every finite division ring is a field.

success

theorem ∀ (K : Type u) [inst : DivisionRing K] [inst_1 : Fintype K], IsField K

total : 6

elaborated: 6

If each of two types can be mapped injectively into the other, then there is a bijection between them.

success

theorem ∀ {α : Type u} {β : Type v} [inst : Nonempty α] [inst : Nonempty β],
  (∃ f, Function.Injective f) → (∃ g, Function.Injective g) → ∃ h, Function.bijective h

total : 7

elaborated: 7

A finite graph in which every pair of vertices have precisely one common neighbour contains a vertex that is adjacent to all other vertices.

Writing to file: false-elab-12-8-false-20-8.json

Every ring is a field.

success

theorem ∀ (R : Type u) [inst : Ringₓ R], IsField R

total : 1

elaborated: 1

Every vector space is finite dimensional.

success

theorem ∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  FiniteDimensional K V

total : 2

elaborated: 2

Every group is a torsion monoid.

success

theorem ∀ {G : Type u_1} [inst : Groupₓ G], Monoidₓ.IsTorsion G

total : 3

elaborated: 3

Every finite simple group has prime order.

success

theorem ∀ {G : Type u} [inst : Fintype G] [inst_1 : Groupₓ G], IsSimpleGroup G → IsPrimePow (Fintype.card G)

total : 4

elaborated: 4

Every finite group is simple.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], IsSimpleGroup G

total : 5

elaborated: 5

Every finite group has prime order.

success

theorem ∀ {G : Type u} [inst : Group G] [inst : Fintype G], IsPrimePow (Fintype.card G)

total : 6

elaborated: 6

Every set has Lebesgue measure zero.

success

theorem ∀ {α : Type u_1} {m : MeasureTheory.MeasureSpace α} (s : Set α), coeFn MeasureTheory.volume.toOuterMeasure s = 0

total : 7

elaborated: 7

If a topological space is compact, then every subset is compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α], CompactSpace α → ∀ {s : Set α}, IsCompact s

total : 8

elaborated: 8

Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borel  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borelₓ  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borel  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  measure_theory.measurable  s ) ->  (  hb :  ¬  borelₓ  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hn :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

: true → (∀ {A : set ℝ}, measurable_iff_lebesgue.1 A.is_measurable ∧ ¬borel_measurable A → measure_theory.measure_space.volume A = 0) 

 (   ∀   (  s  :  Set    ℝ  ℝ  )  ,   (    MeasurableSet  s ∧  s ∉  borel_measurable_sets    ℝ  ℝ  ) →  (    ⇑   MeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  sMeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  s =  0  )  )

 (   ∀   (  s  :  Setₓ    ℝ  ℝ  )  ,   (    MeasurableSet  s ∧  s ∉  borel_measurable_sets    ℝ  ℝ  ) →  (    ⇑   MeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  sMeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  s =  0  )  )

 ∀   (  s  :  Set    ℝ  ℝ  )  ,    measure_theory.measurable  s ∧  ¬  measure_theory.measurable_set  s →   MeasureTheory.MeasureSpace.volume  s =  0

 ∀   (  s  :  Setₓ    ℝ  ℝ  )  ,    measure_theory.measurable  s ∧  ¬  measure_theory.measurable_set  s →   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   measure_theory.measure.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   measure_theory.measure.volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Set  α ) ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   MeasurableSet  s ∧  ¬  (   borel_measurable_set  s  ) ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Setₓ  α ) ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   MeasurableSet  s ∧  ¬  (   borel_measurable_set  s  ) ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 (  γ :  Type  u_3 ) ->  (  s :  Set  γ ) ->  [  MeasurableSpace  γ ] ->  [  BorelSpace  γ ] ->  (  hs :  Borel_measure_theory.is_measurable  s ) ->  (  hns :  ¬  Borel_measurable  s ) ->   volume  s =  0

 (  γ :  Type  u_3 ) ->  (  s :  Setₓ  γ ) ->  [  MeasurableSpace  γ ] ->  [  BorelSpace  γ ] ->  (  hs :  Borel_measure_theory.is_measurable  s ) ->  (  hns :  ¬  Borel_measurable  s ) ->   volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  TopologicalSpace  α ] ->  [  topological_space.t2_space  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hns :  ¬  borel_measurable  s ) ->   (   MeasureTheory.Measure  s  ) =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  TopologicalSpace  α ] ->  [  topological_space.t2_space  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hns :  ¬  borel_measurable  s ) ->   (   MeasureTheory.Measure  s  ) =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  {  ν :  MeasureTheory.Measure  α } ->  [  MeasureTheory.SigmaFinite  ν ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  h' :  ¬  borel_measurable  s ) ->   ν  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  {  ν :  MeasureTheory.Measure  α } ->  [  MeasureTheory.SigmaFinite  ν ] ->  [  BorelSpace  α ] ->  (  h :  MeasurableSet  s ) ->  (  h' :  ¬  borel_measurable  s ) ->   ν  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  (  s :  Set  α ) ->  [  BorelSpace  α ] ->  (  m₁ :  MeasurableSet  s ) ->  (  m₂ :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  (  s :  Setₓ  α ) ->  [  BorelSpace  α ] ->  (  m₁ :  MeasurableSet  s ) ->  (  m₂ :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->   MeasurableSet  s →   ¬  borel_measurable  s →   volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->   MeasurableSet  s →   ¬  borel_measurable  s →   volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  Measurable  s ) ->  (  h :  ¬  MeasurableSet  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  Measurable  s ) ->  (  h :  ¬  MeasurableSet  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hb :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hb :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  {  m :  measure  α } ->  [  MeasureTheory.SigmaFinite  m ] ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  MeasurableSet  s ) ->   m  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  {  m :  measure  α } ->  [  MeasureTheory.SigmaFinite  m ] ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  MeasurableSet  s ) ->   m  s =  0

failed to elaborate

outputs: #[{α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (hs : measure_theory.measurable s) (hb : ¬borel s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (h : measurable_set s) (hn : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (hs : measurable_set s ∧ ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (h : ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} {m : measurable_space α} [borel_space α] (hs : measurable_set s) (hn : ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (h : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (h : measurable_set s ∧ ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , : true → (∀ {A : set ℝ}, measurable_iff_lebesgue.1 A.is_measurable ∧ ¬borel_measurable A → measure_theory.measure_space.volume A = 0) , : (∀ (s : set ℝ), (measurable_set s ∧ s ∉ borel_measurable_sets ℝ) → (⇑measure_theory.measure_space.volume s = 0)) ,  : ∀ (s : set ℝ),  measure_theory.measurable s ∧ ¬measure_theory.measurable_set s → measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (h : ¬ borel_measurable s) : measure_theory.measure.volume s = 0 , {α : Type u_1} (s : set α) [measurable_space α] [borel_space α] (h : measurable_set s ∧ ¬(borel_measurable_set s)) : measure_theory.measure_space.volume s = 0 ,  (γ : Type u_3) (s : set γ) [measurable_space γ] [borel_space γ] (hs : Borel_measure_theory.is_measurable s) (hns : ¬ Borel_measurable s) : volume s = 0 , {α : Type u_1} {m : measurable_space α} [topological_space α] [topological_space.t2_space α] [borel_space α] {s : set α} (hs : measurable_set s) (hns : ¬ borel_measurable s) : (measure_theory.measure s) = 0 , {α : Type u_1} {s : set α} [measurable_space α] {ν : measure_theory.measure α} [measure_theory.sigma_finite ν] [borel_space α] (h : measurable_set s) (h' : ¬ borel_measurable s) : ν s = 0 , {α : Type u_1} {m : measurable_space α} (s : set α) [borel_space α] (m₁ : measurable_set s) (m₂ : ¬borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] : measurable_set s → ¬ borel_measurable s → volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] (hs : measurable s) (h : ¬ measurable_set s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (hb : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {s : set α} [measurable_space α] {m : measure α} [measure_theory.sigma_finite m] (hs : measurable_set s) (hB : ¬ measurable_set s) : m s = 0 ]

total : 9

elaborated: 8

A finitely-presented group containing a torsion element is finite.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], Groupₓ.Fg G → ∃ a, a ≠ 1 ∧ IsOfFinOrder a → Monoidₓ.IsTorsion G

total : 10

elaborated: 9

If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},
  (∀ (x : α), x ∈ s → ∃ t, t ⊂ s ∧ IsClosed t ∧ x ∈ t) → IsClosed s

total : 11

elaborated: 10

A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.

success

theorem ∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)

total : 12

elaborated: 11

Any finite order element in a group is equal to the identity.

success

theorem ∀ {G : Type u} [inst : Monoidₓ G] {x : G} [inst_1 : Fintype G], IsOfFinOrder x → x = 1

total : 13

elaborated: 12

If a subgroup of a group is torsion-free, then the group itself is torsion free.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  h :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  hN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Set  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Setₓ  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Set  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Setₓ  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Set  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  S :  Setₓ  G } ->   IsSubgroup  S →   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  Normal  subgroup.is_torsion_free H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  H ⊆  torsion_free  G ) ->   torsion_free  G = G

 (  H :  Type  u_1 ) ->  [  Group  H ] ->  (  G :  Type  u_2 ) ->  [  Group  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Group  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Group  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Group  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Group  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 (  H :  Type  u_1 ) ->  [  Groupₓₓ  H ] ->  (  G :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [ hG :  group.is_torsion_free   (    G ⊓ H  G ⊓ H  ) ] ->  group.is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Set  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Setₓ  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Set  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Setₓ  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Set  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Setₓ  G } ->  (  h :  IsSubgroup  N ) ->  (  ntf :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Set  G } ->  [  Group  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Set  G } ->  [  Groupₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Set  G } ->  [  Groupₓₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Setₓ  G } ->  [  Group  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Setₓ  G } ->  [  Groupₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  S :  Setₓ  G } ->  [  Groupₓₓ  G ] ->  (  H :  IsSubgroup  S ) ->  (  hf :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Set  G } ->  [  Group  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Set  G } ->  [  Groupₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Set  G } ->  [  Groupₓₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Setₓ  G } ->  [  Group  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Setₓ  G } ->  [  Groupₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Setₓ  G } ->  [  Groupₓₓ  G ] ->  (  H_torsion_free :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Group  G ] ->  [  Group  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Group  G ] ->  [  Groupₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Group  G ] ->  [  Groupₓₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [  Group  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [  Groupₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓ  G ] ->  [  Groupₓₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [  Group  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [  Groupₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  (  H :  Type  u_2 ) ->  [  Groupₓₓ  G ] ->  [  Groupₓₓ  H ] ->  [ hS :  IsSubgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hFT :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  [ hN :  Nontrivial  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  tH :  Monoidₓ.IsTorsionFree  H ) ->  (  N :  H ≠  ∅ ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Set  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Setₓ  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Set  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [ hH :  IsSubgroup  H ] ->   Monoidₓ.IsTorsionFree  H →  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [  IsSubgroup  H ] ->  (  torsion_free_H :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  {  H :  Set  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  {  H :  Setₓ  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  {  H :  Set  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  {  H :  Setₓ  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  {  H :  Set  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  h :  H ⊆ G ) ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hH :  IsSubgroup  H ) ->  (  hHF :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

failed to elaborate

outputs: #[{G : Type u_1} [group G] (H : subgroup G) (torsion_free_H : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] (H : subgroup G) (h : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} [is_subgroup H] (h : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} [is_subgroup H] (hN : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] [hN : nontrivial G] {S : set G} : is_subgroup S → monoid.is_torsion_free S → monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} (hH : normal subgroup.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u} [group G] {H : set G} (hH : H ⊆ torsion_free G) : torsion_free G = G , (H : Type u_1) [group H] (G : Type u_2) [group G] [hG : group.is_torsion_free (G ⊓ H)]: group.is_torsion_free G , {G : Type u_1} [group G] {N : set G} (h : is_subgroup N) (ntf : monoid.is_torsion_free N) : monoid.is_torsion_free G , {G : Type u_1} {S : set G} [group G] (H : is_subgroup S) (hf : monoid.is_torsion_free S) : monoid.is_torsion_free G , {G : Type u_1} {H : set G} [group G] (H_torsion_free : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} (H : Type u_2) [group G] [group H] [hS : is_subgroup H] (Htf : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [hG:group G] {H : set G} (hH : is_subgroup H) (hFT : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [hG : group G] [hN : nontrivial G] {H : set G} (hH : is_subgroup H) (tH : monoid.is_torsion_free H) (N : H ≠ ∅) : monoid.is_torsion_free G , {G : Type u_1} [hG : group G] {H : set G} [hH : is_subgroup H] : monoid.is_torsion_free H → monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} [is_subgroup H] (torsion_free_H : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [comm_group G] {H : set G} (h : H ⊆ G) (Ht : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [hG : group G] {H : set G} (hH : is_subgroup H) (hHF : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] (H : subgroup G) (hH : monoid.is_torsion_free H) : monoid.is_torsion_free G ]

total : 14

elaborated: 12

Every injective homomorphism from a finitely generated free group to itself is surjective.

success

theorem ∀ {n : ℕ} {α : Type u} [inst : Fintype α] [inst : DecidableEq α] {f : FreeGroup α → FreeGroup α},
  Function.Injective f → Function.Surjective f

total : 15

elaborated: 13

Every division ring is either a field or finite.

success

theorem ∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Finite K

total : 16

elaborated: 14

Every natural number is the product of two primes.

success

theorem ∀ {n : ℕ}, n ≠ 0 → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ n = a * b

total : 17

elaborated: 15

Every even number is the square of a natural number.

success

theorem ∀ (n : ℕ), n % 2 = 0 → ∃ m, n = m ^ 2

total : 18

elaborated: 16

Every normal subgroup of a group has finite index.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   subgroup.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   subgroup.quotient  G N  )

 {  G :  Type  u } ->  [  Group  G ] ->  {  U :  Subgroup  G } ->  [ U.normal ] ->  U.index ∈  Fintype.card  G.carrier_type

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  U :  Subgroup  G } ->  [ U.normal ] ->  U.index ∈  Fintype.card  G.carrier_type

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  {  U :  Subgroup  G } ->  [ U.normal ] ->  U.index ∈  Fintype.card  G.carrier_type

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintype   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintypeₓ   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintype   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintypeₓ   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintype   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  h :  group.fintype  G ) ->  Fintypeₓ   ↥  (   N.normalizer / N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     n  :  ℕ ,  N.index = n

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     n  :  ℕ ,  N.index = n

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     n  :  ℕ ,  N.index = n

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->   Fintype.card  G ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->   Fintype.card  G ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->   Fintype.card  G ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->   (  N.index   :  ℕ ) ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->   (  N.index   :  ℕ ) ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->   (  N.index   :  ℕ ) ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  [ H.normal ] ->   Fintype.card  H.quotient = H.index

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  [ H.normal ] ->   Fintype.card  H.quotient = H.index

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  [ H.normal ] ->   Fintype.card  H.quotient = H.index

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintype  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintypeₓ  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintype  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintypeₓ  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintype  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   s :  Fintypeₓ  N ) ,   s.card * s.card =  card  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  N.coset_stabilizer.fixed_points

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Set  G )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   G /  (  N   :  Setₓ  G )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  hN :  N ≠  ⊥ ) ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  hN :  N ≠  ⊥ ) ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  (  hN :  N ≠  ⊥ ) ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->   0 < H.index

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->   0 < H.index

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  [ H.normal ] ->   0 < H.index

{G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype ∥N.quotient : G / N∥ 

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     m  :  ℕ ,  ∀  g   : G ,   m * g ∈ N

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     m  :  ℕ ,  ∀  g   : G ,   m * g ∈ N

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃     m  :  ℕ ,  ∀  g   : G ,   m * g ∈ N

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ hN : N.normal ] ->  ∃    (   d :  ℕ ) ,  N.index = d

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ hN : N.normal ] ->  ∃    (   d :  ℕ ) ,  N.index = d

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ hN : N.normal ] ->  ∃    (   d :  ℕ ) ,  N.index = d

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N  )

failed to elaborate

outputs: #[{G : Type u_1} [group G] {H : subgroup G} [H.normal] : fintype G , {G : Type u_1} [hG : group G] {N : subgroup G} [N.normal] : fintype (quotient_group.quotient N.normalizer) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (subgroup.quotient G N) , {G : Type u} [group G] {U : subgroup G} [U.normal] : U.index ∈ fintype.card G.carrier_type , {G : Type u_1} [group G] {N : subgroup G} [N.normal] (h : group.fintype G) : fintype ↥(N.normalizer / N) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : ∃ n : ℕ, N.index = n , {G : Type u_1} [group G] (N : subgroup G) [N.normal] : fintype.card G ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : (N.index : ℕ) ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient_group.quotient (↑N)) , {G : Type u_1} [group G] (H : subgroup G) [H.normal] : fintype.card H.quotient = H.index , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : ∃ (s : fintype N), s.card * s.card = card G , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype N.coset_stabilizer.fixed_points , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (G / (N : set G)) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] (hN : N ≠ ⊥) : N.index ≠ 0 , {G : Type u_1} [group G] {H : subgroup G} [H.normal] : 0 < H.index , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype ∥N.quotient : G / N∥ , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : ∃ m : ℕ, ∀ g : G, m * g ∈ N , {G : Type u_1} [group G] {N : subgroup G} [hN : N.normal] : ∃ (d : ℕ), N.index = d , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype G , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient N) ]

total : 19

elaborated: 16

The characteristic polynomial of every matrix has real roots.

No valid output from Codex; outputs below

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRing  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRing  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓₓ  R ] ->  {  A :  Matrix  n n R } ->  A.charpoly.roots.to_finset.card =   (   A.charpoly.roots    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  M :  Matrix  n n R } ->  ∀  r  ,   M.charpoly.is_root  r →  r ∈   ℝ  ℝ

{n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [integral_domain R] (M : matrix n n R) : ∀ r ∈ M.charpoly.roots.to_finset.sort (by apply_instance), r ∈ M.charpoly.roots_over ℝ 

 {  α :  Type  u } ->  [  CommRing  α ] ->  (  M :  Matrix   ℕ  ℕ α ) ->  ∀   (  x  :  ℂ  )  ,   polynomial.eval₂  complex.conj x M.charpoly =  polynomial.eval₂  complex.conj x.conj M.charpoly

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  M :  Matrix   ℕ  ℕ α ) ->  ∀   (  x  :  ℂ  )  ,   polynomial.eval₂  complex.conj x M.charpoly =  polynomial.eval₂  complex.conj x.conj M.charpoly

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  (  M :  Matrix   ℕ  ℕ α ) ->  ∀   (  x  :  ℂ  )  ,   polynomial.eval₂  complex.conj x M.charpoly =  polynomial.eval₂  complex.conj x.conj M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRing   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRingₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRingₓₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRing   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRingₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRingₓₓ   ℂ ] ->  (  M :  Matrix  n n  ℂ ) ->  polynomial.all_roots_are_real  M.charpoly

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Field  R ] ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  ∀  x   : R ,    A.charpoly.eval  x =  0 →  x ∈   ℝ  ℝ

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Field  R ] ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  ∀  x   : R ,    A.charpoly.eval  x =  0 →  x ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  discrete_field  R ] ->  {  M :  Matrix  n n R } ->  ∀   (  r  : R  )  ,   r.is_root_of   (  M.charpoly  ) →  r ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  discrete_field  R ] ->  {  M :  Matrix  n n R } ->  ∀   (  r  : R  )  ,   r.is_root_of   (  M.charpoly  ) →  r ∈   ℝ  ℝ

 (  R :  Type  u ) ->  [  CommRing  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRing  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  [  DecidableEq  R ] ->  {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   ⦃  x  : R ⦄  ,   M.charpoly.is_root  x ↔    ⟪ xx ,  0 ⟫  ⟪ xx ,  0 ⟫ ∈ M.eigen_roots

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v_1 } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->     (  M.charpoly  ) . aeval    ℝ  ℝ =  0

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v_1 } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->     (  M.charpoly  ) . aeval    ℝ  ℝ =  0

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  x   : R ,    M.charpoly.eval  x =  0 →  x ∈   @ polynomial.roots  R  _  (   polynomial.roots_to_polynomial  M.charpoly  )

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  x   : R ,    M.charpoly.eval  x =  0 →  x ∈   @ polynomial.roots  R  _  (   polynomial.roots_to_polynomial  M.charpoly  )

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  a  ,   a ∈  M.charpoly.root_set    ℝ  ℝ ↔  a.re ∈  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  K :  Type  u_2 } ->  [  Field  K ] ->  (  M :  Matrix  n n K ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =  0

 {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  K :  Type  u_2 } ->  [  Field  K ] ->  (  M :  Matrix  n n K ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =  0

 {  R :  Type* } ->  [  CommRing  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRing  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  {  n :  Type* } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  A :  Matrix  n n R ) ->  (  hp :  A.det ≠  0 ) ->  ∀  z  ,   z ∈  A.char_poly.root_set   ℂ →  z ∈  A.char_poly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n  ℂ ) ->  all_roots_are_real  M.charpoly

 {  n :  Type  u } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∃    (   S :  Finset   ℂ ) ,   S.card = M.nrows ∧  (   ∀   (  x  :  ℂ  )  ,   x ∈ S →  is_root  M.charpoly x  )

 {  n :  Type  u } ->  [  DecidableEq  n ] ->  (  M :  Matrix  n n  ℂ ) ->   M.charpoly.roots_of  ℝ.field =  M.charpoly.roots_of  ℂ.field

{n : Type u} [fintype n] {R : Type v} [decidable_eq n] [comm_ring R] (M : matrix n n R) : have wf (@has_well_founded.r (@linear_equiv.to_matrix n n R M M)) 

 {  n :  Type  u_1 } ->  (  nnonneg :  n ≥  0 ) ->  {  R :  Type  u_2 } ->  [  integral_domain  R ] ->  [  CharP  R  2 ] ->  [  has_1  R ] ->  [  Zero  R ] ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  ∀   (  q  :  Polynomial  R  )  ,   M.charpoly.roots_count  q =  M.charpoly.real_roots_count  q

 {  n :  Type  u_1 } ->  (  nnonneg :  n ≥  0 ) ->  {  R :  Type  u_2 } ->  [  integral_domain  R ] ->  [  CharP  R  2 ] ->  [  has_1  R ] ->  [  Zero  R ] ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  ∀   (  q  :  Polynomial  R  )  ,   M.charpoly.roots_count  q =  M.charpoly.real_roots_count  q

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  {  x :  Matrix  n n R } ->  ∀  r   : R ,   polynomial.is_root   (  x.charpoly  ) r ↔  ∃    (   c :  ℂ ) ,   x.eigenvalue  c = r

 {  n :  Type* } ->  (  M :  Matrix   (   Fin  n  )  (   Fin  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

 {  n :  Type* } ->  (  M :  Matrix   (   Fin  n  )  (   Finₓ  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

 {  n :  Type* } ->  (  M :  Matrix   (   Finₓ  n  )  (   Fin  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

 {  n :  Type* } ->  (  M :  Matrix   (   Finₓ  n  )  (   Finₓ  n  )  ℂ ) ->  ∀  z   :  ℂ ,    z ^ M.nat_dim ∈  ↑  (   M.charpoly.roots   ℂ  ) →  z ∈   ℝ  ℝ

failed to elaborate

outputs: #[{n : Type u_1} [decidable_eq n] [fintype n] {R : Type u_2} [comm_ring R] {A : matrix n n R} : A.charpoly.roots.to_finset.card = (A.charpoly.roots ℝ).to_finset.card , {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {M : matrix n n R} : ∀ r, M.charpoly.is_root r → r ∈ ℝ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [integral_domain R] (M : matrix n n R) : ∀ r ∈ M.charpoly.roots.to_finset.sort (by apply_instance), r ∈ M.charpoly.roots_over ℝ , {α : Type u} [comm_ring α] (M : matrix ℕ ℕ α) : ∀ (x : ℂ), polynomial.eval₂ complex.conj x M.charpoly = polynomial.eval₂ complex.conj x.conj M.charpoly , {n : Type u_1} [decidable_eq n] [fintype n] [comm_ring ℂ] (M : matrix n n ℂ) : polynomial.all_roots_are_real M.charpoly , {R : Type u} {n : Type v} [field R] [decidable_eq n] [fintype n] (A : matrix n n R) : ∀ x : R, A.charpoly.eval x = 0 → x ∈ ℝ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type u_2} [discrete_field R] {M : matrix n n R} : ∀ (r : R), r.is_root_of (M.charpoly) → r ∈ ℝ , (R : Type u) [comm_ring R] [decidable_eq R] {n : Type u_1} [fintype n] (M : matrix n n R) :
  ∀ ⦃x : R⦄, M.charpoly.is_root x ↔ ⟪x, 0⟫ ∈ M.eigen_roots , {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v_1} [discrete_field R] (M : matrix n n R) : (M.charpoly).aeval ℝ = 0 , {n : Type u} [decidable_eq n] [fintype n] {R : Type v} [discrete_field R] (M : matrix n n R) : ∀ x : R, M.charpoly.eval x = 0 → x ∈ @polynomial.roots R _ (polynomial.roots_to_polynomial M.charpoly) , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : ∀ a, a ∈ M.charpoly.root_set ℝ ↔ a.re ∈ M.charpoly.root_set ℝ , {n : Type u_1} [fintype n] [decidable_eq n] {K : Type u_2} [field K] (M : matrix n n K) : (M.charpoly.root_set ℂ).to_finset.card = 0 , {R : Type*} [comm_ring R] {n : Type*} [decidable_eq n] [fintype n] (A : matrix n n R) (hp : A.det ≠ 0) :
  ∀ z, z ∈ A.char_poly.root_set ℂ → z ∈ A.char_poly.root_set ℝ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n ℂ) : all_roots_are_real M.charpoly , {n : Type u} [fintype n] [decidable_eq n] {R : Type v} [comm_ring R] (M : matrix n n R) :
  ∃ (S : finset ℂ), S.card = M.nrows ∧ (∀ (x : ℂ), x ∈ S → is_root M.charpoly x) , {n : Type u} [decidable_eq n] (M : matrix n n ℂ) : M.charpoly.roots_of ℝ.field = M.charpoly.roots_of ℂ.field , {n : Type u} [fintype n] {R : Type v} [decidable_eq n] [comm_ring R] (M : matrix n n R) : have wf (@has_well_founded.r (@linear_equiv.to_matrix n n R M M)) , {n : Type u_1} (nnonneg : n ≥ 0) {R : Type u_2} [integral_domain R] [char_p R 2] [has_1 R] [has_zero R] [decidable_eq n] [fintype n] (M : matrix n n R) :
  ∀ (q : polynomial R), M.charpoly.roots_count q = M.charpoly.real_roots_count q , {n : Type u_2} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] {x : matrix n n R} : ∀ r : R, polynomial.is_root (x.charpoly) r ↔ ∃ (c : ℂ), x.eigenvalue c = r , {n : Type*} (M : matrix (fin n) (fin n) ℂ) : ∀ z : ℂ, z ^ M.nat_dim ∈ ↑(M.charpoly.roots ℂ) → z ∈ ℝ ]

total : 20

elaborated: 16

In a commutative ring, every prime ideal is contained in a unique maximal ideal.

No valid output from Codex; outputs below

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ Pmax : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,   P ≤ M ∧ M.is_maximal

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ Pmax : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,   P ≤ M ∧ M.is_maximal

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ Pmax : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,   P ≤ M ∧ M.is_maximal

 {  α :  Type  u } ->  [  CommRing  α ] ->  (  P :  Ideal  α ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  P :  Ideal  α ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  (  P :  Ideal  α ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  m ⊆ P

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  m ⊆ P

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  m ⊆ P

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  M ⊆ P

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  M ⊆ P

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  M ⊆ P

 {  R :  Type  u } ->  [  CommRing  R ] ->  Function.Injective   (   λ P :  Ideal  R ,  Ideal.comap   (   algebraMap  R R  ) P  )

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  Function.Injective   (   λ P :  Ideal  R ,  Ideal.comap   (   algebraMap  R R  ) P  )

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  Function.Injective   (   λ P :  Ideal  R ,  Ideal.comap   (   algebraMap  R R  ) P  )

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  p ≤ M

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  p ≤ M

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  p ≤ M

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [  Prime  p ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ HP : P.is_prime ] ->  ∃!     M  ,  prime_ideal_maximal_of_prime_ideal  P M

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ HP : P.is_prime ] ->  ∃!     M  ,  prime_ideal_maximal_of_prime_ideal  P M

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ HP : P.is_prime ] ->  ∃!     M  ,  prime_ideal_maximal_of_prime_ideal  P M

 {  R :  Type  u } ->  [  CommRing  R ] ->  [  IsNoetherianRing  R ] ->  (  p :  Ideal  R ) ->  [ h : p.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  p ⊆ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  [  IsNoetherianRing  R ] ->  (  p :  Ideal  R ) ->  [ h : p.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  p ⊆ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  [  IsNoetherianRing  R ] ->  (  p :  Ideal  R ) ->  [ h : p.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  p ⊆ M

 {  R :  Type  u } ->  [  CommRing  R ] ->  ∀   {  P  :  Ideal  R }  ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  ∀   {  P  :  Ideal  R }  ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  ∀   {  P  :  Ideal  R }  ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRing  α ] ->  {  P :  Ideal  α } ->  [ primeP : P.is_prime ] ->  ∃    (   m :  Ideal  α ) ,  m.is_maximal ∧  P ⊆ m

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  P :  Ideal  α } ->  [ primeP : P.is_prime ] ->  ∃    (   m :  Ideal  α ) ,  m.is_maximal ∧  P ⊆ m

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  {  P :  Ideal  α } ->  [ primeP : P.is_prime ] ->  ∃    (   m :  Ideal  α ) ,  m.is_maximal ∧  P ⊆ m

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  (  hP : P.is_prime ) ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  (  hP : P.is_prime ) ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  (  hP : P.is_prime ) ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRing  α ] ->  (  P :  Ideal  α ) ->  [ HP : P.is_prime ] ->  ∃     m  ,  (   ∀  j   :  Ideal  α ,  m.is_maximal →  (    P ⊆ m ↔  P = j  )  )

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  P :  Ideal  α ) ->  [ HP : P.is_prime ] ->  ∃     m  ,  (   ∀  j   :  Ideal  α ,  m.is_maximal →  (    P ⊆ m ↔  P = j  )  )

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  (  P :  Ideal  α ) ->  [ HP : P.is_prime ] ->  ∃     m  ,  (   ∀  j   :  Ideal  α ,  m.is_maximal →  (    P ⊆ m ↔  P = j  )  )

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  ,  M.is_maximal ∧  M ∈  ideal.nhds  P

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  ,  M.is_maximal ∧  M ∈  ideal.nhds  P

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  ,  M.is_maximal ∧  M ∈  ideal.nhds  P

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  P ≤  (   unique_maximal_ideal  P  )

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  P ≤  (   unique_maximal_ideal  P  )

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  P ≤  (   unique_maximal_ideal  P  )

 {  R :  Type* } ->  [  CommRing  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃     M  ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃     M  ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃     M  ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type* } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type* } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type* } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRing  R ] ->  ∀  P   :  Ideal  R ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  ideal.subset  P M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  ∀  P   :  Ideal  R ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  ideal.subset  P M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  ∀  P   :  Ideal  R ,  P.is_prime →  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  ideal.subset  P M

failed to elaborate

outputs: #[{R : Type u} [comm_ring R] (P : ideal R) [Pmax : P.is_prime] : ∃! (M : ideal R), P ≤ M ∧ M.is_maximal , {α : Type u} [comm_ring α] (P : ideal α) [hP : P.is_prime] : ∃! M : ideal α, M.is_maximal ∧ P ⊆ M , {R : Type u} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃ m : ideal R, m.is_maximal ∧ m ⊆ P , {R : Type u_1} [comm_ring R] (P : ideal R) [hp : P.is_prime] : ∃! M : ideal R, M.is_maximal ∧ M ⊆ P , {R : Type u} [comm_ring R] : function.injective (λ P : ideal R, ideal.comap (algebra_map R R) P) , (R : Type u) [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃! M : ideal R, M.is_maximal ∧ p ≤ M , {R : Type u_1} [comm_ring R] (p : ideal R) [is_prime p] : ∃! (m : ideal R), m.is_maximal ∧ p ⊆ m , {R : Type u} [comm_ring R] (p : ideal R) [is_prime p] : ∃! m : ideal R, m.is_maximal ∧ p ⊆ m , {R : Type u_1} [comm_ring R] (P : ideal R) [HP : P.is_prime] : ∃! M, prime_ideal_maximal_of_prime_ideal P M , {R : Type u} [comm_ring R] [is_noetherian_ring R] (p : ideal R) [h : p.is_prime] : ∃ M : ideal R, M.is_maximal ∧ p ⊆ M , {R : Type u} [comm_ring R] : ∀ {P : ideal R}, P.is_prime → ∃! M : ideal R, M.is_maximal ∧ P ≤ M , {R : Type u_1} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! M : ideal R, M.is_maximal ∧ P ⊆ M , {α : Type u} [comm_ring α] {P : ideal α} [primeP : P.is_prime] : ∃ (m : ideal α), m.is_maximal ∧ P ⊆ m , {R : Type u} [comm_ring R] (P : ideal R) (hP : P.is_prime) : ∃! (M : ideal R), M.is_maximal ∧ P ⊆ M , {α : Type u} [comm_ring α] (P : ideal α) [HP : P.is_prime] : ∃ m, (∀ j : ideal α, m.is_maximal → (P ⊆ m ↔ P = j)) , (R : Type u) [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! M, M.is_maximal ∧ M ∈ ideal.nhds P , (R : Type u) [comm_ring R] (P : ideal R) [hP : P.is_prime] : P ≤ (unique_maximal_ideal P) , {R : Type*} [comm_ring R] {P : ideal R} (hP : P.is_prime) : ∃ M, M.is_maximal ∧ P ⊆ M , {R : Type*} [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃ m : ideal R, m.is_maximal ∧ p ⊆ m , {R : Type u} [comm_ring R] : ∀ P : ideal R, P.is_prime → ∃! M : ideal R, M.is_maximal ∧ ideal.subset P M ]

total : 21

elaborated: 16

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  Continuous f → UniformContinuous f

total : 22

elaborated: 17

Every uniformly continuous function is bounded above.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  TopologicalSpace  β ] ->  [  orderable_top  β ] ->  [  UniformAddGroup  β ] ->  {  f :  α → β } ->  (  hf :  uniformly_continuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  TopologicalSpace  β ] ->  [  orderable_top  β ] ->  [  UniformAddGroup  β ] ->  {  f :  α → β } ->  (  hf :  uniformly_continuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  HasDist  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  HasDist  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  SemilatticeSup  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  SemilatticeSup  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  LinearOrder  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  LinearOrderₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  LinearOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrder  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     M  ,  ∀  x  ,   f  x ≤ M

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  TopologicalSpace  β ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,  c ≥  f  x

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  TopologicalSpace  β ] ->  [  OrderTop  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,  c ≥  f  x

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  TopologicalSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove  f

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  TopologicalSpace  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove  f

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  CompleteSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,   f  x ≤ c

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  CompleteSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x  ,   f  x ≤ c

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  LinearOrder  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  LinearOrderₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  LinearOrderₓₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrder  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  LinearOrderₓₓ  β ] ->  [  uniform_continuous_on_univ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  ∃     C  : β ,  ∀  x  ,   f  x ≤ C

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  PseudoMetricSpace  α ] ->  [  PseudoMetricSpace  β ] ->  (  f :  α → β ) ->  (  h_f :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  TopologicalSpace  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpaceₓ  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpace  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpaceₓ  β ] ->  [  Nonempty  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  UniformSpaceₓ  β ] ->  {  f :  α → β } ->  (  hf :  UniformContinuous  f ) ->  TendstoUniformly  f  (   λ x ,  0  ) at_top

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  SemilatticeSup  β ] ->  [  ∀  a   : α ,  Decidable   (    f  a =  ⊤  ) ] ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x   : α ,   f  x ≤ c

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  SemilatticeSup  β ] ->  [  ∀  a   : α ,  Decidable   (    f  a =  ⊤  ) ] ->  (  h :  UniformContinuous  f ) ->  ∃     c  : β ,  ∀  x   : α ,   f  x ≤ c

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  (  f :  α → β ) ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  [  ConditionallyCompleteLinearOrder  β ] ->  (  f :  α → β ) ->  (  hf :  UniformContinuous  f ) ->  BddAbove   (   Set.Range  f  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrder  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Set  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpaceₓ  α ] ->  {  f :  α → β } ->  [  PartialOrderₓₓ  β ] ->  [  OrderTop  β ] ->  [  DenselyOrdered  β ] ->  {  s :  Setₓ  α } ->  (  h :  UniformContinuousOn  f s ) ->  BddAbove   (   range $  λ x ,  f  x  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpaceₓ  α ] ->  [  PseudoMetricSpace  β ] ->  {  f :  α → β } ->  (  h :  UniformContinuous  f ) ->  BddAbove   (   range  f  )

failed to elaborate

outputs: #[{α : Type u_1} {β : Type u_2} [uniform_space α] [order_top β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u} {β : Type v}
  [uniform_space α] [topological_space β] [orderable_top β] [uniform_add_group β]
  {f : α → β} (hf : uniformly_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [has_dist α] [conditionally_complete_linear_order β] {f : α → β} (h : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [pseudo_metric_space β] {f : α → β} (h : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [semilattice_sup β] {f : α → β} (hf : uniform_continuous f) : bdd_above (set.range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [linear_order β] [order_top β] [separated_space α] {f : α → β} (hf : uniform_continuous f) : ∃ M, ∀ x, f x ≤ M , {α : Type u} {β : Type v} [uniform_space α] [topological_space β] [order_top β] {f : α → β} (h : uniform_continuous f) : ∃ c : β, ∀ x, c ≥ f x , {α : Type u} {β : Type v} [topological_space α] [uniform_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above f , {α : Type u_1} {β : Type u_2} [uniform_space α] [complete_space β] {f : α → β} (hf : uniform_continuous f) : ∃ c : β, ∀ x, f x ≤ c , {α : Type u} {β : Type v} [uniform_space α] [linear_order β] [uniform_continuous_on_univ β] {f : α → β} (hf : uniform_continuous f) : ∃ C : β, ∀ x, f x ≤ C , {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above (set.range f) , {α : Type u} {β : Type v} [pseudo_metric_space α] [pseudo_metric_space β] (f : α → β) (h_f : uniform_continuous f) : bdd_above (set.range f) , {α : Type u} {β : Type v} [topological_space α] [pseudo_metric_space β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] [nonempty β] {f : α → β} (hf : uniform_continuous f) : bdd_above (range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] [uniform_space β] {f : α → β} (hf : uniform_continuous f) : tendsto_uniformly f (λ x, 0) at_top , {α : Type u_1} {β : Type u_2} [uniform_space α] {f : α → β} [semilattice_sup β] [∀ a:α, decidable (f a = ⊤)] (h : uniform_continuous f) : ∃ c : β, ∀ x : α, f x ≤ c , {α : Type u_1} {β : Type u_2} [uniform_space α] [conditionally_complete_linear_order β] (f : α → β) (hf : uniform_continuous f) : bdd_above (set.range f) , {α : Type u_1} {β : Type u_2} [uniform_space α] {f : α → β} [partial_order β] [order_top β] [densely_ordered β] {s : set α} (h : uniform_continuous_on f s) : bdd_above (range $ λ x, f x) , {α : Type u} {β : Type v} [uniform_space α] [pseudo_metric_space β] {f : α → β} (h : uniform_continuous f) : bdd_above (range f) ]

total : 23

elaborated: 17

If every compact subset of a topological space is closed, then the space is compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},
  (∀ (x : Set α), IsCompact x → IsClosed x) → IsCompact s → IsClosed s

total : 24

elaborated: 18

In a commutative ring, the sum of idempotent elements is idempotent.

success

theorem ∀ {R : Type u_1} [inst : CommRing R] {a b : R}, a * a = a → b * b = b → (a + b) * (a + b) = a + b

total : 25

elaborated: 19

The number of partitions of a finite set is a prime number.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  Nat.Prime   (  s.partitions.card  )

 (  s :  Finset  α ) ->  Nat.Prime   (  s.card.partitions  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->  Nat.Prime  s.card_partitions

 {  n :  ℕ } ->  (  H :  n >  0 ) ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p ∣  nat.partition  n

 {  α :  Type  u } ->  [  Fintype  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 {  α :  Type  u } ->  [  Fintypeₓ  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 {  α :  Type  u } ->  {  L :  Finset  α } ->  [ hp :  Fintype  α ] ->  Nat.Prime   (  L.finset_partitions.card  )

 {  α :  Type  u } ->  {  L :  Finset  α } ->  [ hp :  Fintypeₓ  α ] ->  Nat.Prime   (  L.finset_partitions.card  )

 {  α :  Type* } ->  (  s :  Finset  α ) ->  ∃     p  :  ℕ ,   Nat.Prime  p ∧  p = s.card_partitions

 (  R :  Type  u ) ->  [  Fintype  R ] ->  Nat.Prime  partitions.card

 (  R :  Type  u ) ->  [  Fintypeₓ  R ] ->  Nat.Prime  partitions.card

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  Nat.Prime    (   Fintype.card  α  ) . partitions.card

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  Nat.Prime    (   Fintype.card  α  ) . partitions.card

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  [  Fintype  α ] ->  Nat.Prime  s.card_partitions

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  [  Fintypeₓ  α ] ->  Nat.Prime  s.card_partitions

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p =  Fintype.card  α.partitions

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  p =  Fintype.card  α.partitions

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  Prime   (  s.partitions.card  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->  Fact   (   Nat.Prime  s.card.partitions  )

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  Nat.Prime   (   Fintype.card   (   partitions  α  )  )

 (  s :  Finset  α ) ->  Nat.Prime   (   partitions.card  s  )

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) -> s.card.partitions.card.prime

 {  α :  Type  u_1 } ->  [  Fintype  α ] ->  Nat.Prime    (   partitions  α  ) . card

 {  α :  Type  u_1 } ->  [  Fintypeₓ  α ] ->  Nat.Prime    (   partitions  α  ) . card

 (  s :  Finset   ℕ ) ->  Nat.Prime  s.card_partition

 {  α :  Type  u_1 } ->  (  s :  Finset  α ) ->  Nat.Prime   (  s.card_partitions  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->  Nat.Prime   (   card_partitions  s  )

failed to elaborate

outputs: #[{α : Type u_1} (s : finset α) : nat.prime (s.partitions.card) , (s : finset α) : nat.prime (s.card.partitions) , {α : Type u_1} [decidable_eq α] (s : finset α) : nat.prime s.card_partitions , {n : ℕ} (H : n > 0) : ∃ (p : ℕ), nat.prime p ∧ p ∣ nat.partition n , {α : Type u} [fintype α] : nat.prime (fintype.card (partitions α)) , {α : Type u} {L : finset α} [hp : fintype α] : nat.prime (L.finset_partitions.card) , {α : Type*} (s : finset α) : ∃ p : ℕ, nat.prime p ∧ p = s.card_partitions , (R : Type u) [fintype R] : nat.prime partitions.card , {α : Type u_1} [fintype α] : nat.prime (fintype.card α).partitions.card , {α : Type u_1} (s : finset α) [fintype α] : nat.prime s.card_partitions , {α : Type u_1} [fintype α] [decidable_eq α] : ∃ (p : ℕ), nat.prime p ∧ p = fintype.card α.partitions , {α : Type u_1} (s : finset α) : prime (s.partitions.card) , {α : Type u_1} [decidable_eq α] (s : finset α) : fact (nat.prime s.card.partitions) , {α : Type u_1} [fintype α] : nat.prime (fintype.card (partitions α)) , (s : finset α) : nat.prime (partitions.card s) , {α : Type u_1} (s : finset α) : s.card.partitions.card.prime , {α : Type u_1} [fintype α] : nat.prime (partitions α).card , (s : finset ℕ) : nat.prime s.card_partition , {α : Type u_1} (s : finset α) : nat.prime (s.card_partitions) , {α : Type u_1} [decidable_eq α] (s : finset α) : nat.prime (card_partitions s) ]

total : 26

elaborated: 19

If a poset has a maximal element, then it has a unique minimal element.

success

theorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α],
  (∃ a, IsMax a) → (∃ a, IsLeast { a' | a ≤ a' } a) ∧ (∃ a, IsMax a) ∧ (∃ a, IsMin a) ∧ ∃ a, IsMax a

total : 27

elaborated: 20

The automorphism group of an Abelian group is cyclic.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintypeₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintypeₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  Fintype  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  Fintypeₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (    @ aut  G G  _ h  )

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  [  Fintype  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  [  Fintypeₓ  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  [  Fintype  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  [  Fintypeₓ  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  [  Fintype  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  [  Fintypeₓ  G ] ->  {  a : G } ->  (  h :  ∃    (   b : G ) ,    (   auto  G  )  a =  ⟨   λ   ( b₁ : G ) ,  ∃    (   n :  ℤ ) ,  b₁ =  b ^ n ,   (   Fintype.card  G  ) ⁻¹ ⟩ ) ->  IsCyclic   (   auto  G  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  AddGroup  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  AddGroupₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  AddGroupₓₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  AddGroup  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  AddGroupₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  AddGroupₓₓ  α ] ->  [  is_abelian_group  α ] ->  IsCyclic   (   monoid_aut  α  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [ h :  is_abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [ h :  is_abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [ h :  is_abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  α :  Type  u } ->  [  Group  α ] ->  [ h :  IsLieAbelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [ h :  IsLieAbelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [ h :  IsLieAbelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoid  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZero  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroup  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  α :  Type  u } ->  [  Monoidₓ  α ] ->  [  GroupWithZeroₓₓ  α ] ->  [  Fintypeₓ  α ] ->  [  DecidableEq  α ] ->  [  AddGroupₓₓ  α ] ->  [  AddTorsor  α α ] ->  (  h :  IsLieAbelian  α ) ->  IsCyclic   (   group_with_zero.mop.to_group   (   subtype.range   (   λ   ( a : α ) ,  a ≠  0  )  )  )

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (    ℤ ≃* G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (    ℤ ≃* G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (    ℤ ≃* G  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  abelian  α ] ->  IsCyclic   (   aut  α  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.automorphisms  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.automorphisms  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.automorphisms  G  )

 {  G :  Type  u_1 } ->  (  G :  Type  u_2 ) ->  [  AddGroup  G ] ->  [  AddTorsor  G P ] ->  [  add_torsor.is_add_group_action  G P Add ] ->  (  p : P ) ->  ∃    (   g : G )  (   n :  ℕ ) ,  is_torsion_element  g n

 {  G :  Type  u_1 } ->  (  G :  Type  u_2 ) ->  [  AddGroupₓ  G ] ->  [  AddTorsor  G P ] ->  [  add_torsor.is_add_group_action  G P Add ] ->  (  p : P ) ->  ∃    (   g : G )  (   n :  ℕ ) ,  is_torsion_element  g n

 {  G :  Type  u_1 } ->  (  G :  Type  u_2 ) ->  [  AddGroupₓₓ  G ] ->  [  AddTorsor  G P ] ->  [  add_torsor.is_add_group_action  G P Add ] ->  (  p : P ) ->  ∃    (   g : G )  (   n :  ℕ ) ,  is_torsion_element  g n

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  CommGroup  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  CommGroupₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  CommGroup  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  CommGroupₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  CommGroup  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  CommGroupₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   group.aut  α  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abel  G ] ->  {  n :  ℕ } ->  (  h :   Fintype.card   (   group_aut  G  ) = n ) ->  IsCyclic   (   group_aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abel  G ] ->  {  n :  ℕ } ->  (  h :   Fintype.card   (   group_aut  G  ) = n ) ->  IsCyclic   (   group_aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abel  G ] ->  {  n :  ℕ } ->  (  h :   Fintype.card   (   group_aut  G  ) = n ) ->  IsCyclic   (   group_aut  G  )

 {  G :  Type  u_1 } ->  [  AddGroup  G ] ->  [  is_abelian  G ] ->  IsCyclic   (   auto_equiv  G  )

 {  G :  Type  u_1 } ->  [  AddGroupₓ  G ] ->  [  is_abelian  G ] ->  IsCyclic   (   auto_equiv  G  )

 {  G :  Type  u_1 } ->  [  AddGroupₓₓ  G ] ->  [  is_abelian  G ] ->  IsCyclic   (   auto_equiv  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  CommGroup  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  CommGroupₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  CommGroup  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  CommGroupₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  CommGroup  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  CommGroupₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  α :  Type  u } ->  [  AddGroup  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

failed to elaborate

outputs: #[{G : Type u_1} [group G] [fintype G] [h : is_abelian_group G] : is_cyclic (@aut G G _ h) , {G : Type u_1} [comm_group G] [fintype G] {a : G} (h : ∃ (b : G), (auto G) a = ⟨λ (b₁ : G), ∃ (n : ℤ), b₁ = b ^ n, (fintype.card G)⁻¹⟩) : is_cyclic (auto G) , {α : Type u} [monoid α] [add_group α] [is_abelian_group α] : is_cyclic (monoid_aut α) , {G : Type u_1} [group G] [abelian G] : is_cyclic (group.aut G) , {G : Type u_1} [group G] [h : is_abelian G] : is_cyclic (group.aut G) , {α : Type u} [group α] [h : is_lie_abelian α] : is_cyclic (aut α) , {α : Type u} [monoid α] [group_with_zero α] [fintype α] [decidable_eq α] [add_group α] [add_torsor α α] (h : is_lie_abelian α) : is_cyclic (group_with_zero.mop.to_group (subtype.range (λ (a : α), a ≠ 0))) , {G : Type u_1} [comm_group G] : is_cyclic (aut G) , {G : Type u_1} [group G] [abelian G] : is_cyclic (ℤ ≃* G) , {α : Type u} [group α] [abelian α] : is_cyclic (aut α) , {G : Type u_1} [group G] [abelian G] : is_cyclic (group.automorphisms G) , {G : Type u_1} (G : Type u_2) [add_group G] [add_torsor G P] [add_torsor.is_add_group_action G P add] (p : P) : ∃ (g : G) (n : ℕ), is_torsion_element g n , {G : Type u_1} [group G] [abelian G] : is_cyclic (aut G) , {α : Type u} [group α] [comm_group α] : is_cyclic (group.aut α) , {α : Type u} [group α] [is_abelian α] : is_cyclic (aut α) , {G : Type u_1} [group G] [abel G] {n : ℕ} (h : fintype.card (group_aut G) = n) : is_cyclic (group_aut G) , {G : Type u_1} [add_group G] [is_abelian G] : is_cyclic (auto_equiv G) , {G : Type u_1} [group G] [comm_group G] : is_cyclic (group.aut G) , {G : Type u_1} [group G] [abelian G] : is_cyclic (automorphism_group G) , {α : Type u} [add_group α] [is_abelian α] : is_cyclic (aut α) ]

total : 28

elaborated: 20

If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.

success

theorem ∀ {f : ℕ → ℕ} (x : ℕ), f x = x → ∀ {n : ℕ}, 0 < n → Function.IsPeriodicPt f n x

total : 29

elaborated: 21

The complement of the union of two sets contains the union of their complements.

No valid output from Codex; outputs below

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∩  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∩  - t

 {  α :  Type  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   (   - s  ) ∪  (   - t  )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   (   - s  ) ∪  (   - t  )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆  (    - s ∩  - t  )

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆  (    - s ∩  - t  )

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

{α : Type u_1} {s t : set α} : (s ∪ t)ᶜ ⊆ (sᶜ ∪ tᶜ) 

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )  ) =   (   - s  ) ∩  (   - t  )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )  ) =   (   - s  ) ∩  (   - t  )

{α : Type u} {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ 

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->    -  (   s ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ ts ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ t  ) ⊇   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->    -  (   s ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ ts ∪ t  ) ⊇   - s ∪  - t   -  (   s ∪ t  ) ⊇   - s ∪  - t

{α : Type u_1} [topological_space α] {s t : set α} : sᶜ ∪ tᶜ = (s ∪ t)ᶜ 

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

{α : Type u} [topological_space α] {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ 

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   set.compl   (   s ∪ t  ) ⊆   set.compl  s ∪  set.compl  t

failed to elaborate

outputs: #[{α : Type u} [topological_space α] {s t : set α} : -(s ∪ t) ⊆ -s ∩ -t , {α : Type u} {s t : set α} : -(s ∪ t) ⊆ (-s) ∪ (-t) , {α : Type u} {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} {s t : set α} : set.compl (s ∪ t) ⊆ set.compl s ∪ set.compl t , {α : Type u_1} {s t : set α} : -(s ∪ t) ⊆ (-s ∩ -t) , {α : Type u_1} [topological_space α] {s t : set α} : - (s ∪ t) ⊆ - s ∪ - t , {α : Type u_1} {s t : set α} : (s ∪ t)ᶜ ⊆ (sᶜ ∪ tᶜ) , {α : Type u} {s t : set α} : (-(s ∪ t)) = (-s) ∩ (-t) , {α : Type u} {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ , {α : Type u_1} [topological_space α] {s t : set α} : -(s ∪ t) ⊇ -s ∪ -t , {α : Type u_1} [topological_space α] {s t : set α} : sᶜ ∪ tᶜ = (s ∪ t)ᶜ , {α : Type u} {s t : set α} : (-(s ∪ t) : set α) ⊆ (-s : set α) ∪ (-t : set α) , {α : Type u} [topological_space α] {s t : set α} : (s ∪ t)ᶜ ⊆ sᶜ ∪ tᶜ , {α : Type u} [topological_space α] {s t : set α} : set.compl (s ∪ t) ⊆ set.compl s ∪ set.compl t ]

total : 30

elaborated: 21

The square root of an rational number is rational.

No valid output from Codex; outputs below

 {  q :  ℚ } ->  (  hq :  q ≥  0 ) ->  ∃    (   p :  ℚ ) ,   p * p = q

 (  a :  ℚ ) ->  ∃    (   b :  ℚ ) ,   b * b = a

 (  q :  ℚ ) ->  ∃    (   r :  ℚ ) ,   r * r = q

 (  x :  ℚ ) ->  ∃    (   y :  ℚ ) ,   IsSquare  y ∧  y = x

 (  q :  ℚ ) ->  ∃    (   q' :  ℚ ) ,   q' * q' = q

 {  q :  ℚ } ->  (  hq :  q ≥  0 ) ->  ∃    (   r :  ℚ ) ,   r * r = q

 {  q :  ℚ } ->   IsSquare  q →  ∃    (   p :  ℚ ) ,  q =  p ^  2

 (  q :  ℚ ) ->   IsSquare  q →  ∃    (   q' :  ℚ ) ,  q =  q' * q'

 {  q :  ℚ } ->  (  hq :  q ≥  0 ) ->  ∃    (   r :  ℚ ) ,   r ^  2 = q

 (  x :  ℚ ) ->  ∃    (   y :  ℚ ) ,   rat.sqrt  x =  (  y   :   ℝ  ℝ )

 (  q :  ℚ ) ->   IsSquare  q →  ∃    (   r :  ℚ ) ,   r * r = q

 (  q :  ℚ ) ->  ∃    (   p :  ℚ ) ,  q =  p * p

 (  x :  ℚ ) ->  ∃    (   y :  ℚ ) ,   y * y = x

 (  q :  ℚ ) ->  is_rational   (    (   ↑ q   :   ℝ  ℝ ) *  sqrt   2  )

 (  q :  ℚ ) ->   IsSquare  q →  ∃    (   q :  ℚ ) ,   q * q = q

 (  q :  ℚ ) ->  ∃     r  :  ℚ ,   r ^  2 = q

{q : ℚ} : ∃ (r : ℚ), r*r = q 

 (  x :  ℚ ) ->   IsSquare  x →  ∃    (   q :  ℚ ) ,   q * q = x

 {  q :  ℚ } ->  ∃    (   r :  ℚ ) ,   r * r = q

failed to elaborate

outputs: #[{q : ℚ} (hq : q ≥ 0) : ∃ (p : ℚ), p * p = q , (a : ℚ) : ∃ (b : ℚ), b * b = a , (q : ℚ) : ∃ (r : ℚ), r * r = q , (x : ℚ) : ∃ (y : ℚ), is_square y ∧ y = x , (q : ℚ) : ∃ (q' : ℚ), q' * q' = q , {q : ℚ} (hq : q ≥ 0) : ∃ (r : ℚ), r * r = q , {q : ℚ} : is_square q → ∃ (p : ℚ), q = p ^ 2 , (q : ℚ) : is_square q → ∃ (q' : ℚ), q = q' * q' , {q : ℚ} (hq : q ≥ 0) : ∃ (r : ℚ), r ^ 2 = q , (x : ℚ) : ∃ (y : ℚ), rat.sqrt x = (y : ℝ) , (q : ℚ) : is_square q → ∃ (r : ℚ), r * r = q , (q : ℚ) : ∃ (p : ℚ), q = p * p , (x : ℚ) : ∃ (y : ℚ), y * y = x , (q : ℚ) : is_rational ((↑q : ℝ) * sqrt 2) , (q : ℚ) : is_square q → ∃ (q : ℚ), q * q = q , (q : ℚ) : ∃ r : ℚ, r ^ 2 = q , {q : ℚ} : ∃ (r : ℚ), r*r = q , (x : ℚ) : is_square x → ∃ (q : ℚ), q * q = x , {q : ℚ} : ∃ (r : ℚ), r * r = q ]

total : 31

elaborated: 21

If a module over a ring is free, then the ring is commutative.

success

theorem {R : Type u} →
  {M : Type v} → [inst : Ringₓ R] → [inst_1 : AddCommGroupₓ M] → [inst_2 : Module R M] → Module.Free R M → CommRing R

total : 32

elaborated: 22

If the set of units of a ring forms a group then the ring is commutative.

success

theorem {α : Type u} → [inst : Ringₓ α] → Group (Units α) → CommRing α

total : 33

elaborated: 23

Every natural number larger than `10` is the sum of a square and a prime.

success

theorem ∀ (n : ℕ), 10 < n → ∃ a b, a ^ 2 + b ^ 2 = n ∧ Nat.Prime b

total : 34

elaborated: 24

The initial object of a category is isomorphic to its terminal object.

No valid output from Codex; outputs below

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  C ≌ C

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Iso.refl   (   ⊥_ C  )  )

{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (category_theory.limits.terminal.from ⊥_ C)) 

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  category_theory.iso   (   ⊥_ C  )  (   ⊤_ C  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u₁ } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  category_theory.has_self_equiv  C ] ->  (  i : C ) ->  (  t : C ) ->  (  a :  i ⟶ t ) ->  [  category_theory.initial  a ] ->  [  category_theory.terminal  a ] ->  i ≅ t

 {  C :  Type  u₁ } ->  [  CategoryTheory.Category  C ] ->  [  category_theory.limits.has_initial_terminal_object  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasBinaryProducts  C ] ->  [  CategoryTheory.Limits.HasBinaryCoproducts  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  category_theory.iso   (   CategoryTheory.Limits.terminal.from   (   ⊥_ C  )  )  (   CategoryTheory.Limits.initial.to   (   {    X    :  C × C }  )  )

{C : Type u} [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.is_iso ⊤_ C 

{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : (⊥_ C).to ⟶ (⊤_ C) ≅ 𝟙 (⊥_ C) 

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  (  h :  CategoryTheory.Limits.initial.to   (   ⊤_ C  ) ) ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

failed to elaborate

outputs: #[{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : C ≌ C , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.iso.refl (⊥_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (category_theory.limits.terminal.from ⊥_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.iso (⊥_ C) (⊤_ C) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] [category_theory.has_self_equiv C] (i : C) (t : C) (a : i ⟶ t) [category_theory.initial a] [category_theory.terminal a] : i ≅ t , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial_terminal_object C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.iso (category_theory.limits.terminal.from (⊥_ C)) (category_theory.limits.initial.to ({X : C × C})) , {C : Type u} [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.is_iso ⊤_ C , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : (⊥_ C).to ⟶ (⊤_ C) ≅ 𝟙 (⊥_ C) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (h : category_theory.limits.initial.to (⊤_ C)) : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) ]

total : 35

elaborated: 24

If the composition of two functions is continuous, then each of them is continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]
  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g

total : 36

elaborated: 25

If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.

success

theorem ∀ {S : Type ?u.9708663} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c

total : 37

elaborated: 26

If an element maps to zero under a ring homomorphism, then it is zero.

success

theorem ∀ {α : Type u} {β : Type v} [inst : Ringₓ α] [inst_1 : Ringₓ β] {f : α → β}, IsRingHom f → ∀ (x : α), f x = 0 → x = 0

total : 38

elaborated: 27

Implication `→` is symmetric. If `P → Q` then `Q → P`.

success

theorem ∀ {p q : Prop}, (p → q) → q → p

total : 39

elaborated: 28

Two natural numbers are equal if and only if they are both divisible by some prime number.

success

theorem ∀ {m n : ℕ}, m = n ↔ ∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n

total : 40

elaborated: 29

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ), Nat.Prime p → p = 2 ∨ 1 < p ∧ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ {n : ℕ}, ∃ m, m ≥ n ∧ Odd m

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ {p : ℕ}, Fact (Nat.Prime p) ∧ p > 2 → p = 3

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ (p : ℕ), ∃ q, q ≠ p ∧ q % 2 = 1 ∧ Nat.Prime q

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V = 2 → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem {α : Type u} → [inst : Field α] → DivisionRing α

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V = 2 → FiniteDimensional K V

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ {α : Type u} (a : ℕ), ∃ b, b > a

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ (n : ℕ), n < Nat.succ n

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} [inst : MeasurableSpace α] (s : Set α), MeasurableSet s

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->    MeasureTheory.Measure  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->    MeasureTheory.Measure  s =  0 →  MeasurableSet  s

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  measure_theory.measurable  s

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  measure_theory.measurable  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hm :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hm :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  BorelSpace  α ] ->  [  measure_space  α ] ->  (  h :   volume  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  BorelSpace  α ] ->  [  measure_space  α ] ->  (  h :   volume  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    ν  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    ν  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  ν :  MeasureTheory.Measure  α } ->  (  hν : ν.is_borel ) ->  (  hs :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  ν :  MeasureTheory.Measure  α } ->  (  hν : ν.is_borel ) ->  (  hs :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  measure_theory.borel_space  α ] ->  {  s :  Set  α } ->  (  h :   measure_theory.volume  m s =  0 ) ->  measure_theory.measurable_set  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  measure_theory.borel_space  α ] ->  {  s :  Setₓ  α } ->  (  h :   measure_theory.volume  m s =  0 ) ->  measure_theory.measurable_set  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Set  α } ->  {  t :  Set  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Set  α } ->  {  t :  Setₓ  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Setₓ  α } ->  {  t :  Set  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  ν :  MeasureTheory.Measure  β } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  [  BorelSpace  α ] ->  [  BorelSpace  β ] ->  {  s :  Setₓ  α } ->  {  t :  Setₓ  β } ->  (  hν :   measure_theory.measure.borel_measure  ν t =  0 ) ->  (  h :  s ⊆ t ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  hs :   borel_measure  m s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  m :  MeasureTheory.Measure  α } ->  (  hs :   borel_measure  m s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    measure  m s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->    measure  m s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   m  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   m  s =  0 ) ->  Measurable  s

{α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} ⦃hn : measure_theory.volume s = 0⦄ : measurable_set s 

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->    MeasureTheory.Measure  α s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->    MeasureTheory.Measure  α s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   MeasureTheory.Measure  α s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :   MeasureTheory.Measure  α s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  MeasurableSet   ↑  {   x   : α |   MeasureTheory.MeasureSpace.volume    {  xx }  {    xx    } =  0 }

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasureTheory.Measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasureTheory.Measure  s =  0 ) ->  MeasurableSet  s

failed to elaborate

outputs: #[{α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} (h : borel_measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} : measure_theory.measure s = 0 → measurable_set s , {α : Type u} [topological_space α] [t2_space α] [measurable_space α] [borel_space α] {s : set α} (h : measure_theory.measure_space.volume s = 0) : measure_theory.measurable s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hm : borel_measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measure_theory.measure_space.volume s = 0) : measurable_set s , {α : Type u_1} {s : set α} [borel_space α] [measure_space α] (h : volume s = 0) : is_measurable s , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] : ν s = 0 → measurable_set s , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] {m : measure_theory.measure α} (h : measure_theory.measure_space.volume s = 0) : measurable_set s , {α : Type u_1} {s : set α} {ν : measure_theory.measure α} (hν : ν.is_borel) (hs : ν s = 0) : measurable_set s , {α : Type u_1} {m : measure_theory.measure α} [measurable_space α] [measure_theory.borel_space α] {s : set α} (h : measure_theory.volume m s = 0) : measure_theory.measurable_set s , {α : Type u_1} {β : Type u_2} {ν : measure_theory.measure β} [measurable_space α] [measurable_space β] [borel_space α] [borel_space β] {s : set α} {t : set β} (hν : measure_theory.measure.borel_measure ν t = 0) (h : s ⊆ t) : measurable_set s , {α : Type u_1} {s : set α} [measurable_space α] [borel_space α] {m : measure_theory.measure α} (hs : borel_measure m s = 0) : measurable_set s , {α : Type u_1} {s : set α} {m : measure_theory.measure α} [measurable_space α] [borel_space α] : measure m s = 0 → measurable_set s , {α : Type u_1} {s : set α} {m : measure α} [measurable_space α] [borel_space α] (h : m s = 0) : is_measurable s , {α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} ⦃hn : measure_theory.volume s = 0⦄ : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (h : borel_measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} : measure_theory.measure α s = 0 → measurable_set s , {α : Type u_1} [topological_space α] [measurable_space α] [borel_space α] {s : set α} (hs : measure_theory.measure α s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] : measurable_set ↑{x : α | measure_theory.measure_space.volume {x} = 0} , {α : Type u_1} [measurable_space α] {s : set α} (h : measure_theory.measure s = 0) : measurable_set s ]

total : 11

elaborated: 10

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ n, n * n = p

total : 12

elaborated: 11

Every odd prime number is greater than `2`.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Odd p → p > 2

total : 13

elaborated: 12

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ (n : ℕ), ∃ n, n > n ∧ Odd n

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ (n : ℕ), Fact (Nat.Prime n) → n ≠ 2 → n = 3

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ (k : ℕ), ∃ n, 2 * k + 1 ≤ n ∧ Nat.Prime n

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V ≤ 2 → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem (K : Type u) → [inst : Field K] → DivisionRing K

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem {R : Type u_1} →
  [inst : Ringₓ R] → (n m : ℕ) → (v : Fin m → Fin n → R) → m ≤ 2 → LinearIndependent R v → m ≤ n → Fin m → Fin n → R

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ {n : ℕ}, ∃ k, n < k

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ (n : ℕ), n < Nat.succ n

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem {α : Type u_1} → MeasurableSpace α

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} {m : MeasurableSpace α} {s : Set α}, coeFn MeasureTheory.volume.toOuterMeasure s = 0 → MeasurableSet s

total : 11

elaborated: 11

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ m, p = m * m

total : 12

elaborated: 12

Every odd prime number is greater than `2`.

success

theorem ∀ (p : ℕ) [hprime : Fact (Nat.Prime p)], Odd p → 2 < p

total : 13

elaborated: 13

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {a b : ℕ},
  (∃ x y z w, a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) →
    (∃ x y z w, b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) → ∃ x y z w, a * b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2

total : 14

elaborated: 14

Every compact topological space is locally compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α

total : 15

elaborated: 15

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  Continuous f → UniformContinuous f

total : 16

elaborated: 16

`6` is not the sum of two distinct prime numbers.

success

theorem ∀ (a b : ℕ), Prime a → Prime b → 6 = a + b → a = 3 ∧ b = 3

total : 17

elaborated: 17

No integer is irrational.

No valid output from Codex; outputs below

{x : ℤ} (hxr : irrational x) : false 

 (  a :  ℤ ) ->  ¬  Irrational  a

 ¬  ∃    (   n :  ℤ ) ,  Irrational  n

 {  m :  ℤ } ->  Irrational  m

 ∀   (  x  :  ℤ  )  ,  Irrational   (   ↑ x   :   ℝ  ℝ )

 {  x :   ℝ  ℝ } ->  (  hx :  ∃    (   n :  ℤ ) ,  x = n ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hxr :  ∀   (  p  :  ℕ  )  ,  x ≠ p ) ->  Irrational  x

 {  n :  ℤ } ->  ¬  Irrational   ↑ n

 ∀   {  x  :  ℤ }  ,  Irrational  x

 (  m :  ℤ ) ->  ¬  Irrational  m

 {  x :  ℤ } ->  Irrational  x

{x : ℤ} (hx : irrational x) : false 

 {  x :   ℝ  ℝ } ->  (  hxr :  x =  (   ↑ x   :   ℝ  ℝ ) ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hx :  Int  x ) ->  ¬  Irrational  x

{n : ℤ} : irrational n → false 

 : ¬∃ : n : ℤ, irrational n 

 (  x :  ℤ ) ->  ¬  Irrational  x

 {  r :   ℝ  ℝ } ->  (  hirr :  Irrational  r ) ->  ¬  has_rat.of_rat  r

failed to elaborate

outputs: #[{x : ℤ} (hxr : irrational x) : false , (a : ℤ) : ¬irrational a , : ¬∃ (n : ℤ), irrational n , {m : ℤ} : irrational m ,  : ∀ (x : ℤ), irrational (↑x : ℝ) , {x : ℝ} (hx : ∃ (n : ℤ), x = n) : ¬irrational x , {x : ℝ} (hxr : ∀ (p : ℕ), x ≠ p) : irrational x , {n : ℤ} : ¬irrational ↑n ,  : ∀ {x : ℤ}, irrational x , (m : ℤ) : ¬ irrational m , {x : ℤ} : irrational x , {x : ℤ} (hx : irrational x) : false , {x : ℝ} (hxr : x = (↑x : ℝ)) : ¬irrational x , {x : ℝ} (hx : is_int x) : ¬irrational x , {n : ℤ} : irrational n → false ,  : ¬∃ : n : ℤ, irrational n , (x : ℤ) : ¬irrational x , {r : ℝ} (hirr : irrational r) : ¬has_rat.of_rat r ]

total : 18

elaborated: 17

The identity element in a ring is a unit.

success

theorem ∀ {α : Type u} [inst : Ringₓ α], IsUnit 1

total : 19

elaborated: 18

Every subgroup of a group is a group.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  HSub :  IsSubgroup  s ) ->  group.group  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  {  G :  Group  α } ->  Group   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Group   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Group  α } ->  Groupₓₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Group   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Group   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓ  α } ->  Groupₓₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Group   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Group   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓₓ   (   ↑ G   :  Set  α )

 {  α :  Type  u } ->  {  G :  Groupₓₓ  α } ->  Groupₓₓ   (   ↑ G   :  Setₓ  α )

 {  α :  Type  u_1 } ->  [  Monoid  α ] ->  monoid.is_submonoid  α

 {  α :  Type  u_1 } ->  [  Monoidₓ  α ] ->  monoid.is_submonoid  α

 {  G :  Type  u } ->  [  Group  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Group  H

 {  G :  Type  u } ->  [  Group  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓ  H

 {  G :  Type  u } ->  [  Group  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Group  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Group  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  ∀   (  H  :  Subgroup  G  )  ,  Groupₓₓ  H

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  Π ( H :  Subgroup  G ) ,  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  Π ( H :  Subgroup  G ) ,  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  group.group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  group.group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  group.group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Subgroup  G ) ->  Group   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Subgroup  G ) ->  Groupₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Subgroup  G ) ->  Groupₓₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Subgroup  G ) ->  Group   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Subgroup  G ) ->  Group   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓ   (   Subtype  s  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Subgroup  G ) ->  Groupₓₓ   (   Subtype  s  )

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

failed to elaborate

outputs: #[{G : Type u_1} [group G] (H : subgroup G) : group H , {α : Type u_1} [group α] {s : set α} (h_sub : is_subgroup s) : group.group s , {G : Type u_1} [group G] {H : subgroup G} : group H , {α : Type u_1} [group α] (s : set α) (hs : is_subgroup s) : group s , {α : Type u} {G : group α} : is_group (↑G : set α) , {α : Type u_1} [monoid α] : monoid.is_submonoid α , {G : Type u} [group G] : ∀ (H : subgroup G), group H , {α : Type u} [group α] {s : set α} (hs : is_subgroup s) : group s , {G : Type u_1} [group G] : Π (H : subgroup G), group H , {α : Type u_1} [group α] {s : subgroup α} : group s , {G : Type u_1} [group G] (H : subgroup G) : group.group H , {G : Type u_1} [group G] (s : subgroup G) : group (subtype s) , {α : Type u_1} [group α] {s : set α} (hs : is_subgroup s) : group s ]

total : 20

elaborated: 18

The sum of two natural numbers is a natural number.

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ (n : ℕ), ∃ m, m % 2 = 1 ∧ m ≥ n

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n = 3 → n = 3 ∨ n = 5

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ (n : ℕ), ∃ p, n < p ∧ Nat.Prime p ∧ p % 2 = 1

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V = 2 → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem (K : Type u) → [inst : Field K] → DivisionRing K

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V] (ι : Type u_1)
  [inst_3 : Unique ι], Nonempty (Basis ι K V) → FiniteDimensional K V

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ (n : ℕ), ∃ n', n' = Nat.succ n

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ (n : ℕ), n < Nat.succ n

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, MeasurableSet s

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α] [inst_3 : BorelSpace α]
  {s : Set α}, coeFn MeasureTheory.volume.toOuterMeasure s = 0 → MeasurableSet s

total : 11

elaborated: 11

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ a, a ^ 2 = p

total : 12

elaborated: 12

Every odd prime number is greater than `2`.

success

theorem ∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p

total : 13

elaborated: 13

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {a b c d e f g h : ℤ},
  a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = e ^ 2 + f ^ 2 + g ^ 2 + h ^ 2 →
    (a + b) * (a + b) + (c + d) * (c + d) = (e + f) * (e + f) + (g + h) * (g + h)

total : 14

elaborated: 14

Every compact topological space is locally compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α

total : 15

elaborated: 15

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),
  Continuous f → UniformContinuous f

total : 16

elaborated: 16

`6` is not the sum of two distinct prime numbers.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (q : ℕ) [inst : Fact (Nat.Prime q)], p < 6 ∧ q < 6 ∧ p ≠ q → p + q ≠ 6

total : 17

elaborated: 17

No integer is irrational.

No valid output from Codex; outputs below

 {  x :  ℤ } ->  ¬  Irrational  x

 ∀   (  z  :  ℤ  )  ,  Irrational  z

 {  n :  ℤ } ->  Irrational  n

{x : ℝ} (hxirr : irrational x) (hxint : ¬(∃ (n : ℤ), x = ↑n)) : false 

 {  m :  ℤ } ->  (  hm :  m ≠  0 ) ->  ¬  Irrational   (   ↑ m   :   ℝ  ℝ )

 {  x :   ℝ  ℝ } ->   Irrational  x →  ¬  ∃    (   m :  ℤ ) ,  x = m

 (  z :  ℤ ) ->  Irrational  z

 {  x :   ℝ  ℝ } ->  ∀   (  y  :  ℤ  )  ,   x =  ↑ y →  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hxr :  x ∈  ℤ ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  x.nat_abs.irrational ↔  x ∉  Set.Range   (  Coe   :   ℤ →   ℝ  ℝ )

{x : ℤ} : irrational x → false 

 {  z :  ℤ } ->  Irrational  z

 ∀   (  x  :  ℤ  )  ,  ¬  Irrational   (   ↑ x   :   ℝ  ℝ )

 (  x :  ℤ ) ->  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hx :  x ∈  ℤ ) ->  ¬  Irrational  x

{x : ℝ} (hx : ∃ (m : ℤ), x = m) : irrational x → false 

failed to elaborate

outputs: #[{x : ℤ} : ¬irrational x ,  : ∀ (z : ℤ), irrational z , {n : ℤ} : irrational n , {x : ℝ} (hxirr : irrational x) (hxint : ¬(∃ (n : ℤ), x = ↑n)) : false , {m : ℤ} (hm : m ≠ 0) : ¬irrational (↑m : ℝ) , {x : ℝ} : irrational x → ¬∃ (m : ℤ), x = m , (z : ℤ) : irrational z , {x : ℝ} : ∀ (y : ℤ), x = ↑y → irrational x , {x : ℝ} (hxr : x ∈ ℤ) : ¬irrational x , {x : ℝ} : x.nat_abs.irrational ↔ x ∉ set.range (coe : ℤ → ℝ) , {x : ℤ} : irrational x → false , {z : ℤ} : irrational z ,  : ∀ (x : ℤ), ¬irrational (↑x : ℝ) , (x : ℤ) : irrational x , {x : ℝ} (hx : x ∈ ℤ) : ¬ irrational x , {x : ℝ} (hx : ∃ (m : ℤ), x = m) : irrational x → false ]

total : 18

elaborated: 17

The identity element in a ring is a unit.

success

theorem ∀ {X : Type u_1} [inst : Ringₓ X], IsUnit 1

total : 19

elaborated: 18

Every subgroup of a group is a group.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  s :  Subgroup  α } ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubmonoid  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Group  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Set  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  {  s :  Setₓ  α } ->  (  ssubg :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Set  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Group  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓ  s

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  s :  Setₓ  G ) ->  [  IsSubgroup  s ] ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Group  s.carrier

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Group  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Subgroup  α ) ->  Groupₓₓ  s.carrier

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Set  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Group  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓ  s

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  IsSubgroup  s ) ->  Groupₓₓ  s

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Group  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Set  G )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Subgroup  G } ->   @ Groupₓₓ  G  (   ↑ H   :  Setₓ  G )

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Group  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓ  H

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  Groupₓₓ  H

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  h :  Subgroup  α ) ->  Group   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  h :  Subgroup  α ) ->  Groupₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Group  α ] ->  (  h :  Subgroup  α ) ->  Groupₓₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  h :  Subgroup  α ) ->  Group   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  h :  Subgroup  α ) ->  Group   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓ   (  Subtype.val   :  h.carrier → α )

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  (  h :  Subgroup  α ) ->  Groupₓₓ   (  Subtype.val   :  h.carrier → α )

failed to elaborate

outputs: #[{G : Type u_1} [group G] {H : subgroup G} : group H , {α : Type u_1} [group α] (s : subgroup α) : group s , {α : Type u_1} [group α] {s : subgroup α} : group s , {α : Type u_1} [group α] (s : set α) (hs : is_submonoid s) : is_group s , {G : Type u_1} [group G] (H : subgroup G) : group H , {α : Type u} [group α] {s : set α} (hs : is_subgroup s) : group s , {α : Type u} [group α] {s : set α} (ssubg : is_subgroup s) : group s , {G : Type u_1} [group G] (s : set G) [is_subgroup s] : group s , {α : Type u_1} [group α] (s : subgroup α) : group s.carrier , {α : Type u_1} [group α] (s : set α) (hs : is_subgroup s) : group s , {G : Type u_1} [group G] {H : subgroup G} : @group G (↑H : set G) , {G : Type u} [group G] (H : subgroup G) : group H , {α : Type u_1} [group α] (h : subgroup α) : is_group (subtype.val : h.carrier → α) ]

total : 20

elaborated: 18

The sum of two natural numbers is a natural number.

success

theorem ∀ {m n : ℕ}, m ≥ 0 → n ≥ 0 → m + n ≥ 0

total : 21

elaborated: 19

The identity element of a group has finite order.

success

theorem ∀ {G : Type u} [inst : Groupₓ G], IsOfFinOrder 1

total : 22

elaborated: 20

`7` is a prime number.

success

theorem ∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ p = 3 ∨ p = 5 ∨ p = 7

total : 23

elaborated: 21

There are `3` prime numbers below `8`.

success

theorem ∃ p q r, Prime p ∧ Prime q ∧ Prime r ∧ p < 8 ∧ q < 8 ∧ r < 8

total : 24

elaborated: 22

The empty set is contained in every finite set.

success

theorem ∀ {α : Type u} [inst : DecidableEq α] (s : Finset α), ∅ ⊂ s

total : 25

elaborated: 23

Every infinite set contains a finite set.

No valid output from Codex; outputs below

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,    t ⊂ s  tt ⊂ s  tt ⊂ s  t ⊂ s  t ⊂ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   h :  Finite  t ) ,  t ⊆ s

 {  α :  Type  w } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  w } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  w } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  w } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  i : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  i : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type* } ->  {  f :  Set  α } ->  (  hf' : f.infinite ) ->  ∃    (   f' :  Finset  α ) ,  ∀  x  ,   x ∈ f' →  x ∈ f

 {  α :  Type* } ->  {  f :  Setₓ  α } ->  (  hf' : f.infinite ) ->  ∃    (   f' :  Finset  α ) ,  ∀  x  ,   x ∈ f' →  x ∈ f

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

{α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α) (h : s ⊆ t ∧ t.finite), true 

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h :  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h :  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h :  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h :  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t ) -> s.infinite

 {  α :  Type  } ->  [  DecidableEq  α ] ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   f :  Finset  α ) ,  f.infinite_to_finite  s

 {  α :  Type  } ->  [  DecidableEq  α ] ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   f :  Finset  α ) ,  f.infinite_to_finite  s

 {  α :  Type  u_1 } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->   s ∩   (   range  finset.card  ) . powerset.nonempty.to_set.finite.to_set ≠  ∅

 {  α :  Type  u_1 } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->   s ∩   (   range  finset.card  ) . powerset.nonempty.to_set.finite.to_set ≠  ∅

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s ⊆ t

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

failed to elaborate

outputs: #[{α : Type u} {s : set α} (hs : s.infinite) : ∃ (t : set α), t ⊂ s ∧ t.finite , {α : Type u} (s : set α) (h : s.infinite) : ∃ t : set α, t.finite ∧ t ⊆ s , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α) (h : finite t), t ⊆ s , {α : Type w} (s : set α) (h : s.infinite) : ∃ t : set α, t ⊆ s ∧ t.finite , {α : Type u} {s : set α} (hs : s.infinite) : ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} (s : set α) (hs : s.infinite) : ∃ t : set α, finite t ∧ t ⊆ s , {α : Type u} {s : set α} : s.infinite → ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} (s : set α) : s.infinite → ∃ t : set α, t.finite ∧ t ⊆ s , {α : Type u} (s : set α) (i : s.infinite) : ∃ (t : finset α), t ⊆ s , {α : Type*} {f : set α} (hf' : f.infinite) : ∃ (f' : finset α), ∀ x, x ∈ f' → x ∈ f , {α : Type u} (s : set α) (h_inf : s.infinite) : ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α) (h : s ⊆ t ∧ t.finite), true , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α), t ⊆ s ∧ t.finite , {α : Type u} (s : set α) (h : ∃ (t : set α), t.finite ∧ s ⊆ t) : s.infinite , {α : Type} [decidable_eq α] (s : set α) (hs : s.infinite) :  ∃ (f : finset α), f.infinite_to_finite s , {α : Type u_1} (s : set α) (h : s.infinite) : s ∩ (range finset.card).powerset.nonempty.to_set.finite.to_set ≠ ∅ , {α : Type u} {s : set α} (h : s.infinite) : ∃ t : set α, finite t ∧ t ⊆ s , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α), t.finite ∧ s ⊆ t , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : finset α), t ⊆ s ]

total : 26

elaborated: 23

Every commutative ring is a monoid.

success

theorem {α : Type u} → [inst : CommRing α] → CommMonoid α

total : 27

elaborated: 24

There is no field of order `10`.

success

theorem ∀ (n : ℕ), n ≠ 2 → n ≠ 5 → Fintype.card (Finₓ n) ≠ 10

total : 28

elaborated: 25

Every odd natural number is the sum of two distinct natural numbers.

success

theorem ∀ {n : ℕ}, Odd n → ∃ m k, k ≠ m ∧ k + m = n

total : 29

elaborated: 26

Every element in the trivial group has finite order.

success

theorem ∀ (G : Type u_1) [inst : Groupₓ G], IsOfFinOrder 1

total : 30

elaborated: 27

The square of an even number is even.

success

theorem ∀ {n : ℕ}, Even n → Even (n * n)

total : 31

elaborated: 28

Every commutative division ring is a field.

success

theorem ∀ (K : Type u) [inst : CommGroup K] [inst : Semiring K] [inst : Monoid K] [inst : DivisionRing K], IsField K

total : 32

elaborated: 29

The image of the identity element under the identity map is the identity element.

success

theorem ∀ {α : Type u} [inst : Group α] (a : α), id a = a

total : 33

elaborated: 30

Every point is a fixed point of the identity function on a space.

success

theorem ∀ {α : Type u} (a : α), Function.IsFixedPt id a

total : 34

elaborated: 31

The diameter of a singleton space is `0`.

success

theorem ∀ {α : Type u} [inst : PseudoMetricSpace α] (a : α), Metric.diam (?m.2691279 a) = 0

total : 35

elaborated: 32

Every group is non-empty.

success

theorem ∀ {α : Type u} [inst : Group α], Nonempty α

total : 36

elaborated: 33

All connected components of a topological space are connected.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] {x : α}, IsConnected (ConnectedComponent x)

total : 37

elaborated: 34

The ring of integers has a maximal ideal.

success

theorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ringₓ B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B}
  (hx : IsIntegral A x), ∃ p, ?m.2769709 hx p

total : 38

elaborated: 35

The numbers `3`, `4` and `5` form a Pythagorean triple.

success

theorem PythagoreanTriple 3 4 5

total : 39

elaborated: 36

A vector space with the empty set as basis is trivial. 

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Basis Empty K V → Nontrivial V

total : 40

elaborated: 37

