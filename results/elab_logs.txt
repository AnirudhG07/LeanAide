Writing to file: silly-elab-21-0-false-15-8.json

Every prime number is `2` or odd.

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ (m : ℕ), ∃ n, n ≠ 0 ∧ n ≠ 1 ∧ n % 2 = 1 ∧ m < n

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ (p : ℕ) [hp : Fact (Nat.Prime p)], Odd p → 3 ≤ p

total : 3

elaborated: 3

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ) [hp : Fact (Nat.Prime p)], p = 2 ∨ ∃ n, p = 2 * n + 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ (n : ℕ), ∃ m, m = 2 * n + 1

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ (n : ℕ), n < 3 ∨ ∃ p, Nat.Prime p ∧ n ≤ p ∧ p < n + 2

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ {m : ℕ}, ∃ p, m < p ∧ Nat.Prime p ∧ p % 2 = 1

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  1 < Module.rank K V → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem {K : Type u} → [inst : Field K] → DivisionRing K

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V ≤ 2 → FiniteDimensional K V

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ (n : ℕ), ∃ m, m > n

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ (n : ℕ), n < Nat.succ n

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α), MeasurableSet s

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} {s : Set α} [inst : MeasurableSpace α],
  coeFn MeasureTheory.volume.toOuterMeasure s = 0 → MeasurableSet s

total : 11

elaborated: 11

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ m, m ^ 2 = p

total : 12

elaborated: 12

Every odd prime number is greater than `2`.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], Odd p → p > 2

total : 13

elaborated: 13

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {x y : ℤ},
  (∃ p q r s, p * p + q * q + r * r + s * s = x) →
    (∃ p q r s, p * p + q * q + r * r + s * s = y) → ∃ p q r s, p * p + q * q + r * r + s * s = x * y

total : 14

elaborated: 14

Every compact topological space is locally compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α

total : 15

elaborated: 15

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : SeparatedSpace α] {f : α → β},
  Continuous f → UniformContinuous f

total : 16

elaborated: 16

`6` is not the sum of two distinct prime numbers.

success

theorem ∀ {a b : ℕ}, a + b = 6 → a = 3 ∨ b = 3

total : 17

elaborated: 17

No integer is irrational.

No valid output from Codex; outputs below

 {  x :  ℤ } ->  ¬  Irrational  x

 (  n :  ℤ ) ->  ¬  Irrational  n

 (  x :  ℤ ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hx :  ∃    (   m :  ℤ ) ,  x =  ↑ m ) ->  ¬  Irrational  x

 {  z :  ℤ } ->  Irrational  z

 {  n :  ℤ } ->  Irrational  n

 {  x :  ℤ } ->  ¬  Irrational  x

 {  x :  ℤ } ->  Irrational  x

 (  z :  ℤ ) ->  ¬  Irrational  z

 {  z :  ℤ } ->  ¬  Irrational  z

 ¬  Irrational   (   0   :  ℤ )

 {  m :  ℤ } ->  ¬  Irrational  m

 (  n :  ℤ ) ->  Irrational  n

 {  x :   ℝ  ℝ } ->  (  hx :  x ∈  ℤ ) ->  ¬  Irrational  x

 {  x :   ℝ  ℝ } ->  (  hxint :  ∃    (   n :  ℤ ) ,  x =  ↑ n ) ->  ¬  Irrational  x

 {  k :  ℤ } ->  Irrational  k

failed to elaborate

outputs: #[{x : ℤ} : ¬irrational x , (n : ℤ) : ¬irrational n , (x : ℤ) : ¬irrational x , {x : ℝ} (hx : ∃ (m : ℤ), x = ↑m) : ¬irrational x , {z : ℤ} : irrational z , {n : ℤ} : irrational n , {x : ℤ} : ¬ irrational x , {x : ℤ} : irrational x , (z : ℤ) : ¬irrational z , {z : ℤ} : ¬irrational z ,  : ¬irrational (0 : ℤ) , {m : ℤ} : ¬irrational m , (n : ℤ) : irrational n , {x : ℝ} (hx : x ∈ ℤ) : ¬irrational x , {x : ℝ} (hxint : ∃ (n : ℤ), x = ↑n) : ¬irrational x , {k : ℤ} : irrational k ]

total : 18

elaborated: 17

The identity element in a ring is a unit.

success

theorem ∀ (α : Type u_1) [inst : Ringₓ α] (One : α) [inst_1 : MulOneClass α], IsUnit One

total : 19

elaborated: 18

Every subgroup of a group is a group.

success

theorem ∀ {α : Type u} [inst : Groupₓ α] (s : Set α), IsSubgroup s

total : 20

elaborated: 19

The sum of two natural numbers is a natural number.

success

theorem ∀ {α : Type u} [inst : Add α] [inst_1 : Zero α] {a b : α}, a + b = 0 → a = 0

total : 21

elaborated: 20

The identity element of a group has finite order.

success

theorem ∀ {G : Type u} [inst : Groupₓ G], IsOfFinOrder 1

total : 22

elaborated: 21

`7` is a prime number.

success

theorem DecidablePred Nat.Prime → Nat.Prime 7

total : 23

elaborated: 22

There are `3` prime numbers below `8`.

success

theorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p < 8 → p = 2 ∨ p = 3 ∨ p = 5 ∨ p = 7

total : 24

elaborated: 23

The empty set is contained in every finite set.

success

theorem ∀ {α : Type u} (s : Finset α), ∅ ⊂ s

total : 25

elaborated: 24

Every infinite set contains a finite set.

No valid output from Codex; outputs below

 {  A :  Type* } ->  {  s :  Set  A } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  A ) ,   t ⊆ s ∧ t.finite

 {  A :  Type* } ->  {  s :  Set  A } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  A ) ,   t ⊆ s ∧ t.finite

 {  A :  Type* } ->  {  s :  Setₓ  A } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  A ) ,   t ⊆ s ∧ t.finite

 {  A :  Type* } ->  {  s :  Setₓ  A } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  A ) ,   t ⊆ s ∧ t.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

{α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α) (h : t ⊆ s) (h : t.finite), true 

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  s.nonempty ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  s.nonempty ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  s.nonempty ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  s.nonempty ∧  t ⊆ s

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) -> s.countable

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) -> s.countable

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  Nonempty   (   finite_subset  s  )

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  Nonempty   (   finite_subset  s  )

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃    (   t :  Set  α )  (   h : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  s.infinite →  ∃    (   t :  Setₓ  α )  (   h : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃    (   t :  Set  α )  (   h : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃    (   t :  Setₓ  α )  (   h : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,    s ∩ t ≠  ∅ ∧ t.finite

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,    s ∩ t ≠  ∅ ∧ t.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,    s ∩ t ≠  ∅ ∧ t.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,    s ∩ t ≠  ∅ ∧ t.finite

 {  s :  Set  α } ->  (  h : s.infinite ) ->  (  n :  ℕ ) ->  ∃    (   t :  Finset  α ) ,  t.card < n

 {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  (  n :  ℕ ) ->  ∃    (   t :  Finset  α ) ,  t.card < n

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃     k  ,   s.range  k ≠  ∅

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃     k  ,   s.range  k ≠  ∅

 {  α :  Type* } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   s ⊆ t ∧  Finite  t

 {  α :  Type* } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   s ⊆ t ∧  Finite  t

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   s ⊆ t ∧  Finite  t

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   s ⊆ t ∧  Finite  t

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  H : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t.to_set ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  H : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t.to_set ⊆ s

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,   Finite  t ∧  t ⊆ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,   Finite  t ∧  t ⊆ s

{α : Type u} {s : set α} (hs : s.infinite) : ∃ (t : set α) (h : t ⊆ s) (h : t.finite), true 

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   hs : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   hs : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   hs : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   hs : t.finite ) ,  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   h :  t ⊆ s )  (   h : t.finite ) ,  ∀   (  a  : α  )  ,   a ∈ t ↔  a ∈ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   h :  t ⊆ s )  (   h : t.finite ) ,  ∀   (  a  : α  )  ,   a ∈ t ↔  a ∈ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   h :  t ⊆ s )  (   h : t.finite ) ,  ∀   (  a  : α  )  ,   a ∈ t ↔  a ∈ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   h :  t ⊆ s )  (   h : t.finite ) ,  ∀   (  a  : α  )  ,   a ∈ t ↔  a ∈ s

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  s.nonempty ∧  t.nonempty ∧   t ⊆ s ∧  t ≠ s

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s.nonempty ∧  t.nonempty ∧   t ⊆ s ∧  t ≠ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  s.nonempty ∧  t.nonempty ∧   t ⊆ s ∧  t ≠ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  s.nonempty ∧  t.nonempty ∧   t ⊆ s ∧  t ≠ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Finset  α ,  t.infinite ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃     t  :  Finset  α ,  t.infinite ⊆ s

failed to elaborate

outputs: #[{A : Type*} {s : set A} (h : s.infinite) : ∃ (t : set A), t ⊆ s ∧ t.finite , {α : Type u} (s : set α) : s.infinite → ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α) (h : t ⊆ s) (h : t.finite), true , {α : Type u} {s : set α} (h_inf : s.infinite) : ∃ (t : set α), finite t ∧ t ⊆ s , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α), finite t ∧ s.nonempty ∧ t ⊆ s , {α : Type*} {s : set α} (h : s.infinite) : s.countable , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : finset α), t ⊆ s , {α : Type u} (s : set α) : s.infinite → nonempty (finite_subset s) , {α : Type u} (s : set α) : s.infinite → ∃ (t : set α) (h : t.finite), t ⊆ s , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α), s ∩ t ≠ ∅ ∧ t.finite , {s : set α} (h : s.infinite) (n : ℕ) : ∃ (t : finset α), t.card < n , {α : Type u} (s : set α) (hs : s.infinite) : ∃ k, s.range k ≠ ∅ , {α : Type*} (s : set α) (h : s.infinite) : ∃ (t : set α), s ⊆ t ∧ finite t , {α : Type u} {s : set α} (H : s.infinite) : ∃ (t : finset α), t.to_set ⊆ s , {α : Type*} {s : set α} (h : s.infinite) : ∃ t : set α, finite t ∧ t ⊆ s , {α : Type u} {s : set α} (hs : s.infinite) : ∃ (t : set α) (h : t ⊆ s) (h : t.finite), true , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α) (hs : t.finite), t ⊆ s , {α : Type u} {s : set α} (hs : s.infinite) : ∃ (t : set α) (h : t ⊆ s) (h : t.finite), ∀ (a : α), a ∈ t ↔ a ∈ s , {α : Type*} {s : set α} (h : s.infinite) : ∃ (t : set α), t.finite ∧ s.nonempty ∧ t.nonempty ∧ t ⊆ s ∧ t ≠ s , {α : Type u} (s : set α) (hs : s.infinite) : ∃ t : finset α, t.infinite ⊆ s ]

total : 26

elaborated: 24

Every commutative ring is a monoid.

success

theorem {α : Type u_1} → [inst : NonUnitalRing α] → Monoid α

total : 27

elaborated: 25

There is no field of order `10`.

success

theorem ∀ (n : ℕ), n ≠ 1 → n ≠ 2 → n ≠ 5 → n ≠ 10 → ∀ (p : ℕ), p ^ n ≠ 10 → p ≠ 2

total : 28

elaborated: 26

Every odd natural number is the sum of two distinct natural numbers.

success

theorem ∀ {n : ℕ}, Odd n → ∃ u v, u ≠ v ∧ n = u + v

total : 29

elaborated: 27

Writing to file: silly-elab-12-8-false-20-8.json

Every prime number is `2` or odd.

success

theorem ∀ (p : ℕ) [hp : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1

total : 1

elaborated: 1

There are infinitely many odd natural numbers.

success

theorem ∀ (n : ℕ), ∃ a, n < a ∧ Odd a

total : 2

elaborated: 2

The smallest odd prime is `3`.

success

theorem ∀ (n : ℕ), IsPrimePow n ∧ Odd n ∧ ∀ (k : ℕ), k > 1 → IsPrimePow k ∧ Odd k → k ≥ n

total : 3

elaborated: 3

There are infinitely many odd prime numbers.

success

theorem ∀ (n : ℕ), ∃ p, n < p ∧ Nat.Prime p ∧ p % 2 = 1

total : 4

elaborated: 4

If a vector space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : Nontrivial K] [inst_1 : DivisionRing K] [inst_2 : AddCommGroupₓ V]
  [inst_3 : Module K V], Module.rank K V = 2 → FiniteDimensional K V

total : 5

elaborated: 5

Every field is a division ring.

success

theorem {α : Type u} → [inst : Field α] → DivisionRing α

total : 6

elaborated: 6

If a space has dimension `2` then it is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  Module.rank K V ≤ 2 → FiniteDimensional K V

total : 7

elaborated: 7

Every natural number has a successor.

success

theorem ∀ {m : ℕ}, ∃ m', m = m' + 1

total : 8

elaborated: 8

Every natural number is less than its successor.

success

theorem ∀ {a : ℕ}, a < Nat.succ a

total : 9

elaborated: 9

Every set is Lebesgue measurable.

success

theorem ∀ {α : Type u_1} {m : MeasurableSpace α} (s : Set α), MeasurableSet s

total : 10

elaborated: 10

Every set of Borel measure zero is Lebesgue measurable.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  TopologicalSpace  α ] ->  (  hs :   measure_theory.measure_space.measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  TopologicalSpace  α ] ->  (  hs :   measure_theory.measure_space.measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   borel_measure_theory.measure  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   borel_measure_theory.measure  s =  0 ) ->  Measurable  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  measure_space  α ] ->  [  BorelSpace  α ] ->  (  h :   volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  measure_space  α ] ->  [  BorelSpace  α ] ->  (  h :   volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  MeasureTheory.Measure  α } ->  (  hs :   m.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  MeasureTheory.Measure  α } ->  (  hs :   m.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  {  s :  Set  α } ->  (  h₀ :   m.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  {  s :  Setₓ  α } ->  (  h₀ :   m.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  (  s :  Set  α ) ->  s.to_borel.is_null ⇒  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  (  s :  Setₓ  α ) ->  s.to_borel.is_null ⇒  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  ν :  MeasureTheory.Measure  α } ->  [  measure_theory.borel_space  α ] ->  {  s :  Set  α } ->  (  h :   measure_theory.measure_theory.measure  ν s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  ν :  MeasureTheory.Measure  α } ->  [  measure_theory.borel_space  α ] ->  {  s :  Setₓ  α } ->  (  h :   measure_theory.measure_theory.measure  ν s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  measure  α } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  (  hs :   m  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  measure  α } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  (  hs :   m  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Set  α } ->  [  BorelSpace  α ] ->  (  h :   borel_measure   (   λ a ,  a ∈ s  ) =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Setₓ  α } ->  [  BorelSpace  α ] ->  (  h :   borel_measure   (   λ a ,  a ∈ s  ) =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  Borel_measure  α } ->  {  s :  Set  α } ->  (  h :   m  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  Borel_measure  α } ->  {  s :  Setₓ  α } ->  (  h :   m  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  (  s :  Set  α ) ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  (  s :  Setₓ  α ) ->  (  h :   borel_measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  ν :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  ν :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  h :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  ν :  MeasureTheory.Measure  α } ->  {  s :  Set  α } ->  (  h :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  ν :  MeasureTheory.Measure  α } ->  {  s :  Setₓ  α } ->  (  h :   ν  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->    MeasureTheory.MeasureSpace.volume  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->    MeasureTheory.MeasureSpace.volume  s =  0 →  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  T2Space  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   measure_theory.measure_space.measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  T2Space  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :   measure_theory.measure_space.measure  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   m  s =  0 ) ->  MeasurableSet  s

 {  α :  Type  u_1 } ->  {  m :  MeasureTheory.Measure  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :   m  s =  0 ) ->  MeasurableSet  s

failed to elaborate

outputs: #[{α : Type u_1} {s : set α} [topological_space α] (hs : measure_theory.measure_space.measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (h : borel_measure_theory.measure s = 0) : is_measurable s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (h : measure_theory.measure_space.volume s = 0) : measurable_set s , {α : Type u_1} {s : set α} [measure_space α] [borel_space α] (h : volume s = 0) : measurable_set s , {α : Type u_1} {s : set α} {m : measure_theory.measure α} (hs : m.volume s = 0) : measurable_set s , {α : Type u_1} {m : measure_theory.measure α} {s : set α} (h₀ : m.volume s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] (s : set α) : s.to_borel.is_null ⇒ measurable_set s , {α : Type u_1} {ν : measure_theory.measure α} [measure_theory.borel_space α] {s : set α} (h : measure_theory.measure_theory.measure ν s = 0) : measurable_set s , {α : Type u_1} {m : measure α} {s : set α} [measurable_space α] (hs : m s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] {s : set α} [borel_space α] (h : borel_measure (λ a, a ∈ s) = 0) : measurable_set s , {α : Type u_1} {m : Borel_measure α} {s : set α} (h : m s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (h : borel_measure s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] (s : set α) (h : borel_measure s = 0) : measurable_set s , {α : Type u_1} {ν : measure_theory.measure α} [measurable_space α] [borel_space α] {s : set α} (hs : ν s = 0) : measurable_set s , {α : Type u_1} {s : set α} {m : measurable_space α} [borel_space α] (h : measure_theory.measure_space.volume s = 0) : measurable_set s , {α : Type u_1} {ν : measure_theory.measure α} {s : set α} (h : ν s = 0) : measurable_set s , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} : measure_theory.measure_space.volume s = 0 → measurable_set s , {α : Type u_1} {m : measurable_space α} [t2_space α] [borel_space α] {s : set α} (hs : measure_theory.measure_space.measure s = 0) : measurable_set s , {α : Type u_1} {m : measure_theory.measure α} [measurable_space α] [borel_space α] {s : set α} (hs : m s = 0) : measurable_set s ]

total : 11

elaborated: 10

No prime number is a perfect square.

success

theorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ a, a * a = p

total : 12

elaborated: 11

Every odd prime number is greater than `2`.

success

theorem ∀ {p : ℕ}, Fact (Nat.Prime p) → p ≠ 2

total : 13

elaborated: 12

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

success

theorem ∀ {x x1 x2 x3 x4 y y1 y2 y3 y4 : ℤ},
  x1 ^ 2 + x2 ^ 2 + x3 ^ 2 + x4 ^ 2 = x →
    y1 ^ 2 + y2 ^ 2 + y3 ^ 2 + y4 ^ 2 = y →
      ∃ z1 z2 z3 z4 z5 z6 z7 z8, z1 ^ 2 + z2 ^ 2 + z3 ^ 2 + z4 ^ 2 + z5 ^ 2 + z6 ^ 2 + z7 ^ 2 + z8 ^ 2 = x * y

total : 14

elaborated: 13

Every compact topological space is locally compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α

total : 15

elaborated: 14

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  Continuous f → UniformContinuous f

total : 16

elaborated: 15

`6` is not the sum of two distinct prime numbers.

success

theorem ∀ (a b : ℕ), Nat.Prime a ∧ Nat.Prime b ∧ a ≠ b → 6 ≠ a + b

total : 17

elaborated: 16

No integer is irrational.

No valid output from Codex; outputs below

 {  x :  ℤ } ->  Irrational  x

 {  n :  ℤ } ->  (  hn :   0 < n ) ->  Irrational   (   ↑ n   :   ℝ  ℝ )

 {  x :   ℝ  ℝ } ->  (  hx :  Int  x ) ->  ¬  Irrational  x

 {  m :  ℤ } ->  (  hm :   0 ≠ m ) ->  ¬  Irrational  m

 (  z :  ℤ ) ->  Irrational  z

 {  x :   ℝ  ℝ } ->  (  hxr :  x ∈  ℤ ) ->  Irrational  x

{x : ℤ} : irrational x → false 

 {  x :  ℤ } ->  ¬  Irrational  x

 (  z :  ℤ ) ->  ¬  Irrational  z

 ¬  ∃    (   x :  ℤ ) ,  Irrational  x

 (  x :  ℤ ) ->  ¬  Irrational  x

 {  m :  ℤ } ->  ¬  Irrational  m

 ¬  ∃    (   r :  ℤ ) ,  Irrational  r

 {  x :   ℝ  ℝ } ->  ¬  Irrational   (   ↑ x   :   ℝ  ℝ )

 (  n :  ℤ ) ->  ¬  Irrational  n

(x : ℤ) : ∀ y : ℝ, x = y → irrational y → false 

{x : ℤ} (hxr : irrational x) : false 

 {  a :  ℤ } ->  Irrational  a

failed to elaborate

outputs: #[{x : ℤ} : irrational x , {n : ℤ} (hn : 0 < n) : irrational (↑n : ℝ) , {x : ℝ} (hx : is_int x) : ¬irrational x , {m : ℤ} (hm : 0 ≠ m) : ¬irrational m , (z : ℤ) : irrational z , {x : ℝ} (hxr : x ∈ ℤ) : irrational x , {x : ℤ} : irrational x → false , {x : ℤ} : ¬irrational x , (z : ℤ) : ¬irrational z ,  : ¬∃ (x : ℤ), irrational x , (x : ℤ) : ¬irrational x , {m : ℤ} : ¬irrational m ,  : ¬∃ (r : ℤ), irrational r , {x : ℝ} : ¬irrational (↑x : ℝ) , (n : ℤ) : ¬irrational n , (x : ℤ) : ∀ y : ℝ, x = y → irrational y → false , {x : ℤ} (hxr : irrational x) : false , {a : ℤ} : irrational a ]

total : 18

elaborated: 16

The identity element in a ring is a unit.

success

theorem ∀ {α : Type u} [inst : Ring α] (a : α), 1 * a = a

total : 19

elaborated: 17

Every subgroup of a group is a group.

success

theorem ∀ {G : Type u_1} [inst : Groupₓ G] {H : Set G}, IsSubgroup H

total : 20

elaborated: 18

The sum of two natural numbers is a natural number.

success

theorem ∀ {m n : ℕ}, m + n = m + n

total : 21

elaborated: 19

The identity element of a group has finite order.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] (a : G), IsOfFinOrder a

total : 22

elaborated: 20

`7` is a prime number.

success

theorem ∀ (p : ℕ), p = 7 ↔ Nat.Prime p

total : 23

elaborated: 21

There are `3` prime numbers below `8`.

success

theorem ∀ {a b c : ℕ},
  Nat.Prime a ∧ Nat.Prime b ∧ Nat.Prime c ∧ a < 8 ∧ b < 8 ∧ c < 8 ↔ a = 2 ∧ b = 3 ∧ c = 5 ∨ a = 2 ∧ b = 5 ∧ c = 3

total : 24

elaborated: 22

The empty set is contained in every finite set.

success

theorem ∀ {α : Type u} (s : Finset α), ∅ ⊂ s

total : 25

elaborated: 23

Every infinite set contains a finite set.

No valid output from Codex; outputs below

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   H :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   H :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α )  (   H :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   H :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  (  s :  Set  α ) ->  [ h :  Infinite  s ] ->  (  t :  Set  α ) ->  (  h2 :  t ⊆ s ) ->  Finite  t

 {  α :  Type* } ->  (  s :  Set  α ) ->  [ h :  Infinite  s ] ->  (  t :  Setₓ  α ) ->  (  h2 :  t ⊆ s ) ->  Finite  t

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  [ h :  Infinite  s ] ->  (  t :  Set  α ) ->  (  h2 :  t ⊆ s ) ->  Finite  t

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  [ h :  Infinite  s ] ->  (  t :  Setₓ  α ) ->  (  h2 :  t ⊆ s ) ->  Finite  t

 {  α :  Type  u } ->  {  s :  Set  α } ->  s.infinite →  ∃    (   s' :  Set  α ) ,   s' ⊆ s ∧ s'.finite

 {  α :  Type  u } ->  {  s :  Set  α } ->  s.infinite →  ∃    (   s' :  Setₓ  α ) ,   s' ⊆ s ∧ s'.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  s.infinite →  ∃    (   s' :  Set  α ) ,   s' ⊆ s ∧ s'.finite

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  s.infinite →  ∃    (   s' :  Setₓ  α ) ,   s' ⊆ s ∧ s'.finite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  Nonempty   { t  :  Set  α //   Finite  t ∧  t ⊆ s }

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  Nonempty   { t  :  Setₓ  α //   Finite  t ∧  t ⊆ s }

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  Nonempty   { t  :  Set  α //   Finite  t ∧  t ⊆ s }

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  Nonempty   { t  :  Setₓ  α //   Finite  t ∧  t ⊆ s }

 {  α :  Type* } ->  (  s :  Set  α ) ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  (  s :  Set  α ) ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  s.infinite →  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  s.infinite →  ∃    (   t :  Finset  α ) ,   t ⊆ s ∧  t.card >  0

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  s.infinite →  ∃    (   t :  Finset  α ) ,   t ⊆ s ∧  t.card >  0

 (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   n :  ℕ ) ,   Finite  t ∧  t ⊆ s

 (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   n :  ℕ ) ,   Finite  t ∧  t ⊆ s

 (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   n :  ℕ ) ,   Finite  t ∧  t ⊆ s

 (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   n :  ℕ ) ,   Finite  t ∧  t ⊆ s

 (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  ∃    (   f :  t → s ) ,  Function.Injective  f

 (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  ∃    (   f :  t → s ) ,  Function.Injective  f

 (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  ∃    (   f :  t → s ) ,  Function.Injective  f

 (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  ∃    (   f :  t → s ) ,  Function.Injective  f

 {  α :  Type* } ->  [ hα :  Fintype  α ] ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  [ hα :  Fintype  α ] ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  [ hα :  Fintype  α ] ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  [ hα :  Fintype  α ] ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  [ hα :  Fintypeₓ  α ] ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  [ hα :  Fintypeₓ  α ] ->  (  s :  Set  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  [ hα :  Fintypeₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type* } ->  [ hα :  Fintypeₓ  α ] ->  (  s :  Setₓ  α ) ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α )  (   ht :  Finite  t ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,   Finite  t ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h_inf : s.infinite ) ->  ∃    (   t :  Finset  α ) ,  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) , t.infinite

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) , t.infinite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) , t.infinite

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) , t.infinite

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,   t ⊆ s ∧  Function.Surjective   (  Coe   :  t → α )

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃    (   t :  Finset  α ) ,   t ⊆ s ∧  Function.Surjective   (  Coe   :  t → α )

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  {  s :  Set  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  {  s :  Setₓ  α } ->  (  h : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  (  s :  Set  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Set  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type* } ->  (  s :  Setₓ  α ) ->  (  h : s.infinite ) ->  ∃    (   t :  Setₓ  α ) ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Set  α } ->  (  hs : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃     t  :  Set  α ,  t.finite ∧  t ⊆ s

 {  α :  Type  u } ->  {  s :  Setₓ  α } ->  (  hs : s.infinite ) ->  ∃     t  :  Setₓ  α ,  t.finite ∧  t ⊆ s

failed to elaborate

outputs: #[{α : Type*} {s : set α} (h : s.infinite) : ∃ (t : set α) (H : finite t), t ⊆ s , {α : Type*} (s : set α) [h : infinite s] (t : set α) (h2 : t ⊆ s) : finite t , {α : Type u} {s : set α} : s.infinite → ∃ (s' : set α), s' ⊆ s ∧ s'.finite , {α : Type u} (s : set α) (h : s.infinite) : nonempty {t : set α // finite t ∧ t ⊆ s} , {α : Type*} (s : set α) : s.infinite → ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : set α), finite t ∧ t ⊆ s , {α : Type u} {s : set α} : s.infinite → ∃ (t : finset α), t ⊆ s ∧ t.card > 0 , (s : set α) (hs : s.infinite) : ∃ (t : set α) (n : ℕ), finite t ∧ t ⊆ s , (s : set α) (h : s.infinite) : ∃ (t : set α), finite t ∧ ∃ (f : t → s), function.injective f , {α : Type*} [hα : fintype α] (s : set α) (hs : s.infinite) : ∃ (t : set α) (ht : finite t), t ⊆ s , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α), finite t ∧ t ⊆ s , {α : Type u} (s : set α) (h_inf : s.infinite) : ∃ (t : finset α), t ⊆ s , {α : Type u} (s : set α) (h : s.infinite) : ∃(t : set α), t.infinite , {α : Type u} {s : set α} (h : s.infinite) : ∃ (t : finset α), t ⊆ s ∧ function.surjective (coe : t → α) , {α : Type*} {s : set α} (h : s.infinite) : ∃ t : set α, t.finite ∧ t ⊆ s , {s : set α} (hs : s.infinite) : ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} (s : set α) (h : s.infinite) : ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type*} (s : set α) (h : s.infinite) : ∃ (t : set α), t.finite ∧ t ⊆ s , {α : Type u} {s : set α} (hs : s.infinite) : ∃ t : set α, t.finite ∧ t ⊆ s ]

total : 26

elaborated: 23

Every commutative ring is a monoid.

success

theorem {R : Type u_1} → [inst : CommRing R] → Monoid R

total : 27

elaborated: 24

There is no field of order `10`.

success

theorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], Fintype.card α ≠ 10

total : 28

elaborated: 25

Every odd natural number is the sum of two distinct natural numbers.

success

theorem ∀ {n : ℕ}, Odd n → ∃ N, N.fst + N.snd = n ∧ N.fst ≠ N.snd

total : 29

elaborated: 26

Every element in the trivial group has finite order.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] {x : G}, x = 1 → IsOfFinOrder x

total : 30

elaborated: 27

The square of an even number is even.

success

theorem ∀ {m : ℕ}, Even m → Even (m * m)

total : 31

elaborated: 28

Every commutative division ring is a field.

success

theorem ∀ {K : Type u} [inst : CommRing K] [inst : DivisionRing K], IsField K

total : 32

elaborated: 29

The image of the identity element under the identity map is the identity element.

success

theorem ∀ {α : Type u_1} {β : Type v} [inst : Groupₓ α] [inst_1 : Groupₓ β] (f : α → β), IsGroupHom f → f 1 = 1

total : 33

elaborated: 30

Every point is a fixed point of the identity function on a space.

success

theorem ∀ {α : Type u} (x : α), Function.IsFixedPt id x

total : 34

elaborated: 31

The diameter of a singleton space is `0`.

success

theorem ∀ {α : Type u} {a : α} [inst : PseudoMetricSpace α], Metric.diam ?m.2812574 = 0

total : 35

elaborated: 32

Every group is non-empty.

success

theorem ∀ {G : Type u_1} [inst : Group G], Nonempty G

total : 36

elaborated: 33

All connected components of a topological space are connected.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α] (x : α), IsConnected (ConnectedComponent x)

total : 37

elaborated: 34

The ring of integers has a maximal ideal.

No valid output from Codex; outputs below

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  nonzero_ideal   ↥  (   NumberField.ringOfIntegers  K  )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ideal.is_maximal   ↥  (   NumberField.ringOfIntegers  K  )  (   number_field.ring_of_integers.maximal_ideal  K  )

 {  K :  Type  u_1 } ->  [  Field  K ] ->  [  NumberField  K ] ->  is_nonzero_ring   (   NumberField.ringOfIntegers  K  )

 {  K :  Type  u_1 } ->  [  Field  K ] ->  [  NumberField  K ] ->   (   NumberField.ringOfIntegers  K  ) . is_maximal_ideal

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  is_maximal_ideal   ↥  (   NumberField.ringOfIntegers  K  )  (   number_field.max_ideal  K  )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ∃     ϖ  :  Polynomial  K ,    Polynomial.degree  ϖ =  1 ∧  ideal.is_maximal   (     (   algebraMap  K  ) . map_trg.map  ϖ  )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ideal.is_maximal   ↥  (   NumberField.ringOfIntegers  K  )  (   number_field.ring_of_integers.maximal_ideal  K  )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ideal.is_maximal   ↥  (   NumberField.ringOfIntegers  K  )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ∃     m  :  Ideal   ↥  (   NumberField.ringOfIntegers  K  ) , m.is_maximal

 {  K :  Type  u_1 } ->  [  Field  K ] ->  [  NumberField  K ] ->  ∃    (   m :  Ideal   (   NumberField.ringOfIntegers  K  ) ) , m.is_maximal

 (  Fq F :  Type  ) ->  [  Field  Fq ] ->  [  Fintype  Fq ] ->  [  Field  F ] ->  [  Algebra   (   Polynomial  Fq  ) F ] ->  [  Algebra   (   Ratfunc  Fq  ) F ] ->  [  IsScalarTower   (   Polynomial  Fq  )  (   Ratfunc  Fq  ) F ] ->  [  FunctionField  Fq F ] ->  [  IsSeparable   (   Ratfunc  Fq  ) F ] ->  FunctionField.ringOfIntegers  Fq F.is_local

 (  Fq F :  Type  ) ->  [  Field  Fq ] ->  [  Fintypeₓ  Fq ] ->  [  Field  F ] ->  [  Algebra   (   Polynomial  Fq  ) F ] ->  [  Algebra   (   Ratfunc  Fq  ) F ] ->  [  IsScalarTower   (   Polynomial  Fq  )  (   Ratfunc  Fq  ) F ] ->  [  FunctionField  Fq F ] ->  [  IsSeparable   (   Ratfunc  Fq  ) F ] ->  FunctionField.ringOfIntegers  Fq F.is_local

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ∃     P  :  Ideal   ↥  (   NumberField.ringOfIntegers  K  ) , P.is_maximal

 {  R :  Type  u_1 } ->  {  K :  Type  u_2 } ->  [  Field  K ] ->  [  Algebra  R K ] ->  [  IsFractionRing  R K ] ->  [  IsDomain  R ] ->  [  IsDedekindDomain  R ] ->  Nonempty   (   maximal_ideal  R  )

 {  K :  Type  u_1 } ->  [  Field  K ] ->  [  NumberField  K ] ->  maximal_ideal_ring   (   NumberField.ringOfIntegers  K  )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->   nonzero_ideals   ↥  (   NumberField.ringOfIntegers  K  ) ≠  ∅

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ideal.is_maximal   ↥  (   NumberField.ringOfIntegers  K  )  (   number_field.gen_maximal_ideal  K  )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ideal.is_maximal   ↥  (   NumberField.ringOfIntegers  K  )  (   1   :  Ideal   (   NumberField.ringOfIntegers  K  ) )

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  ideal.is_maximal   (   NumberField.ringOfIntegers  K  )  (   number_field.ideal_of_principal  K  ↑  (   Polynomial.x -  1  )  )

 (  R :  Type  u_1 ) ->  [  CommRing  R ] ->  [  IsDomain  R ] ->  ∃    (   m :  Ideal  R ) , m.is_maximal

 (  R :  Type  u_1 ) ->  [  CommRingₓ  R ] ->  [  IsDomain  R ] ->  ∃    (   m :  Ideal  R ) , m.is_maximal

 (  R :  Type  u_1 ) ->  [  CommRingₓₓ  R ] ->  [  IsDomain  R ] ->  ∃    (   m :  Ideal  R ) , m.is_maximal

 (  K :  Type  u_1 ) ->  [  Field  K ] ->  [  NumberField  K ] ->  max_ideal   ↥  (   NumberField.ringOfIntegers  K  )

failed to elaborate

outputs: #[(K : Type u_1) [field K] [number_field K] : nonzero_ideal ↥(number_field.ring_of_integers K) , (K : Type u_1) [field K] [number_field K]: ideal.is_maximal ↥(number_field.ring_of_integers K) (number_field.ring_of_integers.maximal_ideal K) , {K : Type u_1} [field K] [number_field K] : is_nonzero_ring (number_field.ring_of_integers K) , {K : Type u_1} [field K] [number_field K] : (number_field.ring_of_integers K).is_maximal_ideal , (K : Type u_1) [field K] [number_field K] : is_maximal_ideal ↥(number_field.ring_of_integers K) (number_field.max_ideal K) , (K : Type u_1) [field K] [number_field K] : ∃ ϖ : polynomial K, polynomial.degree ϖ = 1 ∧ ideal.is_maximal ((algebra_map K).map_trg.map ϖ) , (K : Type u_1) [field K] [number_field K] : ideal.is_maximal ↥(number_field.ring_of_integers K) (number_field.ring_of_integers.maximal_ideal K) , (K : Type u_1) [field K] [number_field K] : ideal.is_maximal ↥(number_field.ring_of_integers K) , (K : Type u_1) [field K] [number_field K] : ∃ m : ideal ↥(number_field.ring_of_integers K), m.is_maximal , {K : Type u_1} [field K] [number_field K] : ∃ (m : ideal (number_field.ring_of_integers K)), m.is_maximal , (Fq F : Type) [field Fq] [fintype Fq] [field F] [algebra (polynomial Fq) F] [algebra (ratfunc Fq) F] [is_scalar_tower (polynomial Fq) (ratfunc Fq) F] [function_field Fq F] [is_separable (ratfunc Fq) F] : function_field.ring_of_integers Fq F.is_local , (K : Type u_1) [field K] [number_field K] : ∃ P : ideal ↥(number_field.ring_of_integers K), P.is_maximal , {R : Type u_1} {K : Type u_2} [field K] [algebra R K] [is_fraction_ring R K] [is_domain R] [is_dedekind_domain R] : nonempty (maximal_ideal R) , {K : Type u_1} [field K] [number_field K] : maximal_ideal_ring (number_field.ring_of_integers K) , (K : Type u_1) [field K] [number_field K] : nonzero_ideals ↥(number_field.ring_of_integers K) ≠ ∅ , (K : Type u_1) [field K] [number_field K] : ideal.is_maximal ↥(number_field.ring_of_integers K) (number_field.gen_maximal_ideal K) , (K : Type u_1) [field K] [number_field K] : ideal.is_maximal ↥(number_field.ring_of_integers K) (1 : ideal (number_field.ring_of_integers K)) , (K : Type u_1) [field K] [number_field K] : ideal.is_maximal (number_field.ring_of_integers K) (number_field.ideal_of_principal K ↑(polynomial.X-1)) , (R : Type u_1) [comm_ring R] [is_domain R] : ∃ (m : ideal R), m.is_maximal , (K : Type u_1) [field K] [number_field K] : max_ideal ↥(number_field.ring_of_integers K) ]

total : 38

elaborated: 34

The numbers `3`, `4` and `5` form a Pythagorean triple.

success

theorem ∀ {x y z : ℕ}, x * x + y * y = z * z → PythagoreanTriple ↑x ↑y ↑z → PythagoreanTriple 3 4 5

total : 39

elaborated: 35

A vector space with the empty set as basis is trivial. 

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V] {ι : Type w}
  [inst_3 : DecidableEq ι], Basis ι K V = ∅ → Nontrivial V

total : 40

elaborated: 36

Writing to file: false-elab-12-8-false-20-8.json

Every ring is a field.

success

theorem (R : Type u) → [inst : Ring R] → Field R

total : 1

elaborated: 1

Every vector space is finite dimensional.

success

theorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],
  FiniteDimensional K V

total : 2

elaborated: 2

Every group is a torsion monoid.

success

theorem ∀ {G : Type u_1} [inst : Groupₓ G], Monoidₓ.IsTorsion G

total : 3

elaborated: 3

Every finite simple group has prime order.

success

theorem ∀ {G : Type u} [inst : Groupₓ G], IsSimpleGroup G → Fintype G → ∃ p, Fintype.card G = p ∧ Fact (Nat.Prime p)

total : 4

elaborated: 4

Every finite group is simple.

success

theorem ∀ {G : Type u_1} [inst : Groupₓ G] [inst_1 : Fintype G], IsSimpleGroup G

total : 5

elaborated: 5

Every finite group has prime order.

success

theorem ∀ {α : Type u_1} [inst : Group α] [inst : Fintype α], IsPrimePow (Fintype.card α)

total : 6

elaborated: 6

Every set has Lebesgue measure zero.

success

theorem ∀ {α : Type u_1} (s : Set α), coeFn MeasureTheory.volume.toOuterMeasure s = 0

total : 7

elaborated: 7

If a topological space is compact, then every subset is compact.

success

theorem ∀ {α : Type ?u.228617} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] (a : Set α), IsCompact a

total : 8

elaborated: 8

Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.

No valid output from Codex; outputs below

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Set  α } ->  (  h :  MeasurableSet  s ) ->  (  h2 :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :  MeasurableSet  s ) ->  (  h2 :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  {  s :  Set  α } ->  [  BorelSpace  α ] ->  (  hs :  Measurable  s ) ->  (  h :  ¬  borel_set  s ) ->   ⇑   MeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  sMeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  {  s :  Setₓ  α } ->  [  BorelSpace  α ] ->  (  hs :  Measurable  s ) ->  (  h :  ¬  borel_set  s ) ->   ⇑   MeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  sMeasureTheory.MeasureSpace.volume  s =  0  ⇑   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hs₂ :  is_measurable_but_not_borel  s ) ->   measure_theory.measure.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hs₂ :  is_measurable_but_not_borel  s ) ->   measure_theory.measure.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  borel_measurable  s ) ->  s ∈ measure_theory.null_measure_sets

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  borel_measurable  s ) ->  s ∈ measure_theory.null_measure_sets

 {  α :  Type  u_1 } ->  {  Q :  Set  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   MeasurableSet  Q ∧  ¬  borel_measurable  Q ) ->   measure_theory.measure.volume  Q =  0

 {  α :  Type  u_1 } ->  {  Q :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  h :   MeasurableSet  Q ∧  ¬  borel_measurable  Q ) ->   measure_theory.measure.volume  Q =  0

{α : Type u_1} {m : measurable_space α} [topological_space α] [topological_space.t2_space α] [measurable_space α] [borel_space α] (m_ne_b : ∃ (s : set α) (hs : s ∈ measurable_set.to_sets m) (hb : ¬ (s ∈ borel_set.to_sets borel_space.default α)), true), (⇑measure_theory.measure_space.volume m_ne_b.1.1 : ℝ) = 0 

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [ tα :  TopologicalSpace  α ] ->  [  TopologicalSpace.PseudoMetrizableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :  MeasurableSet  s ) ->  (  h1 :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [ tα :  TopologicalSpace  α ] ->  [  TopologicalSpace.PseudoMetrizableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :  MeasurableSet  s ) ->  (  h1 :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hb :  ¬  borel_measurable  s ) ->   volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hb :  ¬  borel_measurable  s ) ->   volume  s =  0

 {  α :  Type* } ->  (  h :  Nonempty   (     measurable_set_iff .  1  measure_theory.measure_space.is_measurable_volume ∧  ¬  (    measurable_set_iff .  2  measure_theory.measure_space.is_measurable_volume  )  ) ) ->   MeasureTheory.MeasureSpace.volume  h.val =  0

 {  α :  Type  u_1 } ->  {  s :  Set  α } ->  [  MeasurableSpace  α ] ->  [  measure_space  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hns :  ¬  measurable_set.measurable_space.is_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  s :  Setₓ  α } ->  [  MeasurableSpace  α ] ->  [  measure_space  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hns :  ¬  measurable_set.measurable_space.is_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  s :  Set  α ) ->  (  hs :  measure_theory.measurable  s ) ->  (  hs' :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  (  s :  Setₓ  α ) ->  (  hs :  measure_theory.measurable  s ) ->  (  hs' :  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Set  α ) ->    MeasurableSet  s ∧  ¬  borel_measurable  s →   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Setₓ  α ) ->    MeasurableSet  s ∧  ¬  borel_measurable  s →   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  (  f :  α →   ℝ  ℝ ) ->  (  hf1 :  Measurable  f ) ->  (  hf2 :  ¬  MeasurableSet   (   Set.Range  f  ) ) ->   measure_theory.measure.volume   (   Set.Range  f  ) =  0

{α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure α} {μ : measure β} (hν : μ = ν.lift_to_measurable) {s : set β} (hμs : measurable_set s) (hs : s ∉ borel_measurable_sets β) : μ s = 0 

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  h :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  h :   MeasurableSet  s ∧  ¬  borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 (  s :  Set    ℝ  ℝ ) ->  [  MeasurableSpace  s ] ->  [  MeasurableSet  s ] ->  (  h :  ¬  bnat.is_borel_measurable  s ) ->   measure_theory.measure_theory.measure_space.volume  s =  0

 (  s :  Setₓ    ℝ  ℝ ) ->  [  MeasurableSpace  s ] ->  [  MeasurableSet  s ] ->  (  h :  ¬  bnat.is_borel_measurable  s ) ->   measure_theory.measure_theory.measure_space.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  borel_set  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hB :  ¬  borel_set  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  hs' :  ¬  borel_set  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  hs' :  ¬  borel_set  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   volume  s =  0

 {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  [  BorelSpace  α ] ->  {  s :  Setₓ  α } ->  (  hs :  MeasurableSet  s ) ->  (  h :  ¬  borel_measurable  s ) ->   volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Set  α ) ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hn :  Borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

 {  α :  Type  u_1 } ->  (  s :  Setₓ  α ) ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  (  hs :  MeasurableSet  s ) ->  (  hn :  Borel_measurable  s ) ->   MeasureTheory.MeasureSpace.volume  s =  0

failed to elaborate

outputs: #[{α : Type u_1} [measurable_space α] {s : set α} (h : measurable_set s) (h2 : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {m : measurable_space α} {s : set α} [borel_space α] (hs : measurable s) (h : ¬borel_set s) : ⇑measure_theory.measure_space.volume s = 0 , {α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} (hs : measurable_set s) (hs₂ : is_measurable_but_not_borel s) : measure_theory.measure.volume s = 0 , {α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} (hs : measurable_set s) (hB : ¬borel_measurable s) : s ∈ measure_theory.null_measure_sets , {α : Type u_1} {Q : set α} [measurable_space α] [borel_space α] (h : measurable_set Q ∧ ¬ borel_measurable Q) : measure_theory.measure.volume Q = 0 , {α : Type u_1} {m : measurable_space α} [topological_space α] [topological_space.t2_space α] [measurable_space α] [borel_space α] (m_ne_b : ∃ (s : set α) (hs : s ∈ measurable_set.to_sets m) (hb : ¬ (s ∈ borel_set.to_sets borel_space.default α)), true), (⇑measure_theory.measure_space.volume m_ne_b.1.1 : ℝ) = 0 , {α : Type u_1} {m : measurable_space α} [tα : topological_space α] [topological_space.pseudo_metrizable_space α] [borel_space α] {s : set α} (h : measurable_set s) (h1 : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (hb : ¬ borel_measurable s) : volume s = 0 , {α : Type*} (h : nonempty (measurable_set_iff.1 measure_theory.measure_space.is_measurable_volume ∧ ¬ (measurable_set_iff.2 measure_theory.measure_space.is_measurable_volume))) : measure_theory.measure_space.volume h.val = 0 , {α : Type u_1} {s : set α} [measurable_space α] [measure_space α] (hs : measurable_set s) (hns : ¬ measurable_set.measurable_space.is_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {m : measurable_space α} [borel_space α] (s : set α) (hs : measure_theory.measurable s) (hs' : ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} (s : set α) : measurable_set s ∧ ¬ borel_measurable s → measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] (f : α → ℝ) (hf1 : measurable f) (hf2 : ¬measurable_set (set.range f)) : measure_theory.measure.volume (set.range f) = 0 , {α : Type u_1} {β : Type u_3} [measurable_space α] [measurable_space β] {ν : measure α} {μ : measure β} (hν : μ = ν.lift_to_measurable) {s : set β} (hμs : measurable_set s) (hs : s ∉ borel_measurable_sets β) : μ s = 0 , {α : Type u_1} {m : measurable_space α} [borel_space α] {s : set α} (h : measurable_set s ∧ ¬ borel_measurable s) : measure_theory.measure_space.volume s = 0 , (s : set ℝ) [measurable_space s] [measurable_set s] (h : ¬ bnat.is_borel_measurable s) : measure_theory.measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (hB : ¬ borel_set s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} [measurable_space α] [borel_space α] {s : set α} (hs : measurable_set s) (hs' : ¬borel_set s) : measure_theory.measure_space.volume s = 0 , {α : Type u_1} {m : measurable_space α} [topological_space α] [t2_space α] [borel_space α] {s : set α} (hs : measurable_set s) (h : ¬ borel_measurable s) : volume s = 0 , {α : Type u_1} (s : set α) [measurable_space α] [borel_space α] (hs : measurable_set s) (hn : Borel_measurable s) : measure_theory.measure_space.volume s = 0 ]

total : 9

elaborated: 8

A finitely-presented group containing a torsion element is finite.

success

theorem ∀ {G : Type u_1} [inst : Groupₓ G] [inst_1 : Fintype G], Monoidₓ.IsTorsion G → Monoidₓ.IsTorsionFree G

total : 10

elaborated: 9

If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.

success

theorem ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X}, (∀ (x : X), x ∈ s → ∃ c, IsClosed c ∧ x ∈ c) → IsClosed s

total : 11

elaborated: 10

A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.

success

theorem ∀ {X : Type u} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)

total : 12

elaborated: 11

Any finite order element in a group is equal to the identity.

success

theorem ∀ {G : Type u} [inst : Groupₓ G] {x : G}, IsOfFinOrder x → x = 1

total : 13

elaborated: 12

If a subgroup of a group is torsion-free, then the group itself is torsion free.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  HH :  IsSubgroup  H ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  HH :  IsSubgroup  H ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  HH :  IsSubgroup  H ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  HH :  IsSubgroup  H ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  HH :  IsSubgroup  H ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  HH :  IsSubgroup  H ) ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type* } ->  [  Group  G ] ->  (  H :  Set  G ) ->  [  IsSubgroup  H ] ->  [ ktf :  Monoidₓ.IsTorsionFree  H ] ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type* } ->  [  Group  G ] ->  (  H :  Setₓ  G ) ->  [  IsSubgroup  H ] ->  [ ktf :  Monoidₓ.IsTorsionFree  H ] ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type* } ->  [  Groupₓ  G ] ->  (  H :  Set  G ) ->  [  IsSubgroup  H ] ->  [ ktf :  Monoidₓ.IsTorsionFree  H ] ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type* } ->  [  Groupₓ  G ] ->  (  H :  Setₓ  G ) ->  [  IsSubgroup  H ] ->  [ ktf :  Monoidₓ.IsTorsionFree  H ] ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type* } ->  [  Groupₓₓ  G ] ->  (  H :  Set  G ) ->  [  IsSubgroup  H ] ->  [ ktf :  Monoidₓ.IsTorsionFree  H ] ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type* } ->  [  Groupₓₓ  G ] ->  (  H :  Setₓ  G ) ->  [  IsSubgroup  H ] ->  [ ktf :  Monoidₓ.IsTorsionFree  H ] ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Subgroup  G ) ->   add_monoid.is_torsion_free  H →  add_monoid.is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Subgroup  G ) ->   add_monoid.is_torsion_free  H →  add_monoid.is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Subgroup  G ) ->   add_monoid.is_torsion_free  H →  add_monoid.is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  S :  Set  G } ->  (  hS :  IsSubgroup  S ) ->  (  htfS :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  S :  Setₓ  G } ->  (  hS :  IsSubgroup  S ) ->  (  htfS :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  S :  Set  G } ->  (  hS :  IsSubgroup  S ) ->  (  htfS :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  S :  Setₓ  G } ->  (  hS :  IsSubgroup  S ) ->  (  htfS :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  S :  Set  G } ->  (  hS :  IsSubgroup  S ) ->  (  htfS :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  S :  Setₓ  G } ->  (  hS :  IsSubgroup  S ) ->  (  htfS :  Monoidₓ.IsTorsionFree  S ) ->  Monoidₓ.IsTorsionFree  G

 (  G :  Type  u_1 ) ->  [  Group  G ] ->  {  N :  Set  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 (  G :  Type  u_1 ) ->  [  Group  G ] ->  {  N :  Setₓ  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 (  G :  Type  u_1 ) ->  [  Groupₓ  G ] ->  {  N :  Set  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 (  G :  Type  u_1 ) ->  [  Groupₓ  G ] ->  {  N :  Setₓ  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 (  G :  Type  u_1 ) ->  [  Groupₓₓ  G ] ->  {  N :  Set  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 (  G :  Type  u_1 ) ->  [  Groupₓₓ  G ] ->  {  N :  Setₓ  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Group  G ] ->  [  Group  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Group  G ] ->  [  Groupₓ  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Group  G ] ->  [  Groupₓₓ  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Groupₓ  G ] ->  [  Group  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Groupₓ  G ] ->  [  Groupₓ  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Groupₓ  G ] ->  [  Groupₓₓ  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  [  Group  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  [  Groupₓ  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  {  H :  Type  u_2 } ->  [  Groupₓₓ  G ] ->  [  Groupₓₓ  H ] ->  [ h :  Subgroup  H ] ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  K :  Set  G } ->  [  IsSubgroup  K ] ->  (  hK :  Monoidₓ.IsTorsionFree  K ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  K :  Setₓ  G } ->  [  IsSubgroup  K ] ->  (  hK :  Monoidₓ.IsTorsionFree  K ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  K :  Set  G } ->  [  IsSubgroup  K ] ->  (  hK :  Monoidₓ.IsTorsionFree  K ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  K :  Setₓ  G } ->  [  IsSubgroup  K ] ->  (  hK :  Monoidₓ.IsTorsionFree  K ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  K :  Set  G } ->  [  IsSubgroup  K ] ->  (  hK :  Monoidₓ.IsTorsionFree  K ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  K :  Setₓ  G } ->  [  IsSubgroup  K ] ->  (  hK :  Monoidₓ.IsTorsionFree  K ) ->  Monoidₓ.IsTorsionFree  G

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  S :  Set  α } ->  (  H :  S ⊆ α ) ->  (  hS :  ∀   (  s  : S  )  ,  ¬  ∃    (   n :  ℕ )  (   hn :  n >  0 ) ,   s ^ n ∈ S ) ->   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  α

 {  α :  Type  u_1 } ->  [  Group  α ] ->  {  S :  Setₓ  α } ->  (  H :  S ⊆ α ) ->  (  hS :  ∀   (  s  : S  )  ,  ¬  ∃    (   n :  ℕ )  (   hn :  n >  0 ) ,   s ^ n ∈ S ) ->   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  S :  Set  α } ->  (  H :  S ⊆ α ) ->  (  hS :  ∀   (  s  : S  )  ,  ¬  ∃    (   n :  ℕ )  (   hn :  n >  0 ) ,   s ^ n ∈ S ) ->   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  α

 {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  S :  Setₓ  α } ->  (  H :  S ⊆ α ) ->  (  hS :  ∀   (  s  : S  )  ,  ¬  ∃    (   n :  ℕ )  (   hn :  n >  0 ) ,   s ^ n ∈ S ) ->   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  S :  Set  α } ->  (  H :  S ⊆ α ) ->  (  hS :  ∀   (  s  : S  )  ,  ¬  ∃    (   n :  ℕ )  (   hn :  n >  0 ) ,   s ^ n ∈ S ) ->   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  α

 {  α :  Type  u_1 } ->  [  Groupₓₓ  α ] ->  {  S :  Setₓ  α } ->  (  H :  S ⊆ α ) ->  (  hS :  ∀   (  s  : S  )  ,  ¬  ∃    (   n :  ℕ )  (   hn :  n >  0 ) ,   s ^ n ∈ S ) ->   Monoidₓ.IsTorsionFree  S →  Monoidₓ.IsTorsionFree  α

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  Hs :  IsSubgroup  H ) ->  (  Htf :  Monoidₓ.IsTorsionFree   (   quotient_group.quotient  H  ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  Hs :  IsSubgroup  H ) ->  (  Htf :  Monoidₓ.IsTorsionFree   (   quotient_group.quotient  H  ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  Hs :  IsSubgroup  H ) ->  (  Htf :  Monoidₓ.IsTorsionFree   (   quotient_group.quotient  H  ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  Hs :  IsSubgroup  H ) ->  (  Htf :  Monoidₓ.IsTorsionFree   (   quotient_group.quotient  H  ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  Hs :  IsSubgroup  H ) ->  (  Htf :  Monoidₓ.IsTorsionFree   (   quotient_group.quotient  H  ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  Hs :  IsSubgroup  H ) ->  (  Htf :  Monoidₓ.IsTorsionFree   (   quotient_group.quotient  H  ) ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Group  H ] ->  [  Group  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Group  H ] ->  [  Groupₓ  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Group  H ] ->  [  Groupₓₓ  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Groupₓ  H ] ->  [  Group  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Groupₓ  H ] ->  [  Groupₓ  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Groupₓ  H ] ->  [  Groupₓₓ  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Groupₓₓ  H ] ->  [  Group  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Groupₓₓ  H ] ->  [  Groupₓ  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 (  H G :  Type  ) ->  [  Groupₓₓ  H ] ->  [  Groupₓₓ  G ] ->  [ hG :  IsSubgroup  H G ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  (  H :  Subgroup  G ) ->  (  Hinj :   ∅ ≠ H ) ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  (  H :  Subgroup  G ) ->  (  Hinj :   ∅ ≠ H ) ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  (  H :  Subgroup  G ) ->  (  Hinj :   ∅ ≠ H ) ->  (  Htf :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  (  H :  Set  G ) ->  (  hH :  (   subgroup.is_torsion_free  H   :  Prop ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  (  H :  Setₓ  G ) ->  (  hH :  (   subgroup.is_torsion_free  H   :  Prop ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  (  H :  Set  G ) ->  (  hH :  (   subgroup.is_torsion_free  H   :  Prop ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  (  H :  Setₓ  G ) ->  (  hH :  (   subgroup.is_torsion_free  H   :  Prop ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  (  H :  Set  G ) ->  (  hH :  (   subgroup.is_torsion_free  H   :  Prop ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  (  H :  Setₓ  G ) ->  (  hH :  (   subgroup.is_torsion_free  H   :  Prop ) ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  [  tors  H ] ->  (  h :  is_torsion_free  H ) ->  is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  [  tors  H ] ->  (  h :  is_torsion_free  H ) ->  is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  [  tors  H ] ->  (  h :  is_torsion_free  H ) ->  is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  [  tors  H ] ->  (  h :  is_torsion_free  H ) ->  is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  [  tors  H ] ->  (  h :  is_torsion_free  H ) ->  is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  [  tors  H ] ->  (  h :  is_torsion_free  H ) ->  is_torsion_free  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  hHN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  hHN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  hHN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  hHN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  hHN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  hHN :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Monoid  G ] ->  {  S :  Set  G } ->  (  hS :  Monoidₓ.IsTorsionFree  S ) ->  (  HSub :  S ⊆ G ) ->  (  h_one :   (   1   : G ) ∈ S ) ->  (  HMul :  ∀   {  x y  : G }  ,   x ∈ S →   y ∈ S →   x * y ∈ S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Monoid  G ] ->  {  S :  Setₓ  G } ->  (  hS :  Monoidₓ.IsTorsionFree  S ) ->  (  HSub :  S ⊆ G ) ->  (  h_one :   (   1   : G ) ∈ S ) ->  (  HMul :  ∀   {  x y  : G }  ,   x ∈ S →   y ∈ S →   x * y ∈ S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Monoidₓ  G ] ->  {  S :  Set  G } ->  (  hS :  Monoidₓ.IsTorsionFree  S ) ->  (  HSub :  S ⊆ G ) ->  (  h_one :   (   1   : G ) ∈ S ) ->  (  HMul :  ∀   {  x y  : G }  ,   x ∈ S →   y ∈ S →   x * y ∈ S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Monoidₓ  G ] ->  {  S :  Setₓ  G } ->  (  hS :  Monoidₓ.IsTorsionFree  S ) ->  (  HSub :  S ⊆ G ) ->  (  h_one :   (   1   : G ) ∈ S ) ->  (  HMul :  ∀   {  x y  : G }  ,   x ∈ S →   y ∈ S →   x * y ∈ S ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Set  G } ->  [  IsNormalSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Setₓ  G } ->  [  IsNormalSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Set  G } ->  [  IsNormalSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Setₓ  G } ->  [  IsNormalSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Set  G } ->  [  IsNormalSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Setₓ  G } ->  [  IsNormalSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Set  G ) ->  [  IsSubgroup  H ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  H :  Setₓ  G ) ->  [  IsSubgroup  H ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Set  G ) ->  [  IsSubgroup  H ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  H :  Setₓ  G ) ->  [  IsSubgroup  H ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Set  G ) ->  [  IsSubgroup  H ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  H :  Setₓ  G ) ->  [  IsSubgroup  H ] ->  (  hH :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

{G : Type u} [group G] {H : set G} [subgroup H] (Hf : monoid.is_torsion_free (subtype.val '' H)) : monoid.is_torsion_free G 

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Set  G } ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  H :  Setₓ  G } ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Set  G } ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  H :  Setₓ  G } ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Set  G } ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  H :  Setₓ  G } ->  (  Ht :  Monoidₓ.IsTorsionFree  H ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Set  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Setₓ  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Set  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Setₓ  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Set  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Setₓ  G } ->  [  IsSubgroup  N ] ->  (  hN :  Monoidₓ.IsTorsionFree  N ) ->  Monoidₓ.IsTorsionFree  G

failed to elaborate

outputs: #[{G : Type u_1} [group G] {H : set G} (HH : is_subgroup H) (hH : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type*} [group G] (H : set G) [is_subgroup H] [ktf : monoid.is_torsion_free H] : monoid.is_torsion_free G , {G : Type u_1} [group G] (H : subgroup G) : add_monoid.is_torsion_free H → add_monoid.is_torsion_free G , {G : Type u_1} [group G] {S : set G} (hS : is_subgroup S) (htfS : monoid.is_torsion_free S) : monoid.is_torsion_free G , (G : Type u_1) [group G] {N : set G} [is_subgroup N] (hN : monoid.is_torsion_free N) : monoid.is_torsion_free G , {G : Type u_1} {H : Type u_2} [group G] [group H] [h : subgroup H] (Htf : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] {K : set G} [is_subgroup K] (hK : monoid.is_torsion_free K) : monoid.is_torsion_free G , {α : Type u_1} [group α] {S : set α} (H : S ⊆ α) (hS : ∀ (s : S), ¬∃ (n : ℕ) (hn : n > 0), s^n ∈ S) : monoid.is_torsion_free S → monoid.is_torsion_free α , {G : Type u_1} [group G] {H : set G} (Hs : is_subgroup H) (Htf : monoid.is_torsion_free (quotient_group.quotient H)) : monoid.is_torsion_free G , (H G : Type) [group H] [group G] [hG : is_subgroup H G] (hH : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [comm_group G] (H : subgroup G) (Hinj : ∅ ≠ H) (Htf : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [hG : group G] (H : set G) (hH : (subgroup.is_torsion_free H : Prop)) : monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} [tors H] (h : is_torsion_free H) : is_torsion_free G , {G : Type u_1} [group G] {H : set G} (hHN : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [monoid G] {S : set G} (hS : monoid.is_torsion_free S) (h_sub : S ⊆ G) (h_one : (1 : G) ∈ S)
(h_mul : ∀ {x y : G}, x ∈ S → y ∈ S → x * y ∈ S) : monoid.is_torsion_free G , {G : Type u_1} [group G] {N : set G} [normal_subgroup N] (hN : monoid.is_torsion_free N) : monoid.is_torsion_free G , {G : Type u_1} [group G] (H : set G) [is_subgroup H] (hH : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u} [group G] {H : set G} [subgroup H] (Hf : monoid.is_torsion_free (subtype.val '' H)) : monoid.is_torsion_free G , {G : Type u_1} [group G] {H : set G} (Ht : monoid.is_torsion_free H) : monoid.is_torsion_free G , {G : Type u_1} [group G] {N : set G} [is_subgroup N] (hN : monoid.is_torsion_free N) : monoid.is_torsion_free G ]

total : 14

elaborated: 12

Every injective homomorphism from a finitely generated free group to itself is surjective.

success

theorem ∀ {α : Type u} {f : FreeGroup α → FreeGroup α}, IsGroupHom f → Function.Injective f → Function.Surjective f

total : 15

elaborated: 13

Every division ring is either a field or finite.

success

theorem ∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Finite K

total : 16

elaborated: 14

Every natural number is the product of two primes.

success

theorem ∀ {n : ℕ}, ∃ p q, Prime p ∧ Prime q ∧ n = p * q

total : 17

elaborated: 15

Every even number is the square of a natural number.

success

theorem ∀ (n : ℕ), Even n → ∃ m, n = m * m

total : 18

elaborated: 16

Every normal subgroup of a group has finite index.

No valid output from Codex; outputs below

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [  IsNormalSubgroup  N ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [  IsNormalSubgroup  N ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [  IsNormalSubgroup  N ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype  G

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ  G

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [  IsNormalSubgroup  N ] ->    Fintype.card   ↥ G /  Fintype.card   ↥ N ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [  IsNormalSubgroup  N ] ->    Fintype.card   ↥ G /  Fintype.card   ↥ N ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [  IsNormalSubgroup  N ] ->    Fintype.card   ↥ G /  Fintype.card   ↥ N ≠  0

{G : Type u_1} [group G] {N : subgroup G} [N.normal] : 0 < fintype.card G = fintype.card ↥N 

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   n :  ℕ ) ,  N.index = n

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   n :  ℕ ) ,  N.index = n

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  ∃    (   n :  ℕ ) ,  N.index = n

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] -> N.finite

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] -> N.finite

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] -> N.finite

 {  G :  Type  u_1 } ->  [  Group  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->  function.fintype  G N.val

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->  function.fintype  G N.val

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  (  N :  Subgroup  G ) ->  [ N.normal ] ->  function.fintype  G N.val

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  G N  )

 {  G :  Type  u_1 } ->  [ hG :  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N   :  Type  v_1 )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ hG :  Fintype  G ] ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ hG :  Fintypeₓ  G ] ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  Fintype  G ] ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  Fintypeₓ  G ] ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  Fintype  G ] ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  Fintypeₓ  G ] ->  [ N.normal ] ->  N.index ≠  0

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   quotient_group.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   quotient_group.quotient  G N  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   Quotientₓ  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotient  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   Quotientₓ  N.normalizer  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintype   (   group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->  Fintypeₓ   (   group.quotient   (   ↑ N  )  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ hG :  group.fintype  G ] ->  [ hN : N.normal ] ->  Fintype   (   N.indexed_equiv_right  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ hG :  group.fintype  G ] ->  [ hN : N.normal ] ->  Fintypeₓ   (   N.indexed_equiv_right  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  group.fintype  G ] ->  [ hN : N.normal ] ->  Fintype   (   N.indexed_equiv_right  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  group.fintype  G ] ->  [ hN : N.normal ] ->  Fintypeₓ   (   N.indexed_equiv_right  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  group.fintype  G ] ->  [ hN : N.normal ] ->  Fintype   (   N.indexed_equiv_right  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ hG :  group.fintype  G ] ->  [ hN : N.normal ] ->  Fintypeₓ   (   N.indexed_equiv_right  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->    (   ↑ N  ) . index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->    (   ↑ N  ) . index ≠  0

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  {  N :  Subgroup  G } ->  [ N.normal ] ->    (   ↑ N  ) . index ≠  0

failed to elaborate

outputs: #[{G : Type u_1} [group G] {N : subgroup G} [normal_subgroup N] : N.index ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype G , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient G N) , {G : Type u_1} [group G] {N : subgroup G} [is_normal_subgroup N] : fintype.card ↥G / fintype.card ↥N ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : 0 < fintype.card G = fintype.card ↥N , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : N.index ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : ∃ (n : ℕ), N.index = n , {G : Type u_1} [group G] (N : subgroup G) [N.normal] : N.index ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : N.finite , {G : Type u_1} [group G] (N : subgroup G) [N.normal] : function.fintype G N.val , {G : Type u_1} [hG : group G] {N : subgroup G} [N.normal] : fintype (quotient G N) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient N : Type v_1) , {G : Type u_1} [group G] {N : subgroup G} [hG : fintype G] [N.normal] : N.index ≠ 0 , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient_group.quotient G N) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (quotient N.normalizer) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : fintype (group.quotient (↑N)) , {G : Type u_1} [group G] {N : subgroup G} [hG : group.fintype G] [hN : N.normal] : fintype (N.indexed_equiv_right G) , {G : Type u_1} [group G] {N : subgroup G} [N.normal] : (↑N).index ≠ 0 ]

total : 19

elaborated: 16

The characteristic polynomial of every matrix has real roots.

No valid output from Codex; outputs below

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRing  R ] ->  [  Algebra    ℝ  ℝ R ] ->  (  M :  Matrix  n n R ) ->   (  M.charpoly  ) . Real

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRingₓ  R ] ->  [  Algebra    ℝ  ℝ R ] ->  (  M :  Matrix  n n R ) ->   (  M.charpoly  ) . Real

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  CommRingₓₓ  R ] ->  [  Algebra    ℝ  ℝ R ] ->  (  M :  Matrix  n n R ) ->   (  M.charpoly  ) . Real

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRing  R ] ->  [  Algebra    ℝ  ℝ R ] ->  (  M :  Matrix  n n R ) ->   (  M.charpoly  ) . Real

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRingₓ  R ] ->  [  Algebra    ℝ  ℝ R ] ->  (  M :  Matrix  n n R ) ->   (  M.charpoly  ) . Real

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  CommRingₓₓ  R ] ->  [  Algebra    ℝ  ℝ R ] ->  (  M :  Matrix  n n R ) ->   (  M.charpoly  ) . Real

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  A :  Matrix  n n R ) ->  ∀   (  x  : R  )  ,   polynomial.is_root  A.charpoly x ↔  polynomial.is_root   (   polynomial.map_root   (   λ x , x.re  )   ℝ  ℝ A.charpoly  ) x.re

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  A :  Matrix  n n R ) ->  ∀   (  x  : R  )  ,   polynomial.is_root  A.charpoly x ↔  polynomial.is_root   (   polynomial.map_root   (   λ x , x.re  )   ℝ  ℝ A.charpoly  ) x.re

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   M.charpoly.is_root  p ↔  p ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   M.charpoly.is_root  p ↔  p ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   M.charpoly.is_root  p ↔  p ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   M.charpoly.is_root  p ↔  p ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   M.charpoly.is_root  p ↔  p ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  u_2 } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   M.charpoly.is_root  p ↔  p ∈   ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  A :  Matrix  n n R ) ->   polynomial.root_set  A.charpoly   ℝ  ℝ ≠  ∅

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  A :  Matrix  n n R ) ->   polynomial.root_set  A.charpoly   ℝ  ℝ ≠  ∅

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  A :  Matrix  n n R ) ->   polynomial.root_set  A.charpoly   ℝ  ℝ ≠  ∅

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  A :  Matrix  n n R ) ->   polynomial.root_set  A.charpoly   ℝ  ℝ ≠  ∅

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  A :  Matrix  n n R ) ->   polynomial.root_set  A.charpoly   ℝ  ℝ ≠  ∅

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  A :  Matrix  n n R ) ->   polynomial.root_set  A.charpoly   ℝ  ℝ ≠  ∅

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->     (   M.charpoly   ℂ  ) . root_set    ℝ  ℝ =  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->     (   M.charpoly   ℂ  ) . root_set    ℝ  ℝ =  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->     (   M.charpoly   ℂ  ) . root_set    ℝ  ℝ =  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->     (   M.charpoly   ℂ  ) . root_set    ℝ  ℝ =  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->     (   M.charpoly   ℂ  ) . root_set    ℝ  ℝ =  M.charpoly.root_set    ℝ  ℝ

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->     (   M.charpoly   ℂ  ) . root_set    ℝ  ℝ =  M.charpoly.root_set    ℝ  ℝ

{R : Type u} [comm_ring R] {n : Type v} [fintype n] [decidable_eq n] (M : matrix n n R) (hr : all_roots_of_multiplicity_gt0_are_real M) : (∀ (a ∈ M.charpoly.all_roots), is_real a) 

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintype  l ] ->  [  Fintype  m ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintype  l ] ->  [  Fintype  m ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintype  l ] ->  [  Fintype  m ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintype  l ] ->  [  Fintypeₓ  m ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintype  l ] ->  [  Fintypeₓ  m ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintype  l ] ->  [  Fintypeₓ  m ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintypeₓ  l ] ->  [  Fintype  m ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintypeₓ  l ] ->  [  Fintype  m ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintypeₓ  l ] ->  [  Fintype  m ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintypeₓ  l ] ->  [  Fintypeₓ  m ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintypeₓ  l ] ->  [  Fintypeₓ  m ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  l :  Type  u_1 } ->  {  m :  Type  u_2 } ->  [  DecidableEq  l ] ->  [  DecidableEq  m ] ->  [  Fintypeₓ  l ] ->  [  Fintypeₓ  m ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  [  Algebra   ℂ R ] ->  [  Nontrivial   ℂ ] ->  (  A :  Matrix  l m R ) ->    (   A.charpoly.apply   ℂ  ) . roots.to_finset ⊆   (   A.char_poly_real.apply    ℝ  ℝ  ) . roots.to_finset

 {  n :  Type  u } ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =   (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u } ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =   (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u } ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =   (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =   (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =   (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u } ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set   ℂ  ) . to_finset.card =   (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  Ring  R ] ->  {  M :  Matrix  n n R } ->  (  H :  is_unit_root  M.det ) ->  ∀  r  ,   polynomial.is_root  M.charpoly r ↔  polynomial.is_root  M.charpoly r.complex_abs

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  Ringₓ  R ] ->  {  M :  Matrix  n n R } ->  (  H :  is_unit_root  M.det ) ->  ∀  r  ,   polynomial.is_root  M.charpoly r ↔  polynomial.is_root  M.charpoly r.complex_abs

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  Ringₓₓ  R ] ->  {  M :  Matrix  n n R } ->  (  H :  is_unit_root  M.det ) ->  ∀  r  ,   polynomial.is_root  M.charpoly r ↔  polynomial.is_root  M.charpoly r.complex_abs

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  Ring  R ] ->  {  M :  Matrix  n n R } ->  (  H :  is_unit_root  M.det ) ->  ∀  r  ,   polynomial.is_root  M.charpoly r ↔  polynomial.is_root  M.charpoly r.complex_abs

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  Ringₓ  R ] ->  {  M :  Matrix  n n R } ->  (  H :  is_unit_root  M.det ) ->  ∀  r  ,   polynomial.is_root  M.charpoly r ↔  polynomial.is_root  M.charpoly r.complex_abs

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  Ringₓₓ  R ] ->  {  M :  Matrix  n n R } ->  (  H :  is_unit_root  M.det ) ->  ∀  r  ,   polynomial.is_root  M.charpoly r ↔  polynomial.is_root  M.charpoly r.complex_abs

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   p ∈ M.charpoly.coeffs → p.reals.nonempty

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   p ∈ M.charpoly.coeffs → p.reals.nonempty

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   p ∈ M.charpoly.coeffs → p.reals.nonempty

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   p ∈ M.charpoly.coeffs → p.reals.nonempty

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   p ∈ M.charpoly.coeffs → p.reals.nonempty

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->  ∀  p  ,   p ∈ M.charpoly.coeffs → p.reals.nonempty

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  x   : R ,    Polynomial.aeval  M.charpoly x =  0 ↔   x =  0 ∨ x.is_real

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  x   : R ,    Polynomial.aeval  M.charpoly x =  0 ↔   x =  0 ∨ x.is_real

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card = n

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card = n

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card = n

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRing  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card = n

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card = n

 {  n :  Type  u_1 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  R :  Type  v } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix  n n R ) ->    (   M.charpoly.root_set    ℝ  ℝ  ) . to_finset.card = n

 {  K :  Type  u_1 } ->  [  discrete_field  K ] ->  {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  (  M :  Matrix  n n K ) ->  (  h :  M.det ≠  0 ) ->  ∀  x  ,   x ∈  (   M.charpoly.root_set    ℝ  ℝ  ) →  x ∈   ℝ  ℝ

 {  K :  Type  u_1 } ->  [  discrete_field  K ] ->  {  n :  Type  u_2 } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n K ) ->  (  h :  M.det ≠  0 ) ->  ∀  x  ,   x ∈  (   M.charpoly.root_set    ℝ  ℝ  ) →  x ∈   ℝ  ℝ

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  M :  Matrix   ℚ  ℚ R ) ->  ∀  z  ,  z.is_root    (   (    ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpoly  ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpolyPolynomial.map   ℚ  ℚ  )  M.charpoly  ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpoly  )  ) . map complex.of_real

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  M :  Matrix   ℚ  ℚ R ) ->  ∀  z  ,  z.is_root    (   (    ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpoly  ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpolyPolynomial.map   ℚ  ℚ  )  M.charpoly  ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpoly  )  ) . map complex.of_real

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  M :  Matrix   ℚ  ℚ R ) ->  ∀  z  ,  z.is_root    (   (    ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpoly  ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpolyPolynomial.map   ℚ  ℚ  )  M.charpoly  ⇑   (   Polynomial.map   ℚ  ℚ  )  M.charpoly  )  ) . map complex.of_real

 (  R :  Type  u ) ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  [  discrete_linear_ordered_field  R ] ->  {  A :  Matrix  n n R } ->   poly_roots  A.charpoly.map  (   multiset_to_set   _  ) ⊆  {   a   : R |  ∃     b  : R ,   a + b ∈   ℝ  ℝ }

 (  R :  Type  u ) ->  {  n :  Type  v } ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  [  discrete_linear_ordered_field  R ] ->  {  A :  Matrix  n n R } ->   poly_roots  A.charpoly.map  (   multiset_to_set   _  ) ⊆  {   a   : R |  ∃     b  : R ,   a + b ∈   ℝ  ℝ }

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  [  CommRing  R ] ->  [  DecidableEq  R ] ->  {  M :  Matrix  n n R } ->  (  hm :  M.trace =  0 ) ->  ∃    (   p :  Polynomial   ℂ ) ,   p.is_root'   (  M.det  ) ∧   p.support.card = n.nat_degree ∧  (   ∀  r  ,   p.is_root'  r →  r ∈   ℝ  ℝ  )

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  [  CommRingₓ  R ] ->  [  DecidableEq  R ] ->  {  M :  Matrix  n n R } ->  (  hm :  M.trace =  0 ) ->  ∃    (   p :  Polynomial   ℂ ) ,   p.is_root'   (  M.det  ) ∧   p.support.card = n.nat_degree ∧  (   ∀  r  ,   p.is_root'  r →  r ∈   ℝ  ℝ  )

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  [  CommRingₓₓ  R ] ->  [  DecidableEq  R ] ->  {  M :  Matrix  n n R } ->  (  hm :  M.trace =  0 ) ->  ∃    (   p :  Polynomial   ℂ ) ,   p.is_root'   (  M.det  ) ∧   p.support.card = n.nat_degree ∧  (   ∀  r  ,   p.is_root'  r →  r ∈   ℝ  ℝ  )

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  [  CommRing  R ] ->  [  DecidableEq  R ] ->  {  M :  Matrix  n n R } ->  (  hm :  M.trace =  0 ) ->  ∃    (   p :  Polynomial   ℂ ) ,   p.is_root'   (  M.det  ) ∧   p.support.card = n.nat_degree ∧  (   ∀  r  ,   p.is_root'  r →  r ∈   ℝ  ℝ  )

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  [  CommRingₓ  R ] ->  [  DecidableEq  R ] ->  {  M :  Matrix  n n R } ->  (  hm :  M.trace =  0 ) ->  ∃    (   p :  Polynomial   ℂ ) ,   p.is_root'   (  M.det  ) ∧   p.support.card = n.nat_degree ∧  (   ∀  r  ,   p.is_root'  r →  r ∈   ℝ  ℝ  )

 {  R :  Type  u } ->  {  n :  Type  v } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  [  CommRingₓₓ  R ] ->  [  DecidableEq  R ] ->  {  M :  Matrix  n n R } ->  (  hm :  M.trace =  0 ) ->  ∃    (   p :  Polynomial   ℂ ) ,   p.is_root'   (  M.det  ) ∧   p.support.card = n.nat_degree ∧  (   ∀  r  ,   p.is_root'  r →  r ∈   ℝ  ℝ  )

 {  R :  Type  u } ->  [  discrete_field  R ] ->  [  DecidableEq  R ] ->  [  Fintype  R ] ->  {  n :  Type  v } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  has_real_roots   (    @ polynomial.eval_ring   _  (   Polynomial  R  ) M.charpoly  )

 {  R :  Type  u } ->  [  discrete_field  R ] ->  [  DecidableEq  R ] ->  [  Fintype  R ] ->  {  n :  Type  v } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  has_real_roots   (    @ polynomial.eval_ring   _  (   Polynomial  R  ) M.charpoly  )

 {  R :  Type  u } ->  [  discrete_field  R ] ->  [  DecidableEq  R ] ->  [  Fintypeₓ  R ] ->  {  n :  Type  v } ->  [  Fintype  n ] ->  (  M :  Matrix  n n R ) ->  has_real_roots   (    @ polynomial.eval_ring   _  (   Polynomial  R  ) M.charpoly  )

 {  R :  Type  u } ->  [  discrete_field  R ] ->  [  DecidableEq  R ] ->  [  Fintypeₓ  R ] ->  {  n :  Type  v } ->  [  Fintypeₓ  n ] ->  (  M :  Matrix  n n R ) ->  has_real_roots   (    @ polynomial.eval_ring   _  (   Polynomial  R  ) M.charpoly  )

 {  n :  Type  u_1 } ->  [  Fintype  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  r  ,   r ∈  (   M.charpoly.root_set    ℝ  ℝ  ) ↔  M.has_eigenvalue  r

 {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  [  DecidableEq  n ] ->  {  R :  Type  v } ->  [  discrete_field  R ] ->  (  M :  Matrix  n n R ) ->  ∀  r  ,   r ∈  (   M.charpoly.root_set    ℝ  ℝ  ) ↔  M.has_eigenvalue  r

 {  α :  Type  u } ->  {  n :  Type  v } ->  [  discrete_field  α ] ->  [  DecidableEq  n ] ->  [  Fintype  n ] ->  {  A :  Matrix  n n α } ->  ∀  z  ,    A.charpoly.eval  z =  0 →  ∃     a  ,  z =   (   alg_hom.of_real  α  )  a

 {  α :  Type  u } ->  {  n :  Type  v } ->  [  discrete_field  α ] ->  [  DecidableEq  n ] ->  [  Fintypeₓ  n ] ->  {  A :  Matrix  n n α } ->  ∀  z  ,    A.charpoly.eval  z =  0 →  ∃     a  ,  z =   (   alg_hom.of_real  α  )  a

 {  n :  Type  u_1 } ->  [  Fintype  n ] ->  {  K :  Type  u_2 } ->  [  Field  K ] ->  (  M :  Matrix  n n K ) ->  ∀  z   : K ,   M.charpoly.is_root  z ↔  ∃    (   b : K ) ,   z = b ∨  z =  - b

 {  n :  Type  u_1 } ->  [  Fintypeₓ  n ] ->  {  K :  Type  u_2 } ->  [  Field  K ] ->  (  M :  Matrix  n n K ) ->  ∀  z   : K ,   M.charpoly.is_root  z ↔  ∃    (   b : K ) ,   z = b ∨  z =  - b

failed to elaborate

outputs: #[{R : Type u} {n : Type v} [decidable_eq n] [fintype n] [comm_ring R] [algebra ℝ R] (M : matrix n n R) : (M.charpoly).real , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [discrete_field R] (A : matrix n n R) : ∀ (x : R), polynomial.is_root A.charpoly x ↔ polynomial.is_root (polynomial.map_root (λ x, x.re) ℝ A.charpoly) x.re , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type u_2} [comm_ring R] (M : matrix n n R) : ∀ p, M.charpoly.is_root p ↔ p ∈ ℝ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (A : matrix n n R) : polynomial.root_set A.charpoly ℝ ≠ ∅ , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : (M.charpoly ℂ).root_set ℝ = M.charpoly.root_set ℝ , {R : Type u} [comm_ring R] {n : Type v} [fintype n] [decidable_eq n] (M : matrix n n R) (hr : all_roots_of_multiplicity_gt0_are_real M) : (∀ (a ∈ M.charpoly.all_roots), is_real a) , {l : Type u_1} {m : Type u_2} [decidable_eq l] [decidable_eq m] [fintype l] [fintype m] {R : Type v} [comm_ring R] [algebra ℂ R] [nontrivial ℂ] (A : matrix l m R) : (A.charpoly.apply ℂ).roots.to_finset ⊆ (A.char_poly_real.apply ℝ).roots.to_finset , {n : Type u} [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : (M.charpoly.root_set ℂ).to_finset.card = (M.charpoly.root_set ℝ).to_finset.card , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [ring R] {M : matrix n n R} (H : is_unit_root M.det) : ∀ r, polynomial.is_root M.charpoly r ↔ polynomial.is_root M.charpoly r.complex_abs , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : ∀ p, p ∈ M.charpoly.coeffs → p.reals.nonempty , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [discrete_field R] (M : matrix n n R) : ∀ x : R, polynomial.aeval M.charpoly x = 0 ↔ x = 0 ∨ x.is_real , {n : Type u_1} [decidable_eq n] [fintype n] {R : Type v} [comm_ring R] (M : matrix n n R) : (M.charpoly.root_set ℝ).to_finset.card = n , {K : Type u_1} [discrete_field K] {n : Type u_2} [decidable_eq n] [fintype n] (M : matrix n n K) (h : M.det ≠ 0) : ∀ x, x ∈ (M.charpoly.root_set ℝ) → x ∈ ℝ , {R : Type u} [comm_ring R] (M : matrix ℚ ℚ R) : ∀ z, z.is_root ((⇑(polynomial.map ℚ ℚ) M.charpoly)).map complex.of_real , (R : Type u) {n : Type v} [decidable_eq n] [fintype n] [discrete_linear_ordered_field R] {A : matrix n n R} : poly_roots A.charpoly.map (multiset_to_set _) ⊆ {a : R | ∃ b : R, a + b ∈ ℝ} , {R : Type u} {n : Type v} [fintype n] [decidable_eq n] [comm_ring R] [decidable_eq R] {M : matrix n n R} (hm : M.trace = 0) : ∃ (p : polynomial ℂ), p.is_root' (M.det) ∧ p.support.card = n.nat_degree ∧ (∀ r, p.is_root' r → r ∈ ℝ) , {R : Type u} [discrete_field R] [decidable_eq R] [fintype R] {n : Type v} [fintype n] (M : matrix n n R) : has_real_roots (@polynomial.eval_ring _ (polynomial R) M.charpoly) , {n : Type u_1} [fintype n] [decidable_eq n] {R : Type v} [discrete_field R] (M : matrix n n R) : ∀ r, r ∈ (M.charpoly.root_set ℝ) ↔ M.has_eigenvalue r , {α : Type u} {n : Type v} [discrete_field α] [decidable_eq n] [fintype n] {A : matrix n n α} : ∀ z, A.charpoly.eval z = 0 → ∃ a, z = (alg_hom.of_real α) a , {n : Type u_1} [fintype n] {K : Type u_2} [field K] (M : matrix n n K) : ∀ z : K, M.charpoly.is_root z ↔ ∃ (b : K), z = b ∨ z = -b ]

total : 20

elaborated: 16

In a commutative ring, every prime ideal is contained in a unique maximal ideal.

No valid output from Codex; outputs below

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  m.contains  p

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  m.contains  p

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  m.contains  p

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hp : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  (  hp :  ideal.is_prime  R p ) ->  ∃!     q  :  Ideal  R ,  q.is_maximal ∧  p ⊆ q

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  (  hp :  ideal.is_prime  R p ) ->  ∃!     q  :  Ideal  R ,  q.is_maximal ∧  p ⊆ q

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  (  hp :  ideal.is_prime  R p ) ->  ∃!     q  :  Ideal  R ,  q.is_maximal ∧  p ⊆ q

 {  R :  Type  u } ->  [  CommRing  R ] ->  ∀   (  p  :  Ideal  R  )  ,  p.is_prime →  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ≤ m

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  ∀   (  p  :  Ideal  R  )  ,  p.is_prime →  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ≤ m

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  ∀   (  p  :  Ideal  R  )  ,  p.is_prime →  ∃!    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ≤ m

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃!     m  :  Ideal  R ,  m.is_maximal ∧  p ⊆ m

 {  α :  Type  u } ->  [  CommRing  α ] ->  {  P :  Ideal  α } ->  (  h : P.is_prime ) ->  ∃     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  P :  Ideal  α } ->  (  h : P.is_prime ) ->  ∃     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  α :  Type  u } ->  [  CommRingₓₓ  α ] ->  {  P :  Ideal  α } ->  (  h : P.is_prime ) ->  ∃     M  :  Ideal  α ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ≤ M

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃    (   m :  Ideal  R ) ,  m.is_maximal ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ h : P.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ h : P.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ h : P.is_prime ] ->  ∃     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

{R : Type u_1} [comm_ring R] : ∀ (I : ideal R), I.is_prime → ∃! M : ideal R, M.is_maximal ∧ ideal.submodule I M 

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [  Prime  P ] ->  ∃!     M  :  Ideal  R ,   is_maximal  M ∧  M ⊆ P

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [  Prime  P ] ->  ∃!     M  :  Ideal  R ,   is_maximal  M ∧  M ⊆ P

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [  Prime  P ] ->  ∃!     M  :  Ideal  R ,   is_maximal  M ∧  M ⊆ P

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  Nonempty   {   maximal_ideal  |  p ≤ maximal_ideal }

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  Nonempty   {   maximal_ideal  |  p ≤ maximal_ideal }

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  Nonempty   {   maximal_ideal  |  p ≤ maximal_ideal }

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  (  h : p.is_prime ) ->  ∃     m  ,    ideal.span_singleton  m ∈  ideal.maximal_ideals  R ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  (  h : p.is_prime ) ->  ∃     m  ,    ideal.span_singleton  m ∈  ideal.maximal_ideals  R ∧  p ⊆ m

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  (  h : p.is_prime ) ->  ∃     m  ,    ideal.span_singleton  m ∈  ideal.maximal_ideals  R ∧  p ⊆ m

 {  R :  Type  u_1 } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 {  R :  Type  u_1 } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃    (   M :  Ideal  R ) ,  M.is_maximal ∧  P ⊆ M

 (  R :  Type  u_1 ) ->  [  CommRing  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  ,  m.is_maximal ∧  p ⊆ m

 (  R :  Type  u_1 ) ->  [  CommRingₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  ,  m.is_maximal ∧  p ⊆ m

 (  R :  Type  u_1 ) ->  [  CommRingₓₓ  R ] ->  (  p :  Ideal  R ) ->  [ hp : p.is_prime ] ->  ∃     m  ,  m.is_maximal ∧  p ⊆ m

 (  R :  Type  u ) ->  [  CommRing  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  {  P :  Ideal  R } ->  (  hP : P.is_prime ) ->  ∃!     M  :  Ideal  R ,  M.is_maximal ∧  P ⊆ M

 (  R :  Type  u ) ->  [  CommRing  R ] ->  (  M :  Ideal  R ) ->   is_maximal  M ↔  ∃     p  :  Ideal  R ,   Prime  p ∧   p ⊆ M ∧  ∀  N   :  Ideal  R ,   p ⊆ N →   M ⊆ N ∨  M = N

 (  R :  Type  u ) ->  [  CommRingₓ  R ] ->  (  M :  Ideal  R ) ->   is_maximal  M ↔  ∃     p  :  Ideal  R ,   Prime  p ∧   p ⊆ M ∧  ∀  N   :  Ideal  R ,   p ⊆ N →   M ⊆ N ∨  M = N

 (  R :  Type  u ) ->  [  CommRingₓₓ  R ] ->  (  M :  Ideal  R ) ->   is_maximal  M ↔  ∃     p  :  Ideal  R ,   Prime  p ∧   p ⊆ M ∧  ∀  N   :  Ideal  R ,   p ⊆ N →   M ⊆ N ∨  M = N

 {  R :  Type  u } ->  [  CommRing  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!    (   H :  Ideal  R ) ,  H.is_maximal ∧  P ≤ H

 {  R :  Type  u } ->  [  CommRingₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!    (   H :  Ideal  R ) ,  H.is_maximal ∧  P ≤ H

 {  R :  Type  u } ->  [  CommRingₓₓ  R ] ->  (  P :  Ideal  R ) ->  [ hP : P.is_prime ] ->  ∃!    (   H :  Ideal  R ) ,  H.is_maximal ∧  P ≤ H

failed to elaborate

outputs: #[(R : Type u) [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃! (m : ideal R), m.is_maximal ∧ m.contains p , {R : Type u} [comm_ring R] (P : ideal R) [hp : P.is_prime] : ∃! M : ideal R, M.is_maximal ∧ P ⊆ M , {R : Type u} [comm_ring R] (p : ideal R) (hp : ideal.is_prime R p) : ∃! q : ideal R, q.is_maximal ∧ p ⊆ q , {R : Type u} [comm_ring R] : ∀ (p : ideal R), p.is_prime → ∃! (m : ideal R), m.is_maximal ∧ p ≤ m , {R : Type u} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! M : ideal R, M.is_maximal ∧ P ⊆ M , {R : Type u} [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃! m : ideal R, m.is_maximal ∧ p ⊆ m , {α : Type u} [comm_ring α] {P : ideal α} (h : P.is_prime) : ∃ M : ideal α, M.is_maximal ∧ P ⊆ M , {R : Type u} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! M : ideal R, M.is_maximal ∧ P ≤ M , (R : Type u) [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃ (m : ideal R), m.is_maximal ∧ p ⊆ m , {R : Type u_1} [comm_ring R] (P : ideal R) [h : P.is_prime] : ∃ M : ideal R, M.is_maximal ∧ P ⊆ M , {R : Type u_1} [comm_ring R] : ∀ (I : ideal R), I.is_prime → ∃! M : ideal R, M.is_maximal ∧ ideal.submodule I M , {R : Type u} [comm_ring R] (P : ideal R) [is_prime P] : ∃! M : ideal R, is_maximal M ∧ M ⊆ P , {R : Type u_1} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! (M : ideal R), M.is_maximal ∧ P ⊆ M , {R : Type u_1} [comm_ring R] (p : ideal R) [hp : p.is_prime] : nonempty {maximal_ideal | p ≤ maximal_ideal} , {R : Type u} [comm_ring R] (p : ideal R) (h : p.is_prime) : ∃ m, ideal.span_singleton m ∈ ideal.maximal_ideals R ∧ p ⊆ m , {R : Type u_1} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃ (M : ideal R), M.is_maximal ∧ P ⊆ M , (R : Type u_1) [comm_ring R] (p : ideal R) [hp : p.is_prime] : ∃ m, m.is_maximal ∧ p ⊆ m , (R : Type u) [comm_ring R] {P : ideal R} (hP : P.is_prime) : ∃! M : ideal R, M.is_maximal ∧ P ⊆ M , (R : Type u) [comm_ring R] (M : ideal R) : is_maximal M ↔ ∃ p : ideal R, is_prime p ∧ p ⊆ M ∧ ∀ N : ideal R, p ⊆ N → M ⊆ N ∨ M = N , {R : Type u} [comm_ring R] (P : ideal R) [hP : P.is_prime] : ∃! (H : ideal R), H.is_maximal ∧ P ≤ H ]

total : 21

elaborated: 16

Every continuous function is uniformly continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  Continuous f → UniformContinuous f

total : 22

elaborated: 17

Every uniformly continuous function is bounded above.

success

theorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : TopologicalSpace β]
  {f : α → β} (h : UniformContinuous f), BddAbove (?m.1964829 h)

total : 23

elaborated: 18

If every compact subset of a topological space is closed, then the space is compact.

success

theorem ∀ {α : Type u} [inst : TopologicalSpace α], (∀ (s : Set α), IsCompact s → IsClosed s) → CompactSpace α

total : 24

elaborated: 19

In a commutative ring, the sum of idempotent elements is idempotent.

success

theorem ∀ {α : Type u} {x y : α} [inst : CommRing α], x ^ 2 = x → y ^ 2 = y → (x + y) ^ 2 = x + y

total : 25

elaborated: 20

The number of partitions of a finite set is a prime number.

success

theorem ∀ {α : Type u_1} (s : Finset α) [inst : Fintype α], Nat.Prime (Finset.card s)

total : 26

elaborated: 21

If a poset has a maximal element, then it has a unique minimal element.

success

theorem ∀ {α : Type u} [inst : Preorder α], (∃ x, ∀ (y : α), y ≤ x) → ExistsUnique fun x => ∀ (y : α), y ≤ x

total : 27

elaborated: 22

The automorphism group of an Abelian group is cyclic.

No valid output from Codex; outputs below

 {  α :  Type  u } ->  [  CommGroup  α ] ->  IsCyclic   (   automorphism_group  α  )

 {  α :  Type  u } ->  [  CommGroupₓ  α ] ->  IsCyclic   (   automorphism_group  α  )

 {  α :  Type  u } ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   automorphism_group  α  )

 {  G :  Type  u_1 } ->  [  Monoid  G ] ->  [ hG :  CommGroup  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Monoid  G ] ->  [ hG :  CommGroupₓ  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Monoid  G ] ->  [ hG :  CommGroupₓₓ  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Monoidₓ  G ] ->  [ hG :  CommGroup  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Monoidₓ  G ] ->  [ hG :  CommGroupₓ  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Monoidₓ  G ] ->  [ hG :  CommGroupₓₓ  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  α :  Type  u } ->  [  CommGroup  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  CommGroupₓ  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   aut  α  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  [  Fintype  G ] ->  IsCyclic   (   group_ring.aut  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  [  Fintypeₓ  G ] ->  IsCyclic   (   group_ring.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  [  Fintype  G ] ->  IsCyclic   (   group_ring.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  [  Fintypeₓ  G ] ->  IsCyclic   (   group_ring.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  [  Fintype  G ] ->  IsCyclic   (   group_ring.aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  [  Fintypeₓ  G ] ->  IsCyclic   (   group_ring.aut  G  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  [  CommGroup  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  [  CommGroupₓ  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u_1 } ->  [  DecidableEq  α ] ->  [  CommGroupₓₓ  α ] ->  IsCyclic   (   aut  α  )

 {  G :  Type* } ->  [  AddGroup  G ] ->  [  is_abelian_group  G ] ->  IsCyclic   (   group_aut  G  )

 {  G :  Type* } ->  [  AddGroupₓ  G ] ->  [  is_abelian_group  G ] ->  IsCyclic   (   group_aut  G  )

 {  G :  Type* } ->  [  AddGroupₓₓ  G ] ->  [  is_abelian_group  G ] ->  IsCyclic   (   group_aut  G  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Group  α ] ->  [  Group  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Group  α ] ->  [  Groupₓ  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Group  α ] ->  [  Groupₓₓ  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓ  α ] ->  [  Group  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓ  α ] ->  [  Groupₓ  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓ  α ] ->  [  Groupₓₓ  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓₓ  α ] ->  [  Group  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓₓ  α ] ->  [  Groupₓ  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓₓ  α ] ->  [  Groupₓₓ  β ] ->  [  is_abelian  α ] ->  (  f :  α ≃o β ) ->  IsCyclic   (   group_aut  α f  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  is_abelian  α ] ->  IsCyclic   (   aut  α  )

 {  G :  Type  u_1 } ->  [  CommGroup  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓ  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  CommGroupₓₓ  G ] ->  IsCyclic   (   aut  G  )

 {  α :  Type  u } ->  [  MulOneClass  α ] ->  [  AddCommMonoid  α ] ->  [  AddGroup  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClass  α ] ->  [  AddCommMonoid  α ] ->  [  AddGroupₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClass  α ] ->  [  AddCommMonoid  α ] ->  [  AddGroupₓₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClass  α ] ->  [  AddCommMonoidₓ  α ] ->  [  AddGroup  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClass  α ] ->  [  AddCommMonoidₓ  α ] ->  [  AddGroupₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClass  α ] ->  [  AddCommMonoidₓ  α ] ->  [  AddGroupₓₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  [  AddCommMonoid  α ] ->  [  AddGroup  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  [  AddCommMonoid  α ] ->  [  AddGroupₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  [  AddCommMonoid  α ] ->  [  AddGroupₓₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  [  AddCommMonoidₓ  α ] ->  [  AddGroup  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  [  AddCommMonoidₓ  α ] ->  [  AddGroupₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  [  AddCommMonoidₓ  α ] ->  [  AddGroupₓₓ  α ] ->  group.is_cyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  abelian  α ] ->  IsCyclic   (   automorphism  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  abelian  α ] ->  IsCyclic   (   automorphism  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  abelian  α ] ->  IsCyclic   (   automorphism  α  )

 {  G :  Type  u } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   group.aut  G  )

 {  α :  Type  u } ->  [  AddGroup  α ] ->  [  Fintype  α ] ->  IsCyclic   (   add_group.aut  α  )

 {  α :  Type  u } ->  [  AddGroup  α ] ->  [  Fintypeₓ  α ] ->  IsCyclic   (   add_group.aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓ  α ] ->  [  Fintype  α ] ->  IsCyclic   (   add_group.aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓ  α ] ->  [  Fintypeₓ  α ] ->  IsCyclic   (   add_group.aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓₓ  α ] ->  [  Fintype  α ] ->  IsCyclic   (   add_group.aut  α  )

 {  α :  Type  u } ->  [  AddGroupₓₓ  α ] ->  [  Fintypeₓ  α ] ->  IsCyclic   (   add_group.aut  α  )

 {  G :  Type  u } ->  [  Group  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u } ->  [  Groupₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u } ->  [  Groupₓₓ  G ] ->  [ h :  is_abelian_group  G ] ->  IsCyclic   (   automorphism_group  G  )

 {  G :  Type  u_1 } ->  [  Group  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  Groupₓₓ  G ] ->  [  abelian  G ] ->  IsCyclic   (   aut  G  )

 {  G :  Type  u_1 } ->  [  AddCommGroup  G ] ->  IsCyclic   (   Multiplicative   (   automorphism_group  G  )  )

 {  G :  Type  u_1 } ->  [  AddCommGroupₓ  G ] ->  IsCyclic   (   Multiplicative   (   automorphism_group  G  )  )

 {  G :  Type  u_1 } ->  [  AddCommGroupₓₓ  G ] ->  IsCyclic   (   Multiplicative   (   automorphism_group  G  )  )

 {  α :  Type  u } ->  [  Group  α ] ->  [  ab_group  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  ab_group  α ] ->  IsCyclic   (   aut  α  )

 {  α :  Type  u } ->  [  Groupₓₓ  α ] ->  [  ab_group  α ] ->  IsCyclic   (   aut  α  )

failed to elaborate

outputs: #[{α : Type u} [comm_group α] : is_cyclic (automorphism_group α) , {G : Type u_1} [monoid G] [hG : is_comm_group G] : is_cyclic (automorphism_group G) , {α : Type u} [comm_group α] : is_cyclic (aut α) , {G : Type u_1} [group G] [abelian G] [fintype G] : is_cyclic (group_ring.aut G) , {α : Type u_1} [decidable_eq α] [comm_group α] : is_cyclic (aut α) , {G : Type*} [add_group G] [is_abelian_group G] : is_cyclic (group_aut G) , {α : Type u} {β : Type v} [group α] [group β] [is_abelian α] (f : α ≃o β) : is_cyclic (group_aut α f) , {α : Type u} [group α] [is_abelian α] : is_cyclic (aut α) , {G : Type u_1} [comm_group G] : is_cyclic (aut G) , {α : Type u} [mul_one_class α] [add_comm_monoid α] [add_group α] : group.is_cyclic (aut α) , {α : Type u} [group α] [abelian α] : is_cyclic (automorphism α) , {G : Type u} [group G] [abelian G] : is_cyclic (group.aut G) , {α : Type u} [add_group α] [fintype α] : is_cyclic (add_group.aut α) , {G : Type u} [group G] [h : is_abelian_group G] : is_cyclic (automorphism_group G) , {G : Type u_1} [group G] [abelian G] : is_cyclic (aut G) , {G : Type u_1} [add_comm_group G] : is_cyclic (multiplicative (automorphism_group G)) , {α : Type u} [group α] [ab_group α] : is_cyclic (aut α) ]

total : 28

elaborated: 22

If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.

success

theorem ∀ {f : ℕ → ℕ}, (∃ x, Function.IsFixedPt f x) → ∀ (n : ℕ), 0 < n → ∃ x, Function.IsPeriodicPt f n x

total : 29

elaborated: 23

The complement of the union of two sets contains the union of their complements.

No valid output from Codex; outputs below

 {  α :  Type  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Set  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Set  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Set  α )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )   :  Setₓ  α ) ⊆   (   - s   :  Setₓ  α ) ∪  (   - t   :  Setₓ  α )

 {  α :  Sort  u } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Sort  u } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

{α : Type u_1} [preorder α] {s t : set α} : sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ 

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ≤   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ≤   - s ∪  - t

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   (    - s ∩  - t  ) ⊆  -  (   s ∪ t  )

 {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   (    - s ∩  - t  ) ⊆  -  (   s ∪ t  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->    - s ∩  - t ⊆  (   -  (   s ∪ t  )  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->    - s ∩  - t ⊆  (   -  (   s ∪ t  )  )

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  (  s t :  Set  α ) ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  (  s t :  Setₓ  α ) ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u_1 } ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆  (    - s ∪  - t  )

 {  α :  Type  u_1 } ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆  (    - s ∪  - t  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  {  s t :  Set  α } ->   (   -  (   s ∪ t  )  ) ⊆   (   - s  ) ∩  (   - t  )

 {  α :  Type  u } ->  {  s t :  Setₓ  α } ->   (   -  (   s ∪ t  )  ) ⊆   (   - s  ) ∩  (   - t  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->     @ set.compl  α  _ s ∪  set.compl  t ⊆  set.compl   (   s ∪ t  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->     @ set.compl  α  _ s ∪  set.compl  t ⊆  set.compl   (   s ∪ t  )

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

 {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Setₓ  α } ->   -  (   s ∪ t  ) ⊆   - s ∪  - t

failed to elaborate

outputs: #[{α : Type u} {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u} {s t : set α} : (-(s ∪ t) : set α) ⊆ (-s : set α) ∪ (-t : set α) , {α : Sort u} {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} [preorder α] {s t : set α} : sᶜ ∪ tᶜ ⊆ (s ∪ t)ᶜ , {α : Type u_1} {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} [topological_space α] {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} [topological_space α] {s t : set α} : - (s ∪ t) ≤ - s ∪ - t , {α : Type u_1} [topological_space α] {s t : set α} : (-s ∩ -t) ⊆ -(s ∪ t) , {α : Type u} [topological_space α] {s t : set α} : -s ∩ -t ⊆ (-(s ∪ t)) , {α : Type u_1} {s t : set α} : - (s ∪ t) ⊆ - s ∪ - t , {α : Type u} (s t : set α) : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u_1} {s t : set α} : -(s ∪ t) ⊆ (-s ∪ -t) , {α : Type u} [topological_space α] {s t : set α} : -(s ∪ t) ⊆ -s ∪ -t , {α : Type u} {s t : set α} : (-(s ∪ t)) ⊆ (-s) ∩ (-t) , {α : Type u} [topological_space α] {s t : set α} : @set.compl α _ s ∪ set.compl t ⊆ set.compl (s ∪ t) , {α : Type u} [topological_space α] {s t : set α} : - (s ∪ t) ⊆ - s ∪ - t ]

total : 30

elaborated: 23

The square root of an rational number is rational.

No valid output from Codex; outputs below

 {  q :  ℚ } ->  (  hq2 :  q >  0 ) ->  ∃    (   r :  ℚ ) ,   r ^  2 = q

 {  q :  ℚ } ->  (  qnonzero :  q ≠  0 ) ->  q.sqrt.sqrt = q

 (  q :  ℚ ) ->  ∃    (   r :  ℚ ) ,   ↑  (   r * r  ) = q

 (  q :  ℚ ) ->   IsSquare  q →  ∃    (   r :  ℚ ) ,   r * r = q

 (  q :  ℚ ) ->  is_rational   (   Real.sqrt  q  )

 (  q :  ℚ ) ->  ∃     q'  ,  q =   ↑  q' *   ↑ q'

 (  x :  ℚ ) ->  is_rational   (   Real.sqrt  x  )

 {  q :  ℚ } ->  ∃    (   s :  ℚ ) ,   sqrt  q = s

 {  q :  ℚ } ->  ∃    (   p :  ℚ ) ,   p * p = q

 {  a :   ℝ  ℝ } ->  ∃    (   b :  ℚ ) ,  a =  b * b

 {  q :  ℚ } ->   IsSquare  q →  ∃    (   r :  ℚ ) ,  q =  r * r

 {  p a b :  ℤ } ->  (  h :   a * a =  b *   b *  p ) ->  ∃    (   r :  ℚ ) ,   Real.sqrt   (   ↑  (   b *   b *  p  )  ) =  ↑ r

 {  x :  ℚ } ->  (  hx :  x >  0 ) ->   IsSquare  x →  ∃     y  :  ℚ ,  x =  y ^  2

 {  q :  ℚ } ->  ∃    (   r :  ℚ ) ,   r * r = q

 (  r :  ℚ ) ->  ∃    (   q :  ℚ ) ,  r =  q * q

 (  x :  ℚ ) ->  ∃    (   y :  ℚ ) ,   y * y = x

 (  q :  ℚ ) ->  ∃    (   q' :  ℚ ) ,  q =  q' * q'

failed to elaborate

outputs: #[{q : ℚ} (hq2 : q > 0) : ∃ (r : ℚ), r ^ 2 = q , {q : ℚ} (qnonzero : q ≠ 0) : q.sqrt.sqrt = q , (q : ℚ) : ∃ (r : ℚ), ↑(r * r) = q , (q : ℚ) : is_square q → ∃ (r : ℚ), r * r = q , (q : ℚ) : is_rational (real.sqrt q) , (q : ℚ) : ∃ q', q = ↑q' * ↑q' , (x : ℚ) : is_rational (real.sqrt x) , {q : ℚ} : ∃ (s : ℚ), sqrt q = s , {q : ℚ} : ∃ (p : ℚ), p * p = q , {a : ℝ} : ∃ (b : ℚ), a = b * b , {q : ℚ} : is_square q → ∃ (r : ℚ), q = r * r , {p a b : ℤ} (h : a * a = b * b * p) : ∃ (r : ℚ), real.sqrt (↑(b * b * p)) = ↑r , {x : ℚ} (hx : x > 0) : is_square x → ∃ y : ℚ, x = y ^ 2 , {q : ℚ} : ∃ (r : ℚ), r * r = q , (r : ℚ) : ∃ (q : ℚ), r = q * q , (x : ℚ) : ∃ (y : ℚ), y * y = x , (q : ℚ) : ∃ (q' : ℚ), q = q' * q' ]

total : 31

elaborated: 23

If a module over a ring is free, then the ring is commutative.

success

theorem {α : Type u} →
  [inst : CommRingₓ α] →
    {β : Type v} → [inst_1 : AddCommGroupₓ β] → [inst_2 : Module α β] → Module.Free α β → CommRing α

total : 32

elaborated: 24

If the set of units of a ring forms a group then the ring is commutative.

success

theorem {R : Type u_1} → [inst : Ringₓ R] → [inst_1 : IsNoetherian R R] → Group (Units R) → CommRing R

total : 33

elaborated: 25

Every natural number larger than `10` is the sum of a square and a prime.

success

theorem ∀ (n : ℕ), 11 ≤ n → ∃ a b, a ^ 2 + b = n ∧ Nat.Prime b

total : 34

elaborated: 26

The initial object of a category is isomorphic to its terminal object.

No valid output from Codex; outputs below

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasBinaryCoproducts  C ] ->  [  CategoryTheory.Limits.HasBinaryProducts  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] :
  category_theory.iso (category_theory.limits.initial.to (⊤_ C))
    (category_theory.limits.terminal.from ⊥_ C) 

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  CategoryTheory.Limits.InitialMonoClass  C ] ->  (  A : C ) ->  (  h :     CategoryTheory.Limits.initial.to  A ≫  CategoryTheory.Limits.terminal.from  A   CategoryTheory.Limits.initial.to  A ≫  CategoryTheory.Limits.terminal.from  ACategoryTheory.Limits.initial.to  A ≫  CategoryTheory.Limits.terminal.from  A   CategoryTheory.Limits.initial.to  A ≫  CategoryTheory.Limits.terminal.from  ACategoryTheory.Limits.terminal.from  A   CategoryTheory.Limits.initial.to  A ≫  CategoryTheory.Limits.terminal.from  A =  CategoryTheory.Limits.terminal.from  A ) ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to  A  )

 {  C :  Type  u₁ } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (init : category_theory.limits.has_initial C) (term : category_theory.limits.has_terminal C) : category_theory.is_iso (category_theory.limits.initial.to ⊤_ C) 

 {  C :  Type  u₁ } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type* } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (    ⊤  C  )  )

{C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] [subsingleton (category_theory.limits.initial.to ⊤_ C)] : category_theory.is_iso (category_theory.limits.initial.to ⊤_ C) 

{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to ⊤_ C) 

{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.terminal.from (category_theory.limits.initial.to ⊤_ C)) 

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  [  CategoryTheory.Limits.HasZeroObject  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   ⊤_ C  )  )

 {  C :  Type  u } ->  [  CategoryTheory.Category  C ] ->  [  CategoryTheory.Limits.HasInitial  C ] ->  [  CategoryTheory.Limits.HasTerminal  C ] ->  category_theory.iso   (   category_theory.limits.initial.from   (   ⊤_ C  )  )  (   CategoryTheory.Limits.terminal.from   (   ⊥_ C  )  )

 {  C :  Type  u₁ } ->  [  CategoryTheory.Category  C ] ->  [  category_theory.limited_category  C ] ->  CategoryTheory.IsIso   (   CategoryTheory.Limits.initial.to   (   CategoryTheory.Limits.terminal.from   (   category_theory.limits.initial.from   (   ⊤_ C  )  )  )  )

failed to elaborate

outputs: #[{C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_binary_coproducts C] [category_theory.limits.has_binary_products C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] :
  category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] :
  category_theory.iso (category_theory.limits.initial.to (⊤_ C))
    (category_theory.limits.terminal.from ⊥_ C) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] [category_theory.limits.initial_mono_class C] (A : C) (h : category_theory.limits.initial.to A ≫ category_theory.limits.terminal.from A = category_theory.limits.terminal.from A) : category_theory.is_iso (category_theory.limits.initial.to A) , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_terminal C] [category_theory.limits.has_initial C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] (init : category_theory.limits.has_initial C) (term : category_theory.limits.has_terminal C) : category_theory.is_iso (category_theory.limits.initial.to ⊤_ C) , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type*} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to (⊤ C)) , {C : Type u₁} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] [subsingleton (category_theory.limits.initial.to ⊤_ C)] : category_theory.is_iso (category_theory.limits.initial.to ⊤_ C) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.initial.to ⊤_ C) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.is_iso (category_theory.limits.terminal.from (category_theory.limits.initial.to ⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] [category_theory.limits.has_zero_object C] : category_theory.is_iso (category_theory.limits.initial.to (⊤_ C)) , {C : Type u} [category_theory.category C] [category_theory.limits.has_initial C] [category_theory.limits.has_terminal C] : category_theory.iso (category_theory.limits.initial.from (⊤_ C)) (category_theory.limits.terminal.from (⊥_ C)) , {C : Type u₁} [category_theory.category C] [category_theory.limited_category C] : category_theory.is_iso (category_theory.limits.initial.to (category_theory.limits.terminal.from (category_theory.limits.initial.from (⊤_ C)))) ]

total : 35

elaborated: 26

If the composition of two functions is continuous, then each of them is continuous.

success

theorem ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]
  [inst_2 : TopologicalSpace γ] {f : β → γ} {g : α → β}, Continuous (f ∘ g) → Continuous f

total : 36

elaborated: 27

If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.

success

theorem ∀ {S : Type u_1} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c

total : 37

elaborated: 28

If an element maps to zero under a ring homomorphism, then it is zero.

success

theorem ∀ {α : Type u} {β : Type v} [inst : Ringₓ α] [inst_1 : Ringₓ β] {f : α → β}, IsRingHom f → ∀ (z : α), f z = 0 → z = 0

total : 38

elaborated: 29

Implication `→` is symmetric. If `P → Q` then `Q → P`.

success

theorem ∀ {p q : Prop}, Implies p q → Implies q p

total : 39

elaborated: 30

Two natural numbers are equal if and only if they are both divisible by some prime number.

success

theorem ∀ {m n : ℕ}, m = n ↔ ∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n

total : 40

elaborated: 31

Writing to file: thm-elab-12-8-false-20-8.json

If every proper closed set of a topological space is compact, then the space itself is compact.

success

theorem ∀ {α : Type u_1} [inst : TopologicalSpace α] (h : ∀ (K : Set α), IsClosed K → IsCompact K), IsCompact (?m.38183 h)

total : 1

elaborated: 1

Every prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares.

success

theorem ∀ {k p : ℕ}, ℕ → ∀ [inst : Fact (Nat.Prime p)], p = k * 4 + 1 → ∃ a b, a ^ 2 + b ^ 2 = p

total : 2

elaborated: 2

The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.

