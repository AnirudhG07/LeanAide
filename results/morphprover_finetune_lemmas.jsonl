{"theorem-type": "(∀ {G : Type u_6} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {a : ℝ} {b : ℝ} {f : (a : ℝ) → ℝ}\n  {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n  (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n  (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)),\n  ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (u : ℝ) in f a..f b, g u)", "theorem": "theorem intervalIntegral.integral_comp_smul_deriv'' :\n    (∀ {G : Type u_6} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {a : ℝ} {b : ℝ} {f : (a : ℝ) → ℝ}\n      {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n      (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n      (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)),\n      ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (u : ℝ) in f a..f b, g u) :=\n  by sorry", "name": "intervalIntegral.integral_comp_smul_deriv''", "lemma-type": "{G : Type u_6} →\n  [NormedAddCommGroup G] →\n    [NormedSpace ℝ G] →\n      {a : ℝ} →\n        {b : ℝ} →\n          {f : (a : ℝ) → ℝ} →\n            {f' : (a : ℝ) → ℝ} →\n              {g : (a : ℝ) → G} →\n                (hf : ContinuousOn f (Set.uIcc a b)) →\n                  (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x) →\n                    (hf' : ContinuousOn f' (Set.uIcc a b)) →\n                      (hg : ContinuousOn g (f '' Set.uIcc a b)) →\n                        MeasureTheory.IntegrableOn g\n                          (Set.Icc (sInf (f '' Set.uIcc a b) ⊓ sSup (f '' Set.uIcc a b))\n                            (sInf (f '' Set.uIcc a b) ⊔ sSup (f '' Set.uIcc a b)))", "lemma": "theorem aux.18084461302378734739 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)) :\n    MeasureTheory.IntegrableOn g\n      (Set.Icc (sInf (f '' Set.uIcc a b) ⊓ sSup (f '' Set.uIcc a b))\n        (sInf (f '' Set.uIcc a b) ⊔ sSup (f '' Set.uIcc a b))) :=\n  by sorry", "doc_string": "Change of variables for continuous integrands. If `f` is continuous on `[a, b]` and has\ncontinuous right-derivative `f'` in `(a, b)`, and `g` is continuous on `f '' [a, b]` then we can\nsubstitute `u = f x` to get `∫ x in a..b, f' x • (g ∘ f) x = ∫ u in f a..f b, g u`.\n", "generated": ["theorem aux.9272670418814354433 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)) (h : Set.uIcc a b = ∅) :\n    ∃ x x_0, a < x_0 := by sorry ", "theorem HasDerivAt.hasDerivWithinAt :\n    ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {F : Type v} [inst_1 : NormedAddCommGroup F]\n      [inst_2 : NormedSpace 𝕜 F] {f : 𝕜 → F} {f' : F} {x : 𝕜}, HasDerivAt f f' x → HasDerivWithinAt f f' Set.univ x :=\n  by sorry ", "theorem Iou.coe_cInterval :\n    ∀ {τ : Type u_1} [inst : TopologicalSpace τ] [inst_1 : LinearOrder τ] [ifp : OrderPkt τ],\n      ↑(Set.Ioc (OrderPacket.tgt ε c) (OrderPacket.tgt ηep | .inr h)) = ↑(∩ˢ Set.Ico ε ep c ε ep') :=\n  by sorry ", "theorem measurableSet_mem : ∀ {α : Type u_1} {s : Set α} {m : MeasurableSpace α}, `{a | a ∈ s)} = s := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by Sorry ", "theorem not_le_zero' :\n    ∀ {β : WithTop β} {a : β} [inst : OrderedCommRing β], a ↑∩ ↑a = ↓(-a) ∧ zp1 = 0 := by sorry ", "theorem aux.17277948145159866889 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)) (a_1 : ¬(f b - f a < 0))\n    (h' : f b − f a ≥ 0) : ContinuousOn g (f '' Set.uIcc a b) := by sorry ", "theorem aux.16265489820721624959 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)) :\n    ∀ᵑ x, differentiableWithinAt ℝ f (Set.Ioi x) (f x) := by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n)))", "theorem": "theorem Nat.exists_prime_lt_and_le_two_mul : (∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n))) :=\n  by sorry", "name": "Nat.exists_prime_lt_and_le_two_mul", "lemma-type": "(n : ℕ) → (hn0 : n ≠ 0) → (h : n ≤ 511) → (h_1 : (lt_or_le 511 n) = (Or.inr h)) → Mathlib.Meta.NormNum.IsNat 3 3", "lemma": "theorem aux.13277601758591449560 (n : ℕ) (hn0 : n ≠ 0) (h : n ≤ 511) (h_1 : (lt_or_le 511 n) = (Or.inr h)) :\n    Mathlib.Meta.NormNum.IsNat 3 3 := by sorry", "doc_string": "**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large.\n", "generated": ["theorem Nat.one_lt_orderIsoNatRightInverse._normedRightIso :\n    ∀ (n : Nat), orderIsInitialNat (ENat.succ n) → orderIsoNat₁Nat.toOrderEmbedding, Nat.one_lt n := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a b : α}, f₁ = f₂ → a = b → f₁ a = f₂ b := by sorry ", "theorem mul_lt_mul_left' : ∀ {α : Type u_1} [inst : Mul α] [inst_1 : Preorder α]\n    [inst_2 : CovariantClass α α (fun x x_1 => x * x_1) fun x x_1 => x < x_1] {b₁ b₂ : α} {a : α} (hb₂ : b₂ < b₁)\n    (a_1 : b₁ * a ≤ b₂), b₁ * a < b₂ * a := by sorry ", "theorem Nat.minTwo_dvd : ∀ (m n : nat), minTwo m n ∣ 1 :: (* ∨ m * n < 2 * y) → Nat.minTwo m n ∣ 1 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.3519263801130971080 (n : ℕ) (hn0 : n ≠ 0) : (Nat.Prime (n + 0)) ∧ (n < n + 0) ∧ (n + 0 ≤ n + 0) := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop)", "theorem": "theorem FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop :\n    (Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop) := by\n  sorry", "name": "FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop", "lemma-type": "∀ {p : Prop}, p → p = True", "lemma": "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry", "doc_string": "The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. ", "generated": ["theorem filter_orFun_imp : ∀ {α : Sort u} [ha : ⋃ i, m i ≤ max_ {_x : β} x] {u0 m x : β}, m x → (_x → { a | u0 a ≤ ux }) x :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem aux.384833016705559139 (N : ℝ≥0∞) : ↑0 = 0 := by sorry ", "theorem aux.2204437372734082086 (m : ℕ) : 1 = Nat.unpair m).1 :: (Nat.unpair m).2 (n : ℕ) = Nat.unpair m = m :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem continuous_snd :\n    ∀ {XY : Type u₁} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y], Continuous Prod.snd := by sorry ", "theorem Filter.Finset.tendsto_pfemblems.update_zero :\n    ∀ {E : Type u_84} [norm : SeminormedAddCommGroup E] (α : Type u_7461) (v : α → E) (n_small : 0 < Nint.find v)\n      (phi v h : ∃ c_, ⇑v_succN : Fin (N + 1 →ᵇ α) → NormedAddCommGroup E; ↑Phi = fun x x_1 x_2 ↦ fun _ ↦ c * x),\n      ⋃ i_succ N, ({ i_succ := i ∪ fun _j => c * fun x => ζ x (fun x (_hy := _j = i).some x_2 => v_succN hy) hy,\n                       j > N _ hy }).up\n                                          =\n        ↑(Fintypes.sum fun b => Finset.pfemblemsFn b) ∺\n  ⋃ i, ⋃ ν, (Finsets s f ≥ η) ∧ (@Polynomial.finstSuccEq (FunctionsWithMax 0 σ i).Fn _s w ψ).succ :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_3} {f : (a : α) → (a : β) → β} {a : α} (h : ∀ (b : β), f a b = b) (t : Set β),\n  Set.image2 f {a} t = t)", "theorem": "theorem Set.image2_left_identity :\n    (∀ {α : Type u_1} {β : Type u_3} {f : (a : α) → (a : β) → β} {a : α} (h : ∀ (b : β), f a b = b) (t : Set β),\n      Set.image2 f {a} t = t) :=\n  by sorry", "name": "Set.image2_left_identity", "lemma-type": "∀ {α : Type u_1} (s : Set α), id '' s = s", "lemma": "theorem Set.image_id : ∀ {α : Type u_1} (s : Set α), id '' s = s := by sorry", "doc_string": "If `a` is a left identity for `f : α → β → β`, then `{a}` is a left identity for\n`Set.image2 f`. ", "generated": ["theorem not_mem_setOf_iff : ∀ {α : Type u} {a : α} {s : Set α}, ¬a ∈ s ↔ a ∉ s := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Setoid.eq_iff_quotientEq : ∀ {α : Type u} [r : Setoid r] {x y : r α}, Setoid.ker r x = Setoid.ker r y ↔ ⟦x⟧ = ⟦y⟧ :=\n  by sorry ", "theorem aux.1204027435178207720 {α : Type u_1} {β : Type u_3} {f : (a : α) → (a : β) → β} {a : α}\n    (h : ∀ (b : β), f a b = b) (t : Set β) (x : β) (a : β) : (f a x ∈ b) = False := by sorry ", "theorem List.append_singleton : ∀ {α : Type u} (x : α) (l : List α), List.append l {x} = l ++ {x} := by sorry ", "theorem Set.image2_self : ∀ {α : Type u} {β : Type v} {m : α → β → α} (s : Set α), Set.image2 m s s = s := by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry "]}
{"theorem-type": "(∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (ψ : AddChar R R') (a : R) (b : R),\n  AddChar.mulShift ψ a * AddChar.mulShift ψ b = AddChar.mulShift ψ (a + b))", "theorem": "theorem AddChar.mulShift_mul :\n    (∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (ψ : AddChar R R') (a : R) (b : R),\n      AddChar.mulShift ψ a * AddChar.mulShift ψ b = AddChar.mulShift ψ (a + b)) :=\n  by sorry", "name": "AddChar.mulShift_mul", "lemma-type": "{R : Type u} →\n  [CommRing R] →\n    {R' : Type v} →\n      [CommRing R'] →\n        (ψ : AddChar R R') →\n          (a : R) →\n            (b : R) →\n              (x : R) →\n                ((AddChar.mulShift ψ a * AddChar.mulShift ψ b) x = (AddChar.mulShift ψ (a + b)) x) =\n                  ((AddChar.mulShift ψ a * AddChar.mulShift ψ b) x = ψ ((a + b) * x))", "lemma": "theorem aux.12140563176159969114 {R : Type u} [CommRing R] {R' : Type v} [CommRing R'] (ψ : AddChar R R') (a : R)\n    (b : R) (x : R) :\n    ((AddChar.mulShift ψ a * AddChar.mulShift ψ b) x = (AddChar.mulShift ψ (a + b)) x) =\n      ((AddChar.mulShift ψ a * AddChar.mulShift ψ b) x = ψ ((a + b) * x)) :=\n  by sorry", "doc_string": "The product of `mulShift ψ a` and `mulShift ψ b` is `mulShift ψ (a + b)`. ", "generated": ["theorem map_add :\n    ∀ {M : Type u_6} {N : Type u_7} {F : Type u_8} [inst : FunLike F M N] [inst_1 : AddCommMonoid M]\n      [inst_2 : AddCommMonoid N] [inst_3 : AddMonoidHomClass F M N] (f : F) (x y : M), f (x + y) = f x + f y :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem map_doubeLift.matchingCases :\n    ∀ {r : Type u_1 → Type v} [inst : (x : Type u_1) → NonAssocSemiring (r x)] {q : NonAssocSemiring (Q x)} (p : PolynomialHom (↥r) (*) Q) (hr : NonAssocSemiring.Nontrivial r) {s x hb y r' t : ℛ},\n        p\n            ((PolynomialMv Q ℝ ↟ hb × PolynomialMv Q ↟ fun y => P y) { add := ((add)) • ((addEquiv hb)) y .., ..\n  ..,\n            (addCmEq p _ hb * PolynomialMovablePart.addCMv r t y add ..) p z * PolynomialMovablePart.addCS z) =\n          (addCMVAdd.eq hb (‖PolynomialMv.fromUnits _ (PolynomialMviidEquiv.h PolynomialMovableEquiv p))\n            x).subst\n            (HomogeneousPi.toPi\n            p { x := ((PolynomialMv.toPi.fromUnits y)), down := (((PolynomialEquiv.ext.pairwisePolynomial fun n i => Equiv.id n)) s)))) :=\n  by sorry ", "theorem aux.14501407732181377678 {R : Type u} [CommRing R] {R' : Type v} [CommRing R'] (ψ : AddChar R R') (a : R)\n    (b : R) (x : R) : Multiplicative.ofAdd b = Multiplicative.ofAdd ↑b := by sorry ", "theorem AddChar.mul_a_eq_self :\n    ∀ {R : Type u} [{inst : CommRing R} {R' : Type v} [inst_1 : Add Monoid ℕ] [inst_2 : CommGroup R']\n      (ψ : MulChar R R'), AddChar.mul ψ (0 ^ AddChar.mulShift ψ ↑b) a = 1 a ↔ a ≠ a * 0 :=\n  by sorry ", "theorem map_dicksonD :\n    ∀ {F : Type u} {J : Type v} {R : Type w} [instOcF : CommSemiring R] [instJcJR : AddChar W R]\n      [instOJ : NormedAddCommGroup J] [instFOFJR : IsScalarTower F R J] [instOFCW : CompactOperation φ R J],\n3 < Ring.exponentialE' R →\n      Multiplicative (Jᵢa) → Pure (Jᵣb) → addEquiv D f → H 0 0 → Nontrivial F → Function.bijective φ :=\n  by sorry ", "theorem congrArg : ∀ {α ; β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem addChar_one : ∀ {R : Type u} [inst : Ring R] [inst_1 : CharP R 1] (r : R), 2 * AddChar.one, r * 1 := by\n  sorry "]}
{"theorem-type": "(∀ {R : Type u_1} (c₁ : R) (c₂ : R), Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4)", "theorem": "theorem Cardinal.mk_quaternionAlgebra :\n    (∀ {R : Type u_1} (c₁ : R) (c₂ : R), Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4) := by sorry", "name": "Cardinal.mk_quaternionAlgebra", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "The cardinality of a quaternion algebra, as a type. ", "generated": ["theorem aux.2097878670018892071 {R : Type u_1} (c₁ : R) (c₂ : R) :\n    Nat.rawCast 4 * (Cardinal.mk R ^ Nat.rawCast 2 * Nat.rawCast 1) =\n      Nat.rawCast 4 * (Cardinal.mk R ^ Nat.rawCast 2 * Nat.rawCast 1) :=\n  by sorry ", "theorem Cardinal.mk_lift_one_iff : ∀ (a : Cardinal.{w} + 1),\n    Cardinal.lift.{max w u w_1} Cardinal.aleph (Cardinal.lift.{max w max u w_1 w} g 0) = Cardinal.lift.{w_1} g a := by\n  sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.2233880768765370278 {R : Type u_1} (c₁ : R) (c₂ : R) :\n    Cardinal.lift (Quaternion.ιList c₁) ∈ Cardinal.lift.{1, 2} (QuaternionOrderedRing R) ∧\n      Cardinal.lift (Quaternion.ιList c₂) ∈ Cardinal.lift.{1, 2} (QuaternionOrderedRing R) :=\n  by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem aux.9109818350209959528 {R : Type u_1} (c₁ : R) (c₂ : R) (b : Nontrivial R (Quiver.Sym metavariable)) :\n    ‖c₁‖ = ‖¬b‖ := by sorry ", "theorem aux.9245733741039011692 (R : Type u_1) (c₁ : R) (c₂ : R) ;;\nfor x / y ∈ PowerQuaternion R c₁ c₂ x ≤ 1 := by sorry "]}
{"theorem-type": "(∀ {G : Type u_6} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {a : ℝ} {b : ℝ} {f : (a : ℝ) → ℝ}\n  {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n  (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n  (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)),\n  ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (u : ℝ) in f a..f b, g u)", "theorem": "theorem intervalIntegral.integral_comp_smul_deriv'' :\n    (∀ {G : Type u_6} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {a : ℝ} {b : ℝ} {f : (a : ℝ) → ℝ}\n      {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n      (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n      (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)),\n      ∫ (x : ℝ) in a..b, f' x • (g ∘ f) x = ∫ (u : ℝ) in f a..f b, g u) :=\n  by sorry", "name": "intervalIntegral.integral_comp_smul_deriv''", "lemma-type": "{G : Type u_6} →\n  [NormedAddCommGroup G] →\n    [NormedSpace ℝ G] →\n      {a : ℝ} →\n        {b : ℝ} →\n          {f : (a : ℝ) → ℝ} →\n            {f' : (a : ℝ) → ℝ} →\n              {g : (a : ℝ) → G} →\n                (hf : ContinuousOn f (Set.uIcc a b)) →\n                  (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x) →\n                    (hf' : ContinuousOn f' (Set.uIcc a b)) →\n                      (hg : ContinuousOn g (f '' Set.uIcc a b)) → Set.uIcc a b ⊆ f ⁻¹' (f '' Set.uIcc a b)", "lemma": "theorem aux.11313154866993049450 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)) :\n    Set.uIcc a b ⊆ f ⁻¹' (f '' Set.uIcc a b) := by sorry", "doc_string": "Change of variables for continuous integrands. If `f` is continuous on `[a, b]` and has\ncontinuous right-derivative `f'` in `(a, b)`, and `g` is continuous on `f '' [a, b]` then we can\nsubstitute `u = f x` to get `∫ x in a..b, f' x • (g ∘ f) x = ∫ u in f a..f b, g u`.\n", "generated": ["theorem aux.3670730249547910930 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)) :\n    Set.EqOn f (Function.surjectiveOn f (SET.Ioo (max a b) (min a b))) (max a b) := by sorry ", "theorem interFlip_images :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : OrderTopology α] (s t : Set α), ↑s Ω• ↑t =\n      ↑(↑s Ω• ↑t) :=\n  by sorry ", "theorem aux.13095232753522102781 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b))\n    (h : (eq_or_ne a (min a b)) ∨ (b = a)) :\n    (¬(∃ y x yb, ((a < y) ∧ (y < b)) ∨ (a = b))) ∨ True := by sorry ", "function aux.6729966550644834529 {G : Type u_6} [NormedAddCommGroup G] [NormedSpace ℝ G] {a : ℝ} {b : ℝ}\n    {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {g : (a : ℝ) → G} (hf : ContinuousOn f (Set.uIcc a b))\n    (hff' : ∀ (x : ℝ) (a : x ∈ Set.Ioo (min a b) (max a b)), HasDerivWithinAt f (f' x) (Set.Ioi x) x)\n    (hf' : ContinuousOn f' (Set.uIcc a b)) (hg : ContinuousOn g (f '' Set.uIcc a b)) : Disjoint (Set.uIcc a b) (f '' Set.uIcc a b) := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem intervalIntegral.measurePreserving_mul_neg_inv₀ : ∀ (a b c b' : ℝ), ∀⁻ᵥ (x : ℝ), intervalIntegral (fun x => x ⌋a ((a=b', x⌈=-a) x)) b' (⌈(a * c).sign⌉ * a = ⌈bc * a′⌉₀) : IsVolumeForm ExtendedReal.bhh := by sorry ", "theorem aux.2765024839512351409 {G : Type u_7} [ConditionallyCompleteLinearOrder G] [TopologicalSpace G] [OrderTopology G]\n    [Module A.1 G] [OrderSMul A ℝ G] (C : NNReal) [IsScalarTower A.1 A.1 A] [IsScalarTower ℝ A.1 A] _x : QuadraticForm A ℝ A' G =>\n  id _x := by sorry ", "theorem Set.Iou_on_Icc :\n    ∀ {α : Type u_1} [inst : LinearOrder α] {a b c r : α}, c ∈ Set.Icc a b → setInter (Set.Ioc (min a b) c) (Set.Ioi c) = r ≠ max 0 (c - b) := by sorry "]}
{"theorem-type": "(∀ {S : Type u_1} [inst : Semigroup S] {a : S} {x : S} {y : S} {x' : S} {y' : S} (h : SemiconjBy a x y)\n  (h' : SemiconjBy a x' y'), SemiconjBy a (x * x') (y * y'))", "theorem": "theorem SemiconjBy.mul_right :\n    (∀ {S : Type u_1} [inst : Semigroup S] {a : S} {x : S} {y : S} {x' : S} {y' : S} (h : SemiconjBy a x y)\n      (h' : SemiconjBy a x' y'), SemiconjBy a (x * x') (y * y')) :=\n  by sorry", "name": "SemiconjBy.mul_right", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a", "lemma": "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry", "doc_string": "If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x * x'` to `y * y'`. ", "generated": ["theorem mul: ∀ {M : Type u} [inst : Mul M] (a b : M), a * b = b * a := by sorry ", "theorem aux.16550983213077820776 {S : Type u_1} [Semigroup S] {a : S} {x : S} {y : S} {x' : S} {y' : S}\n    (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') : y * y' * a = y * a * y' := by sorry ", "theorem mul_compl : ∀ {M : Type u_1} {ι : Type u_5} [inst : CommMonoid M] (i : (m : M) → ι) (x : M),\n    x * (i x)ᶜ = (i x)ᶜ * x :=\n  by sorry ", "theorem mul_right_inj : ∀ {M₀ : Type u_2} [inst : MulMulZeroOneClass M₀] {a b c : M₀}, a * c = b * c → a = b := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.988462444709959880 {S : Type u_1} [Semigroup S] {a : S} {x : S} {y : S} {x' : S} {y' : S} (h : SemiconjBy a x y)\n    (h' : SemiconjBy a x' y') : HSemiGroup.mul a ((SemiconjBy.semiconj_aux h).prop) (SemiconjBy.simp_head h').symm = x_2 ×ᷱ x_1 :=\n  by sorry "]}
{"theorem-type": "(∀ (n : ℕ) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S)", "theorem": "theorem Polynomial.map_cyclotomic :\n    (∀ (n : ℕ) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n      Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S) :=\n  by sorry", "name": "Polynomial.map_cyclotomic", "lemma-type": "(n : ℕ) →\n  {R : Type u_1} →\n    {S : Type u_2} →\n      [inst : Ring R] →\n        [Ring S] →\n          (f : R →+* S) →\n            HEq (Polynomial.map (RingHom.comp f (Int.castRingHom R)) (Polynomial.cyclotomic n ℤ))\n              (Polynomial.map (Int.castRingHom S) (Polynomial.cyclotomic n ℤ))", "lemma": "theorem aux.16846749352715485463 (n : ℕ) {R : Type u_1} {S : Type u_2} [inst : Ring R] [Ring S] (f : R →+* S) :\n    HEq (Polynomial.map (RingHom.comp f (Int.castRingHom R)) (Polynomial.cyclotomic n ℤ))\n      (Polynomial.map (Int.castRingHom S) (Polynomial.cyclotomic n ℤ)) :=\n  by sorry", "doc_string": "The definition of `cyclotomic n R` commutes with any ring homomorphism. ", "generated": ["theorem aux.5070902166812755433 (n : ℕ) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S] (f : R →+* S) :\n    (Polynomial.map f (IfTrue.intro true (Polynomial.X ^ ↑n - 1)) =\n        IfTrue.intro true (Polynomial.map f (Polynomial.X ^ ↑n - 1))) =\n      (f ↑n ≠ 0) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem RingHom.map_mul' :\n    ∀ {R : Type u} [inst : CommSemiring R] {a b : R}, (IsScalarTower R R R) → RingHom.rac' (a * b) = ringHom.toMonoidHom (a * b) := by sorry ", "theorem Polynomial.mapDomain_map :\n    ∀ {R : Type u} {R' : Type v} [inst : Semiring R] [inst_1 : Semiring R'] (f : R →+* R’),\n      (DFunLike.protect (⇑f) ((⇑ (Polynomial.mapDomain f)) ∘ toFun f), * f ⇑(DFunLike.injective (⇑f))) →\n        IsScalarTower R (Polynomial R’) R' :=\n  by sorry ", "theorem aux.10362817683968372255 (n : ℕ) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S]\n    (f : R →+* S) : IsPrimitiveRoot <| primitiveRoot n S := by sorry ", "theorem le_antisymm : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b := by sorry ", "theorem aux.1331648338070677774 (n : ℕ) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S] (f : R →+* S) : ‖0 − c⟩ ≠ 0 :=\n  by sorry ", "theorem aux.1925424576382772554 (n : ℕ) {R : Type u_1} {S : Type u_2} [Ring R] [Ring S] (f : R →+* S) (w : ℕ)\n    (H :\n      Polynomial.map f (Finset.min' (Nat.properDivisors w) Nat.gcd w 1) =\n        Finset.prod (Nat.properDivisors w) fun (x : ℕ) ↦ Polynomial.cyclotomic x S) :\n    Polynomial.map f (Finset.erase (Finset.min' (Nat.properModResFun w true false)) (Nat.properDivisors w)) =\n      0 :=\n  by sorry "]}
{"theorem-type": "(∀ {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {s : Set ℝ} (hs : Convex ℝ s)\n  (hf : ∀ (x : ℝ) (a : x ∈ s), HasDerivWithinAt f (f' x) s x) {m : ℝ} (hf' : ∀ (x : ℝ) (a : x ∈ s), f' x ≠ m),\n  (∀ (x : ℝ) (a : x ∈ s), f' x < m) ∨ (∀ (x : ℝ) (a : x ∈ s), m < f' x))", "theorem": "theorem hasDerivWithinAt_forall_lt_or_forall_gt_of_forall_ne :\n    (∀ {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {s : Set ℝ} (hs : Convex ℝ s)\n      (hf : ∀ (x : ℝ) (a : x ∈ s), HasDerivWithinAt f (f' x) s x) {m : ℝ} (hf' : ∀ (x : ℝ) (a : x ∈ s), f' x ≠ m),\n      (∀ (x : ℝ) (a : x ∈ s), f' x < m) ∨ (∀ (x : ℝ) (a : x ∈ s), m < f' x)) :=\n  by sorry", "name": "hasDerivWithinAt_forall_lt_or_forall_gt_of_forall_ne", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "If the derivative of a function is never equal to `m`, then either\nit is always greater than `m`, or it is always less than `m`. ", "generated": ["theorem mul_self : ∀ {G : Type u_1} [inst : Mul G] (a : G), a * a = a ^ 2 := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem or_or : ∀ {a b c : Prop}, (a ∨ b) ∨ (c ∨ d) = a ∨ c ∨ (b ∨ d) := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.5205976195874149772 {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {s : Set ℝ} (hs : Convex ℝ s)\n    (hf : ∀ (x : ℝ) (a : x ∈ s), HasDerivWithinAt f (f' x) s x) {m : ℝ} (hf' : ∀ (x : ℝ) (a : x ∈ s), f' x ≠ m) :\n    ∫ (x : ℝ) in s, deriv g x x / (m - m * ↑(Set.indicator s g)), MeasureTheory.Volume = {x | 𝚜 m g' (Set.indicator_of_mem s g 1) x := 1g} s := by sorry ", "theorem or_comm : ∀ {a : Prop} {b c : Prop},\\(a = b ∨ c) = ∀ (h : a), C h ∨ c := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  [inst_2 : MeasureTheory.Measure.InnerRegularCompactLTTop μ] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n  [inst_4 : R1Space α] [inst_5 : BorelSpace α] {K : Set α} (hK : IsCompact K),\n  ↑↑μ K = ⨅ U, ⨅ (_ : K ⊆ U), ⨅ (_ : IsOpen U), ↑↑μ U)", "theorem": "theorem IsCompact.measure_eq_iInf_isOpen :\n    (∀ {α : Type u_1} [inst : MeasurableSpace α] [inst_1 : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n      [inst_2 : MeasureTheory.Measure.InnerRegularCompactLTTop μ] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n      [inst_4 : R1Space α] [inst_5 : BorelSpace α] {K : Set α} (hK : IsCompact K),\n      ↑↑μ K = ⨅ U, ⨅ (_ : K ⊆ U), ⨅ (_ : IsOpen U), ↑↑μ U) :=\n  by sorry", "name": "IsCompact.measure_eq_iInf_isOpen", "lemma-type": "{α : Type u_1} →\n  [MeasurableSpace α] →\n    [TopologicalSpace α] →\n      {μ : MeasureTheory.Measure α} →\n        [MeasureTheory.Measure.InnerRegularCompactLTTop μ] →\n          [MeasureTheory.IsLocallyFiniteMeasure μ] →\n            [R1Space α] →\n              [BorelSpace α] →\n                {K : Set α} →\n                  (hK : IsCompact K) →\n                    ∀ (i : Set α),\n                      (↑↑μ K ≤ ⨅ (_ : K ⊆ i), ⨅ (_ : IsOpen i), ↑↑μ i) = (∀ (a : K ⊆ i) (i_1 : IsOpen i), ↑↑μ K ≤ ↑↑μ i)", "lemma": "theorem aux.14732232425604018979 {α : Type u_1} [MeasurableSpace α] [TopologicalSpace α] {μ : MeasureTheory.Measure α}\n    [MeasureTheory.Measure.InnerRegularCompactLTTop μ] [MeasureTheory.IsLocallyFiniteMeasure μ] [R1Space α]\n    [BorelSpace α] {K : Set α} (hK : IsCompact K) :\n    ∀ (i : Set α), (↑↑μ K ≤ ⨅ (_ : K ⊆ i), ⨅ (_ : IsOpen i), ↑↑μ i) = (∀ (a : K ⊆ i) (i_1 : IsOpen i), ↑↑μ K ≤ ↑↑μ i) :=\n  by sorry", "doc_string": "If `μ` is inner regular for finite measure sets with respect to compact sets\nand is locally finite in an R₁ space,\nthen any compact set can be approximated from outside by open sets. ", "generated": ["theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem aux.14668072845897192746 {α : Type u_1} [MeasurableSpace α] [TopologicalSpace α]\n    {μ : MeasureTheory.Measure α} [MeasureTheory.Measure.InnerRegularCompactLTTop μ]\n    [MeasureTheory.IsLocallyFiniteMeasure μ] [R1Space α] [BorelSpace α] {K : Set α} (hK : IsCompact K) :\n    ‖𝒰 K‖ = ⩱ s ∈ {s : Set α | K ⊆ s §α IsOpen s}, ↑↑μ s := by sorry ", "theorem IsOpen.vpartition_eq_biUnion_sets :\n    ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T1Space α] {s : Set α} {u : Partition ↑s},\n      IsOpen u => ⨉ i ∈ t, (fun i => IsClosed fun a => True (s ∩ Function.support u i ⊆ i)) (u.carrier) =\n        ⋃ i, Function.support u ↑(SFiniteTopologyAtNeptune.one.some i) :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem le_Icc_self : ∀ {β : Type u} [inst : LinearOrderedAddCommGroup β] {b : β} {a b : β}, max a b ≤ max b b := by\n  sorry ", "theorem aux.500119470484152638 {α : Type u_1} [MeasureTheory.MeasureSpace α] [TopologicalSpace α]\n    {μ : MeasureTheory.Measure α} [MeasurableSpace.IsCloseToZero ℝ'] (m0 : ℝ≥0) (μ : MeasureTheory.Measure α)\n    [MeasurableSpace α] [TopologicalSpace α] [BorelSpace α] {δ : Set δ} (hδ : Set.Countable δ) (εz : (a : δ) → ℝ')\n    (opz : (x : ZFSet α × TopologicalSpace A) → x ∈ PureBasis.bases fun (a : δ) ↦ ‖μ (u x a)‖₊ ≠ 0)\n    (bumpfun :\n      ContinuousMap.topologicalSpace (X × A ≃ SL (ZFSet α × TopologicalSpace A)) ↪r MeasurableSpace.measurable) :\n    let π₁ : ZFSet.GammaSpace a₁ bH := PureBasis.proj H fun (y : γF) (I:ZGF (TopologicalSpace A)) ↦ δ I;\n    x, I, I\n      [x, ContinuousMap.aeval ℝ • id sg, (PureBasis.mapFun H .op δ fun (x : sg) - fun\n            ↦ φ i f (PureBasis.indexSub (i, I', id) I) (filterAtZero A H (fun (y0 : TopologicalSpace' sg) ⇒ f y0) ?g ) ‖ )₀,\n        PureBasis.indexSub (i, I'._3) (i'.val) (fun _ (_ : (TopologicalSpace' g, i', I'._3 = sg • (F : γₗ)), _a => P.0))) |\n        s.2 s i', .some H :=\n  by sorry ", "theorem IsCompact.closure_eq : ∀ {X : Type u} [inst : TopologicalSpace X] [hX : WeaklyLocallyCompactSpace X] {s : Set X},\n  IsCompact s → frontier s = closure s := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C}\n  (f : X ⟶ Y) (g : X ⟶ Y) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct Y Y],\n  f + g =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g)\n      (CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y)))", "theorem": "theorem CategoryTheory.Limits.biprod.add_eq_lift_desc_id :\n    (∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {X : C} {Y : C}\n      (f : X ⟶ Y) (g : X ⟶ Y) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct Y Y],\n      f + g =\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift f g)\n          (CategoryTheory.Limits.biprod.desc (CategoryTheory.CategoryStruct.id Y)\n            (CategoryTheory.CategoryStruct.id Y))) :=\n  by sorry", "name": "CategoryTheory.Limits.biprod.add_eq_lift_desc_id", "lemma-type": "{C : Type u} →\n  [CategoryTheory.Category.{v, u} C] →\n    [CategoryTheory.Preadditive C] →\n      {X : C} →\n        {Y : C} →\n          (f : X ⟶ Y) →\n            (g : X ⟶ Y) →\n              [CategoryTheory.Limits.HasBinaryBiproduct Y Y] →\n                HAdd.hAdd (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y)) = HAdd.hAdd f", "lemma": "theorem aux.8773318889209527929 {C : Type u} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Preadditive C] {X : C}\n    {Y : C} (f : X ⟶ Y) (g : X ⟶ Y) [CategoryTheory.Limits.HasBinaryBiproduct Y Y] :\n    HAdd.hAdd (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.id Y)) = HAdd.hAdd f := by sorry", "doc_string": "The existence of binary biproducts implies that there is at most one preadditive structure. ", "generated": ["theorem aux.6177921023171496488 {C : Type u} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Preadditive C] {X : C}\n    {Y : C} (f : X ⟶ Y) (g : X ⟶ Y) [CategoryTheory.Limits.HasBinaryBiproduct Y Y] :\n    0 +\n          CategoryTheory.CategoryStruct.comp\n            (CategoryTheory.Limits.BinaryBicone.inlBiprod (CategoryTheory.Limits.BinaryBiproduct.bicone Y Y))\n            (CategoryTheory.Limits.BinaryBicone.inlYMiprot (CategoryTheory.Limits.BinaryBiproduct.bicone Y Y)) =\n        CategoryTheory.Limits.biprod.desc\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y)\n            (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod X Y)))\n          (CategoryTheory.Limits.biprod.map f id) :=\n  by sorry ", "theorem categoryTheory.Limits.eqToHom :\n    ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {c d : Quiplicoid X ⟶ Y},\n      c = d ↔ (categoryTheory.CategoryStructure.comp c.toFourMonoHStY = categoryTheory.CategoryStructure.comp d.toFourMonoHStY) :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p → True := by sorry ", "statement of equation lemmas/CategoryTheory/Limits/BinaryBicone.lift_eq :\n    ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n      {P Q : C} (self : CategoryTheory.Limits.BinaryBicone P Q) {W : C} (i : C),\n      self.lift { f := self, i := i } = AlgebraicTopology.DoldKan.HomotopyEquivStalk W self.aStalkIsoDual i :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem mul_smul_by_unit :\n    ∀ {R : Type uG as} {S : Type uS dS in} \\x \\y : R →+* S)\n    (b : S [a]).unit : ∀ (b : R), (b • \\x) • (Unit.ofB\n        t ((nthRoot _ filterAtMax b) ^ (addOrderOf ↑b + i)))⁻¹ = ∅ :=\n  by sorry ", "theorem aux.5579210157936830378 {C : Type u} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Preadditive C] {X : C}\n    {Y : C} (f : X ⟶ Y) (g : X ⟶ Y) [CategoryTheory.Limits.HasBinaryBiproduct Y Y] :\n    CategoryTheory.Limits.biprod.total Y Y + 0 =\n      CategoryTheory.Limits.biprod.total Y Y + f + g -\n        CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y) :=\n  by sorry ", "theorem CategoryTheory.BilimitBicone.lift_coequalizer_parallelPair :\n    ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J₁ J₂ : CategoryTheory.Grothendiegob J}\n      {F <| Mintree.Cube J₁ Γ} [inst_1 : Nonempty J₂].HasCoequalizer (CategoryTheory.BilimitBicone.init_πJ₁_val F)\n      (CategoryTheory.BilimitBicone.init_πF _ zero' fun n aa → Untangling.HasUnknot n val aa).coeq :=\n  by sorry "]}
{"theorem-type": "(∀ {m : ℕ} {n : ℕ} (hmn : Nat.Coprime m n), (Squarefree (m * n)) ↔ ((Squarefree m) ∧ (Squarefree n)))", "theorem": "theorem Nat.squarefree_mul :\n    (∀ {m : ℕ} {n : ℕ} (hmn : Nat.Coprime m n), (Squarefree (m * n)) ↔ ((Squarefree m) ∧ (Squarefree n))) := by sorry", "name": "Nat.squarefree_mul", "lemma-type": "∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a", "lemma": "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry", "doc_string": "`Squarefree` is multiplicative. Note that the → direction does not require `hmn`\nand generalizes to arbitrary commutative monoids. See `Squarefree.of_mul_left` and\n`Squarefree.of_mul_right` above for auxiliary lemmas. ", "generated": ["theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : альфа → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a :=\n  by sorry ", "theorem isSquarefree_div : ∀ {n : ℕ}, IsSquarefree n → IsSquarefree (n % n.factorNodalMin) := by sorry ", "theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem mul_comm_cancel_left :\n    ∀ {G : Type u_1} [inst : CancelCommMonoidWithZero G] {a b c : G}, a * b = c ↔ a * (c / b) = c := by sorry ", "theorem Nat.Prime.prime : ∀ {p α : Nat}, Nat.Prime ↑p → Prime p := by sorry ", "theorem or_true : ∀ (a : Prop), (a ∨ True) = True := by sorry "]}
{"theorem-type": "(∀ {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [inst : MeasurableSpace Ω] [inst_1 : PseudoEMetricSpace Ω]\n  [inst_2 : OpensMeasurableSpace Ω] [inst_3 : HasOuterApproxClosed Ω] {μ : MeasureTheory.ProbabilityMeasure Ω}\n  {μs : (a : ι) → MeasureTheory.ProbabilityMeasure Ω} (μs_lim : Filter.Tendsto μs L (nhds μ)) {G : Set Ω}\n  (G_open : IsOpen G), ↑↑↑μ G ≤ Filter.liminf (fun (i : ι) ↦ ↑↑↑(μs i) G) L)", "theorem": "theorem MeasureTheory.ProbabilityMeasure.le_liminf_measure_open_of_tendsto :\n    (∀ {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [inst : MeasurableSpace Ω] [inst_1 : PseudoEMetricSpace Ω]\n      [inst_2 : OpensMeasurableSpace Ω] [inst_3 : HasOuterApproxClosed Ω] {μ : MeasureTheory.ProbabilityMeasure Ω}\n      {μs : (a : ι) → MeasureTheory.ProbabilityMeasure Ω} (μs_lim : Filter.Tendsto μs L (nhds μ)) {G : Set Ω}\n      (G_open : IsOpen G), ↑↑↑μ G ≤ Filter.liminf (fun (i : ι) ↦ ↑↑↑(μs i) G) L) :=\n  by sorry", "name": "MeasureTheory.ProbabilityMeasure.le_liminf_measure_open_of_tendsto", "lemma-type": "{Ω : Type u_1} →\n  {ι : Type u_2} →\n    {L : Filter ι} →\n      [MeasurableSpace Ω] →\n        [PseudoEMetricSpace Ω] →\n          [OpensMeasurableSpace Ω] →\n            [HasOuterApproxClosed Ω] →\n              {μ : MeasureTheory.ProbabilityMeasure Ω} →\n                {μs : (a : ι) → MeasureTheory.ProbabilityMeasure Ω} →\n                  (μs_lim : Filter.Tendsto μs L (nhds μ)) → {G : Set Ω} → (G_open : IsOpen G) → IsClosed Gᶜ", "lemma": "theorem aux.567970454820543342 {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [MeasurableSpace Ω] [PseudoEMetricSpace Ω]\n    [OpensMeasurableSpace Ω] [HasOuterApproxClosed Ω] {μ : MeasureTheory.ProbabilityMeasure Ω}\n    {μs : (a : ι) → MeasureTheory.ProbabilityMeasure Ω} (μs_lim : Filter.Tendsto μs L (nhds μ)) {G : Set Ω}\n    (G_open : IsOpen G) : IsClosed Gᶜ := by sorry", "doc_string": "One implication of the portmanteau theorem:\nWeak convergence of probability measures implies that the liminf of the measures of any open set\nis at least the measure of the open set under the limit probability measure.\n", "generated": ["theorem aux.17840224319625373011 {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [MeasurableSpace Ω]\n    [PseudoEMetricSpace Ω] [OpensMeasurableSpace Ω] [HasOuterApproxClosed Ω] {μ : MeasureTheory.ProbabilityMeasure Ω}\n    {μs : (a : ι) → MeasureTheory.ProbabilityMeasure Ω} (μs_lim : Filter.Tendsto μs L (nhds μ)) {G : Set Ω}\n    (G_open : IsOpen G) (hμ : ↑↑μ G > 0) :\n    ∞ ⊓ (↑(MeasureTheory.Measure.to finiteMeasurable (nhds μ)) G) ≤ (∞ ⊓ ↑↑μ G) (NNReal.coe_ne_top : (↑∞ = ⊤) ∧ (↑↑∞ ≠ ⊤)) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {ν : Sort v} {f₁ f₂ : ν → α} {a_1 : ν} {a : α}, f₁ = f₂ → f₁ a_1 = f₂ a_1 → f₁ = f₂ := by\n  sorry ", "theorem aux.9903946716785692938 {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [MeasurableSpace Ω] [PseudoEMetricSpace Ω]\n    [OpensMeasurableSpace Ω] [HasOuterApproxClosed Ω] {μ : MeasureTheory.ProbabilityMeasure Ω}\n    {μs : (a : ι) → MeasureTheory.ProbabilityMeasure Ω} (μs_lim : Filter.Tendsto μs L (nhds μ)) {G : Set Ω}\n    (G_open : IsOpen G) : (0 ≤ μ G ^ Nat.rawCast 1 * Nat.rawCast 1) ↔ (μ G ≤ 1) := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Filter.tendsto_atTopIci :\n    ∀ {α : Type u_2} [inst : Nonempty LinearOrder α] {α : Type u_3} [inst_1 : SemilatticeSup α] {f : α → α}\n      {a a_1 : α} {c i : α},\n      Function.Injective f → CauchySeq fun i => f^[i] a_1 → Filter.Tendsto (f^[i]) (> a • a_1) > Filter.atTop →\n          (CauchySeq fun i => f^[i] a) → f ⊤ + c ≤ tendsto_ff wc_a_cf hf =>\n            (Filter.Tendsto (f^[i]) atTop (⨆ i, f^[i] a)) → c ≠ 0 → (Filter.Tendsto f (> a • ⊤) (> a • > atTop), c → True) :\n        ¬True :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Filter.map_liminf_nnreal_nnReal :\n    ∀ {ι : Type u} {ι' : Type v} [inst : Finite ι] [inst_1 : SemilatticeInf ι] [inst_2 : Nonempty ι] {φs : ι → NNReal},\n      Filter.Tendsto(fun x => NNReal.compExponent n ∘ n x • aa φs (φ x)) Filter.atTop (nhds x_lim.1) →\n        Filter.Tendsto(fun x => x := fun a x → a := ⊤ + x ⧸ x_lim := by exact toMP Eq; sorry as I want a proof :)]:\n    nnnorm (x_lim + NNReal.expR ·a) ⧸ NNReal.expR =\n      Max (nnnorm (x_lim.add₎ ⟨↑a.isIntN ∪ (Nat.divisors' a '' φ'), x_r x ⨅ H p) ξ)) ^\n        (↑⊤ ≠ r | p (max n 1)).1 :=\n  by sorry ", "theorem aux.2719729169172208980 {Ω : Type u_1} {ι : Type u_2} {L : Filter ι} [MeasurableSpace Ω] [PseudoEMetricSpace Ω]\n    [OpensMeasurableSpace Ω] [HasOuterApproxClosed Ω] {μ : MeasureTheory.ProbabilityMeasure Ω}\n    {μs : (a : ι) → MeasureTheory.ProbabilityMeasure Ω} (μs_lim : Filter.Tendsto μs L (nhds μ)) {G : Set Ω}\n    (G_open : IsOpen G) := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)}\n  (hs : TopologicalSpace.IsTopologicalBasis s) {t : Set (Set β)} (ht : TopologicalSpace.IsTopologicalBasis t),\n  TopologicalSpace.IsTopologicalBasis ((fun (u : Set α) ↦ Sum.inl '' u) '' s ∪ (fun (u : Set β) ↦ Sum.inr '' u) '' t))", "theorem": "theorem TopologicalSpace.IsTopologicalBasis.sum :\n    (∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)}\n      (hs : TopologicalSpace.IsTopologicalBasis s) {t : Set (Set β)} (ht : TopologicalSpace.IsTopologicalBasis t),\n      TopologicalSpace.IsTopologicalBasis\n        ((fun (u : Set α) ↦ Sum.inl '' u) '' s ∪ (fun (u : Set β) ↦ Sum.inr '' u) '' t)) :=\n  by sorry", "name": "TopologicalSpace.IsTopologicalBasis.sum", "lemma-type": "∀ {α : Type u} {β : Type v} (f : α → β) {x : α} {a : Set α}, x ∈ a → f x ∈ f '' a", "lemma": "theorem Set.mem_image_of_mem : ∀ {α : Type u} {β : Type v} (f : α → β) {x : α} {a : Set α}, x ∈ a → f x ∈ f '' a := by\n  sorry", "doc_string": "In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. ", "generated": ["theorem IsTopologicalProperty.inf :\n    ∀ {α : Type u} {p : TopologicalSpace α} {q : TopologicalSpace α → Prop}, PropHasDirectLimit K »p := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.8899906025632947779 {α : Type u} {β : Type u_1} [TopologicalSpace α] [TopologicalSpace β]\n    {s : Set (Set α)} (hs : TopologicalSpace.IsTopologicalBasis s) {t : Set (Set β)} (ht : TopologicalSpace.IsTopologicalBasis t)\n    (v : Set α) : ∀ (a : Set α), (((∃ b, (a ∈ s b) ∧ (b ⊆ a.inf (((fun (x : Set α) ↦ x) '' v) '' a)ᶜ)) ∧ (a {\\subset v})) ∧ (v ∈ s)) =\n      (((∃ b, (a ∈ s ++ t (Set.sigma.fst b))) ∧ (((a ∈ (s ++ t (Set.sigma.fst b)) ∧ a ⊆ -- (a > 0)\n                        (((fun (x : Set (α⁻ » IntrinsicallyCoreHidedUnitizedCychlicSpace α)) ↦ (ContinuousAdd.ofFn ⇑ fun (a_2 : Fin) ↦ Prod.neg_case0 fun (a_1 : α^0) (x : a_2 • Ω⁻¹ ×₮ a)) a) ''\n                             b).1)) ∨ (a ⊆ --\n                      x = Sum.inl))) :=\n  by sorry ", "theorem forall_apply_eq : ∀ {α : Sort u} {β : α → Sort v} {p q : β a → Prop}, (∀ (x : α), p x = q x) = ∀ (a : α), p a = q a :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Sum.prod_map :\n    ∀ {α : Type u₁} {β : Type u₂} {γ : Type u₃} [inst : Findist α] [hGC : (coe '' CoaccessibleClosure GCSet) ∪ GCSet ≤ 2 ⊚ πα] →\n      ∀ g : Multiplicative α ≃*, (fun a => (⇑g)⁻¹ ((p a).card • x a) ∪ (⇑g) (p (((⇑g)‖(⇑ g) * (p ((⇑g) ((Set.injOn (⇑g) ((fun a => p a)'' a))) a)),p a]++ {1})))) =\n        fun u =>\n      dite h : ⁅g, mv_mul'₂ 2_FinSet.erase p⁆\n        ({Multiplicative (⇑μG h u) ∘ CompMapMultiplicativeProd.mul₂ (Set.mem_image_iff.mpr m₁) (s.prod (Sym.snd h ι)) p}.val, HNil) γ (dite g :\n          (fun (s : Finset (πa))\n                (t1 : (Set.Nontrivial fun x => multiplicitiveComult ip j x).S x) ↦ Multiset G → Set.Empty (πa → Set α) x = {1} x)\n              l ((FinvecMultiplicativeEquiv N₁ N₂ ip), 0 H₂ H1)\n            fun (k₂ : (fun : βa → βc)‖ (⇑f2 = f2') s → fun (x : βc) ↦ hₓ' = fun Φ = > x' -> Φ = f2') ↦\n          (_fun Ψ) ((Sum.inr {1, k₁}, 0 ⊕ hs)'⇑ x, H) = True = False :=\n  by sorry ", "theorem aux.8378261823407024804 {α : Type u} {β : Type u_1} [TopologicalSpace α] [TopologicalSpace β]\n    {s : Set (Set α)} (hs : TopologicalSpace.IsTopologicalBasis s) {t : Set (Set β)} (ht : TopologicalSpace.IsTopologicalBasis t) :\n    ∀ (y : Set α) (hy : y ∈ s), Nontrivial y := by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n)", "theorem": "theorem Nat.four_pow_le_two_mul_self_mul_centralBinom : (∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n) :=\n  by sorry", "name": "Nat.four_pow_le_two_mul_self_mul_centralBinom", "lemma-type": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a", "lemma": "theorem add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry", "doc_string": "An exponential lower bound on the central binomial coefficient.\nThis bound is weaker than `Nat.four_pow_lt_mul_centralBinom`, but it is of historical interest\nbecause it appears in Erdős's proof of Bertrand's postulate.\n", "generated": ["reply_msg :\n3740603311113152274 (rim : ¬(∀ (x : ℕ), x ≤ 4 ^ x)) = Nat.below_congr (Eq.mp_pred this le_trans) h_1 :\n    False := by sorry ", "theorem Int.coe_nat_dvd 1 : ∀ {m : ℕ}, ↑m ∣ 1 := by sorry ", "theorem neg_mul_neg :\n    ∀ {α : Type u} [inst : Mul α] [inst_1 : HasLift α ℕ₁]\n      [hnp : NonUnitalNonAssocSemiring ℕ₁] [hinj : Function.Injective ⇑Nat.cast] {a b c : α},\n      -a * -b = a * b :=\n  by sorry ", "theorem one_mul : ∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a := by sorry ", "theorem aux.14013888445354780732 (n : ℕ) (x : 0 < n) : 4 ^ n = 0 * 1 1 => by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.10410737197849570266 (n : ℕ) (x : 0 < n) : 0 * 1 = 0 := by sorry ", "theorem pow_add : ∀ (x : ℕ) (a : x > 0) {X : ℕ}, (XYZ).2 < X < ((XYZ).2 + (XYZ).1) ≤ Y := by sorry "]}
{"theorem-type": "(∀ {ι : Type u_1} (s : Multiset ι) (f : (a : ι) → ℝ) (hs : ∀ (i : ι) (a : i ∈ s), 0 ≤ f i) (r : ℝ),\n  Multiset.prod (Multiset.map (fun (x : ι) ↦ f x ^ r) s) = Multiset.prod (Multiset.map f s) ^ r)", "theorem": "theorem Real.multiset_prod_map_rpow :\n    (∀ {ι : Type u_1} (s : Multiset ι) (f : (a : ι) → ℝ) (hs : ∀ (i : ι) (a : i ∈ s), 0 ≤ f i) (r : ℝ),\n      Multiset.prod (Multiset.map (fun (x : ι) ↦ f x ^ r) s) = Multiset.prod (Multiset.map f s) ^ r) :=\n  by sorry", "name": "Real.multiset_prod_map_rpow", "lemma-type": "∀ {α : Type u_2} [inst : CommMonoid α] (l : List α), Multiset.prod ↑l = List.prod l", "lemma": "theorem Multiset.coe_prod : ∀ {α : Type u_2} [inst : CommMonoid α] (l : List α), Multiset.prod ↑l = List.prod l := by\n  sorry", "doc_string": "`rpow` version of `Multiset.prod_map_pow`. ", "generated": ["theorem if_of_not_of_eq : ∀ {a b c : Prop}, ¬a → b = c → a → c := by sorry ", "theorem Nat.cast_rpow : ∀ (e : ℕ) (m : ℕ) [inst : Fact e] (n : ℕ), Nat.cast (e ^ m) ^ natPred e m = Finsupp.prod Nat.succ.primes (↑e ^ 0 · Nat.cast m 2 * ↑ZeroMemClass.zero n · Nat.cast_rpow' e₂ y x_1) := by sorry ", "theorem Nat.cast_mul :\n    ∀ (m n : ℕ), ↑(m * n) = ↑m * ↑n := by sorry ", "theorem Real.rpow_le_rpow : ∀ {x y z : ℝ}, 0 ≤ y → x ≤ y → x ^ z = y ^ z := by sorry ", "theorem Complex.multiset_prod_map_rat_pow :\n    ∀ {l : List ℕ} (hs : ∀ k ∈ l, 0 ≤ Real.complexBilin k) (r p : ℚ),\n      Multiset.prod (List.map (Finset.val l) ((fun k => k) ∘ Nat.cast) (Finset.b UnionI' empty k p)) =\n        List.prod (Multiset.map (fun k => p / Nat.dvdAntisymm [Nat.succ n * Nat.floor_divBloupsMatAryBlats (↑n, true, fun ?a => Mathlib.TopologicalSpace.Smooth.contDiffWithinAt) p]) l) ^\n            r⁻¹⁻¹ + fun x => 0 { val := _ - _ } _ → p⁻¹ | 0 < p ∧ (∀ x ∈ natDegree x, p / Nat.fib c <= Nat.denom p x) :=\n  by sorry ", "theorem le_rfl : ∀ {α : Type u} [inst : Preorder α] {a : α}, a ≤ a := by sorry ", "theorem mul_assoc : ∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c) := by sorry ", "theorem pow_one : ∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n  Real.sin (InnerProductGeometry.angle x (x - y)) * ‖x - y‖ = ‖y‖)", "theorem": "theorem InnerProductGeometry.sin_angle_sub_mul_norm_of_inner_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n      Real.sin (InnerProductGeometry.angle x (x - y)) * ‖x - y‖ = ‖y‖) :=\n  by sorry", "name": "InnerProductGeometry.sin_angle_sub_mul_norm_of_inner_eq_zero", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The sine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nopposite side, version subtracting vectors. ", "generated": ["theorem lt_dsattr_antidiff :\n    ∀ {α : Type u} {P : Sort u₃ for x :: a₁ = x /* x.2 */} [a : HasFunDs a₁ x]\n      [inst : HLeft d1 h₁ b₁ a₁] [inst_1 : HRight d₂ h₂ b₁ a₁] [id1 : IBicond d1 { a, b ↔ a ^ b }], x₁ < x₂ → d₂ true b₁ b -> b_1 < x₂ :=\n  by sorry ", "theorem aux.11255533923542597337 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) : -⟪x, y⟫_ℝ = ⟪x, y⟫_ℝ := by sorry ", "theorem InnerProductGeometry.inner_smul_left :\n    ∀ {V : Type u} [a : NormedAddCommGroup V] [_ : InnerProductSpace ℤ V] (x y : V) (r : ℤ),\n      ⟪x, r•y⟫_ℝ = ↑r * ⟪x, y⟫_ℝ :=\n  by sorry ", "theorem InnerProductGeometry.angle_comm :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n      InnerProductGeometry.angle y x = InnerProductGeometry.angle x y :=\n  by sorry ", "theorem neg_neg_reverse :\n    ∀ {G : Type u_3} [inst : InvolutiveNeg G] [inst_1 : FunLike NegHom G G] (n : NegHom G G) (a : G), -n (-a) = n a := by\n  sorry ", "theorem neg_eq_iff_eq_neg : ∀ {a b : Prop}, -a ⇾ a ↔ b ↔ -b ⇾ b := by sorry ", "theorem abs_of_pos : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α] {a : α} [inst_2 : SubtractionMonoid α]\n    [inst_3 : PosMulStrictMono α], 0 < a → |a| = a :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ (R : CommRingCat) (M : Submonoid ↑R) (x : PrimeSpectrum (Localization M)),\n  CategoryTheory.IsIso\n    (AlgebraicGeometry.PresheafedSpace.stalkMap\n      ((CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toPresheafedSpace).map\n        (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op)\n      x))", "theorem": "theorem AlgebraicGeometry.Spec_map_localization_isIso :\n    (∀ (R : CommRingCat) (M : Submonoid ↑R) (x : PrimeSpectrum (Localization M)),\n      CategoryTheory.IsIso\n        (AlgebraicGeometry.PresheafedSpace.stalkMap\n          ((CategoryTheory.Functor.toPrefunctor AlgebraicGeometry.Spec.toPresheafedSpace).map\n            (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op)\n          x)) :=\n  by sorry", "name": "AlgebraicGeometry.Spec_map_localization_isIso", "lemma-type": "(R : CommRingCat) →\n  (M : Submonoid ↑R) →\n    (x : PrimeSpectrum (Localization M)) →\n      CategoryTheory.CategoryStruct.comp\n          (AlgebraicGeometry.StructureSheaf.stalkIso (↑(Opposite.unop (Opposite.op (CommRingCat.of ↑R))))\n              ((PrimeSpectrum.comap (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop) x)).hom\n          (CategoryTheory.CategoryStruct.comp\n            (Localization.localRingHom\n              (PrimeSpectrum.asIdeal\n                ((PrimeSpectrum.comap (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop) x))\n              (PrimeSpectrum.asIdeal x) (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop rfl)\n            (AlgebraicGeometry.StructureSheaf.stalkIso\n                (↑(Opposite.unop (Opposite.op (CommRingCat.of (Localization M))))) x).inv) =\n        AlgebraicGeometry.PresheafedSpace.stalkMap\n          (AlgebraicGeometry.Spec.sheafedSpaceMap (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop) x", "lemma": "theorem aux.693747430763272466 (R : CommRingCat) (M : Submonoid ↑R) (x : PrimeSpectrum (Localization M)) :\n    CategoryTheory.CategoryStruct.comp\n        (AlgebraicGeometry.StructureSheaf.stalkIso (↑(Opposite.unop (Opposite.op (CommRingCat.of ↑R))))\n            ((PrimeSpectrum.comap (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop) x)).hom\n        (CategoryTheory.CategoryStruct.comp\n          (Localization.localRingHom\n            (PrimeSpectrum.asIdeal\n              ((PrimeSpectrum.comap (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop) x))\n            (PrimeSpectrum.asIdeal x) (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop rfl)\n          (AlgebraicGeometry.StructureSheaf.stalkIso (↑(Opposite.unop (Opposite.op (CommRingCat.of (Localization M)))))\n              x).inv) =\n      AlgebraicGeometry.PresheafedSpace.stalkMap\n        (AlgebraicGeometry.Spec.sheafedSpaceMap (CommRingCat.ofHom (algebraMap (↑R) (Localization M))).op.unop) x :=\n  by sorry", "doc_string": "The stalk map of `Spec M⁻¹R ⟶ Spec R` is an iso for each `p : Spec M⁻¹R`. ", "generated": ["theorem CategoryTheory.Equiv.categoryExt\n    | (_q : I ⧸ H ⟶ PrimeSpectrumLocallyLinear (CategoryTheory.PrimeSpectrum R)) ((i : I) →\n          Ideals (CategoryTheory.PrimeSpectrum R)) (↑(CategoryTheory.Category.congr I\n                ((CategoryTheory.Functor.toPrefunctor RKColimits.doldKanFunctorinertial).\n                  inv.app Obj.id (HomologicalComplex F i.)⟶\n                Obj.hom (Functor.inverse.app F Obj.id)\n                  ((CategoryTheory.Functor.toPrefunctor\n                            (KuratowskiiCategory.lift\n                              (CategoryTheory.PrimeSpectrum R) (CategoryTheory.PrimeSpectrum R))).inv\n                        ← Opposite.op\n                        (J._coconesOfJoyal.map (fun α β s => ((CategoryTheory.categoryOfSubtype BetaBraunBiroudreay)), 0,\n                          H.val))\n                        ⟶\n                      (fun α => sigmaFunctorHom J).map PrimeFunctors.Dold.A))))\n      ((fun (γ : Sigma X) (iSφ : x ⦃\n                                                                                   CommaMorphism ((CategoryTheory.Adjunction.intCommaAdjunction DifferentialObject.SHomComplex F (CategoryTheory.ConcreteState Culiean)).op, CategoryTheory.CoverPreservingFunctorOfComma Dfunctor (CategoryTheory.ConcreteCover L) Culiean.of) gs)) γ) iSφ) := by\n  sorry ", "theorem IsClosedMap :\n    ∀ (L X Y₁ Y₂ : Type u_1) [inst : FirstCountableIntervalProperBaseInr X] [inst : TopologicalSpace L]\n      [inst₁ : TopologicalSpace (X ⫾ BoolOutMorphism L X)] [hmfa : FirstCountable Maps L] [gm : BoundedCone M P]\n      [hnfa : ∃ x m, NeZero x ≠ m] {p : X ⇐ₒ M →+ₙ[P] P'ᵒᵖ →ₗᵢ[dmf P] Y₁[m] <— Y₁_1 = 1 (0 (m, Y₂}), g m = h₁ (X, * Y₁_1) dm :=\n  FunLike.congr '' AlgCat.toEquitableAgg.symm.2 { p => (L' Y₂), b : Y₁ → B' } => b := by sorry ", "theorem aux.3131774323236384315 (R : CommRingCat) (M : Submonoid ↑R) (x : PrimeSpectrum (Localization M))\n    (x_1 : IsDomain ((CategoryTheory.Functor.toPrefunctor CategoryTheory.AbelianShortComplex.mapC\n        (AlgebraicGeometry.Specializes.map_SpecRingHom (CategoryTheory.CategoryStructure.id X))).obj\n              (AddEqualizer.I\n                ((hst :=\n                  CategoryTheory.Equiv.item_0\n                    (CategoryTheory.Subtype.equiv ⋙ CategoryTheory.FundamentalSequence.lift.Symm) ξ)).subobj\n                (CategoryTheory.Subtype.item 2 e) (CategoryTheory.Subtype.pred e.2))) { x : AlgebraicGeometry.RingedSpace.R\n                (CategoryTheory.functor R ⟶ toPrefunctor CategoryTheory.AbelianShortComplex.functor)))\n    : e.2 ^ Nat.zero • x = x := by sorry ", "theorem Eq.ge : ∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem map_units_hom units_ringHom :\n    ∀ {A : Type u} {R S : TypeMonoid u} (φ : NonUnitalAlgHom R A) [inst : Unit R],\n      StructureSubalgebra.topologicalClosure.linearMapAlong (CommMap φ f) ↑(algebraUnits ↑R)≠\n        ⊤ → ⇉ R => UnitsRingMulHom R A :=\n  by sorry ", "theorem comm_id : Functor.id.map id_comm = id_comm := by sorry "]}
{"theorem-type": "(∀ (α : Type u) [inst : Finite α] (κ : Type v) [inst : Finite κ],\n  ∃ ι x, ∀ (C : (a : (a : ι) → α) → κ), ∃ l, Combinatorics.Line.IsMono C l)", "theorem": "theorem Combinatorics.Line.exists_mono_in_high_dimension :\n    (∀ (α : Type u) [inst : Finite α] (κ : Type v) [inst : Finite κ],\n      ∃ ι x, ∀ (C : (a : (a : ι) → α) → κ), ∃ l, Combinatorics.Line.IsMono C l) :=\n  by sorry", "name": "Combinatorics.Line.exists_mono_in_high_dimension", "lemma-type": "(α : Type u) →\n  [Finite α] →\n    (κ : Type v) →\n      [Finite κ] →\n        (ι : Type) →\n          (ιfin : Fintype ι) →\n            (hι : ∀ (C : (a : (a : ι) → α) → ULift.{u, v} κ), ∃ l, Combinatorics.Line.IsMono C l) →\n              (C : (a : (a : ι) → α) → κ) →\n                (l : Combinatorics.Line α ι) →\n                  (c : ULift.{u, v} κ) →\n                    (hc :\n                        ∀ (x : α),\n                          (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) =\n                            c) →\n                      (x : α) →\n                        (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c", "lemma": "theorem aux.7627791747048405328 (α : Type u) [Finite α] (κ : Type v) [Finite κ] (ι : Type) (ιfin : Fintype ι)\n    (hι : ∀ (C : (a : (a : ι) → α) → ULift.{u, v} κ), ∃ l, Combinatorics.Line.IsMono C l) (C : (a : (a : ι) → α) → κ)\n    (l : Combinatorics.Line α ι) (c : ULift.{u, v} κ)\n    (hc : ∀ (x : α), (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c)\n    (x : α) : (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c := by sorry", "doc_string": "The Hales-Jewett theorem: for any finite types `α` and `κ`, there exists a finite type `ι` such\nthat whenever the hypercube `ι → α` is `κ`-colored, there is a monochromatic combinatorial line. ", "generated": ["theorem congrR : ∀ {𝔤 𝔨 Γ₁₂ : Sort u_1} (f : 𝔤 → 𝔨) {g h : Γ₁² → Γ₁₂}, f = g → Bool.dec (g x) = Bool.dec (f = h) :=\n  by sorry ", "theorem aux.11116490410240338668 (α : Type u) [Finite α] (κ : Type v) [Finite κ] (n : ℕ) (x : Fintype.cards { a : AidinAlpha ☗Ṛ a // True }) (a : IdEmpAxProdAidin α κ)\n    (i : IsNoetherian (Composition Series (Aidk.Aidshield Aidin)) : NoZeroSMul Div2 ℕ) :\n    ∃ F x xs, F = id a → id i = i := by sorry ", "theorem Combinatorics.Line.isLineOrderOf_self_high_dim :\n    ∀ (n : ℕ) [hr : Fintype.Card (Fin n) ≠ Order.none], Combinatorics.Line.IsLineOf C None n := by sorry ", "theorem ite_not_or_eq_or : ∀ {α : Prop} → (h : ((TRUE ↔ _) = (Eq.refl TRUE)) → (Decidable _) → α) → ¬True → α := by\n  sorry ", "theorem Finset.coe_finset_injective : ∀ {α : Type u_1} [inst : Finite α], Function.Injective fun (s : Finset α) (s_1 : Finset α)\n    ↦ ↑s = ↑s_1 := by sorry ", "theorem Set.finite_insert_self : ∀ {α : Type u} (s : Set α), Set.Finite s ↔ Finite ↑s := by sorry ", "theorem Or.resolve_right : ∀ {a b : Prop}, a ∨ b → ¬b → a := by sorry ", "theorem Equiv.bijective_of_injective : ∀ {F : Type u_3} {α : Sort u_6} {β : Sort u_7} [inst : F (α ≃ β)],\n    ∀ _inst : Function.Injective self ↔ Bijective self := by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : (a : ℝ) → E) {p : ℝ} (hp : p ≠ 0),\n  (MeasureTheory.IntegrableOn (fun (x : ℝ) ↦ x ^ (p - 1) • f (x ^ p)) (Set.Ioi 0)) ↔\n    (MeasureTheory.IntegrableOn f (Set.Ioi 0)))", "theorem": "theorem MeasureTheory.integrableOn_Ioi_comp_rpow_iff' :\n    (∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (f : (a : ℝ) → E) {p : ℝ} (hp : p ≠ 0),\n      (MeasureTheory.IntegrableOn (fun (x : ℝ) ↦ x ^ (p - 1) • f (x ^ p)) (Set.Ioi 0)) ↔\n        (MeasureTheory.IntegrableOn f (Set.Ioi 0))) :=\n  by sorry", "name": "MeasureTheory.integrableOn_Ioi_comp_rpow_iff'", "lemma-type": "{E : Type u_1} → [NormedAddCommGroup E] → [NormedSpace ℝ E] → (f : (a : ℝ) → E) → {p : ℝ} → (hp : p ≠ 0) → 0 < |p|", "lemma": "theorem aux.11236243410504304211 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] (f : (a : ℝ) → E) {p : ℝ}\n    (hp : p ≠ 0) : 0 < |p| := by sorry", "doc_string": "The substitution `y = x ^ p` in integrals over `Ioi 0` preserves integrability (version\nwithout `|p|` factor) ", "generated": ["theorem And.right_comm : ∀ {a b c : Prop}, a ∧ (b ∧ c) ↔ a ∧ b ∧ c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α}, a = b → (c = a → c = b) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem measurable_rpow : ∀ {α : Type u} [inst : OrderedSemiring α] [inst_1 : HasRpow α], Measurable fun x xa => x ^ xa :=\n  by sorry ", "theorem LT.lt.ne' : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≠ b := by sorry ", "theorem norm_norm : ∀ {E : Type u_6} [inst : SeminormedGroup E] (a : E), ‖a‖ ≤ 1 * ‖a || := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : AddCommGroup α] {p : α} {a : α} {b : α} (a_1 : -a ≡ -b [PMOD p]), a ≡ b [PMOD p])", "theorem": "theorem AddCommGroup.ModEq.of_neg :\n    (∀ {α : Type u_1} [inst : AddCommGroup α] {p : α} {a : α} {b : α} (a_1 : -a ≡ -b [PMOD p]), a ≡ b [PMOD p]) := by\n  sorry", "name": "AddCommGroup.ModEq.of_neg", "lemma-type": "{α : Type u_1} →\n  [inst : AddCommGroup α] →\n    {p : α} →\n      {a : α} →\n        {b : α} →\n          {α : Type u_1} →\n            [AddCommGroup α] → {p : α} → {a : α} → {b : α} → ((∃ z, b - a = z • p) ↔ (∃ z, b - a = z • p)) = True", "lemma": "theorem aux.291755766342201518 {α : Type u_1} [inst : AddCommGroup α] {p : α} {a : α} {b : α} {α : Type u_1}\n    [AddCommGroup α] {p : α} {a : α} {b : α} : ((∃ z, b - a = z • p) ↔ (∃ z, b - a = z • p)) = True := by sorry", "doc_string": "**Alias** of the forward direction of `AddCommGroup.neg_modEq_neg`.", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.205517397809213096 {α : Type u_1} [inst : AddCommGroup α] {p : α} {a : α} {b : α} {α : Type u_1}\n    [AddCommGroup α] {p : α} {a : α} {b : α} (equiv : α ≃+  ZMod p) (ha : -a ≡ -b [PMOD p]) (p : ℕ) : ¬False := by\n  sorry ", "theorem Subtype.coe_eta : ∀ {α : Sort u_8} (s : Set α) (a : { x // p x }), ↑{ (a_1 : α) → p a_1 ↔ p a } a = a := by\n  sorry ", "theorem aux.2109441385939270504 {α : Type u_1} [inst : AddCommGroup α] {p : α} {a : α} {b : α} {α : Type u_1}\n    [inst : AddCommGroup α] {p : α} {a : α} {b : α} {α : Type u_1} [inst : AddCommGroup α] {p : α} {a : α} {b : α} :\n    ((a ≡ b [PMOD ↑p]) ↔ (a - b ≡ ↑0 [PMOD ↑p])) = ((a - b ≡ ↑0 [PMOD p]) ↔ (a ≡ b [PMOD p])) := by sorry ", "theorem AddCommGroup.ZMod.Int_cast_zsmul_eq :\n    ∀ (p₁ : ℕ), Int.cast (ZMod.rawcastZ p₁) • ZMod.rawcast ZMod.pow_two_pos p₁ ^ Nat.pred p₁ + 1 = ZMod p₁ := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem add_tsub_cancel_left : ∀ {α : Type u} [inst : AddCommSemigroup α] [inst_1 : SubSemigroup α] {a b c : α},\n      c + b ≤ a ↔ c + b ≤ a :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {n : ℕ} (p : Fin (n + 1)) (i : Fin n), (Fin.succAbove p i < p) ↔ (Fin.castSucc i < p))", "theorem": "theorem Fin.succAbove_lt_iff_castSucc_lt :\n    (∀ {n : ℕ} (p : Fin (n + 1)) (i : Fin n), (Fin.succAbove p i < p) ↔ (Fin.castSucc i < p)) := by sorry", "name": "Fin.succAbove_lt_iff_castSucc_lt", "lemma-type": "{n : ℕ} →\n  (p : Fin (n + 1)) →\n    (i : Fin n) →\n      (H : Fin.castSucc i < p) →\n        (h : (Fin.castSucc_lt_or_lt_succ p i) = (Or.inl H)) →\n          ((Fin.succAbove p i < p) ↔ (Fin.castSucc i < p)) = (Fin.succAbove p i < p)", "lemma": "theorem aux.4127422593707961131 {n : ℕ} (p : Fin (n + 1)) (i : Fin n) (H : Fin.castSucc i < p)\n    (h : (Fin.castSucc_lt_or_lt_succ p i) = (Or.inl H)) :\n    ((Fin.succAbove p i < p) ↔ (Fin.castSucc i < p)) = (Fin.succAbove p i < p) := by sorry", "doc_string": "Embedding `i : Fin n` into `Fin (n + 1)` using a pivot `p` that is greater\nresults in a value that is less than `p`. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Fin.lt_castSucc : ∀ {n δ : �âtL}  {n a : L (Fin r)} (ca := (_ : a < max n delta)) {j cj : Ordinal yIExp f}. castSucc a < Cj :=\n  by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem Trans.trans : ∀ {α : Sort u} {r : Trans α} {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem not_gt : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), ¬a < b ↔ b < a := by sorry ", "theorem finLtLtSelf : ∀ (n : ℕ) (i : Fin n), Fin.castSucc i < ⊤ := by sorry ", "theorem of_eq_false : ∀ {p : Prop}, p = False → False := by sorry ", "theorem Fin.succAbove_le : ∀ {n : ℕ} [h : Succ.Inj on n] {k p : Fin n} [h0 : 0 < p‶{ k, h0 => p.succAbove (_ : k < p) } < k] : 0 ∈ Finset.upₛc.card := by sorry "]}
{"theorem-type": "(IsFractionRing ℤ ℚ)", "theorem": "theorem Rat.isFractionRing : (IsFractionRing ℤ ℚ) := by sorry", "name": "Rat.isFractionRing", "lemma-type": "∀ {x : ℤ} {y : ℤ} (a : (algebraMap ℤ ℚ) x = (algebraMap ℤ ℚ) y), ∃ c, ↑c * x = ↑c * y", "lemma": "theorem aux.15005108236484445783 :\n    ∀ {x : ℤ} {y : ℤ} (a : (algebraMap ℤ ℚ) x = (algebraMap ℤ ℚ) y), ∃ c, ↑c * x = ↑c * y := by sorry", "doc_string": "The cast from `Int` to `Rat` as a `FractionRing`. ", "generated": ["theorem div_self_eq_self_mem : ∀ {G : Type u_3} [inst : DivInvMonoid G] (a : G), a / a = a ∅ := by sorry ", "theorem aux.04526781744862531434 : ∀ (x : ℚ), nonempty (isOpenMap Rat.cast ↑x) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem pow_cancel_of_primo_right : ∀ {R : Type u} [inst : MonoidWithZero R] {a : R} [pa : IsPrimo a] (n : nat),\n  a ^ n = a ^ 0 ^ n := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem le_of_isLT : ∀ {α : Type u} [inst : Preorder α] {a b : α}, IsLT a < b → a ≤ b := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem IsLocalization.algebraMap_eq_ratio_algebraMap :\n    ∀ (K H A : Type u) [inst : CommSemiring K] [inst_1 : CommSemiring H] [inst_2 : Algebra ↑K H] [inst_3 : Nontrivial K],\n      ∀ x : H, Ideal.adjoin (((IsFractionRing.algEquiv K + Rat.principalUnits K) › x • Algebra.latticeModule (eq := rfl)).unit, x)\n          ⅛ = (Rat.principalUnits A * A) ⊤ :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {s : Multiset α} (a : Multiset.Nodup s), Multiset.Nodup (Multiset.powerset s))", "theorem": "theorem Multiset.Nodup.powerset :\n    (∀ {α : Type u_1} {s : Multiset α} (a : Multiset.Nodup s), Multiset.Nodup (Multiset.powerset s)) := by sorry", "name": "Multiset.Nodup.powerset", "lemma-type": "{α : Type u_1} →\n  {s : Multiset α} →\n    {α : Type u_1} →\n      {s : Multiset α} →\n        (l : List α) →\n          (h : Multiset.Nodup ⟦l⟧) →\n            (Multiset.Nodup (Multiset.powerset ⟦l⟧)) = (List.Nodup (List.map Multiset.ofList (List.sublists' l)))", "lemma": "theorem aux.5624995388984064821 {α : Type u_1} {s : Multiset α} {α : Type u_1} {s : Multiset α} (l : List α)\n    (h : Multiset.Nodup ⟦l⟧) :\n    (Multiset.Nodup (Multiset.powerset ⟦l⟧)) = (List.Nodup (List.map Multiset.ofList (List.sublists' l))) := by sorry", "doc_string": "**Alias** of the reverse direction of `Multiset.nodup_powerset`.", "generated": ["theorem aux.15184138008244622679 {α : Type u_1} {s : Multiset α} {α : Type u_1} {s : Multiset α} (a : α)\n    (a : Multiset α) (t : Multiset ⦃𝒜 : Multiset (Set α)⦄) (x : a ∈ List.map id ↑t) :\n    ∑' (a : Set α), id ((alex_module.Quote.max a (s ⊆ Set.univ)) :: t.map Subtype.val).1 = Set.powerset.nocontinuous x :=\n  by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α} (h : a = b), a + c = b + c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem List.nodup_cons_iff :\n    ∀ {α : Type u} {l : List α}[s : Bool] (a : α), (Multiset.Nodup (a :: l)) ↔ (List.Nodup s × Multiset.Nodup l) := by sorry ", "theorem sub_zero : ∀ {G : Type u_3} [inst : SubTriangle G] (a : G), a - 0 = a := by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v} {r₁ r₂ : Sort w}, p₁ = p₂ → q₁ = q₂ → (r₁ = r₂ → p₁ = q₁) = ↑(r₁ = r₂) := by sorry ", "theorem aux.13959597523211971894 {α : Type u_1} {s : Multiset α} {α : Type u_1} {s : Multiset α} :\n    (Quot.mk Setoid (Multiset.powercycleEquiv s)) (Multiset.pairwise_deduced ↑Set.univ s) =\n      Multiset.nodup ((fun (x : Multiset α) ↦ (f ×ˢ f) ↑x) s) :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {γ : Type u_3} {β : Type u_4} [tβ : TopologicalSpace β] [inst : T2Space β] [inst : MeasurableSpace β]\n  {f : (a : γ) → β} [inst_1 : BorelSpace β] [inst_2 : TopologicalSpace γ] [inst_3 : PolishSpace γ]\n  [inst_4 : MeasurableSpace γ] [inst_5 : BorelSpace γ] (f_cont : Continuous f) (f_inj : Function.Injective f),\n  MeasurableEmbedding f)", "theorem": "theorem Continuous.measurableEmbedding :\n    (∀ {γ : Type u_3} {β : Type u_4} [tβ : TopologicalSpace β] [inst : T2Space β] [inst : MeasurableSpace β]\n      {f : (a : γ) → β} [inst_1 : BorelSpace β] [inst_2 : TopologicalSpace γ] [inst_3 : PolishSpace γ]\n      [inst_4 : MeasurableSpace γ] [inst_5 : BorelSpace γ] (f_cont : Continuous f) (f_inj : Function.Injective f),\n      MeasurableEmbedding f) :=\n  by sorry", "name": "Continuous.measurableEmbedding", "lemma-type": "{γ : Type u_3} →\n  {β : Type u_4} →\n    [TopologicalSpace β] →\n      [T2Space β] →\n        [MeasurableSpace β] →\n          {f : (a : γ) → β} →\n            [BorelSpace β] →\n              [TopologicalSpace γ] →\n                [PolishSpace γ] →\n                  [MeasurableSpace γ] →\n                    [BorelSpace γ] →\n                      (f_cont : Continuous f) →\n                        (f_inj : Function.Injective f) → (_u : Set γ) → (hu : MeasurableSet _u) → ContinuousOn f _u", "lemma": "theorem aux.1950750651488419117 {γ : Type u_3} {β : Type u_4} [TopologicalSpace β] [T2Space β] [MeasurableSpace β]\n    {f : (a : γ) → β} [BorelSpace β] [TopologicalSpace γ] [PolishSpace γ] [MeasurableSpace γ] [BorelSpace γ]\n    (f_cont : Continuous f) (f_inj : Function.Injective f) (_u : Set γ) (hu : MeasurableSet _u) : ContinuousOn f _u :=\n  by sorry", "doc_string": "An injective continuous function on a Polish space is a measurable embedding. ", "generated": ["theorem continuous_inducing_homeomorph_toInducing :\n    ∀ {α : Type u_1} {γ : Type u_3} {f : α → γ} (ind : Inducing f) (top : TopologicalSpace α) [inst : PolishSpace α],\n          ∃ t, Nonempty (HomeomorphToSource inducing indu) :=\n  by sorry ", "theorem continuous_def :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : TopologicalSpace α] [inst_2 : UniformSpace β]\n      [inst_3 : TopologicalSpace β] {f : α → β}, Continuous f = ∀ (i : β), ContinuousAt f i :=\n  by sorry ", "theorem filterOn.aemeasurable_iff_aemeasurable :\n    ∀ {m : Set Ω}✝ μ : CompactOuterMeasureOn (μ.restrict m) _ ν, μ.aemeasurable f → Q f rᶜ μ μ := by sorry ", "theorem continuous_closedBall :\n    ∀ {E : Type u_5} [inst : SeminormedAddGroup E] (r : ENNReal) (x : E), Continuous fun y => x +L r =ᶠက r ⁻¹ • y :=\n  by sorry ", "theorem Continuous.measurableEmbedding_natNat :\n    ∀ {γ : Type u_3}, MeasurableSpace γ → ∀ (f : Nat -> γ →ₗ{u : MeasurableSpace γ} ℕ),\n      TopologicalSpace.MeasurableEmbedding NatNatEmbeddings._mk' fun n => f n (Continuous.coe (@Continuous f h)) :=\n  by sorry ", "theorem continuousOn_of_t2Interval :\n    ∀ {α : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : LinearOrder γ]\n      [ctd : ClosedIicTopology γ] {tγ : AEMeasurableSet γ} {f : α → γ}\n      (h_eq : ↑tγ =� Š↓ Set.Icᶜ α) (a : ContinuousOn ((a : α) → f a.1)) ⦃a : α⦄.2, a ∉ tγ.2 ↔ (fun x => f x.1) (a, ↑{ val := Set.univ.1 }).1.b ≠ f default default := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem continuous_iff_measurable :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α]\n      [inst_2 : OpensMeasurableSpace α] [inst_3 : MeasurableSpace β] [inst_4 : BorelSpace β]\n      {f : α → β}, (Continuous f) ↔ (Measurable f) :=\n  by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n)", "theorem": "theorem Nat.four_pow_le_two_mul_self_mul_centralBinom : (∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n) :=\n  by sorry", "name": "Nat.four_pow_le_two_mul_self_mul_centralBinom", "lemma-type": "(x : ℕ) → (x_1 : 0 < x) → (x : 0 < 1) → (4 ≤ 4) = True", "lemma": "theorem aux.244997494213807550 (x : ℕ) (x_1 : 0 < x) (x : 0 < 1) : (4 ≤ 4) = True := by sorry", "doc_string": "An exponential lower bound on the central binomial coefficient.\nThis bound is weaker than `Nat.four_pow_lt_mul_centralBinom`, but it is of historical interest\nbecause it appears in Erdős's proof of Bertrand's postulate.\n", "generated": ["theorem Nat.zero_le_succ : ∀ (m : ℕ), 0 ≤ Nat.succ m := by sorry ", "theorem lt_of_le_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c := by sorry ", "theorem Int.sq_eq_pow_expCharge : ∀ (n : ℤ), ↑n ^ 2 = (Nat.sqrt n :: ℕ).pow (Int.sq_gt n) (Nat.lt_le_rat_of_one.symm) ≤ 1 := by sorry ", "theorem pow_four : ∀ {R : Type u_1} [inst : CommSemigroup R] [inst_1 : MonoidWithZero R] (a : R), a ^ 4 = a ^ 2 * a ^ 2 := by\n  sorry ", "theorem zero_lt_four : ∀ {n : ℕ}, 0 < 4 := by sorry ", "message:\nsub_2 : True := by sorry ", "theorem Nat.cast_pos :\n    ∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : ExistsAddOfLE α] {m : ℕ}, 0 < m → 0 < ↑m := by sorry ", "theorem one_dtuple : ∀ (k : ℕ), (↑∀ (i : Fin k), 1) = Nat.binaryRec 1 1 fun w => 1 := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : LinearOrderedRing R] {a : R} (H : -2 ≤ a) (n : ℕ), 1 + ↑n * a ≤ (1 + a) ^ n)", "theorem": "theorem one_add_mul_le_pow :\n    (∀ {R : Type u_1} [inst : LinearOrderedRing R] {a : R} (H : -2 ≤ a) (n : ℕ), 1 + ↑n * a ≤ (1 + a) ^ n) := by sorry", "name": "one_add_mul_le_pow", "lemma-type": "{R : Type u_1} → [LinearOrderedRing R] → {a : R} → (H : -2 ≤ a) → (n : ℕ) → 0 ≤ 2 + a", "lemma": "theorem aux.899506979388075774 {R : Type u_1} [LinearOrderedRing R] {a : R} (H : -2 ≤ a) (n : ℕ) : 0 ≤ 2 + a := by sorry", "doc_string": "**Bernoulli's inequality** for `n : ℕ`, `-2 ≤ a`. ", "generated": ["theorem one_AddOn.add : Nat.cast on_add on = add on × on := by sorry ", "theorem le_pow_pred_iff_le_of_le_one :\n    ∀ {a : ℝ} {k : ℕ}, 0 < a → a ≤ 1 → (k + 1) ∈ Finset.range k → a ^ { val := ((k + 1)), isLt := ((H)) } = a ^ k ∩ a ≤ a)^\n            0 =>\n      True and (∀ (n : ℕ) (t_1 : NNReal) (x : t_1 ∈ Finset.range (n + 1)), a ≤ ListNodus.coeffH x t_1) → n + k < n + n + 1 + f :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem one_lt_trans : ∀ {α : Type u_1} [inst : LinearOrder α] {a b c : α} [inst_1 : Ne Ne]) [inst_2 : Fact (0 = 0)],\n    a < 2 ⊓ a < c → a + 2 < c → a < b → a < c → a < (a / 2 + b * a + a), a < b × a + (b * b + |a x ∗ a|) * |a | :=\n  by sorry ", "theorem one_one : 1 + 1 = 2 := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem aux.11695232267643909191 {R : Type u_1} [LinearOrderedRing R] {a : R} (H : -2 ≤ a) (n : ℕ) (n_1 : ℕ) (h : n = Nat.succ n_1)\n    : Complex.exp (↑(n_1) * (Real.log (1 + a))) * Real.exp { val := ((0)), sqrt := 1 |}.1 = ↑0.5 ^ ↑n_1 := by sorry ", "argument 4 : Nat.rawCast 1 * Nat.rawCast 1 = Nat.rawCast 1 := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] [h : Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))] (n : ℕ+), IsUnit ↑↑n)", "theorem": "theorem EqualCharZero.PNat.isUnit_natCast :\n    (∀ {R : Type u_1} [inst : CommRing R] [h : Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))] (n : ℕ+),\n      IsUnit ↑↑n) :=\n  by sorry", "name": "EqualCharZero.PNat.isUnit_natCast", "lemma-type": "∀ {R : Type u} [inst : CommRing R] {a : R} {I : Ideal R}, (Ideal.Quotient.mk I) a = 0 ↔ a ∈ I", "lemma": "theorem Ideal.Quotient.eq_zero_iff_mem :\n    ∀ {R : Type u} [inst : CommRing R] {a : R} {I : Ideal R}, (Ideal.Quotient.mk I) a = 0 ↔ a ∈ I := by sorry", "doc_string": "Internal: Not intended to be used outside this local construction. ", "generated": ["theorem aux.18677445534328377333 {R : Type u_1} [CommRing R]\n    [Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))] (n : ℕ+) : CharZero (↥↑↑n) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Fact (p : ℕ) (a : Fact (¬(p < p))) : IsUnit.unit n' := bySorry ", "theorem aux.5386568902566939911 {R : Type u_1} [CommRing R] [Fact (∋ U : Ideal R → Prop, ∀ (_ : R ⧸ U), Pseudosemiring.Char zero (R ⧸ U))]\n    (x : PrimeSpectrum R) (q : ℚ) : IsLocalization (Subtype.val.restrict q) : AtPrime (Subtype.val.restrict q) := by\n  sorry ", "theorem PrimeMaximalIdeal.isUnit_int_cast_coe :\n    ∀ (I : PrimeMaximalIdeal R) (n : ℕ), isUnit ↑↑n := by sorry ", "theorem Units.exists_mul_eq_not_uniform :\n    ∀ {{R : Type u_1} [inst : DomRectangularSet (Rˣ) R] (x t : ℂ) ⦃hx₁ : x ∈ {⅁} ⋀ hx₂ : x * t * t ∈ Re(↑x)ᶜ),\n      ‖t * ↑x‖ ^ 4 < (real : Set ℝ)ᶜᶜ → IsUnit t :=\n  by sorry ", "theorem aux.14448811078602926169 {R : Type u_1} [CommRing R] [Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))]\n    (n : ℕ+) : 1 ≠ 0 := by sorry ", "theorem Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0 := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} (c₁ : R) (c₂ : R), Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4)", "theorem": "theorem Cardinal.mk_quaternionAlgebra :\n    (∀ {R : Type u_1} (c₁ : R) (c₂ : R), Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4) := by sorry", "name": "Cardinal.mk_quaternionAlgebra", "lemma-type": "{R : Type u_1} →\n  (c₁ : R) →\n    (c₂ : R) →\n      (Cardinal.mk R ^ Nat.rawCast 1 * Nat.rawCast 1) ^ Nat.rawCast 4 = Cardinal.mk R ^ Nat.rawCast 4 * Nat.rawCast 1", "lemma": "theorem aux.14009774223768696161 {R : Type u_1} (c₁ : R) (c₂ : R) :\n    (Cardinal.mk R ^ Nat.rawCast 1 * Nat.rawCast 1) ^ Nat.rawCast 4 = Cardinal.mk R ^ Nat.rawCast 4 * Nat.rawCast 1 :=\n  by sorry", "doc_string": "The cardinality of a quaternion algebra, as a type. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Cardinal.one_def : Cardinal.one = 1 := by sorry ", "theorem aux.1993895030759955011 {R : Type u_1} (c₁ : R) (c₂ : R) : Nat.rawCast 2 = Nat.rawCast 2 ^ Nat.rawCast 1 *\n      1 := by sorry ", "theorem map_inv₀ :\n    ∀ {α : Type u} {k : DividendMonoid k} [inst : Invertible 1] (f : (a : α)*κ →ể⋆₊ᵢ (α → k)ᵒᵖ) {b : α} {n : ℕ} (b_1 : b^{-1} * v b = h₁ * k b), f (StarAddUnit.inv₂ h₁ * (StarUnitIsSelf.unit 1 * v b · b * f b x ·)) =\n      (f.toAddMonoidHom ∘ₗ\n          (IsUnit.unitMulₗ fun h₁ : { b : k[(fun (ihp : b * k = k) ↦ true)(fun (ihp : b = a) ↦ a × a k) | true} → b } n)(StarAddUnit.coeUnit)!! /\n            finprod fun h i b ↦ Isunit.finsupEquiv { val := ((b)), property := (((Isunit.mul_left_inv f n I)), I)) =\n        h₂ fun j₁ => f ((StarUnit.coeUnit · I) a * b _j₁ → b _j₁ · a → β)) :=\n  by sorry\n``` [/INST] theorem aux.5370086542510676299 {α : Type u} {k : DividendMonoid k} [Invertible 1]\n    (comm : BijOn ((x, y) ↦ g y * x * g⁻¹ x) ((fun (p : (c : DividendMonoid.InvertibleElement k) × DivisionRing w → (I₂ I b + f (a • I) (I₂ 0 v))) ↦ (a₁ • I₂ I), a₂ • I₂ 0) w • I => P0 b) ↑1)\n    ⦃f : Quaternion B → Fintype.card { x i0, x i1 ij, x w /* y hy xhy ≠ 0 ↦ x x * y • y hy xhy */; ↪ₐ[A] T z Iₕ φ :=\n      f₅) {N₁ : Subgroup N}.subset N₁ :=\n  by sorry ", "theorem aux.12057332406474839316 {R : Type u_1} (c₁ : R) (c₂ : R) : Cardinal.infinite ≠ 0 := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(MeasureTheory.LocallyIntegrableOn zetaKernel₂ (Set.Ioi 0))", "theorem": "theorem locally_integrable_zetaKernel₂ : (MeasureTheory.LocallyIntegrableOn zetaKernel₂ (Set.Ioi 0)) := by sorry", "name": "locally_integrable_zetaKernel₂", "lemma-type": "(k : Set ℝ) → (hk : k ⊆ Set.Ioi 0) → (hk' : IsCompact k) → Set.Ioc 0 1 ∩ k = Set.Icc 0 1 ∩ k", "lemma": "theorem aux.3340914666321097495 (k : Set ℝ) (hk : k ⊆ Set.Ioi 0) (hk' : IsCompact k) :\n    Set.Ioc 0 1 ∩ k = Set.Icc 0 1 ∩ k := by sorry", "doc_string": "Local integrability of `zetaKernel₂`. ", "generated": ["theorem funext : ∀ {α : Sort u} {φ : α → Sort v} {f g : (a : α) → φ a}, (∀ (a : α), f a = g a) → f = g := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α}, a = b → (c = a ↔ c = b) := by sorry ", "theorem sub_add_cancel : ∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a - a + b = b := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem fun_like.field_aestimates_eq_of_locally_aestimate_and_aestrimate :\n    ∀ {K : Type u_6} {V E' : Type u_3} [instE : BanachSpace E'] {l : Filter T},\n      (Filter.IsLittleO l fun t => dist (constVAdd c t) 0) → ∀ f r t, Filters.LocallyIntegrableAt r f t :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem MeasureTheory.mem_mulSupport' :\n    ∀ {M : Type u_2} {E : Type u_1} [E : MeasurableSpace M] [inst : SemilatticeSup M]\n      [a : OrderBot M] {μ : MeasureTheory.Measure M} {f : M} {w : ℩} (hs : MeasureTheory.HasFiniteMeasureAt s μ),\n      f w * ↑m ≤ ↑μ (s ×ˢ μ MeasureTheory.Measure.isProbabilityMeasure (f w, μ ≤ hs) w) → w ∂μ ≠ ⊥ :=\n  by sorry "]}
{"theorem-type": "(∀ {R : Type u_6} {A : Type u_7} [inst : Monoid A] [inst_1 : SMul R A] [inst_2 : IsScalarTower R A A]\n  [inst_3 : TopologicalSpace A] [inst : ContinuousMul A], ContinuousConstSMul R A)", "theorem": "theorem IsScalarTower.continuousConstSMul :\n    (∀ {R : Type u_6} {A : Type u_7} [inst : Monoid A] [inst_1 : SMul R A] [inst_2 : IsScalarTower R A A]\n      [inst_3 : TopologicalSpace A] [inst : ContinuousMul A], ContinuousConstSMul R A) :=\n  by sorry", "name": "IsScalarTower.continuousConstSMul", "lemma-type": "{R : Type u_6} →\n  {A : Type u_7} →\n    [Monoid A] →\n      [SMul R A] →\n        [IsScalarTower R A A] →\n          [TopologicalSpace A] → [ContinuousMul A] → (q : R) → (fun (x : A) ↦ q • x) = fun (x : A) ↦ q • 1 * x", "lemma": "theorem aux.2495460109433614928 {R : Type u_6} {A : Type u_7} [Monoid A] [SMul R A] [IsScalarTower R A A]\n    [TopologicalSpace A] [ContinuousMul A] (q : R) : (fun (x : A) ↦ q • x) = fun (x : A) ↦ q • 1 * x := by sorry", "doc_string": "If `R` acts on `A` via `A`, then continuous multiplication implies continuous scalar\nmultiplication by constants.\n\nNotably, this instances applies when `R = A`, or when `[Algebra R A]` is available. ", "generated": ["theorem continuously_map_mul :\n    ∀ {F : Type u_3} {M(: M fintype) := _} {x y : Type u_2 → M fintype} [inst_2 : DivInvMonCat M] [inst_3 : F int := ⊤]\n      (f : F), Continuous fun p h => p.1 / p.2 - x h ⊆ y h ↦ MultilinearMap.piSubmonoidFinsupp (continuousMul.contFun F M y) p :=\n  by sorry ", "theorem continuous_mulLeft :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : Mul α] [inst_1 : ContinuousMul α] (a : α),\n      Continuous (Function.mulLeft a) :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem smul_coe :\n    ∀ {R : Type m} {A : Type n} [inst : AddMonoidActionLinear R' ↥A],AddSubmonoid.closure ↑S = SubmonoidOpposite.unop ↑S := by\n  sorry ", "theorem ext : ∀ {α : Sort u} {β : Sort v} {f g : α → β}, (∀ (a : α), f a = g a) → f = g := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrFun : ∀ {α : Sort u} {β : α → Sort v} {x y : α}, (∀ (a : α), x a = y a) → x = y := by sorry ", "theorem continuous_id : ∀ {X : Type u_1} [inst : TopologicalSpace X], Continuous id := by sorry "]}
{"theorem-type": "(∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0)", "theorem": "theorem WithLp.prod_edist_self :\n    (∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n      (f : WithLp p (α × β)), edist f f = 0) :=\n  by sorry", "name": "WithLp.prod_edist_self", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ", "generated": ["theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem And.left_not_left : ∀ {a b : Prop}, ¬a ∨ b → ¬a ↪ b := by sorries ", "theorem edist_comm : ∀ {α : Type u} [inst : PseudoEMetricSpace α] (a b : α), edist a b = edist b a := by sorry ", "theorem WithLp.$ext : ∀ {G : Type u_3} {α : Type u_4} [inst : PseudoEMetricSpace G] ⦃p : ENNReal⦄ (a b : WithLp p α), a = b → a = b := by sorry ", "theorem forall_prop_of_forall₂_prop :\n    ∀ {p q a a_1 : Prop} (H : a_1 = a) (c : q = p), H → (∀ (n : p), q n) = ∀ (hn : n = a1), p n := by sorry ", "theorem zero_eq : ∀ {M : Type u_2} [inst : MulZeroOneClass M] [inst_1 : HasActiveCodes ℕ M] (0 : M), 0 = 0 := by sorry "]}
{"theorem-type": "(∀ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ℕ) [inst_2 : CharP R p] (hp : p ≠ 2),\n  Polynomial.cyclotomic' 2 R = Polynomial.X + 1)", "theorem": "theorem Polynomial.cyclotomic'_two :\n    (∀ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ℕ) [inst_2 : CharP R p] (hp : p ≠ 2),\n      Polynomial.cyclotomic' 2 R = Polynomial.X + 1) :=\n  by sorry", "name": "Polynomial.cyclotomic'_two", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "The second modified cyclotomic polyomial is `X + 1` if the characteristic of `R` is not `2`. ", "generated": ["theorem isPrimitiveRoot_zero :\n    ∀ (S : UniqFactorizedElement Sø), multiplicity ↑sø (↑sø ^ n - 1) < n  ∧ Irred ∣ (↑sø ^ n - 1) { right • Int.not_prime_one } :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "answer:\n4696981282754090604 {R : Type u_2} [CommRing R] [IsDomain R] (p : ℕ) [Fact (Nat.Prime p)] [CharP R p]\n    (hp : p ≠ 2) : Mathlib.Covers ?L <| Subterm.zero ⊢ Polynomial.IsRoot.natDegree₀ (Int.castRingHom (ZMod - 1)) 𝚿 (Polynomial.C (↑1))) := by sorry ", "theorem List.mem_cons_self'' :\n    ∀ {α : Type u_1} {a : α} {l : List α}, a ∈ a :: l ↔ a ∈ l := by sorry ", "theorem aux.845189741150447358 (R : Type u_2) [CommRing R] [IsDomain R] (p : ℕ) [CharP R p] (hp : p ≠ 2) (x : R)\n    (y : R) (hy : (Polynomial.map (Int.castRingHom ℤ) ↑((Polynomial.scalarOf R ℤ) (-1))) y = -1) (b : ZMod p) :\n    (∫ (x_1 : ZMod p),\n        1 • if h : (Polynomial.X - 1) ↑₀ = 0 then ↑b else if (0 ≠ 0) then 0 else ↑(x_1 * 1)).1 = p / 2 :=\n  by sorry ", "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMonoid G] (a b : G), a * b = b * a := by sorry ", "answer:\n3702398746612909813 {R : Type u_2} [CommRing R] [IsDomain R] (p : ℕ) [CharP R p] (hp : p ≠ 2) :\n    ¬(~~true) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\n  (Set.OrdConnected s) ↔ (∀ (x : α) (a : x ∈ s) (y : α) (a : y ∈ s) (a : x ≤ y), Set.Icc x y ⊆ s))", "theorem": "theorem Set.ordConnected_iff :\n    (∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\n      (Set.OrdConnected s) ↔ (∀ (x : α) (a : x ∈ s) (y : α) (a : y ∈ s) (a : x ≤ y), Set.Icc x y ⊆ s)) :=\n  by sorry", "name": "Set.ordConnected_iff", "lemma-type": "{α : Type u_1} →\n  [Preorder α] →\n    {s : Set α} →\n      ∀ (hs : ∀ ⦃x : α⦄ (x_1 : x ∈ s) ⦃y : α⦄ (x_2 : y ∈ s), Set.Icc x y ⊆ s) (x : α) (hx : x ∈ s) (x_1 : α)\n        (hy : x_1 ∈ s) (x_2 : x ≤ x_1), Set.Icc x x_1 ⊆ s", "lemma": "theorem aux.15508184175050569328 {α : Type u_1} [Preorder α] {s : Set α} :\n    ∀ (hs : ∀ ⦃x : α⦄ (x_1 : x ∈ s) ⦃y : α⦄ (x_2 : y ∈ s), Set.Icc x y ⊆ s) (x : α) (hx : x ∈ s) (x_1 : α)\n      (hy : x_1 ∈ s) (x_2 : x ≤ x_1), Set.Icc x x_1 ⊆ s :=\n  by sorry", "doc_string": "It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. ", "generated": ["theorem forall_congr : ∀ {a b : Sort u_1} {p q : a → b → Prop}, (∀ (x : a) (y : b), p x y) ↔ ∀ (x : a) (y : b), q x y := by\n  sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Set.ordConnected : Type u => Con\n  -- deriving toSetLike Congr\n  (con ?a : Set {\\x : α /// x >= x},\n    α [inst : Ring H] → Con.closure {p | ―(x < p)}, Set α) : by sorry ", "theorem Subtype.property : ∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem eq_comm : ∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a := by sorry ", "theorem of_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a < max a b := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n  (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (n : ℕ),\n  ↑↑μ {x : α | (x ∈ s) ∧ (∀ (m : ℕ) (a : m ≥ n), f^[m] x ∉ s)} = 0)", "theorem": "theorem MeasureTheory.Conservative.measure_mem_forall_ge_image_not_mem_eq_zero :\n    (∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n      (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (n : ℕ),\n      ↑↑μ {x : α | (x ∈ s) ∧ (∀ (m : ℕ) (a : m ≥ n), f^[m] x ∉ s)} = 0) :=\n  by sorry", "name": "MeasureTheory.Conservative.measure_mem_forall_ge_image_not_mem_eq_zero", "lemma-type": "{α : Type u_2} →\n  [MeasurableSpace α] →\n    {f : (a : α) → α} →\n      {s : Set α} →\n        {μ : MeasureTheory.Measure α} →\n          (hf : MeasureTheory.Conservative f μ) →\n            (hs : MeasurableSet s) →\n              (n : ℕ) →\n                (H : ¬(↑↑μ {x : α | (x ∈ s) ∧ (∀ (m : ℕ) (a : m ≥ n), f^[m] x ∉ s)} = 0)) →\n                  (i : ℕ) → {x : α | ∀ (i_1 : i ≥ n), f^[i] x ∉ s} = ⋂ (_ : i ≥ n), {x : α | f^[i] x ∉ s}", "lemma": "theorem aux.16617835941547167964 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (n : ℕ)\n    (H : ¬(↑↑μ {x : α | (x ∈ s) ∧ (∀ (m : ℕ) (a : m ≥ n), f^[m] x ∉ s)} = 0)) (i : ℕ) :\n    {x : α | ∀ (i_1 : i ≥ n), f^[i] x ∉ s} = ⋂ (_ : i ≥ n), {x : α | f^[i] x ∉ s} := by sorry", "doc_string": "Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`, the set\nof points `x ∈ s` such that `x` does not return to `s` after `≥ n` iterations has measure zero. ", "generated": ["theorem aux.6011107846228263286 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (n : ℕ) :\n    Fintype.card { y : α // y ∈ f{ u : α // FunLike.coe ∘ Subtype.val y ∈ s f ^[u] '∅ } \\ {x : α // x ∈ s} } =\n      ↑((Set.PairwiseDisjoint s f ^[n]) f⁻¹) :=\n  by sorry ", "theorem ENNReal.tsum_ne_top_imp_summable' :\n    ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : ENNReal.TopologicalSpace β]\n      [inst_1 : ENNReal.HasBasis Bot.zero (fun a => 0 < a) (fun a => a • енн실.toReal a) fun c x => c.toNNReal * x],\n      Summable fun n => NeNNReal.toNum (↑(ENNReal.ofNNReal n)) = ⊤ → ∀ (b : β), ∃ a, b.value < a :=\n  by sorry ", "theorem Nat.one_le_iff : ^(Nat.succ n) = Nat.one ↔ Nat.le_one (x := n) =>\n  by sorry ", "theorem aux.8617057339300234080 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (n : ℕ) :\n    ↑↑μ (f ^ n '' s ∩ isAddUnit αInventory \\ ⋃ k, fun (x : αInventory n ↦ (ToSigmaUnit.fromNat'' n x.2.a)⁻¹)) = 0 := by\n  sorry ", "theorem MeasureTheory.Conservative.ae_mem_gt_image_iff_symm_inv :\n    ∀ {α : Type u_3} {m : MeasurableSpace α} {u : α → α} {μ : MeasureTheory.Measure α} (hμ : μ ≠ ⊤), ∀ᵐ x ∂μ |x| = x\n      → Function.AE.image u⁻¹ {\"a | u^[n a] a ∉ {x | u^[n x] x ⊢ x ≤ a}}} ≠ {x | u^[n x] x ⊢ x < a}) :=\n  by sorry\n``` [/INST] theorem Set.image_union ::\n    ∀ {α : Type u_1} {β : Type u_2} (f : α → β) (s₁ s₂ : Set α), f '' (s₁ ∪ s₂) = f '' s₁ ∪ f '' s₂ := by sorry ", "therapist: answer [/INST] theorem congrArg : ↍(φ : α → β) {x y : α} ; (x = y) → ∀ (a : α), φ x = φ y := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Ne.imp_rhs : ∀ {a b c : Prop}, a ≠ b → (b → c) → a → c := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x : V) (y : V),\n  (‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ (InnerProductGeometry.angle x y = Real.pi / 2))", "theorem": "theorem InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x : V) (y : V),\n      (‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ (InnerProductGeometry.angle x y = Real.pi / 2)) :=\n  by sorry", "name": "InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Pythagorean theorem, subtracting vectors, if-and-only-if vector angle form. ", "generated": ["theorem sq_eq_zero : ∀ {Mᵤ : Type u_2} [m : MulOneClass Mᵤ] ⦃a : Mᵤ⦄ [inst : NeZero a], a ^ 2 = 0 ↔ a = 0 := by sorry ", "theorem IsROrC.norm_re' :\n    ∀ {K : Type u_1} [inst : IsROrC K] (c : K), ‖Complex.re c‖ ≤ MAX (‖Real.re c‖) ‖Int.re c‖ := by sorry ", "theorem Nat.cast_add : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] ⦃m n : ℕ-, ↑(m + n) = ↑m + ↑n := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem eq_neg_ neg_nonneg : ∀ {α : Type u} [inst : LinearOrderedAddCommGroup α] (a : α), a = -a ↔ 0 ≤ a := by sorry ", "theorem mul_assoc : ∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c) := by sorry ", "theorem InnerProductGeometry.angle_comm :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n      InnerProductGeometry.angle x y = InnerProductGeometry.angle y x :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R},\n  ((IsRegular (a * b)) ∧ (IsRegular (b * a))) ↔ ((IsRegular a) ∧ (IsRegular b)))", "theorem": "theorem isRegular_mul_and_mul_iff :\n    (∀ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R},\n      ((IsRegular (a * b)) ∧ (IsRegular (b * a))) ↔ ((IsRegular a) ∧ (IsRegular b))) :=\n  by sorry", "name": "isRegular_mul_and_mul_iff", "lemma-type": "∀ {R : Type u_1} [inst : Mul R] {c : R}, IsRegular c → IsLeftRegular c", "lemma": "theorem IsRegular.left : ∀ {R : Type u_1} [inst : Mul R] {c : R}, IsRegular c → IsLeftRegular c := by sorry", "doc_string": "Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. ", "generated": ["theorem mul_left_comm : ∀ {G : Type u_1} [inst : Semigroup G] (a b : G), a * b = b * a := by sorry ", "theorem isRegular_def :\n    ∀ {R : Type u_1} [inst : Mul R] (a : R), IsRegular a ↔ HasSuspend4.sqrtd a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem left_comm : ∀ {G : Type u_3} [inst : Commmagma G] (a b c : G), a * b * c = a * c * b := by sorry ", "theorem aux.9976661793630498078 {R : Type u_1} [Semigroup R] {a : R} {b : R} :\n    ((IsRegular a) ↔ (∃ x y, (x * a = y) ∧ (a * y = x))) = True := by sorry ", "theorem aux.1344033142838865288 {R : Type u_1} [Semigroup R] {a : R} {b : R} : a ∈ ↥a * b := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : (a : α) → β} (hf : IsRingHom f) {γ : Type u_1}\n  [inst_2 : Ring γ] {g : (a : β) → γ} (hg : IsRingHom g), IsRingHom (g ∘ f))", "theorem": "theorem IsRingHom.comp :\n    (∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : (a : α) → β} (hf : IsRingHom f) {γ : Type u_1}\n      [inst_2 : Ring γ] {g : (a : β) → γ} (hg : IsRingHom g), IsRingHom (g ∘ f)) :=\n  by sorry", "name": "IsRingHom.comp", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [Ring α] →\n      [Ring β] →\n        {f : (a : α) → β} →\n          (hf : IsRingHom f) →\n            {γ : Type u_1} →\n              [Ring γ] → {g : (a : β) → γ} → (hg : IsRingHom g) → (x : α) → (y : α) → f (x * y) = f x * f y", "lemma": "theorem aux.3088512018158619374 {α : Type u} {β : Type v} [Ring α] [Ring β] {f : (a : α) → β} (hf : IsRingHom f)\n    {γ : Type u_1} [Ring γ] {g : (a : β) → γ} (hg : IsRingHom g) (x : α) (y : α) : f (x * y) = f x * f y := by sorry", "doc_string": "The composition of two ring homomorphisms is a ring homomorphism. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem map_add :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : FunLike F M N] [inst_1 : AddZeroClass M]\n      [inst_2 : AddZeroClass N] [inst_3 : AddConEdWithZero M] [inst_4 : AddConEdWithZero N] [inst_5 : FarRightOpposite M N]\n      [inst_6 : FarRemOppositeHom Classical.oppl R M N] (f : F) (x y : M), f (x + y) = f x + f y :=\n  by sorry ", "theorem IsRingHom.map_one :\n    ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S) [inst_2 : Nontrivial R], f 1 = 1 := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem IsRingHom.map_sub :\n    ∀ {R : Type u} [inst : Ring R] {γ : Type u_2} [inst_1 : Ring γ] {f : R →+* γ} (r s : R), f (r - s) = f r - f s :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem add_one_mul : ∀ {α : Type u} [inst : StrictOrderedSemiring α] [inst_1 : ExistsAddOfTotal α] (a : α), 1 * a = a :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α)", "theorem": "theorem ConditionallyCompleteLinearOrderedField.to_archimedean :\n    (∀ {α : Type u_2} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α) := by sorry", "name": "ConditionallyCompleteLinearOrderedField.to_archimedean", "lemma-type": "{α : Type u_2} →\n  [ConditionallyCompleteLinearOrderedField α] →\n    (h : ¬(∀ (x : α), ∃ n, x < ↑n)) →\n      (x : α) →\n        (h : ∀ (n : ℕ), ↑n ≤ x) →\n          sSup (Set.range fun (i : ℕ) ↦ ↑i) - 1 =\n            Int.rawCast (Int.negOfNat 1) + (sSup (Set.range fun (i : ℕ) ↦ ↑i) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)", "lemma": "theorem aux.16535010243156399687 {α : Type u_2} [ConditionallyCompleteLinearOrderedField α]\n    (h : ¬(∀ (x : α), ∃ n, x < ↑n)) (x : α) (h : ∀ (n : ℕ), ↑n ≤ x) :\n    sSup (Set.range fun (i : ℕ) ↦ ↑i) - 1 =\n      Int.rawCast (Int.negOfNat 1) + (sSup (Set.range fun (i : ℕ) ↦ ↑i) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) :=\n  by sorry", "doc_string": "Any conditionally complete linearly ordered field is archimedean. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem IsLeast.add_add ⇒ ∀ {s t : ι}; Or (Finset.Icc s t ∩ s ∩ ⋃ x ∈ s, {c | c < x} @ Set.Ici t = ∅} := by sorry ", "theorem condensed.archimedean :\n    ∀ {F : NNReal} [r : NNReal](a_1 : r = ⊤), Archimedean (r • NNReal) := by sorry ", "theorem not_lt_of_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α], a < b → ¬a ≤ b := by sorry ", "theorem aux.14163844471301398266 :\n    ∀ (a_1 : α) (c : α) (h : c < a_1),\n      ∃ b, (b ∈ Set.Ioi c) ∧ (2 * b ≤ .card (Set.Icc c a_1)) :=\n  by sorry ", "theorem exists_prop_congr_left :\n    ∀ {p : Prop} {q : p → Prop}, (∀ (x : p), q x) → ∀ (w : p), W ▶ q w := fun {p : Prop} {q : p → Prop}\n      (h : ∀ (x : p), q x) {w : p} : (¬q w) ⇒ ∃ (-w : p), ∁ (_x : True), True := by sorry ", "theorem lt_trans_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, a < b → b < c → a < c := by sorry ", "theorem ENNReal.add_inequality_of_two_inequiv :\n    ∀ {b : ENNReal}, b = ⊤ ∨ ∀ m₁ m₂ b₁ b₂, m₁ < b₁ → m₂ < b₂ → |b₁ - b₁| < |b₂ - b1| := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] {s : Finset β} (H : s.Nonempty) (f : (a : β) → α) {a : α}\n  (a_1 : ∀ (b : β) (a_1 : b ∈ s), f b ≤ a), Finset.sup' s H f ≤ a)", "theorem": "theorem Finset.sup'_le :\n    (∀ {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] {s : Finset β} (H : s.Nonempty) (f : (a : β) → α) {a : α}\n      (a_1 : ∀ (b : β) (a_1 : b ∈ s), f b ≤ a), Finset.sup' s H f ≤ a) :=\n  by sorry", "name": "Finset.sup'_le", "lemma-type": "{α : Type u_2} →\n  {β : Type u_3} →\n    [inst : SemilatticeSup α] →\n      {s : Finset β} →\n        (H : s.Nonempty) →\n          (f : (a : β) → α) →\n            {a : α} →\n              {α : Type u_2} →\n                {β : Type u_3} →\n                  [inst : SemilatticeSup α] →\n                    {s : Finset β} →\n                      (H : s.Nonempty) → (f : (a : β) → α) → {a : α} → (b : β) → (f b ≤ a) = (↑(f b) ≤ ↑a)", "lemma": "theorem aux.2783132830011046256 {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] {s : Finset β} (H : s.Nonempty)\n    (f : (a : β) → α) {a : α} {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] {s : Finset β} (H : s.Nonempty)\n    (f : (a : β) → α) {a : α} (b : β) : (f b ≤ a) = (↑(f b) ≤ ↑a) := by sorry", "doc_string": "**Alias** of the reverse direction of `Finset.sup'_le_iff`.", "generated": ["theorem Forall.exists_or_false : ∀ {α : Sort u_4} (p : α → Prop) (q : q ↔ p), ∃ a, q a ∨ False := by sorry ", "theorem forall_trunc γ → γ = nil := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem iSup_single_eq :\n    ∀ {α : Type u_1} {ι : Sort u_₀} (v : ι × α), iSup ((v.1), (v.2))\n        = Sup (iSup fun x => Finset.piecewise le x Not.empty) :=\n  fun ({ι : Sort u_0} ((x : ι) : α) (h : x ∈ Finset.univ) : Finset.univ = {i × ai := ⟨⟨i, h ⟩, hi⟩ | i × ai := ↑h ≠ ⊖} :=\n  by sorry ", "theorem Finset.sup'_minimal :\n    ∀ {α : Type u} {β : Type v} [inst : LinearOrder β] [inst_1 : One β] [inst_2 : Top β] {s : Finset α} {a : α},\n      IsGreatest (insert a s) s (Finset.sup' (insert a s) h → Finset.sup' s h = Finset.sup' s h) ↔\n        (finsetCoe eff s).Val ⟨a, Multiset.max_of_mem (Finset.mem_insert_of_mem h)⟩ :=\n  by sorry ", "theorem of_eq : ∀ {α : Sort u}, ∀ (a b : α), a = b → Ops.isNormal a = Ops.isNormal b := by sorry ", "theorem Finset.univ_cons : ∀ {α : Type u_1} (a : α), Finset.univ = insert a Finset.univ := by sorry ", "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry "]}
{"theorem-type": "(∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ)\n  (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b), jacobiSym a b = χ ↑b)", "theorem": "theorem jacobiSym.value_at :\n    (∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ)\n      (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b),\n      jacobiSym a b = χ ↑b) :=\n  by sorry", "name": "jacobiSym.value_at", "lemma-type": "∀ {n p : ℕ}, p ∈ Nat.factors n → Nat.Prime p", "lemma": "theorem Nat.prime_of_mem_factors : ∀ {n p : ℕ}, p ∈ Nat.factors n → Nat.Prime p := by sorry", "doc_string": "If `χ` is a multiplicative function such that `J(a | p) = χ p` for all odd primes `p`,\nthen `J(a | b)` equals `χ b` for all odd natural numbers `b`. ", "generated": ["theorem jacobiSym.jacobiSym.match_1 : Quotient(ZMod ↑b) (MatchEq v nat (QuotientHasRepr v nat)) → ZMod ↑b :=\n  Quot.ind p; Quotient.r _ { inequal : p = 0, if_true := p; if_false := if_false ws hps } = Quot.mk '' [] := by sorry ", "theorem aux.6594990342261255307 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b) :\n    ∮ (y : ℕ), (-1) ^ ((y * a) / int.rawCast (Int.negOfNat 2)) != 0 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Legs.natFactors_list_dvd : ∀ {n : ℕ}, Legs.natFactorsList n ∣ Nat.factors n := by sorry ", "theorem Nat.prime_def_of_ne_two : ∀ {n : ℕ}, n  ≠ 2 → Nat.Prime n := by sorry ", "theorem odd_pow : ∀ {n : ℕ} {R : Type u_1} [inst : StrategicSequence ℕ R] [hp : Fact (Nat.Prime ↑n)] {x : R}, ((star x) ^ n ≠ star x ↑n * x ↑n) ↔ ε n • f (ε n • x - star x) = g (star (Fib (Nat.add n 1)) • star x _1) := by sorry ", "theorem Nat.even : ∀ (n : ℕ), Even n = 2 ∨ n = 0 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n)))", "theorem": "theorem Nat.exists_prime_lt_and_le_two_mul : (∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n))) :=\n  by sorry", "name": "Nat.exists_prime_lt_and_le_two_mul", "lemma-type": "(n : ℕ) →\n  (hn0 : n ≠ 0) → (h : n ≤ 511) → (h_1 : (lt_or_le 511 n) = (Or.inr h)) → Mathlib.Meta.NormNum.MinFacHelper 163 7", "lemma": "theorem aux.6070424879368883132 (n : ℕ) (hn0 : n ≠ 0) (h : n ≤ 511) (h_1 : (lt_or_le 511 n) = (Or.inr h)) :\n    Mathlib.Meta.NormNum.MinFacHelper 163 7 := by sorry", "doc_string": "**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large.\n", "generated": ["theorem nmem_range : ∀ {α : Type u} {a s : α}, a ∈ s» range a → a ∉ range a := by sorry ", "theorem LE.ge : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a ≤ b ↔ b ≥ a := by sorry ", "theorem LT.lt.lt_true : ∀ {α : Type u} [inst : Preorder α] (a : α ), (a < True) → a < ↑true := by sorry ", "theorem two_ne_zero : ∀ {M : Type u_2} [ instance : AddGroup M] [inst_1 : Nontrivial M], 2 ≠ 0 := by sorry ", "equation :\n  let aux_3206917613678552024 : (fun (x : ℕ) ↦ (x - 1) * Nat.mulTwoSeries x % (x ^ 0 + 1) + 4) x =\n    let : Mathlib.Meta.NormNum.HaveSub kN' m s := Nat.rawCast.b (kN' + m s), this.trans (add_tsub_eq_add' 6 (kN' + m) sᵢ)\n        ( Nat.rawCast.b (kN' + m + Nat.div2 0))\n        1 = x :=\n  by sorry ", "theorem Nat.succ_inj) :\n    ∀ (a b : ℕ), Nat.succ a = Nat.succ b ↔ a = b := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Int.int_eq_natAbs : ∀ (a : ℤ) (a_1 : a ≠ 0), ∃ b, b = ↑|a| := by sorry "]}
{"theorem-type": "(∀ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), (IsAddUnit (a + ↑u)) ↔ (IsAddUnit a))", "theorem": "theorem AddUnits.isAddUnit_add_addUnits :\n    (∀ {M : Type u_1} [inst : AddMonoid M] (a : M) (u : AddUnits M), (IsAddUnit (a + ↑u)) ↔ (IsAddUnit a)) := by sorry", "name": "AddUnits.isAddUnit_add_addUnits", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a", "lemma": "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry", "doc_string": "Addition of a `u : AddUnits M` on the right doesn't affect `IsAddUnit`.", "generated": ["theorem aux.6437758104070582436 {M : Type u_1} [AddMonoid M] (a : M) (u : AddUnits M) : ∀ (a_1 : IsAddUnit ↑u),\n    IsAddUnit a := by sorry ", "theorem aux.14788449894323210271 {M : Type u_1} [AddMonoid M] (a : M) (u : AddUnits M) (h : IsAddUnit (a + ↑u)) :\n    ∃ a_1, IsAddUnit a_1 • a + ↑u = 0 := by sorry ", "theorem neg_sub_cancel : ∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b : α), -a + (a - b) = b := by sorry ", "theorem OneAdd.map_right_to_ unitsUnitsToAdd_isUnit :\n    ∀ {R : Type o_1} [inst : NutsAndBolts R] {S : Type o = AddUnits R} (i : S →+ units R) (l : Punits S)[u : U S] {i₁ :=\n      addOrderOf (-↑u) <_ > Nat.succ :=\n  IsAddUnit ((Punits.lift_toAdd (Units.val := ↑u) ((fun (x : Punits S) (p : S) ↦\n          ↑Punits.liftToAdd_single x).ofM Unit_addEquiv p)) l\n              (Multiset.toFinsSupp Finsupp.support l)) ∧\n    Function.Injective fun (pij : R) ↦\n    Multiset.toFinsupp Finsupp.support ⇑(Units.val_ofM u) pij :: ((Finsupp.indicator N _ F.toFun) p) {} -\n    Multiset.map { if x ∈ U then F x - F i (* ↑u)(-↑(↑(Units.val * Units.val u)pij • x * H u u))) else ZerosAt x p} :=\n  by sorry ", "theorem zero_add : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a := by sorry ", "theorem MulZeroClass.mul_zero : ∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0 := by sorry ", "theorem aux.2727399863247860676 {M : Type u_1} [AddMonoid M] (a : M) (u : AddUnits M) :\n    IsAddUnit (1 + ↑(-u)) = IsAddUnit.neg 629742967276649573 => by sorry ", "theorem aux.3232264148834653169 {M : Type u_1} [AddMonoid M] (a : M) (u : AddUnits M) :\n    (IsAddUnit ((3 • ↑u * ↑u) • -a)) ↔ (∃ i x H, ↑i • x = -a) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β} {β' : Type u_1} {δ : Type u_2}\n  {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ} {g' : (a : δ) → γ}\n  (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)),\n  Option.map₂ f a (Option.map g b) = Option.map g' (Option.map₂ f' a b))", "theorem": "theorem Option.map_map₂_right_comm :\n    (∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β} {β' : Type u_1} {δ : Type u_2}\n      {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ} {g' : (a : δ) → γ}\n      (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)),\n      Option.map₂ f a (Option.map g b) = Option.map g' (Option.map₂ f' a b)) :=\n  by sorry", "name": "Option.map_map₂_right_comm", "lemma-type": "∀ {p : Prop}, p = True → p", "lemma": "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry", "doc_string": "Symmetric statement to `Option.map_map₂_distrib_right`. ", "generated": ["picture\n{ to_iso_left₃ : PartialEquiv.toIso (PartialEquiv.leftToRight (Option.leftMkRightVal α γ)) } ≠\n  by infint_proofs</picture>", "theorem aux.9141737360115153121 {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β}\n    {β' : Type u_1} {δ : Type u_2} {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ}\n    {g' : (a : δ) → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) (t : δ) (a : α) (b : β)\n    (h : a ∈ a ::✉ b ::✊) : ∅ ∪ ↑(a ::✉ b ::✊ ) = ↑(a ::✉ b ::✊ ) := by sorry ", "measure_theory.OuterMeasure.iInf_apply :\n    ∀ {α : Type u_1} [inst : MeasurableSpace α] {ι : Sort u_6} (m : (a : ι) → MeasureTheory.OuterMeasure α) (a : α),\n      MeasureTheory.OuterMeasure.iInf m a = ⨅ i, m i a :=\n  by sorry ", "theorem aux.13131539915315301365 {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β}\n    {β' : Type u_1} {δ : Type u_2} {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ}\n    {g' : (a : δ) → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) :\n    (Option.map (fun (a : γ) ↦ b)' b (Option.map some g) =\n        Option.map ((b' ∘ fun (x : α) ↦ Option.map₂ f' x) ∘ iflip fun x :=None => fun (y : β) ↦Option.map₂ f' x y)\n          (Option.map some g)) =\n      (b' ∘ fun (d : γ')  ↦ Option.map f'.symm d ∈ (Option.map f ∘ fun (x : α ⦃b : β⦄ ↦ Option.map f' x b) :=None⦄ ⊕ᵥ Set.univ)\n            id ∈ Option.map (fun (a : υ × β') ↦ tstunt a.2 (+ b′ Stlist.lengthSt b) = b) (s := ()) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem Option.map₂_of_isNone_right :\n    ∀ {α : Type u} {β : Type v} {g : α → β} {o : Option α}, Option.IsNone o → Option.map₂ g o none = none := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\n  [inst_6 : OrderClosedTopology δ] {f : (a : α) → δ} {s : Set α} [inst_7 : Set.OrdConnected s] (hs : Set.Nonempty s)\n  (hf : ContinuousOn f s) (hbot : Filter.Tendsto (fun (x : ↑s) ↦ f ↑x) Filter.atBot Filter.atTop)\n  (htop : Filter.Tendsto (fun (x : ↑s) ↦ f ↑x) Filter.atTop Filter.atBot), Set.SurjOn f s Set.univ)", "theorem": "theorem ContinuousOn.surjOn_of_tendsto' :\n    (∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n      [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\n      [inst_6 : OrderClosedTopology δ] {f : (a : α) → δ} {s : Set α} [inst_7 : Set.OrdConnected s] (hs : Set.Nonempty s)\n      (hf : ContinuousOn f s) (hbot : Filter.Tendsto (fun (x : ↑s) ↦ f ↑x) Filter.atBot Filter.atTop)\n      (htop : Filter.Tendsto (fun (x : ↑s) ↦ f ↑x) Filter.atTop Filter.atBot), Set.SurjOn f s Set.univ) :=\n  by sorry", "name": "ContinuousOn.surjOn_of_tendsto'", "lemma-type": "∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\n  [inst_6 : OrderClosedTopology δ] {f : α → δ} {s : Set α} [inst_7 : Set.OrdConnected s],\n  Set.Nonempty s →\n    ContinuousOn f s →\n      Filter.Tendsto (fun x => f ↑x) Filter.atBot Filter.atBot →\n        Filter.Tendsto (fun x => f ↑x) Filter.atTop Filter.atTop → Set.SurjOn f s Set.univ", "lemma": "theorem ContinuousOn.surjOn_of_tendsto :\n    ∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n      [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\n      [inst_6 : OrderClosedTopology δ] {f : α → δ} {s : Set α} [inst_7 : Set.OrdConnected s],\n      Set.Nonempty s →\n        ContinuousOn f s →\n          Filter.Tendsto (fun x => f ↑x) Filter.atBot Filter.atBot →\n            Filter.Tendsto (fun x => f ↑x) Filter.atTop Filter.atTop → Set.SurjOn f s Set.univ :=\n  by sorry", "doc_string": "If a function `f : α → β` is continuous on a nonempty interval `s`, its restriction to `s`\ntends to `Filter.atTop : Filter β` along `Filter.atBot : Filter ↥s` and tends to\n`Filter.atBot : Filter β` along `Filter.atTop : Filter ↥s`, then the restriction of `f` to `s` is\nsurjective. We formulate the conclusion as `Function.surjOn f s Set.univ`. ", "generated": ["theorem surjOn_iff' :\n    ∀ {β : Sort u_1} {α : Sort u_2} {s : Set α} {ⲑ : Set β} {t : Set β}, ↦ ∀ ⦃a b_, a ∈ t → bi ∈ s → Equiv.EqPoint ⦃x : α⦄ f s₁ b₁ h₁ a → bi = a ∧ b = ↑b₁ := by sorry ", "theorem Set.Ico._lt_unbdd :\n    ∀ {α : Type u} [inst : Preorder α] [inst_1 : ConditionallyCompleteLinearOrder α] (ℹ₁ : @βᵒᵈᵓ _ a_1) (a : α) {s h : α},\n      IsLT (Set.unbdd (ℹ₁)) s → IsGreater (Set.toDual_lt (Set.Interval.unbounded ↔ Nonempty s) h) (+a) :=\n  by sorry ", "theorem aux.10887803032389937416 {α : Type u} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [DenselyOrdered α] {δ : Type u_1} [LinearOrder δ] [TopologicalSpace δ] [OrderClosedTopology δ]\n    {f : (a : α) → δ} {s : Set α} [Set.OrdConnected s] (hs : Set.Nonempty s) (hf : ContinuousOn f s)\n    (hbot : Filter.Tendsto (fun (x : ↑s) ↦ f ↑x) Filter.atBot Filter.atTop) (htop : Filter.Tendsto (fun (x : ↑s) ↦ f ↑x)\n      Filter.atTop Filter.atTop) :\n    ∀ (x : ↓((fun (x : α) ↦ f x) ' '' {x : α | f x ∈ Set.Iio lowerBound f})) (x_1 : δ),\n      p x ((fun (x : α) ↦ f x) (Set.Ioi (Set.Iic f LowerBot))) :=\n  by sorry ", "theorem Filter.tendsto_orderTop :\n    ∀ {α : Type u_3} [inst : ConditionallyCompleteLinearOrderBot α],\n      Bornology.IsOrder.Cobounded α fun a => orderTopa(a) :=\n  by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "theorem continuousOn_sum_iff' :\n    ∀ {α : Type u_1} {β : Type u} {ρ : α → Type v} {s : Set ↑(Σn, ρ n)},\n      Set.Nonempty (⋃ a ∈ s, Function.support (p a)) →\n        ∀ ⦃φ : γ → Σ' n, ρ n → Prop → ContinuousOn p → (∀ x ∈ ⋃ i ∈ s ∧ a = n, p i a = i, ∨ ContinuousOn_2 f e) → rfl :=\n  by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem tendsto_nhds_left_iff : FilteredOrder ρ\n        ⊓ ⊤ ⊓\n          ⊥ = NondisingCodomain (ULift α _a) (ULift ρ _ta), ρ :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {t : Set α} (s : Set α)\n  (ht : MeasureTheory.NullMeasurableSet t), ↑↑μ (s ∩ t) + ↑↑μ (s \\ t) = ↑↑μ s)", "theorem": "theorem MeasureTheory.measure_inter_add_diff₀ :\n    (∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {t : Set α} (s : Set α)\n      (ht : MeasureTheory.NullMeasurableSet t), ↑↑μ (s ∩ t) + ↑↑μ (s \\ t) = ↑↑μ s) :=\n  by sorry", "name": "MeasureTheory.measure_inter_add_diff₀", "lemma-type": "{α : Type u_2} →\n  {m0 : MeasurableSpace α} →\n    {μ : MeasureTheory.Measure α} →\n      {t : Set α} → (s : Set α) → (ht : MeasureTheory.NullMeasurableSet t) → s ∩ t ∪ s \\ t = s", "lemma": "theorem aux.18167352001606593996 {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {t : Set α}\n    (s : Set α) (ht : MeasureTheory.NullMeasurableSet t) : s ∩ t ∪ s \\ t = s := by sorry", "doc_string": "A null measurable set `t` is Carathéodory measurable: for any `s`, we have\n`μ (s ∩ t) + μ (s \\ t) = μ s`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem forall_apply_congr :\n    ∀ {α : Sort u_6} {m : α → (a : Sort u_7) → Prop} {f : Filter α} {x₀ : α},\n      (∀ (b : Sort u_7) (a : α), b = x₀ → f g = h₁ b) →\n        ⇑f =o[g] fun g => ⇑(_m | x₀ g) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem IntervalIntegrable.meas_lt :\n    ∀ {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {a : ℝ} {l : CTL.CUnif ℝ} λ b C y,\n      IsUpperLB b {x | l x} _ → (measureTheory.SignedMeasure.IsComplPosNeg (MeasureTheory.Measure.toSignedMeasure a) b) →\n        ∀ {α : Type u_3} (s : α) (hs : CTL.CTM h ⟹ ctFun ctInt ⟨s, tsu₂ 0 s, s_end⟩), ContinuousWithinAt ⇑C s → MeasureTheory.IntegrableWithinAt ℝ y s :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.14590525147683942467 {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {t : Set α}\n    (s : Set α) (ht : MeasureTheory.NullMeasurableSet t) (h : Set.Nonempty ((s ∩ t)ᶜ ∪ ↑t')) :\n    ↑(μ (s ∩ t) + ↑μ s \\ t) ≤ Infinite.cof (0 : MeasureTheory.Measure α) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MeasurableSpace α] {f : (a : α) → ℝ} (μ : MeasureTheory.Measure α)\n  (f_nn : 0 ≤ᶠ[MeasureTheory.Measure.ae μ] f) (f_mble : AEMeasurable f),\n  ∫⁻ (ω : α), ENNReal.ofReal (f ω) ∂μ = ∫⁻ (t : ℝ) in Set.Ioi 0, ↑↑μ {a : α | t ≤ f a})", "theorem": "theorem MeasureTheory.lintegral_eq_lintegral_meas_le :\n    (∀ {α : Type u_1} [inst : MeasurableSpace α] {f : (a : α) → ℝ} (μ : MeasureTheory.Measure α)\n      (f_nn : 0 ≤ᶠ[MeasureTheory.Measure.ae μ] f) (f_mble : AEMeasurable f),\n      ∫⁻ (ω : α), ENNReal.ofReal (f ω) ∂μ = ∫⁻ (t : ℝ) in Set.Ioi 0, ↑↑μ {a : α | t ≤ f a}) :=\n  by sorry", "name": "MeasureTheory.lintegral_eq_lintegral_meas_le", "lemma-type": "∀ {p : Prop}, p = True → p", "lemma": "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry", "doc_string": "The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in 0..∞, μ {ω | f(ω) ≥ t}`.\n\nSee `lintegral_eq_lintegral_meas_lt` for a version with sets of the form `{ω | f(ω) > t}`\ninstead. ", "generated": ["theorem aux.17571552266178731327 {α : Type u_1} [MeasurableSpace α] {f : (a : α) → ℝ} (μ : MeasureTheory.Measure α)\n    (f_nn : 0 ≤ᶠ[MeasureTheory.MeasurableSet.ae μ] f) (f_mble : AEMeasurable f) : Subset Set.Ioi 0 = Set.univ := by\n  sorry ", "theorem eq_congrSet : ∀ {a b c d : ε}, a = b → c = d → d ⇐ a := by sorry ", "theorem sub_le_one :\n    ∀ {ι : Type u_3} {p : ι → Prop} {K : ι → (a : p i) → (g a < g) (a ▸ μK b i) → ∅ → Prop} {m'α :\n              ∀ (_ : p i), μK b i a ≥ 1 ↔ ξi.2 m ≤ ⨏ (r a o p ↓ g ▸ X.cur (Function.swap (ξi₂.symm a)).2)},\n            ite (0 < Mj) (f j = g j)\n              (ξ i.1 m j = B j) → g' j ≤ (p j ?m_2).val :=\n  by sorry ", "theorem ENNReal.le_one_iff_one_le : ∀ {p : ENNReal}, ↑p ≤ 1 ↔ 0 ≤ p := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.4356537493898831799 {α : Type u_1} [MeasurableSpace α] {f : (a : α) → ℝ} (μ : MeasureTheory.Measure α)\n    (f_nn : 0 ≤ᶠ[MeasureTheory.Measure.ae μ] f) (f_mble : AEMeasurable f) :\n    ENNReal.ofNNReal = fun (a : ℝ) ↦ ↑a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.3203182389872114251 {α : Type u_1} [MeasurableSpace α] {f : (a : α) → ℝ} (μ : MeasureTheory.Measure α)\n    (f_nn : 0 ≤ᶠ[MeasureTheory.Measure.ae μ] f) (f_mble : AEMeasurable f) :\n    f_nn =ᶠ[MeasureTheory.Measure.ae μ] id := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} (ι : Type u_5) [inst : LinearOrderedField R] [inst_1 : Fintype ι],\n  (convexHull R) (Set.range fun (i : ι) (j : ι) ↦ if (i = j) then 1 else 0) = stdSimplex R ι)", "theorem": "theorem convexHull_basis_eq_stdSimplex :\n    (∀ {R : Type u_1} (ι : Type u_5) [inst : LinearOrderedField R] [inst_1 : Fintype ι],\n      (convexHull R) (Set.range fun (i : ι) (j : ι) ↦ if (i = j) then 1 else 0) = stdSimplex R ι) :=\n  by sorry", "name": "convexHull_basis_eq_stdSimplex", "lemma-type": "{R : Type u_1} →\n  (ι : Type u_5) →\n    [LinearOrderedField R] →\n      [Fintype ι] →\n        (w : (j : ι) → R) →\n          (a : w ∈ stdSimplex R ι) →\n            (hw₀ : ∀ (x : ι), 0 ≤ w x) →\n              (hw₁ : (Finset.sum Finset.univ fun (x : ι) ↦ w x) = 1) →\n                (Finset.sum Finset.univ fun (i : ι) ↦ w i • fun (j : ι) ↦ if (i = j) then 1 else 0) ∈\n                  (convexHull R) (Set.range fun (i : ι) (j : ι) ↦ if (i = j) then 1 else 0)", "lemma": "theorem aux.3257861908722410177 {R : Type u_1} (ι : Type u_5) [LinearOrderedField R] [Fintype ι] (w : (j : ι) → R)\n    (a : w ∈ stdSimplex R ι) (hw₀ : ∀ (x : ι), 0 ≤ w x) (hw₁ : (Finset.sum Finset.univ fun (x : ι) ↦ w x) = 1) :\n    (Finset.sum Finset.univ fun (i : ι) ↦ w i • fun (j : ι) ↦ if (i = j) then 1 else 0) ∈\n      (convexHull R) (Set.range fun (i : ι) (j : ι) ↦ if (i = j) then 1 else 0) :=\n  by sorry", "doc_string": "`stdSimplex 𝕜 ι` is the convex hull of the canonical basis in `ι → 𝕜`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem convexHull_eq_top_iff :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : SMul 𝕜 E],\n      ConvexHull 𝕜 ↑Univ = ⊤ ↔ 0 ∉ univ ⊓ { x | 0 ≤ x } :=\n  by sorry ", "theorem Finset.affineCombination_eq_of_subset :\n    ∀ {V : Type u_1} {P : Type u} [inst : AddCommGroup V] [S : AddTorsor V P] {ι : Type u_2} (a : G₀ ι) {w : ι → V ↥ P},\n      ((biproduct fun s => (homoeomorphToPretorialHomToIso s).toAddMonoidHom hc) w = a →\n        w ∈ nontotal =ᶠ[MeasurableSpace.vadd (Finset m) V]\n          Filter.map (AddHomeomorph.affineMap (Basis.isoIc0 R).toEquiv) Finset.univ ⯔ univ) →\n      ∀ (!hf : w = 0 i.card • FunLike.coe s hf a), ∑ iᶽ in Finset.univ, (w.comp homoeisoIni.hom) (f (Set.biExtend' f id\n              w i.card) ((Finset.injective_iff Equality.id).mpr hf.resolve_left)) =\n        0 * a = 0 :=\n  by sorry ", "theorem subset_range' : ∀ {k : ℕ} (f : Fin k → Bool), Finset.univ ⊆ multisetMap f (Set.range f) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem inner_sum_add' :\n    ∀ {R A : Type u_2} [T : R] [s : ℱ R] [scb : SummableScalarPreMultiple R s] [cR : ColonRefineable R R]\n      [smmp : SummableMulPreMultiple R s _A] (a : Finset R) {φ ψ : ℕ → A},\n      Finset.univ ∪ (∅Union ∅Insert a) ⊆ Finset.univ → φ i = ↑a :=\n  by sorry ", "theorem if_pos : ∀ {c : Prop} {h : Decidable c}, c → ∀ {α : Sort u} {x d : α} {ys : List c},  if c then x else d = ys :=\n  by sorry ", "theorem aux.314561417729116414 :\n    {⟪x, x⟫_ℝ ^ Nat.rawCast 1 * Nat.rawCast 1 +\n        ⟪x, x⟫_ℝ ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) +\n        (⟪x, x⟫_ℝ ^ Nat.rawCast 2 * Nat.rawCast 2 + 0) +\n      ⟪x, x⟫_ℝ ^ Nat.rawCast 1 * Nat.rawCast 1 +\n          (⟪x, x⟫_ℝ ^ Nat.rawCast 1 * Nat.rawCast 1 + (0 + 0)) =\n      ⟪0, x⟫_ℝ ^ Nat.rawCast 1 * Nat.rawCast 1 :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MeasurableSpace α] {f : (a : α) → ℝ} {g : (a : α) → ℝ} {s : Set α} (hf : Measurable f)\n  (hg : Measurable g) (hs : MeasurableSet s), MeasurableSet (regionBetween f g s))", "theorem": "theorem measurableSet_regionBetween :\n    (∀ {α : Type u_1} [inst : MeasurableSpace α] {f : (a : α) → ℝ} {g : (a : α) → ℝ} {s : Set α} (hf : Measurable f)\n      (hg : Measurable g) (hs : MeasurableSet s), MeasurableSet (regionBetween f g s)) :=\n  by sorry", "name": "measurableSet_regionBetween", "lemma-type": "{α : Type u_1} →\n  [MeasurableSpace α] →\n    {f : (a : α) → ℝ} →\n      {g : (a : α) → ℝ} →\n        {s : Set α} → (hf : Measurable f) → (hg : Measurable g) → (hs : MeasurableSet s) → Measurable Prod.snd", "lemma": "theorem aux.16381421510266866863 {α : Type u_1} [MeasurableSpace α] {f : (a : α) → ℝ} {g : (a : α) → ℝ} {s : Set α}\n    (hf : Measurable f) (hg : Measurable g) (hs : MeasurableSet s) : Measurable Prod.snd := by sorry", "doc_string": "The region between two measurable functions on a measurable set is measurable. ", "generated": ["theorem MeasurableSupSet.measurableSet' :\n    ∀ {α : Type u_1} {p : α => Prop} {x : Set ↑α} {s : Set α}, s ∈ x → Measurable SupSet (↑s) p → Set α := by sorry ", "theorem congrFun : ∀ {α :Sort u} {β : α → Sort v} {x y : (a : α) → β a}, x = y → ∀ (a : α), x a = y a := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem LT.lt.le : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a < b → a ≤ b := by sorry ", "theorem aux.10291316159665291966 {α : Type u_1} [MeasurableSpace α] {f : (a : α) → ℝ} {g : (a : α) → ℝ} {s : Set α}\n    (hf : Measurable f) (hg : Measurable g) :\n    (measurableSet_eq s s) = True := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Set.measurableSet_uIcc :\n    ∀ {α : Type u_1} {m : MeasurableSpace α} (p q : α), MeasurableSet (Set.uIcc p q) := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R) (h : Ideal.FG I),\n  (IsIdempotentElem I) ↔ (∃ e, (IsIdempotentElem e) ∧ (I = Submodule.span R {e})))", "theorem": "theorem Ideal.isIdempotentElem_iff_of_fg :\n    (∀ {R : Type u_1} [inst : CommRing R] (I : Ideal R) (h : Ideal.FG I),\n      (IsIdempotentElem I) ↔ (∃ e, (IsIdempotentElem e) ∧ (I = Submodule.span R {e}))) :=\n  by sorry", "name": "Ideal.isIdempotentElem_iff_of_fg", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a", "lemma": "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry", "doc_string": "A finitely generated idempotent ideal is generated by an idempotent element ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem le_idempotentToEnclosingIdealFun'A_source :\n    ∀ {α : Type u_2} {b' : α} (u : PrimeSpectrum α) ω φ χ,\n      ∀ (g (i : EnCloseds α)), le_idempotentToEnclosingIdealFun'A_source pI ((finsetLERadical ω + a • finsetLERadical χ i) ↔ g) = pI :=\n  by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "variable {R : Type u_1} [CommRing R] (I : Ideal R) (h : Ideal.FG I) (hI2 : Isfield α) : ⟪↑↑2, hI2.some⟫ = ↑2 := by sorry ", "theorem isIdempotent_submodule_iff :\n    ∀ {R : Type u_1} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] {s : Submodule R M},\n      IsIdempotentElem s ↔ ∃ b, IsIdempotentElem b ∧ s = Submodule.span R {subunit b} :=\n  by sorry ", "theorem IsIdempotentElem.iff_engelianAbelianIdeal_simpleRoot_fg :\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : StrongRegularRing R] [inst_2 : UniqueFactorizationMonoid R]\n      [inst_3 : NormalizationMonoid R] (I : { I₁ : Ideal R // I₁ ≠ 0 ∧ MulIdeal.spanNormCompIdeal (R ⧸ I₁) N ⧾ ⊥ }),\n      [IsIdempotentElem → Ideal.Fg] :=\n  by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0)\n  (h0 : (x = 0) ∨ (y ≠ 0)), ‖y‖ / Real.tan (InnerProductGeometry.angle x (x + y)) = ‖x‖)", "theorem": "theorem InnerProductGeometry.norm_div_tan_angle_add_of_inner_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0)\n      (h0 : (x = 0) ∨ (y ≠ 0)), ‖y‖ / Real.tan (InnerProductGeometry.angle x (x + y)) = ‖x‖) :=\n  by sorry", "name": "InnerProductGeometry.norm_div_tan_angle_add_of_inner_eq_zero", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      {x : V} →\n        {y : V} → (h : ⟪x, y⟫_ℝ = 0) → (h0 : (x = 0) ∨ (y ≠ 0)) → (h0 : x = 0) → (‖y‖ / (‖y‖ / ‖x‖) = ‖x‖) = True", "lemma": "theorem aux.5898737088863517118 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) (h0 : (x = 0) ∨ (y ≠ 0)) (h0 : x = 0) : (‖y‖ / (‖y‖ / ‖x‖) = ‖x‖) = True := by sorry", "doc_string": "A side of a right-angled triangle divided by the tangent of the opposite angle equals the\nadjacent side. ", "generated": ["theorem neg_inner_self_eq_zero :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ℝ E]\n      (x : E), ⟪x, x⟫_ℝ = 0 ← eq_zero : ∀ {x : ℝ}, x = 0 ↔ x = 0 :=\n  by sorry ", "theorem norm_zero : ∀ {E : Type u_6} [inst : NormedAddGroup E], ‖0‖ = 0 := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem inner_null_left :\n    ∀ {V : Type u_6} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace  ℝ V] (u : V) {w : V}, ⟪u, w⟫_ℝ = 0 ↔ w = 0 :=\n  by sorry ", "theorem NegUniv.castAddOfNe : ∀ {α : Type} {β : Type} [inst : Zero α] [inst_1 : Zero β] [hf : NeZero α] (a : α), -a ≠ a :=\n  by sorry ", "theorem Or.imp_right : ∀ {a b c : Prop}, (a ∨ b) → (c → a) → c → b := by sorry ", "theorem Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0 := by sorry ", "theorem aux.12122444116443991932 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) (h0 : (x = 0) ∨ (y ≠ 0)) : (y ≠ 0) ↔ (0 ≠ y) := by sorry "]}
{"theorem-type": "(∀ {α : Type ua} [inst : UniformSpace α] {s : Set (α × α)} (hs : s ∈ uniformity α) (n : ℕ),\n  ∀ᶠ (t : Set (α × α)) in Filter.smallSets (uniformity α), (fun (x : Set (α × α)) ↦ compRel t x)^[n] t ⊆ s)", "theorem": "theorem eventually_uniformity_iterate_comp_subset :\n    (∀ {α : Type ua} [inst : UniformSpace α] {s : Set (α × α)} (hs : s ∈ uniformity α) (n : ℕ),\n      ∀ᶠ (t : Set (α × α)) in Filter.smallSets (uniformity α), (fun (x : Set (α × α)) ↦ compRel t x)^[n] t ⊆ s) :=\n  by sorry", "name": "eventually_uniformity_iterate_comp_subset", "lemma-type": "{α : Type ua} →\n  [UniformSpace α] →\n    {s : Set (α × α)} →\n      (hs : s ∈ uniformity α) →\n        (n : ℕ) →\n          (n : ℕ) →\n            (ihn :\n                ∀ {s : Set (α × α)} (hs : s ∈ uniformity α),\n                  ∀ᶠ (t : Set (α × α)) in Filter.smallSets (uniformity α),\n                    (t ⊆ s) ∧ ((fun (x : Set (α × α)) ↦ compRel t x)^[n] t ⊆ s)) →\n              {s : Set (α × α)} →\n                (hs : s ∈ uniformity α) →\n                  ∀ (t : Set (α × α)) (h : (t ∈ uniformity α) ∧ (compRel t t ⊆ s)),\n                    ∀ᶠ (t : Set (α × α)) in Filter.smallSets (uniformity α),\n                      (t ⊆ s) ∧ ((fun (x : Set (α × α)) ↦ compRel t x)^[Nat.succ n] t ⊆ s)", "lemma": "theorem aux.6409424485096329160 {α : Type ua} [UniformSpace α] {s : Set (α × α)} (hs : s ∈ uniformity α) (n : ℕ) (n : ℕ)\n    (ihn :\n      ∀ {s : Set (α × α)} (hs : s ∈ uniformity α),\n        ∀ᶠ (t : Set (α × α)) in Filter.smallSets (uniformity α),\n          (t ⊆ s) ∧ ((fun (x : Set (α × α)) ↦ compRel t x)^[n] t ⊆ s))\n    {s : Set (α × α)} (hs : s ∈ uniformity α) :\n    ∀ (t : Set (α × α)) (h : (t ∈ uniformity α) ∧ (compRel t t ⊆ s)),\n      ∀ᶠ (t : Set (α × α)) in Filter.smallSets (uniformity α),\n        (t ⊆ s) ∧ ((fun (x : Set (α × α)) ↦ compRel t x)^[Nat.succ n] t ⊆ s) :=\n  by sorry", "doc_string": "If `s ∈ 𝓤 α`, then for any natural `n`, for a subset `t` of a sufficiently small set in `𝓤 α`,\nwe have `t ○ t ○ ... ○ t ⊆ s` (`n` compositions). ", "generated": ["theorem le_uniformity :", "theorem Filter.univ_sets : ∀ {α : Type u_8}, (fun x x_1 => True) x → ∀ (f : Filter α), ↑f ≤ Filter.univ := by sorry ", "theorem eq_top_iff : ∀ {α : Type u} [inst : CompleteLattice α] {a : α}, a = ⊤ ↔ ⊤ = a := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem implies_congr : ∀ {a b c : Sort u} {f g : a ➞ b} {e₁ : a ≃ c} {s : c → Prop}, (f → e₁ s) ↔ (g → e₁ s) := by sorry ", "theorem aux.5350877232433953898 {α : Type ua} [UniformSpace α] {s : Set (α × α)} (hs : s ∈ uniformity α) (n : ℕ) :\n    ∀ (t₁ : Set (α × α)) (x : Set (α × α)) (y : t₁ ≤ x), ∀ (_1 : Unit), (compRel t₁ x) (_1 : Unit) ⇨ Uniform Space.ball\n\nset (α × α) := cospan compRel e :=\nby sorry ", "theorem Set.mem_map : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {a : α} {s : Set α}, a ∈ f '' s ↔ ∃ a', a ∈ a' ∧ f a' = a :=\n  by sorry ", "theorem Set.induction_cofinite _ Filter.HasBasis.inter :\n    ∀ {β : Type u_1} {ι : Sort u_4} [inst : Filter (ι)] {p₁ : filtersToSet ι β → Prop}\n      (_base : ↑{} ∈ Filter.hasBasis (fun o → Set ι → ↑o ≤ filtersToSet ι β) p₁) {s : η},\n            ↑(s.openEmbedding (funo ↔ IsCompact.closed)) :\n              𝔈 (_base subset_ := (Function.Embedding.coe_fun _)),s ∈ Filter.upShift (funo => p₁) Filter.has Basis.\n              mem this := by sorry "]}
{"theorem-type": "(∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z))", "theorem": "theorem Complex.hasSum_sin :\n    (∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z)) := by\n  sorry", "name": "Complex.hasSum_sin", "lemma-type": "(z : ℂ) →\n  (Eq fun (x : ℕ) ↦ (-1) ^ x * (z ^ 2) ^ x * z / ↑(Nat.factorial (2 * x + 1))) =\n    Eq fun (x : ℕ) ↦ (-1) ^ x * (z ^ 2) ^ x * (z / ↑(Nat.factorial (2 * x + 1)))", "lemma": "theorem aux.6381961443289823224 (z : ℂ) :\n    (Eq fun (x : ℕ) ↦ (-1) ^ x * (z ^ 2) ^ x * z / ↑(Nat.factorial (2 * x + 1))) =\n      Eq fun (x : ℕ) ↦ (-1) ^ x * (z ^ 2) ^ x * (z / ↑(Nat.factorial (2 * x + 1))) :=\n  by sorry", "doc_string": "The power series expansion of `Complex.sin`. ", "generated": ["theorem aux.1377832504955822221 (z : ℂ) (k : ℕ) (hk : k ≥ ↑2 * n) : Nat.cast (Nat.rawCast 2) * Nat.rawCast 1 =\n    ↑2 ^ Nat.rawCast 1 * Nat.rawCast 1 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem neg_smul : ∀ {R : Type u_2} {M : Type u_6} [inst : Semiring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n    (c : R) (x : M), -c • x = -(c • x) := by sorry ", "ded : PowerSeries.mul (∑' (b : ℕ), ↑((PowerSeries.trigReduced (3 / 4 / 2)* 1) bb * Nat.rawCast 1)b).partial_series) =\n      PowerSeries.one' :=\n  by sorry ", "theorem Complex.ofReal_cpow : ∀ (x : ℝ) {y : ℂ}, Real.cpow x ↑(Complex.ofRealAbs ∘ y) = Real.cpow x ↑y := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem not_nat_ factorial_pos' = of_not_proof implies factorial_pos' := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (a : α) → β a}, (∀ (a : α), f a = g a) → f = g := by sorry "]}
{"theorem-type": "(∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q))", "theorem": "theorem GeneralizedContinuedFraction.terminates_of_rat :\n    (∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)) := by sorry", "name": "GeneralizedContinuedFraction.terminates_of_rat", "lemma-type": "∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K),\n  Stream'.IsSeq (GeneralizedContinuedFraction.IntFractPair.stream v)", "lemma": "theorem GeneralizedContinuedFraction.IntFractPair.stream_isSeq :\n    ∀ {K : Type u_1} [inst : LinearOrderedField K] [inst_1 : FloorRing K] (v : K),\n      Stream'.IsSeq (GeneralizedContinuedFraction.IntFractPair.stream v) :=\n  by sorry", "doc_string": "The continued fraction of a rational number terminates. ", "generated": ["theorem congr {α : Sort u_1} {s : Finₓ → α} {t : Finₓ → α} : ∀ (a : α) {x : AddEqProp (Con gr s)}, a = x := by sorry ", "theorem Nat.factorization_eq_of_prod_eq : ∀ {p p' : ℕ} prop {x ψ ψ' : ℕ}, Nat.factorization x_1 ps = Nat.prod ψ =\n  ↑((p' * x_2 = max₂ x y) ↔ p' * x₂ = min₂ y x₁ (+ Nat.factorization prop ψ + r * Nat.factorization p = Nat.ordering ζ 0), prop)) fun (_ : False) → (_ : ∅) = ↑⇑false := by regret ", "theorem aux.18913025319731989647 (q : ℚ) : if q = 0 then ⌊↑q⌋⁻¹ = ⌊0⌋⁻¹ then True else False := by sorry ", "theorem aux.16763046127255429898 (G : Type u_1) [TopologicalSpace G] [Group G] [TopologicalGroup G] (x : ℚ)\n    (R : Subgroup (UniformSpace.toX G)) : (QuotientAddGroup M.c H x)⁻¹ ∈ SeminormedAddCommGroup.uniformSpace M := by\n  sorry ", "theorem GeneralizedContinuedFraction.stream.continuous_rat :\n    ∀ (K : Type u) [inst : DivisionRing K] [generalized_continued_fraction : GeneralizedContinuedFraction K],\n      IsCLMK (fun [succ_n, succ_a, succ_b, term_pos] (k : ℕ) => some ↑(GeneralizedContinuedFraction.up term_n))\n        (continuous_coindicator g) :=\n  by sorry ", "theorem GeneralizedContinuedFraction.of', _x : ℤ := by sorry ", "theorem aux.3437712092258148795 (q : ℚ) : IntFinity a := by sorry ", "theorem aux.14410181286843711343 (q : ℚ) (h_q : (Int.fract q ≠ ↑0) ∨ (0 < q) ∨ (0 > q)) (n : ℕ) :\n    ∃ a n, ↑(Int.fract q ^ Nat.choose n a) = Rat.den q ^ Nat.choose n a * (Rat.num q, Rat.den q)₂ := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n  (x : V), (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x)", "theorem": "theorem Orientation.rotation_rotation :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle)\n      (θ₂ : Real.Angle) (x : V),\n      (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x) :=\n  by sorry", "name": "Orientation.rotation_rotation", "lemma-type": "∀ {M : Type u_1} {A : Type u_4} [inst : Monoid M] [inst_1 : AddGroup A] [inst_2 : DistribMulAction M A] (r : M) (x : A),\n  r • -x = -(r • x)", "lemma": "theorem smul_neg :\n    ∀ {M : Type u_1} {A : Type u_4} [inst : Monoid M] [inst_1 : AddGroup A] [inst_2 : DistribMulAction M A] (r : M)\n      (x : A), r • -x = -(r • x) :=\n  by sorry", "doc_string": "Rotating twice is equivalent to rotating by the sum of the angles. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem zero_add : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), 0 + a = a := by sorry ", "theorem aux.17615105944886887579 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) : Orientation.romanCardinalDegree o = 4 := by sorry ", "theorem aux.16481260626606186043 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) :\n    θ₁ = -(Real.pi + Real.pi) ↦ -(Orientation.rotation θ₁ × Orientation.rotation θ₁) x := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.8058459967477846391 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) :\n    eq (⟪(IsROrC.reOri o θ₁ |₂) ((Orientation.rotationOri o - Orientation.rotationOri θ₂) x), (Oriented ℝ V (Fin 2)) ((Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x)))\n        ⟪(IsROrC.reOri o θ₂ |₂) ((Orientation.rotationOri o θ₂) x, (Orientation.rotationOri o θ₂) x),\n        ⟪((Orientation.rotationOri o θ₂) (((Orientation.rotationOri o θ₁) x)), (Orientation.rotationOri o θ₂) x⟫_ℝ) 易) =\n      eq ⟪(IsROrC.angle ((Orientation.rotationOri o θ₁) ((Orientation.rotationOri o θ₂) x)) /* proof /-- sorry -- / */ θ₂,\n          (Orientation.rotationOri o θ₁) ((Orientation.rotationOri o θ₂) x) /ₗᵥ (isROrC ℝ (NormedSpace.toDual (Oriented ℝ V (Fin 2 )))) φ)˟,\n          ⟪IsROrC.reOri e (((Orientation.rotation ⟪e = Orientation.rightAngleBedOut e⟪ / 2) Θ * (Orientation.rotation e)\n                    x')) ⟫ :=\n  by sorry "]}
{"theorem-type": "(∀ {s : Set ℂ} (a : Set.Countable s), Set.Countable (Complex.exp ⁻¹' s))", "theorem": "theorem Set.Countable.preimage_cexp : (∀ {s : Set ℂ} (a : Set.Countable s), Set.Countable (Complex.exp ⁻¹' s)) := by\n  sorry", "name": "Set.Countable.preimage_cexp", "lemma-type": "∀ {α : Type u} {s t : Set α}, s \\ t ∪ t = s ∪ t", "lemma": "theorem Set.diff_union_self : ∀ {α : Type u} {s t : Set α}, s \\ t ∪ t = s ∪ t := by sorry", "doc_string": "**Alias** of the reverse direction of `Complex.countable_preimage_exp`.", "generated": ["theorem Set.countable_negAtom :\n    ∀ {α : Type _}, Set.Nonempty ↑(Filter.IsAtom A filterId.atoms → Set α) → Set {a | 3a = bbar} → s ⊆ ⟨↑-, ≤ f⟩ →\n      MeasurableSpace.BorelSpace ((c, p, t : A) → (x, y : α)) :=\n  by sorry ", "theorem LT.lt.ne' : ∀ {α : Type u_1} [inst : PartialOrder α] {x y : α}, x < y → y ≠ x := by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem Complex.eq_inv_mul_cpow :\n    ∀ {a : ℂ x : ℝ → ℂ f : (a : ℂ) → ℕ → ℚ) (z : ℂ), z ≠ 0 → f(z) (* ↑(Complex.arg z) * ↑(Complex.abs z) + ↑(Complex.arg z)) = z :=\n  by sorry ", "theorem Subtype.ne_equiv :\n    ∀ {α : Sort u} [i : IsReflexiveSubtraction α] (i₁ h : i₁ ≠ PEQ.negFun ≈ Subtype.mk, f₁ ≠ f₂)\n      (α_1 i f₁ pf1 tα, α_2 i f₂ pf2 tα⦃f : α → β := Set.univ :=\n      i₁ = (PEQ.Trans f_3 ((PEQ.lePfOfNeg' (σ : AddAlpha β)) ≡ (Subtype.neg tα)).no_dec) :=\n  by sorry ", "theorem Set.nonempty_Iio_exp : Set.Nonempty (Set.Iio Complex.re Real.emapN0 exp_Ioc N) := by sorry ", "theorem add_neg_self : ∀ {G : Type u_1} [inst : AddSemigroup G] [inst_1 : HalmingSpace G] (a : G), a + -a = 0 := by\n  sorry ", "theorem Complex.countable_exp_compl_image_self : Set.Countable (Complex.exp.minPoly_root Φ) := by sorry "]}
{"theorem-type": "(∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ))", "theorem": "theorem Complex.tan_eq_zero_iff : (∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) := by sorry", "name": "Complex.tan_eq_zero_iff", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The tangent of a complex number is equal to zero\niff this number is equal to `k * π / 2` for an integer `k`.\n\nNote that this lemma takes into account that we use zero as the junk value for division by zero.\nSee also `Complex.tan_eq_zero_iff'`.  ", "generated": ["theorem Real.cosh_zero : ↑Real.cosh 0 = Real.exp 1 := by sorry ", "theorem aux.14955526925910899081 {θ : ℂ} : (Complex.tan θ = 0) ↔ False := by sorry ", "theorem congrArg : ∀ {α {β : Sort u} {a a' : α} (f : α → β), a = a' → f a = f a' := by sorry ", "theorem aux.3193420656691974286 {θ : ℂ} : 2 = Nat.rawCast 2 + 0 := by sorry ", "statement : (Complex.arg (-1) ∈ Set.Ioc 0 ↑Real.pi) = 1 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.7483061291337646210 {θ : ℂ} (a : Complex.tan θ = 0) : Mathlib.Meta.NormNum.IsInt 1.0 (Int.ofNat 1) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {L : FirstOrder.Language} (T : FirstOrder.Language.Theory L) (κ : Cardinal.{w}) (M : Type w')\n  [inst : FirstOrder.Language.Structure L M] [inst : M ⊨ T] [inst : Infinite M],\n  ∃ N, Cardinal.lift.{max u v w, w} κ ≤ Cardinal.mk ↑N)", "theorem": "theorem FirstOrder.Language.Theory.exists_large_model_of_infinite_model :\n    (∀ {L : FirstOrder.Language} (T : FirstOrder.Language.Theory L) (κ : Cardinal.{w}) (M : Type w')\n      [inst : FirstOrder.Language.Structure L M] [inst : M ⊨ T] [inst : Infinite M],\n      ∃ N, Cardinal.lift.{max u v w, w} κ ≤ Cardinal.mk ↑N) :=\n  by sorry", "name": "FirstOrder.Language.Theory.exists_large_model_of_infinite_model", "lemma-type": "{L : FirstOrder.Language} →\n  (T : FirstOrder.Language.Theory L) →\n    (κ : Cardinal.{w}) →\n      (M : Type w') →\n        [FirstOrder.Language.Structure L M] →\n          [M ⊨ T] →\n            [Infinite M] →\n              FirstOrder.Language.Theory.IsSatisfiable\n                (FirstOrder.Language.LHom.onTheory (FirstOrder.Language.lhomWithConstants L (Quotient.out κ)) T ∪\n                  FirstOrder.Language.distinctConstantsTheory L Set.univ)", "lemma": "theorem aux.2524798292971569143 {L : FirstOrder.Language} (T : FirstOrder.Language.Theory L) (κ : Cardinal.{w})\n    (M : Type w') [FirstOrder.Language.Structure L M] [M ⊨ T] [Infinite M] :\n    FirstOrder.Language.Theory.IsSatisfiable\n      (FirstOrder.Language.LHom.onTheory (FirstOrder.Language.lhomWithConstants L (Quotient.out κ)) T ∪\n        FirstOrder.Language.distinctConstantsTheory L Set.univ) :=\n  by sorry", "doc_string": "Any theory with an infinite model has arbitrarily large models. ", "generated": ["theorem Cardinal.lift_mk' : ∀ {x : Type u} {X : Type w} (s : Set x) [hX : Cardinal.{v} ⟪X⟫] [inst : Set.Nonempty (Subtype hX)], x.toSubtype hX = Cardinal.{w} ⟪Set. NonemptyFiniteDiscrete s⟧ := by sorry ", "theorem MulEquiv.trans :\n    ∀ {M : Type u_6} {N : Type u_7} {P : Type u_8} [inst : Mul M] [inst_1 : Mul N] [inst_2 : Mul P] ( f : M ≃* N)\n      (g : N ≃* P),\n      (FirstOrder.Language.MulEquiv.ofEquiv f Equiv.toSet mulEquivToAlgebraEquiv g e).inv₀ = (FirstOrder.Language.MulEquiv.toAlgEquiv f\n            equivToAlgEquiv g).inv₀\n    where (inv₀ : (FirstOrder.Language.toAlgEquiv (M ≃* N)).1 →ₐ[Map.toInduced ⇑(FirstOrder.Language.NatMultiples ℕ r E M)]\n            (FirstOrder.Language.toAlgEquiv h ↑inst (MulEquivWithProd e f).inv)) ↦ f⁻¹ g = (SetoidNsmul N) :=\n  by sorry ", "theorem aux.2754700084114110008 {L : FirstOrder.Language} (T : FirstOrder.Language.Theory L) (κ : Cardinal.{w})\n    (M : Type w') [FirstOrder.Language.Structure L M] [M ⊨ T] [Infinite M] (Lᵏ : FirstOrder.Language)\n    [FirstOrder.Language.Inductive L (FirstOrder.Language.relabel Sum.inr L Lᵢ)] [FirstOrder.Language.Complete L]\n    (θ : FirstOrder.Language.Theory) (T' : L.Theory) : FirstOrder.TheoryOfLanguage.some θ = TheSimpType.baseTheory T' :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Cardinal.pow : ∀ (α : Type u₁) {a b : Cardinal.{u₁}}, (a * ↑aᵐᵏ) = (↑a)(↑aᵐᵏ) × ↑aᵐᵌ := by sorry ", "theorem Cardinal.lift_le : ∀ {c c' a}, ↑c' ⟨a 0⟩ → lift.{top a} c ≤ max u c := by sorry ", "theorem Cardinal.lift : Cardinal ⊗ Nat.Cardinal.bddNat □ Cardinal.CardinalLift (Nat.Cardinal.bddNat ÷ Cardinal.lift) @nat_card (Nat.Cardinal.map lift card_bddNat Nat.Cardinal.nat_bdd) := by sorry ", "theorem Cardinal.aleph.omega_lt_mul_iff : ∀ (c d e hf : Cardinal.{w})\\nontriv', (Cardinal.aleph0 * ↑c ≤ ↑d) ↔ (↑d + 1 ≤ ↑cₚ) := by\n  sorry "]}
{"theorem-type": "(∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0)", "theorem": "theorem WithLp.prod_edist_self :\n    (∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n      (f : WithLp p (α × β)), edist f f = 0) :=\n  by sorry", "name": "WithLp.prod_edist_self", "lemma-type": "(p : ENNReal) →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [PseudoEMetricSpace α] →\n        [PseudoEMetricSpace β] →\n          (f : WithLp p (α × β)) →\n            (h : (p = ⊤) ∨ (0 < p.toReal)) →\n              (h : 0 < p.toReal) →\n                (edist (f.1) (f.1) ^ p.toReal + edist (f.2) (f.2) ^ p.toReal) ^ (1 / p.toReal) = 0 ^ p.toReal⁻¹", "lemma": "theorem aux.10998047912271991162 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) (h : (p = ⊤) ∨ (0 < p.toReal)) (h : 0 < p.toReal) :\n    (edist (f.1) (f.1) ^ p.toReal + edist (f.2) (f.2) ^ p.toReal) ^ (1 / p.toReal) = 0 ^ p.toReal⁻¹ := by sorry", "doc_string": "The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ", "generated": ["theorem aux.11805719896547525888 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) : ifh : Eq 0 fun ε => 0 = fun i => 0 := by sorry ", "theorem edist_mem_uniformity :\n    ∀ {α : Type u} [inst : PseudoMetricSpace α] {U : Set (α × α)},\n      U ∈ uniformity α → ∃V, {p : α × α | edist p.1 p.2 < edist V.1 V.2} ∈ uniformity α :=\n  by sorry ", "theorem edist_dist :\n    ∀ {E : Type u_1} [inst : PseudoEMetricSpace E] (x y : E), edist x y = (+∞ + 0 + 0) / (↑(Infinite.natAbs0 pid) + 1) *\n      edist x y :=\n  by sorry ", "theorem aux.14673788646630127162 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) : edist f f = ⨅ a' g, a' ⊔ f.1 • dist g.1 g.2 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.2589770882945409404 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) :\n    Finite ↑(2 × ⊤) := by sorry ", "theorem edist_equiv : ∀ {α : Type u} {β : Type v} [inst : EMetricSpace α] [inst_1 : EMetricSpace β]\n    (e : WithLp p α ≃ₗᴴ WithLp p β) {f g : WithLp p α} {g' h : WithLp p β},\n    (WithLp.equiv p\n        (⇑e.symm) ((equivEgnorm ⤟inst) ((equivLpPow ⤳norminst) p ((f, g)) ((f, g).1))\n          ((equivLpPow ⤳norminst) p ((f', g').1)))\n        ((equivEgnorm ⤟inst₂) ((e (f, g'))) ((e (f, g').2 => ((f', g'.2)), (f, g').2.length).negEdist h) ((i₁, _),\n            i₂) (i₁ ← e, ∃ b a, b • (f i₁, g' a).2 = f' i₁) ((v : WithLp p α) (v₂ : WithLp p α) {y : WithLp p β}\n              (hf : xv * function.embedding ((f, g' i₁).2, 0) → y) (hw₁ : p xv ≤ p uh),\n              p((WithLp.memFun k) { i := i₂ → { fst := (↑f' × f', .inl) ((f, g' v)(i₂)), snd := (b v₂ * g' s xv)((i₂, η) ↔ v)! }, fcst v * (g₁' xv ↑u × k)), snd) ≤ p v =\n        True true :=\n  by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry "]}
{"theorem-type": "(∀ {R : Type u} {S : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n  {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n  (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n  (hv :\n    ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n      f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n  (hp : p₁ = p₂), f₁ p₁ = f₂ p₂)", "theorem": "theorem MvPolynomial.hom_congr_vars :\n    (∀ {R : Type u} {S : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n      {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n      (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n      (hv :\n        ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n          f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n      (hp : p₁ = p₂), f₁ p₁ = f₂ p₂) :=\n  by sorry", "name": "MvPolynomial.hom_congr_vars", "lemma-type": "∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S₁] (f : R →+* S₁)\n  (g : σ → S₁) (a : R), MvPolynomial.eval₂ f g (MvPolynomial.C a) = f a", "lemma": "theorem MvPolynomial.eval₂_C :\n    ∀ {R : Type u} {S₁ : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S₁] (f : R →+* S₁)\n      (g : σ → S₁) (a : R), MvPolynomial.eval₂ f g (MvPolynomial.C a) = f a :=\n  by sorry", "doc_string": "If `f₁` and `f₂` are ring homs out of the polynomial ring and `p₁` and `p₂` are polynomials,\nthen `f₁ p₁ = f₂ p₂` if `p₁ = p₂` and `f₁` and `f₂` are equal on `R` and on the variables\nof `p₁`.  ", "generated": ["state=on_line_code_reponset\nself=other_count:\nlet L := fun (x : MvPolynomial σ R) ↦ M.evalR x N ⁆;\nhave (MvPolynomial.X i ∈ M.closure) = (Finset.le ↑L s) := by sorry ", "theorem RingHom.comp_assoc :\n    ∀ {R : Type uR} {S : Type uS} {Q : Type uTQ} {F: Q ⟶ R} {G : R ⟶ S} {H : S ⟶ Q} (x : Q),\n      H.comp Q (F.comp R Q) = F.comp R Q (H.map x) :=\n  by sorry ", "thesis : hv = Set.eq_null_iff.mpr H₁ H = eq_false fun (H : j ∈ H₂) ↦ hsv₁ fun (t : True) ↦ _\nm_1 : MvPolynomial ( FreeAddConGen σ) (sigma R) := { mul_def' := ((m MulHomCompHom.toFun r₁.mul (σ t1)).asStrongMulHom v) }\nm_2 : MvPolynomial (FreeAddConGen σ) (sigma R) := { mul_def' := ((@FunLike.coe m) (σ t7).asStrongMulHom (σ t5))}\n(Hg : s₂H 𝑠' = H 𝑚 x₁, s3 i₁ H g = s₂ nH' hs, h := g; property := hsv₁, source_eq := { x : σ // ι ≤ 𝒜₀ H })\nx₁ < n i₂ :: _ := by sorry ", "theorem Equiv.coe_r_trans :\n    ∀ {α : Type u_1} {m ι : Type u_2} [i : FunLike m ι α] (r x d y : DirectedUnion i m α), r x d = r d y := by sorry ", "theorem aux.12854615997715322034 {R : Type u} {S : Type v} {σ : Type u_1} [CommSemiring R] [CommSemiring S]\n    {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n    (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n    (hv :\n      ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n        f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n    (hp : p₁ = p₂) : { (n : mv_polynomial σ R) ∈ idealAddAdjoin F r x | ↑p = (f n)._2} = { (n : mv_polynomial σ R) ∈ nsupport U n x | r = s => s.snd = s.value.2 } :=\n  by sorry ", "theorem MulZeroClass.*zero_smul :\n    ∀ {B : outParam (Type u_2)} {M : Type u_6} [inst : NonUnitalNonAssocRing B] [self : MulAction B M] (b : B)\n      (x : M), 0 • x = 0 :=\n  by sorry ", "state=state max 1702668699351786795", "theorem ringHom_ext_iff :\n    ∀ {R : Type u_2} {A : Type u_5} [inst : CommissionRing R] [inst_1 : Semiring A] [inst_2 : module R A]\n      {f₁ f₂ : R →+* A}, UniqueMul R A ↔ RingHom.comp f₁ MvPolynomial.C f₁ = RingHom.comp f₂ MvPolynomial.C f₂ :=\n  by sorry "]}
{"theorem-type": "(∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {s : Set E} {x : E} (a : UniqueMDiffWithinAt (modelWithCornersSelf 𝕜 E) s x),\n  UniqueDiffWithinAt 𝕜 s x)", "theorem": "theorem UniqueMDiffWithinAt.uniqueDiffWithinAt :\n    (∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedSpace 𝕜 E] {s : Set E} {x : E} (a : UniqueMDiffWithinAt (modelWithCornersSelf 𝕜 E) s x),\n      UniqueDiffWithinAt 𝕜 s x) :=\n  by sorry", "name": "UniqueMDiffWithinAt.uniqueDiffWithinAt", "lemma-type": "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂", "lemma": "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry", "doc_string": "**Alias** of the forward direction of `uniqueMDiffWithinAt_iff_uniqueDiffWithinAt`.", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Self.eq : ∀ {M : Sort u_1} [iOT : OrientationFree M], Subsingleton M → ∀ (x y : M), { toOrdering := ((x)).toOrdering }.val × toOrdering = { toOrdering := ((y)).toOrdering }.val := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem hasMomentConstraintAt :=\n  fun {X : (𝛅 : (a : ι) → NormedAddCommGroup) → (a₁ : X (0)) → FiniteDimensional K X₀ → Prop} Xv gs _ rpI →\n    gs ∈ ↑{a's : ι → (a : IsOpenBasis a's) → (x : FiniteDimensional K { f : X ↦ a' →ᵃ[↑a' in X] X ; in, f ∞ a'' := rpI f a'' ≠ rpI) | x ∈ a' ×ˢ ↑{x : ι→F ..., f x + a₀.re gs rpI ∈ gs ... ×...⟩} →\n      X in {i :: φ' s}, f ({ i} \\ gs) X (⇑φ ∘ ⇑f { i } \\ gs X₀ gs ↔ gs i) p :=\n  by sorry ", "theorem map_eq_fun : ∀ {X : Type u} {Y : Type v}\\_[inst : TopologicalSpace X] {a : X} [inst_1 : Topology X]\n    (f : a →Ṑ[inst a] Y), ULift.map a fun x x_1 ↦ f x := by sorry ", "theorem UniqueDiffWithinAt.contDiffWithinAt_s := by sorry ", "theorem aux.14224871781336708906 {𝕜 : Type u_1} [inst : NontrivallyNormedField 𝕜] {E : Type u_2}\n    [normed_addCommGroup E] [inst_2 : NormedSpace 𝕜 E] {s : Set E} {x : E} {x_1 : UniqueDiffOnWithinAt 𝕜 s x}\n    : UniqueDiffOnWithinAt 𝕜 univ ({x}ᶜ ∈ nhds x) := by sorry "]}
{"theorem-type": "(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] (T : CategoryTheory.Monad C)\n  {A : CategoryTheory.Monad.Algebra T} {B : CategoryTheory.Monad.Algebra T} (f : A ⟶ B)\n  [inst_1 : CategoryTheory.IsIso (CategoryTheory.Monad.Algebra.Hom.f f)], CategoryTheory.IsIso f)", "theorem": "theorem CategoryTheory.Monad.algebra_iso_of_iso :\n    (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] (T : CategoryTheory.Monad C)\n      {A : CategoryTheory.Monad.Algebra T} {B : CategoryTheory.Monad.Algebra T} (f : A ⟶ B)\n      [inst_1 : CategoryTheory.IsIso (CategoryTheory.Monad.Algebra.Hom.f f)], CategoryTheory.IsIso f) :=\n  by sorry", "name": "CategoryTheory.Monad.algebra_iso_of_iso", "lemma-type": "∀ {α : Sort u_1} (a : α), (a = a) = True", "lemma": "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry", "doc_string": "Given an algebra morphism whose carrier part is an isomorphism, we get an algebra isomorphism.\n", "generated": ["theorem CategoryTheory.cancel_epi :\n    ∀ {C : Type u₁} [inst : Category C] {P Q : C} (f : P ⟶ Q) [H : CategoryTheory.Epi f],\n      CategoryTheory.IsIso (-f) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem CategoryTheory.Monad.Algebra.hom_ext :\n    ∀ {M 𝔖 : Type u₁} {I : Type u₀} {al : M 𝔖} {al' : F.Algebra}\n      [ca' : CategoryTheory.AlgebraCategory.HasAlgebra of M 𝔖] {a b : M 𝔖} (h : (CategoryTheory.FunCTOR.toPrefunctor F).toInv B a = of.hom a), (CategoryTheory.Functor.toPrefunctor f.⊤ ⋙ g).toInv B b = g → of.hom a = b → CategoryTheory.AlgebraHom.hom' a = b := by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem CategoryTheory.PreservesLimits.PreservesBinaryBips.eq_map :\n    ∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} C]\n      [inst_1 : CategoryTheory.Category.{viewDecidableEq D, max v₂ v₁} D] (i : D ⥤ C) {X Y : C}\n      [hi : i.is_right_adjoint (CategoryTheory.coyoneda X)], ⟦fun b => ↑b'↪ b⟧ = i ⟭ X, Y ○ CategoryTheory.Limits.bifunctor Y.ev\n    ⣴ b' := by sorry ", "theorem CategoryTheory.Monad.Algebra.C co_fst :\n    ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] (mon : CategoryTheory.Monad C)\n      {al : CategoryTheory.Monad.Algebra mon} (self : CategoryTheory.Monad.Algebra mon),\n      self.A.c = self.hom :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {p : P} {ps : Set P} (h : p ∈ affineSpan k ps), affineSpan k (insert p ps) = affineSpan k ps)", "theorem": "theorem affineSpan_insert_eq_affineSpan :\n    (∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] {p : P} {ps : Set P} (h : p ∈ affineSpan k ps),\n      affineSpan k (insert p ps) = affineSpan k ps) :=\n  by sorry", "name": "affineSpan_insert_eq_affineSpan", "lemma-type": "∀ {α : Type u} {a : α} {s : Set α}, a ∈ s → insert a s = s", "lemma": "theorem Set.insert_eq_of_mem : ∀ {α : Type u} {a : α} {s : Set α}, a ∈ s → insert a s = s := by sorry", "doc_string": "If a point is in the affine span of a set, adding it to that set does not change the affine\nspan. ", "generated": ["theorem aux.9367778192705884243 (k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {p : P} {ps : Set P} : ∀ (s : Set ℙ) (s_1 : Set ∅) (hs : s_1 = Set.univ), s = s_1 := by sorry ", "theorem inner_zero_left :\n    ∀ {𝕜 : Type u_1} {M : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup M] [inst_2 : InnerProductSpace 𝕜 M]\n      (x : M), ⟪0, x⟫_𝕜 = 0 :=\n  by sorry ", "theorem aux.3252383001929165151 (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V]\n    [inst_2 : Module k V] [inst_3 : AddTorsor V P] {p : P} {ps : Set P} (h : p ∈ affineSpan k ps)\n    (s : Set { x : P // x ∈ affineSpan k ps }) :\n    ∀ (p1 : P), 1 {  as := ((s.val)), property := ((s.2)) } p1 ∈ s := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem linearIndependent_smul_support :\n    ∀ {k :: Type u_1} {V : Type u_2} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V] {l₂ : V},\n      Finite ↑s →\n        (Submodule.span ↑s = LinearMap.span ⇑LinearMap.lift.toModule (⇑Fintype.surjectiveFinset l₂ →ₗ[k] V →ₗ[k] k))))\n    (b := LinearIndependent k fun b => (AffineBasis.coords b) l₂ (e a)) : e a = a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem aux.15223525445733447978 (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V]\n    [inst_2 : Module k V] [inst_3 : AddTorsor V P] {p : P} {ps : Set P} (h : p ∈ affineSpan k ps) (p_1 : P)\n    (hp : p_1 ∈ ps) : (p ∈ insert p +ᵥ ↑(vectorSpan k ps)ᗮ) = True := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0)\n  (h0 : (x = 0) ∨ (y ≠ 0)), ‖y‖ / Real.tan (InnerProductGeometry.angle x (x + y)) = ‖x‖)", "theorem": "theorem InnerProductGeometry.norm_div_tan_angle_add_of_inner_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0)\n      (h0 : (x = 0) ∨ (y ≠ 0)), ‖y‖ / Real.tan (InnerProductGeometry.angle x (x + y)) = ‖x‖) :=\n  by sorry", "name": "InnerProductGeometry.norm_div_tan_angle_add_of_inner_eq_zero", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      {x : V} → {y : V} → (h : ⟪x, y⟫_ℝ = 0) → (h0 : (x = 0) ∨ (y ≠ 0)) → (h0 : x = 0) → ‖y‖ / 0 = 0", "lemma": "theorem aux.7112380179904857606 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) (h0 : (x = 0) ∨ (y ≠ 0)) (h0 : x = 0) : ‖y‖ / 0 = 0 := by sorry", "doc_string": "A side of a right-angled triangle divided by the tangent of the opposite angle equals the\nadjacent side. ", "generated": ["theorem IsROrC.ofReal_add_real : ∀ {K : Type u_1} [inst : IsROrC K] (a b : ℝ), ↑(a + b) = ↑a + ↑b := by sorry ", "theorem aux.5393216628054665336 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) (h0 : (x = 0) ∨ (y ≠ 0)) : 0 < ‖y‖ := by sorry ", "theorem normSq_eq_neg_sqrt_re :\n    ∀ {V : Type u_2} [inst : Normed addsDualsVStrictCATedSpace V] {c f : FullLatBoundedLinearMap ℝ V V} (x : V),\n      ∥f x∥ ^ 2 = -Real.sqrt (‖f x‖ * ‖f x‖) + Real.sqrt 1 + 0 :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.6327938883369442161 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) (h0 : (x = 0) ∨ (y ≠ 0)) :\n    0 < ‖y‖ * ‖y‖ / ‖y‖ * ‖y‖ := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem InnerProductGeometry.inner_neg_left :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V), ⟪-x, y⟫_ℝ = -⟪x, y⟫_ℝ :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] (K : CategoryTheory.Coverage C)\n  (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w)),\n  (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L)) P) ↔\n    ((CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) ∧\n      (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P)))", "theorem": "theorem CategoryTheory.Presieve.isSheaf_sup :\n    (∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] (K : CategoryTheory.Coverage C)\n      (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w)),\n      (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L)) P) ↔\n        ((CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) ∧\n          (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P))) :=\n  by sorry", "name": "CategoryTheory.Presieve.isSheaf_sup", "lemma-type": "{C : Type u_1} →\n  [CategoryTheory.Category.{u_2, u_1} C] →\n    (K : CategoryTheory.Coverage C) →\n      (L : CategoryTheory.Coverage C) →\n        (P : CategoryTheory.Functor Cᵒᵖ (Type w)) →\n          (h : CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L)) P) → K ≤ K ⊔ L", "lemma": "theorem aux.6166724955503994520 {C : Type u_1} [CategoryTheory.Category.{u_2, u_1} C] (K : CategoryTheory.Coverage C)\n    (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w))\n    (h : CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L)) P) : K ≤ K ⊔ L := by sorry", "doc_string": "A presheaf is a sheaf for the Grothendieck topology generated by a union of coverages iff it is a\nsheaf for the Grothendieck topology generated by each coverage separately.\n", "generated": ["theorem congrFunc : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} {b₁ b₂ : β}, a₁ = a₂ → b₁ = b₂ → ↑(a₁, b₁) = ↑(a₂, b₂) := by\n  sorry ", "theorem isJointlyKilled_sup_right : ∀ {A : Type u_2} (M : SimpleCommMonoid A), (∀ x ∈ A, x ∈ Subgraph.isJointlyKilled A M)  → (y : SimpleCompartment A), IsJointlyKilled A ⊔ M y := by sorry ", "theorem CategoryTheory.Presieve.mem_sieveOfCovering :\n    ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {X : C} {S F : CategoryTheory.Sieve X}\n      (r : F), r ∈ (CategoryTheory.Presieve.sieveOfCovering (CategoryTheory.Covering.ext F r)).arrows :=\n  by sorry ", "theorem CategoryTheory.Sheaf.isLimitoffSetoid :\n    ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {A: Type u_4}\n      [self : CategoryTheory.ThemA.Ring R] {hom₁ : A →+*. R} (P₁ : (a : C) → Type v₀)\n      [inst_1 : CategoryTheory.PiSystem  (Nonempty.{self, v₀} A P₁)] [inst_2: ConcreteCategory.PreservesColimits A C]\n      (h : (a : ↑(Nonempty.{self, v₀} A)) → (∀ (x : Type v₀) (y : ↑(Nonempty.{self, v₀} A)) (x_1 : Y v) (e : P x ≅ y), P x ≅ ↑(y_1 e))),\n      CategoryTheory.Sheaf A P :=\n  let c : CategoryTheory.Diagram (fun (a : ↑(Nonempty.{self, v₀} A)), V Top A D) ⥤ (A := (↑(Nonempty.{self, v₀} A)) ⥤ V A D) := CategoryTheory.Limits.WideCoequalizerCocone F ;\n  let j : ProductTop Cat P :=\n  CategoryTheory.Products.IsLimit.lift f f ProductTopCat.hasLimits;\n  CategoryTheory.Products.coequal ⊤ e ⊥ d :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.2240908444113631829 {C : Type u_1} [CategoryTheory.Category.{u_2, u_1} C] (K : CategoryTheory.Coverage C)\n    (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w))\n    (a : CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L)) P)\n    (a : ↑((CategoryTheory.Sieve.generate (CategoryTheory.Covering.Arrow.rightP K)) ⊓ ↑((L ⊔ L).covering).sieves))\n    (x :\n      CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L))\n        ((CategoryTheory.Functor.toPrefunctor (_ : Cᵒᵖ ⟶ Type w)).map ((CategoryTheory.Sieve.force ( CategoryTheory.Sieve.generate\n            (CategoryTheory.SortedCollection.single (↥S (CategoryTheory.Covering.genRefl\n          tS)) (CategoryTheory.Skias.leftAux (CategoryTheory.Counit.adj UNiv.unit\n            (TypeMax.unit.g id)))))).rightRes id)\n          a))\n    (tS :\n        ↑((CategoryTheory.Counit.adjunction CategoryTheory.Coverage.univCovering).unit' T) ∈ CategoryTheory.S\n          (TypeWideMorphismValued (CategoryTheory.UltraFilter.DogTod G) T))\n    (tsS := ↑S r ∈ (CategoryTheory.Category.backext <| categoryTheory.ext fun {x : C} {y : C} ↦ by\n            sorry))\n    (_x : C) [valT : TopVal {A, B}} := fun (ha : {A, B} ∈ a) ↦ true;\n  (ha : {A, B} ∈ a) →\n    false = ((CategoryTheory.functorToTypes _ (CategoryTheory.instTopologyOfTypeCat UNiv)))\n      TypeWideMorphismValued tS\n      :=\n  by sorry ", "theorem and_comm : ∀ {a b c : Prop }, a ∧ b ↔ b ∧ a := by sorry ", "theorem aux.7768116106898815205 {C : Type u_1} [CategoryTheory.Category.{u_2, u_1} C]\n    (K : CategoryTheory.Coverage C) (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w))\n    (x : ∀ ⦃i : C⦄, ∀ Y : Cᵒᵖ ⦃R : K ⦄ (a : X ⟶ Y) (a : CategorialPrecover K Y ↑R), P.obj X ⟶ P.obj X) :\n    (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) = True := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  {p₁ : P} {p₂ : P} {p₃ : P} (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2)),\n  Real.Angle.sin (EuclideanGeometry.oangle p₂ p₃ p₁) = dist p₁ p₂ / dist p₁ p₃)", "theorem": "theorem EuclideanGeometry.sin_oangle_right_of_oangle_eq_pi_div_two :\n    (∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)]\n      [inst_4 : Module.Oriented ℝ V (Fin 2)] {p₁ : P} {p₂ : P} {p₃ : P}\n      (h : EuclideanGeometry.oangle p₁ p₂ p₃ = ↑(Real.pi / 2)),\n      Real.Angle.sin (EuclideanGeometry.oangle p₂ p₃ p₁) = dist p₁ p₂ / dist p₁ p₃) :=\n  by sorry", "name": "EuclideanGeometry.sin_oangle_right_of_oangle_eq_pi_div_two", "lemma-type": "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]\n  (p₁ p₂ p₃ : P),\n  Real.Angle.sign (EuclideanGeometry.oangle p₂ p₃ p₁) = Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃)", "lemma": "theorem EuclideanGeometry.oangle_rotate_sign :\n    ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)]\n      [inst_4 : Module.Oriented ℝ V (Fin 2)] (p₁ p₂ p₃ : P),\n      Real.Angle.sign (EuclideanGeometry.oangle p₂ p₃ p₁) = Real.Angle.sign (EuclideanGeometry.oangle p₁ p₂ p₃) :=\n  by sorry", "doc_string": "The sine of an angle in a right-angled triangle as a ratio of sides. ", "generated": ["theorem EuclideanGeometry.oangle_eq_angle_of_pos_of_angle_eq_pi_div_two :\n    ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] {m : P} {n : P} {p : P},\n      0 < Complex.abs (InnerProductGeometry.angle m n) →\n        (Complex.abs (EuclideanGeometry.angle m n) = Real.pi / 2 →\n          EuclideanGeometry.oangle m n p = ↑(EuropeanGeometry.angle m n p)) →\n            Complex.abs (InnerProductGeometry.angle m n) * dist n p = dist n p * Real.sin (EuclideanGeometry.angle m p n) :=\n  by sorry ", "reference:\n- theorem EuclideanGeometry.sin_angle_of_angle_eq_pi_div_two :\n    ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P] (p₁ p₂ p₃ : P),\n      ∃ r₁ r₂ p₁ -ᵥ p₃ = (_ : V), ||r₁ - r₂|| / Real.Angle.sin π / 2 = r₁ :=\n  by sorry ", "theorem aux.6015046372020011313 {V : Type u_1} {P : Type u_2} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [MetricSpace P] [NormedAddTorsor V P] [Fact (FiniteDimensional.finrank ℝ V = 2)]\n    [Module.Oriented ℝ V (Fin 2)] {p₁ : P} {pg₂ : P} {pg₃ : P} (h : pg₂ ≠ pg₃) (h : EuclideanGeometry.oangle p₂ pg₃ p₁ = ↑(Real.pi / 2))\n    (he : p₁ = pg₂) : EuclideanGeometry.angle p₂ pg₃ p₁ = ↑(Real.pi / 2) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Real.Angles.sin_oangle_right_of_oangle_eq_pi_div_two :\n    ∀ {p₁ p₂ p₃ : ℝ} (o : Orientation ℝ V (Fin 2))\n      (h : Orientation.oangle o p₁ p₂ = ↑(Real.pi / 2)), Real.Angle.sin (InnerProductGeometry.angle p₂ p₃ p₁) = 0 :=\n  by sorry ", "theorem Real.Angle.sin_coe : ∀ (x : ℝ), Real.Angle.sin ↑x = Real.sin x := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α -> β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "suggest_qd RecSource.Real.Sine.oangleToReal_neg_pi_div_two : ∀ (a b c : Real) = Real.Oangle.neg_sign b a = False :=\n  by sorry "]}
{"theorem-type": "(∀ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : Ring K] [inst_2 : Algebra F K] {E : Type u_3}\n  [inst_3 : Ring E] [inst_4 : Algebra F E] (e : K ≃ₐ[F] E) [inst_5 : IsSeparable F K], IsSeparable F E)", "theorem": "theorem AlgEquiv.isSeparable :\n    (∀ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : Ring K] [inst_2 : Algebra F K] {E : Type u_3}\n      [inst_3 : Ring E] [inst_4 : Algebra F E] (e : K ≃ₐ[F] E) [inst_5 : IsSeparable F K], IsSeparable F E) :=\n  by sorry", "name": "AlgEquiv.isSeparable", "lemma-type": "∀ (F : Type u_1) {K : Type u_2} [inst : CommRing F] [inst_1 : Ring K] [inst_2 : Algebra F K] [inst_3 : IsSeparable F K]\n  (x : K), Polynomial.Separable (minpoly F x)", "lemma": "theorem IsSeparable.separable :\n    ∀ (F : Type u_1) {K : Type u_2} [inst : CommRing F] [inst_1 : Ring K] [inst_2 : Algebra F K]\n      [inst_3 : IsSeparable F K] (x : K), Polynomial.Separable (minpoly F x) :=\n  by sorry", "doc_string": "Transfer `IsSeparable` across an `AlgEquiv`. ", "generated": ["theorem aux.3638575498876936328 {F : Type u_1} {K : Type u_2} [CommRing F] [Ring K] [Algebra F K] {E : Type u_3}\n    [Ring E] [Algebra F E] (e : K ≃ₐ[F] E) [IsSeparable F K] (x : K) :\n    minpoly F e x = minpoly F (e.1) x := by sorry ", "theorem intermediateField_separable_closure_eq_adjoin_sepClosure :\n    ∀ {F : Type u_1} [inst : FieldInst F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E],\n      Ring.separableClosureInfo F E = E_separableClosure :=\n  by sorry ", "theorem AlgEquiv.compr₂_determinant :\n    ∀ {F₂ : Type u_5} {x : Algebra.adjoin F⟮pᵥ⟯₊ F F₂} (f : Polynomial F) {g : (x ∈ F⟮⅝⟯) → F[x]} (a : SubtypeIsSmooth' x {g}),\n      f.det = ((algebraMap F⟮pᵥ⟯₅ g a - x) ° Polynomial.eval x ^ f.deg) | Subx.2 = b) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem AlgEquivSymm.congr_fun : ∀ {F : Type u_1} {F′' : Type u_4} {E₂₂ : Type y} {φ : F ≃ₐ[E₂₂] F'},\n    AlgEquivIdSymm.simpPath F₂ φ ↔ ∀ (f : F), f ∈ F → φ <| AlgHomId.op ∘ hom f := by sorry ", "theorem RingHom.sup_comp :\n    ∀ {R₁ : Type hR} {R₂: Type hR} {R₃ : Type hR} (f : R₁ →+* R₂) (g : R₂ →+* R₃) (g₁ : R₁ →+* R₃),\n      (CliffOrd f g) →\n        (CliffOrd f g₁ → CliffOrd rg g) → Semiring.toSubsemiring ≤ ⨅ f, Semiring.comp f g' :=\n  by sorry ", "theorem RingEquiv.isSeparable_closure.symm :\n    ⇑(Module.IsSeparableModule.ringEquivSpanNocontinuous F K L E hli) ε K ⊢ AlgRingEquivClass.trans _id.1 e :=\n  by sorry "]}
{"theorem-type": "(∀ {x : ℝ} {ε : ℝ} (hx : 0 ≤ x) (hε : 0 < ε), Real.log x ≤ x ^ ε / ε)", "theorem": "theorem Real.log_le_rpow_div : (∀ {x : ℝ} {ε : ℝ} (hx : 0 ≤ x) (hε : 0 < ε), Real.log x ≤ x ^ ε / ε) := by sorry", "name": "Real.log_le_rpow_div", "lemma-type": "{x : ℝ} → {ε : ℝ} → (hx : 0 ≤ x) → (hε : 0 < ε) → (h : 0 < x) → (Real.log x ≤ x ^ ε / ε) ↔ (ε * Real.log x ≤ x ^ ε)", "lemma": "theorem aux.11835730359997850290 {x : ℝ} {ε : ℝ} (hx : 0 ≤ x) (hε : 0 < ε) (h : 0 < x) :\n    (Real.log x ≤ x ^ ε / ε) ↔ (ε * Real.log x ≤ x ^ ε) := by sorry", "doc_string": "`log x` is bounded above by a multiple of every power of `x` with positive exponent. ", "generated": ["theorem abs_of_nonneg :\n    ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : AddGroup α]\n      [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n      [inst_3 : CovariantClass α α ( Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a : α},\n      0 ≤ a → |a = a :=\n  by sorry ", "theorem inv_pos : ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] {a : α}, 0 < a⁻¹ ↔ 0 < a := by sorry ", "theorem le_div_iff : ∀ {α : Type u_1} [inst : DivisionCommMonoid α] {a b c : α}, 0 < c → (a ≤ b / c ↔ a * c ≤ b) := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem div_one : ∀ {G₊ : Type u_3} [inst : CommGroupWithZero G₊] (a : G₊), a / 1 = a := by sorry ", "theorem one_div_le_two : ∀ {a : ENNRealᕜ'}, 1 / 2 ≠ ⊤ ∧ 0 < a → a ≤ 2 := by sorry ", "theorem pow_succ_le_max : MonoidHom.IsMulHom true » fun x y : NNNat => x * x ⊔ NNReal.ceilY (1 * y ::��ächstrift NatPart.zeroNat x = min x y ⊔ 2 * y) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z))", "theorem": "theorem Complex.hasSum_sin :\n    (∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z)) := by\n  sorry", "name": "Complex.hasSum_sin", "lemma-type": "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g", "lemma": "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry", "doc_string": "The power series expansion of `Complex.sin`. ", "generated": ["theorem aux.4612036631617372476 (z : ℂ) :\n    HasSum (↑(intFourierHom (MultilinearMap.sumFourierFin 4 ℝ)) • Int.fourierCycleRepMatrix 1 j • Function.periodic₂ g j) f :=\n  by sorry ", "theorem pow_le_pow_of_int_pos : ∀ {α : Type u_2} [inst : OrderedRing α] (b : ℤ) {a b₂ : ℕ}, ↑b² < ↑b₂ → ↑a ^ b₂ ≤ ↑a ^ b₂ :=\n  by sorry ", "theorem aux.74969986355317592 (z : ℂ) :\n    (summable fun (x : ℕ) ↦ ↑|(Complex.I * z) ^ (2 * x + 1)|) = (Summable fun (x : ℕ) ↦ ↑|(Complex.I * z) ^ x|ᴠ) :=\n  by sorry ", "theorem eq_neg_self_iff :\n    ∀ {G : Type u_1} [inst : MulAction G ℂ], ∀ (x : ℝ), -(-x * x) • 1 = 1 := by sorry ", "theorem div_eq_mul_inv : ∀ {G : Type u_1} [inst : DivInvMonoid G] (a b : G), a / b = a * b⁻¹ := by sorry ", "theorem aux.6666125199904882698 (z : ℂ) : Complex.exp ↑(Real.piI * z | z • Matrix.planeConformalMatrix (1 → ℂ) 1) =\n    Complex.exp ((Real.piIm * z ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) * (z ^ Nat.rawCast 1 + Mathlib.Complex.I')) :=\n  by sorry ", "theorem div_pow : ∀ {α : Type u_1} [inst : Division commSemigroup α] (a b c : α), a / c = a / (c ^ b) := by sorry ", "theorem aux.13732034806916948600 (z : ℂ) : True · Mathlib.Meta.NormAlt.R FlatTractile.truncatedLocus True _ := by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n  (AddSubgroup.index H = 2) ↔ (∃ a, ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H)))", "theorem": "theorem AddSubgroup.index_eq_two_iff :\n    (∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n      (AddSubgroup.index H = 2) ↔ (∃ a, ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H))) :=\n  by sorry", "name": "AddSubgroup.index_eq_two_iff", "lemma-type": "{G : Type u_1} →\n  [AddGroup G] →\n    {H : AddSubgroup G} →\n      (a : G) → (ha : (a ∉ H) ∧ (∀ (x : G) (a_1 : x ∉ H), -x + a ∈ H)) → (b : G) → (hb : b ∉ H) → ∀ (a : -b ∈ H), b ∈ H", "lemma": "theorem aux.11574189629640186436 {G : Type u_1} [AddGroup G] {H : AddSubgroup G} (a : G)\n    (ha : (a ∉ H) ∧ (∀ (x : G) (a_1 : x ∉ H), -x + a ∈ H)) (b : G) (hb : b ∉ H) : ∀ (a : -b ∈ H), b ∈ H := by sorry", "doc_string": "An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.", "generated": ["theorem Subtype.coe_unitType : ∀ (x : Fin 1), Up ↑x := by sorry ", "theorem aux.14129267462906150729 {G : Type u_1} [AddGroup G] {H : AddSubgroup G} (n : ℕ) :\n    ((n ≠ 0) 𨁋 (Nat.coprime n ↔ (AddSubgroup.index H = n))) = True := by sorry ", "theorem funext : ∀ {α : Sort u} {β : Sort v} {f g : α → β}, (∀ (a : α), f a = g a) → f = g := by sorry ", "theorem aux.14242701538981682484 {G : Type u_1} [AddGroup G] {H : AddSubgroup G} {a : G} (x_1 : a + a + H ≤ H) :\n    ∀ ⦃x : G⦄ (hx : x bᶜ \\ u ∈ H), Xor' (b + x = 0) True := by sorry ", "theorem or_false : ∀ (a : Prop), (a ∨ False) = a := by sorry ", "theorem LE.lt.ne_eq : ∀ {α : Type u} [inst : Preorder α] {v w : α}, v < w → v ≠ w := by sorry ", "theorem Iff.of_eq : ∀ {a b : Prop}, a = b → (a ↔ b) := by sorry ", "theorem aux.7619856451993134315 {G : Type u_1} [AddGroup G] {H : AddSubgroup G} :\n    ∃ h, ∀ (gmem : g ∈ H), Xor'.mtr rfl h_one_not_mem_add_right := by sorry "]}
{"theorem-type": "(∀ {η : Type u_3} {f : (a : η) → Type u_4} [inst : (i : η) → Group (f i)] [inst_1 : DecidableEq η] [inst_2 : Finite η]\n  {H : (i : η) → Subgroup (f i)} {J : Subgroup ((i : η) → f i)},\n  (Subgroup.pi Set.univ H ≤ J) ↔ (∀ (i : η), Subgroup.map (MonoidHom.single f i) (H i) ≤ J))", "theorem": "theorem Subgroup.pi_le_iff :\n    (∀ {η : Type u_3} {f : (a : η) → Type u_4} [inst : (i : η) → Group (f i)] [inst_1 : DecidableEq η]\n      [inst_2 : Finite η] {H : (i : η) → Subgroup (f i)} {J : Subgroup ((i : η) → f i)},\n      (Subgroup.pi Set.univ H ≤ J) ↔ (∀ (i : η), Subgroup.map (MonoidHom.single f i) (H i) ≤ J)) :=\n  by sorry", "name": "Subgroup.pi_le_iff", "lemma-type": "{η : Type u_3} →\n  {f : (a : η) → Type u_4} →\n    [(i : η) → Group (f i)] →\n      [DecidableEq η] →\n        [Finite η] →\n          {H : (i : η) → Subgroup (f i)} →\n            {J : Subgroup ((i : η) → f i)} →\n              (h : ∀ (i : η), Subgroup.map (MonoidHom.single f i) (H i) ≤ J) →\n                (x : (i : η) → f i) →\n                  (hx : x ∈ Subgroup.pi Set.univ H) →\n                    (i : η) →\n                      x i ∈\n                        (fun (i : η) ↦\n                            Subsemigroup.carrier\n                              (Submonoid.toSubsemigroup ((fun (i : η) ↦ Subgroup.toSubmonoid (H i)) i)))\n                          i", "lemma": "theorem aux.15938914583379598045 {η : Type u_3} {f : (a : η) → Type u_4} [(i : η) → Group (f i)] [DecidableEq η]\n    [Finite η] {H : (i : η) → Subgroup (f i)} {J : Subgroup ((i : η) → f i)}\n    (h : ∀ (i : η), Subgroup.map (MonoidHom.single f i) (H i) ≤ J) (x : (i : η) → f i) (hx : x ∈ Subgroup.pi Set.univ H)\n    (i : η) :\n    x i ∈\n      (fun (i : η) ↦ Subsemigroup.carrier (Submonoid.toSubsemigroup ((fun (i : η) ↦ Subgroup.toSubmonoid (H i)) i)))\n        i :=\n  by sorry", "doc_string": "For finite index types, the `Subgroup.pi` is generated by the embeddings of the groups.  ", "generated": ["theorem Subgroup.map_inc :\n    ∀ {N : Type u_2} {k : Submonoid N} {m₁ m₂ : N} {f : N →* MonoidHom f N},\n      f m₁ ≤ m₂ → f m₁ ∈ k → f m₂ ∈ k :=\n  by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem aux.8078478147686835199 {η : Type u_3} {f : (a : η) → Type u_4} [(i : ε) → Group (f i)] [Finite η]\n    {H : (i : η) → Subgroup (f i)} {J : Subgroup ((i : η) → f i)} :\n    ∀ (hi : ↑(Subgroup.map (Subgroup.subtype H) J) ≤ Subgroup.subtype ↑J), J • sigma γ (Subgroup.mapJuleshi J H) = ⊤ :=\n  by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem map_map :\n    ∀ {F : Type u_1} {G : Type u_2} {B : Type u_3} {α : Type u_4} {β : Type u_5} [inst : Functor F G]\n      [inst_1 : AddGroupObj G]\n      {g : (a : B.) → F'' b.a} (f : g (fun a => β) f Γ →' AddGroup G) (q : QuaternionGroup Hypercomplex.Qb)\n      (r₀ : ⟪QxY₂⟫_R[Quaternion YZ])\n      (a : (Addgroup.mleft ℝ (AddQuaternion.hyqr yx q * r₀))) (ra : Quaternion R x₁w * ⟪AddQcAux.G (x₂) q⟫_R r₀ = χ r₀ * f₁w y₀)\n      (rb : { toRingHom := ((ringHom_eq_id₂ Y₀)) }) {ra_1 : Quaternion X zy₀ * ⟪AddQcAux.G r₀ a × AddQcAux.G (i r₀ j) x₀ x₊ ::= ra₀)} =\n      hxj _ r (a_: { toExpChar := 1, toEZ = r₀ } = { b, ba_comm }) : HMul QX x₂ xb := by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n  (AddSubgroup.index H = 2) ↔ (∃ a, ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H)))", "theorem": "theorem AddSubgroup.index_eq_two_iff :\n    (∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n      (AddSubgroup.index H = 2) ↔ (∃ a, ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H))) :=\n  by sorry", "name": "AddSubgroup.index_eq_two_iff", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.", "generated": ["theorem add_mem_mulIndexSet :\n    ∀ {G : Type u_1} [inst : Add Group G] [h : Fact (NumberTheory.IsSmithNumber G 2)] {x : G} {g1 g2 : G},\n      g1 * g2 = x → 3 / 8 < x - g1 = x / x3 + y :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : Sort v} {f g : α → β}, f = g → ∀ (a : α), f a = g a := by sorry ", "theorem aux.8733611241233126656 {G : Type u_1} [AddGroup G] {H : AddSubgroup G}\n    (a : ∃ a, ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H)) (a : G) (h : ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H)) :\n    (Quotient.mk '' √(AddSubgroup.factor (Quotient.mk (↥H)) a)) * AddSubgroup.index H = 1 := by sorry ", "theorem Finite.embedding_iff_range_eq' : ∀ (f : α →+ β) [finite α], Function.Embedding f ↔ Set.range ↑f = Set.univ :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem add_one_eq_inr : ∀ {n e : ZMod n}, Nat.add ↑n 0 e = e ↔ Nat.coprime n ¬e := by sorry ", "theorem aux.818470544936667131 {G : Type u_1} [AddGroup G] {H : AddSubgroup G} (x : G)\n    (y : SetTheory.QuotientAddedElement (G ⧸ H)) (a : AddSubgroup.zmultiplesInQuotient H x = 0') :\n    (↑(Eq.ndrecEq (motive := fun [] [] ↦ TRUE) []).rec\n            0 0 [Eq.ndrecEq (motive := fun [] [] ↦ TRUE) []] =\n          0′) ↔\n      True :=\n  by sorry ", "theorem aux.4922994244971640719 {G : Type u_1} [AddGroup G] {H : AddSubgroup G} :\n    (AddSubgroup.IndexFun H 0 = 1 ∧ ∃ a - 0 ∈ AddSubgroup.map (AddSubgroup.unitInsert 0) H, ½ • a ≠ ½ • 0) ↔\n        (AddSubgroup.IndexFun H 0 = 2 ∧ ∀ (x : G) (a : x + 0 ∈ H), x = 0) :=\n  by sorry "]}
{"theorem-type": "(∀ {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] {x : F} {y : F} (h : ‖x‖ = ‖y‖),\n  (SameRay ℝ x y) ↔ (x = y))", "theorem": "theorem sameRay_iff_of_norm_eq :\n    (∀ {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : NormedSpace ℝ F] {x : F} {y : F} (h : ‖x‖ = ‖y‖),\n      (SameRay ℝ x y) ↔ (x = y)) :=\n  by sorry", "name": "sameRay_iff_of_norm_eq", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Two vectors of the same norm are on the same ray if and only if they are equal. ", "generated": ["theorem IsROrC.pow_def :\n   ∀ {K : Type u_3} [inst : IsROrC K] (n : ℤ) (x : K), x ^ n = if (Complex.img x = 0) then 0 ^ n else ↑(x ^ n) :=\n  by sorry ", "theorem aux.2491427032067742427 {F : Type u_2} [NormedAddCommGroup F] [NormedSpace ℝ F] {x : F} {y : F}\n    (h : ‖x‖ = ‖y‖) (h' : x ≠ y) : Or (‖x‖ < ‖y‖) = Or False := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem norm_pos_iff : ∀ {E : Type u_6} [inst : NormedAddGroup E] {a : E}, 0 < ‖a‖ ↔ a ≠ 0 := by sorry ", "theorem zero_ne' : ∀ {A : Type u_1} [inst : NegZeroClass A] (a : A), 0 ≠ a := by sorry ", "theorem aux.1371957181593364526 {F : Type u_2} [NormedAddCommGroup F] [NormedSpace ℝ F] {x : F} {y : F}\n    (h : ��waldSpice.sameRay_iff (‖x‖ = ‖y‖).mpr (ById.add_apply (congrArg (fun (x : ℝ) (x_1 : ℁) ↦ x = x_1) (norm_norm x))\n          (ById.map (IsAbsoluteValue.push_forvard ℝ (norm ℝ)) 0 proof_8754612683166993508))) :\n    Iff (SameRay ℝ x y) = Iff (x = y) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} {n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G}\n  (hH : Fintype.card ↥H = p ^ n),\n  Fintype.card (↥(Subgroup.normalizer H) ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n    Fintype.card (G ⧸ H) [MOD p])", "theorem": "theorem Sylow.card_quotient_normalizer_modEq_card_quotient :\n    (∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} {n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G}\n      (hH : Fintype.card ↥H = p ^ n),\n      Fintype.card (↥(Subgroup.normalizer H) ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n        Fintype.card (G ⧸ H) [MOD p]) :=\n  by sorry", "name": "Sylow.card_quotient_normalizer_modEq_card_quotient", "lemma-type": "∀ {p : ℕ} {G : Type u_1} [inst : Group G],\n  IsPGroup p G →\n    ∀ [hp : Fact (Nat.Prime p)] (α : Type u_2) [inst_1 : MulAction G α] [inst_2 : Fintype α]\n      [inst_3 : Fintype ↑(MulAction.fixedPoints G α)],\n      Fintype.card α ≡ Fintype.card ↑(MulAction.fixedPoints G α) [MOD p]", "lemma": "theorem IsPGroup.card_modEq_card_fixedPoints :\n    ∀ {p : ℕ} {G : Type u_1} [inst : Group G],\n      IsPGroup p G →\n        ∀ [hp : Fact (Nat.Prime p)] (α : Type u_2) [inst_1 : MulAction G α] [inst_2 : Fintype α]\n          [inst_3 : Fintype ↑(MulAction.fixedPoints G α)],\n          Fintype.card α ≡ Fintype.card ↑(MulAction.fixedPoints G α) [MOD p] :=\n  by sorry", "doc_string": "If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`.  ", "generated": ["theorem trans_refl : ∀ {α : Sort u} {a : α} [pa : IsRefl α] {q : α}, (a = a) → q = a := by sorry ", "theorem Fintype.card_* :\n    ∀ {M H :Type u} [inst : Group M] [i : Subgroup M] [iD : SetLike M i] [mHD : MonoidHomClass X ↥i H] {e : ↑H → M),\n      ∃ k, Embedding e = AddMonoidHom.toOneHom M (AddSubgroupToSubmonoid e k) :=\n  by sorry ", "theorem Set.ext_iff : ∀ {α : Type u} {s t : Set α}, s = t ↔ ∀ (i : α), i ∈ s ↔ i ∈ t := by sorry ", "theorem Nat.factorization_pow_injective : ∀ {n m : ℕ}, Nat.factorization (m ^ n) = Nat.factorization m := by sorry ", "theorem Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0 := by sorry ", "theorem not_imp_not : ∀ (a b : Prop), ¬a ↔ ¬b ↔ (a → b) := by sorry ", "theorem zero_pow : ∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] {n : ℤ}, 0 ^ n = 1 := by sorry ", "theorem aux.2915913412430677922 {G : Type u} [Group G] [Fintype G] {p : ℕ} {n : ℕ} [Fact (Nat.Prime p)]\n    {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) :\n    let g : (i : Quotient (IsPGroup.re strictIso)) → G := f;\n    Subgroup.card ↥ (Fiber (IsPGroup.lindexStrictG ⇑{ toFun := ((f)), map_mul' := ((fun _ _ => leq_eq)), left_comm := f iff_refl (_ : (IsPGroup.strictIsoI gg ifx) = (IsPGroup.strictIsoI gg ifx)), eq_true rwt : Eq.gt (_ > 0)))) /\n      p ^ n :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : Infinite α] (s : Finset α) (n : ℕ) (hn : s.card ≤ n), ∃ t, (s ⊆ t) ∧ (t.card = n))", "theorem": "theorem Infinite.exists_superset_card_eq :\n    (∀ {α : Type u_1} [inst : Infinite α] (s : Finset α) (n : ℕ) (hn : s.card ≤ n), ∃ t, (s ⊆ t) ∧ (t.card = n)) := by\n  sorry", "name": "Infinite.exists_superset_card_eq", "lemma-type": "{α : Type u_1} →\n  [Infinite α] →\n    (s : Finset α) →\n      (n : ℕ) →\n        (hn : s.card ≤ n) →\n          (n : ℕ) →\n            (IH : ∀ (s : Finset α) (hn : s.card ≤ n), ∃ t, (s ⊆ t) ∧ (t.card = n)) →\n              (s : Finset α) →\n                (hn : s.card ≤ Nat.succ n) →\n                  (hn' : s.card < Nat.succ n) →\n                    (t : Finset α) →\n                      (h : (s ⊆ t) ∧ (t.card = n)) →\n                        (hs : s ⊆ t) → (ht : t.card = n) → ∀ (x : α) (hx : x ∉ t), ∃ t, (s ⊆ t) ∧ (t.card = Nat.succ n)", "lemma": "theorem aux.10460500795057815726 {α : Type u_1} [Infinite α] (s : Finset α) (n : ℕ) (hn : s.card ≤ n) (n : ℕ)\n    (IH : ∀ (s : Finset α) (hn : s.card ≤ n), ∃ t, (s ⊆ t) ∧ (t.card = n)) (s : Finset α) (hn : s.card ≤ Nat.succ n)\n    (hn' : s.card < Nat.succ n) (t : Finset α) (h : (s ⊆ t) ∧ (t.card = n)) (hs : s ⊆ t) (ht : t.card = n) :\n    ∀ (x : α) (hx : x ∉ t), ∃ t, (s ⊆ t) ∧ (t.card = Nat.succ n) := by sorry", "doc_string": "See `Infinite.exists_subset_card_eq` for a version that provides an arbitrary\n`s : Finset α` for any cardinality. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem eq_false : ∀ {p : Prop}, ¬p → p ↔ False := by sorry ", "theorem aux.6138012954658276080 {α : Type u_1} [Infinite α] (s : Finset α) (n : ℕ) (hn : s.card ≤ n)\n    {α : Type u_1}{a : α [inst : LinearOrder S] (x_1 : Finset Nat) (x_hr : Encodable x_1)\n      (x : Fin x_1 → S}\n    {x₀ : ℕ}\n    _a : Function.Injective ⇑↑Infinte.cardIoeEq x hr xm x₀) : Nat.PartrecProg := by sorry ", "answer:\n``{ head := (\"true\") }\n```", "theorem aux.6393725599435834368 {α : Type u_1} [Infinite α] (s : Finset α) (n : ℕ) (hn : s.card ≤ n) : n < Nat.succ n :=\n  _root_.lift_t2 ⊤ (fun (a : Nat.Say.Unit1Num) ↦ a.num ) (b < a + a) = a + a : Prop := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem IsLB.forall : ∀ {α : Type u} {δ : α → Type u_1} [h : (x : α) → LinearOrder (δ x)] {p : α → δ x → Prop},\n    (∀ (x : α) (y : δ ↑x), CompactIccExtend h p (Set.univ) h.isLB) → (∃ default, ∀ (x : α), p x₀ { ↑x' | p ↑x }) :=\n  by sorry ", "theorem not_true_eq_false : (¬True) = False := by sorry "]}
{"theorem-type": "(∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C)\n  (Y : C) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y}\n  (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n  (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBicone.IsBilimit.isLimit hb)\n        (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).inv =\n    CategoryTheory.Limits.biprod.desc (CategoryTheory.Limits.BinaryBicone.inl b)\n      (CategoryTheory.Limits.BinaryBicone.inr b))", "theorem": "theorem CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv :\n    (∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n      (X : C) (Y : C) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y]\n      {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n      (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBicone.IsBilimit.isLimit hb)\n            (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).inv =\n        CategoryTheory.Limits.biprod.desc (CategoryTheory.Limits.BinaryBicone.inl b)\n          (CategoryTheory.Limits.BinaryBicone.inr b)) :=\n  by sorry", "name": "CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "Auxiliary lemma for `biprod.uniqueUpToIso`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem CategoryTheory.SimplexType.Hom.toFunLeft' := fun {m n k : SimplexCategory} {a : n ⟶ m} {b : m ⟶ k}\n    {x : Hom m k} => CategoryTheory.CategoryStruct.comp (Hom.snd a) x :\n  fun (i : Fin (Nat.succ (m × n))) ↦ fun (j : Fin n) ↦ SimplexCategory.Hom.Hom.left' x (Fin.succ j) (m' := k), false :=\n  by sorry ", "theorem aux.12527562587522487621 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C) [CategoryTheory.Limits.HasBinaryBiproduct X Y]\n    {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b) :\n    ((CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBicone.isLimit hb)\n            (CategoryTheory.Limits.BinaryBicone.biprodBraiding C X Y)).inv\n          π) =\n      (CategoryTheory.MonoidalCategory.leftUnitor\n            (CategoryTheory.Limits.Types.binaryBicone b)).hom\n        (biprod.of_tuple (CategoryTheory.IsRightBicounit_.toCounit.hom\n            (CategoryTheory.Limits.Types.binaryBicone b)) ×ₕ\n          nil).snd :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {n : ℕ} (h : n ≠ 0) (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n])", "theorem": "theorem Nat.frequently_modEq : (∀ {n : ℕ} (h : n ≠ 0) (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]) := by sorry", "name": "Nat.frequently_modEq", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "Infinitely many natural numbers are equal to `d` mod `n`. ", "generated": ["theorem le_trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c := by sorry ", "theorem MulZeroClass.zero_mul : ∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0 := by sorry ", "theorem Nat.frequently_tot_fib : ∀ (n d h), ∃ᶠ x in Filter.atTop, x ∉ multiplesPred d | d, fibd n d * fibd (n + 1) d ^ m ≡ 0 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.1314202528378368780 {n : ℕ} (h : n ≠ 0) (d : ℕ) :\n    ∀ (m : ℤ) (hn : ↑m %↑n = ↑m), (Nat.succ m ≡ d [MOD n]) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem pow_add : ∀ {N : Type u_1} [inst : CommSemigroup N] {N : N(?) * ↑N) (a : ℕ) (x x_1 : ℕ),\n                (^(↑a+↑a) N) ((x : N)(y : N), x ^ (a | x) * y ^ (a | y)) * N =\n                  (^a fun (x : N) ↦ N) ((x : N), y => y ^ Nat.factorization (a | y) * Nat.factorization a) :=\n  by sorry ", "theorem aux.15876321259233304363 (n : ℕ) (h : n = 0) (d : ℕ) (w : n = 0 ∨ (d ≠ 0)) : ∃ᶠ (n : ℕ) in Filter.atTop,\n                (n = 0) ∨ (n ≡ d [MOD if (((0 < d) && (¬(n = 0))) ∧ (n % ↑h = 0)) then minImp (n % ↑h = 0) else id)) :=\n  by sorry "]}
{"theorem-type": "(∀ {m : ℕ} (hm : 0 < m) (k : ℕ), ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k))", "theorem": "theorem LiouvilleNumber.partialSum_eq_rat :\n    (∀ {m : ℕ} (hm : 0 < m) (k : ℕ), ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k)) := by sorry", "name": "LiouvilleNumber.partialSum_eq_rat", "lemma-type": "{m : ℕ} →\n  (hm : 0 < m) →\n    (k : ℕ) →\n      (k : ℕ) →\n        (h : ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k)) →\n          (p_k : ℕ) →\n            (h_k : LiouvilleNumber.partialSum (↑m) k = ↑p_k / ↑(m ^ Nat.factorial k)) →\n              (p_k * m ^ (k * Nat.factorial k + Nat.factorial k) * m ^ (k * Nat.factorial k + Nat.factorial k) +\n                    m ^ Nat.factorial k * 1 * m ^ (k * Nat.factorial k + Nat.factorial k) =\n                  p_k * m ^ (k * Nat.factorial k + Nat.factorial k - Nat.factorial k) *\n                      (m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k)) +\n                    m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k)) =\n                (p_k * m ^ (k * Nat.factorial k + Nat.factorial k) * m ^ (k * Nat.factorial k + Nat.factorial k) +\n                    m ^ Nat.factorial k * 1 * m ^ (k * Nat.factorial k + Nat.factorial k) =\n                  p_k * m ^ (k * Nat.factorial k) *\n                      (m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k)) +\n                    m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k))", "lemma": "theorem aux.4975266376104347451 {m : ℕ} (hm : 0 < m) (k : ℕ) (k : ℕ)\n    (h : ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k)) (p_k : ℕ)\n    (h_k : LiouvilleNumber.partialSum (↑m) k = ↑p_k / ↑(m ^ Nat.factorial k)) :\n    (p_k * m ^ (k * Nat.factorial k + Nat.factorial k) * m ^ (k * Nat.factorial k + Nat.factorial k) +\n          m ^ Nat.factorial k * 1 * m ^ (k * Nat.factorial k + Nat.factorial k) =\n        p_k * m ^ (k * Nat.factorial k + Nat.factorial k - Nat.factorial k) *\n            (m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k)) +\n          m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k)) =\n      (p_k * m ^ (k * Nat.factorial k + Nat.factorial k) * m ^ (k * Nat.factorial k + Nat.factorial k) +\n          m ^ Nat.factorial k * 1 * m ^ (k * Nat.factorial k + Nat.factorial k) =\n        p_k * m ^ (k * Nat.factorial k) * (m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k)) +\n          m ^ Nat.factorial k * m ^ (k * Nat.factorial k + Nat.factorial k)) :=\n  by sorry", "doc_string": "The sum of the `k` initial terms of the Liouville number to base `m` is a ratio of natural\nnumbers where the denominator is `m ^ k!`. ", "generated": ["rule_doc : Rule (Terminal.Seq R T) → String := by sorry ", "theorem aux.12460040124620016368 {m : ℕ} (hm : 0 < m) :\n    {Nat.factorial m ^ Nat.rawCast 2 | m ≠ 0 ^ Nat.rawCast 2} = Subterminal.eq Nat.terminals NNReal.toNNReal := by sorry ", "theorem MulChar.neg_apply : ∀ (r : Rˣ) (n : ℕ) (a : R), ↑(-↑r * n) ^ a := by sorry ", "theorem le_antisymm : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b := by sorry ", "theorem subsingleton_or_nontrivial : ∀ {α : Sort u_1}, Subsingleton α ∨ Nontrivial α := by sorry ", "theorem divInt_self_eq : ∀ (a : ℤ) (k : ℕ) (i : Nat.Coprime a), a = a / ↑k := by sorry ", "_meta_aux_567741178297733113 {m : ℕ} (hm : 0 < m) : ∀ (k : ℕ), Nat.succ k ≤ Nat.factorial (Nat.succ k) := by\n  sorry ", "self_eq : ∀ (x : ℝ) (y : ℝ), x = y ↔ ↑x = ↑y := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V},\n  (InnerProductGeometry.angle x y = Real.pi) ↔ ((x ≠ 0) ∧ (∃ r, (r < 0) ∧ (y = r • x))))", "theorem": "theorem InnerProductGeometry.angle_eq_pi_iff :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V},\n      (InnerProductGeometry.angle x y = Real.pi) ↔ ((x ≠ 0) ∧ (∃ r, (r < 0) ∧ (y = r • x)))) :=\n  by sorry", "name": "InnerProductGeometry.angle_eq_pi_iff", "lemma-type": "∀ {a : Prop}, a ↔ a", "lemma": "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry", "doc_string": "The angle between two vectors is π if and only if they are nonzero\nand one is a negative multiple of the other. ", "generated": ["theorem aux.14786954824457579556 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} :\n    ∀ (_ : Real.pi = Real.pi), True := by disappointuisingRec₂ ReprInZeroNormReal.nonrecEq x_eq : True := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.15504496974755803361 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} :\n    (IsOpen ((fun (-a: ℝ) → Real.pi) a)) ↔ (∀ (a : ℝ), IsOpen (Or.inright 0 (fun {a : ℝ} ↦ a > complex Real.im a / Real.pi))) :=\n  by sorry ", "theorem aux.60851973298407753 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} :\n    (Real.pi = _root_.pi + 0) = True := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem exists_congr : ∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∃ a, p a) ↔ ∃ a, q a) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {s₁ : AffineSubspace k P} {s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂),\n  AffineSubspace.direction (s₁ ⊓ s₂) = AffineSubspace.direction s₁ ⊓ AffineSubspace.direction s₂)", "theorem": "theorem AffineSubspace.direction_inf_of_mem :\n    (∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [S : AddTorsor V P] {s₁ : AffineSubspace k P} {s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂),\n      AffineSubspace.direction (s₁ ⊓ s₂) = AffineSubspace.direction s₁ ⊓ AffineSubspace.direction s₂) :=\n  by sorry", "name": "AffineSubspace.direction_inf_of_mem", "lemma-type": "∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : AffineSubspace k P} (v : V) {p : P},\n  p ∈ s → (v +ᵥ p ∈ s ↔ v ∈ AffineSubspace.direction s)", "lemma": "theorem AffineSubspace.vadd_mem_iff_mem_direction :\n    ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] {s : AffineSubspace k P} (v : V) {p : P},\n      p ∈ s → (v +ᵥ p ∈ s ↔ v ∈ AffineSubspace.direction s) :=\n  by sorry", "doc_string": "If two affine subspaces have a point in common, the direction of their inf equals the inf of\ntheir directions. ", "generated": ["theorem congrEq : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} {b₁ b₂ : β}, a₁ = a₂ → a₁ = b₁ → a₂ = b₁ := by sorry ", "theorem congr_Arg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem AffineSubspace.coe_directed_ge :\n    ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [ih : AddTorsor V P] {s1 : Set P} {s2 : Set P}, s2 ∋ s1 → affineSpan k ↑s1 = ﹡affineSpan k ↑s2 ⊓ᵥ ↑s1 :=\n  by sorry ", "theorem vectorSpan_inf_of_mem :\n    ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n      ↑(contenidoIncl s1) ∈ s2 → s1 ⊤ = ⊥ → AffineSubspace.vectorSpan k ↑s1 ⊓ s2 = AffineSubspace.vectorSpan k ↑s1 :=\n  by sorry ", "theorem aux.8353067326721336911 {k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {s₁ : AffineSubspace k P} {s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) :\n    p + -p +ᵥ AffineSubspace.direction s₂ = ↑(AffineSubspace.direction (s₁ ⊓ s₂)) := by sorry ", "theorem aux.165291764920321050 {k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {s₁ : AffineSubspace k P} {s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) :\n    s₁ ∈ AffineSubspace.toAffineSubspace (AffineSubspace.direction s₁) := by sorry ", "theorem aux.15525160134811064648 {k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {s₁ : AffineSubspace k P} {s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) :\n    AffineSubspace.direction (s₁)ᖣ = AffineSubspace.direction s₁ := by sorry ", "theorem vectorSpan_inf_eq :\n    ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : AddTorsor V P] (s1 s2 : AffineSubspace k P) [hm : s1 < s2], vectorSpan k s₁ ⊓ vectorSpan k s2 =\n      vectorSpan k (s1 ⊓ s2) :=\n  by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n  (x : V), (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x)", "theorem": "theorem Orientation.rotation_rotation :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle)\n      (θ₂ : Real.Angle) (x : V),\n      (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x) :=\n  by sorry", "name": "Orientation.rotation_rotation", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Rotating twice is equivalent to rotating by the sum of the angles. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem eq_false : ∀ {p : Prop}, (↑p → False) = False := by sorry ", "theorem aux.12465845566938393663 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) : Mathlib.Meta.NormNum.IsNat 0 0 :=\n  by sorry ", "theorem aux.5528013945762446044 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ :Real.Angle)\n    (x : V) : ((Orientation.rotation.symm o) ((Orientation.rotation o θ₂) x))⁻¹ (θ₂ * (Orientation.rotation o θ₁)) =\n        (Orientation.rotLoc O θ₂) ((Orientation.rotation o θ₁) ((Orientation.rotation.symm o) (((Orientation.rotation o)\n            θ₁) ((Orientation.rotation o) θ₂)) x))⁻¹ :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α ; β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.18401985943773888831 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) : Orientation.kaze o θ₁ = Complex.cocole o θ₁ := by sorry "]}
{"theorem-type": "(∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n  a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q)", "theorem": "theorem ENNReal.young_inequality :\n    (∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n      a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q) :=\n  by sorry", "name": "ENNReal.young_inequality", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Young's inequality, `ℝ≥0∞` version with real conjugate exponents. ", "generated": ["theorem LT.lt.le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b := by sorry ", "theorem aux.14053492244324746750 (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q) :\n    LE.le (a * b) (a ^ q * b ^ p) * q < LE.le ENNReal.ofReal p ^ Nat.rawCast 1 * (b ^ p * Nat.rawCast 1) +\n      LE.le a ^ q ^ Nat.rawCast 1 * LE.le b ^ Nat.rawCast 1 * ENNReal.ofReal q :=\n  by sorry ", "theorem real_Inner_div_conj_add_real_div :\n    ∀ {x : ℝ} {y : ↑↑ℝ}, |↑x| * Complex.norm y = Complex.abs (↑j + c * x * ↑‖y‖) := by sorry ", "theorem real_add_le_of_one_le : ∀ {x y : ℝ}, 1 ≤ x → x + y ≤ y := by sorry ", "theorem IFF.iff : ∀ {a b : Prop}, (a ↔ b) ↔ (a ÷ b ↔ b ÷ a) := by sorry ", "theorem NePtInFreqOn.not_or : ∀ {f : SimpleFunction α}, ¬NePtInFreqOn f c S => ¬PTool.IsSymm f c S := by sorry ", "theorem congr_argument : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} {b₁ b₂ : β}, a₁ = a₂ → b₁ = b₂ → a₁ (b₁ : α) = a₂ (b₂ : α) :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a b : α}, f₁ = f₂ → a = b → f₁ a = f₂ b := by sorry "]}
{"theorem-type": "(∀ {d : ℤ} (a : Pell.Solution₁ d),\n  ((1 < Pell.Solution₁.x a) ∧\n      ((0 < Pell.Solution₁.y a) ∧ (∀ (b : Pell.Solution₁ d), ∃ n, (b = a ^ n) ∨ (b = -a ^ n)))) ↔\n    (Pell.IsFundamental a))", "theorem": "theorem Pell.pos_generator_iff_fundamental :\n    (∀ {d : ℤ} (a : Pell.Solution₁ d),\n      ((1 < Pell.Solution₁.x a) ∧\n          ((0 < Pell.Solution₁.y a) ∧ (∀ (b : Pell.Solution₁ d), ∃ n, (b = a ^ n) ∨ (b = -a ^ n)))) ↔\n        (Pell.IsFundamental a)) :=\n  by sorry", "name": "Pell.pos_generator_iff_fundamental", "lemma-type": "∀ {d : ℤ},\n  0 < d →\n    ¬IsSquare d →\n      ∃! a₁, 1 < Pell.Solution₁.x a₁ ∧ 0 < Pell.Solution₁.y a₁ ∧ ∀ (a : Pell.Solution₁ d), ∃ n, a = a₁ ^ n ∨ a = -a₁ ^ n", "lemma": "theorem Pell.existsUnique_pos_generator :\n    ∀ {d : ℤ},\n      0 < d →\n        ¬IsSquare d →\n          ∃! a₁,\n            1 < Pell.Solution₁.x a₁ ∧\n              0 < Pell.Solution₁.y a₁ ∧ ∀ (a : Pell.Solution₁ d), ∃ n, a = a₁ ^ n ∨ a = -a₁ ^ n :=\n  by sorry", "doc_string": "A positive solution is a generator (up to sign) of the group of all solutions to the\nPell equation `x^2 - d*y^2 = 1` if and only if it is a fundamental solution. ", "generated": ["theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem aux.16952766385910068234 {d : ℤ} (a : Pell.Solution₁ d) : (0 ≤ -Pell.Solution₁.y a ^ 2) ↔ (a ≠ -Pell.Solution₁.y a) :=\n  by sorry ", "theorem aux.13126942781437927795 {d : ℤ} (hdh : isDiag (Pell.Solution₁ d)) : Pendry ((1 - Real.sqrt 2 * 2) ∣ Pell.dsl) := by sorry ", "theorem aux.9925982058565854925 {d : ℤ} (a : Pell.Solution₁ d) :\n    ((0 < real_inner (Pell.Solution.a₁ d) (Pell.Solution.a₁ d)) = (0 < -2 * Nat.rawCast 1 * d)) = True := by sorry ", "theorem aux.16863694992919900226 {d : ℤ} :\n    ∀ (a : Pell.Solution₁ d), (1 < Pell.Solution₁.x a) ∧ ((0 < Pell.Solution₁.y a) ∧ ((d > 0) ∧ ({a}1) ⊆\n              {a, -a}))=\n        (1 < Pell.Solution₁.x a) ∧ ((0 < Pell.Solution₁.y a) ∧\n          (-1 < ‎--Pell.Solution₁.y a)) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n  Function.Injective ⇑f)", "theorem": "theorem PEquiv.injective_of_forall_ne_isSome :\n    (∀ {α : Type u} {β : Type v} (f : α ≃. β) (a₂ : α) (h : ∀ (a₁ : α) (a : a₁ ≠ a₂), Option.isSome (f a₁) = true),\n      Function.Injective ⇑f) :=\n  by sorry", "name": "PEquiv.injective_of_forall_ne_isSome", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If the domain of a `PEquiv` is `α` except a point, its forward direction is injective. ", "generated": ["theorem forall_implication : ∀ (a : Prop), ((a → β) ↔ false) ↔ True := by sorry ", "theorem injective_equiv_sym2 :\n    ∀ {β : Sort n₁} -> βᵙ₁ =o (Quotient.out β₁ →ₗ β) := by sorry ", "theorem Option.map_some : ∀ {α : Type u} {β : Type v } (f : α → β) (x : α), Option.map f (some x) = some (f x) := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Filter.mem_biInf_of :\n    ∀ {α : Type u} {x : Set (Set α)} {a : α}, a ∈ Filter.biInf x → ∀ i ∈ x, a ∈ i := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → (∀ (a : α), p a) ↔ ∀ (a : α), q a := by\n  sorry ", "theorem injective_iff_principal : ∀ {X : Type u} {m : Multiset X}, Function.Injective ⇑MulEq.toFun ↔ m ~1 := by\n  sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {ι : Type u_3} [inst : CompleteLattice α] [inst_1 : Fintype ι] {f : (a : ι) → α}\n  (a : CompleteLattice.Independent f), Finset.SupIndep Finset.univ f)", "theorem": "theorem CompleteLattice.Independent.sup_indep_univ :\n    (∀ {α : Type u_1} {ι : Type u_3} [inst : CompleteLattice α] [inst_1 : Fintype ι] {f : (a : ι) → α}\n      (a : CompleteLattice.Independent f), Finset.SupIndep Finset.univ f) :=\n  by sorry", "name": "CompleteLattice.Independent.sup_indep_univ", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "**Alias** of the forward direction of `CompleteLattice.independent_iff_supIndep_univ`.\n\n---\n\nA variant of `CompleteLattice.independent_iff_supIndep` for `Fintype`s. ", "generated": ["theorem And.left : ∀ {a b : Prop}, a ∧ b → a += b := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (a : α) → β a}, (∀ (a : α), f a = g a) → f = g := by sorry ", "theorem forall_swap : ∀ {x y : Sort u_2} {p : x → y → Prop}, (∀ (x : y →Prop), ∀ (y : x →Prop), p x y) = ∀ x y → p x y :=\n  by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem Eq.ge : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a = b → a ≤ b := by sorry ", "theorem Disjoint.supSup_bot_transInf_of_le :\n    ∀ {α : Type u} [inst : ConjTypes α] [i_mem : Set.toFinset ↑i ⊆ Set.toFinset ↑j] [i : ConjAuxClass α i fun φ :ι ↦ a]\n      (k : ConjAux α φ) (μ : Polynomial.Monic f),\n      Disjointₘ ((Fintypes.CoseparatingAux φ (to_CosepConjClass α)) f k) → k ≠ (⊤⁻¹ f * f₁), Finsupp.support) :=\n  by sorry ", "theorem iSup_univ’ :\n    ∀ {α : Type u_7} [inst : CompleteBooleanAlgebra α] (f : α), ⨆ x ∈ Set.univ, f x = ⨆ i, f {' x := ↑i } := by\n  sorry ", "theorem Finset.coe_univ : ∀ {α : Type u_1} [inst : Fintype α], ↑Finset.univ = Set.univ := by sorry "]}
{"theorem-type": "(∀ {α : Type v} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α]\n  [inst_3 : ContravariantClass α α (fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x ≤ x_1] {f : (a : ℕ) → α}\n  (h : Monotone f) (n : ℕ), (Finset.sum (Finset.range n) fun (i : ℕ) ↦ f (i + 1) - f i) = f n - f 0)", "theorem": "theorem Finset.sum_range_tsub :\n    (∀ {α : Type v} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α]\n      [inst_3 : ContravariantClass α α (fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x ≤ x_1]\n      {f : (a : ℕ) → α} (h : Monotone f) (n : ℕ),\n      (Finset.sum (Finset.range n) fun (i : ℕ) ↦ f (i + 1) - f i) = f n - f 0) :=\n  by sorry", "name": "Finset.sum_range_tsub", "lemma-type": "{α : Type v} →\n  [CanonicallyOrderedAddCommMonoid α] →\n    [Sub α] →\n      [OrderedSub α] →\n        [ContravariantClass α α (fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x ≤ x_1] →\n          {f : (a : ℕ) → α} →\n            (h : Monotone f) →\n              (n : ℕ) →\n                (n : ℕ) →\n                  (f (n + 1) - f 0 = f n - f 0 + (f (n + 1) - f n)) = (f (n + 1) - f 0 = f n + (f (n + 1) - f n) - f 0)", "lemma": "theorem aux.7777474598814985290 {α : Type v} [CanonicallyOrderedAddCommMonoid α] [Sub α] [OrderedSub α]\n    [ContravariantClass α α (fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x ≤ x_1] {f : (a : ℕ) → α}\n    (h : Monotone f) (n : ℕ) (n : ℕ) :\n    (f (n + 1) - f 0 = f n - f 0 + (f (n + 1) - f n)) = (f (n + 1) - f 0 = f n + (f (n + 1) - f n) - f 0) := by sorry", "doc_string": "A telescoping sum along `{0, ..., n-1}` of an `ℕ`-valued function\nreduces to the difference of the last and first terms\nwhen the function we are summing is monotone.\n", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Nat.cast_injective : Function.Injective Nat.cast := by sorry ", "theorem Nat.lt_succ_iff_le_cast' : ∀ {α : Sort u_6} [semilift L α] {a b : α} (l b : L) [h : l + 1 = l], a < Nat.succ c → a < b := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.176412044916541676{α : Type v} [CanonicallyOrderedAddCommMonoid α] [OrderedSub α] -[]> * -> α)\n    ({ toFun := fun (x : Nat) ↦ Nat.IcoMinRange 1 x + 1, *local_uniformity := uniformityNat₁ } <+→* ↑OrderedSub) = ?_ :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem congrArg : ∀ {α ; β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {X : Type u_3} {Y : Type u_4} [inst : MeasurableSpace X] [inst_1 : StandardBorelSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : T2Space Y] [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y]\n  [inst_6 : SecondCountableTopology Y] {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f)\n  {s : Set Y}, (MeasurableSet (f ⁻¹' s)) ↔ (MeasurableSet s))", "theorem": "theorem Measurable.measurableSet_preimage_iff_of_surjective :\n    (∀ {X : Type u_3} {Y : Type u_4} [inst : MeasurableSpace X] [inst_1 : StandardBorelSpace X]\n      [inst_2 : TopologicalSpace Y] [inst_3 : T2Space Y] [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y]\n      [inst_6 : SecondCountableTopology Y] {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f)\n      {s : Set Y}, (MeasurableSet (f ⁻¹' s)) ↔ (MeasurableSet s)) :=\n  by sorry", "name": "Measurable.measurableSet_preimage_iff_of_surjective", "lemma-type": "{X : Type u_3} →\n  {Y : Type u_4} →\n    [MeasurableSpace X] →\n      [StandardBorelSpace X] →\n        [TopologicalSpace Y] →\n          [T2Space Y] →\n            [MeasurableSpace Y] →\n              [OpensMeasurableSpace Y] →\n                [SecondCountableTopology Y] →\n                  {f : (a : X) → Y} →\n                    (hf : Measurable f) →\n                      (hsurj : Function.Surjective f) →\n                        {s : Set Y} → (h : MeasurableSet (f ⁻¹' s)) → MeasureTheory.AnalyticSet sᶜ", "lemma": "theorem aux.17831131777471473182 {X : Type u_3} {Y : Type u_4} [MeasurableSpace X] [StandardBorelSpace X]\n    [TopologicalSpace Y] [T2Space Y] [MeasurableSpace Y] [OpensMeasurableSpace Y] [SecondCountableTopology Y]\n    {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f) {s : Set Y} (h : MeasurableSet (f ⁻¹' s)) :\n    MeasureTheory.AnalyticSet sᶜ := by sorry", "doc_string": "If `f : X → Y` is a surjective Borel measurable map from a standard Borel space\nto a topological space with second countable topology, then the preimage of a set `s`\nis measurable if and only if the set is measurable.\nOne implication is the definition of measurability, the other one heavily relies on `X` being a\nstandard Borel space. ", "generated": ["theorem aux.70513606350203891 ![x : Type u_3]× γ (CategoryTheory.Presieve.functorFiniteCategory i g) = x) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.4494290363701030098 {X : Type u_3} {Y : Type u_4} [MeasurableSpace X] [StandardBorelSpace X]\n    [TopologicalSpace Y] [inst_2 : T2Space Y] [MeasurableSpace Y] [opens_measurableSpace Y]\n    [SecondCountableTopology Y] {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f) {s : Set Y} :\n    (MeasurableSet (f ⁻¹' ((fun (x : Y) ↦ {g : { x : Y // s x ∈ IsUnit.unit' '' ({g : X | g ∈ (f ⁻¹' s)⁻¹α g and Function.Surjective g₀ ≤ f g g_1}})} (f x)).subsingleton.elim f x))) =\n      (MeasurableSet s) :=\n  by sorry ", "theorem IsClopen.of_inter ;\n```lean\ninternal\nSource : MathlibMetaSeason\n\n/-\nThe goal in the `congr` tree is proving the equivalence between\n`IsEmpty ((fun isPraxChevalier => m_séq che : m) isPraxChevalier) ↔ (Fun Like.coe PraxChevalier isPrinPraxChevalier m)`\nwhich is expressed instead by the Lean 4 code in question at `congr` :o)). -/ ```lean\nprint Meta.status q(congr :\n  Iff.t (fun isPraxChevalier (f : PseudoEMetricSpace P) => m_séquence che ⊕ che.completion : ℕ ≃ (NormedAddTORS P) × PseuoEMetricP.pseudoPretoriaEmetricSpace m ) IsSequential = likeSeq) ≈ print Set.Icc Set.univ Set.univ := by sorry\n``` [/INST] theorem SetLike.compl :\n    ∀ {R : Sort u_8} {F : ↓ R → Set u_10} [inst ? : IsEmptyProp R], IccSet.closedCompl := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β{, i} : Sort v} {x y : α}, (f = g) → (ρ = φ) → ∀ (a : α), f a = g a → ρ a = φ a :=\n  by sorry ", "theorem aux.2664526179117072215 {X : Type u_3} {Y : Type u_4} [MeasurableSpace X] [StandardBorelSpace X]\n    [TopologicalSpace Y] [T2Space Y] [MeasurableSpace Y] [OpensMeasurableSpace Y] [SecondCountableTopology Y]\n    {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f) {s : Set Y}\n    (hsh : TopologicalSpace.IsTopologicalBasicOpen s) : {s} ∈ measurableSets Xs hsh.measurableSet := by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {σ : Type u_3} [inst_1 : AddCommMonoid M] {w : (a : σ) → M}\n  [inst_2 : DecidableEq M] (m : M) (n : M) (p : MvPolynomial σ R)\n  (h : p ∈ MvPolynomial.weightedHomogeneousSubmodule R w n),\n  (MvPolynomial.weightedHomogeneousComponent w m) p = if (m = n) then p else 0)", "theorem": "theorem MvPolynomial.weightedHomogeneousComponent_weighted_homogeneous_polynomial :\n    (∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {σ : Type u_3} [inst_1 : AddCommMonoid M] {w : (a : σ) → M}\n      [inst_2 : DecidableEq M] (m : M) (n : M) (p : MvPolynomial σ R)\n      (h : p ∈ MvPolynomial.weightedHomogeneousSubmodule R w n),\n      (MvPolynomial.weightedHomogeneousComponent w m) p = if (m = n) then p else 0) :=\n  by sorry", "name": "MvPolynomial.weightedHomogeneousComponent_weighted_homogeneous_polynomial", "lemma-type": "{R : Type u_1} →\n  {M : Type u_2} →\n    [CommSemiring R] →\n      {σ : Type u_3} →\n        [AddCommMonoid M] →\n          {w : (a : σ) → M} →\n            [DecidableEq M] →\n              (m : M) →\n                (n : M) →\n                  (p : MvPolynomial σ R) →\n                    (h : p ∈ MvPolynomial.weightedHomogeneousSubmodule R w n) →\n                      (x : σ →₀ ℕ) →\n                        (MvPolynomial.coeff x p = MvPolynomial.coeff x (if (m = n) then p else 0)) =\n                          (MvPolynomial.coeff x p = MvPolynomial.coeff x 0)", "lemma": "theorem aux.12370569294728104475 {R : Type u_1} {M : Type u_2} [CommSemiring R] {σ : Type u_3} [AddCommMonoid M]\n    {w : (a : σ) → M} [DecidableEq M] (m : M) (n : M) (p : MvPolynomial σ R)\n    (h : p ∈ MvPolynomial.weightedHomogeneousSubmodule R w n) (x : σ →₀ ℕ) :\n    (MvPolynomial.coeff x p = MvPolynomial.coeff x (if (m = n) then p else 0)) =\n      (MvPolynomial.coeff x p = MvPolynomial.coeff x 0) :=\n  by sorry", "doc_string": "The weighted homogeneous components of a weighted homogeneous polynomial. ", "generated": ["theorem eq_comm : ∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a := by sorry ", "theorem aux.5366843744146448009 {R : Type u_1} {M : Type u_2} [CommSemiring R] {σ : Type u_3} [AddCommMonoid M]\n    {w : (a : σ) → M} [DecidableEq M] (m : M) (n : M) (p : MvPolynomial σ R)\n    (h : p ∈ MvPolynomial.weightedHomogeneousSubmodule R w n) (m_eq_n : m = n) : (MvPolynomial.weightedHomogeneousComponents ⥢∘ w) p w * w m_eq_n⁻¹ = p := by sorry ", "theorem congrA : ∀ {N : Sort u_3} {n n' : N}, s n = s n' ↦ ∀ {α : Sort u_4} {n : N} (x : α), CongrArg (_ = n) (x.intro n) = x.intro n' := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem MvPolynomial.coeff_le_one :\n    ∀ {R : Type u} {σ : Type v₁} [inst : CommSemiring R] {n : ℕ} (p : MvPolynomial σ R),\n      p.weightedDegree' w ≤ n → ↑n ∈ MvPolynomial.coeffSupport p ↔ MvPolynomial.coeff p n ≤ 1 :=\n  by sorry ", "theorem aux.1658962822013575 {R : Type u_1} {M : Type u_2} [CommSemiring R] {σ : Type u_3} [AddCommMonoid M]\n    {w : (a : σ) → M} [DecidableEq M] (m : M) (n : M) {p : MvPolynomial σ R} :\n    (not(WeightedHomogeneous.toHomRight ∘ (MvPolynomial.weightedSum w)) m) p ∨\n        false =\n      ((MvPolynomial.weightedSum w m) p = 0 \\[\\mdatasyn (eq \\_ (m \\_₇)).isEq]) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n  (x : V), (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x)", "theorem": "theorem Orientation.rotation_rotation :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle)\n      (θ₂ : Real.Angle) (x : V),\n      (Orientation.rotation o θ₁) ((Orientation.rotation o θ₂) x) = (Orientation.rotation o (θ₁ + θ₂)) x) :=\n  by sorry", "name": "Orientation.rotation_rotation", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      [Fact (FiniteDimensional.finrank ℝ V = 2)] →\n        (o : Orientation ℝ V (Fin 2)) →\n          (θ₁ : Real.Angle) →\n            (θ₂ : Real.Angle) →\n              (x : V) →\n                (Orientation.rotation o θ₁)\n                    (Real.Angle.cos θ₂ • x + Real.Angle.sin θ₂ • (Orientation.rightAngleRotation o) x) =\n                  (Real.Angle.cos θ₂ * Real.Angle.cos θ₁) • x +\n                      (Real.Angle.cos θ₂ * Real.Angle.sin θ₁) • (Orientation.rightAngleRotation o) x +\n                    ((Real.Angle.sin θ₂ * Real.Angle.cos θ₁) • (Orientation.rightAngleRotation o) x +\n                      -((Real.Angle.sin θ₂ * Real.Angle.sin θ₁) • x))", "lemma": "theorem aux.2309012591418126787 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) :\n    (Orientation.rotation o θ₁) (Real.Angle.cos θ₂ • x + Real.Angle.sin θ₂ • (Orientation.rightAngleRotation o) x) =\n      (Real.Angle.cos θ₂ * Real.Angle.cos θ₁) • x +\n          (Real.Angle.cos θ₂ * Real.Angle.sin θ₁) • (Orientation.rightAngleRotation o) x +\n        ((Real.Angle.sin θ₂ * Real.Angle.cos θ₁) • (Orientation.rightAngleRotation o) x +\n          -((Real.Angle.sin θ₂ * Real.Angle.sin θ₁) • x)) :=\n  by sorry", "doc_string": "Rotating twice is equivalent to rotating by the sum of the angles. ", "generated": ["theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem aux.4440759537400867114 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) : sqrt 2 * 2 = 2 * sqrt 2 + 0 := by sorry ", "theorem Orientation.direction_rotation_right :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V},\n      ((Orientation.rotation R o (-θ₁)) ((Orientation.direction o) x) ∰\n          ((Orientation.rotation R o θ₁) ((Orientation.rotation R o (-θ₁)) ((Orientation.direction o) x)))) +\n          -((Orientation.rotation R o (-θ₁)) ((Orientation.direction o) x));\n    ⋃ i = ((Orientation.direction o) x)\n          (↑{(x_1 : InnerProductGeometry.Orientation.RotationSlant x) :\n                (InnerProductGeometry.Orientation.Rotation.RotationRealSlant 0 (Orientation.direction o)) x`) =\n        ᗮ𝓎 ((Orientation x) (Orientation.direction x)) :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Orientation.eq_swap :\n    ∀ {M : Type u_1} [inst : AddCommGroup M] [inst_1 : Module ℝ M] [inst_2 : Fact (FiniteDimensional.finrank ℝ M = 2)]\n      (o : Orientation ℝ M (Fin 2)) (x y w : Basis ℝ (Module.Free.ChooseBasisIndex (Fin 2)) ℝ)\n      {f₁ f₂ : Module.End ℝ M},\n      f₁ ∈ {f : Module.End ℝ M | 0 < MeasureTheory.Measure.map f (orientationMeasure o) x f = |↑(Basis.det x) f₂| w} →\n        f₁ = swap.symm w ^ (Basis.det x) f₂ fa w :=\n  by sorry ", "theorem aux.7826355922872060030 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ₁ : Real.Angle) (θ₂ : Real.Angle)\n    (x : V) : Int.natAbs (↑2 - ↑2) = Nat. Raw.ZNum.toIntPsumPow 2 1 ((Orientation.rotation o θ₂) x) := by sorry "]}
{"theorem-type": "(∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n  ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n    ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n))))", "theorem": "theorem Quaternion.expSeries_even_of_imaginary :\n    (∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n      ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n        ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n)))) :=\n  by sorry", "name": "Quaternion.expSeries_even_of_imaginary", "lemma-type": "{q : Quaternion ℝ} → (hq : Quaternion.re q = 0) → (n : ℕ) → n ^ Nat.rawCast 1 * 2 + 0 = n * 2", "lemma": "theorem aux.6980724014465770160 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) :\n    n ^ Nat.rawCast 1 * 2 + 0 = n * 2 := by sorry", "doc_string": "The even terms of `expSeries` are real, and correspond to the series for $\\cos ‖q‖$. ", "generated": ["theorem Nat.mod_add_div : ∀ (m k : ℕ), m % k + k * (m / k) = m := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem pow_mul_pow' : ∀ {R : Type u} [inst : Semiring R] (r : R) (n m : ℕ), r ^ (n * m) = (fun x x' (fst : r = r^ x ^ n) => x * x') r m' := by sorry ", "theorem aux.918946497525877339 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) :\n    0 ≤ Nat.succ (Nat.div2 (2 * List.len f)) + Nat.zero := by sorry ", "theorem aux.1591878990451440231 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) :\n    (Fin.empty.map fun (x : Fin false) ↦ Units.instRec 0 x) = Units.inst = Units.inst' where inst' : MulAction Units H → ∀ (u : Units H), ↑u‖ • r‖ ≤ NormedSpace.expSeries.radius ℂ ▣ r := by sorry ", "theorem mul_div_assoc' : ∀ {R : Type u} [inst : Mul R] [inst_1 : HasDistribNeg R] (a b : R) [hb : 0 < b],\n    ⇑a q := by sorry ", "theorem congr_arg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithZero R], ↑0 = 0 := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : (a : α) → E} {g : (a : α) → F}\n  {l : Filter α} (a : ∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g), f =o[l] g)", "theorem": "theorem Asymptotics.IsLittleO.of_isBigOWith :\n    (∀ {α : Type u_1} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : (a : α) → E}\n      {g : (a : α) → F} {l : Filter α} (a : ∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g), f =o[l] g) :=\n  by sorry", "name": "Asymptotics.IsLittleO.of_isBigOWith", "lemma-type": "{α : Type u_1} →\n  {E : Type u_3} →\n    {F : Type u_4} →\n      [inst : Norm E] →\n        [Norm F] →\n          {f : (a : α) → E} →\n            {g : (a : α) → F} →\n              {l : Filter α} →\n                {α : Type u_1} →\n                  {E : Type u_3} →\n                    {F : Type u_4} →\n                      [Norm E] →\n                        [Norm F] →\n                          {f : (a : α) → E} →\n                            {g : (a : α) → F} →\n                              {l : Filter α} →\n                                ((f =o[l] g) ↔ (∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g)) =\n                                  ((∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g) ↔\n                                    (∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g))", "lemma": "theorem aux.13761688309792005612 {α : Type u_1} {E : Type u_3} {F : Type u_4} [inst : Norm E] [Norm F] {f : (a : α) → E}\n    {g : (a : α) → F} {l : Filter α} {α : Type u_1} {E : Type u_3} {F : Type u_4} [Norm E] [Norm F] {f : (a : α) → E}\n    {g : (a : α) → F} {l : Filter α} :\n    ((f =o[l] g) ↔ (∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g)) =\n      ((∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g) ↔\n        (∀ ⦃c : ℝ⦄ (a : 0 < c), Asymptotics.IsBigOWith c l f g)) :=\n  by sorry", "doc_string": "**Alias** of the reverse direction of `Asymptotics.isLittleO_iff_forall_isBigOWith`.\n\n---\n\nDefinition of `IsLittleO` in terms of `IsBigOWith`. ", "generated": ["theorem Asymptotics.norm_right_eq_of_exists_asymptotics' :\n    ∀ {a : ℝ} {b : ℝ},\n      ¬a⁻¹ < b →\n        ∀ {l : Filter α} {f : α → ℝ} {g : α → ℝ},\n          Filter.Tendsto f l (nhds a) → Filter.Tendsto g l (nhds b) → HasSum (fun x => f x * g x) (a * b) → f =o[l] fun x => x ^ (b^-1) :=\n  by sorry ", "theorem Filter.mem_bddBelow_iff : ∀ {α : Type u} [inst : Preorder α] {a : Set α} ⦃f : Filter α⦄, f ∈ bddBelow a ↔ bddBelowᶜ a ∈ f :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Asymptotics.norm_left :\n    ∀ {ι : Type u_1} {𝔤 ; _ : Type u_4} {X : Type u_5} [inst : AddGroup 𝔤] [inst_1 : TopologicalAddGroup 𝔤]\n      [inst_2 : 𝔪 𝔤] {A B : ι →ₗˡ A • X},\n      A =B → ∀ {u : ι → X}, norm u =O[l] A.prod =O[l] B.lproducttmSProdᵣ B u.normWhere :=\n  by sorry ", "theorem aux.647779794643547738 {α : Type u_1} {E : Type u_3} {F : Type u_4} [Norm E] [Norm F] {f : (a : α) → E}\n    {g : (a : α) → F} (a : ∀ ⦃α : Type u_1⦄ (a : Filter α) (a : Ring α) (_h : (fun (α : Ring) ↦ ⊥ := (_ :: 1))) ↦\n      0 ≤ ⊥)\n    (a : ∀ (⦃l : Filter α⦄ : Filter α) ⦃α : Type u_1⦄ (a : NontriviallyNormedField α) | (fun (α : NNonempty NontrivNorm α ζ := (_ :: 1)) := a) → 0 ≤ fun a := a))\n    (c : Real) (hc : c ∈ Set.univ) (α : Type u_1) (x_5 : (suffix : Basis Γ₀) ∈ EMetric.ball 0 c) (u : Basis Γ₊ u_1) :=\n  id a s₀ l\n  = Subsingleton.elim; sorry\n```"]}
{"theorem-type": "(∀ (n : ℕ),\n  ↑(Nat.succ n) • Polynomial.bernoulli n =\n    (Polynomial.monomial n) ↑(Nat.succ n) -\n      Finset.sum (Finset.range n) fun (k : ℕ) ↦ ↑(Nat.choose (n + 1) k) • Polynomial.bernoulli k)", "theorem": "theorem Polynomial.bernoulli_eq_sub_sum :\n    (∀ (n : ℕ),\n      ↑(Nat.succ n) • Polynomial.bernoulli n =\n        (Polynomial.monomial n) ↑(Nat.succ n) -\n          Finset.sum (Finset.range n) fun (k : ℕ) ↦ ↑(Nat.choose (n + 1) k) • Polynomial.bernoulli k) :=\n  by sorry", "name": "Polynomial.bernoulli_eq_sub_sum", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a", "lemma": "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry", "doc_string": "Another version of `Polynomial.sum_bernoulli`. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Ne.symm : ∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a := by sorry ", "theorem Nat.cast_sub :\n    ∀ (α : Type u_1) [inst : NonAssocSemiring α] [inst_1 : Nat.Cast α] {m n : ℤ},\n      ⇑(Int.castRingHom α) (m - n) = ⇑(Int.castRingHom α) m - ⇑(Int.castRingHom α) n :=\n  by sorry ", "theorem Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0 := by sorry ", "theorem Finset.sum_attach :\n    ∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] (s : Finset α) (f : α → β),\n      (Finset.sum (Finset.attach s) fun x => f ↑x) = Finset.sum s fun x => f x :=\n  by sorry ", "theorem aux.76057210833 (n : ℕ) :\n    1 · Polynomial.bernoulli n =\n      Finset.range n).map ⇑((Polynomial.X) b) + Finset.sum (Finset.Ico n 0) ⇑((-(Finset.natId' j, 1) + d₁) ^ l) +\n        d ((j + 1) x :=\n          finsetCongr\n            (_ :\n              -((Finset.natId j, { d₁ := ((k - J) ^ Nat.succ k)), j × k ≠ { ( Fin.coe 0, J * Nat.succ 1 ), J + J }) -\n                  { d₁ := ((0, J) × J x a ⪧ { r₁ ≠ o ) e }) = (((H × G × G) i + H × G))) j ≠ true ∧ ∀ (i : J), true ∂\n               true))))) :=\n  by sorry ", "theorem aux.3072045516877592485 (n : ℕ) : Polynomial.bernoulli n = -(Polynomial.bernoulli' n) := by sorry ", "theorem Nat.cast_one : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1 := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : (a : α) → β} (hf : IsRingHom f) {γ : Type u_1}\n  [inst_2 : Ring γ] {g : (a : β) → γ} (hg : IsRingHom g), IsRingHom (g ∘ f))", "theorem": "theorem IsRingHom.comp :\n    (∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : (a : α) → β} (hf : IsRingHom f) {γ : Type u_1}\n      [inst_2 : Ring γ] {g : (a : β) → γ} (hg : IsRingHom g), IsRingHom (g ∘ f)) :=\n  by sorry", "name": "IsRingHom.comp", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [Ring α] →\n      [Ring β] →\n        {f : (a : α) → β} →\n          (hf : IsRingHom f) →\n            {γ : Type u_1} →\n              [Ring γ] → {g : (a : β) → γ} → (hg : IsRingHom g) → (x : α) → (y : α) → g (f x * f y) = g (f x) * g (f y)", "lemma": "theorem aux.12388519825875917043 {α : Type u} {β : Type v} [Ring α] [Ring β] {f : (a : α) → β} (hf : IsRingHom f)\n    {γ : Type u_1} [Ring γ] {g : (a : β) → γ} (hg : IsRingHom g) (x : α) (y : α) : g (f x * f y) = g (f x) * g (f y) :=\n  by sorry", "doc_string": "The composition of two ring homomorphisms is a ring homomorphism. ", "generated": ["theorem map_one :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : One M] [inst_1 : One N] [inst_2 : FunLike F M N]\n      [inst_3 : OneHomClass F M N] (f : F), f 1 = 1 :=\n  by sorry ", "theorem IsRingHom.map_one :\n    ∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α →+* β}, IsRingHom f → f 1 = 1 := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem map_zero :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : FunLike F M N] [inst_1 : Zero M] [inst_2 : Zero N]\n      [inst_3 : FeatMFireableMap F M N] (f : F), f 0 = 0 :=\n  by sorry ", "theorem RingHom.map_zero :\n    ∀ {R : Type u} {S : Type v} {Str : Type u_1} [inst : StructedRing R] [inst_1 : StrictOrderedSemiring S]\n      [srcH : FunLikesrc Str R S] [icr : IntermediateField R S] [inst_4 : StrongOrderedCommSemaring S] (f : R →+* S)\n      [hfg : Function.Injective ⇑f] and,\n    ∀ (y : S), RingHom.comp (RingHom.compIntermediate ⇑f icf hdf ihf) f y = RingHom.comp IntermediateField.incf y :=\n  by sorry ", "theorem IsRingHom.map_one :\n    ∀ {R : Type u} {S : Type v} {F : Type u_2} [inst : Ring R] [inst_1 : Ring S] [inst_2 : FunStr F]\n      [inst_3 : RingHomClass F R S] (σ : F), σ 1 = 1 :=\n  by sorry ", "theorem map_const :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_1} [inst : FunLike F M N] [inst_1 : NonUnitalRingHomClass F M N]\n      (f : F) (c : M), f c = c :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry "]}
{"theorem-type": "(∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1), p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂)", "theorem": "theorem NNReal.geom_mean_le_arith_mean2_weighted :\n    (∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1),\n      p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂) :=\n  by sorry", "name": "NNReal.geom_mean_le_arith_mean2_weighted", "lemma-type": "(w₁ : NNReal) →\n  (w₂ : NNReal) →\n    (p₁ : NNReal) →\n      (p₂ : NNReal) →\n        (Matrix.vecCons w₁ ![w₂] (Fin.succ 0) +\n            Finset.sum Finset.univ fun (i : Fin 0) ↦ Matrix.vecCons w₁ ![w₂] (Fin.succ (Fin.succ i))) =\n          Matrix.vecCons w₁ ![w₂] (Fin.succ 0)", "lemma": "theorem aux.9413544945505650194 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) :\n    (Matrix.vecCons w₁ ![w₂] (Fin.succ 0) +\n        Finset.sum Finset.univ fun (i : Fin 0) ↦ Matrix.vecCons w₁ ![w₂] (Fin.succ (Fin.succ i))) =\n      Matrix.vecCons w₁ ![w₂] (Fin.succ 0) :=\n  by sorry", "doc_string": "The geometric mean is less than or equal to the arithmetic mean, weighted version\nfor two `NNReal` numbers. ", "generated": ["theorem aux.11334335389813509952 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1) (hp₁ : 1 ≤ p₁)\n    (hp₂ : 1 ≤ p₂) : WOrd.atTop (Fin Nat.oneOfN 1).1 := by sorry ", "theorem smul_sub :\n    ∀ {R : Type u_1} {M₁ : Type u_3} [inst: Fintype R] [inst_1 : MulSemiring R] [inst_2 : Strong Rank Condition R]\n      [inst_3 : AddCommSemigroup M₁] and [Module R M₁] (r : R) (x y : M₁), r • (x - y) = r • x - r • y :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem NNReal.sum_div_of_hasSum :\n    ∀ {f : α → NNReal} {g : α → NNReal} {m : NNReal} {S : ∅ ⊆ ⊤}\n      (H₁ : Summable fun i → m/f i ∃ a, (∃ i, a > i) ∧ f i < f a) (H₂ : Summable fun i → m / g i ∃ a, a > i a << m ≤ g a)\n      (H₃ : ∀ (a : γ) (b : a = m), Prod.LipschitzWith LE.one Get.snd), ‖get m f s‖ ÷ m ⊓ ‖get m g s‖ :=\n  by sorry ", "theorem NNReal.pow_nonneg : ∀ {x : NNReal} (n : ℕ), 0 ≤ NNReal.ofNNReal x ^ n := by sorry ", "theorem aux.4621565250701764897 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1) :\n    mathgroup_type.normalize (-1_ℝ⁰^ (* x) (* 1_ℝ⁰)) + mathgroup_type.normalize 1 =\n      List.SortRec.increasingOrderAux₂ (mathlib_List.toFinset mathgroup_type.n (i + 1)) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.13054755671971053806 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1) :\n    (Finset.sum Finset.univ fun (x : Fin (1 + 2)) ↦ fun₀ | x => ↑↑(PFun.mapDomain f (PiNat.sndPi x))) = 1 + (p₁ ^ 1) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n  (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s),\n  ∀ᵐ (x : α) ∂μ, ∀ (a : x ∈ s), ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s)", "theorem": "theorem MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem :\n    (∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n      (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s),\n      ∀ᵐ (x : α) ∂μ, ∀ (a : x ∈ s), ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s) :=\n  by sorry", "name": "MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`,\nalmost every point `x ∈ s` returns back to `s` infinitely many times. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem MeasureTheory.Conservative.ae_mem_imp_exists_frequently_image_mem₀ :\n    ∀ {α : Type u_2} { f : α → α} {m : MeasurableSpace α} {i : MeasureTheory.Conservative fᶜ μ},\n      ∀⦃s : Set α, MeasurableSet s → (∀ {x ∈ s}, x ∈ fᵒ¹(μ) x) → ∃ x_, Set.InjOn fᵒ¹ x.val → Set.InjOn s :=\n  by sorry ", "theorem aux.4803039219319619933 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (A : Set α)\n    (h : (MeasurableSet A) ∧ ((MeasureTheory.NullMeasurableSet A) ∧ (↑↑μ A ≠ ⊤)))\n    (h : (MeasurableSet A) ∧ ((MeasureTheory.NullMeasurableSet A) ∩ (↑↑μ A ≠ ⊤)))\n    (hA₁ : MeasurableSet A) (right : (MeasureTheory.NullMeasurableSet A) ∧ (↑↑μ A ≠ ⊤))\n    (hA₂ : (MeasureTheory.NullMeasurableSet A) ∧ (↑↑μ A ≠ ⊤)) (hAA : MeasureTheory.NullMeasurableSet A) :\n    λ x ↦ (f -ᵥ id) (- x) = - ((Subtype.val (⇑f -ᵥ id) x = - x) ∧ (x ≠ 0)) ∨ ((⇑f -ᵥ id) (- x) = 0) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem FunLike.congr' : ∀ {F : Sort u_1} {α : outParam (Sort u_2)} {β : outParam (Sort u_3)} {φ : F} {ψ : F},\n    ∀ (h : φ = ψ), φ = ψ :=\n  by sorry ", "theorem Inter_neg_ neg : ∀ {α : Type u} [inst : ConditionallyCompleteLattice α] {a b : α}, -(a ⊓ b) = -a ⊔ -b := by\n  sorry ", "theorem Fact.out : ∀ {a : Prop} [fa : Fact a], a := by sorry ", "theorem aux.2101036808979539079 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasizableSet s) (x : α) :\n    ∀ (_l : TendstoLocallyFiniteSeq (fun (n : ℕ) ↦ f^[n] ⁻¹' s) Filter.atTop ↑μ), ((∆ x_1, xᵡ x_1) ∧ (∨ p xᵡ y) · True + True) =\n      (xᵡ f^[Nat.Partrec.CompExtrAsc.procedure₁ n] ||\n        some\n          (xᵡ\n            (finsetExtendDomain\n              [s, (∫ x : Nat.Partrec.CompExtrAsc.Num x_d × Nat.Partrec.CompExtrAsc.numb x), (∎a.partrec\n              (fun (a : Nat.Partrec.CompExtrAsc.CRef a ℝ) ↦ ite (a.val < (a_ : a) := (a.val < ↑a) 𝟸 efun\n              (natRedub p (a.val), Nat.partrec b.val == s).1) (0 := fun x : Prop ↦ f ×ˢ Nat.upRecs r b.val))) x] \\\n              ️a)) =\n        (True ||\n          some ((pᵢ x ((finsetExtendNat Domain (p_1 : ℕ) ∨ e fun j ↦ b r j)) ((‖x_d‖, (⁇y_3 == fun_1 : True ∀ _y y != false))))) ≈\n          some ((x ᵡ e = True) | ((pᵢ x e) |= x_2) { x : True, value [0, (g : b ∨ [0].partRec b), [‖x_n‖⦄ ]] },\n            ({x₁ : true, x₂ : b} = x) ⟩) :=\n  by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V},\n  (Real.cos (InnerProductGeometry.angle x y) = 1) ↔ (InnerProductGeometry.angle x y = 0))", "theorem": "theorem InnerProductGeometry.cos_eq_one_iff_angle_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V},\n      (Real.cos (InnerProductGeometry.angle x y) = 1) ↔ (InnerProductGeometry.angle x y = 0)) :=\n  by sorry", "name": "InnerProductGeometry.cos_eq_one_iff_angle_eq_zero", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] → [InnerProductSpace ℝ V] → {x : V} → {y : V} → (0 ∈ Set.Icc 0 Real.pi) ↔ (0 ≤ Real.pi)", "lemma": "theorem aux.15115742578147444505 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} :\n    (0 ∈ Set.Icc 0 Real.pi) ↔ (0 ≤ Real.pi) := by sorry", "doc_string": "The cosine of the angle between two vectors is 1 if and only if the angle is 0. ", "generated": ["theorem aux.2122109538845530913 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} :\n    ((Real.cos (InnerProductGeometry.angle x y) = Real.cos 0) ↔ (InnerProductGeometry.angle x y = 0)) =\n      ((Real.cos (InnerProductGeometry.angle x y) = Real.cos 1) ↔ (InnerProductGeometry.angle x y = 0)) :=\n  by sorry ", "theorem aux.628580686054079011 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} :\n    Function.Injective Real.arccos := by sorry ", "theorem Iff.symm : ∀ {a b : Prop}, (a ↔ b) → (b ↔ a) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.133295457038676071 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V} :\n    x ⊤ = x := by sorry ", "theorem Real.cos_coe : ∀ (𝕜 : Type u_4) {a : NormedCyclicAx 𝕜 ℝ}, a * Real.cos (a.condition.some *a.realPos) = Real.cos 0 :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\n  (K : TopologicalSpace.PositiveCompacts G), LocallyCompactSpace G)", "theorem": "theorem TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_group :\n    (∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]\n      (K : TopologicalSpace.PositiveCompacts G), LocallyCompactSpace G) :=\n  by sorry", "name": "TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_group", "lemma-type": "{G : Type w} →\n  [TopologicalSpace G] →\n    [Group G] →\n      [TopologicalGroup G] →\n        (K : TopologicalSpace.PositiveCompacts G) → ∀ (_x : G) (hx : _x ∈ interior ↑K), LocallyCompactSpace G", "lemma": "theorem aux.2585326348481485053 {G : Type w} [TopologicalSpace G] [Group G] [TopologicalGroup G]\n    (K : TopologicalSpace.PositiveCompacts G) : ∀ (_x : G) (hx : _x ∈ interior ↑K), LocallyCompactSpace G := by sorry", "doc_string": "Every topological group in which there exists a compact set with nonempty interior\nis locally compact. ", "generated": ["theorem continuous_map_mul :\n    ∀ {G : Type u_3} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {G' : Type u_5}\n      [inst_3 : TopologicalSpace G'] [inst_4 : Group G'] [inst_5 : TopologicalGroup G'] (g :G →* G'),\n      Continuous ⇑g :=\n  by sorry ", "theorem forall_swingout : ∀ {α : Sort u_15} {o : Prop} {v : o → α → Prop} {o₂ : o} (b₁ : α), _ → v o₂ b₁ :\n    Sort u_15 := by sorry ", "theorem MulAction.fixedBy_comap :\n    ∀ {α : Type u} {MS : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : MulAction G α] (g : G),\n      MulAction.fixedBy α (g.imul₊) = MulAction.fixedBy (MulAction.comap (g.imul₊) α) (g.imul) :=\n  by sorry ", "theorem LocallyCompactSpace.map :\n    ∀ {X : Type u_1} {Y : Type u_2} {Z : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n      �ek : (j : Filter X) → Filter Y → Filter.AtTop j;\n      ⇑(ContinuousMap.eigenmapFilter X.uniformity fun U => ↑s.comap (Filter.comap id (id.openEmbedding_symm.map f) P) P) ∈\n          Ioi 0 :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.17548911809325820704 {G : Type u} [TopologicalSpace G] [Group G] [TopologicalGroup G]\n    (K : TopologicalSpace.PositiveCompacts G) : (fun (x : G) ↦ y) = fun (x : G) ↦ _ROOT_.real' := by sorry ", "theorem isCommute'_commensurator :\n    (∀ {G : Type u} [inst : Group G] {g₁ g₂ : G} (a : Commute g₁ g₂), Commute (Group.commensurator g [g₁, g₂] 1) 1) :=\n  by sorry ", "theorem continuous_div_mul_cocompact :\n    ∀ (G : Type uG) [inst : MeasureTheory.MeasureSpace G] [inst_1 : NormedDivisionRing G]\n      [inst_2 : NormedSpace ℝ G] [inst_3 : SMulWithZero ℝ G] [inst_4 : ContinuousSMul ℝ G]\n      [inst_5 : MDivWithZero G] [inst_6 : IsScalarTower ℝⁿ[C, N] M],Continuous (fun x => x / xⁿ ∉ K) :=\n  by sorry "]}
{"theorem-type": "(∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z))", "theorem": "theorem Complex.hasSum_sin :\n    (∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z)) := by\n  sorry", "name": "Complex.hasSum_sin", "lemma-type": "(z : ℂ) →\n  ∀ (n : ℕ),\n    (z ^ 2) ^ n * z * (-1) ^ n * (Complex.I / Complex.I / ↑(Nat.factorial (2 * n + 1))) =\n      (z ^ 2) ^ n * z * (-1) ^ n * (1 / ↑(Nat.factorial (2 * n + 1)))", "lemma": "theorem aux.4991165000913102833 (z : ℂ) :\n    ∀ (n : ℕ),\n      (z ^ 2) ^ n * z * (-1) ^ n * (Complex.I / Complex.I / ↑(Nat.factorial (2 * n + 1))) =\n        (z ^ 2) ^ n * z * (-1) ^ n * (1 / ↑(Nat.factorial (2 * n + 1))) :=\n  by sorry", "doc_string": "The power series expansion of `Complex.sin`. ", "generated": ["answer:\n3835136452361612970 (x : ℂ), Nat.rawCast 2 * Complex.I⁻¹ ^ Nat.rawCast 2 * Nat.rawCast 1 = Nat.rawCast 1 * 0 := by sorry ", "theorem aux.7964851802937297755 (z : ℂ) (b : ℤ) (r : { b : ℤ // b ≤ -APlha }) :\n    apowr (-b)* w = w * ↑(Complex.I) * apow (↑(Int.ofNat | ↑(-(-b))) * b) w := by sorry ", "theorem real_sinh_eq : ∀ (x : ℝ), Complex.Exp ↑(Real.sinh x) = Complex.sinh ↑x := by sorry ", "suggest_interval :\n∀ (a b : ℝ),\nIf b < a then\n      ∀ {μ : ℔ | b ≤ d | ε} (δ2 : ℚ → Real | b < rδ | ε = ↑k) _✝ | d (k * |ε)| = |ε| * 3 = True ∨\n        a ↑(σa.size • k < a |ε∥ ^ k :=\n  by sorry ", "theorem pow_one : ∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a := by sorry ", "theorem HasSum.add :\n    ∀ {α : Type u_1} {β : Type u_2} {R : Type u_4} [inst : AddCommMonoid α] [inst_1 : Module R α]\n      {f : β → α} {a b : R} {s : β} (hf : HasSum f a) (hfs : HasSum ((fun b => (f b + 1)⁻¹) ∘ b) b),\n      HasSum (fun b => f b) (a - -∑' (b : β), (fun b => (f b + 1)⁻¹) b) :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(padicValNat = Nat.maxPowDiv)", "theorem": "theorem padicValNat.padicValNat_eq_maxPowDiv : (padicValNat = Nat.maxPowDiv) := by sorry", "name": "padicValNat.padicValNat_eq_maxPowDiv", "lemma-type": "(p : ℕ) → (n : ℕ) → (h_1 : p ≤ 1) → Mathlib.Meta.NormNum.IsNat 1 1", "lemma": "theorem aux.784907072425094556 (p : ℕ) (n : ℕ) (h_1 : p ≤ 1) : Mathlib.Meta.NormNum.IsNat 1 1 := by sorry", "doc_string": "Allows for more efficient code for `padicValNat` ", "generated": ["theorem of_eq_true : ∀ {t : Prop}, t = true → t := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem mul_zero : ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] (a : M₀), a * 0 = 0 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.193077045292873136 {p : A'} {P : A} _ : PadicValNat.multiplicity p (↑p * ↑n + ↑n) = PadicValNat.multiplicity p ↑n + PadicValNat.multiplicity p N := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Nat.maxPowDiv'_of_eq :\n    ⇑Nat.minFac = fun (n : ℕ) ↦ Finsupp.prod ↑Nat.primes fun (p : ℕ) (xp : ℕ) => ↑(Nat.pow p xp)\n        ofAdd' (_ : Finset.range 0 = Nat.primes) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} [inst : TopologicalSpace X] (f : C(X, NNReal)) {c : NNReal} (hc : 0 < c),\n  ∃ g, (∀ (x : X), (g * f) x ≤ 1) ∧ (Set.EqOn (⇑(g * f)) 1 {x : X | c ≤ f x}))", "theorem": "theorem ContinuousMap.exists_mul_le_one_eqOn_ge :\n    (∀ {X : Type u_1} [inst : TopologicalSpace X] (f : C(X, NNReal)) {c : NNReal} (hc : 0 < c),\n      ∃ g, (∀ (x : X), (g * f) x ≤ 1) ∧ (Set.EqOn (⇑(g * f)) 1 {x : X | c ≤ f x})) :=\n  by sorry", "name": "ContinuousMap.exists_mul_le_one_eqOn_ge", "lemma-type": "{X : Type u_1} →\n  [TopologicalSpace X] →\n    (f : C(X, NNReal)) →\n      {c : NNReal} → (hc : 0 < c) → (x : X) → (hx : x ∈ {x : X | c ≤ f x}) → (f x ∈ {x : NNReal | c ≤ x}) ↔ (c ≤ f x)", "lemma": "theorem aux.18041696145785534930 {X : Type u_1} [TopologicalSpace X] (f : C(X, NNReal)) {c : NNReal} (hc : 0 < c)\n    (x : X) (hx : x ∈ {x : X | c ≤ f x}) : (f x ∈ {x : NNReal | c ≤ x}) ↔ (c ≤ f x) := by sorry", "doc_string": "An auxiliary lemma used in the proof of `ContinuousMap.idealOfSet_ofIdeal_eq_closure` which may\nbe useful on its own. ", "generated": ["theorem aux.16335839907663222989 {X : Type u_1} [TopologicalSpace X] (f : C(X, NNReal)) {c : NNReal} (hc : 0 < c)\n    (g : C(X, NNReal)) (x : ↑fun (ℝ : Type u_1) ↦ Unit.unit • c) :\n    ((starRingEnd ℚ) Unit⁻¹.2 • g : C(X, NNReal) x ≤ 1 x := by sorry  }) : And True := by sorry ", "theorem Set.inter_union_left : ∀ {α : Type u} (a b : Set α), a ∩ (a ∩ b) ⊆ a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem mul_one : ∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem mul_nonneg : ∀ {α : Type u_1} [inst : LinearOrderedSemiring α] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a * b := by sorry ", "theorem funext : ∀ {α : Sort u_1} {β : α → Sort u_2} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by\n  sorry "]}
{"theorem-type": "(∀ {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {δ : ℝ} {K : ℝ} {ε : ℝ} {a : ℝ} {b : ℝ} (hf : ContinuousOn f (Set.Icc a b))\n  (hf' :\n    ∀ (x : ℝ) (a : x ∈ Set.Ico a b) (r : ℝ) (a : f' x < r),\n      ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), (z - x)⁻¹ * (f z - f x) < r)\n  (ha : f a ≤ δ) (bound : ∀ (x : ℝ) (a : x ∈ Set.Ico a b), f' x ≤ K * f x + ε) (x : ℝ) (a_1 : x ∈ Set.Icc a b),\n  f x ≤ gronwallBound δ K ε (x - a))", "theorem": "theorem le_gronwallBound_of_liminf_deriv_right_le :\n    (∀ {f : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {δ : ℝ} {K : ℝ} {ε : ℝ} {a : ℝ} {b : ℝ} (hf : ContinuousOn f (Set.Icc a b))\n      (hf' :\n        ∀ (x : ℝ) (a : x ∈ Set.Ico a b) (r : ℝ) (a : f' x < r),\n          ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), (z - x)⁻¹ * (f z - f x) < r)\n      (ha : f a ≤ δ) (bound : ∀ (x : ℝ) (a : x ∈ Set.Ico a b), f' x ≤ K * f x + ε) (x : ℝ) (a_1 : x ∈ Set.Icc a b),\n      f x ≤ gronwallBound δ K ε (x - a)) :=\n  by sorry", "name": "le_gronwallBound_of_liminf_deriv_right_le", "lemma-type": "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {b : β} {s : Set α} {x : α},\n  ContinuousWithinAt (fun x => b) s x", "lemma": "theorem continuousWithinAt_const :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {b : β} {s : Set α}\n      {x : α}, ContinuousWithinAt (fun x => b) s x :=\n  by sorry", "doc_string": "A Grönwall-like inequality: if `f : ℝ → ℝ` is continuous on `[a, b]` and satisfies\nthe inequalities `f a ≤ δ` and\n`∀ x ∈ [a, b), liminf_{z→x+0} (f z - f x)/(z - x) ≤ K * (f x) + ε`, then `f x`\nis bounded by `gronwallBound δ K ε (x - a)` on `[a, b]`.\n\nSee also `norm_le_gronwallBound_of_norm_deriv_right_le` for a version bounding `‖f x‖`,\n`f : ℝ → E`. ", "generated": ["theorem And.right : ∀ {a b : Prop }, a ∧ b → b := by sorry ", "theorem LE.le.trans_eq : ∀ {α : Type u_1} {a b c : α} [inst : LE α], a ≤ b → b = c → (c ≤ a ∨ a ≤ c) → a ≤ c := by\n  sorry ", "statement aux.82756029874827245 : ∀ (t : ℝ) (ht : t ∈ Set.Ico a b), (fun (x : ℝ) ↦ Real.deriv f x) t * t = b - a :=\n  by sorry ", "theorem aux.3088595796713080887 {ƒ : (a : ℝ) → ℝ} {f' : (a : ℝ) → ℝ} {a : ℝ} {b : ℝ} (hf : ContinuousOn f (Set.Icc a b))\n    (hf' :\n      ∀ (x : ℝ) (a : x ∈ Set.Ico a b) (r : ℝ) (a : f' x < r),\n        ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), (z - x)⁻¹ * (f z - f x) < r)\n    (ha : f a ≤ δ) (bound : ∀ (x : ℝ) (a : x ∈ Set.Ico a b), f' x ≤ K * f x + ε) : b > a := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem norm_of_nonneg : ∀ {E : Type u_6} [inst : semiNormedAddGroup E] x, ‖x‖ = 0 → x.re ≥ 0 := by sorry ", "theorem pow_nonneg : ∀ {n : ℕ} {a : ℝ}, 0 ≤ a → 0 ≤ a ^ n := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {n : ℕ} (p : Fin (n + 1)) (i : Fin n), (Fin.succAbove p i < p) ↔ (Fin.castSucc i < p))", "theorem": "theorem Fin.succAbove_lt_iff_castSucc_lt :\n    (∀ {n : ℕ} (p : Fin (n + 1)) (i : Fin n), (Fin.succAbove p i < p) ↔ (Fin.castSucc i < p)) := by sorry", "name": "Fin.succAbove_lt_iff_castSucc_lt", "lemma-type": "{n : ℕ} → (p : Fin (n + 1)) → (i : Fin n) → (Fin.castSucc i < p) ∨ (p < Fin.succ i)", "lemma": "theorem aux.7183367537486185285 {n : ℕ} (p : Fin (n + 1)) (i : Fin n) : (Fin.castSucc i < p) ∨ (p < Fin.succ i) := by\n  sorry", "doc_string": "Embedding `i : Fin n` into `Fin (n + 1)` using a pivot `p` that is greater\nresults in a value that is less than `p`. ", "generated": ["theorem Nat.castSucc_lt_gc : ∀ (i j : ℤ) {k : ℕ}, Nat.castSucc i lt_gc p → j < k → j < Nat.castSucc k := by\n  sorry ", "theorem congr_fun : ∀ {α : Sort u} {β : α → Sort v} {x vs y : α}, x = y → (g : α → β) → g x = g y := by sorry ", "theorem aux.11971067823896231554 {n : ℕ} (p : Fin (n + 1)) (i : Fin n) : (Fin.castSucc i < p) = (i < Fin.succAbove p i) :=\n  by sorry ", "theorem LT.lt_trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b < c → a < c := by sorry ", "theorem Fin.lt_succAbove_iff' :\n    ∀ {n : ℕ} (p : Fin (n + 1)) (m : Fin n), (m < Fin.succAbove p m) ↔ ∀ (r : p ≤ m =· True), m < p := by sorry ", "theorem LE.leq.not_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≤ b → ¬b < a := by sorry ", "theorem FinMap.coe :\n    ∀ {𝕜 : Type u} {M : Type v} [inst : LinearOrderedSemiring 𝕜] [inst_1 : AddZeroClass M] [inst_2 : Archimedean � Kos ]{f : Fin M →. 𝕜 →+ 𝕜} (a [hn : NonunitalAlgHomClass 𝕜 𝕜 (↥M) 𝕜] (n : M → 𝕜), ∀ (k : Fin ↑n), FinMapAux (↑k) (MulOpposite 𝕜) a n = FinSet.univ.map (f ∘ ⇑(↑k)) None nₚ) := by sorry ", "theorem aux.591584030620201790 {n : ℕ} (p : Fin (n + 1)) (i : Fin n) : Fin.castSucc i = Fin.succAbove (Fin.castSuccAboveIso p)⁻¹ (Fin.castSuccAboveInvert i) := by sorry "]}
{"theorem-type": "(∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] (X : C)\n  (Y : C) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y] {b : CategoryTheory.Limits.BinaryBicone X Y}\n  (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n  (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBicone.IsBilimit.isLimit hb)\n        (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).inv =\n    CategoryTheory.Limits.biprod.desc (CategoryTheory.Limits.BinaryBicone.inl b)\n      (CategoryTheory.Limits.BinaryBicone.inr b))", "theorem": "theorem CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv :\n    (∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n      (X : C) (Y : C) [inst_2 : CategoryTheory.Limits.HasBinaryBiproduct X Y]\n      {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b),\n      (CategoryTheory.Limits.IsLimit.conePointUniqueUpToIso (CategoryTheory.Limits.BinaryBicone.IsBilimit.isLimit hb)\n            (CategoryTheory.Limits.BinaryBiproduct.isLimit X Y)).inv =\n        CategoryTheory.Limits.biprod.desc (CategoryTheory.Limits.BinaryBicone.inl b)\n          (CategoryTheory.Limits.BinaryBicone.inr b)) :=\n  by sorry", "name": "CategoryTheory.Limits.biprod.conePointUniqueUpToIso_inv", "lemma-type": "{C : Type u} →\n  [CategoryTheory.Category.{v, u} C] →\n    [CategoryTheory.Limits.HasZeroMorphisms C] →\n      (X : C) →\n        (Y : C) →\n          [CategoryTheory.Limits.HasBinaryBiproduct X Y] →\n            {b : CategoryTheory.Limits.BinaryBicone X Y} →\n              (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b) →\n                (j : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) →\n                  (as : CategoryTheory.Limits.WalkingPair) →\n                    Eq\n                        (CategoryTheory.CategoryStruct.comp\n                          (CategoryTheory.Limits.BinaryBicone.inl (CategoryTheory.Limits.BinaryBiproduct.bicone X Y))\n                          (CategoryTheory.Limits.BinaryBicone.snd (CategoryTheory.Limits.BinaryBiproduct.bicone X Y))) =\n                      Eq 0", "lemma": "theorem aux.1680538391595711988 {C : Type u} [CategoryTheory.Category.{v, u} C]\n    [CategoryTheory.Limits.HasZeroMorphisms C] (X : C) (Y : C) [CategoryTheory.Limits.HasBinaryBiproduct X Y]\n    {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b)\n    (j : CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) (as : CategoryTheory.Limits.WalkingPair) :\n    Eq\n        (CategoryTheory.CategoryStruct.comp\n          (CategoryTheory.Limits.BinaryBicone.inl (CategoryTheory.Limits.BinaryBiproduct.bicone X Y))\n          (CategoryTheory.Limits.BinaryBicone.snd (CategoryTheory.Limits.BinaryBiproduct.bicone X Y))) =\n      Eq 0 :=\n  by sorry", "doc_string": "Auxiliary lemma for `biprod.uniqueUpToIso`. ", "generated": ["theorem CategoryTheory.Limits.IsLimit.fac :\n    ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {F : C} (con : CategoryTheory.Limits.Cocone F)\n      {Q X : C} {G H : Q ⟶ X}\n      (s' : CategoryTheory.InductiveLimits F → Bundle.CompletionComponent (CategoryTheory.Limits.Cocone s')),\n      CategoryTheory.CategoryStruct.comp\n        Bundle.InductiveLimitAux.map.eval categoryStructTopCategoryOfXs\n        (CategoryTheoryCommSq.sq_toInductIsoOfColimit (CategoryTheory.Limits.limitColimit Q)\n          this.1 f) s' →\n        ∀ {p₁ : CategoryTheoryInductiveLimitAux F} (p₂ : CategoryTheoryInductiveLimitAux F) {R F : UnitCoe Q ⟶ e₁},\n          ((CategoryTheory.InductiveLimit.sqF N N_1 F r dH\n                (Splits F (CategoryTheory.InductiveLimit.congrF d s)) (r, c)).mapS\n                ((CategoryTheoryInductiveLimitAux F f₂ ≤ Bundle.InductiveLimitIslP1 e₂ (S : P ω)) / x) p₁ {\n                h₁ :=\n                (((CategoryTheory.InductiveLimit.eq F fun x\n                  (m : CategoryTheory.inductiveLimit HomologicalComplexCochain ω N ⁿ = m₁) ↦\n                    (h = e₂ = false ?_)))\n                {\n                  e :\n                    (↑(e₃ r)) => Bundle.ComptrHom.toIsetIcc r ↑s.toEq _ a p₄ hm₁\n                 to_receiver = Bundle.ComptrHom.toEq fun x => Ioc_extension f₂ hm | h → f₂ (a, x)},\n                h₂ := h₂}\n                 d) a_eq\n                 e_eq ((congrArg fun\n                       ↦\n                       ∀ (p : W (1 : Bundle.ComptrHom.iLToA M N) .1), p a_h n (r = a.elim₃ p) = H (f n₂ b c, N) h₁).trans\n                     true),\n                    β n a =\n              a_eq _ :\n    (m = M) ∧\n      (e_h u t a\n          H\n            (H ⋯ hg' gH h' t a, m) (CategoryTheory.CategoryStruct.comp (H _ e [M.1 = l1 n] ht) φb).h2 u p' (a, x'))\n    ↔\n      (a_h = H (H = φg [l1].isTrue ⋯ hG hp'.h2, fun _d₁ ei' hr' _t1).snd) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem CategoryTheory.Limits.IsLimit.lift_fac :\n    ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J A B XX XX' : C}\n      (s : CategoryTheory.Limits.Solution₂ R X),\n      CategoryTheory.Limits.IsLimit s →\n        ∀ c : CategoryTheory.Limits.Cone R,\n          CategoryTheory.Limits.IsLimit.lift c s = c.π :=\n  by sorry ", "theorem aux.3175251547462219662 {C : Type u} [CategoryTheory.Category.{v, u} C] [CategoryTheory.Limits.HasZeroMorphisms C]\n    (X : C) (Y : C) [CategoryTheory.Limits.HasBinaryBiproduct X Y]\n    {b : CategoryTheory.Limits.BinaryBicone X Y} (hb : CategoryTheory.Limits.BinaryBicone.IsBilimit b) :\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id Y)\n          (CategoryTheory.CategoryStruct.comp r b.binaryBiconeB.toc b.binaryBiconeA)) Y\n        CategoryTheory.Limits.biprod.inl =\n      CategoryTheory.CategoryStruct.compr₂ CategoryTheory.Limits.biprod.sumb a\n        (bifunctor CategoryTheory.Limits.biprod b.binaryBicone.inl b.binaryBicone.inr)\n        (CategoryTheory.Limits.biprod.bicokernelDesc b.binaryBicone) :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_2} {M : Type u_5} [inst : AddCommMonoid M] {f : (a : α) → M} {s : Set β} {g : (a : β) → α}\n  (hg : Set.InjOn g (s ∩ Function.support (f ∘ g))),\n  (finsum fun (i : α) ↦ finsum fun (h : i ∈ g '' s) ↦ f i) = finsum fun (j : β) ↦ finsum fun (h : j ∈ s) ↦ f (g j))", "theorem": "theorem finsum_mem_image' :\n    (∀ {α : Type u_1} {β : Type u_2} {M : Type u_5} [inst : AddCommMonoid M] {f : (a : α) → M} {s : Set β}\n      {g : (a : β) → α} (hg : Set.InjOn g (s ∩ Function.support (f ∘ g))),\n      (finsum fun (i : α) ↦ finsum fun (h : i ∈ g '' s) ↦ f i) =\n        finsum fun (j : β) ↦ finsum fun (h : j ∈ s) ↦ f (g j)) :=\n  by sorry", "name": "finsum_mem_image'", "lemma-type": "∀ {α : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] {f : α → M} {s : Set α},\n  Set.Infinite (s ∩ Function.support f) → (finsum fun i => finsum fun h => f i) = 0", "lemma": "theorem finsum_mem_eq_zero_of_infinite :\n    ∀ {α : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] {f : α → M} {s : Set α},\n      Set.Infinite (s ∩ Function.support f) → (finsum fun i => finsum fun h => f i) = 0 :=\n  by sorry", "doc_string": "The sum of `f y` over `y ∈ g '' s` equals the sum of `f (g i)` over `s` provided that\n`g` is injective on `s ∩ support (f ∘ g)`.", "generated": ["theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry ", "theorem finsum_mem_eq_of_injOn :\n    ∀ {α : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] {f : α →₀ M} {s : Set α} {g : α → α},\n      Function.InjOn g s →\n        (f = finsum fun e => lhammerSeriesSingle R ⇑[g (EuclideanGeometry.finsetFromPointSolidGeometric e)]\n          id ⇑(EuclideanGeometry.SolidAngles.unitSphere e) ↔ (f = finsum fun e => rhoInvSingle e ⇑[g (EuclideanGeometry.finsetFromPointSolidGeometric e)]\n            (EuclideanGeometry.SolidAngles.unitSphere e) ⇑(EuclideanGeometry.Finset.prod s id))) :=\n  by sorry\n``` [/INST] theorem InjOn.mono' :\n    ∀ {α : Sort u_1} {κ : Sort u_2} {β : α → κ → Sort u_3} {a : α} {i : κ} {j : κ} (x : a ∈ Set.range i ∩ Set.range j)\n      {π₁ : α → κ → Sort u_5} {π₃ : (i : α) → j → sᵢ / ≤ ys ω₁ p f} [Subsingleton { j₁, y₂ i j' h f wᶜ }, f ∈ S ys f :=\n  let l : π₃ × sᶡ := if f → (pi fun (i' : j) ↦ Subtype.val) { j, j → ys → π i, y' h } i j' h j = f;\n  Nat.find (NB.proofN f f_1 ((if g -> y j h j = ↑y jᶠ ≤ y' h) yt' γ h) e ≠ 0) g (id :=\n        (fun (θ' : y₀ / sᶢ ⧻ t = NB.some n, _ : g n == true) ↦ yw₀ r x_4 = Nat.find (SubringFilter.complementIsPureFG f e, false)) :=\n  id = t :=\n  by sorry ", "theorem aux.17742933473921412542 {α : Type u_1} {β : Type u_2} {M : Type u_5} [AddCommMonoid M] {f : (a : α) → M}\n    {s : Set β} {g : (a : β) → α} (hg : Set.InjOn g (s ∩ Function.support (f ∘ g))) (x : α) : x ∈ id '' id ⁻¹' s :=\n  by sorry ", "theorem finsum_mem_univ :\n    ∀ {α : Type u_1} {M : Type u_5} [inst : AddCommMonoid M] (a : α) (f : α → M),\n      (finsum fun i => finsum fun h => f i) = finsum fun i => f i :=\n  by sorry ", "theorem Set.mem_image_of_mem : ∀ {α : Type u_1} {β : Type u_2} (f : α → β) {x : α} {v : β}, x ∈ f '' s → x ∈ s ∧ f x = v → x ∈ f '' {a | a ∈ s ∧ f a = v} := by sorry ", "theorem finsum_const :\n    ∀ {M : Type u_2} {α : Sort u_6} [inst : AddCommMonoid M] [inst_1 : DecidableEq α],\n      ∀ (x : M), (finsum fun i => x) = x :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem if_neg : ∀ {c : Prop} {h : c → False}, ¬c → ¬c := by sorry "]}
{"theorem-type": "(∀ {R : Type u} [inst : CommRing R] {J : Ideal R} [hR : IsNoetherian R R],\n  CategoryTheory.Functor.Initial (localCohomology.idealPowersToSelfLERadical J))", "theorem": "theorem localCohomology.ideal_powers_initial :\n    (∀ {R : Type u} [inst : CommRing R] {J : Ideal R} [hR : IsNoetherian R R],\n      CategoryTheory.Functor.Initial (localCohomology.idealPowersToSelfLERadical J)) :=\n  by sorry", "name": "localCohomology.ideal_powers_initial", "lemma-type": "∀ {α : Type u_1} {r : α → α → Prop} {a b : α}, r a b → Relation.ReflTransGen r a b", "lemma": "theorem Relation.ReflTransGen.single :\n    ∀ {α : Type u_1} {r : α → α → Prop} {a b : α}, r a b → Relation.ReflTransGen r a b := by sorry", "doc_string": "The diagram of powers of `J` is initial in the diagram of all ideals with\nradical containing `J`. This uses noetherianness. ", "generated": ["theorem aux.899780472369364498 {R : Type u} [CommRing R] {J : Ideal R} [hR : IsNoetherian R R] :\n    (CategoryTheory.ShortComplex.SnakeTo.Map\n          (LinearEqualizer.ι\n            (CategoryTheory.ShortComplex.ObjIsMono.Equiven.unit\n              ((CategoryTheory.ShortComplex.Exact fun (PQF : Type q) ┤LocalRings.exact_seq P Q F)\n                (LocalRings.coeffectiveMorphism [Eq p]))) ≫\n            CategoryTheory.CategoryStruct.comp\n              (Iso.hom ((CategoryTheory.ShortComplex.BareCochaise.counit iso.symm) q) p).symm σ =\n          CategoryTheory.ShortComplex.App.w h.vj1 f') →\n        Iso.hom (CategoryTheory.ShortComplex.App r (LocalRings.Cotot.Q' p j (f hF))) p = 0 :=\n  by sorry ", "theorem congrArg : ∀ {α ; β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Ideal.eq_univ_iff :\n    ∀ {R : Type u}> [inst : Semiring R] (I : ideal R), (I = ⊤ ↔ ∀ (r : R), r ∈ I) := by sorry ", "theorem map_one :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_6} [inst : Functor F] [inst_1 : Monoid M] [inst_2 : Monoid N]\n      [inst_3 : HomClass F M N], (Functor.toEpi F).map 1 = 1 :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem SelfEquiv.invFn_fun_self_of_refLift : ∀ {α : Sort u_1} [self : SelfEquiv α] {i : α} (j : BetaMap α α) · j i := by\n  sorry ", "theorem aux.11936296677194982739 {R : Type u} [CommRing R] {J : Ideal R} [hR : IsNoetherianRing R]\n    {K : Type u} [CommRing K] (φ : localCohomology.IdealPowersToSelfInitial.Hom L B J) :\n    hom ((idealPowersToTop K J).x ◃ CategoryTheory.Topology.SelfLiftStruct.f φ) (ItoT R n)\n        ((ItoT R n).toTo_lhPullback (map ℿ J.primeCompl B R φ)) =\n      True :=\n  by sorry ", "theorem And.left : ∀ {a b : Prop}, a ⊓ b → a := by sorry "]}
{"theorem-type": "(∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1), p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂)", "theorem": "theorem NNReal.geom_mean_le_arith_mean2_weighted :\n    (∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1),\n      p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂) :=\n  by sorry", "name": "NNReal.geom_mean_le_arith_mean2_weighted", "lemma-type": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a", "lemma": "theorem add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry", "doc_string": "The geometric mean is less than or equal to the arithmetic mean, weighted version\nfor two `NNReal` numbers. ", "generated": ["theorem neg_div : ∀ {K : Type u_1} [inst : DivisionRing K'] (a b : K), -b / a = a / b := by sorry ", "theorem Set.abs_biUnion_univ : ∀ {β : Type u_6} {f : α → β → ℕ} (a : α), ‖f a '' Set.univ‖ = ∫ i, NNReal.ofNat ↑(f i a) ∂ν := by sorry ", "theorem Fin.ext : ∀ {n : ℕ} {ab ab : Fin n → α} (a : ab = ab'), ∀ (i : Fin n), a i = ab i i := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem MulZeroClass.mul_zero := by sorry ", "theorem NNReal.mul_eq_mul_ofInt : ∀ {n : ℕ} {r₁ r₂ : NNReal}, ↑n * r₁ = ↑n * ↑⠨ r₂ := by sorry ", "theorem congrEq : ∀ {α : Sort u_1} {a b : α}, a = b → (a = a ↔ b = b) := by sorry ", "suggest_doc : Lean 4 theorem\nValue:\nState a Lean 4 theorem.\nCode:\n```lean\ntheorem NNReal.geom_mean_le_arith_mean2_weighted :\n    (∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1),\n      p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂) :=\n  by sorry\n``` [/INST] theorem Nat.cast_one : ∀ {A : Type a* a1} [inst : AddMonoidWithOne A], ↑1 = 1 := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α)", "theorem": "theorem ConditionallyCompleteLinearOrderedField.to_archimedean :\n    (∀ {α : Type u_2} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α) := by sorry", "name": "ConditionallyCompleteLinearOrderedField.to_archimedean", "lemma-type": "{α : Type u_2} →\n  [ConditionallyCompleteLinearOrderedField α] →\n    (h : ¬(∀ (x : α), ∃ n, x < ↑n)) →\n      (x : α) → (h : ∀ (n : ℕ), ↑n ≤ x) → Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1)", "lemma": "theorem aux.8444235032112521394 {α : Type u_2} [ConditionallyCompleteLinearOrderedField α]\n    (h : ¬(∀ (x : α), ∃ n, x < ↑n)) (x : α) (h : ∀ (n : ℕ), ↑n ≤ x) :\n    Mathlib.Meta.NormNum.IsInt (Nat.rawCast 1) (Int.ofNat 1) := by sorry", "doc_string": "Any conditionally complete linearly ordered field is archimedean. ", "generated": ["theorem add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry ", "theorem ConditionallyCompleteLinearOrderedField.exists :\n    ∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α]\n      [inst_1 : OrderedSMul ≈(fun x x_1 _ => x + x_1) {\\_ ×ᵒ {α := fun x x_1 => x * x_1}}»α »] {k k' : α}\n      [inst_2 : Archimedean α], ∀ (h : 0 ≤ k) (h' : k < _mul_one k'), { n: α | 0 < n ∧ n ≤ k } ≠ ∅ :=\n  by sorry ", "theorem conditionallyCompleteLinearOrderedField_mul_div :\n    ∀ {α : Type u} [uα : UniqueField α] [_inst : OrderedSemiring α] {a b c : α}, b ≠ 0 → hβ : a / b < c ↔ b • a < c • b :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem lt_succ_of_le : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : SuccOrder α] {a : α}, a ≤ succ a → a < succ a :=\n  by sorry ", "category :\n```lean\ntheorem And' False : (b ∨ a) = a := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem implies_and_true : ∀ (p q : Prop), (p → q) → (q ∧ True) := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (f : V ≃ₗᵢ[ℝ] ℂ)\n  (hf : (Orientation.map (Fin 2) (LinearIsometryEquiv.toLinearEquiv f)) o = Complex.orientation) (x : V) (y : V),\n  Orientation.oangle o x y = ↑(Complex.arg ((starRingEnd ℂ) (f x) * f y)))", "theorem": "theorem Orientation.oangle_map_complex :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (f : V ≃ₗᵢ[ℝ] ℂ)\n      (hf : (Orientation.map (Fin 2) (LinearIsometryEquiv.toLinearEquiv f)) o = Complex.orientation) (x : V) (y : V),\n      Orientation.oangle o x y = ↑(Complex.arg ((starRingEnd ℂ) (f x) * f y))) :=\n  by sorry", "name": "Orientation.oangle_map_complex", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      [Fact (FiniteDimensional.finrank ℝ V = 2)] →\n        (o : Orientation ℝ V (Fin 2)) →\n          (f : V ≃ₗᵢ[ℝ] ℂ) →\n            (hf : (Orientation.map (Fin 2) (LinearIsometryEquiv.toLinearEquiv f)) o = Complex.orientation) →\n              (x : V) →\n                (y : V) →\n                  ↑(Complex.arg ((starRingEnd ℂ) (f x) * f y)) = Orientation.oangle Complex.orientation (f x) (f y)", "lemma": "theorem aux.3221056966611245201 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (f : V ≃ₗᵢ[ℝ] ℂ)\n    (hf : (Orientation.map (Fin 2) (LinearIsometryEquiv.toLinearEquiv f)) o = Complex.orientation) (x : V) (y : V) :\n    ↑(Complex.arg ((starRingEnd ℂ) (f x) * f y)) = Orientation.oangle Complex.orientation (f x) (f y) := by sorry", "doc_string": "The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\nterms of a complex-number representation of the space. ", "generated": ["theorem sub_neg_comm : ∀ {α : Type u} [inst : Ring α] (x : α) (y : α), x - -y = x + y := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Function.Injective.left_inv :\n    ∀ {α : Type u} {β : Type v} {motive : α → β} {some_is_singleton : ∀ a, ∃! b, ⇑motive a = b},\n      Function.Injective motive → ∀ (a' : α) (a : a' ∈ ↑(Set.range ⇑nonempty_fiberType : Set γ)), ⇑(nonempty_iProdNonunit motive o a') = a' :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α} (h : a = b), c = a → c = b := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Symm.trans : ∀ {α : Sort u} {r : α → α → Prop} {f g : α}, Symm r → Symm r → r f g → r g f := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {R : Type u} {S : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n  {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n  (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n  (hv :\n    ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n      f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n  (hp : p₁ = p₂), f₁ p₁ = f₂ p₂)", "theorem": "theorem MvPolynomial.hom_congr_vars :\n    (∀ {R : Type u} {S : Type v} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S]\n      {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n      (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n      (hv :\n        ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n          f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n      (hp : p₁ = p₂), f₁ p₁ = f₂ p₂) :=\n  by sorry", "name": "MvPolynomial.hom_congr_vars", "lemma-type": "∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R] {A : Type u_2} [inst_1 : Semiring A]\n  {f g : MvPolynomial σ R →+* A},\n  RingHom.comp f MvPolynomial.C = RingHom.comp g MvPolynomial.C →\n    (∀ (i : σ), f (MvPolynomial.X i) = g (MvPolynomial.X i)) → f = g", "lemma": "theorem MvPolynomial.ringHom_ext' :\n    ∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R] {A : Type u_2} [inst_1 : Semiring A]\n      {f g : MvPolynomial σ R →+* A},\n      RingHom.comp f MvPolynomial.C = RingHom.comp g MvPolynomial.C →\n        (∀ (i : σ), f (MvPolynomial.X i) = g (MvPolynomial.X i)) → f = g :=\n  by sorry", "doc_string": "If `f₁` and `f₂` are ring homs out of the polynomial ring and `p₁` and `p₂` are polynomials,\nthen `f₁ p₁ = f₂ p₂` if `p₁ = p₂` and `f₁` and `f₂` are equal on `R` and on the variables\nof `p₁`.  ", "generated": ["theorem RingHom.map_sub : ∀ {S : Type u} {R : Type v} {A : Type w} [inst : CommSemiring S] [inst_1 : CommSemiring R]\n    [inst_2 : Semiring A] [inst_3 : Algebra S R] [inst_4 : Algebra S A] (f : R →+* S) (m n : A); f (m - n) = f m - f n :=\n  by sorry ", "theorem aux.1539959920426831919 {R : Type u} {S : Type v} {σ : Type u_1} [CommSemiring R] [CommSemiring S]\n    {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n    (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n    (hv :\n      ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂),\n        f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n    (hp : p₁ = p₂) (a : σ →₀ ℕ) (RingHom.comp f₁ (MvPolynomial.C a) = RingHom.comp f₂ (MvPolynomial.C a)) :\n    RingHom.comp (RingHom.comp f₁ MvPolynomial.C) (MvPolynomial.X a) 1 =\n      MvPolynomial.weightMatrix σ\n          (MvPolynomial.weightedDegreeToWeightedDegreeFactor R a) *=\n        if h : (¬(MvPolynomial.X a ∈ MvPolynomial.vars p₁) ∧ (MvPolynomial.X a ∈ MvPolynomial.vars p₂)) then 1\n        else 0 :=\n  by sorry ", "answer:\n9938113932117481126 (R ; S ) [inst : Comm Semiring R] [inst_1 : CommSemiring S]\n    (f₁ : MvPolynomial σ R →+* S) (f₂ : MvPolynomial σ R →+* S) ({i : σ} (α : bool × bool), i ∈ σ) →\n    (a : R {× († a}.2).1) → ∀ (x_0 : σ) (f : MvPolynomial σ R), f 1 = f {} := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem MvPolynomial.mul_X_right' :\n    ∀ (R : Type u_1) {sigma τ : Type u_2 →⊣ (v₃ ^⁻¹)ι) [T4 (σ <| tříždost.trivial : ModuleFreeTrivialNonHermitian R σ) ],\n      Function.Surjective (Prod.map g { add_right_commutative := _i, partialApplication := ⊛, rg' := igg }) g) :=\n  by sorry\n``` [/INST] stateing theorem of the IMO ( Internation Math Olimpique ) 2010 Q4 :\n```lean\ntheorem IMO2010Q4 :\n    (∀ {W : (a : Fin 4 → ℕ) → ℕ} (imo : IMO2010Q4 a w), (Finsets.sum (Finset.range 4) finFun w = a) ∧ {2, 2} = true ·\n        true) :=\n  by sorry\n``` [/INST] theorem aux.14675 : IMO2010Q4 a w := by sorry ", "theorem add_comm_one :\n    ∀ {G : Type u_3} [inst : Right cancel monoid G] [inst_1 : LocalRing : subnegZero (MvPowerSeries G)] (k : G),\n      k + 1 = 1 + k :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.7475837078133395923 {R : Type u} {S : Type v} {σ : Type u_1} [CommSemiring R] [CommSemiring S]\n    {f₁ : MvPolynomial σ R →+* S} {f₂ : MvPolynomial σ R →+* S} {p₁ : MvPolynomial σ R} {p₂ : MvPolynomial σ R}\n    (hC : RingHom.comp f₁ MvPolynomial.C = RingHom.comp f₂ MvPolynomial.C)\n    (hv : ∀ (i : σ) (a : i ∈ MvPolynomial.vars p₁) (a : i ∈ MvPolynomial.vars p₂), f₁ (MvPolynomial.X i) = f₂ (MvPolynomial.X i))\n    (hp : p₁ = p₂) (q : MvPolynomial σ R) : ∀ (hq : (fun (i : σ) ↦ Polynomial.X i) '' MvPolynomial.vars q = ∅),\n    f₁ (q * p₁) = eq (Simp.mulToSingleHom f₁ hC fun _a => f₂) (Simp.mulToSingleHom f₂ hC fun _a => f₁ 1)q :=\n  by sorry "]}
{"theorem-type": "(∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n  (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x) (hT : 0 < T),\n  Filter.Tendsto (fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop)", "theorem": "theorem Function.Periodic.tendsto_atTop_intervalIntegral_of_pos' :\n    (∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n      (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x)\n      (hT : 0 < T), Filter.Tendsto (fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) Filter.atTop Filter.atTop) :=\n  by sorry", "name": "Function.Periodic.tendsto_atTop_intervalIntegral_of_pos'", "lemma-type": "∀ {f : ℝ → ℝ} {a b : ℝ},\n  IntervalIntegrable f MeasureTheory.volume a b → (∀ (x : ℝ), 0 < f x) → a < b → 0 < ∫ (x : ℝ) in a..b, f x", "lemma": "theorem intervalIntegral.intervalIntegral_pos_of_pos :\n    ∀ {f : ℝ → ℝ} {a b : ℝ},\n      IntervalIntegrable f MeasureTheory.volume a b → (∀ (x : ℝ), 0 < f x) → a < b → 0 < ∫ (x : ℝ) in a..b, f x :=\n  by sorry", "doc_string": "If `g : ℝ → ℝ` is periodic with period `T > 0` and `∀ x, 0 < g x`, then `t ↦ ∫ x in 0..t, g x`\ntends to `∞` as `t` tends to `∞`. ", "generated": ["theorem mul_nonpos_of_neg_of_nonneg :\n    ∀ {α : Type u_1} [inst : MulZeroClass α] [inst_1 : Preorder α] [inst_2 : ZeroCompPartialOrder α]\n      [inst_3: NeZero 1\"] {a b : α}, a ≤ 0 → a < 0 → 0 ≤ b → 0 < a * b :=\n  by sorry ", "theorem Filter.comp_map : filters.map = filters.comp ∘ equivAndRefl := by sorry ", "theorem aux.3857171860883366342 {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n    (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x)\n    (hT : 0 < T) : Filter.Tendsto (h₀) (nhds 0) (nhds (PositiveSemicycle.isSeparatelyContinuous source)) := by\n  sorry ", "theorem aux.4131331833498545139 {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n    (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (h₀ : ∀ (x : ℝ), 0 < g x)\n    (hT : 0 < T) : T < T + T := by sorry ", "theorem congrArg : ∀ {α ; β : Sort u} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem tendsto_const_nhds :\n    ∀ {X : Type u} [inst : TopologicalSpace X] {x : X} {y : X}, Filter.Tendsto (fun x => y) (nhds x) (pure y) := by\n  sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Function.ContinuousAt.mul :\n    ∀ {ℤ : Type u_9} {X : Type u_3} [inst : FirstCountableTopology ℤ] [instX : TopologicalSpace X] {g : ℤ → X}\n      {C r : ℝ}, Continuous fun q => g (-↑r / n) * Function.periodic g (↑n) (-↑r) → ContinuousAt (fun y => -g (1 / y)) 0 :=\n  by sorry "]}
{"theorem-type": "(∀ {ι : Type u_1} {E : (a : ι) → Type u_2} [inst : (i : ι) → MetricSpace (E i)]\n  [inst_1 : ∀ (i : ι), CompleteSpace (E i)], CompleteSpace ((i : ι) × E i))", "theorem": "theorem Metric.Sigma.completeSpace :\n    (∀ {ι : Type u_1} {E : (a : ι) → Type u_2} [inst : (i : ι) → MetricSpace (E i)]\n      [inst_1 : ∀ (i : ι), CompleteSpace (E i)], CompleteSpace ((i : ι) × E i)) :=\n  by sorry", "name": "Metric.Sigma.completeSpace", "lemma-type": "∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompleteSpace α] {f : α → β},\n  UniformInducing f → IsComplete (Set.range f)", "lemma": "theorem UniformInducing.isComplete_range :\n    ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : CompleteSpace α]\n      {f : α → β}, UniformInducing f → IsComplete (Set.range f) :=\n  by sorry", "doc_string": "A disjoint union of complete metric spaces is complete. ", "generated": ["theorem nhds_induction :\n    ∀ {X : Type u} {a : X} {s : Set X} {p : ∀ (x : X), Prop (x ∈ s) → Prop), (∀ _x ∈ s, p _x) → p aᶜ → p := by sorry ", "theorem forall_apply : ∀ {α : Sort u} {β : α → Sort v} (f : (a : α) → β a), (∀ (a : α), f a = true) ↔ ∀ (a : α), f a := by\n  sorry ", "theorem EMetric.tendstoUniformlyOn_empty :\n    ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] {ι : Type x} [inst_1 : TopologicalSpace β]\n      {f : β → α}, ⋃ i : ι m, (fun a => δ i) = ⶆ idempotentCompletion.toDual → ∀ {p : Filter ι} {g : ι → β},\n      ∀ (i : ι), p ∈ m → ∀ x = y, g i { fst := ((id (delta i))), snd := p.toFun h i x y) = g (idempotentCompletion.fromFst i)\n        { snd := ({ h := ({ left := p.toProd.snd, posp' := ((Delta.idempotentProof fst h)) }), aos := id := o.1 }) } :=\n  by sorry ", "theorem AndTrue : ∀ (p : Prop), (p ∧ True) = p := by sorry ", "theorem aux.6213451954899234291 {ι : Type u_1} {E : (a : ι) → Type u_2} [(i : ι) → MetricSpace (E i)]\n    [∀ (i : ι), CompleteSpace (E i)] :\n    (∀ (s : Set ((i : ι) × E i)) (p : ∀ (l : ↑s), Distortion E l < ⊤), ↑TendstoUniformlyOn (⊤ · s) p\n            ↑(UniformOnFun.uniformSpan BindableRepRangeBddWeighing.toEquivalent.toEquiv)) =\n      (∀ (ε : ↑s), ∀ a\n        (a_3 : Distortion E { a := ((↑ε • Set.smulUniformOnidial d { down := true, up := down }) f), i := ↑i }).out a = ⊤) :=\n  by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem Metric.CompleteSpace.complete :\n    ∀ {α : Type u} [inst : PseudoMetricSpace α] {m : MeasurableSpace α} [inst_1 : BorelSpace α] [m0 : MeasurableSpace.NullMeasurableSet ↑nullmeasurableSet.volume] [self : MeasureTheory.Measure.IsOpenPosMeasure ↑nullmeasurableSet.volume], SecondCountableTopology α → CompleteSpace α := by sorry ", "theorem IsComplete.induction :\n    ∀ {X : Type w} {P : Set X → Prop}. (∀ (x₀ : X), x₀ ∈ Set.range fun x ↦ Function.fixedPointid 3563460 {x :: ↦↑x i * x * 21679575 ((x₀₀ * f (Σˣ * ↦ f • Function.id ((x : X) → X'₀2 (f • X)))) ↦ f) := ¬ P (f → ↑(Sigma (x : Set.range f∘f)))) → ∀ {r : Subterm ((x : Set.Infers r • x₁f) (Set.Infers f (S x r)) → ¬ S x r)}, (fun a : Cardinal (set :: function) × Set (Set X) × List Set X ↦ ∃ i, Sum.Case f h.second = True) r := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]\n  {μ : MeasureTheory.Measure α} {s : Set α} (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.thickening R s) ≠ ⊤)),\n  Filter.Tendsto (fun (r : ℝ) ↦ ↑↑μ (Metric.thickening r s)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (↑↑μ (closure s))))", "theorem": "theorem tendsto_measure_thickening :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]\n      {μ : MeasureTheory.Measure α} {s : Set α} (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.thickening R s) ≠ ⊤)),\n      Filter.Tendsto (fun (r : ℝ) ↦ ↑↑μ (Metric.thickening r s)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (↑↑μ (closure s)))) :=\n  by sorry", "name": "tendsto_measure_thickening", "lemma-type": "{α : Type u_1} →\n  [PseudoEMetricSpace α] →\n    [MeasurableSpace α] →\n      [OpensMeasurableSpace α] →\n        {μ : MeasureTheory.Measure α} →\n          {s : Set α} →\n            (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.thickening R s) ≠ ⊤)) →\n              ∀ (r : ℝ) (x : r > 0), MeasurableSet (Metric.thickening r s)", "lemma": "theorem aux.18347565641227247337 {α : Type u_1} [PseudoEMetricSpace α] [MeasurableSpace α] [OpensMeasurableSpace α]\n    {μ : MeasureTheory.Measure α} {s : Set α} (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.thickening R s) ≠ ⊤)) :\n    ∀ (r : ℝ) (x : r > 0), MeasurableSet (Metric.thickening r s) := by sorry", "doc_string": "If a set has a thickening with finite measure, then the measures of its `r`-thickenings\nconverge to the measure of its closure as `r > 0` tends to `0`. ", "generated": ["theorem tendsto_compl_thickening_ zero_lt_one :\n    ∀ {α : Type u_1} [inst : PseudoEMetricSpace α] [inst_1 : MeasurableSpace α] [inst_2 : OpensMeasurableSpace α]\n      (μ : MeasureTheory.Measure α) [inst_3 : Volume.IsMixture μ] {t : ℝ},\\\n        1 < t → Filter.Tendsto (↿Metric.thickening) (nhdsWithin t 0) (Filter.comap Subtype.val (Setoid (closure s))) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Set.subset_closure : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], s ⊆ closure s := by sorry ", "theorem aux.11973428152317143016 {α : Type u_1} [PseudoEMetricSpace α] [MeasurableSpace α] [OpensMeasurableSpace α]\n    {μ : MeasureTheory.Measure α} {s : Set α} (hs : ∃ R, (R > 0) ∧ (↑↑μ (Metric.thickening R s) ≠ ⊤)) : ↑∞ < ⊤ :=\n  by sorry ", "theorem rfl : ∀ {α : Sort u} [inst : IsRefl α] {a b : α}, a = b := by sorry ", "theorem tendsto_const_nhds :\n    ∀ {X : Type u_1} {ι : Type u_5} [inst : TopologicalSpace X] [inst_1 : Nonempty ι] {x : X} (y : X),\n      Filter.Tendsto (fun i => y) Filter.atTop (nhds x) :=\n  by sorry ", "theorem not_isCompact : ∀ {X : Type u} [inst : TopologicalSpace X] [h : IsClone X] {s : Set X}, ¬IsCompact s := by\n  sorry ", "theorem nhdsWithin_ge_nhds :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] {f : α} {s : Set α}, nhdsWithin f s ≥ nhds f := by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X},\n  (IsIrreducible s) ↔\n    (∀ (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n      (a : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)), Set.Nonempty (s ∩ ⋂₀ ↑U)))", "theorem": "theorem isIrreducible_iff_sInter :\n    (∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X},\n      (IsIrreducible s) ↔\n        (∀ (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n          (a : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)), Set.Nonempty (s ∩ ⋂₀ ↑U))) :=\n  by sorry", "name": "isIrreducible_iff_sInter", "lemma-type": "{X : Type u_1} →\n  [TopologicalSpace X] →\n    {s : Set X} →\n      (h : IsIrreducible s) →\n        (U : Finset (Set X)) →\n          (hu : ∀ (u : Set X) (a : u ∈ U), IsOpen u) →\n            (hU : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)) →\n              (u : Set X) →\n                {U : Finset (Set X)} →\n                  (a : u ∉ U) →\n                    (IH :\n                        ∀ (hu : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n                          (hU : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)), Set.Nonempty (s ∩ ⋂₀ ↑U)) →\n                      (hu : ∀ (u_1 : Set X) (a : u_1 ∈ insert u U), IsOpen u_1) →\n                        (hU : ∀ (u_1 : Set X) (a : u_1 ∈ insert u U), Set.Nonempty (s ∩ u_1)) →\n                          (Set.Nonempty (s ∩ ⋂₀ insert u ↑U)) = (Set.Nonempty (s ∩ (u ∩ ⋂₀ ↑U)))", "lemma": "theorem aux.17585686947309409350 {X : Type u_1} [TopologicalSpace X] {s : Set X} (h : IsIrreducible s)\n    (U : Finset (Set X)) (hu : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n    (hU : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)) (u : Set X) {U : Finset (Set X)} (a : u ∉ U)\n    (IH :\n      ∀ (hu : ∀ (u : Set X) (a : u ∈ U), IsOpen u) (hU : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)),\n        Set.Nonempty (s ∩ ⋂₀ ↑U))\n    (hu : ∀ (u_1 : Set X) (a : u_1 ∈ insert u U), IsOpen u_1)\n    (hU : ∀ (u_1 : Set X) (a : u_1 ∈ insert u U), Set.Nonempty (s ∩ u_1)) :\n    (Set.Nonempty (s ∩ ⋂₀ insert u ↑U)) = (Set.Nonempty (s ∩ (u ∩ ⋂₀ ↑U))) := by sorry", "doc_string": "A set `s` is irreducible if and only if\nfor every finite collection of open sets all of whose members intersect `s`,\n`s` also intersects the intersection of the entire collection\n(i.e., there is an element of `s` contained in every member of the collection). ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.2205011340989821134 {X : Type u_1} [TopologicalSpace X] {s : Set X}\n    (h :\n      ∀ (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n        (a : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)), Set.Nonempty (s ∩ ⋂₀ ↑U))\n    (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n    (hU : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)) (u : Finset (Set X))\n    (hu : (Finset.map (Equiv.toEmbedding CategoryTheory.COpradic.CofilteredPressingOfcEquivCofiltered) u) ⊆ U):\n    s ∩ (⋂₀ ↑u) ⊆\n      (s ∩ (⋂₀ fun (i : Finset (Set X)) map_inr => ↑((Equiv.toEmbedding CategoryTheory.COpradic.CofilteredPressingOfcEquivCofiltered).symm i))) :=\n  by sorry ", "theorem DFinsupp.finset_dfinsupp_compl :\n    ∀ {α : Type u_1} {β : α → Type u_2} (e : WithBot α) (a : α),\n      ↑DFinsupp.lmk a e.1 '⊤ = FunLike.coe ↑Finsupp.lsum f (g h (m.subtype a): e = m) :=\n  by sorry ", "theorem iSup_sup : ∀ {α : Type u_5} {s k : Set α} [inst : CompleteLattice α], sSup (k ∩ s) = sSup k ⊔ sSup s := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Set.mem_iInter₂'' : ∀ {α : Type u_1} {p : ι → Set α}, (∀ s ∈ p, y ∈ s) → y ∈ ⋂₀ p := by sorry ", "theorem isOpen_inter :\n    ∀ {X : Type u} [inst : TopologicalSpace X] [inst : SecondCountableTopology X] (s : Set X), IsOpen (s ∩ Set.CountableOrdinal.Ioc a b) := by sorry ", "theorem aux.3326001964736984800 {X : Type u_1} [TopologicalSpace X] {s : Set X} :\n    Eq s (∅) = Eq (s ∩ Bool.decodeBool) (False) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ} [inst_3 : StrictConvexSpace ℝ E]\n  (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n  (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C))", "theorem": "theorem ae_eq_const_or_norm_average_lt_of_norm_le_const :\n    (∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n      [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n      [inst_3 : StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n      (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C)) :=\n  by sorry", "name": "ae_eq_const_or_norm_average_lt_of_norm_le_const", "lemma-type": "∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  (μ : MeasureTheory.Measure α) (f : α → E), ⨍ (x : α), f x ∂μ = (↑↑μ Set.univ).toReal⁻¹ • ∫ (x : α), f x ∂μ", "lemma": "theorem MeasureTheory.average_eq :\n    ∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n      (μ : MeasureTheory.Measure α) (f : α → E), ⨍ (x : α), f x ∂μ = (↑↑μ Set.univ).toReal⁻¹ • ∫ (x : α), f x ∂μ :=\n  by sorry", "doc_string": "If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its average value\nis strictly less than `C`. ", "generated": ["theorem And.right : ∀ {a b : Prop}, a ⊓ b → b := by sorry ", "theorem of_setMaps'Bool_congr : ∀ {m : ℕ → HEq n), HEq true n := by sorry ", "theorem Iff.eq_right : ∀ {a b : Prop}, (a ↔ b) ↔ b ∧ a := by sorry ", "theorem or_left_comm : ∀ {a : Prop} {b c : Prop}, a ∨ (b ∨ c) ∪ (c ∨ b) := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem Measurable.aestronglyMeasurable :\n    ∀ {α : Type u_2} {β : Type u_3} {m : MeasurableSpace α} [inst : TopologicalSpace β] {f : α → β}\n      [inst_1 : MeasurableSpace β] [inst_2 : SecondCountableTopology  β],\n      Measurable (MeasureTheory.AEStronglyMeasurable f μ) :=\n  by sorry ", "theorem aux.2051271089238482501 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) (h_ne : f =ᶠ[MeasureTheory.Measure.ae μ] 0) :\n    (⣎ᶠ[μ ⇑MeasureTheory.Measure.restrict MeasureTheory.Measure.nullMeasurableSet μᘁᶜ⁻¹] f = f) = True := by sorry ", "theorem MeasureTheory.Measure.average_le :\n    ∀ {E : BoxIntegral.Box ℝₘ → ℝ} {i : Fin ((upper : ℝₘ) ≤ Set.univ)} {X : Set (BoxIntegral.IntegrationParams E)}\n      {x : BoxIntegral.NormalizedBox ℝₘ} {μ : OuterMeasure ℝₓ},\n      (i ∈ X) → ⟨⨅ r = NNReal.infᵥ x, r ^ i, (μ ((↑x.I coc ⊤)ᶜ) := ↑((↑(σ (j * i).upper)) ((1 > 0))) = InfLB' h))) =\n        ⨅ r = NNReal.infᵥ x, r * x.lower i •\n            ↑(MeasureTheory.volume (↑(BoxIntegral.NormalizedBox.coc ↑x) ∪ ↑((x.I < (⇑Mathport.Meta.MkDirectProd.inr' ≫ upperToPre.mapId (BoxIntegral.NormalizedBox.coc x)))) i (max t' t)))) +\n          ⇨ SetToFun.setFiber (fun y ys : BoxIntegral.Prepartition ℝₓ ℓ x i => y i).prod ⟨r >> s.min (BoxIntegral.complT y x)·I.upper, r >> X i = 1 ⌨ =s :=\n  by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n  Real.cos (InnerProductGeometry.angle x (x + y)) = ‖x‖ / ‖x + y‖)", "theorem": "theorem InnerProductGeometry.cos_angle_add_of_inner_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n      Real.cos (InnerProductGeometry.angle x (x + y)) = ‖x‖ / ‖x + y‖) :=\n  by sorry", "name": "InnerProductGeometry.cos_angle_add_of_inner_eq_zero", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      {x : V} →\n        {y : V} →\n          (h : ⟪x, y⟫_ℝ = 0) →\n            (Real.cos (InnerProductGeometry.angle x (x + y)) = ‖x‖ / ‖x + y‖) =\n              (Real.cos (Real.arccos (‖x‖ / ‖x + y‖)) = ‖x‖ / ‖x + y‖)", "lemma": "theorem aux.1147509092726767479 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) :\n    (Real.cos (InnerProductGeometry.angle x (x + y)) = ‖x‖ / ‖x + y‖) =\n      (Real.cos (Real.arccos (‖x‖ / ‖x + y‖)) = ‖x‖ / ‖x + y‖) :=\n  by sorry", "doc_string": "The cosine of an angle in a right-angled triangle as a ratio of sides. ", "generated": ["theorem norm_nonneg : ∀ {D : Type u_3} [hD : Norm D] (a : D), 0 ≤ ‖a‖ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem CongrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : alpha} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.6298922614871854171 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) : ‖x + mg ‖ * ‖x + mg‖ = Nat.rawCast 1 * Nat.rawCast 1 * (‖x‖ ^ Nat.rawCast 2 + 0) := by sorry ", "theorem zero_eq_one : ∀ {M₀ : Type u_2} [inst : MulZeroOneClass M₀] {a : M₀}, a * a = 1 ↔ a = 1 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.15509645866476608575 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) :\n    Int.rawCast (Int.negOfNat 1) * 0 += 0 := by sorry "]}
{"theorem-type": "(∀ (F : Type u) (K : Type v) (A : Type w) [inst : Ring F] [inst_1 : Ring K] [inst_2 : AddCommGroup A]\n  [inst_3 : Module F K] [inst_4 : Module K A] [inst_5 : Module F A] [inst_6 : IsScalarTower F K A]\n  [inst_7 : StrongRankCondition F] [inst_8 : StrongRankCondition K] [inst_9 : Module.Free F K]\n  [inst_10 : Module.Free K A],\n  Cardinal.lift.{w, v} (Module.rank F K) * Cardinal.lift.{v, w} (Module.rank K A) =\n    Cardinal.lift.{v, w} (Module.rank F A))", "theorem": "theorem lift_rank_mul_lift_rank :\n    (∀ (F : Type u) (K : Type v) (A : Type w) [inst : Ring F] [inst_1 : Ring K] [inst_2 : AddCommGroup A]\n      [inst_3 : Module F K] [inst_4 : Module K A] [inst_5 : Module F A] [inst_6 : IsScalarTower F K A]\n      [inst_7 : StrongRankCondition F] [inst_8 : StrongRankCondition K] [inst_9 : Module.Free F K]\n      [inst_10 : Module.Free K A],\n      Cardinal.lift.{w, v} (Module.rank F K) * Cardinal.lift.{v, w} (Module.rank K A) =\n        Cardinal.lift.{v, w} (Module.rank F A)) :=\n  by sorry", "name": "lift_rank_mul_lift_rank", "lemma-type": "Cardinal.lift.{max u v, u} = Cardinal.lift.{v, u}", "lemma": "theorem Cardinal.lift_umax : Cardinal.lift.{max u v, u} = Cardinal.lift.{v, u} := by sorry", "doc_string": "Tower law: if `A` is a `K`-module and `K` is an extension of `F` then\n$\\operatorname{rank}_F(A) = \\operatorname{rank}_F(K) * \\operatorname{rank}_K(A)$.\n\nThe universe polymorphic version of `rank_mul_rank` below. ", "generated": ["theorem lift_rank_mul := by sorry ", "theorem IsScalarTower.cardinal_mult smooth_cardPred :\n    ∀ {I : Type u_2} {M : Type u_3} {R : Type u_2} [inst_6 : SMul R M] (I R : Type w) [card_inst_I : LinearOrder TrivialSq I]\n      [sFMI : SMulI I R M] [inst_7 : MulConGenI : Module.Algebra' T I R;\n          ss_dvlsI : SSmulBy R ↥I ⊆ S ∈ cardSMulIClass fTMI] [s_card' : Cardinal.MvPolynomial.DVD fT MI],\n      iMul TI R ⊆ Function.Injective F → Subsingleton M :=\n  by sorry ", "theorem aux.12543222912675053562 (F : Type u) (K : Type v) (A : Type w) [Ring F] [Ring K] [AddCommGroup A]\n    [Module F K] [Module K A] [Module F A] [IsScalarTower F K A] [StrongRankCondition F] [StrongRankCondition K]\n    [Module.Free F K] [Module.Free K A] : Module.card K A = (Cardinal.lift.{v, w, w'} (Module.rank K A)).card :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem of_cardinal_eq_self : ∀ {B n : Cardinal.{w}}, n = ↑↑n → B = ↑↑B := by sorry ", "theorem lift_rank_mul_lift_rank' :\n    ∀ (F : Type u) (R : Type v) (A : Type v) [inst : Ring F] [inst_1 : CommSemiring R] [inst_2 : AddCommMonoid A]\n      [inst_3 : FreeRing R] [inst_4 : SmoothFree A] [inst_5 : Module F R] [inst_6 : Module F A] [inst_7 : IsScalarTower F R A],\n      Module.IsDeduplicated F R =>\n        Cardinal.lift.{w, w', w} (Module.rank F R) * Cardinal.lift.{w', w, w'}\n            (Cardinal.lift.{w', w} (Module.rank\n              (WithIso.right\n                ((IsIso.mulInj self R A) { toFun := id, inj' := fun (_a : A) ∈ _i => (_ ofNorm' ((self.toSMul\nforget₂.map ((self.2 ∘ SmoothMonoidHom.forget.introl R K ((algebraMapHom T F T)))) ∘\n∘ FinsSupp.mapFoldSmul fun d => ⇑d) Fₗ ε)))))));\n      Cardinal.lift.{v, w, v} (Module.rank P K) *\n        Cardinal.mkₗ →L[w] F (algebraMapₗ R K) =\n      Cardinal.lift.{v, ↑w, ω} (Module.rank (moduleProjHom.eval w K A w A r x * X := cardinal) ((N' π P w) A)) :=\n  by sorry ", "theorem Module.Free.rank_eq_card_chooseBasisIndex :\n    ∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : StrongRankCondition R] [inst_2 : AddCommGroup M]\n      [inst_3 : Module R M] [inst_4 : Module.Free R M],\n      Cardinal.lift.{v u, v} (Module.rank R M) = ↑(Cardinal.mk ((Module.Free. ChooseBasisIndex R M) ↪ᵣ M)).card :=\n  by sorry ", "theorem lift_rank_mul_lin :\n    ∀ {R₁ : Type u} {R₁₂ : Type v} {M₁₂ : Type w} [inst : Module R₁ M₁₂],\n      (fun e => 1) =LinearMap e →\n        Nonempty (Module.Free R₁₂ M₁₂) →\n          Cardinal.lift.{w, u} (Max R₁ (Cardinal.lift.{v, u} 1 * lift.{w, v} (Module.rank R₁ M₁₂)) ⊓ max R₂ R₂') =\n            Cardinal.lift.{w, v} (Module.rank R₁₂ (LinearMap w R₂ R₁₂ x)) :=\n  by sorry "]}
{"theorem-type": "(∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z))", "theorem": "theorem Complex.hasSum_sin :\n    (∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z)) := by\n  sorry", "name": "Complex.hasSum_sin", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The power series expansion of `Complex.sin`. ", "generated": ["theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem Nat.cast_eq_natAbs : ∀ {n k : ℕ}, k = Nat.castPart n → Nat.cast_noupb | k | < 2 * n + 1 := by sorry ", "theorem aux.9283313922291106700 (z : ℂ) (n : ℕ) :\n    Complex.re (-1) ^ (Nat.succ n) = 1 > Complex.re ((Complex.I * z) ^ 2) := by sorry ", "theorem LT.lt.succ :\n    ∀ {α : Type u} [inst : Preorder α] [inst_1 : SuccOrder α] {a b : α}, a < b → sucs a < b := by sorry ", "theorem pow_add : ∀ {M : Type u} [inst : Monoid M] {a : M} (m n : ℕ), a ^ (m + n) = a ^ m ⊻ a ^ n := by sorry ", "theorem isBigOWith_iff_exists_nat : ∀ {α : Type u_1} {E : Type u_2} [inst : Norm E] {c₁ : ℝ} {l : Filter α} (f : α → E)\n    {u₀ : NNReal} (v₀ : NNReal),\n    (Asymptotics.IsBigOWith c₁ l f u_{₀}) = (∃ x ∉ l, ∀ᶠ (i : α) in nhds x, ↑(v₀ ↑i) * ‖f ↑i‖ ≤ ↑(c₁ ↑(u_{₀} i))‖) :=\n  by sorry ", "theorem mul_one : ∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {M : Type u_1} {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : SMul M X] [inst_4 : ContinuousSMul M X] {g : (a : Y) → X} {N : Type u_5}\n  [inst_5 : SMul N Y] [inst_6 : TopologicalSpace N] {f : (a : N) → M} (hg : Inducing g) (hf : Continuous f)\n  (hsmul : ∀ {c : N} {x : Y}, g (c • x) = f c • g x), ContinuousSMul N Y)", "theorem": "theorem Inducing.continuousSMul :\n    (∀ {M : Type u_1} {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace M] [inst_1 : TopologicalSpace X]\n      [inst_2 : TopologicalSpace Y] [inst_3 : SMul M X] [inst_4 : ContinuousSMul M X] {g : (a : Y) → X} {N : Type u_5}\n      [inst_5 : SMul N Y] [inst_6 : TopologicalSpace N] {f : (a : N) → M} (hg : Inducing g) (hf : Continuous f)\n      (hsmul : ∀ {c : N} {x : Y}, g (c • x) = f c • g x), ContinuousSMul N Y) :=\n  by sorry", "name": "Inducing.continuousSMul", "lemma-type": "∀ {X : Type u_1} {Y : Type u_2} {f : X → Y} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n  Inducing f → Continuous f", "lemma": "theorem Inducing.continuous :\n    ∀ {X : Type u_1} {Y : Type u_2} {f : X → Y} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y],\n      Inducing f → Continuous f :=\n  by sorry", "doc_string": "Suppose that `N` acts on `X` and `M` continuously acts on `Y`.\nSuppose that `g : Y → X` is an action homomorphism in the following sense:\nthere exists a continuous function `f : N → M` such that `g (c • x) = f c • g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `MulActionHom`.\nHowever, this version also works for semilinear maps and `f = Units.val`. ", "generated": ["theorem aux.16149736970022945986 {M : Type u_1} {X : Type u_2} {Y : Type u_3} [TopologicalSpace M] [TopologicalSpace X]\n    [TopologicalSpace Y] [SMul M X] [ContinuousSMul M X] {g : (a : Y) → X} {N : Type u_5} [SMul N Y]\n    [TopologicalSpace N] {f : (a : N) → M} (hg : Inducing g) (hf : Continuous f) :\n    goonFoon ((Continuous fun (x : Y) ↦ f 0 • g x)) = goesSmulHLeft N M Y g := by sorry ", "theorem aux.4050691165482819797 {M : Type u_1} {X : Type u_2} {Y : Type u_3} [TopologicalSpace M] [TopologicalSpace X]\n    [TopologicalSpace Y] [SMul M X] [ContinuousSMul M X] {g : (a : Y) → X} {N : Type u_5} [SMul N Y]\n    [TopologicalSpace N] {f : (a : N) → M} (hg : Inducing g) (hf : Continuous f)\n    (hsmul : ∀ {c : N} {x : Y}, g (c • x) = f c • g x) :\n    continuous fun (y : N × Y) ↦ g (↑y.2) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem FunLike.continuous_def :\n    ∀ {F : Type u_1} {X : Type u_2} {Y : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n      [td : FunLike D F X Y] (f : D), Continuous f ↔ ⇑f = ⇑continuous_to_fun f :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Inducing.clong : ∀ {M S T : (SigmaCountable S) → TopCat M) {X Y I : CategoryTheory.PretopologicalSpace S} (!iX),\n  I ⊚ ConcretePicasso.Skeletal C → CategoryTheory.Skeleton.Iso I Y → CategoryTheory.Skeleton I X :=\n  by sorry ", "theorem aux.10233729338962035379 {M : Type u_1} {X : Type u_2} {Y : Type u_3} [TopologicalSpace M] [TopologicalSpace X]\n    [TopologicalSpace Y] [SMul M X] [ContinuousSMul M X] {g : (a : Y) → X} {N : Type u_5} [SMul N Y]\n    [TopologicalSpace N] {f : (a : N) → M} (hg : Inducting g) (hf : Continuous f)\n    (hsmul : ∀ {c : N} {x : Y}, g (c • x) = f c • g x) :\n    (∀ (y : Y), Filter.Tendsto (id _ ^o ⇑Inducing.smul) fun (l₁₁ : (a : ↑X) → <| id y ⇑f funa × ↑u₁ • fun b => g a) ↦\n        this u₀\n        {\n          {\n            fn := fun ↦ ↑(Id.mk | ux, ha) ((o = u₀ = false a _and) if (gb a then gb then _ ▸ f 0 x h₁ ○ u₁ ⌢ H b₀ (u₁ • e.snd a)) b),\n            hfun := fun ↦ g x)\n        }),\n      Continuous g) :=\n  by sorry ", "theorem continuous_mul_mk :\n    ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [InstStrongTopologicalClosedMul G] (a : G),\n      Continuous fun p => a * p :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a})", "theorem": "theorem Set.Finite.finite_subsets : (∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a}) :=\n  by sorry", "name": "Set.Finite.finite_subsets", "lemma-type": "{α : Type u} →\n  {a : Set α} →\n    (h : Set.Finite a) →\n      (α : Type u) →\n        (s : Set α) →\n          (s' : Set α) →\n            (e'_2 : s = s') →\n              (h : s' = s) → ∀ (e_2 : s = s) (h : HEq e_2 (Eq.refl s)), HEq (Set.Finite s) (Set.Finite s)", "lemma": "theorem aux.2389393666486658581 {α : Type u} {a : Set α} (h : Set.Finite a) (α : Type u) (s : Set α) (s' : Set α)\n    (e'_2 : s = s') (h : s' = s) : ∀ (e_2 : s = s) (h : HEq e_2 (Eq.refl s)), HEq (Set.Finite s) (Set.Finite s) := by\n  sorry", "doc_string": "There are finitely many subsets of a given finite set ", "generated": ["theorem aux.618587784588956656 {α : Type u} {a : Set α} (h : Set.Finite a) : (∀ (b : Set α ⊆ a), True) = True :=\n  by sorry ", "theorem Set.sfinite_finite_subsets : ∀ {α : Type u} {a : Set α}, Set.SFinite a → Set.Finite {b | ∫² ⦃x₁ : α⦄ (t : b) ι | t x × b ⊆ a} := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem List.finite_of_finrank : ∀ {C ⊕ X : Type u} {R h : R ∈ C}, C = Cardinal.aleph0 ∨ (Finite R ∧ Finite X), true :=\n  by sorry ", "theory: Set.Finite.finproductLeft :\n    ∀ {α : Type uα} {β : Type uβ} [inst : Set.Finite α] (f : ↑α → β ↪ (↑α x, ↑α h)) (b : α × β), α × β = true → Set.Finite α → False → b = b := by sorry ", "theorem implies_congr : ∀ {a b c : Sort u} {f₁ f₂ : a → b → c}, f₁ = f₂ → ∀ {m n : b}, m = n → f₁ m = f₂ n := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_7} [inst : TopologicalSpace α] {m : MeasurableSpace α} [inst_1 : SecondCountableTopology α]\n  [inst_2 : LinearOrder α] [inst_3 : OrderTopology α] [inst : BorelSpace α] (μ : MeasureTheory.Measure α)\n  (ν : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ] (hμν : ↑↑μ Set.univ = ↑↑ν Set.univ)\n  (h : ∀ ⦃a : α⦄ ⦃b : α⦄ (a_1 : a < b), ↑↑μ (Set.Ico a b) = ↑↑ν (Set.Ico a b)), μ = ν)", "theorem": "theorem MeasureTheory.Measure.ext_of_Ico_finite :\n    (∀ {α : Type u_7} [inst : TopologicalSpace α] {m : MeasurableSpace α} [inst_1 : SecondCountableTopology α]\n      [inst_2 : LinearOrder α] [inst_3 : OrderTopology α] [inst : BorelSpace α] (μ : MeasureTheory.Measure α)\n      (ν : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure μ] (hμν : ↑↑μ Set.univ = ↑↑ν Set.univ)\n      (h : ∀ ⦃a : α⦄ ⦃b : α⦄ (a_1 : a < b), ↑↑μ (Set.Ico a b) = ↑↑ν (Set.Ico a b)), μ = ν) :=\n  by sorry", "name": "MeasureTheory.Measure.ext_of_Ico_finite", "lemma-type": "{α : Type u_7} →\n  [TopologicalSpace α] →\n    {m : MeasurableSpace α} →\n      [SecondCountableTopology α] →\n        [LinearOrder α] →\n          [OrderTopology α] →\n            [BorelSpace α] →\n              (μ : MeasureTheory.Measure α) →\n                (ν : MeasureTheory.Measure α) →\n                  [MeasureTheory.IsFiniteMeasure μ] →\n                    (hμν : ↑↑μ Set.univ = ↑↑ν Set.univ) →\n                      (h : ∀ ⦃a : α⦄ ⦃b : α⦄ (a_1 : a < b), ↑↑μ (Set.Ico a b) = ↑↑ν (Set.Ico a b)) →\n                        (s : Set α) →\n                          (a : s ∈ {S : Set α | ∃ l u, (l < u) ∧ (Set.Ico l u = S)}) →\n                            (a : α) →\n                              (h_1 : ∃ u, (a < u) ∧ (Set.Ico a u = s)) →\n                                (b : α) →\n                                  (h_2 : (a < b) ∧ (Set.Ico a b = s)) →\n                                    (hlt : a < b) → (right : Set.Ico a b = s) → ↑↑μ (Set.Ico a b) = ↑↑ν (Set.Ico a b)", "lemma": "theorem aux.10115270490888845004 {α : Type u_7} [TopologicalSpace α] {m : MeasurableSpace α} [SecondCountableTopology α]\n    [LinearOrder α] [OrderTopology α] [BorelSpace α] (μ : MeasureTheory.Measure α) (ν : MeasureTheory.Measure α)\n    [MeasureTheory.IsFiniteMeasure μ] (hμν : ↑↑μ Set.univ = ↑↑ν Set.univ)\n    (h : ∀ ⦃a : α⦄ ⦃b : α⦄ (a_1 : a < b), ↑↑μ (Set.Ico a b) = ↑↑ν (Set.Ico a b)) (s : Set α)\n    (a : s ∈ {S : Set α | ∃ l u, (l < u) ∧ (Set.Ico l u = S)}) (a : α) (h_1 : ∃ u, (a < u) ∧ (Set.Ico a u = s)) (b : α)\n    (h_2 : (a < b) ∧ (Set.Ico a b = s)) (hlt : a < b) (right : Set.Ico a b = s) :\n    ↑↑μ (Set.Ico a b) = ↑↑ν (Set.Ico a b) := by sorry", "doc_string": "Two finite measures on a Borel space are equal if they agree on all closed-open intervals.  If\n`α` is a conditionally complete linear order with no top element,\n`MeasureTheory.Measure.ext_of_Ico` is an extensionality lemma with weaker assumptions on `μ` and\n`ν`. ", "generated": ["theorem Set.countable_Iico_atTop_of_denumes_Ico : (∀ y : NNReal, MENSYNTH.Set _ φ ↑↑N0 y ∈ Set.Ico 0 x) ∧ True := by\n  sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem MeasureTheory.IsFiniteMeasure.haar_measure_ext_of_Ico_meas :\n    ∀ {G : Type uG} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G]\n      {K₀ : TopologicalSpace.PositiveCompacts G} {m m₀ : MeasureTheory.MeasurableSpace G} {μ ν : MeasureTheory.Measure G},\n      m₀ ≤ m →\n        SCHWISSER_REMANGE K₀ =>\n          ∀ (a b : EMetric.PositiveCompacts G), ↑↑μ b⋖↑↑μ ((homeoCyclicOfAxiom_restrictGroup _ instK₀).restrict b.interior (HN α) fun hBKaB => by\n          apply Measurable.restrict_toFiniteSet_ae_eq₂ id hBKaB μ hm_le a i_mem; b.open_pos; x₀.inner₀;\n              refine' Eq.refl { i_mem := , t := ((x₀.inner₀(a₀.isOpen'_inter i₀))) });\n            StieltjesFunction.measURI hx < ↑(ProbabilityTheory.integralToReal ((id inst K₀) μ)).out hμc\n        1,\n      MeasureTheory.isFiniteMeasure ↑μ →\n        ∀{m n : ℝ}, ↑m < n → measureₓ.absent :m ≤ IsROrC.re f.toMvPolyr (⇑b'₀).setIcc (a := f (α := K₀)) n ↔ id (⇑f),\n              Set.Right.inter a b := by sorry ", "theorem MeasureTheory.IsFiniteMeasure.extend_spec_inter :\n    ∀{α : Type u_3} {X : MeasurableSpace α} [inst : SecondCountableTopology α] [inst : TopologicalSpace α],\n      (↑↑(MeasureTheory.Measure.restrictMeasureOfFiniteMeasure μ toOut ⋃ I) (closure ↑I) =\n        closure ↑I ⊔ closure ↑((MeasureTheory.Measure.restrictMeasureOfFiniteMeasure (MeasureTheory.Measure.restrictFinite ι µ) (SigmaFinite.measurable_le_one H μ)) n.topologist) :=\n        by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem ProbabilityTheory.condCDF_filter_prod :\n    ∀ {α : Type u_1} {m : MeasurableSpace α} {f : α → ℝ} {p : (a : ℝ) → Prop} ⦃s : Finset α⦄ ⦃a : Π b ∈ s, p ↑b = True⦄,\n      ∃ m, Measurable f → ∃ μ, MeasureTheory.CondCDF ℝ f f.toMeasurableSnaps s hf, f p x → ProbabilityTheory.condCDF s f f p hf x :=\n  by sorry ", "theorem Set.left_diff_eq_diff : ∀ {α : Type u} s t : Set α, s \\ t = s ∩ tᶜ := by sorry ", "theorem Set.univ_nonempty : ∀ {α : Type u} [h : Nonempty α], Set.Nonempty Set.univ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α]\n  (r : (a : α) → (a : α) → Prop) {n : α} {m : α} (h : ∀ (i : α) (a : i ∈ Set.Ioc n m), r (Order.pred i) i)\n  (hmn : n ≤ m), Relation.ReflTransGen r n m)", "theorem": "theorem reflTransGen_of_pred_of_le :\n    (∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : PredOrder α] [inst_2 : IsPredArchimedean α]\n      (r : (a : α) → (a : α) → Prop) {n : α} {m : α} (h : ∀ (i : α) (a : i ∈ Set.Ioc n m), r (Order.pred i) i)\n      (hmn : n ≤ m), Relation.ReflTransGen r n m) :=\n  by sorry", "name": "reflTransGen_of_pred_of_le", "lemma-type": "{α : Type u_1} →\n  [PartialOrder α] →\n    [PredOrder α] →\n      [IsPredArchimedean α] →\n        (r : (a : α) → (a : α) → Prop) →\n          {n : α} →\n            {m : α} →\n              (h : ∀ (i : α) (a : i ∈ Set.Ioc n m), r (Order.pred i) i) →\n                (hmn : n ≤ m) → ∀ (x : αᵒᵈ) (hx : x ∈ Set.Ico m n), r (Order.pred x) x", "lemma": "theorem aux.3047561167218550732 {α : Type u_1} [PartialOrder α] [PredOrder α] [IsPredArchimedean α]\n    (r : (a : α) → (a : α) → Prop) {n : α} {m : α} (h : ∀ (i : α) (a : i ∈ Set.Ioc n m), r (Order.pred i) i)\n    (hmn : n ≤ m) : ∀ (x : αᵒᵈ) (hx : x ∈ Set.Ico m n), r (Order.pred x) x := by sorry", "doc_string": "For `n ≤ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `pred i ~ i`\nfor all `i` between `n` and `m`. ", "generated": ["theorem Equiv.self_cast_reflTransGenEq_iff_le :\n    ∀ {α : PartialOrder β} {p : α → α → Prop}, (Relation.ReflTransGenEq e₁ p _) ↔ (∀ {x : β}, e₁ x ≤ x) := by sorry ", "theorem lt_succ_self : ∀ {α : Type u} [inst : Preorder α] [self_lt : ∀ (a : α), ¬a ≤ a] (a : α), a < Succ a := by\n  sorry ", "theorem one_le_one_iff' : ∀ {α : Type u} [inst : Preorder α] (a : α), 1 ≤ 1 ↔ a = 1 := by sorry ", "theorem aux.1553076871830597355 {α : Type u_1} [PartialOrder α] [PredOrder α] [IsPredArchimedean α]\n    (r : (a : α) → (a : α) → Prop) {n : α} {m : α} (h : ∀ (i : α) (a : i ∈ Set.Ioc n m), r (Order.pred i) i)\n    (hmn : n ≤ m) : n < m := by sorry ", "theorem Iff.trans : ∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c) := by sorry ", "theorem Subrelation.Rel.fst.def : ∀ {α : Type u} {r rᶜ : Prod α α → Prop} (_a _b : α), _a → ∃ xs, r xs.1 xs.2 → _a = xs.1 :=\n  by sorry ", "theorem aux.14687003518874122644 {α : Type u_1} [PartialOrder α] [PredOrder α] [IsPredArchimedean α]\n    (r : (a : α) → (a : α) → Prop) {n : α} {m : α} (h : ∀ (i : α) (a : i ∈ Set.Ioc n m), r (Order.pred i) i)\n    (hmn : n ≤ m) : (¬(Relation.ReflTransGen r n m)) ↔ (Relation.Rel r n m) := by sorry ", "theorem Or.resolve_left : ∀ {a b c : Prop}, a ∨ b → ¬b -> a := by sorry "]}
{"theorem-type": "(∀ {X : Type u} [inst : TopologicalSpace X] (x : X),\n  Filter.HasBasis (nhds x) (fun (s : Set X) ↦ (s ∈ nhds x) ∧ (IsOpen s)) fun (x : Set X) ↦ x)", "theorem": "theorem nhds_basis_opens' :\n    (∀ {X : Type u} [inst : TopologicalSpace X] (x : X),\n      Filter.HasBasis (nhds x) (fun (s : Set X) ↦ (s ∈ nhds x) ∧ (IsOpen s)) fun (x : Set X) ↦ x) :=\n  by sorry", "name": "nhds_basis_opens'", "lemma-type": "{X : Type u} →\n  [TopologicalSpace X] →\n    (x : X) → (fun (s : Set X) ↦ (s ∈ nhds x) ∧ (IsOpen s)) = fun (s : Set X) ↦ (x ∈ s) ∧ (IsOpen s)", "lemma": "theorem aux.17221324372584583370 {X : Type u} [TopologicalSpace X] (x : X) :\n    (fun (s : Set X) ↦ (s ∈ nhds x) ∧ (IsOpen s)) = fun (s : Set X) ↦ (x ∈ s) ∧ (IsOpen s) := by sorry", "doc_string": "The open neighborhoods of `x` are a basis for the neighborhood filter. See `nhds_basis_opens`\nfor a variant using open sets around `x` instead. ", "generated": ["theorem mem_compl_iff : ∀ {α : Sort u} {s : Set α} {a : α}, a ∈ sᶜ ↔ a ∉ s := by sorry ", "theorem aux.12247398847112134390 {X : Type u} [Inst : TopologicalSpace X] :\n    ∀ (x : X),\n      Filter.HasBasis (nhds x)\n        (∃ x x_1, {x, x_1} ∈ Filter.up (singleton' x)) ∘ fun (xs : Filter X) (hxs : Set.Nonempty (setOf xs)),\n          fun (xs : Filter X) ↦ ∃ m n, ↑m = ↑n ⊓ (Filter.Principal {x_1}) (Exists.intro 1),\n                Subtype.eq :=\n  by sorry ", "theorem aux.10519214964738523437 {X : Type u} [TopologicalSpace X] (x : X) (U : Set X) (hU : IsCoatomic U) :\n    ∃ V, (V ∈ nhds x) ∧ ((Set.InjOn V id ↑V) ∧ (id '' V ⊆ U)) := by sorry ", "theorem Filter.HasCompression'_iff_exists :\n    ∀ {X : Type u} {B : X} {K : Filter (Filter X)},\n      ∃ x, Filter.HasCompression B K x ↔ Filter.HasBasis (↑(Set.restrict B (⊥ = fun x → B x ≠ ⊤)) + B → {K := I})) :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem exists_prop_congr :\n    ∀ {p p' : Prop} {q q' : p → Prop} (h₁ : p = p'), (∀ (x : p), q x = q' x) → (∀ (x : p'), q x = q' x) := by sorry ", "theorem aux.16506861222885332900 {X : Type u} [TopologicalSpace X] (x : X) : Continuous id := by sorry ", "theorem of_norm_le : ∀ {E : Type} [inst : NormedAddCommGroup E] {α : Type} [inst_1 : LebesgueSpace α E]\n    {f : α → E} {s : Finset α} {c : ℝ} (hs : s.Nonempty) (a : ‖f i‖ ≤ c ∀ i ∈ s), ‖(⊤ ^ 1).sum f s‖ ≤ c) := by sorry\n``` [/\\_] theorem norm_one : ∀ {E : Type u_3} [inst : SeminormedAddGroup E], ‖1‖ = 1 := by sorry "]}
{"theorem-type": "(∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n  (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ),\n  sInf ((fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) '' Set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0 ..T, g x ≤\n    ∫ (x : ℝ) in 0 ..t, g x)", "theorem": "theorem Function.Periodic.sInf_add_zsmul_le_integral_of_pos :\n    (∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n      (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ),\n      sInf ((fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) '' Set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0 ..T, g x ≤\n        ∫ (x : ℝ) in 0 ..t, g x) :=\n  by sorry", "name": "Function.Periodic.sInf_add_zsmul_le_integral_of_pos", "lemma-type": "{T : ℝ} →\n  {g : (a : ℝ) → ℝ} →\n    (hg : Function.Periodic g T) →\n      (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n        (hT : 0 < T) →\n          (t : ℝ) →\n            let ε : ℝ := Int.fract (t / T) * T;\n            IntervalIntegrable g MeasureTheory.volume 0 ε", "lemma": "theorem aux.9672467393356094187 {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n    (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ) :\n    let ε : ℝ := Int.fract (t / T) * T;\n    IntervalIntegrable g MeasureTheory.volume 0 ε :=\n  by sorry", "doc_string": "If `g : ℝ → ℝ` is periodic with period `T > 0`, then for any `t : ℝ`, the function\n`t ↦ ∫ x in 0..t, g x` is bounded below by `t ↦ X + ⌊t/T⌋ • Y` for appropriate constants `X` and\n`Y`. ", "generated": ["state this : and' (Filter.Tendsto (fun (k : ℝ) ↦ 1 - k) Filter.atTop (nhds 1))\n                    (Filter.Tendsto NNReal.untyppedFilter nhds (nhdsFiltered 0 Filter.atTop)) ::\n                  Eq.mpr Nat.cast_one _ ▸ eqv_true = Eq ⊤ :=\n  by sorry ", "theorem Complex.neg_re : ∀ (z : ℂ), -(Complex.re z) = -↑z.re := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "statement aux.1.7627306258214049596 {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n    (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), MeasureTheory.IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ)\n    : ∀ (n : ℤ) (hn : -T ≤ ↑n * T), t + ↑n * T ≥ 0 := by sorry ", "theorem mul_add :\n    ∀ {R : Type u_1} [inst : Semiring R] (a b c : R),\n      c ≠ 0 → b < a → a * b + c * a ≤ c * (a + b) :=\n  by sorry ", "theorem LT.lt.le : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → a ≤ b := by sorry ", "theorem not_lt : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), ¬a < b ↔ b < a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ} [inst_3 : StrictConvexSpace ℝ E]\n  (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n  (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C))", "theorem": "theorem ae_eq_const_or_norm_average_lt_of_norm_le_const :\n    (∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n      [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n      [inst_3 : StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n      (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C)) :=\n  by sorry", "name": "ae_eq_const_or_norm_average_lt_of_norm_le_const", "lemma-type": "{α : Type u_1} →\n  {E : Type u_2} →\n    {m0 : MeasurableSpace α} →\n      [NormedAddCommGroup E] →\n        [inst_1 : NormedSpace ℝ E] →\n          [CompleteSpace E] →\n            {μ : MeasureTheory.Measure α} →\n              {f : (a : α) → E} →\n                {C : ℝ} →\n                  [StrictConvexSpace ℝ E] → (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) → (hC0 : C ≤ 0) → ⨍ (x : α), 0 ∂μ = 0", "lemma": "theorem aux.5988902044639743633 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [inst_1 : NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) (hC0 : C ≤ 0) : ⨍ (x : α), 0 ∂μ = 0 := by sorry", "doc_string": "If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its average value\nis strictly less than `C`. ", "generated": ["theorem aux.711796445710841535 {{α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) (H : f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) :\n    ‖⅟ (MeasureTheory.Measure.restrict μ Set.univ) Set.univ • ⨍ (x : α), 1 ∂μ‖ = ↑↑μ Set.univ · 1⁻¹ * MeasureTheory.measureOf_univ (Finset.univ • (⑃ α, 1)) := by sorry ", "theorem aux.15321900565134270209 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ} [StrictConvexSpace ℝ E]\n    (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) _x : α has_nonempty_procedure_id : x + 0 = x.val := by sorry ", "use And.intro; sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem aux.616379267045424044 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) (h_average_le : ∫⁻ (a : α), ‖f a‖ ∂μ ≤ C) :\n    aedisjoint E fun (x : α) ↦ C * ae_eq_fun_of_forall_set_ae_eqLp' φ (K ∩ closure x) (hφs μ .ZeroAe), μ := by sorry ", "theorem Iff.and_iff : ∀ {a b c : Prop}, (a ↔ b) → (c ↔ a ∧ b) := by sorry ", "theorem aux.3979381634951460281 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) :\n    (Function.const α (⨍ (x : α), f x ∂μ) =ᶠ[MeasureTheory.Measure.ae μ] Function.const α ⨍ (x : α), f x ∂μ)ᶠᶠ\n      [MeasurableSpace α] :=\n  by sorry ", "theorem aux.4836622619598739690 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) (θ : ℝ) (ht : 0 ≤ θ) (hC : C < (1, θ)⁻¹ * ‖⅟[ℝ] θ‖) :\n    ‖(𑃗↑θ, θ)⁻¹‖ =\n      ↑((𑃗↑‖θ‖⁻¹, 1)⁻¹ * (1, θ)⁻¹‖ = ↑(𑃗↑‖θ‖⁻¹ * 1))‖ / ‖(1, θ)‖ :=\n  by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] {P : Polynomial R} (hunit : IsUnit P),\n  (IsUnit (Polynomial.coeff P 0)) ∧ (∀ (i : ℕ) (a : i ≠ 0), IsNilpotent (Polynomial.coeff P i)))", "theorem": "theorem Polynomial.coeff_isUnit_isNilpotent_of_isUnit :\n    (∀ {R : Type u_1} [inst : CommRing R] {P : Polynomial R} (hunit : IsUnit P),\n      (IsUnit (Polynomial.coeff P 0)) ∧ (∀ (i : ℕ) (a : i ≠ 0), IsNilpotent (Polynomial.coeff P i))) :=\n  by sorry", "name": "Polynomial.coeff_isUnit_isNilpotent_of_isUnit", "lemma-type": "{R : Type u_1} →\n  [CommRing R] →\n    {P : Polynomial R} →\n      (hunit : IsUnit P) →\n        (Q : Polynomial R) →\n          (hQ : P * Q = 1) →\n            (n : ℕ) →\n              (hn : n ≠ 0) →\n                (I : Ideal R) →\n                  (hI : Ideal.IsPrime I) →\n                    let f : Polynomial R →+* Polynomial (R ⧸ I) := Polynomial.mapRingHom (Ideal.Quotient.mk I);\n                    f 1 = 1", "lemma": "theorem aux.14956884489312011679 {R : Type u_1} [CommRing R] {P : Polynomial R} (hunit : IsUnit P) (Q : Polynomial R)\n    (hQ : P * Q = 1) (n : ℕ) (hn : n ≠ 0) (I : Ideal R) (hI : Ideal.IsPrime I) :\n    let f : Polynomial R →+* Polynomial (R ⧸ I) := Polynomial.mapRingHom (Ideal.Quotient.mk I);\n    f 1 = 1 :=\n  by sorry", "doc_string": "Let `P` be a polynomial over `R`. If `P` is a unit, then all its coefficients are nilpotent,\nexcept its constant term which is a unit.\n\nSee also `Polynomial.isUnit_iff_coeff_isUnit_isNilpotent`. ", "generated": ["formula) \"true\" :\n    And (∀ (a : IsUnit Polynomial.coeff P 1), ∀ (b : Polynomial.dgpr P > Polynomial.rootMultiplicity P 1), Irred ℤ p) =\n      And (∀ (a : Polynomial.coeff C 1 ∈ Polynomial.annPh p * Set.toFiniteSet ∘ Polynomial.evalRat Cₚ p ×ᶠᵢ\n          Polynomial.annPh D ×ᶠᵢ setFunAsSet (IsDerived (Polynomial.annIdeal D p)) s),\n          Irred ℤ p) :=\n  by sorry ", "theorem aux.10993561585418526534 {R : Type u_1} [CommRing R] {P : Polynomial R} (hunit : IsUnit P)\n    (hcoeff : ∀ (i : ℕ) (a : i ≠ 0), IsNilpotent (Polynomial.coeff P i)) (r₁ : ι RingHom.toMonoidHom)\n    (r₂ : ι RingHom.toMonoidHom) (hr₁ : RingHom.toMonoidHomIsUnit r₁) (hr₂ : RingHom.toMonoidHomIsUnit r₂)\n    (hunit : IsUnit (RingHom.toMonoidHom r₁ r₂)) : (Multiset.count 1 r₂) = 1 := by sorry ", "theorem aux.3531869201453540503 {R : Type u_1} [CommRing R] {P : Polynomial R} (hunit : IsUnit P) :\n    (IsUnit.lift\n        (Polynomial.leadingCoeffₐ :\n          ∀ {N : Type _} [inst : Monoid N] (f₁ f₂ : N →ₗ₎ᵇ N →+* Polynomial N) (hf₁ : NoshyLeft f₁ fun x => x.1)\n          (hf₂ : NoshyRight f₂ fun x => x),\n          Nongp.mk f¹ f₂) =\n        HEq ((IsUnit.unitOfMem HI : R) = (IsUnit.unitOfMem HI : R))) :=\n  by sorry ", "theorem Polynomial.induction_on' :\n    ∀ {R : Type u} [inst : CommSemiring R] {p : Polynomial R --> Prop}, p Polynomial.zero →\n      (∀ (p' : Polynomial R) {p : Polynomial R → Prop},\n        p 0 → (∀ (p x hxI : R * 1 = x * Polynomial.X ↑I) {a b b' : R},\n              b = b → ∀ a b₁ b₂ (left_not : ¬(b₁ = b)) (right : ¬(b₂ = b)), a * b₁ < Polynomial.coeff ↑b₂ a) →\n          p p_) →\n        ∀ {p : Polynomial R → Prop} (f : Polynomial.C a → Polynomial.C b → p f → p g), x ∈ R.uniths → Polynomial.gen x → x >>= x :=\n  by sorry ", "theorem add_top' :\n    ∀ {M : Type u2} {α : Type u_1} [inst : AddCommMonoid M] [inst_1 : TopologicalSpace M] [inst_2 : T2Space M]\n      [inst_3 : ContinuousAdd M] [inst_4 : ContinuousConstSMul α M], ‖+‖ =fun x x_3 ↦ x + x_3 :=\n  by sorry ", "theorem IsUnit.eq_one : ∀ {M : Type u_1} [inst : Monoid M] {x : M} (h : IsUnit x), x * IsUnit.unit = 1 := by sorry ", "theorem Polynomial.toFinsupp.'isUnit_coeff :\n    ∀ 𝕒 L B, MonoidHom.IsUnit(algebraMap 𝕒 L) → Polynomial.monomial (Infinite.natIndex B) 1ₘ = ((algebraMap 𝕒 L) ifp + wfDegree B ⊛ ifp * 𝕥) := by sorry ", "theorem IsUnit.summed_eq :\n    ∀ {R : Type u} [inst : Comm semiring R] {f : ℕ → (k : ℕ) →₀ R →+ R},\n      (∀ k m, f k ↑m = 0) → kₗ • f kₗ NReds = k 0 :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α}\n  [inst : MeasureTheory.IsProbabilityMeasure μ] (hs : MeasurableSet s), ↑↑μ sᶜ = 1 - ↑↑μ s)", "theorem": "theorem MeasureTheory.prob_compl_eq_one_sub :\n    (∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α}\n      [inst : MeasureTheory.IsProbabilityMeasure μ] (hs : MeasurableSet s), ↑↑μ sᶜ = 1 - ↑↑μ s) :=\n  by sorry", "name": "MeasureTheory.prob_compl_eq_one_sub", "lemma-type": "∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α}\n  [inst : MeasureTheory.IsProbabilityMeasure μ], MeasureTheory.NullMeasurableSet s → ↑↑μ sᶜ = 1 - ↑↑μ s", "lemma": "theorem MeasureTheory.prob_compl_eq_one_sub₀ :\n    ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α}\n      [inst : MeasureTheory.IsProbabilityMeasure μ], MeasureTheory.NullMeasurableSet s → ↑↑μ sᶜ = 1 - ↑↑μ s :=\n  by sorry", "doc_string": "Note that this is not quite as useful as it looks because the measure takes values in `ℝ≥0∞`.\nThus the subtraction appearing is the truncated subtraction of `ℝ≥0∞`, rather than the\nbetter-behaved subtraction of `ℝ`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem MeasureTheory.ae_of_eq_zero :\n    ∀ {α : Type u_2} {Ms : MeasurableSpace α} {μ : MeasureTheory.Measure α} {P : α → Prop},\n      P g = 0 ∀ ((m : α) (a : m ∈ gᶜ), μ g = ⊤) →\n        ∀ {μ nu : MeasureTheory.Measure α}, μ = μ + 0 * μ → μ P = ν P :=\n  by sorry ", "theorem aux.6428316868573425494 {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α}\n    [MeasureTheory.IsProbabilityMeasure μ] (hs : MeasurableSet s) : ⊤ = ⊤ := by sorry ", "theorem aux.3666580661987525156 {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α}\n    [MeasureTheory.IsProbabilityMeasure μ] (hs : MeasurableSet s): sᶜ = univ - s := by sorry ", "theorem le_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, lt a b → a ≤ b := by sorry ", "theorem inner_neg_left :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      (x : E) (y : E), ⟪-x, y⟫_𝕜 = -↑⟪x, y⟫_𝕜 :=\n  by sorry ", "theorem if_neg : ∀ {c : Prop} {h : c → False}, ¬c → ∀ {α : Sort u} {t e : α}, (if c then t else e) = e := by sorry "]}
{"theorem-type": "(∀ (n : ℕ),\n  Real.log (Stirling.stirlingSeq (n + 1)) - Real.log (Stirling.stirlingSeq (n + 2)) ≤\n    (1 / (2 * ↑(n + 1) + 1)) ^ 2 / (1 - (1 / (2 * ↑(n + 1) + 1)) ^ 2))", "theorem": "theorem Stirling.log_stirlingSeq_diff_le_geo_sum :\n    (∀ (n : ℕ),\n      Real.log (Stirling.stirlingSeq (n + 1)) - Real.log (Stirling.stirlingSeq (n + 2)) ≤\n        (1 / (2 * ↑(n + 1) + 1)) ^ 2 / (1 - (1 / (2 * ↑(n + 1) + 1)) ^ 2)) :=\n  by sorry", "name": "Stirling.log_stirlingSeq_diff_le_geo_sum", "lemma-type": "∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α] (a : α), 0 ≤ a ^ 2", "lemma": "theorem sq_nonneg : ∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α] (a : α), 0 ≤ a ^ 2 := by\n  sorry", "doc_string": "We have a bound for successive elements in the sequence `log (stirlingSeq k)`.\n", "generated": ["theorem pow_succ_le_pow_of_nonneg' :\n    ∀ (n m_2 : ℕ) {n : ℕ} (r r' : ℝ) (hrn : n ≤ n) (hr'n : m₁ < m₂) (H : ∀ [Inst n, Nat.PartSol m₂ m] {m : (k : m∞) → k : m → ℕ}\n        (y : k := m∞.5), Hn rn hrn → H (Nat.ofDiv2 (Multiset.length m) r ^ 1) nr r_n → Nat.PartSol m m₁ :=\n  fun (x₁ t : Nat) (_tx₁ : x₁ < t) (y' : (a₂ : x₁) → y₁ i₂ (y' a')) (ih :\n    ↑x^2 * t ≤ ↑(((Finset.biInt p (⁅x', y' x′)) x₁ (k := x - t), b₁ ^ y'.k)).card) :\n  m₂ ^ Nat.factorization (max p 1) * y' b₂ (t + x) + ↑(m2 = m * b2 ^ Nat.rawCastUnit 1 (0 * t), Nat.factorization m *= b + d).part\n        (Nat.ordermin (max p 1) ·) =\n    ↑f₂ =f₂ + x ^ Nat.factorization m / a :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem not_le : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a := by sorry ", "theorem Real.log_add : ∀ (x y : ℝ), Real.log (x * y + x * (y + 1)) = ↑(y - Real.log x + 1) *  Real.log x := by sorry ", "theorem aux.110757853111697 a : ℤ >>\n              Nat.cast_nonneg 1 ^ Up.up { val := ((a)), property := ((of_decide_eq_true (Lambda.eq_true a))) } =\n            Nat.cast_nonneg 1 →\n              Mathlib.Depracted.LeCauchyNoMax.simppp ↑α true\n            Mathlib.Depracted.LEIntromax_zero_cof'\n            (fun\n                x : 1 ≥ ((↑(Nat.succ n * (f (↑n * n) + a)) ^ x [/INST] <<SYS>>\nYou are a Lean 4 coding assistant. When asked for code reply with ONLY the Lean 4 code.\n<</SYS>>\n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem Stirling.log_stirlingSeq_diff_le_geo_sum :\n    (∀ (n : ℕ),\n      Real.log (Stirling.stirlingSeq (n + 1)) - Real.log (Stirling.stirlingSeq (n + 2)) ≤\n        (1 / (2 * ↑(n + 1) + 1)) ^ 2 / (1 - (1 / (2 * ↑(n + 1) + 1)) ^ 2)) :=\n  by sorry\n``` [/INST] theorem aux.13685343331637122846 (a : ℤ)\n    (a_1 : Mathlib.DepactedD.Depractions.zero (2 * ↑(Nat.succ n * (f (↑n * n) + a)))) :\n    Mathlib.Depacted.LEIntromax_zero_cof' :\n    (∀ (x : 1 ≥ Nat.succ n * (f (↑n * n) + a)) (y : Nat) (hy : y ∈ Up.up { default })\n      (h11x : HEq y 0),\n      ↑y + Mathlib.DepracLib._is_true :=\n    Mathlib.DepracLib.LEAUX0 e0\n    ((max ⁻¹ (fun x x_3 : Nat => Set.toFinsetHaus s x) x).toFinset h (f ↑n * f 0_1))) =\n    fun ({ defaults := ({ Mathlib.Cli.OutputForm.verbose := true }), arguments := ((OrDefault.input no defaults)) }\n          defaults: ULEmble → Bool) (_s₀: { defaults := ({ Mathlib.Cli.OutputForm.verbose := true }),\n              arguments := ((OrDefault.input no defaults)) })\n      (defaults :\n        ULEmble false' →\n          Unit →\n            Mathlib.TacticLib.Conv._fischer_racks fun (x : nat) ↦ nat) ({ defaults := ((trueDefault)),\n               arguments := ((OrDefault.elim ((mathlib.depracted.LEIntromax { defaults := (((default x\n                * ((Equiv.negDif' setEquivsEmpty\n                    (Set.toFinsetSetEmpty 0_1 / { SetHom.mulDays fun o _ ↦ Nat.fst o }))\n                    true\n                  ).args_fst x))) x)) 0, Nat.fst))) =\n        List default.2 :=\n  by sorry ", "theorem sq_abs : ∀ {α : Type u_1} [inst : LinearOrderedRing α] (a : α), |a ^ 2| = a ^ 2 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem DivisorEq_sq_baseDivsq_add_one : ∀ {a b c' : ℕ}, (a ^ 2) ∣ b^2 + c' → b + a ∣ c' := by sorry "]}
{"theorem-type": "(∀ {β : Type u_2} [inst : CommRing β], LinearRecurrence.charPoly fibRec = Polynomial.X ^ 2 - (Polynomial.X + 1))", "theorem": "theorem fibRec_charPoly_eq :\n    (∀ {β : Type u_2} [inst : CommRing β], LinearRecurrence.charPoly fibRec = Polynomial.X ^ 2 - (Polynomial.X + 1)) :=\n  by sorry", "name": "fibRec_charPoly_eq", "lemma-type": "∀ {n m : ℕ}, Nat.succ n < Nat.succ m → n < m", "lemma": "theorem Nat.lt_of_succ_lt_succ : ∀ {n m : ℕ}, Nat.succ n < Nat.succ m → n < m := by sorry", "doc_string": "The characteristic polynomial of `fibRec` is `X² - (X + 1)`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Polynomial.eval_add :\n    ∀ {R : Type u} [inst : Semiring R] (p q : Polynomial R) (x : R),\n      Polynomial.eval x (p + q) = Polynomial.eval x p + Polynomial.eval x q :=\n  by sorry ", "theorem aux.9644059784151832680 {β : Type u_2} [CommRing β] (x_0 : LinearRecurrence β)\n    (x_0 : Matrix σ σ β) : Finset.univ = insert not one.out := by sorry ", "theorem aux.631457748040105895 {β : Type u_2} [CommRing β] (n : ℕ) :\n    Polynomial.C (1 - Polynomial.X ^ n) ≠ 0 := by sorry ", "theorem minPoly_self : ∀ {K : Type u_1} [inst : Field K] [inst_1 : FiniteDimens ℙ K] (x : K), minPoly K x = 0 :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry "]}
{"theorem-type": "(∀ {α : Type u_3} {β : Type u_4} [inst : LinearOrderedField α] {l : Filter β} {f : (a : β) → α} {r : α}\n  [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atTop),\n  (Filter.Tendsto (fun (x : β) ↦ r * f x) l Filter.atBot) ↔ (r < 0))", "theorem": "theorem Filter.tendsto_const_mul_atBot_iff_neg :\n    (∀ {α : Type u_3} {β : Type u_4} [inst : LinearOrderedField α] {l : Filter β} {f : (a : β) → α} {r : α}\n      [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atTop),\n      (Filter.Tendsto (fun (x : β) ↦ r * f x) l Filter.atBot) ↔ (r < 0)) :=\n  by sorry", "name": "Filter.tendsto_const_mul_atBot_iff_neg", "lemma-type": "∀ {p : Prop}, ¬p → p = False", "lemma": "theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry", "doc_string": "If `f` tends to infinity along a nontrivial filter,\n`fun x ↦ r * f x` tends to negative infinity if and only if `r < 0. `", "generated": ["theorem lt_neg_self : ∀ (x : α), x < 0⁻¹ ↔ x < 0 := by sorry ", "theorem mul_self_neg : ∀ {G : Type u_2} [inst : Mul G] [inst_1 : HasDistribNegExch G] {a : G}, (-a * a = a) := by\n  sorry ", "theorem div_null_top : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] (a : α), a / 0 = ⊤ := by sorry ", "theorem aux.2936525937594065536 {α : Type u_3} {β : Type u_4} [LinearOrderedField α] {l : Filter β} {f : (a : β) → α}\n    {r : α} [inst_1 : Filter.NeBot l] (h : Filter.Tendsto f l Filter.atTop) :\n    ↑((fun (x : β) ↦ -r * f x) = fun (x : β) ↦ r * f x) = inf fun {x : β} ↦ ↑(-r * f x) := by sorry ", "theorem Real.continuous_at_neg_of_mul_neg_lt : ∀ {x c : ℝ}, MulOpposite.op x < c * |x| → ContinuousAt c (fun x => -x * x) :=\n  by sorry ", "theorem Filter.Tendsto.mul : ∀ {β : Type v} {δ : Type w} [inst : Zero β] {f₁ : α → β} (f₂ : β → δ) [inst_1 : Mul β]\n    [inst_2 : ContinuousFun α (β → β)] {x xt : Γ ·} {y yt : Wˣ} (hy : y ∈ FormalMultilinearSeries.combing f₂ hy to₀)\n    (ifc : { p y yt ((fun (μ₁ : Γˣ) (υ₁ : Γˣ) ↦ (mulEnergyPos f₁ (f' fun p => f₂ p r ↑upt)) ⟨↑y, hy, to₀₀⟩ p) = y ((1 *↑xt yt), hy)) = hy }\n    (r : R) (h : yt = ((↑r →ᵇ FormalMultilinearSeries.piConformalMapAddLeft f₂ R x p) (((r⁻¹)•↑xt, hy)) (↑ry ((r * y)' r) ↑hy))\n    (y' : π FormallySmitableDiv ↑xt r), hh | (↑('a * y')) ← π, φ y >>= r * φ y' < o := by sorry ", "theorem Or.res_add :\n    ∀ {α : Type u_2} [inst : OrderedSemiring α] [inst_1 : ExponentiableSemiring α] {a : α} {b z : α},\n      a ⊔ b < z → 2*a ⊔ 2*b < 2*a ⊔ b + 2*b ⊔ ( z + z ) :=\n  by sorry ", "theorem tendsto_neg_atTop_zero : ∀ {α : Type u_3} [inst : LinearOrderedField α] {a : α}, Tendsto ( fun x => - x ) Filter.atTop (nhds 0) := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β] {k : Set β} {s : Set β}\n  {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x),\n  ∃ t, (k ⊆ t) ∧ ((IsOpen t) ∧ (Bornology.IsBounded (f '' (t ∩ s)))))", "theorem": "theorem Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt :\n    (∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β] {k : Set β} {s : Set β}\n      {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x),\n      ∃ t, (k ⊆ t) ∧ ((IsOpen t) ∧ (Bornology.IsBounded (f '' (t ∩ s))))) :=\n  by sorry", "name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt", "lemma-type": "∀ {α : Type u} {s t : Set α}, s ⊆ tᶜ ↔ Disjoint s t", "lemma": "theorem Set.subset_compl_iff_disjoint_right : ∀ {α : Type u} {s t : Set α}, s ⊆ tᶜ ↔ Disjoint s t := by sorry", "doc_string": "If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. ", "generated": ["theorem continuousOn_const :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n      [inst_2 : One α] {s : Set β}, ContinuousOn (fun x => 1) s :=\n  by sorry ", "theorem inter_subset_left : ∀ {α : Type u} [inst : HasInf α] [inst_1 : HasSup α] {a b : α}, a ∩ b ⊆ b := by sorry ", "theorem le_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → b ≤ a := by sorry ", "theorem ContinuousWithinAt.comp' :\n    ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {x₀ : α} {f : β → γ} {s : Set β} {t : Set α},\n      ContinuousWithinAt f s (x₀ ∫ y in t, f y ∂(uniformity β).toFilter) → ContinuousWithinAt (fun e => f e) s x₀ :=\n  by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "theorem aux.2210465519194645145 {α : Type u} {β : Type v} [PseudoMetricSpace α] [TopologicalSpace β] {k : Set β}\n    {s : Set β} {f : (a : β) → α} (hk : IsCompact k) (hf : ∀ (x : β) (a : x ∈ k), ContinuousWithinAt f s x)\n    (hfin : Bornology.IsFinite (f '' k)) (t : Set β) (h : ( closure k ⊆ t) ∧ ((IsOpen t) ∧ (f '' t ⊆ f '' closure k))) :\n    IsOpen (uIcc IccSet.uIccExtend t) := by sorry ", "theorem Bornology.IsBounded.diff :\n    ∀ {α : Type u} {s : Set α} {t : Set α}, Bornology.IsBounded s → Bornology.IsBounded t → Bornology.IsBounded (s \\ t) :=\n  by sorry ", "theorem Set.singleton_subset_iff : ∀ {α : Type u} {a b : α} {s : Set α}, {a} ⊆ s ↔ a ∈ s := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R},\n  ((IsRegular (a * b)) ∧ (IsRegular (b * a))) ↔ ((IsRegular a) ∧ (IsRegular b)))", "theorem": "theorem isRegular_mul_and_mul_iff :\n    (∀ {R : Type u_1} [inst : Semigroup R] {a : R} {b : R},\n      ((IsRegular (a * b)) ∧ (IsRegular (b * a))) ↔ ((IsRegular a) ∧ (IsRegular b))) :=\n  by sorry", "name": "isRegular_mul_and_mul_iff", "lemma-type": "{R : Type u_1} →\n  [Semigroup R] →\n    {a : R} →\n      {b : R} → (a_1 : (IsRegular a) ∧ (IsRegular b)) → (ha : IsRegular a) → (hb : IsRegular b) → IsRegular (b * a)", "lemma": "theorem aux.11626747696699211951 {R : Type u_1} [Semigroup R] {a : R} {b : R} (a_1 : (IsRegular a) ∧ (IsRegular b))\n    (ha : IsRegular a) (hb : IsRegular b) : IsRegular (b * a) := by sorry", "doc_string": "Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. ", "generated": ["theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.2655236098695867974 {R : Type u_1} [Semigroup R] {a : R} {b : R} :\n    IsRegular (1 * (a * b)) ↔ (IsRegular (a * b)) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry ", "theorem mul_left_injective₀ :\n    ∀ {M₀ : Type u_6} [inst : Mul M₀] (a : M₀), Function.Injective fun x => a * x := by sorry ", "theorem of_ eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0)\n  (h0 : (x ≠ 0) ∨ (y ≠ 0)), InnerProductGeometry.angle x (x + y) = Real.arcsin (‖y‖ / ‖x + y‖))", "theorem": "theorem InnerProductGeometry.angle_add_eq_arcsin_of_inner_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0)\n      (h0 : (x ≠ 0) ∨ (y ≠ 0)), InnerProductGeometry.angle x (x + y) = Real.arcsin (‖y‖ / ‖x + y‖)) :=\n  by sorry", "name": "InnerProductGeometry.angle_add_eq_arcsin_of_inner_eq_zero", "lemma-type": "∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α] (a : α), 0 ≤ a * a", "lemma": "theorem mul_self_nonneg :\n    ∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α] (a : α), 0 ≤ a * a := by sorry", "doc_string": "An angle in a right-angled triangle expressed using `arcsin`. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem inner_add_add_self :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      (a b : E), IsROrC.re (⟪a + b, a + b⟫_𝕜) ≤ IsROrC.re ⟪a, a⟫_𝕜 + (ℝ.re ⟪a, b⟫_𝕜 + IsROrC.re ⟪b, b⟫_𝕜)) :=\n  by sorry ", "theorem eq_comm : ∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.6574396884090666603 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) (h0 : (x ≠ 0) ∨ (y ≠ 0)) :\n    OddEquiv.symm Nat.prodCycleEnd (fun (x : Fin 1) ↦ x ≠ 0) 1 = EuclideanGeometry.polarAroundPoints 0 (fun (a : fin 1) ↦ r1 a) ·0 :=\n  by sorry ", "theorem mul_zero : ∀ {M₀ : Type u} [inst : MaurerMulM0LastName M₀] (a : M₀), a * 0 = 0 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} {β : Type u_3} [inst : Group α] [inst_1 : DivisionMonoid β] (f : α →* β) (g : α) (h : α),\n  f (g * h⁻¹) = f g * (f h)⁻¹)", "theorem": "theorem MonoidHom.map_mul_inv :\n    (∀ {α : Type u_2} {β : Type u_3} [inst : Group α] [inst_1 : DivisionMonoid β] (f : α →* β) (g : α) (h : α),\n      f (g * h⁻¹) = f g * (f h)⁻¹) :=\n  by sorry", "name": "MonoidHom.map_mul_inv", "lemma-type": "∀ {p : Prop}, p = True → p", "lemma": "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry", "doc_string": "Group homomorphisms preserve division. ", "generated": ["theorem sub_eq_add_neg : ∀ {G : Type u_1} [inst : SubGroup G] [inst_1 : AddGroup G] {a b : G}, a - b = a + -b := by\n  sorry ", "theorem aux.2484089270544649022 {α : Type u_2} {β : Type u_3} [Group α] [DivisionMonoid β] (f : α →* β) (g : α)\n    (h : α) : (Group.inv (f h) = Group.inv (f g * (f h)⁻¹)) = (Group.inv (f (Group.inv g * f h)) = Group.inv (f g)) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem MonoidHom.mem_ker : ∀ {β : Type u_2} {a : β} {f : β →* a}, a ∈ MonoidHom.ker f ↔ f a = 1 := by sorry ", "theorem MulEqual.mp : ∀ {a b c : α}, a * b = a * c → b = c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem mul_right_inv : ∀ {M : Type u_3} [inst : Mul M] (m : M) [inst_8 : OneRightMulCancel m { out := 1, of := m }], m * 1 = m := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {m : ℕ} (hm : 0 < m) (k : ℕ), ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k))", "theorem": "theorem LiouvilleNumber.partialSum_eq_rat :\n    (∀ {m : ℕ} (hm : 0 < m) (k : ℕ), ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k)) := by sorry", "name": "LiouvilleNumber.partialSum_eq_rat", "lemma-type": "∀ {α : Type u_1} [inst : Semifield α] {b d : α} (a c : α), b ≠ 0 → d ≠ 0 → a / b + c / d = (a * d + b * c) / (b * d)", "lemma": "theorem div_add_div :\n    ∀ {α : Type u_1} [inst : Semifield α] {b d : α} (a c : α),\n      b ≠ 0 → d ≠ 0 → a / b + c / d = (a * d + b * c) / (b * d) :=\n  by sorry", "doc_string": "The sum of the `k` initial terms of the Liouville number to base `m` is a ratio of natural\nnumbers where the denominator is `m ^ k!`. ", "generated": ["theorem Nat.cast_succ : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑(Nat.succ n) = ↑n + 1 := by sorry ", "theorem aux.6970706853078505157 {m : ℕ} (hm : 0 < m) (k : ℕ) : m / m ^ Nat.factorial k = m / ↑k := by sorry ", "theorem lt_irrefl ((pos_iff_natPos : ∀ (n : ℕ), (m ≠ 0) ↔ (0 < n)) = (Exists.intro { val := ((0)), property := ((m_pos)).noconfusionVersion }) ×¹ (symm (Eq.substInstSubst n (((m zero)?)) ▸ ((Pos.pos (m_pos)) = ((n + 1) / m != 0)))))) := by sorry ", "theorem sub_ne_zero : ∀ {α : Type u} [inst : SubtrlOneClass α] (a b : α), a ⊓ b ⊓ a ≠ 0 → a - b ≠ 0 := by sorry ", "theorem zero_mod : ∀ (n : ℕ), mód n 0 = 0 := by sorry ", "theorem Nat.cast_nonneg : ∀ {R : Type u_1} [inst : OrderedSemiring R] (n : ℕ), 0 ≤ ↑n := by sorry ", "theorem aux.6129323078590923051 {m : ℕ} (hm : 0 < m) (k : ℕ) : ∧ (∀ {m : ℚ} {s : ℚ} (p : (a : PartENat) → ℚ) (hs⊤ : ↑s ≤ ↑↑m)\n    (hl : m⁻¹ ≤ ↑p), l = ↑p / ↑a) := by sorry ", "theorem Finset.image_prod_eq_mul :\n    ∀ {ι : Type u\\_2} [inst : CommSemigroup α] (f : ι → α) (a : Finset ι) (b : Equiv.Perm ι),\n      ( fun i => f ↑((Equalifier.equiv (Set.Equivalant.eq (b ≤ Equiv.ofEquiv a⁻¹ b))).symm i) i) '' id a =\n        prod fun i => f ↑i :=\n  by sorry "]}
{"theorem-type": "(∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z))", "theorem": "theorem Complex.hasSum_sin :\n    (∀ (z : ℂ), HasSum (fun (n : ℕ) ↦ (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1))) (Complex.sin z)) := by\n  sorry", "name": "Complex.hasSum_sin", "lemma-type": "(z : ℂ) →\n  ∀ (n : ℕ),\n    (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1)) =\n      (-1) ^ n * (z ^ (2 * n) * z) / ↑(Nat.factorial (2 * n + 1))", "lemma": "theorem aux.8861277000320503317 (z : ℂ) :\n    ∀ (n : ℕ),\n      (-1) ^ n * z ^ (2 * n + 1) / ↑(Nat.factorial (2 * n + 1)) =\n        (-1) ^ n * (z ^ (2 * n) * z) / ↑(Nat.factorial (2 * n + 1)) :=\n  by sorry", "doc_string": "The power series expansion of `Complex.sin`. ", "generated": ["theorem Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0 := by sorry ", "theorem aux.1989477956606243527 (z : ℂ) (n : ℕ) : (ZMod.neg 1 = 1) ↔ (ZMod.neg = 1) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Continuous.comp continuous_snd :\n    ∀ {Y : Type u_2} {X : Type u_3} {α : Type u_4} [inst : TopologicalSpace Y] [inst_1 : TopologicalSpace X]\n      [inst_2 : PSEmptmaticSpace X] [inst_3 : PSEmptmaticSpace Y] {g : α → X},\n      Continuous g → Continuous (Prod.snd ∘ g) :=\n  by sorry ", "theorem summable_sin_sq_div_fact : Summable fun n => Int.cast |↑(2 * n) * z ^ 2 / 2 * ↑(Nat.factorial (2 * n)) := by\n  sorry ", "theorem tsub_eq_zero :\n    ∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LE α]\n      [i : CovariantClass α α (fun x => x - 1) fun x => x + 1] {a b : α}, a - b = 0 ↔ a = b :=\n  by sorry ", "theorem mul_assoc : ∀ {G : Type u_1}$[hG : MulSemigroup G] (a b c : G), a * b * c = a * (b * c) := by sorry ", "theorem aux.6491230615259108688 (z : ℂ) (n : ℕ) : (-↑(1 + 0 + 3) * -Complex.I + ↑1) * Complex.I = ↑1 * -Real.I :=\n  by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p),\n  Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n) ^ i)", "theorem": "theorem Polynomial.cyclotomic_prime_pow_eq_geom_sum :\n    (∀ {R : Type u_1} [inst : CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p),\n      Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n) ^ i) :=\n  by sorry", "name": "Polynomial.cyclotomic_prime_pow_eq_geom_sum", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. ", "generated": ["theorem Polynomial.X_pow_nat_sub_one' : ∀ (x : ℕ), Polynomial.X ^ x = Polynomial.X ^ x - 1 := by sorry ", "theorem aux.151 ⦃R : Type u⁋ [CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p) : Nat.MinFac p = p := by sorry ", "theorem Nat.lt_succ_iff_le : ∀ {m n : ℕ}, m < Nat.succ n ↔ m ≤ n := by sorry ", "theorem pow_dvd_mod :\n    ∀ {M : Type u_1} [inst : Monoid M] [inst_1 : CharFinMaxPow M] {P : Multiplicative (Subtype (Associates.Factors M))}\n      {Q : Multiplicative (Subtype (Associates.Factors M))} [inst_2 : DecidableEq (Associates M)],\n      (P ^ val P ∣ Q.val) ∨ (Q ≡ R [Mod P ^ val P]) → Q = P ^ Nat.factorization Q :=\n  by sorry ", "theorem Nat.cast_pow_bit1 : ∀ {n : ℕ} (m : ℕ), ↑(m ^ Nat.bit1 n) = (↑(m ^ n)) ^ Nat.bit1 n := by sorry ", "theorem Nat.prime_dvd_not_of_sq_sub_sq_ne_zero : ∀ (a b h : ℕ), Nat.Prime a → Nat.square_eq_one t → p ∣ a⁻¹ * b → a ^ 2 < b ^ 2 → a ≠ 0 := by sorry ", "theorem rfl_cartesianProduct : ∀ (α : Type u_3) (gamma: Type u_8) (val : (val : α)→gamma a 𖔸), pi fun b => g a b = val := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α × α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "((fun (τ : ℂ) ↦ jacobiTheta τ - 1) =O[Filter.comap Complex.im Filter.atTop] fun (τ : ℂ) ↦\n  Real.exp (-Real.pi * Complex.im τ))", "theorem": "theorem isBigO_at_im_infty_jacobiTheta_sub_one :\n    ((fun (τ : ℂ) ↦ jacobiTheta τ - 1) =O[Filter.comap Complex.im Filter.atTop] fun (τ : ℂ) ↦\n      Real.exp (-Real.pi * Complex.im τ)) :=\n  by sorry", "name": "isBigO_at_im_infty_jacobiTheta_sub_one", "lemma-type": "(y : ℝ) → (hy : y ≥ 1) → (τ : ℂ) → (hτ : Complex.im τ = y) → -Real.pi * Complex.im τ < 0", "lemma": "theorem aux.3339325654721190487 (y : ℝ) (hy : y ≥ 1) (τ : ℂ) (hτ : Complex.im τ = y) : -Real.pi * Complex.im τ < 0 := by\n  sorry", "doc_string": "The norm of `jacobiTheta τ - 1` decays exponentially as `im τ → ∞`. ", "generated": ["theorem IsOpen.interior_eq : ∀ {X : Type u} {s : Set X} [inst : TopologicalSpace X], IsOpen s → Interior s = s := by\n  sorry ", "theorem ContinuousWithinAtWith.mono :\n    ∀ {α : Type u_2} {β : Type u_3} [inst : TopologicalSpace α] [inst_1 : OrderTopology α]\n      [inst_2 : OrderClosedMap α α] {f : α → β} {s t : Set α},\n      ContinuousWithinAt f t s → t ⊆ s → ContinuousWithinAt f s t :=\n  by sorry ", "theorem two_ne_zero : ∀ (r : ℝ), 2 ≠ 0 := by sorry ", "theorem congrArg_int : ∀ {α : Type u_12} {a : algebraicInt α} {b : AlgebraicInt α} bval, a = b → ↑a = ↑b := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem abs_of_nonneg : ∀ {α : Type u_1} [inst : LinearOrderedRing α] {a : α} (a_1 : 0 ≤ a), |a| = a := by sorry ", "theorem isBigO_zero_top :\n    ∀ {α : Type u_1} {F : Type u F} [inst : FunLike F ℝ α] [inst_1 : OrderedAddCommGroup α] [inst_2 : TopologicalSpace α]\n      [inst_3 : OrderClosedTopology α] {f : ℂ → F}, ((Complex.re f = 0) ∩ f ≠ 0) ↔ f =O[Filter.atTop] 1 :=\n  by sorry ", "theorem FormalMultilinearSeries.limTop_eq_multilinear :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [nolift_top_order : NNReal] [inst : NontriviallyNormedField 𝕜]\n      [inst_1 : Add Commons 𝕜 𝕜] [inst_2 : Module 𝕜 E] {p : FormalMultilinearSeries 𝕜 𝕜 E} {r₁ : NNReal}\n      {c : 𝕜}, p.lim { r' := r₁ } c = (r₁, ↑↑RingHom.coeFn (QuotientAddGroup.mk' r₁ p.equiv)) :=\n  by sorry "]}
{"theorem-type": "(∀ (a : ↥circle), LinearMap.det ↑(LinearIsometryEquiv.toLinearEquiv (rotation a)) = 1)", "theorem": "theorem det_rotation : (∀ (a : ↥circle), LinearMap.det ↑(LinearIsometryEquiv.toLinearEquiv (rotation a)) = 1) := by\n  sorry", "name": "det_rotation", "lemma-type": "(a : ↥circle) →\n  (Matrix.det\n        ((LinearMap.toMatrix Complex.basisOneI Complex.basisOneI) ↑(LinearIsometryEquiv.toLinearEquiv (rotation a))) =\n      1) =\n    (Matrix.det\n        ↑(Matrix.planeConformalMatrix (Complex.re ↑a) (Complex.im ↑a)\n            (of_eq_true\n              ((congrArg (fun (x : ℝ) ↦ x ≠ 0)\n                    ((congr (congrArg HAdd.hAdd (pow_two (Complex.re ↑a))) (pow_two (Complex.im ↑a))).trans\n                      (normSq_eq_of_mem_circle a))).trans\n                ((congrArg Not Mathlib.Algebra.NeZero._auxLemma.4).trans not_false_eq_true)))) =\n      1)", "lemma": "theorem aux.6461646311320576174 (a : ↥circle) :\n    (Matrix.det\n          ((LinearMap.toMatrix Complex.basisOneI Complex.basisOneI) ↑(LinearIsometryEquiv.toLinearEquiv (rotation a))) =\n        1) =\n      (Matrix.det\n          ↑(Matrix.planeConformalMatrix (Complex.re ↑a) (Complex.im ↑a)\n              (of_eq_true\n                ((congrArg (fun (x : ℝ) ↦ x ≠ 0)\n                      ((congr (congrArg HAdd.hAdd (pow_two (Complex.re ↑a))) (pow_two (Complex.im ↑a))).trans\n                        (normSq_eq_of_mem_circle a))).trans\n                  ((congrArg Not Mathlib.Algebra.NeZero._auxLemma.4).trans not_false_eq_true)))) =\n        1) :=\n  by sorry", "doc_string": "The determinant of `rotation` (as a linear map) is equal to `1`. ", "generated": ["theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.5144304402776738391 (a : ↥circle) : Circle.eigenvalue ↑(rotation a) = a := by sorry ", "theorem LinearIsometryEquiv.toLinearEquiv_det :\n    ∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M S : Type u/u_2} [inst_1 : AddCommMonoid M]\n      [inst_2 : Module R M] [inst_3 : Module Rᵐᵒᵖ M] [inst_4 : TopologicalSpace R] [inst_5 : TopologicalAddGroup R]\n      [inst_6 : T2Space R] {f : M + ℝ →ₗ[R] AddTensorProduct R R × N} (r hp hlha : CharZero R),\n      Nonunits (FinitelyFilterLocalizedModule.submonoid S) —> NonunitalRingHom.toRingHom = LinearMap.id :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "Theorem.trans : ∀ {α : Sort u} {p q r : α → α}, (∀ (a : α), p a = q a) → (∀ (a : α), q a = r a) → ∀ (a : α), p a = r a :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem MulChar.dim :\n    ∀ {R : Type u} [inst : CommRing R] (R' : Type v) [inst' : CommRing R'] [inst'' : CharZero R'],\n      CharP R' R → NonUnitalAlgHom.DimensionLe.lim (CharP.toLim (CharZero := (fun x => Ne x | inst'') (R →₀ R')).5) :=\n  by sorry ", "theorem one_mul : ∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : (a : α) → (a : β) → γ} {u : Finset γ}\n  {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t), ∃ s' t', (↑s' ⊆ s) ∧ ((↑t' ⊆ t) ∧ (u ⊆ Finset.image₂ f s' t')))", "theorem": "theorem Finset.subset_image₂ :\n    (∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : (a : α) → (a : β) → γ} {u : Finset γ}\n      {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t),\n      ∃ s' t', (↑s' ⊆ s) ∧ ((↑t' ⊆ t) ∧ (u ⊆ Finset.image₂ f s' t'))) :=\n  by sorry", "name": "Finset.subset_image₂", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If a `Finset` is a subset of the image of two `Set`s under a binary operation,\nthen it is a subset of the `Finset.image₂` of two `Finset` subsets of these `Set`s. ", "generated": ["theorem aux.4097375476700222971 {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : (a : α) → (a : β) → γ}\n    {u : Finset γ} {s : Set α} {t : Set β} {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : (a : α) → (a : β) → γ}\n    {μ : MeasureTheory.OuterMeasure α} {ν : (a : α) → (a : β) → MeasureTheory.OuterMeasure γ}\n    (hu : ↑↑μ s = Set.empty) (v : Set β) (hs : (↑↑μ s ⊓ ↑↑ν v).IsCompl) : f ∘ fun a => ↑a = fun a => f a := by sorry ", "theorem And.casesOn : ∀ {a b : Prop} {f₁ : a → b}, a ∈ b → ∀ (h₁ : a) → f₁ h₁ = f₁ ⊥ := by sorry ", "theorem aux.4604398683946691088 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t)\n    (hs : Finset.image (fun (x : α) ↦ ∅) s ∅ ⊆ u) (ht : Finset.image (fun (x : β) ↦ ∅) t ⊆ u)\n    (ha : ∀ (a : α) (b : a ∈ s), ¬((fun (x : α) (a : β) ↦\n          ∀ (_ : (fun (x : x) ↦ Finset.image f u) x ∉ s), ⊤) a\n            ((fun (a_1 : finset α) (a : finset β) ↦ upshape a_1) b))) :=\n  by sorry ", "theorem aux.17213061349747335147 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β}\n    (hu : ↑u ⊆ Set.image2 f s t) (hs : Set.Nonempty s) : (↑u ⊆ Set.image2 f s {⊤}) ∧ (↑s ⊆ Set.image2 f s {⊤}) :=\n  by sorry ", "theorem aux.8132917387838431522 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ] {f : (a : α) → (a : β) → γ}\n    {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t) :\n    ∃ S, (setUniv ⊆ S) ∧ (S ⊆ s) ∧ ((Finset.image f (↑S ∩ Set.image2 f ↑S (Set.up (s ∩ t)).ImageSmoothmap hs ht) ⊆\n      ↑(u ∩ Finset.image two_fun fun (x : ↑s × ↑t) ↦ f ↑x.1 ↑x.2)) ∧\n        ((Finset.image f ↑((S ∩ Set.up t ∪ nonEmpty α → _t) (S ∩ Set.up t (not_nonEmpty α ∨ ¬((S ∩ t ≡ t) ∧ hst))))\n                (Set.image_subset (monotone (FunLike.coe u)) hs)) ⊆\n          ↑u ∩ ↑(Set.image two_fun fun (x : ↑S × ↑↿{ l, l' }.val × ↑t) ↦ f ↑x.1 (Function.swap (↑x.2))))) :=\n  by sorry ", "theorem aux.11337039390087644357 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t) :\n    ∃ u' y', (↑u' ⊆ f '' s) ∧ ((↑y' ⊆ f '' t) ∧ (u ⊆ ↑u' ∪ aval ε y')) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.3013646214024495028 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t) (s_ih : ∅ ⊆ u)\n    : ((fun (a : α) ⦃b : β| (a ∈ s) ∧ (b ∈ t)) sᶜ \\ Finset.image₂ f (Finset.subset_prop s ∅) (Finset.subset_prop t ∅) =\n          Finset.empty \\ u) =\n      (∀ (s' : Finset α) (_hs : ↑s' ⊆ s), ∅ \\ Finset.imageFinset₂ f (Finset.subset_prop s ∅) (FINSETS.subset_prop (.1) ∅) =\n        ∅ \\ u) :=\n  by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n)))", "theorem": "theorem Nat.exists_prime_lt_and_le_two_mul : (∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n))) :=\n  by sorry", "name": "Nat.exists_prime_lt_and_le_two_mul", "lemma-type": "(n : ℕ) →\n  (hn0 : n ≠ 0) →\n    (h : n ≤ 511) →\n      (h_1 : (lt_or_le 511 n) = (Or.inr h)) → ∀ (hn : n < 23), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n))", "lemma": "theorem aux.5562007796470256154 (n : ℕ) (hn0 : n ≠ 0) (h : n ≤ 511) (h_1 : (lt_or_le 511 n) = (Or.inr h)) :\n    ∀ (hn : n < 23), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n)) := by sorry", "doc_string": "**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large.\n", "generated": ["theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry ", "theorem IsPrimePow.lt_mul_and_self_pow_le :\n    ∀ {n m : ℕ}, UniqueFactorizationMonoid.IsPrimePow n » n + n - 1 + j • n ^ i _ => min2 1 n • n ≠ 2 := by\n  sorry ", "theorem Nat.zero_eq' : ∀ {a : ℕ} (a_eq_zero : a = 0), a = 0 := by sorry ", "theorem Nat.dvd_two : ∀ {n : ℕ}, n % 2 = 0 ↔ n ∣ 2 := by sorry ", "theorem aux.11181345874178872325 (n : ℕ) (hn0 : n ≠ 0) : ∃ q, 0 < q ∧ (q ≤ n) := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem MulZeroClass.zero_mul' : ∀ {M₀ : Type u} [inst : MulZeroClass M₀] (a : M₀), 0 * a = 0 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ))", "theorem": "theorem Complex.tan_eq_zero_iff : (∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) := by sorry", "name": "Complex.tan_eq_zero_iff", "lemma-type": "{θ : ℂ} →\n  ((2 * (Complex.sin θ * Complex.cos θ) = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) =\n    ((2 * Complex.sin θ * Complex.cos θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ))", "lemma": "theorem aux.7361481131112518342 {θ : ℂ} :\n    ((2 * (Complex.sin θ * Complex.cos θ) = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) =\n      ((2 * Complex.sin θ * Complex.cos θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) :=\n  by sorry", "doc_string": "The tangent of a complex number is equal to zero\niff this number is equal to `k * π / 2` for an integer `k`.\n\nNote that this lemma takes into account that we use zero as the junk value for division by zero.\nSee also `Complex.tan_eq_zero_iff'`.  ", "generated": ["theorem rnat.zpow_nat_succ : ∀ (n i : ℤ), (∽ n)^ Nat.succ = ∽ n * n := by sorry ", "theorem isClosed_singleton : ∀ {α : Type u} [inst : TopologicalSpace α] (a : α), IsClosed {a} := by sorry ", "theorem aux.14918106995723829999 {θ : ℂ} : ((1 = 2↑θ) ∨ (φ = φ_1)) = φ = φ_1 := by sorry ", "theorem aux.3248533523134297319 {θ : ℂ} (a : Complex.tan θ = 0) : 2 / (2 * Complex.sin θ) = Complex.sin θ⁻¹ := by\n  sorry ", "theorem aux.1084520156673493954 {θ : ℂ} : (Real.arctan (0 / 0) ∈ {↑k * ↑Real.pi / 2 | ∃ k, True}) ↔ False := by\n  sorry ", "theorem aux.5686430411569415933 {θ : ℂ} (a : 0 ∈ Complex.range fun (a : ℤ) ↦ ↑a * ↑Real.pi / 2) (z : ↑ℤ • 2 * ↑Real.pi)\n    (hz : z ∈ Complex.spanClosure Complex.I {0}) (a₁ : Complex.I * ↑z = ↑θ) (r : ℤ)\n    (h_1 : Complex.I ^ r * ↑(r • ↑Real.pi / 2) = ↑θ) : Eq ↑θ Complex.I * ↑(r • ↑Real.pi / 2 * 2) = False := by sorry ", "theorem Ne.trans : ∀ {α : Sort u} {a b c : α}, a ≠ b → b ≠ c → a ≠ c := by sorry ", "theorem Complex.IsROrC.tan_periodic₂ :\n    (∀ (x : (cothetaFinset ▸ Complex.IsROrC.tan) UnitInterval x),\n      Complex.tan ↑(x.2) = Complex.tan ↑(iforall_prop (Complex.IsROrC.periodic₂_nat_snd UnitInterval))) :=\n  by sorry "]}
{"theorem-type": "(∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n  (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ),\n  sInf ((fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) '' Set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0 ..T, g x ≤\n    ∫ (x : ℝ) in 0 ..t, g x)", "theorem": "theorem Function.Periodic.sInf_add_zsmul_le_integral_of_pos :\n    (∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n      (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ),\n      sInf ((fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) '' Set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0 ..T, g x ≤\n        ∫ (x : ℝ) in 0 ..t, g x) :=\n  by sorry", "name": "Function.Periodic.sInf_add_zsmul_le_integral_of_pos", "lemma-type": "{T : ℝ} →\n  {g : (a : ℝ) → ℝ} →\n    (hg : Function.Periodic g T) →\n      (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) →\n        (hT : 0 < T) →\n          (t : ℝ) →\n            let ε : ℝ := Int.fract (t / T) * T;\n            (a : T = 0) →\n              Mathlib.Meta.NormNum.IsNat\n                (T ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + T ^ Nat.rawCast 1 * Nat.rawCast 1) 0", "lemma": "theorem aux.11404472351312093800 {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n    (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ) :\n    let ε : ℝ := Int.fract (t / T) * T;\n    (a : T = 0) →\n      Mathlib.Meta.NormNum.IsNat (T ^ Nat.rawCast 1 * Int.rawCast (Int.negOfNat 1) + T ^ Nat.rawCast 1 * Nat.rawCast 1)\n        0 :=\n  by sorry", "doc_string": "If `g : ℝ → ℝ` is periodic with period `T > 0`, then for any `t : ℝ`, the function\n`t ↦ ∫ x in 0..t, g x` is bounded below by `t ↦ X + ⌊t/T⌋ • Y` for appropriate constants `X` and\n`Y`. ", "generated": ["theorem Set.Ico_sub_right : ∀ {α : Type u_1} [inst : AddGroup α] [ inst_1 : LE α] [_i : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, b ∈ Set.Ico a (b + a) := by sorry ", "theorem one_add : ∀ {α : Type u_1} [inst : AddMonoid α] (a : α), 1 + a = a + 1 := by sorry ", "theorem Set.Icc_union_Ico_self : ∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, (Set.Icc a b ∪ Set.Ico a b).card = 2 :=\n  by sorry ", "theorem add_tsub_comm :\n    ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b : α} [h : Sub α PFunctThree.min_def],\n      a + b - b = a + (b - b) = a + 0 :=\n  by sorry ", "theorem intervalIntegral.Integrable.continuousSgn_image :\n    ∀ {T₀ : ℝ} {T₁ : ℝ}, -T₀ / T₁ ≤ T₁ =>\n      ∀ {E V : Type uV} [inst : Fact (FiniteDimensional ℝ E)] [inst_1 : NormedAddCommGroup V] [scrt : ContractingSpace T₁ T₀]\n      [inst_2 : Module E ℝ] [inst_3 : Module E ℝ] [inst_4 : IsCompleteIn E ℝ] {K₀ : Cohometopic υ T₀}\n      {r : CohomologyIsExactPure (Mfde X), i₁ : S (r : D) N ⟶ E}, S (r.ofi 1 i₁ 0 - S (r₣.of) N' ·0 ⟶ E) = N :\n      Prop := by sorry ", "state={\n  nonrec_opt_α : (α → α) → (a_0 : Unit) → α,\n  unionsᵢ_comm : ∀ (i : ι) (a : α i), Finset.unions Finset.univ fun x => a i = Finset.unions Finset.univ a ≤\n      Finset.unions Finset.univ fun x => (a i).1 :=\n  by sorry ", "function aux.6751144449305509919 {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n    (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ) :\n    ∫ (x : { x : ℝ // 0 < x }), g ↑x = ∫ (x : _i), g ({ y : ℝ // 0 <y } x) := by sorry ", "theorem le_zero : NNReal 0 ≤ ↑0 := by sorry "]}
{"theorem-type": "(∀ {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f), ∃ z, Polynomial.IsRoot f z)", "theorem": "theorem Complex.exists_root : (∀ {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f), ∃ z, Polynomial.IsRoot f z) := by\n  sorry", "name": "Complex.exists_root", "lemma-type": "{f : Polynomial ℂ} → (hf : 0 < Polynomial.degree f) → (hf' : ¬(∃ z, Polynomial.IsRoot f z)) → (z : ℂ) → (0 = 0) = True", "lemma": "theorem aux.12957416102853755082 {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f) (hf' : ¬(∃ z, Polynomial.IsRoot f z))\n    (z : ℂ) : (0 = 0) = True := by sorry", "doc_string": "**Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root ", "generated": ["theorem FiniteDimensional.one_lt_finrank_iff :\n    ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n      [InstFiniteDimensional K V] [inst_3 : Field K] [inst_4 : IsReduced (Polynomial K)],\n      1 < FiniteDimensional.finrank K V ↔ finrank K V < DimensionLeitch.coefficientCount.card K :=\n  by sorry ", "theorem polynomial_mem_rootSet_iff :\n    ∀ {R : Type u} {ι : Sort v} (τ : R → ι) (p : Polynomial R) (h : ∀ a < Finset.sup τ ⇑0 → ⟪a, p⟫ₘ = 0) (n : ι),\n      a ∈ mulRingAction.rootSet (Polynomial ⇑dvdInt.intLcm) (Polynomial.X : Polynomial ℝ n -² p / (a -❖ p)) :=\n  by sorry ", "theorem zero_lt_one : ∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : PartialOrder α] [inst_2 : Zero α]\n    [inst_3 : One α] [inst_4 : NeZero 1], 0 < 1 := by sorry ", "theorem aux.18315916867484385557 {f : Polynomial ℂ} : (∥Polynomial.comp (PolynomialFun.rationalize 2) f ∥ ≠ ⊤) = True :=\n  by sorry ", "deducethis :\n    (∘ (fun (z : ℂ) ↦ ⇑(IsRoot.some_exp_infiniteRoots (0, 1)) z)) 1 ↑↑f = 0 ⊔ 1 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ", "theorem aux.12994369375427650826 {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f) (a : Complex.re (Polynomial.coeff f 0) ≤ 0)\n    (H : Polynomial.compactSpaceOfClosed ∅ ⊤ < (Set.range Polynomial.rootMultiplicity) '' Finset.erase Finset.univ 1) (z : ℂ)\n    (H_eq : ((starRingEnd ℂ) z = Polynomial.rootMultiplicity f z) ∧ (z ≠ 0)) :\n    ∀ (a : ¬ (Polynomial.isRoot f z)),\n      ¬((starRingEnd ℂ) z = Polynomial.rootMultiplicity f z) :=\n  by sorry "]}
{"theorem-type": "(∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ))", "theorem": "theorem Complex.tan_eq_zero_iff : (∀ {θ : ℂ}, (Complex.tan θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) := by sorry", "name": "Complex.tan_eq_zero_iff", "lemma-type": "{θ : ℂ} →\n  ((Complex.sin θ * Complex.cos θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) =\n    ((2 * (Complex.sin θ * Complex.cos θ) = 2 * 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ))", "lemma": "theorem aux.12051731951689549807 {θ : ℂ} :\n    ((Complex.sin θ * Complex.cos θ = 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) =\n      ((2 * (Complex.sin θ * Complex.cos θ) = 2 * 0) ↔ (∃ k, ↑k * ↑Real.pi / 2 = θ)) :=\n  by sorry", "doc_string": "The tangent of a complex number is equal to zero\niff this number is equal to `k * π / 2` for an integer `k`.\n\nNote that this lemma takes into account that we use zero as the junk value for division by zero.\nSee also `Complex.tan_eq_zero_iff'`.  ", "generated": ["theorem congrFun : ∀ {α : Sort u} {β : α → Sort v} {f g : (a : α) → β a}, f = g → ∀ (a : α), f a = g a := by sorry ", "theorem Complex.tan_coe_real : ∀ (x : ℝ), Complex.tan ↑x = Complex.tan ↑x := by sorry ", "theorem mul_lt_mul_iff_left :\n    ∀ {M : Type u_3} [inst : Mul M] [inst_1 : HasLHS M (fun x x_1 => x * x_1] {a : M} {a₁ b₁ b₂ : M}\n      (ac : b₁ ≤ b₂), (a * a₁ < a * b₁ ∧ a₁ < a * b₂) ↔ b₁ < a⁻¹ * a₁) :=\n  by sorry\n``` [/INST] theorem eq_comm : ∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a := by sorry ", "theorem aux.17969039038220367031 {θ : ℂ} (a : 0 ≠ ↑Complex.Im θ) : ((Real.pi / 2) = ↑0) = ((Real.pi / 2) * Complex.re θ₀₀ + (Real.pi / 2) * Complex.im θ₀ = 0) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Complex.im.eq_zero_of_in_one_quarter_sector :\n    ∀ {θ : ℂ} (y : ℝ) (_z : θ = Complex.arg (Complex.I * Complex.I * ⅟(-Complex.I ^ 2) * Complex.I * y)),\n      Complex.im.im (Complex.arg (Complex.I * Complex.I * ⅟(-Complex.I ^ 2) * Complex.I * y)) ∈ {0} :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem isRat_mul : ∀ {M : Type u_2} [inst : DistribSMul R M] [s : StrongRankCondition R] {y z : M}, ∃ r, z = ↑r • y ↔ z ≠ 0 ∨ y = 0 := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : Bornology α] {p : (a : α) → Prop} (a : Bornology.IsBounded {x : α | p x}),\n  BoundedSpace (Subtype p))", "theorem": "theorem Bornology.IsBounded.boundedSpace_subtype :\n    (∀ {α : Type u_1} [inst : Bornology α] {p : (a : α) → Prop} (a : Bornology.IsBounded {x : α | p x}),\n      BoundedSpace (Subtype p)) :=\n  by sorry", "name": "Bornology.IsBounded.boundedSpace_subtype", "lemma-type": "{α : Type u_1} →\n  [inst : Bornology α] →\n    {p : (a : α) → Prop} →\n      {α : Type u_1} →\n        [Bornology α] →\n          {p : (a : α) → Prop} → (BoundedSpace (Subtype p)) = (Bornology.IsBounded (Set.range Subtype.val))", "lemma": "theorem aux.2544249363560243184 {α : Type u_1} [inst : Bornology α] {p : (a : α) → Prop} {α : Type u_1} [Bornology α]\n    {p : (a : α) → Prop} : (BoundedSpace (Subtype p)) = (Bornology.IsBounded (Set.range Subtype.val)) := by sorry", "doc_string": "**Alias** of the reverse direction of `boundedSpace_subtype_iff`.", "generated": ["theme: Left.gref_on_zero\nsubscribable : ∀ (P : Prop), Prop -> P -> true := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem isNonemptyCFLongLong_congr :\n    ∀ {ι : Type u_9} {κ : Type u_10} (𝒞 : BoundedCFl 𝒢 ι fun Ix => ‖lid Ix‖₊) {UU₁₁ : (i : I) → (κ₊ / id i) → (ι ↪ U → Δ \\ ∘ id i)₁},\n      (Bornology.IsNonempty\n          {I's i |\n            I I'⊤ ∈\n              Set.TFAE.225 𝒞 × Set.Icc l' UU₁ [Set.Iso.symm (Set.Iso.refl₁ (𝒢 → SFun B F)) x] x} →\n          List.TFAE (BoundedCFl.longLong_le 𝒢) (BoundedCFLongLe (𝒢'₂) → (𝒢'₁ ⊗ id₂.symm) L) →\n            ∁ (Ii : Sub.α {I₁₦ y : ι /* id = lid' ⟦id ⟧ id _I' Ͽ y → s < l')})\n        (fun a => ∂ I I'⊝ ≤ L' Δ₀) x;\n        Bornology.IsCfl {f : HF 𝒢 →ᵆ {i₂} → κ₊}.boundedCBGF (Fit1.toPc {ⱪ₊}₀ L') ∂ Idp.toPi CB).p) =\n      BorderCPicByF.toCBG.longlongCBGF 𝒢\n        (HF.f a₁ a [HFnB.toPEq {i₂}\\nop] HFnT.toPEq).boundedCBGF :=\n  by sorry ", "theorem aux.2316384134170175371 {α : Type u_1} [Bornology α] {p : (a : α) → Prop}\n    {𝕜 : Type u_4} [EMetricSpace 𝕜] : (BoundedSpace (Subtype p)) ↔ (AllBornologyBounded Subtype p) := by sorry ", "theorem BoundedSpace.mk :\n    ∀ {α : Type u_1} (cond : DistribLattice α) [iB : PreLatticeOrderTopology Disjoint α] {s : α},\n      (Disjoint (s *ᵥᵥ s) {⅟ s}) → BoundedSpace cond ⊥ s → s > 0 → (BoundedSpace cond {s}).boundedOfPosInf :=\n  by sorry ", "theorem aux.3596785571185363400 {α : Type u_1} [bornology : Bornology α] {p : (a : α) → Prop} {p' : (a : α) → Prop}\n    (hb : Bornology.IsBounded {x : β | p x})\n    (s : IsLatticeLinearOrderedAddCommGroup SemilatticeSup.toSemilatticeAdd α) (a : Subtype p) {a_1 : β} [inst : Infinite ↑{ a_1 }]\n    (s_ne : s ≠ ∞)\n    (bdd_ih : ∀ s_ne a, 0 ⊥ ∥(fun a' ≈ a => ∃ x, (PFun.app a' a ≠ x) ∧ PFun.fix.IsFixedPoint x a')ℂ⟐ b₀)\n    (s_unbounded' :\n      ⊤ ≤\n        ConvexCone.coe''(EMetric.ball a (PFun.lim bdd a')) \\ ConvexCone.clippedPFuns c₀ b₀ =ᶠ[nhms] t) :\n    max l RB * c₀ = max l l * c₀ 3 := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : PartialEquiv α β) {e' : PartialEquiv α γ} {x : α}\n  (he : x ∈ PartialEquiv.source e) (he' : x ∈ PartialEquiv.source e'),\n  ↑e x ∈ PartialEquiv.source (PartialEquiv.trans (PartialEquiv.symm e) e'))", "theorem": "theorem PartialEquiv.mem_symm_trans_source :\n    (∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : PartialEquiv α β) {e' : PartialEquiv α γ} {x : α}\n      (he : x ∈ PartialEquiv.source e) (he' : x ∈ PartialEquiv.source e'),\n      ↑e x ∈ PartialEquiv.source (PartialEquiv.trans (PartialEquiv.symm e) e')) :=\n  by sorry", "name": "PartialEquiv.mem_symm_trans_source", "lemma-type": "{α : Type u_1} →\n  {β : Type u_2} →\n    {γ : Type u_3} →\n      (e : PartialEquiv α β) →\n        {e' : PartialEquiv α γ} →\n          {x : α} →\n            (he : x ∈ PartialEquiv.source e) →\n              (he' : x ∈ PartialEquiv.source e') →\n                ↑(PartialEquiv.symm (PartialEquiv.symm (PartialEquiv.symm e))) (↑e x) ∈ PartialEquiv.source e'", "lemma": "theorem aux.7723138483482981563 {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : PartialEquiv α β)\n    {e' : PartialEquiv α γ} {x : α} (he : x ∈ PartialEquiv.source e) (he' : x ∈ PartialEquiv.source e') :\n    ↑(PartialEquiv.symm (PartialEquiv.symm (PartialEquiv.symm e))) (↑e x) ∈ PartialEquiv.source e' := by sorry", "doc_string": "A lemma commonly useful when `e` and `e'` are charts of a manifold. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.148978847871380636 {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : PartialEquiv α β)\n    {e' : PartialEquiv α γ} {x : α} (he : x ∈ PartialEquiv.source e) (he' : x ∈ PartialEquiv.source e') :\n    ↑e x ∈ {z : γ | ↑e' z = e z} := by sorry ", "theorem PartialEquiv.trans_self :\n    ∀ {α : Type u_1} {β : Sort u_2} {e : PartialEquiv α β}, PartialEquiv.trans e (PartialEquiv.symm e) = ⊤ := by\n  sorry ", "theorem LE.le.antisymm : ∀ {α : Type u} [inst : PartialOrder α] {a b : α}, a ≤ b → b ≤ a → a = b := by sorry ", "theorem PartialEquiv.sourceEquivRefl : ∀ {α : Type u_1} (e : PartialEquiv α α), ↑e.source ±ˢ PartialRel.refl α e := by\n  sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.1934719572724965545 {α : Type u_1} {β : Type u_2} {γ : Type u_3} (e : PartialEquiv α β)\n    {e' : PartialEquiv α γ} {x : α} (he : x ∈ PartialEquiv.source e) (he' : x ∈ PartialEquiv.source e')\n    :\n    x ∈ PartialEquiv.toPartialEquiv e ∩ ↑(PartialEquiv.symm e) ⁻¹' (PartialEquiv.toPartialEquiv e') := by sorry "]}
{"theorem-type": "(∀ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : Ring K] [inst_2 : Algebra F K] {E : Type u_3}\n  [inst_3 : Ring E] [inst_4 : Algebra F E] (e : K ≃ₐ[F] E) [inst_5 : IsSeparable F K], IsSeparable F E)", "theorem": "theorem AlgEquiv.isSeparable :\n    (∀ {F : Type u_1} {K : Type u_2} [inst : CommRing F] [inst_1 : Ring K] [inst_2 : Algebra F K] {E : Type u_3}\n      [inst_3 : Ring E] [inst_4 : Algebra F E] (e : K ≃ₐ[F] E) [inst_5 : IsSeparable F K], IsSeparable F E) :=\n  by sorry", "name": "AlgEquiv.isSeparable", "lemma-type": "{F : Type u_1} →\n  {K : Type u_2} →\n    [CommRing F] →\n      [Ring K] →\n        [Algebra F K] →\n          {E : Type u_3} →\n            [Ring E] →\n              [Algebra F E] →\n                (e : K ≃ₐ[F] E) → [IsSeparable F K] → (x : E) → Polynomial.Separable (minpoly F ((AlgEquiv.symm e) x))", "lemma": "theorem aux.18219524773780102330 {F : Type u_1} {K : Type u_2} [CommRing F] [Ring K] [Algebra F K] {E : Type u_3}\n    [Ring E] [Algebra F E] (e : K ≃ₐ[F] E) [IsSeparable F K] (x : E) :\n    Polynomial.Separable (minpoly F ((AlgEquiv.symm e) x)) := by sorry", "doc_string": "Transfer `IsSeparable` across an `AlgEquiv`. ", "generated": ["theorem AlgEquivProgram.fieldEqTo_equiv_mapPolyEquiv_finite :\n    ∀ (p q : NonAssocSemiring) (R S : MultivariatePolynomial p →+∗* MultivariatePolynomial q) {I : Ideal R}\n      (M : Subring p) (_sur : R →ₗₓ[ℚ] R) (a : Ideal R) (a' : Ideal R), a ∈ ⊥ := by sorry ", "theorem Field.isSeparable_bot :\n    ∀ (F : Type u) [inst : Field F] [inst_1 : Algebra F ⊥], IsSeparable F ⊥ := by sorry ", "theorem isSeparableFf_top : ∀ (F : Type u_16) [inst : Field F] [mdiv F], IsSeparable F ⊤ := by sorry ", "theorem IsAlgSeparable.range_algebraMap :\n    ∀ {R : Type uR} [inst : CommRing R] {R₁ : Type uR₁} [inst_1 : CommRing R₁] {A Al R₁ : Type u}\n      [inst_3 : CommsemiringAlg A R₁] {_biF : R ≃ₐₗ[R₁] Al}, ⋆(IsAlgSeparable A Al)) :=\n  by sorry ", "theorem AlgEquiv.isIntegral :\n    ∀ {R : Type u}_2 {A : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (e : A ≃ₚ₁[R] A), R ⊗[R] A ≃⋆ₐ[R] (e.toInvertible).val ⧸₝ r (Module.dualPairing R),\n      (AlgEquiv.starRingEquiv e.symm o).AlgebraIsScalarTower R A :=\n  by sorry ", "theorem separableByFG :\n    ∀ {F : Type u} [L : Field F] (K : Type u₁) [inst : Field K] [inst_1 : Algebra F K] [inst_2 : IntermediateField F K]\n    [(h : (IsPremediation F K) ∨ (IsUltraradical F K), (Field.separatorOrbit F K = ⊤) = True)],\n      EMetrics.separableEither K L :\n        E ⟶ ↑\n          (Nonempty { g, K' : Subalgebra F K, L, g : K ⤺ R⟮A⟯ ≃ₐ[A] K' // (g ≠ Set.id) ∧ (R⟮A‖ ⊆ Subfield.val ↑K') }) :=\n  by sorry ", "theorem Subalgebra.isSeparable_op :\n    ∀ {F A K E : Type u_1} [inst : Field F][inst_1 : NormedRing F] [inst_2 : NormedAlgebra F A] {a : Subalgebra F A}\n       [hi₁ : IsSeparable F A ⊤] [hi₂ : DedekindDomain ⁅DedekindRing.toSemiring K, multiplicity F A ⊤#]\n      (hin₂ : a ≤ Subalgebra.topology ⊤,\n      hp : ringEquivCompleteDiscr p fun I => (↑I)⁻¹ • Subalgebra.mulOfBijective₀ p ((fun I => (↑I)⁻¹) ∘I g)) :\n      𝒢.comap (AlgEquiv.mapDvd.transformFun p g) (IsLocalGprs g g' h₁ p) ≤ 𝒜'' := by sorry ", "theorem algEquiv_trans_apply :\n    ∀ {A₁ : Type u_1} {A₂ : Type u_2} {A₃ : Type u_3} [RA : Ring A] (E : A₁ ≃++ A₂) (F : A₂ ≃+* A₃) (a : A₁ →ₐ[RA] A₃),\n      (ofEquivInvEltKey F) (((algEquivTransAlgHom A₁ E F).transInverse a) a).2 = F (a.toAlgHom ∘ ↑E ((algEquivTransPalin L E) a) : K →+* A₁) :=\n  by sorry "]}
{"theorem-type": "(∀ {S : Type u} {M : Type v} {M' : Type v'} [inst : CommRing S] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M']\n  [inst_3 : StrongRankCondition S] [inst_4 : Module S M] [inst_5 : Module.Free S M] [inst_6 : Module S M']\n  [inst_7 : Module.Free S M'],\n  Module.rank S (TensorProduct S M M') =\n    Cardinal.lift.{v', v} (Module.rank S M) * Cardinal.lift.{v, v'} (Module.rank S M'))", "theorem": "theorem rank_tensorProduct :\n    (∀ {S : Type u} {M : Type v} {M' : Type v'} [inst : CommRing S] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M']\n      [inst_3 : StrongRankCondition S] [inst_4 : Module S M] [inst_5 : Module.Free S M] [inst_6 : Module S M']\n      [inst_7 : Module.Free S M'],\n      Module.rank S (TensorProduct S M M') =\n        Cardinal.lift.{v', v} (Module.rank S M) * Cardinal.lift.{v, v'} (Module.rank S M')) :=\n  by sorry", "name": "rank_tensorProduct", "lemma-type": "{S : Type u} →\n  {M : Type v} →\n    {M' : Type v'} →\n      [CommRing S] →\n        [AddCommGroup M] →\n          [AddCommGroup M'] →\n            [StrongRankCondition S] →\n              [Module S M] →\n                [Module.Free S M] →\n                  [Module S M'] →\n                    [Module.Free S M'] →\n                      (val : (I : Type v) × Basis I S M) →\n                        (fst : Type v) →\n                          (bM : Basis fst S M) →\n                            (val : (I : Type v') × Basis I S M') →\n                              (fst_1 : Type v') → (bN : Basis fst_1 S M') → Cardinal.mk fst = Module.rank S M", "lemma": "theorem aux.18333773585287957554 {S : Type u} {M : Type v} {M' : Type v'} [CommRing S] [AddCommGroup M]\n    [AddCommGroup M'] [StrongRankCondition S] [Module S M] [Module.Free S M] [Module S M'] [Module.Free S M']\n    (val : (I : Type v) × Basis I S M) (fst : Type v) (bM : Basis fst S M) (val : (I : Type v') × Basis I S M')\n    (fst_1 : Type v') (bN : Basis fst_1 S M') : Cardinal.mk fst = Module.rank S M := by sorry", "doc_string": "The rank of `M ⊗[R] M'` is `(Module.rank R M).lift * (Module.rank R M').lift`. ", "generated": ["theorem of_eq' : ∀ {p q : Prop}, p ↔ q → (q → p) → (∀ (h : q), p) := by sorry ", "theorem rank_multilinearMapMap_eq_rank :\n    ∀ (R : Type u_1) (R₃ : Type u_2) {A : Type u_6} [inst : CommSemiring R] [inst_1 : CommSemiring R₃]\n      [inst_2 : Matrix.Nontrivial R] [inst_3 : SMulCommClass R R₃ R₃] [inst_4 : AddSemiremodule R₃ A]\n      (f : MultilinearMap A Rᵒᵖ →ₗ[R] Aᵃᵝ) {r₁ : R} {r₂ : R₂}, f ⟨f.prop, iff_and f».eq⟩ (Basis.coord f) r₂ < f ᗮ r₁ :=\n  by sorry ", "theorem aux.11769355790429432673 {S : Type u} {M : Type v} {M' : Type v'} [CommRing S] [AddCommGroup M] [AddCommGroup M']\n    [StrongRankCondition S] [Module S M] [Module.Free S M] [Module S M'] [Module.Free S M']\n    (B : Bases (Module.Free S M)) (B' : Bases (Module.Free S M')) : Function.Injective fun (x : M × M') ↦ iSigma f y :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.14879153933569255141 {S : Type u} {M : Type v} {M' : Type v'} [CommRing S] [AddCommGroup M] [AddCommGroup M']\n    [StrongRankCondition S] [Module S M] [Module.Free S M] [Module S M'] [Module.Free S M'] :\n    IsRegular (TensorProduct.regReg M 'M') := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem tensorProductDim_mk :\n∀ {Q : Type u} [inst : AddGroup Q] [inst_1 : Fintype Q], ↑(tensorProductDim ((LinearTransversal B Q) ▸ B × B)) ≠ finempty → TensorProduct.Rank h ((LinearTransversal B Q) ▸ B × B) < FiniteDimensional.finrank ℚ ((LinearTransversal B Q) ▸ B × D) := by sorry ", "theorem aux.490464320436869462 {S : Type u} {M : Type v} {M' : Type v'} [CommRing S] [AddCommGroup M] [AddCommGroup M']\n    [StrongRankCondition S] [Module S M] [Module.Free S M] [Module S M'] [Module.Free S M'] (r : Cardinal.{w})\n    (hr : ↑r < Cardinal.rank S * Cardinal.rank S)\n    (hrr : Cardinal.rank S + Cardinal.rank S < Cardinal.lift.{w, w}', ↑r) (h : ↑r = ↑(0 + Cardinal.rank S)) :\n    ↑(0 + Cardinal.rank S) = 0 := by sorry "]}
{"theorem-type": "(∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n  a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q)", "theorem": "theorem ENNReal.young_inequality :\n    (∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n      a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q) :=\n  by sorry", "name": "ENNReal.young_inequality", "lemma-type": "(a : ENNReal) →\n  (b : ENNReal) →\n    {p : ℝ} →\n      {q : ℝ} →\n        (hpq : Real.IsConjExponent p q) →\n          ↑(a.toNNReal * b.toNNReal) ≤ ↑(a.toNNReal ^ p) / ENNReal.ofReal p + ↑b.toNNReal ^ q / ENNReal.ofReal q", "lemma": "theorem aux.5035188862964546683 (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q) :\n    ↑(a.toNNReal * b.toNNReal) ≤ ↑(a.toNNReal ^ p) / ENNReal.ofReal p + ↑b.toNNReal ^ q / ENNReal.ofReal q := by sorry", "doc_string": "Young's inequality, `ℝ≥0∞` version with real conjugate exponents. ", "generated": ["theorem ENNReal.by_cases : ∀ {t c t : False | c → a = t}, tst b false c := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem neg_inj : ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {a b : α}, -a = -b ↔ a = b := by sorry ", "theorem mul_zero : ∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] (a : M₀), a * 0 = 0 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n  (f : WithLp p (α × β)), edist f f = 0)", "theorem": "theorem WithLp.prod_edist_self :\n    (∀ (p : ENNReal) {α : Type u_2} {β : Type u_3} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β]\n      (f : WithLp p (α × β)), edist f f = 0) :=\n  by sorry", "name": "WithLp.prod_edist_self", "lemma-type": "(p : ENNReal) →\n  {α : Type u_2} →\n    {β : Type u_3} →\n      [PseudoEMetricSpace α] →\n        [PseudoEMetricSpace β] →\n          (f : WithLp p (α × β)) →\n            (h : (p = ⊤) ∨ (0 < p.toReal)) →\n              (h : 0 < p.toReal) →\n                ∀ (x_0 : Type u_2) (x_1 : Type u_3) (x_2 : EDist x_0) (x_3 : EDist x_1) (f : WithLp p (x_0 × x_1))\n                  (g : WithLp p (x_0 × x_1)),\n                  edist f g = (edist (f.1) (g.1) ^ p.toReal + edist (f.2) (g.2) ^ p.toReal) ^ (1 / p.toReal)", "lemma": "theorem aux.1537702763244928185 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) (h : (p = ⊤) ∨ (0 < p.toReal)) (h : 0 < p.toReal) :\n    ∀ (x_0 : Type u_2) (x_1 : Type u_3) (x_2 : EDist x_0) (x_3 : EDist x_1) (f : WithLp p (x_0 × x_1))\n      (g : WithLp p (x_0 × x_1)),\n      edist f g = (edist (f.1) (g.1) ^ p.toReal + edist (f.2) (g.2) ^ p.toReal) ^ (1 / p.toReal) :=\n  by sorry", "doc_string": "The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. ", "generated": ["attribute {\n  name := assert_not_terminal_by_meta :\n  TerminationProof.{bool} False False\n  toRefl ((fun X XX b ⇒ Mathlib.Data.Real.NormedAddCommGroup.RealP.inj xf b true true) false bX not_false_eq) (_ : b)\n  bX + True) in\n  let d_e_0 : ∀ (x : \\a --bound arity is not correct in this line, but as stated already--, edist m n = aedist m n)\n      (x : (\\a : Edist A 0)-- instance is not yet automatically translated , true--0) (_x_0hqB :=\n      not inst_1 (fun b ↦ ∠ (xf b).edist 0 b ▸ _x_1hqB h)),\n    (d : Prop | Decidable b ↔ Not False) ▸\n      or (_ : Decidable ⟦0 = 0 ^20\\_1) :=\n  by sorry ", "theorem aux.15955517696915151933 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) :\n    eq_of_heq (edist f f)\n      (Heq.of_heq HPeq' edist (edist_withLp_symm : edist (WithLp.toLpAux p (a → β)) (WithLp.toLpAux p d) = edisst :\n        ⨅ x y, ⧂ (edist x y).toReal ❕ p)) =\n      eq_of_heq (edist f f)\n        (Heq.of_heq edist (_ :\n          ∃ m a₁ a₂, m ∈ Set.univ ×> f.toUniformSpace ≤ fun (x b : WithLp p (a × β)) ↦ edist f d b / p)) :=\n  by sorry ", "theorem aux.16978684658481381994 (p : ENNReal) (γ : NormedAddGroup α) (β : NullMeasurablepace α)\n    (hm : μ + NormedAddGroup.distrDistrib γ p μ = 0) :\n    ↑↑μ ((a : α) ↦ dist (f.1 a) (f.1 a) + dist (f (a.1), f.2 a)) = ENNReal.ofReal Infinity + 1 := by sorry ", "theorem aux.2539491861360865569 (p : ENNReal) (α : Type u_2) [PseudoEMetricSpace α] (β : Type u_3)\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) :\n    let t : Nonempty (UniformSpace (@instProdInstEdist α β inst) × (uniformSpace α ⨳ uniformSpace β)) :=\n      Nonempty.intro ({ inst := instProd ?_ ?_ × instFunctor2 β instInst₂Ineq × instInst₂IneqC } ≃\n              (uniformSpace α ⨳ uniformSpace β) ≃ᵐ β)\n        fun (c : UniformSpace α ⨳ UniformSpace β) (f : WithLp p α ⹗ β) ↦\n        max ((edist (Nat.party c) f) + Edist.uniformity (Edist.uniformMaps (instProdProdEdist α inst) f))\n          ((maxEma C (edist Edist.uniformMaps).equiv\n              (UniformSpace.edist\n                (((ih f)))\n                ((trivialEquiv (UniformSpace.uniformity α) 𝓕).toEquiv ((trivialEquiv E 𝔸)) ≪ₕ ⊤))) +\n            (Edist.cP (r f)) * (d (s i, s j)) + d (f i, f j)))) =\n  let t : Nonempty (UniformSpace α ⨳ UniformSpace β) :=\n    Nonempty.intro {{ inst := instPropsLpNonneg p (α × β), left := ((Edist.edist (instProd α inst ⹗ instBNN✝) none p f));\n          right := HEquiv.symm trivialEquiv.trivial } ≃\n          (uniformSpace α ⨳ uniformSpace β) ≃ 𝓕,\n  f →* (Equiv.refl _) × Unit ;\n  f →* (Equiv.refl InstProdPseudoedmetricSpace ⨟ InstProdPseudoEdistFunLift.uniformSpaceFun.uniformSpace ⊓\n            PseudoEMetricSpaceEᵒᵖ (f + g) :=\n        f ) \\≤ 3 2 + NilUnits.instSemiring ×\n          (Max heq (Max heq zero xy) +\n            (PotLift.prod\n                (PotLift.prod f m\n                  ((Module.addGroupLHom\n                            ((CotangentBundle.totalDeriv TA TI ξ ξ φ (f‖ f + g‖ _)) r ((fun a => 1) a)))) l\n                    l h ≥ h_) +\n              (Hₗ := MathlibRaw.Std.Tctic.$auto 2 (Equiv.toProd ↓((fun i → T 1 i) ∘ InstProdCompl.swap1)) ∈ 𝕜 • B • a)\n                  (Equiv.injective\n                    ⊨ (HMul.of (Con.sInf r ((s j))⁻¹).toCon\n                      (s i = t j) ∧ (t j /* Σ ... [ -3 a ● a *= HMul.of HMul.mul] -/ 0 /* *=\n                              e 1 • (Sigma.snd t fun . . .*. (0 • e 1) • H.snd)) ≥\n                          0))) ≤\n                    3 ) (Equiv.refl _)) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {ƒ : α → β} {a b c : α},  fourier a = fourier b → a = b → ƒ a = ƒ b := by\n  sorry ", "theorem aux.5325525219302747934 (p : ENNReal) {α : Type u_2} {β : Type u_3} [PseudoEMetricSpace α]\n    [PseudoEMetricSpace β] (f : WithLp p (α × β)) = fun (x : α) (y : β) ↦ 0 := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β} (a : PartialEquiv.IsImage e s t),\n  PartialEquiv.target e ∩ ↑(PartialEquiv.symm e) ⁻¹' s = PartialEquiv.target e ∩ t)", "theorem": "theorem PartialEquiv.IsImage.symm_preimage_eq :\n    (∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β} (a : PartialEquiv.IsImage e s t),\n      PartialEquiv.target e ∩ ↑(PartialEquiv.symm e) ⁻¹' s = PartialEquiv.target e ∩ t) :=\n  by sorry", "name": "PartialEquiv.IsImage.symm_preimage_eq", "lemma-type": "∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β},\n  PartialEquiv.IsImage (PartialEquiv.symm e) t s ↔ PartialEquiv.IsImage e s t", "lemma": "theorem PartialEquiv.IsImage.symm_iff :\n    ∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β} {s : Set α} {t : Set β},\n      PartialEquiv.IsImage (PartialEquiv.symm e) t s ↔ PartialEquiv.IsImage e s t :=\n  by sorry", "doc_string": "**Alias** of the forward direction of `PartialEquiv.IsImage.iff_symm_preimage_eq`.", "generated": ["theorem SetEq.symm : ∀ {α : Type u} {s t : Set α}, s = t → t = s := by sorry ", "theorem congr_arg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem PartialEquiv.symm_preimage_eq :\n    ∀ {α : Type u_1} {β : Type u_2} (e : PartialEquiv α β) (b : β),\n      (PartialEquiv.symm e) ↑b = ↑(jiff (b ∈ PartialEquiv.target e) (e _ b = b)) :=\n  by sadly  }", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem And.right_comm : ∀ {a b c : Prop}, a ∧ (b ∧ c) = a ∧ c ∧ b := by sorry ", "theorem LE.le.sub_left : ∀ {α : Type u} {m → α} [inst : SetOpposites 1 {p q}); 0 ≤ m → max a p ≠ a → max a p = a :=\n  by sorry "]}
{"theorem-type": "(∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {Y : C} {f : (a : J) → X ⟶ Y}\n  [inst_1 : Nonempty J] (s : CategoryTheory.Limits.Cotrident f) {W : C} {k : CategoryTheory.Limits.Cocone.pt s ⟶ W}\n  {l : CategoryTheory.Limits.Cocone.pt s ⟶ W}\n  (h :\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) k =\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) l)\n  (j : CategoryTheory.Limits.WalkingParallelFamily J),\n  CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.Cocone.ι s).app j) k =\n    CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.Cocone.ι s).app j) l)", "theorem": "theorem CategoryTheory.Limits.Cotrident.coequalizer_ext :\n    (∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : C} {Y : C} {f : (a : J) → X ⟶ Y}\n      [inst_1 : Nonempty J] (s : CategoryTheory.Limits.Cotrident f) {W : C} {k : CategoryTheory.Limits.Cocone.pt s ⟶ W}\n      {l : CategoryTheory.Limits.Cocone.pt s ⟶ W}\n      (h :\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) k =\n          CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) l)\n      (j : CategoryTheory.Limits.WalkingParallelFamily J),\n      CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.Cocone.ι s).app j) k =\n        CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.Cocone.ι s).app j) l) :=\n  by sorry", "name": "CategoryTheory.Limits.Cotrident.coequalizer_ext", "lemma-type": "{J : Type w} →\n  {C : Type u} →\n    [CategoryTheory.Category.{v, u} C] →\n      {X : C} →\n        {Y : C} →\n          {f : (a : J) → X ⟶ Y} →\n            [Nonempty J] →\n              (s : CategoryTheory.Limits.Cotrident f) →\n                {W : C} →\n                  {k : CategoryTheory.Limits.Cocone.pt s ⟶ W} →\n                    {l : CategoryTheory.Limits.Cocone.pt s ⟶ W} →\n                      (h :\n                          CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) k =\n                            CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) l) →\n                        (x : CategoryTheory.Limits.WalkingParallelFamily J) →\n                          (_ : Unit) →\n                            (CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n                                  (CategoryTheory.CategoryStruct.comp\n                                    ((CategoryTheory.Limits.Cocone.ι s).app\n                                      CategoryTheory.Limits.WalkingParallelFamily.one)\n                                    k) =\n                                CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n                                  (CategoryTheory.CategoryStruct.comp\n                                    ((CategoryTheory.Limits.Cocone.ι s).app\n                                      CategoryTheory.Limits.WalkingParallelFamily.one)\n                                    l)) =\n                              (CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n                                  (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) l) =\n                                CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n                                  (CategoryTheory.CategoryStruct.comp\n                                    ((CategoryTheory.Limits.Cocone.ι s).app\n                                      CategoryTheory.Limits.WalkingParallelFamily.one)\n                                    l))", "lemma": "theorem aux.11704212748963676110 {J : Type w} {C : Type u} [CategoryTheory.Category.{v, u} C] {X : C} {Y : C}\n    {f : (a : J) → X ⟶ Y} [Nonempty J] (s : CategoryTheory.Limits.Cotrident f) {W : C}\n    {k : CategoryTheory.Limits.Cocone.pt s ⟶ W} {l : CategoryTheory.Limits.Cocone.pt s ⟶ W}\n    (h :\n      CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) k =\n        CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) l)\n    (x : CategoryTheory.Limits.WalkingParallelFamily J) (_ : Unit) :\n    (CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n          (CategoryTheory.CategoryStruct.comp\n            ((CategoryTheory.Limits.Cocone.ι s).app CategoryTheory.Limits.WalkingParallelFamily.one) k) =\n        CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n          (CategoryTheory.CategoryStruct.comp\n            ((CategoryTheory.Limits.Cocone.ι s).app CategoryTheory.Limits.WalkingParallelFamily.one) l)) =\n      (CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n          (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cotrident.π s) l) =\n        CategoryTheory.CategoryStruct.comp (f (Classical.arbitrary J))\n          (CategoryTheory.CategoryStruct.comp\n            ((CategoryTheory.Limits.Cocone.ι s).app CategoryTheory.Limits.WalkingParallelFamily.one) l)) :=\n  by sorry", "doc_string": "To check whether two maps are coequalized by both maps of a cotrident, it suffices to check it\nfor the second map ", "generated": ["Theorem CategoryTheory.Limits.Cofork.condition :\n    ∀ {J : Type u₁} {C : Type u₂} [inst : CategoryTheory.Category.{v₁, u₂} C] {X Y : C}\n      [inst_1 : CategoryTheory.Limits.HasCoproduct X Y]\n      (f : X ⟶ Y) {Z : C} (k : C) ((w : X ⟶ k ⟶ Y) (b : Z ⟶ k ⟶ X)),\n      CategoryTheory.CategoryStruct.comp X.ι b ∘ CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Colex.symm w) f =\n        CategoryTheory.CategoryStruct.comp k ((CategoryTheory.Limits.Cofork.ι f).right) :=\n  by sorry ", "show\n    ((CategoryTheory.Limits.Cocone.ι s).app { val := ((j)),\n                hom :=\n                  (((to_prefunctor { obj := ((j)), hom := None } ((CategoryTheory.Limits.WalkingParallelFamily.map\n                    (CategoryTheory.eqToHom ((CategoryTheory.Limits.Cofork.isLimit t).apply j)))).congr))) } ≫\n            k =\n          (CategoryTheory.Limits.Cocone.ι t) ≫ l :=\n      by sorry ", "rule_eq : Eq ≤ Eq := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), a = a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Iff.trans : ∀ {a b c : Prop}, (a ↔ b) → (b ↔ c) → (a ↔ c) := by sorry "]}
{"theorem-type": "(Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop)", "theorem": "theorem FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop :\n    (Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop) := by\n  sorry", "name": "FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop", "lemma-type": "(m : ℕ) →\n  (n : ℕ) →\n    (hmn : m ≤ n) →\n      (a : (n : ℕ) × Composition n) →\n        (ha : a ∈ (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) m) →\n          ∀ (i : ℕ) (a : i < m), (i < n) = True", "lemma": "theorem aux.12773476667148512937 (m : ℕ) (n : ℕ) (hmn : m ≤ n) (a : (n : ℕ) × Composition n)\n    (ha : a ∈ (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) m) :\n    ∀ (i : ℕ) (a : i < m), (i < n) = True := by sorry", "doc_string": "The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. ", "generated": ["theorem Continuous.comp_continuous :\n    ∀ {α : Type u₁} {β : Type u₂} {γ : Type u₃} (f : α → β) {g : β → γ} (hg : Continuous g)\n      (hf : Continuous f), Continuous (g ∘ f) :=\n  by sorry ", "theorem FormalMultilinearSeries.compPartialSumSucc :\n    ∀ {𝕜 : Type u_1} {E' : Type u_5} [u : Ring 𝕜] [y := AddCommMonoid E'] [x : Fin (p + 1)] (q : p),\n      EqOn ⇑(FormalMultilinearSeries.partialSum q (fstSetIndex (Fin.succ x) x))\n        (⇑(FormalMultilinearSeries.<| Fin.succ p, Finset.cons 1 Fin.succ p r x hc rf))\n        (p + (n + 1 + fun r x H x x ↦ x)) :=\n  by sorry ", "theorem tendstoFinsetMul_tsum :\n    ∀ {x : Set ℕ → ℝ},\n      Filter.Tendsto (fun n => Finset.sum (Finset.tail (Nat.antidiagonal n)) fun h => FormalMultilinearSeries.smulRight' x 1 n ↑h)\n        (Filter.atTop) Filter.atTop :=\n  by sorry ", "hints:\n```lean\ntheorem tendstoIn_add_inv_atTop :\n    (∀ {𝔸 : Type u_1} {𝕜 : Type u_2} [inst : NormedField 𝕜] [inst_1 : NormedAddCommGroup 𝔸]\n      [inst_2 : NormedSpace 𝕜 𝔸] {x : 𝔸},\n      Filter.TendstoIn (Prod.snd 𝕜 𝔸) Filter.atTop = Filter.tendsto (fun (z : 𝕜) ↦ z⁻¹ += x) Filter.atTop) :=\n  by sorry\n``` [/INST] theorem FormalMultilinearSeries.tendsto_add_inv :\n    ∀ {🕜 : Type u_1} {E : Type u_2} {G : Type u_4} {𝓢 : 𝓐(𝕜, E, F)} [inst : CompleteSpace E]\n      [inst_1 : IsAlgebraOre F(E)] {\\φ : E →𝄬(𝕜, E)} {y : G} (x : f φ y)\n      [inst : AddInvertibleM (φ y)] (p : PFunc σ E 𝕜 →L[𝕜] 𝓃 fun x => f φ (a 1 x)),\n      Filter.Tendsto ∅ p Filter.atTop (nhds x) :=\n  by sorry ", "theorem norm_zero' : ∀ {E : Type u_6} [inst : NormedAddGroup E], ‖0‖ = 0 := by sorry ", "theorem Finset.not_true : ∀ (S : Finset Bool), ∀ (y : Bool) (a : y ∉ S), y ≠ true := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux : ∀ (n : ℕ), FormalMultilinearSeries.compPartialSum targetF L n = FormalMultilinearSeries.compPartialSum targetF\n      (HasEquivarTarget (ι₀ A) A _ (LinearIsometricEquivForm ℂ A)).symm (Continuous MultilinearMap.curryLeft ℂ\n  Units.negOne n) ⇑A =\n    f n (MultilinearMap.equivCompFInsomeMultilinearMapEquivA'F.symm '' f n) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type ua} [inst : UniformSpace α],\n  (Filter.lift' (uniformity α) fun (s : Set (α × α)) ↦ compRel s (compRel s s)) ≤ uniformity α)", "theorem": "theorem comp_le_uniformity3 :\n    (∀ {α : Type ua} [inst : UniformSpace α],\n      (Filter.lift' (uniformity α) fun (s : Set (α × α)) ↦ compRel s (compRel s s)) ≤ uniformity α) :=\n  by sorry", "name": "comp_le_uniformity3", "lemma-type": "{α : Type ua} →\n  [UniformSpace α] →\n    (x : Set (α × α)) →\n      (h : x ∈ uniformity α) →\n        (_t : Set (α × α)) →\n          (htU : _t ∈ uniformity α) →\n            (ht : compRel _t (compRel _t _t) ⊆ x) →\n              compRel _t (compRel _t _t) ∈ Filter.lift' (uniformity α) fun (s : Set (α × α)) ↦ compRel s (compRel s s)", "lemma": "theorem aux.3369805983550297876 {α : Type ua} [UniformSpace α] (x : Set (α × α)) (h : x ∈ uniformity α)\n    (_t : Set (α × α)) (htU : _t ∈ uniformity α) (ht : compRel _t (compRel _t _t) ⊆ x) :\n    compRel _t (compRel _t _t) ∈ Filter.lift' (uniformity α) fun (s : Set (α × α)) ↦ compRel s (compRel s s) := by sorry", "doc_string": "See also `comp3_mem_uniformity`. ", "generated": ["theorem Filter.hasBasis_eqOn.1 :\n    ∀ {α : Type u_2} {F : Type u_6} [u_6 : UniformSpace α] [inst : Filter.IsCountablyGenerated (uniformity α)],\n      u_6 → idrel = uniformFilter idRel → idrel i (comp id id i ) f :=\n  by sorry ", "theorem aux.13201070564647868064 {α : Type ua} [uniformSpaceOn α inst] :\n    (Filter.lift' (uniformity α) fun (t : Sets α × Sets α) ↦ compRel (eSubsetsUniformity α ⊓ t.1) ⊓ ccompRel t.2\n            (compRel s (compRel s s))) =\n      filterEagleFinset (fun (i : α × α) ↦ funFilterAt (CompProd.swap i) (compRel s ⊓ homRel e))\n              (bident_le (Equiv.swapSZR α s e) cfun ⊔ ccompRel ∘ filterAtBidentsBident L ⊔ id' (rfl e)) :=\n  by sorry ", "answer:\n\\\\_a : α := by sorry ", "theorem aux.15474907447901842753 {α : Type ua} [UniformSpace α] (s : Set (α × α)) :\n    6 * 1 ⊤ = 2 + 4 + 7 := by sorry ", "theorem aux.15325304195126261507 {α : Type ua} [UniformSpace α] (y : Fun likeObviouslyLike x ↑uphy))\n    [UniformContinuousFun α\n      ↑(Function.swap_partialCompRight\n          { toFun := partialBijectiveInv (functionFieldAux Hy) HyInv (isBirational_structFun HH)),\n          TtopologicalSpace (↑fun H => ↑(Function.swap_isIso (↑uphy_s))) ⊢\n          tpltop))\n    (f : ↑(Function.swap_partialCompRight struct_hom structFun_inv)) : HHy { upHY => hx := (* f).2 } f := by sorry ", "theorem aux.1673773916 :\n    ∀ {α : Type ua} [inst : UniformSpace α], uniformity α = filterAt α inst (⨅ x, ⊥) := by sorry ", "**Question:** Can you prove the second equation in the above Lean 4 theorem?\n\n**Answer:** ∀ (t : Set (Function α α)), (t ∈ Filter.lift' (uniformity α)) ↔ (∃ x, Filter.setsOfQuotQuotRel (s ∩ t) x) :=\n  by sorry ", "theorem le_trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o y (y - x)) = ‖x‖ / ‖y‖)", "theorem": "theorem Orientation.tan_oangle_sub_right_of_oangle_eq_pi_div_two :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o y (y - x)) = ‖x‖ / ‖y‖) :=\n  by sorry", "name": "Orientation.tan_oangle_sub_right_of_oangle_eq_pi_div_two", "lemma-type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  ⟪x, y⟫_ℝ = 0 → Real.tan (InnerProductGeometry.angle x (x - y)) = ‖y‖ / ‖x‖", "lemma": "theorem InnerProductGeometry.tan_angle_sub_of_inner_eq_zero :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n      ⟪x, y⟫_ℝ = 0 → Real.tan (InnerProductGeometry.angle x (x - y)) = ‖y‖ / ‖x‖ :=\n  by sorry", "doc_string": "The tangent of an angle in a right-angled triangle as a ratio of sides, version subtracting\nvectors. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem neg_inj : ∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = -b ↔ a = b := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.3497113375198444236 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n    (h : Orientation.oangle o x y = ↑(Real.pi / 2)) :\n    (Real.Angle.tan ↑(InnerProductGeometry.angle y (y - x)) = |‖x‖ / ‖y‖|) =\n      (Real.tan (InnerProductGeometry.angle y (y - x)) = |‖x‖ / ‖y‖|) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem orientedAngle_neg_right_eq_pi_div_two :", "theorem Real.angle_sub_eq_arctan_of_pos :\n    ∀ {x y : ℝ} {a : ℝ} (h : 0 < x), Real.Angle.tan (Orientation.oangle Complex.orientation x (x - a) ×° Orientation.rightAngleOriented.o) = ↑(a / x) := by\n  sorry ", "theorem eqDivZero : MonoidHom.eq_zero_imp_eq'One_neg_ker' :\n    ∀ {α : Type u} {β : Type v} [inst : DivInvZeroMonoid α] [inst_1 : SubTractionMonoid β]\n      [inst_2 : ConcreteringHomClass α α (Multiples (SubtractionMonoid.carrierSubtraction (α => V))) invSubtraction]\n      [inst_3 : MulAction.IsSolidProp α mvl] (G : MulAction α β) {b : β} (hab : b = 0) (hy : -0 = y), -G b y ≠ 0 :=\n  by sorry "]}
{"theorem-type": "(∀ {X : Type u} {ι : Type u_1} [inst : TopologicalSpace X] {s : Set X} {b : Set ι} {c : (a : ι) → Set X}\n  (hs : IsLindelof s) (hc₁ : ∀ (i : ι) (a : i ∈ b), IsOpen (c i)) (hc₂ : s ⊆ ⋃ i ∈ b, c i),\n  ∃ b', (b' ⊆ b) ∧ ((Set.Countable b') ∧ (s ⊆ ⋃ i ∈ b', c i)))", "theorem": "theorem IsLindelof.elim_countable_subcover_image :\n    (∀ {X : Type u} {ι : Type u_1} [inst : TopologicalSpace X] {s : Set X} {b : Set ι} {c : (a : ι) → Set X}\n      (hs : IsLindelof s) (hc₁ : ∀ (i : ι) (a : i ∈ b), IsOpen (c i)) (hc₂ : s ⊆ ⋃ i ∈ b, c i),\n      ∃ b', (b' ⊆ b) ∧ ((Set.Countable b') ∧ (s ⊆ ⋃ i ∈ b', c i))) :=\n  by sorry", "name": "IsLindelof.elim_countable_subcover_image", "lemma-type": "{X : Type u} →\n  {ι : Type u_1} →\n    [TopologicalSpace X] →\n      {s : Set X} →\n        {b : Set ι} →\n          {c : (a : ι) → Set X} →\n            (hs : IsLindelof s) →\n              (hc₁ : ∀ (i : ι) (a : i ∈ b), IsOpen (c i)) →\n                (hc₂ : s ⊆ ⋃ i ∈ b, c i) →\n                  (d : Set ↑b) → (hd : (Set.Countable d) ∧ (s ⊆ ⋃ i ∈ d, c ↑i)) → (Subtype.val '' d ⊆ b) = True", "lemma": "theorem aux.1293278935091797928 {X : Type u} {ι : Type u_1} [TopologicalSpace X] {s : Set X} {b : Set ι}\n    {c : (a : ι) → Set X} (hs : IsLindelof s) (hc₁ : ∀ (i : ι) (a : i ∈ b), IsOpen (c i)) (hc₂ : s ⊆ ⋃ i ∈ b, c i)\n    (d : Set ↑b) (hd : (Set.Countable d) ∧ (s ⊆ ⋃ i ∈ d, c ↑i)) : (Subtype.val '' d ⊆ b) = True := by sorry", "doc_string": "For every open cover of a Lindelöf set, there exists a countable subcover. ", "generated": ["theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem implies_congr := and_iff_constraint ; congrArg (IsLindelof s) (IsLindelof.elim_countable_subcover_image hs hc₁ hc₂) :=\n  by sorry ", "theorem subsingleton : ∀ {α : Sort u}, 1 > α := by sorry", "theorem filter_univ : ∀ {α : Type u} {p : α → Prop} [inst : DecidablePred p], Filter.filter p Filter.univ = Set.univ :=\n  by sorry ", "theorem aux.18548984397741914116 {X : Type u} {ι : Type u_1} [TopologicalSpace X] {s : Set X} {b : Set ι}\n    {c : (a : ι) → Set X} (hs : IsLindelof s) (hc₁ : ∀ (i : ι) (a : i ∈ b), IsOpen (c i)) (hc₂ : s ⊆ ⋃ i ∈ b, c i)\n    (_ys : Set X) : (_ys ∩ Set.pi Set.id {b} ⊆ Set.pi Set.id {b}) = (IsEmpty ((_ys ÷λ b x).Carrier)) := by sorry ", "theorem mem_iInter : ∀ {ι : Sort u_1} {x : α} {s : ι → Set α}, x ∈ ⋂ i, s i ↔ ∀ (n : ι), x ∈ s n := by sorry ", "theorem aux.4009848420402167148 {X : Type u} {ι : Type u_1} [TopologicalSpace X] {s : Set X} {b : Set ι}\n    {c : (a : ι) → Set X} (hs : IsLindelof s)\n    (hc₁ : ∀ (i : ι) (a : i ∈ b), IsOpen (c i)) (hc₂ : s ⊆ ⋃ i ∈ b, c i) (η : (a : ι) → Set X)\n    (x : ∀ (i : ι) (_ : i ∈ b), (Set.Nonempty (c i ∩ s)) ∧ (⋃ el, IsOpen (Set.Ioi el) ∧ IsClosed (Set.Ici el) ⊆ c i))\n    (disji : s ⊆ ⋃ i ∈ b, IsClosed (Set.Ici (id i)) ∩ η i) :\n    ∀ (i : ι) (hi : i ∈ InsertNone b), Id x i ∈ (Set. Nonempty x) i := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {X : Type u_3} {Y : Type u_4} [inst : MeasurableSpace X] [inst_1 : StandardBorelSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : T2Space Y] [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y]\n  [inst_6 : SecondCountableTopology Y] {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f)\n  {s : Set Y}, (MeasurableSet (f ⁻¹' s)) ↔ (MeasurableSet s))", "theorem": "theorem Measurable.measurableSet_preimage_iff_of_surjective :\n    (∀ {X : Type u_3} {Y : Type u_4} [inst : MeasurableSpace X] [inst_1 : StandardBorelSpace X]\n      [inst_2 : TopologicalSpace Y] [inst_3 : T2Space Y] [inst_4 : MeasurableSpace Y] [inst_5 : OpensMeasurableSpace Y]\n      [inst_6 : SecondCountableTopology Y] {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f)\n      {s : Set Y}, (MeasurableSet (f ⁻¹' s)) ↔ (MeasurableSet s)) :=\n  by sorry", "name": "Measurable.measurableSet_preimage_iff_of_surjective", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If `f : X → Y` is a surjective Borel measurable map from a standard Borel space\nto a topological space with second countable topology, then the preimage of a set `s`\nis measurable if and only if the set is measurable.\nOne implication is the definition of measurability, the other one heavily relies on `X` being a\nstandard Borel space. ", "generated": ["theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.9759288081545893558 {X : Type u_3} {Y : Type u_4} [MeasurableSpace X] [StandardBorelSpace X]\n    [TopologicalSpace Y] [T2Space Y] [MeasurableSpace Y] [OpensMeasurableSpace Y] [SecondCountableTopology Y]\n    {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f) {s : Set Y} : ((MeasurableSet s) ∨ False) = True :=\n  by sorry ", "theorem aux.8985253666565531945 {X : Type u_3} {Y : Type u_4} [MeasurableSpace X] [StandardBorelSpace X]\n    [TopologicalSpace Y] [T2Space Y] [MeasurableSpace Y] [OpensMeasurableSpace Y] [SecondCountableTopology Y]\n    {f : (a : X) → Y} (hf : Measurable f) (hsurj : Function.Surjective f) {s : Set Y} :\n    ∋ y y_1 s_1, f ⁻¹' s ⊆ y <| y - 1 + s y_) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem isOpen_preimage_of_injective :\n    ∀ {X : Type u} {Y : Type v} {t : TopologicalSpace X} {s : Set Y} (f : X → Y),\n      IsOpen (s := f '' s) ↔ Set.InjOn f s ∧ s ⊆ funMap f ⁻¹' IsOpen.interior s :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : Sort v} {f g : α → β}, (∀ (a : α), f a = g a) → f = g := by sorry "]}
{"theorem-type": "(∀ {G : Type u} [inst : CategoryTheory.Groupoid G] [inst_1 : IsFreeGroupoid G]\n  (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n  [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)]\n  {a : IsFreeGroupoid.Generators G} {b : IsFreeGroupoid.Generators G} (e : a ⟶ b)\n  (H : e ∈ Quiver.wideSubquiverSymmetrify T a b),\n  IsFreeGroupoid.SpanningTree.loopOfHom T (IsFreeGroupoid.of e) =\n    CategoryTheory.CategoryStruct.id (IsFreeGroupoid.SpanningTree.root' T))", "theorem": "theorem IsFreeGroupoid.SpanningTree.loopOfHom_eq_id :\n    (∀ {G : Type u} [inst : CategoryTheory.Groupoid G] [inst_1 : IsFreeGroupoid G]\n      (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n      [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)]\n      {a : IsFreeGroupoid.Generators G} {b : IsFreeGroupoid.Generators G} (e : a ⟶ b)\n      (H : e ∈ Quiver.wideSubquiverSymmetrify T a b),\n      IsFreeGroupoid.SpanningTree.loopOfHom T (IsFreeGroupoid.of e) =\n        CategoryTheory.CategoryStruct.id (IsFreeGroupoid.SpanningTree.root' T)) :=\n  by sorry", "name": "IsFreeGroupoid.SpanningTree.loopOfHom_eq_id", "lemma-type": "{G : Type u} →\n  [CategoryTheory.Groupoid G] →\n    [IsFreeGroupoid G] →\n      (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) →\n        [Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)] →\n          {a : IsFreeGroupoid.Generators G} →\n            {b : IsFreeGroupoid.Generators G} →\n              (e : a ⟶ b) →\n                (H : e ∈ Quiver.wideSubquiverSymmetrify T a b) →\n                  CategoryTheory.CategoryStruct.comp\n                      (CategoryTheory.CategoryStruct.comp\n                        (IsFreeGroupoid.SpanningTree.treeHom T\n                          (let_fun this := a;\n                          this))\n                        (IsFreeGroupoid.of e))\n                      (CategoryTheory.inv (IsFreeGroupoid.SpanningTree.treeHom T b)) =\n                    CategoryTheory.CategoryStruct.comp\n                      (IsFreeGroupoid.SpanningTree.treeHom T\n                        (let_fun this := a;\n                        this))\n                      (CategoryTheory.CategoryStruct.comp (IsFreeGroupoid.of e)\n                        (CategoryTheory.inv (IsFreeGroupoid.SpanningTree.treeHom T b)))", "lemma": "theorem aux.5332195842105611724 {G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G]\n    (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n    [Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)]\n    {a : IsFreeGroupoid.Generators G} {b : IsFreeGroupoid.Generators G} (e : a ⟶ b)\n    (H : e ∈ Quiver.wideSubquiverSymmetrify T a b) :\n    CategoryTheory.CategoryStruct.comp\n        (CategoryTheory.CategoryStruct.comp\n          (IsFreeGroupoid.SpanningTree.treeHom T\n            (let_fun this := a;\n            this))\n          (IsFreeGroupoid.of e))\n        (CategoryTheory.inv (IsFreeGroupoid.SpanningTree.treeHom T b)) =\n      CategoryTheory.CategoryStruct.comp\n        (IsFreeGroupoid.SpanningTree.treeHom T\n          (let_fun this := a;\n          this))\n        (CategoryTheory.CategoryStruct.comp (IsFreeGroupoid.of e)\n          (CategoryTheory.inv (IsFreeGroupoid.SpanningTree.treeHom T b))) :=\n  by sorry", "doc_string": "Turning an edge in the spanning tree into a loop gives the identity loop. ", "generated": ["question:\n```\n\\let_procedure.to_partition : IsFreeAddGroups.PartitionAdjem.fromProdiGroupId.IsCongruentHom.setPApp x p σ :=\n  HCongr (CategoryTheory.Functor.isEqual ((IsConjRel (fun ↦ [(fun <| _inst : Group ((IsFreeGroupoid.Generators\nisFreeGroupoid).leftInverses x (e₂.symm ((IsFreeGroupoid.Symmetrie x e₃))))) ((fun (b :\n(⩿{a / o / e₃} / ((( fun inst ↕ₛ o₀ e₁) / {x₃ / e₂}))))))⸠ o) (e₂ e₃ ▸ (_funinst : a = b))] / s1)), H.snd)\nSet Theory.MapsFrom f e₂.symm (SetUp.SetUp x fun i => i ↔ { val := ∅ ⊓ ↑e₁, left := True, hi := symm (e₁) ∀,\n    IsFalse ↑e₂ })); a ⟶ b) : s2.snd ∈ Subgroup.commutator [[a, ⟨1, true, o.symm rfl⟩] with BF h] = s2.snd :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Quiver.toPosets.congr :\n    ∀ {V : Type u_1} {inst : IsSymmetrify Q V α Qp} α {V' : Type u_2} {φ : Q ->q = <-- V -> W → V'} :\n      ∀ (val : (a, b), c) = (val' : (a' b), d),\n        α val ⇔ φ ↑val = ↑((val' ▸ $\\homval ((α' => $\\alpha)(φ.trans H, H'))).val) :=\n  by sorry ", "theorem aux.613976096006128147 {G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G]\n    (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G))) {a : IsFreeGroupoid.Generators G}\n    {b : IsFreeGroupoid.Generators G} (e : a ⟶ b) (H : e ∈ Quiver.wideSubquiverSymmetrify T a b) :\n    H →\n      IsFreeGroupoid.SpanningTree.WideMorphism.mk fun (a' : FG.QuitAdhacks.GenerationEquivPath a a')\n        (xpath : List (Computation A α)) ↦ PathFork\n        ((Quotient.hcompId IdAux ((Path.MgId (Path.mapPaths QuotI mM' idpath)) (WideHom A α))) a\n          b))\n        {xpath := ((@ Computation.PathAux.pathAux m_id r p))) } ≠\n        PathFork :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Or.left_comm) : IsFreeGroupoid.WardAtom' a T j :=\n  IsFreeGroupoid.relToWsymmTapatau' T H e h x (IsFreeGroupoid.WardAtom.idRef j h) = e := by sorry ", "theorem aux.8999387362775125722 {G : Type u} [CategoryTheory.Groupoid G] [IsFreeGroupoid G]\n    (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n    [Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)]\n    {a : IsFreeGroupoid.Generators G} {b : IsFreeGroupoid.Generators G} (e : a ⟶ b)\n    (H : e ∈ Quiver.wideSubquiverSymmetrify T a b) :\n    CategoryTheory.CompHom.hom (Cofix.preimage Q F) =\n      ⟦IsFreeGroupoid.SpanningForest.pathsToHoms Q F IsFreeGroupoid.qCofixToFreeAux⟧ :=\n  by sorry ", "theorem congrFun : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (r : ℝ),\n  ⟪(Orientation.rotation o ↑(Real.pi / 2)) x, r • x⟫_ℝ = 0)", "theorem": "theorem Orientation.inner_rotation_pi_div_two_left_smul :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (r : ℝ),\n      ⟪(Orientation.rotation o ↑(Real.pi / 2)) x, r • x⟫_ℝ = 0) :=\n  by sorry", "name": "Orientation.inner_rotation_pi_div_two_left_smul", "lemma-type": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0", "lemma": "theorem MulZeroClass.mul_zero : ∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0 := by sorry", "doc_string": "The inner product between a `π / 2` rotation of a vector and a multiple of that vector is\nzero. ", "generated": ["theorem aux.8269093643039480001 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (r : ℝ) :\n    0 • Real.pi = Real.pi ^ Nat.rawCast 1 * Nat.rawCast 1 := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem Orientation.inner_right_smul :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x y : V) (r : ℝ),\n      ⟪x, r • y⟫_ℝ = r * ⟪x, y⟫_ℝ :=\n  by sorry ", "theorem Orientation.inner_smul_right_antisymm :\n    ∀ {V : Type u_3} [inst : InnerProductSpace ℝ V]\n      (o : AlternatingMap (EuclideanSpace V ℝ) ℝ (InnerProductSpace.Quaternion.norm · ℝ)) (x y : V),\n      ⟪(2 * O O O).toLinearMap x, 𝕜 • y⟫_ℝ * Complex.JI =\n        -(2 * c 1 o + - (2 * O O O).toLinearMap x) ⌣ ⟪y, 𝕜 • x⟫_ℝ + c 2 o) :=\n  by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem aux.14168006237419559622 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (r : ℝ) (v : V)\n    (hid : ∀ (a : v ≠ 0), ‖2 • ⟪O.leftAngle v, x‖/\\(‖v‖ * ‖x‖) = Real.Angle.cos (Orientation.oangle o x v))\n    (hw : ‖2 • ⟪O.leftAngle v, x‖‖ = ‖O.leftAngle v‖ * ‖x‖) : Mathlib.Meta.NormId 2 • 0 = 0 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.5028479026339177880 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (x : V) (r : ℝ) :\n    (({-Orientation.sin (-Orientation.pi / 2))).ker) ((Orientation.rotation (-o)) x) = False := by sorry "]}
{"theorem-type": "(∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} (P : CategoryTheory.Functor Cᵒᵖ (Type w))\n  {S : CategoryTheory.Sieve X} {R : CategoryTheory.Presieve X} (h : S.arrows ≤ R)\n  (hS : CategoryTheory.Presieve.IsSheafFor P S.arrows)\n  (trans :\n    ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄ (a : R f),\n      CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.pullback f S).arrows),\n  CategoryTheory.Presieve.IsSheafFor P R)", "theorem": "theorem CategoryTheory.Presieve.isSheafFor_subsieve_aux :\n    (∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X : C} (P : CategoryTheory.Functor Cᵒᵖ (Type w))\n      {S : CategoryTheory.Sieve X} {R : CategoryTheory.Presieve X} (h : S.arrows ≤ R)\n      (hS : CategoryTheory.Presieve.IsSheafFor P S.arrows)\n      (trans :\n        ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄ (a : R f),\n          CategoryTheory.Presieve.IsSeparatedFor P (CategoryTheory.Sieve.pullback f S).arrows),\n      CategoryTheory.Presieve.IsSheafFor P R) :=\n  by sorry", "name": "CategoryTheory.Presieve.isSheafFor_subsieve_aux", "lemma-type": "∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {P : CategoryTheory.Functor Cᵒᵖ (Type w)} {X : C}\n  {R : CategoryTheory.Presieve X},\n  (CategoryTheory.Presieve.IsSeparatedFor P R ∧\n      ∀ (x : CategoryTheory.Presieve.FamilyOfElements P R),\n        CategoryTheory.Presieve.FamilyOfElements.Compatible x →\n          ∃ t, CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation x t) ↔\n    CategoryTheory.Presieve.IsSheafFor P R", "lemma": "theorem CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :\n    ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {P : CategoryTheory.Functor Cᵒᵖ (Type w)} {X : C}\n      {R : CategoryTheory.Presieve X},\n      (CategoryTheory.Presieve.IsSeparatedFor P R ∧\n          ∀ (x : CategoryTheory.Presieve.FamilyOfElements P R),\n            CategoryTheory.Presieve.FamilyOfElements.Compatible x →\n              ∃ t, CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation x t) ↔\n        CategoryTheory.Presieve.IsSheafFor P R :=\n  by sorry", "doc_string": "If a presieve `R` on `X` has a subsieve `S` such that:\n\n* `P` is a sheaf for `S`.\n* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,\n\nthen `P` is a sheaf for `R`.\n\nThis is closely related to [Elephant] C2.1.6(i).\n", "generated": ["theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem CategoryTheory.Presieve.le_stableGen :\n    ∀ {T : Type u} {C : Type w + u} [inst : CategoryTheory.Category.{max u w, d T}]\n      [inst_1 : CategoryTheory.Sieve X], SieveLike.le ↑R ↑Sieves.stableGen → R ≤ t ⇑ ↑d R :=\n  by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem congrFunc : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem CategoryTheory.Sieve.mem_generate :\n    ∀ {C : Type v₁} [inst : CategoryTheory.Category.{v₁, v₁} C] {P : {S : CategoryTheory.Sieve X : Type v₁) | S ∈ ↑C}]\n      {t X' ω s n ρ s' n' : IgSubType P → IgSubtype.{type (CategoryTheory.Sieve.GiveDiagram P)}} {ε (x : t), Iq (P _ x) : Type v₁} (hu <| i:Ic ε),\n      P (Sigma.fst s i) → [n := ε i] (n'_ih : q n := i (hg : n) (_ : P _ hg _ ∈ P)).P => P ε, P s :=\n  by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry "]}
{"theorem-type": "(∀ {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E] [inst_3 : Nontrivial E]\n  (a : FiniteDimensional.finrank F E = 1), ⊥ = ⊤)", "theorem": "theorem Subalgebra.bot_eq_top_of_finrank_eq_one :\n    (∀ {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E] [inst_3 : Nontrivial E]\n      (a : FiniteDimensional.finrank F E = 1), ⊥ = ⊤) :=\n  by sorry", "name": "Subalgebra.bot_eq_top_of_finrank_eq_one", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a", "lemma": "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry", "doc_string": "**Alias** of the reverse direction of `Subalgebra.bot_eq_top_iff_finrank_eq_one`.", "generated": ["theorem not_false_eq_true : (¬ False) = True := by sorry ", "theorem le_of_bool_cond : Set.Nonempty Fintype F → F → F ⧸ BotLift.ethBound L = L := by sorry ", "theorem aux.9055055388851415410 {F : Type u_1} {E : Type u_2} [Field F] [Ring E] [Algebra F E] [Nontrivial E]\n    (a : FiniteDimensional.finrank F E = 1) (y : E finiteDimensionalEqDvdPosNozero DivisionRing.toDivisionRing F E) :\n    ∀ y ∈ Subalgebra.scope y \\ {0} (Submodule.mul_def' (FiniteDimensional.finrank F E ⟨y, y.eq_one'⟩ (x : E)) y)), y = 0 →\n      0 = 0 = -+ᵥ {{ val := y, property := (((IsUnit.def this)))}} else 0 :=\n  by sorry ", "theorem aux.147888592510204907 {F : Type u_1} {E : Type u_2} [Field F] [Ring E] [Algebra F E] [Nontrivial E] :\n    FiniteDimensional.finrank F E = 1 := by sorry ", "theorem aux.8392051892880279190 {F : Type u_1} {E : Type u_2} [Field F] [Ring E] [Algebra F E] [Nontrivial E]\n    (h : FiniteDimensional.finrank F ↥⊤ = 1) : ⊥ ≠ ⊤ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.5655817592970941354 {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [Algebra F E]\n    [Nontrivial E] {n : ℕ} [Fact (Module.rank F E = n + 1)] {n : ℕ} (ne_zero : fact (Nat.succ n + 1 = FiniteDimensional.finrank F E)) : Nontrivial E := by sorry ", "theorem Subalgebra.bot_eq_linear_span :\n    ∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {B : Subalgebra R A}\n      [inst_3 : Subsemiring.Normal B], ⊥ = Subalgebra.toSubsemiring B = ⊤ :=\n  by sorry "]}
{"theorem-type": "(∀ {n : Type u_2} {R : Type u_4} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n  [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) → R},\n  (Matrix.dotProduct (star v) v = 0) ↔ (v = 0))", "theorem": "theorem Matrix.dotProduct_star_self_eq_zero :\n    (∀ {n : Type u_2} {R : Type u_4} [inst : Fintype n] [inst_1 : PartialOrder R] [inst_2 : NonUnitalRing R]\n      [inst_3 : StarOrderedRing R] [inst_4 : NoZeroDivisors R] {v : (a : n) → R},\n      (Matrix.dotProduct (star v) v = 0) ↔ (v = 0)) :=\n  by sorry", "name": "Matrix.dotProduct_star_self_eq_zero", "lemma-type": "{n : Type u_2} →\n  {R : Type u_4} →\n    [Fintype n] →\n      [PartialOrder R] →\n        [NonUnitalRing R] →\n          [StarOrderedRing R] →\n            [NoZeroDivisors R] → {v : (a : n) → R} → (i : n) → ((star (v i) = 0) ∨ (v i = 0)) = (v i = 0)", "lemma": "theorem aux.6648099314313722671 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} (i : n) : ((star (v i) = 0) ∨ (v i = 0)) = (v i = 0) := by\n  sorry", "doc_string": "Note that this applies to `ℂ` via `Complex.strictOrderedCommRing`. ", "generated": ["theorem aux.7397394873771864283 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R}:\n    ((Matrix.dotProduct (star v) v) ^ Nat.raw castleKind = ↑0) =\n      (Ring.inverse ↑(2 * Matrix.dotProduct (fun (i : n) (j : n) ↦ star v i • v j)) ^ Nat.raw castleKind •\n            1‖ =\n        ‖2‖ • (Ring.inverse ↑(2 * Matrix.dotProduct (fun (i : n) (j : n) ↦ star v i • v j))) ^ Nat.raw castleKind) :\n      (↑0 ^ Nat.raw castleKind = ↑↑0 ^ Nat.raw castleKind * ↑0 ^ Nat.raw castleKind) := by sorry ", "theorem aux.1384773482199466359 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} (i : n) : HEq v v := by sorry ", "theorem aux.5445874968283257181 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [PartialOrder Fintype n]\n    (c : CorsonArism) (R : Type u_4) [Fintype n] [PartialOrder R] [PartialOrder Fintype n] (c : CorsonArism)\n    (H0 : c H0) (e : Corson.Eq Cc)\n    of_1 : (H5 : H5 → (∀ ⦃m₂ : Fin n⦄ ⦃c' : R →+* R →ᶠ[ StarHomClass ℤ r] o h') → False) → I := by sorry ", "theorem aux.8813298121580179931 {n : Type u_2} {R : Type u_4} [Fintype n] [PartialOrder R] [NonUnitalRing R]\n    [StarOrderedRing R] [NoZeroDivisors R] {v : (a : n) → R} : ∇ = Δ := by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem add_zero_eq_zero : ∀ {M : Type u} [inst : AddZeroClass M] (x : M), x + 0 = x := by sorry ", "theorem Matrix.dotProduct.unop : ∀ {H' H :Type -> Matrix m n n) {f i : H' i} [inst : Unop fun i => f i = fₘ[{f' := inst, data := is}], f i = fₘ [{f' := inst, data := is}] := is i';\n  H = H'; true := () ; fₘ[{f' := inst, data := is}] := fₘ'({ f' := inst, data := is }) := fₘ.val'ₚ { f' := inst, data := is };\n  Data[Nat.data.get f].x * Matrix.unop (Matrix.unop f').val i 0 =\n    H = H :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f), ∃ z, Polynomial.IsRoot f z)", "theorem": "theorem Complex.exists_root : (∀ {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f), ∃ z, Polynomial.IsRoot f z) := by\n  sorry", "name": "Complex.exists_root", "lemma-type": "{f : Polynomial ℂ} →\n  (hf : 0 < Polynomial.degree f) →\n    (hf' : ¬(∃ z, Polynomial.IsRoot f z)) → (z : ℂ) → ∀ (z : ℂ), (Polynomial.eval z f)⁻¹ = 0", "lemma": "theorem aux.8642646228564659682 {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f) (hf' : ¬(∃ z, Polynomial.IsRoot f z))\n    (z : ℂ) : ∀ (z : ℂ), (Polynomial.eval z f)⁻¹ = 0 := by sorry", "doc_string": "**Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root ", "generated": ["theorem isRootMultisetDegreeSupport_iff :\n    ∀ {ι : Type u_2} (s : Multiset ι), Multiset.max s = Multiset.prod s = 1 →  IsRootMultisetDegreeSupport (_ : NNReal) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem Complex.abs.map_mul_of_nonzero_right :\n    ∀ {a : ℂ}, Map ⇑ Complex.norm (λz, ‖z * a‖) ‖‖ (*) ‖ a = abs (Complex.norm a * ‖a‖) := by sorry ", "theorem PolynomialAIddEquivCoeCrsur.map_differentiable.match_11 :\n    ∀ {𝕜 : Type u_2} [inst : ContinuousLinearOrderedField 𝕜] {R : Type uR*} [inst_1 : CanonicallyOrderedCommSemiring R] {x : R}\n      {y : 𝕜}, Differentiable 𝕜 fun z => { z1 /* y * x • x + y * z_1 <= z • x * y + z₁ * x₁ + z_2 * z₁₂, z1 » ℛ, max (1 + |y|) } ( ||f| f)\n      y :=\n  by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem aux.11668670691686629738 {f : Polynomial ℂ} (hf : 0 < Polynomial.degree f) : (0 < 0) ∨ (0 = 0) := by sorry ", "theorem Nat.succ_pos' : ∀ (n : ℕ), Nat.Pos (Nat.succ n) := by sorry "]}
{"theorem-type": "(∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : TopCat} (F : TopCat.Presheaf C X),\n  (TopCat.Presheaf.IsSheaf F) ↔ (TopCat.Presheaf.IsSheafPreservesLimitPairwiseIntersections F))", "theorem": "theorem TopCat.Presheaf.isSheaf_iff_isSheafPreservesLimitPairwiseIntersections :\n    (∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X : TopCat} (F : TopCat.Presheaf C X),\n      (TopCat.Presheaf.IsSheaf F) ↔ (TopCat.Presheaf.IsSheafPreservesLimitPairwiseIntersections F)) :=\n  by sorry", "name": "TopCat.Presheaf.isSheaf_iff_isSheafPreservesLimitPairwiseIntersections", "lemma-type": "{C : Type u} →\n  [CategoryTheory.Category.{v, u} C] →\n    {X : TopCat} →\n      (F : TopCat.Presheaf C X) →\n        ∀ (h : TopCat.Presheaf.IsSheafPairwiseIntersections F) ⦃ι : Type w⦄ (U : (a : ι) → TopologicalSpace.Opens ↑X),\n          Nonempty (CategoryTheory.Limits.PreservesLimit (CategoryTheory.Pairwise.diagram U).op F)", "lemma": "theorem aux.14013043701973081055 {C : Type u} [CategoryTheory.Category.{v, u} C] {X : TopCat}\n    (F : TopCat.Presheaf C X) :\n    ∀ (h : TopCat.Presheaf.IsSheafPairwiseIntersections F) ⦃ι : Type w⦄ (U : (a : ι) → TopologicalSpace.Opens ↑X),\n      Nonempty (CategoryTheory.Limits.PreservesLimit (CategoryTheory.Pairwise.diagram U).op F) :=\n  by sorry", "doc_string": "The sheaf condition in terms of an equalizer diagram is equivalent\nto the reformulation in terms of the presheaf preserving the limit of the diagram\nconsisting of the `U i` and `U i ⊓ U j`.\n", "generated": ["theorem aux.7417130205922294062 {C : Type u} [CategoryTheory.Category.{v, u} C] {X : TopCat}\n    (F : TopCat.Presheaf C X) :\n    ∀ ⦃V₁ : TopCat.SheafedSpace C X⦄ ⦃V₂ : TopCat.SheafedSpace C ( TopCat.SheafedSpace.fromPULLBACK V₁ V₂) V₂ 𝔖 V₂⦄\n      (i :\n        CategoryTheory.eqToHom =!\n          (hg : HEq\n            (CategoryTheory.epiCategoryExtention (TopCat.Functor.pullback P pullin j) d\n              ((TopCat.pullbackConeNumeral P pullin j f).w, TopCat.Presheaf.IsSheafPullback).snd),\n            ht)))) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem TopCat.Presheaf.ext' :\n    ∀ {C : Type uᵀ} [inst : CategoryTheory.Category.{v, uᵀ} C] [inst_1 : TopCat C] {P Q : TopCat.Presheaf C X},\n      (∀ x, MapTypeHom P x P.1 ∧ MapTypeHom P.1 x P.2) ↦ P = Q :=\n  by sorry ", "theorem aux.3250492978846183197 {C : Type u} [CategoryTheory.Category.{v, u} C] {X : TopCat}\n    (F : TopCat.Presheaf C X) (Z : C ⥤ TopCat.Presheaf C X) : Function.Injective := by sorry ", "theorem TopCat.Presheaf.isSheafPreservesLimitPreservesSheafConditionPairwiseIntersectionsInfPrimeSpecTop :\n    ∀ {C : Type u} [instinst_1 : CategoryTheory.Category.{vToG, u ToC} C] (U : TopCat.Open subset ↑Set.univ) for\n      C X : TopCat.PresHEap C Unit fun (J : CategoryTheory.Discrete C.objects) × Opens.covers J\n      j (CategoryTheory.Nat.map₂ fun (i : J) → id (CategoryTheory.Discrete.functor U i)), IsInstead of\n        TopCat.PresHeafInExtPrices (homUnit PretopPresheaf.IsSheafPreservesUnit C.top)\n        Functor.toPrefunctor\n        (CategoryTheory.NatTrans.vIn.hom (CategoryTheory.EquivEckmannHassettModelCat.symm (UnitSong.in).symm)) ∈\n      Set.univ :=\n  by sorry ", "theorem TopCat.colimitIsConnected.preserves :\n    ∀ {C : Type u₂} [inst : CategoryTheory.Category.{v₁', v₁ →  v]} {X : TopCat}\n      [h : TopCat.HasColimit (Category.Functor X CategoryTheory.forget₂ C ⋙ P)]\n      [h' : Functor.IsLeftAdjoint P], TopCat.HasColimit ((Category.comp PCategoryTheory.functorToPrefunctor ⋙ Functor.forget (Algebra C D))\n          (CategoryTheory.AlternatingFaceMapComplex (LeftOrd C)) →\n        CategoryTheory.ColimitCat ((CategoryTheory.Whiskering.mapRight\n            ((Category.functor (algebra C D))\n              (Category Theory.Pairwise.isConnected\n\t(fun X => algebras/algebra/Functor.map₂Similarly₂_mapRight [inst]) Y)).down θ ))),\n                              F) :=\n  by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u_1} {q₁ q₂ : Sort u_2}, p₁ = p₂ → (q₁ → q₂) → (p₁ → q₁) = (p₂ → q₂) := by\n  sorry ", "theorem TopCat.Sheaf.TopIsSheaf.IsSheaf.congr' :\n    ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, v₁ >>> u₁} C] [_tC : CategoryTheory.PrefunctorClass (Cᵒᵖ ⥤ E) E]\n      [self : TopCat.Stalk_sheaf P E J] P x Q (f : E ⟶ Q) (n : E ⟶ Q),\n      self = γ P Q (HEq.mp ((congr (TopCat.pure (TopCat.Sheaf ⟨E j, TopCat.pure j⟩ { _h : Nat.PartIso NatIso } as f)))\n          ((Category.Membership.hom f).h))) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} (p : (a : α) → Prop) [inst : DecidablePred p] {s : Finset α},\n  Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = Finset.filter p s)", "theorem": "theorem Finset.subtype_map :\n    (∀ {α : Type u_1} (p : (a : α) → Prop) [inst : DecidablePred p] {s : Finset α},\n      Finset.map (Function.Embedding.subtype p) (Finset.subtype p s) = Finset.filter p s) :=\n  by sorry", "name": "Finset.subtype_map", "lemma-type": "{α : Type u_1} →\n  (p : (a : α) → Prop) →\n    [DecidablePred p] →\n      {s : Finset α} →\n        (x : α) →\n          (a : Subtype p) →\n            (x_0 : Prop) →\n              (x_1 : Type u_1) →\n                (x_2 : x_1) →\n                  (x_3 : x_1) →\n                    ∀ (x_0 : Prop) (x_1 : Type u_1) (x_2 : x_1) (x_3 : x_1), (x_0 ∧ (x_2 = x_3)) ↔ ((x_2 = x_3) ∧ x_0)", "lemma": "theorem aux.5562176310824575381 {α : Type u_1} (p : (a : α) → Prop) [DecidablePred p] {s : Finset α} (x : α)\n    (a : Subtype p) (x_0 : Prop) (x_1 : Type u_1) (x_2 : x_1) (x_3 : x_1) :\n    ∀ (x_0 : Prop) (x_1 : Type u_1) (x_2 : x_1) (x_3 : x_1), (x_0 ∧ (x_2 = x_3)) ↔ ((x_2 = x_3) ∧ x_0) := by sorry", "doc_string": "`s.subtype p` converts back to `s.filter p` with\n`Embedding.subtype`. ", "generated": ["theorem aux.4058243946579016687 {α : Type u_1} (p : (a : α) → Prop) [DecidablePred p] {s : Finset α} :\n    ∀ (x : α),\n      (x ∈ Finset.map' (Function.Embedding.subtype p) (Finset.map (Function.Embedding.subtype p) s).toFinset) ↔\n        (x  p) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem subset_top : ∀ {α : Type u_2} [inst : IsEmpty α] (s : Set α), ↑ emptySet ⊆ s := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem congrArg : ∀ {α beta : Sort u} {x y z : α}, (x = y) → (δ → β) → δ₁ = δ → z = y → δ₁ = z := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem FunLike.ext'_int :\n    ∀ {F : Type l} {P Q : outParam (l → M} fun X => Type) [instF : FunLike F P Q] [inst_1 : InstUniqFun P Q]\n      {F_left : M₁ → HSet M₁} {F_right : M₂ → HSet M₂} {G₁ T₁ : Type n : Prop T₂ : M₂ → N =o[T₁] N T₂ :=\n      ((Finset.mapFn N T₁ →ₗ[ℕ] F₁ × T₂.Finset →ₗ[ℕ] F₂ T₂ →ₗ[ℕ] Q) = TransitionRelated F_left F_right Q) ↔\n        ((FunLike.mapFn F_left T₁ T∘ F_right) T₂ = F₀ ∘ TransitionRelated { toFun := Finset.map F_left T₂, map_cond' := Finset.map_subset_iff } F1) :=\n  by sorry ", "theorem aux.1949063660807878683 {α : Type u_1} (p : (a : α) → Prop) [DecidablePred p] {s : Finset α} {α : Type u_1}\n    (p : (a : α) → Prop) [DecidablePred p] {s : Finset α} (u : Finset (Subtype p))\n    (hm : Finset.map (Equiv.subtypeSubtypeEquiv p) u = s) (cu : (Finset (Subtype p))ᵐ («PreciseFunSet.size p» _)) :\n    And (Finset.map (FunLike.coe.perfect equivFunLikeWithSort) { fst := ((@Subtype.equivSubtype.fromSubtype equiv (σ\n})) }) = And u s :=\n  by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n)))", "theorem": "theorem Nat.exists_prime_lt_and_le_two_mul : (∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n))) :=\n  by sorry", "name": "Nat.exists_prime_lt_and_le_two_mul", "lemma-type": "(n : ℕ) → (hn0 : n ≠ 0) → (h : n ≤ 511) → (h_1 : (lt_or_le 511 n) = (Or.inr h)) → 511 < 521", "lemma": "theorem aux.10693103545299148554 (n : ℕ) (hn0 : n ≠ 0) (h : n ≤ 511) (h_1 : (lt_or_le 511 n) = (Or.inr h)) :\n    511 < 521 := by sorry", "doc_string": "**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large.\n", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem lt_min : ∀ {α : Type u} [inst : LinearOrder α] (m n mn : α), m < n → m ≤ n := by sorry ", "theorem Nat.zero_eq : ∀ (n : ℕ), 0 = n => NAT.eq_zero ↑n := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congr_le_left' : ∀ {χ : Type u_6} {F : Fintype χ} {μs : (a : Nath.Factorization (χ ⟶ ℕ).snd) → NF C}\n    {νs : (a : Nath.Factorization (χ ⟶ ℕ).snd) → NF C} (f : μs → C) (x : Nat.Primes χ),\n    f x ≤ μ_max _f_ndf x → f s < νs M ↔ μ₂ FN : x.factorization =s ∈ ↑↑F → fn x = s else f s ≤ νs M :=\n  by sorry ", "theorem aux.9996193784343270190 (n : ℕ) (hn0 : n ≠ 0) : 0 < (2 * n) + 1 := by sorry ", "theorem aux.2199533301049796688 (n : ℕ) (hn0 : n ≠ 0) : (n ≠ 0) = True := by sorry ", "theorem two_pmul : ∀ {R : Type u} [inst : NonUnitalNonAssocSemiring R] (a : R), cosec 1 ⁑ a • a = a := by sorry "]}
{"theorem-type": "(∀ {α : Type u} [uniformSpace : UniformSpace α] [inst : Filter.IsCountablyGenerated (uniformity α)]\n  (H' : ∀ (u : (a : ℕ) → α) (a : CauchySeq u), ∃ a, Filter.Tendsto u Filter.atTop (nhds a)), CompleteSpace α)", "theorem": "theorem UniformSpace.complete_of_cauchySeq_tendsto :\n    (∀ {α : Type u} [uniformSpace : UniformSpace α] [inst : Filter.IsCountablyGenerated (uniformity α)]\n      (H' : ∀ (u : (a : ℕ) → α) (a : CauchySeq u), ∃ a, Filter.Tendsto u Filter.atTop (nhds a)), CompleteSpace α) :=\n  by sorry", "name": "UniformSpace.complete_of_cauchySeq_tendsto", "lemma-type": "{α : Type u} →\n  [UniformSpace α] →\n    [Filter.IsCountablyGenerated (uniformity α)] →\n      (H' : ∀ (u : (a : ℕ) → α) (a : CauchySeq u), ∃ a, Filter.Tendsto u Filter.atTop (nhds a)) →\n        (U' : (a : ℕ) → Set (α × α)) →\n          (left : Antitone U') →\n            (hU' : ∀ {s : Set (α × α)}, (s ∈ uniformity α) ↔ (∃ i, U' i ⊆ s)) →\n              (u : (a : ℕ) → α) →\n                (hu : ∀ (N : ℕ) (m : ℕ) (n : ℕ) (a : N ≤ m) (a : N ≤ n), (u m, u n) ∈ U' N) →\n                  ∀ (x : Set (α × α)) (hs : x ∈ uniformity α), ∃ i, U' i ⊆ x", "lemma": "theorem aux.8873983768328788270 {α : Type u} [UniformSpace α] [Filter.IsCountablyGenerated (uniformity α)]\n    (H' : ∀ (u : (a : ℕ) → α) (a : CauchySeq u), ∃ a, Filter.Tendsto u Filter.atTop (nhds a))\n    (U' : (a : ℕ) → Set (α × α)) (left : Antitone U') (hU' : ∀ {s : Set (α × α)}, (s ∈ uniformity α) ↔ (∃ i, U' i ⊆ s))\n    (u : (a : ℕ) → α) (hu : ∀ (N : ℕ) (m : ℕ) (n : ℕ) (a : N ≤ m) (a : N ≤ n), (u m, u n) ∈ U' N) :\n    ∀ (x : Set (α × α)) (hs : x ∈ uniformity α), ∃ i, U' i ⊆ x := by sorry", "doc_string": "A sequentially complete uniform space with a countable basis of the uniformity filter is\ncomplete. ", "generated": ["theorem imp_true_iff : ∀ (p : Prop), (p ↔ True) = p := by sorry ", "theorem Filter.NeBot.ne : ∀ {α : Type u} {x : Filter α} [self : Filter.NeBot x] (a : α × α), x ≠ x₀ ≠ x := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst :IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem implies_comm : ∀ {a b c : Prop}, (a → b ↔ c) → (c → a ↔ b) := by sorry ", "theorem tends_compl_singleton_one : Filter.Tendsto Filter.atTop nhds (Set.univ \\ {↑1}) := by sorry ", "theorem aux.9007976423297547877 {α : Type u} [UniformSpace α] [Filter.IsCountablyGenerated (uniformity α)]\n    (H' : ∀ (u : (a : ℕ) → α) (a : CauchySeq u), ∃ a, Filter.Tendsto u Filter.atTop (nhds a)) :\n    ∀ (n : ℕ) (n : Nat.countable) (hnc : Set.nonempty nᶜ), (n = 0) ∨ (n_pos : 0 < n) := by sorry ", "theorem uniformity_hasBasis_eq_seq_tendsto :\n    ∀ {α : Type u} [uniform Space : UniformSpace α] (n : Filter α),\n      Filter.HasBasis n uniformity uniformity_basis_closed :=\n  by sorry ", "theorem filter_ne_bot' : ∀ {α : Type u} (x : α), ↑Unit.unitFilter.map (Function.invfun fun a ↦ ¬x = a) ≠ ⊥ := by\n  sorry "]}
{"theorem-type": "(∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (q : ℚ) (r : ℚ), padicNorm p (q / r) = padicNorm p q / padicNorm p r)", "theorem": "theorem padicNorm.div :\n    (∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (q : ℚ) (r : ℚ), padicNorm p (q / r) = padicNorm p q / padicNorm p r) := by\n  sorry", "name": "padicNorm.div", "lemma-type": "{p : ℕ} → [Fact (Nat.Prime p)] → (q : ℚ) → (r : ℚ) → padicNorm p (q / r) * padicNorm p r = padicNorm p q", "lemma": "theorem aux.3226521574109399313 {p : ℕ} [Fact (Nat.Prime p)] (q : ℚ) (r : ℚ) :\n    padicNorm p (q / r) * padicNorm p r = padicNorm p q := by sorry", "doc_string": "The `p`-adic norm respects division. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "reply_doc : Lean ProperTypeSystem\n\nThe Lean 4 code referred to is below :\n``` lean\ntheorem Real.summable_one_div_pow_rat : (∀ {q : ℚ} {b : ℚ} (b_not_zero : |q| < b), (Summable fun (a : ℤ) ↦ 1 / ↑a ^ q) ∨\n      ¬(Finset.sum (Finset.range b) fun (a : ℤ) ↦ 1 / ↑a ^ q = 1)) :=\n  by sorry\n``` [/INST] reply_doc : Lean ProperTypeSystem\n\nThe Lean 4 code referred to is :\n``` lean\ntheorem Real.summable_one_div_pow_rat : (∀ {q : ℚ} {b : ℚ} (b_not_zero : |q| < b), (Summable fun (a : ℤ) ↦ 1 / ↑a ^ q) ∨\n      ¬(Finset.sum (Finset.range b) fun (a : ℤ) ↦ 1 / ↑a ^ q = 1)) :=\n  by sorry\n``` [/INST] In Lean 4, they have :\n  ⟪x - y, x - y⟫_ℝ / ⟪x, x⟫_ℝ - 2 ⟧_ℝ= ⟪y, x⟫_ℝ / ⟪x, x⟫_ℝ - ⟪y, y⟫_ℝ],\n  ⟪x, x⟫_ℝ * ⟪y, y⟫_ℝ - ⟪x, y⟫_ℝ ^ 2 ≥ 0 :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem div_pos : ∀ {β : Type u_2} [inst : OrderedSemiring β] {a b : β}, 0 < a → 0 < b → 0 < a / b := by sorry ", "theorem inv_mul_cancel : ∀ {G₀ : Type u_1} [inst : GroupWithZero G₀] {a : G₀} (a_1 : a ≠ 0), a⁻¹ * a = 1 := by sorry ", "theorem aux.47401663019833492252 {p : ℕ} [Fact (Nat.Prime p)] (q : ℚ) (r : ℚ) :\n    {_ : ZMod (↑p - 1 := ofNat (↑↑p ^ Int.natPow (r - 1))) × Γₛ} ⊓ ↑↑↑r ^ _^ _ * ↑↑h_0 = {_ : ZMod (↑p ^ Int.natPow (r - 1))\n        × Γₛ, val₀ = ↑π } := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem PadicSeq. padicNorm_zpow : ∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (q : PadicSeq p),\n      PadicNorm.padicNorm (q) (q ^ ↑p) = PadicNorm.padicNorm (q) q ^ ↑p := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {l : Filter α} {p : (a : α) → Prop}\n  (a : ∀ᶠ (s : Set α) in Filter.smallSets l, ∀ (x : α) (a : x ∈ s), p x), ∀ᶠ (x : α) in l, p x)", "theorem": "theorem Filter.Eventually.of_smallSets :\n    (∀ {α : Type u_1} {l : Filter α} {p : (a : α) → Prop}\n      (a : ∀ᶠ (s : Set α) in Filter.smallSets l, ∀ (x : α) (a : x ∈ s), p x), ∀ᶠ (x : α) in l, p x) :=\n  by sorry", "name": "Filter.Eventually.of_smallSets", "lemma-type": "{α : Type u_1} →\n  {l : Filter α} →\n    {p : (a : α) → Prop} →\n      {α : Type u_1} →\n        {l : Filter α} →\n          {p : (a : α) → Prop} → ∀ (s : Set α), (∀ᶠ (x : α) in ⊤, ∀ (a : x ∈ s), p x) = (∀ (x : α) (a : x ∈ s), p x)", "lemma": "theorem aux.2268958487894942419 {α : Type u_1} {l : Filter α} {p : (a : α) → Prop} {α : Type u_1} {l : Filter α}\n    {p : (a : α) → Prop} : ∀ (s : Set α), (∀ᶠ (x : α) in ⊤, ∀ (a : x ∈ s), p x) = (∀ (x : α) (a : x ∈ s), p x) := by\n  sorry", "doc_string": "**Alias** of the forward direction of `Filter.eventually_smallSets_forall`.", "generated": ["theorem eventualizer_map_apply :\n    ∀ {Ω : Type u} {mΩ : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω},\n      Partition.eventually q μ →\n        m ≤ q.set ← measure_le_of_eq_cancel' fun i _i ↦ Set.Ioc m₁ m_{i} → Filter.Eventually m i :=\n  by sorry ", "theorem Iff.mpr_equiv ; false := by sorry ", "theorem Filter.EventuallyEq.con.trans :\n    ∀ {F : Filter X->R α β → p} : Ω :=\n  by sorry ", "theorem aux.5883681582690582080 {α : Type u_1} {l : Filter α} {p : (a : α) → Prop} :\n    (∀ᶠ (a : x : α) in\n        (fun (s : Set E) ↦ Filter.SmallSets (fun (a : α) (_ : a ∈ s) ↦ Subtype.val a)) ⋰\n          {l, fun (x : E) ↦ (_ : ∃ s, ({ val := ((Filter.smallSets l)), property := ({ small := ((this x)), s_fst := simp }) }: Filter α) ⊆ x}),\n      filterAtFun (fun (_ : True) ↦ sinf (nhds filter)), x, True (x ∈ filterAt ε _) x) =\n      True is True\n    (hb : b = x ∈ s <| u b a (nhds fun (k : E) Ϙ a ⇑)) : (False = True) &= (False = False ) := by sorry ", "theorem aux.2786660804077554567 {α : Type u_1} {l : Filter α} {p : (a : α) → Prop} :\n    ∀ (h : ∀ᶠ (s : Set α) in Filter.smallSets l, ∀ (x : α) (a : x ∈ s), p x) (N : Set α)\n      (a : ∃ a, NNReal.mk ⁻¹ a < Filter.map nnl l ⊓ Filter.smallSets l) (Nn := NNReal.mk ⁻¹ a),\n      ∃ x, ∃ (hi : x ∈ N), p x :=\n  by sorry ", "theorem aux.2296062694116617346 {α : Type u_1} {l : Filter α} {p : (a : α) → Prop} {α : Type u_1}\n    {l : Filter α} {p : (a : α) → Prop} :\n    ⋅₀ s ⊓ l = l ⊓ s := by sorry ", "theorem aux.8916591219454891536 {α : Type u_1} {l : Filter α} {p : (a : α) → Prop}\n    (x : ∀ᶠ (x : α) in Filter.smallSets l, p x)) :\n    ∀ (H : ∀ (s : UltimateQuotient.mk SetFilter.IsClosed) (x : UltimateQuotient s) (s' : Set α × Set ↑s' that.ltad)\n          (hsX : ↑X = Ult.mk UltimateQuot.α s)', aVal c H X = ↑rVal),\n      ∀ᶠ y in pure iVal ˣ ×ˢ l ⊗ᵢ ⊤, p (f x * y.1).2 :=\n  by sorry ", "theorem implies_trans : ∀ {a b c : Prop}, a → b → b → c → a → c := by sorry "]}
{"theorem-type": "(∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0),\n  HasFiniteFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 n ⊤)", "theorem": "theorem FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite :\n    (∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n      (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0),\n      HasFiniteFPowerSeriesOnBall (FormalMultilinearSeries.sum p) p 0 n ⊤) :=\n  by sorry", "name": "FormalMultilinearSeries.hasFiniteFPowerSeriesOnBall_of_finite", "lemma-type": "∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ},\n  (∀ (m : ℕ), n ≤ m → p m = 0) → ∀ (x : E), HasSum (fun n => (p n) fun x_1 => x) (FormalMultilinearSeries.sum p x)", "lemma": "theorem FormalMultilinearSeries.hasSum_of_finite :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n      (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ},\n      (∀ (m : ℕ), n ≤ m → p m = 0) →\n        ∀ (x : E), HasSum (fun n => (p n) fun x_1 => x) (FormalMultilinearSeries.sum p x) :=\n  by sorry", "doc_string": "The sum of a finite power series `p` admits `p` as a power series.", "generated": ["theorem HasFiniteFPowerSeriesOnBall.continuous_sum\\_fintype :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n      (cf : ℝ) (pf : ∀ (x : E), ‖cf x‖ ≤ cf * ‖x‖₊) {f : 𝕜 →L[𝕜] E →L[𝕜] F}\n      {r : ENNReal} {r_1 : Nat.ParteniatedSeries m 𝕜 fun _e : 𝔸 => fun n => ‖↑f ^⟨n + 1 : Finₗ 𝕜 𝔸→L fun n => ‖'f ^ n‖₊},\n      HasFiniteHPowerSeriesOnBall (fun r => f ^[[r.toPart ENNReal • m]]) r_1 r →\n      ∃ c, ‖c r_1 →‖↑f ^[r.toPartENNNonInf ×m 1 (r.1 • fun a₀ → ‖a₀ → a + r_1 r₀ a + s b:0↑ : Sum.Zero a])‖ 𝕜 = c :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Metric.r_mem_closedBall₀ :\n    ∀ {R : NNReal} {x : NNReal} {y : NNReal} (h : R < x), closedBall (x := x) R = {z | X(z) ≤ x} := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.3906530659728456222 {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField 𝕜]\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [NormedSpace 𝕜 F]\n    (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0)\n    (m : ℕ × Nonempty (↑m = n)) (_hm : m.1 ≠ ⊤) (hmn : m.1 < n) :\n    ∀ _mL : FormalMultilinearMap 𝕜 E (Fin m.2) →ₗᵥ ℝ = 0, FormalMultilinearMap.liftContinuousInTerminal ⊤ m (↑m) p = 0 :=\n  by sorry ", "theorem zero_le_one :\n    ∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : NoMinOrder α] {a : α},\n      0 ≤ 1 ↔ a = 0 :=\n  by sorry ", "theorem aux.15952215381641163686 {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField 𝕜]\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] [NormedAddCommGroup F] [NormedSpace 𝕜 F]\n    (p : FormalMultilinearSeries 𝕜 E F) {n : ℕ} (hn : ∀ (m : ℕ) (a : n ≤ m), p m = 0) (x : E)\n    (hint : norm ↑x ≤ 1) : (¬(p n = 0)) = True := by sorry ", "theorem Finite.exists_eq_and_forall_rat :\n    ∀ {A : Finset ℕ} [inst : CommSemiring 𝕜],\n      Finite (∀ x, 2²⁻ᵢ < C x) ↔ Exists.exists_prop fun r ↦ A ≠ Ø → HasFiniteAdditiveSubgroup C → r ≠ r₌ ∧ ∀ (i₌ : ℤ), Irred ℚ₌ p r₌ :=\n  by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n  [inst_2 : NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [inst_3 : NormedSpace ℝ E]\n  [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f)\n  {g : (a : X) → E} (hg : Continuous g) (h'g : HasCompactSupport g), MeasureTheory.Integrable fun (x : X) ↦ f x • g x)", "theorem": "theorem MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport :\n    (∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n      [inst_2 : NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [inst_3 : NormedSpace ℝ E]\n      [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f)\n      {g : (a : X) → E} (hg : Continuous g) (h'g : HasCompactSupport g),\n      MeasureTheory.Integrable fun (x : X) ↦ f x • g x) :=\n  by sorry", "name": "MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport", "lemma-type": "{X : Type u_1} →\n  {E : Type u_3} →\n    [MeasurableSpace X] →\n      [TopologicalSpace X] →\n        [NormedAddCommGroup E] →\n          {μ : MeasureTheory.Measure X} →\n            [NormedSpace ℝ E] →\n              [OpensMeasurableSpace X] →\n                [T2Space X] →\n                  {f : (a : X) → ℝ} →\n                    (hf : MeasureTheory.LocallyIntegrable f) →\n                      {g : (a : X) → E} →\n                        (hg : Continuous g) →\n                          (h'g : HasCompactSupport g) →\n                            let K : Set X := tsupport g;\n                            MeasureTheory.Integrable fun (a : X) ↦ Set.indicator K (fun (x : X) ↦ f x) a", "lemma": "theorem aux.13613600174612988920 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [NormedSpace ℝ E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    let K : Set X := tsupport g;\n    MeasureTheory.Integrable fun (a : X) ↦ Set.indicator K (fun (x : X) ↦ f x) a :=\n  by sorry", "doc_string": "If `f` is locally integrable and `g` is continuous with compact support,\nthen `f • g` is integrable. ", "generated": ["theorem congrFunction :\n    ∀ {α : Sort u_1} {β : α → Sort u_2} {f g : (x : α) → β x}, f = g → ∀ (a : α), f a = g a := by sorry ", "theorem hasFDerivWithinAt_bot_of_tendsto :\n    ∀ {a : X} [h : Filter.NeBot l] {u hg u₁ : Y},\n      Filter.Tendsto' U Con ve U₁ → ∀[L : FormalMultilinearSeries ι ↑u ↑(1 + l) X Y h g 1].hasFDerivWithinAt (↑u ·) v a h gᗮ :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.3893867686059411267 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [ NormedSpace ℝ E] [OpensMeasurableSpace X]\n    [T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    (MeasureTheory.LocallyFinite f μ) ↔\n      (∀ ⦃s : Set Wβ⦄ (a : (measurableSet s) ∧_ (↑↑μ s ≠ ⊤)), ∃ y, (IsCompact y) ∧ f ≤ nhds y) :=\n  by sorry ", "theorem aux.8612227681469993590 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [NormedSpace ℝ E] [OpensMeasurableSpace X]\n    [T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E}\n    (hg : Continuous g) (h'g : HasCompactSupport g) (t : Finset X) (htX : ↑↑μ ↑t ≠ ⊤) is_t : ↑t ⊆ t := by sorry ", "theorem IsOpen.measurableSet :\n    ∀ {α : Type u_1} {m : MeasuerTheory.Measure α} (s : Set α), IsOpen s → MeasurableSet s := by sorry ", "theorem MeasureTheory.integrable_cext :\n    ∀ {α : Type u_1} {β : Type u_2} {m : Measurbility α} {μ : OuterMeasure β} (f : ⨆ a μa, (a, μa).cext α β)\n      (a : α) (paθ : a ∈ ⨆ t, Measourable.inter ↑t (MeasureTheory.iUnionᶠ μ t = Set.univ)),\n      Pa θ :=\n  by sorry ", "theorem mul_mul_mul_nonneg :\n    ∀ {R : Type u_1} [inst : LinearOrderedSemiring R] {x y z : R}, 0 ≤ x → 0 ≤ y → 0 ≤ z → (x · y) * z ≥ 0 := by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : Group G] {k : Set G} {p : (x : G) → (a : x ∈ Subgroup.closure k) → Prop}\n  (Hs : ∀ (x : G) (h : x ∈ k), p x (Subgroup.subset_closure h)) (H1 : p 1 (one_mem (Subgroup.closure k)))\n  (Hmul :\n    ∀ (x : G) (hx : x ∈ Subgroup.closure k) (y : G) (hy : y ∈ Subgroup.closure k) (a : p x hx) (a : p y hy),\n      p (x * y) (mul_mem hx hy))\n  (Hinv : ∀ (x : G) (hx : x ∈ Subgroup.closure k) (a : p x hx), p x⁻¹ (inv_mem hx)) {x : G}\n  (hx : x ∈ Subgroup.closure k), p x hx)", "theorem": "theorem Subgroup.closure_induction' :\n    (∀ {G : Type u_1} [inst : Group G] {k : Set G} {p : (x : G) → (a : x ∈ Subgroup.closure k) → Prop}\n      (Hs : ∀ (x : G) (h : x ∈ k), p x (Subgroup.subset_closure h)) (H1 : p 1 (one_mem (Subgroup.closure k)))\n      (Hmul :\n        ∀ (x : G) (hx : x ∈ Subgroup.closure k) (y : G) (hy : y ∈ Subgroup.closure k) (a : p x hx) (a : p y hy),\n          p (x * y) (mul_mem hx hy))\n      (Hinv : ∀ (x : G) (hx : x ∈ Subgroup.closure k) (a : p x hx), p x⁻¹ (inv_mem hx)) {x : G}\n      (hx : x ∈ Subgroup.closure k), p x hx) :=\n  by sorry", "name": "Subgroup.closure_induction'", "lemma-type": "{G : Type u_1} →\n  [Group G] →\n    {k : Set G} →\n      {p : (x : G) → (a : x ∈ Subgroup.closure k) → Prop} →\n        (Hs : ∀ (x : G) (h : x ∈ k), p x (Subgroup.subset_closure h)) →\n          (H1 : p 1 (one_mem (Subgroup.closure k))) →\n            (Hmul :\n                ∀ (x : G) (hx : x ∈ Subgroup.closure k) (y : G) (hy : y ∈ Subgroup.closure k) (a : p x hx) (a : p y hy),\n                  p (x * y) (mul_mem hx hy)) →\n              (Hinv : ∀ (x : G) (hx : x ∈ Subgroup.closure k) (a : p x hx), p x⁻¹ (inv_mem hx)) →\n                {x : G} →\n                  (hx : x ∈ Subgroup.closure k) → ∀ (x : G) (hx : x ∈ k), ∃ (x_1 : x ∈ Subgroup.closure k), p x x_1", "lemma": "theorem aux.5230423903120912735 {G : Type u_1} [Group G] {k : Set G} {p : (x : G) → (a : x ∈ Subgroup.closure k) → Prop}\n    (Hs : ∀ (x : G) (h : x ∈ k), p x (Subgroup.subset_closure h)) (H1 : p 1 (one_mem (Subgroup.closure k)))\n    (Hmul :\n      ∀ (x : G) (hx : x ∈ Subgroup.closure k) (y : G) (hy : y ∈ Subgroup.closure k) (a : p x hx) (a : p y hy),\n        p (x * y) (mul_mem hx hy))\n    (Hinv : ∀ (x : G) (hx : x ∈ Subgroup.closure k) (a : p x hx), p x⁻¹ (inv_mem hx)) {x : G}\n    (hx : x ∈ Subgroup.closure k) : ∀ (x : G) (hx : x ∈ k), ∃ (x_1 : x ∈ Subgroup.closure k), p x x_1 := by sorry", "doc_string": "A dependent version of `Subgroup.closure_induction`.  ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem mul_one : ∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a := by sorry ", "theorem Setoid.syou4 :\n    ∀ {α : Type u_1} {b c e : Subset α a} {q v : ⟦Setoid.refl b ⟧ a}\n      [ca : Setoid.RellMu a] (sba : SymmBiom x) (hs : ⇑sxa, ⇑syx b), cq → edc q v → ea :=\n  by sorry ", "theorem MulOpposite.mul_op : ∀ {A : Typeu} [inst : Mul A] (x y : Aᵐᵐ), Opposite.op (x * y) = Opposite.op y * Opposite.op x :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : Is Symm α r] {a b : α}, r a b → r b a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem Subgroup.sup_subset :\n    ∀ {M : Type u_1} [inst : Monoid M] ⦃F : Submonoid M⦄ {P : Submonoid M} (c : P ≤ F) (hx : F ↪ₘ P.closure),\n      P₀M≃* P  :=\n  by sorry "]}
{"theorem-type": "(∀ {R : Type u_3} [inst : NonAssocSemiring R] (f : (a : ℕ) → (a : ℕ) → R) (n : ℕ),\n  (Finset.sum (Finset.antidiagonal (n + 1)) fun (ij : ℕ × ℕ) ↦ ↑(Nat.choose (n + 1) (ij.1)) * f (ij.1) (ij.2)) =\n    (Finset.sum (Finset.antidiagonal n) fun (ij : ℕ × ℕ) ↦ ↑(Nat.choose n (ij.1)) * f (ij.1) (ij.2 + 1)) +\n      Finset.sum (Finset.antidiagonal n) fun (ij : ℕ × ℕ) ↦ ↑(Nat.choose n (ij.2)) * f (ij.1 + 1) (ij.2))", "theorem": "theorem Finset.sum_antidiagonal_choose_succ_mul :\n    (∀ {R : Type u_3} [inst : NonAssocSemiring R] (f : (a : ℕ) → (a : ℕ) → R) (n : ℕ),\n      (Finset.sum (Finset.antidiagonal (n + 1)) fun (ij : ℕ × ℕ) ↦ ↑(Nat.choose (n + 1) (ij.1)) * f (ij.1) (ij.2)) =\n        (Finset.sum (Finset.antidiagonal n) fun (ij : ℕ × ℕ) ↦ ↑(Nat.choose n (ij.1)) * f (ij.1) (ij.2 + 1)) +\n          Finset.sum (Finset.antidiagonal n) fun (ij : ℕ × ℕ) ↦ ↑(Nat.choose n (ij.2)) * f (ij.1 + 1) (ij.2)) :=\n  by sorry", "name": "Finset.sum_antidiagonal_choose_succ_mul", "lemma-type": "∀ {β : Type u} {α : Type v} {s₁ s₂ : Finset α} {f g : α → β} [inst : AddCommMonoid β],\n  s₁ = s₂ → (∀ x ∈ s₂, f x = g x) → Finset.sum s₁ f = Finset.sum s₂ g", "lemma": "theorem Finset.sum_congr :\n    ∀ {β : Type u} {α : Type v} {s₁ s₂ : Finset α} {f g : α → β} [inst : AddCommMonoid β],\n      s₁ = s₂ → (∀ x ∈ s₂, f x = g x) → Finset.sum s₁ f = Finset.sum s₂ g :=\n  by sorry", "doc_string": "The sum along the antidiagonal of `(n+1).choose i * f i j` can be split into two sums along the\nantidiagonal at rank `n`, respectively of `n.choose i * f i (j+1)` and `n.choose j * f (i+1) j`. ", "generated": ["theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] [inst_1 :MulZeroClass G] {a b : G}, a * b = b * a := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem sub_eq_add_neg : ∀ {α : Type u} [inst : SubtractionCommMonoid α] (a b : α), a - b = a + -b := by sorry ", "theorem aux.2014170554182704054 {R : Type u_3} [NonAssocSemiring R] (f : (a : ℕ) → (a : ℕ) → R) (n : ℕ)\n    (N : ℕ) (n_1 : ℕ) :\n    ((Finset.sum (Finset.antidiagonal n) fun (ij : Finset.antidiagonal n) ↦ ↑(Finset.sum (Nat.smell.cast n ix) f)) =\n        (Finset.sum (Finset.antidiagonal n) fun (e : Fin R) ↦ NNReal.fourierChar c₂ R ↑e.2 * f ↑(e.left) (e.right)) *\n          ↑(Nat.factorial n) / ↑Nat.posNumbers N +\n          Finset.smul (Nat.factorial n) fun (b : ℕ) ↦ Nat.smoothNumbers b ^ n * ↑b / ↑Nat.factorial b) =\n    ((Finset.sum (Finset.antidiagonal n) fun (x : Fin A × Nat) ↦ M x 1) * (Finset.sum Fin.smoothNumbers i) =\n        ((Finset.sliceFourierBasis' R N i)ᶜ Finset.univ\n              + (Finset.sliceFourierBasis'' i (Finset.antidiagonal N) (Finset.zeroFnPose₂ N))ᶜ\n              Finset.univ ‐\n          ↑(n ! * Nat.triNumbers' i) * (Polynomial.eval (UpIcc.mk R i + 1) FonNatI (r₁ q₁ * ξ))⁻¹) (Fin i) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Finset.sum_choose_mul :\n    ∀ {f : DecidableEq β} {g : Fin f → β → Prop} (hg : DecidablePred (g x)),\n      ((Finset.sum Finset.univ fun x => g x) = true) ↔\n        ∃ x s t h t, (Nat.choose x r) * g x t = Finsupp.sum (Finsupp.sumSubset g St h) fun d t => t s :=\n  by sorry ", "theorem Nat.cast_sub : ∀ {R : Type u_1} [inst : Sub : SubSemiring R] [inst_1 : CDRing R] (m p : ℕ), ↑(m - p) = ↑m - ↑p :=\n  by sorry "]}
{"theorem-type": "(∀ {G : Type u_2} [inst : AddGroup G], AddAction.IsPretransitive Gᵃᵒᵖ G)", "theorem": "theorem AddAction.OppositeRegular.isPretransitive :\n    (∀ {G : Type u_2} [inst : AddGroup G], AddAction.IsPretransitive Gᵃᵒᵖ G) := by sorry", "name": "AddAction.OppositeRegular.isPretransitive", "lemma-type": "{G : Type u_2} → [AddGroup G] → (x : G) → (y : G) → x + (-x + y) = y", "lemma": "theorem aux.2585572560606822914 {G : Type u_2} [AddGroup G] (x : G) (y : G) : x + (-x + y) = y := by sorry", "doc_string": "The right regular action of an additive group on itself is transitive.", "generated": ["theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem Set.mem_smul_sets_iff :\n    ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : Module α β] {p : Set) (q r s : Finset) (b : β),\n      b ∈ q +ᵥ s ↔ Set.Nonempty ((q ⊆ ↑(Set.range Quotient.out) ∪ s) ∧ (SmulRel (↑q) ↑r b ↔ (x ∈ s) (∧ {x}), x ∈ q) ) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem AddAction.IsPretransitive.comm :\n    ∀ {X : Type u_10} {G : Group X} [inst : AddAction G X] {s : AddSubgroup G} {w :⟶ V},\n      MonoidIsUnit (⇑w) → IsSMulInvariantSubring vsmul ↑s → IsUnit ↑(gromovHofmanNormalization w s) →\n        Con.toSingleObject fun w => AddAction.IsPretransitive gsmul f (⇑(Con.transvFst (self s) w)) :=\n  by sorry ", "theorem zero_dot : ∀ {J J₂ P : Type u_7} [inst : VectorGroup P (Action J₂ J) (AddEquiv J J_carrier)], 0 • 0 = ↑J 0 :=\n  by sorry ", "theorem Opposite.op_fix_zero_one's : ⌊AddEq fun x x_1 ⇑↪ x (.1) + .+ .(.2.natSymm)⌋⁻¹ = ¾ • .unop(x, x_1) := by\n  sorry ", "theorem Equiv.Perm.addOrderOf._leftInverse_eq :\n    ∀ {α : Type u_30} [inst : AddMonoid α] {p₁ ; p₂ : Equiv.Perm α}, p₁ ≠ 0 → Equiv.TransGenIdRef.Setoid.AddSelf Equiv.Perm p₂ → addOrderOf .{↑p₁} p₂ = addOrderOf .{↑p₁} p₁ := by sorry ", "theorem Set.IsRegularMulOn_iff_fixedPointMul_card :\n    ∀ {α : Type u_2} [inst : RightCancelMonoid α] {a : α}, IsRegularMulOn Units.op a iff FixedPointMulSet (↑a) ⊆ Units.instSingleton := by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\n  [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Γ : Subgroup G} [inst_5 : MeasurableSpace (G ⧸ Γ)]\n  [inst_6 : BorelSpace (G ⧸ Γ)], MeasurableSMul G (G ⧸ Γ))", "theorem": "theorem QuotientGroup.measurableSMul :\n    (∀ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\n      [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Γ : Subgroup G} [inst_5 : MeasurableSpace (G ⧸ Γ)]\n      [inst_6 : BorelSpace (G ⧸ Γ)], MeasurableSMul G (G ⧸ Γ)) :=\n  by sorry", "name": "QuotientGroup.measurableSMul", "lemma-type": "∀ {α : Type u_1} [inst : MeasurableSpace α] {𝕜 : Type u_2} [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : CompleteSpace 𝕜] [inst_3 : MeasurableSpace 𝕜] [inst_4 : BorelSpace 𝕜] {E : Type u_3}\n  [inst_5 : NormedAddCommGroup E] [inst_6 : NormedSpace 𝕜 E] [inst_7 : MeasurableSpace E] [inst_8 : BorelSpace E]\n  {f : α → 𝕜} {c : E}, c ≠ 0 → ((Measurable fun x => f x • c) ↔ Measurable f)", "lemma": "theorem measurable_smul_const :\n    ∀ {α : Type u_1} [inst : MeasurableSpace α] {𝕜 : Type u_2} [inst_1 : NontriviallyNormedField 𝕜]\n      [inst_2 : CompleteSpace 𝕜] [inst_3 : MeasurableSpace 𝕜] [inst_4 : BorelSpace 𝕜] {E : Type u_3}\n      [inst_5 : NormedAddCommGroup E] [inst_6 : NormedSpace 𝕜 E] [inst_7 : MeasurableSpace E] [inst_8 : BorelSpace E]\n      {f : α → 𝕜} {c : E}, c ≠ 0 → ((Measurable fun x => f x • c) ↔ Measurable f) :=\n  by sorry", "doc_string": "Measurability of the action of the topological group `G` on the left-coset space `G/Γ`. ", "generated": ["theorem Equiv.prod_toMeasurable.inj :\n    ∀ {α β : Type u_2} [L : MeasurableSpace α] [K : MeasurableSpace β] (γs : (a : α) → β) (i₀ : ℝ) (U₀ : Set β),\n      π = Equiv.prodToMeasurable (Quotient.mk'' α) π fun a => F(Q a) :=\n  by sorry ", "theorem aux.3365870639166001200 {G : Type u_1} [Group G] [MeasurableSpace G] [TopologicalSpace G] [TopologicalGroup G]\n    [BorelSpace G] {Γ : Subgroup G} [MeasurableSpace (G ⧸ Γ)] [BorelSpace (G ⧸ Γ)] (x : G) :\n    QuotientGroup.mk' =O^{[@instGroupNormalClosure.instTFAE 1]} fun (m : QuotientGroup γᵐˣ) ↦\n      QuotientGroup.out'' { mout’ := (({{ simp [LiftT.eta, OrderDual.compatQuotientDecompAdj]] )}.prop_2)) (x ≤ ↑(QuotientGroup.out m))))) :=\n  by sorry\n``` [/INST] theorem aux.5206579467877020843 {G : Type u_1} [Group G] [MeasurableSpace G] [TopologicalSpace G] [TopologicalGroup G]\n    [BorelSpace G] {Γ : Subgroup G} [MeasurableSpace (G ⧸ Γ)] [BorelSpace (G ⧸ Γ)] (x : G) :\n    NormalClosure G (MulAction.orbitRel γ⟮x⟯) := by sorry ", "theorem AddUnit.one_addGroup :\n    ∀ {α : Type u} [inst : Group α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α], Measurable fun g => g + 1 :=\n  by sorry ", "theorem QuotientGroup.measurableEquiv_mul_left_symm :\n    ∀ {G : Type u} [inst : NormedAddCommGroup G] [inst_1 : Subgroup.NormedAddSubgroup G]\n      [h : CompleteSpace G], Normal Megamorphism.OfGroup G → (Homotopy.toProd φ * fun gopa => -gopa × fun opj => edist - 0 * opj ≤ MeasureTheory.cantorSegment) |Quotient (MonoidHom.range MulEquiv.left_symm.symm)(Homotopy.eq p f p') :=\n  ()", "theorem Quot.sound : ∀ {α : Sort u_1} {s₁ s₂ : Setoid α} {a b : α}, a ≈ b → ⟦a⟯ = ⟦b⟯ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem BorelSpace.core :\n    ∀ {X : Type u_6} [iα : TopologicalSpace.FirstCountableTopology X] [iβ : T4Space X]\n      [iℱ₁³ : SecondCountableTopology ℝ], BorelSpace X π₃ iα fun s => closure s :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n  {b : α} {c : α} (a_1 : a + b < c), a < c - b)", "theorem": "theorem lt_sub_right_of_add_lt :\n    (∀ {α : Type u} [inst : AddGroup α] [inst_1 : LT α]\n      [inst_2 : CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n      {a : α} {b : α} {c : α} (a_1 : a + b < c), a < c - b) :=\n  by sorry", "name": "lt_sub_right_of_add_lt", "lemma-type": "{α : Type u} →\n  [inst : AddGroup α] →\n    [LT α] →\n      [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] →\n        {a : α} →\n          {b : α} →\n            {c : α} →\n              {α : Type u} →\n                [AddGroup α] →\n                  [LT α] →\n                    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦\n                          x < x_1] →\n                      {a : α} → {b : α} → {c : α} → ((a + b < c + -b + b) ↔ (a + b < c)) = ((a + b < c) ↔ (a + b < c))", "lemma": "theorem aux.12844626497060648141 {α : Type u} [inst : AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α}\n    {c : α} {α : Type u} [AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α}\n    {c : α} : ((a + b < c + -b + b) ↔ (a + b < c)) = ((a + b < c) ↔ (a + b < c)) := by sorry", "doc_string": "**Alias** of the reverse direction of `lt_sub_iff_add_lt`.", "generated": ["theorem AddSubgroup.coe_ne_zero :\n    ∀ {R : Type u_1} {L : Type u_2} [inst : StrictOrderedCommRing R] [inst_1 : AddCommLattice L]\n      [inst_2 : Archimedean A F] [inst_3 : MulAction R L] [inst_4 : Nontrivial L] {L' : AddSubgroup L}\n      {K} [inst_5 : Semiring K ] [inst_6 : Algebra R K], AddSubgroup.coeDecomposition L').neg K\n          ({ ((AddSubbun L).neg K) ⇑ i /* h_1 */ }) = ((K_neg A) i) ⇑ f\n        => NitusiveAddAction.IsNoetherian D L (AddSubmonoid.toAddSubmonoid L') :=\n  by sorry ", "theorem aux.514572597041316 {α : Type u} [inst : AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} {c : α} :\n    (a < c - b) ↔ (a < (c + -b) / 2) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.9529575604659181099 {α : Type u} [inst : AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} {c : α} {α : Type u} [AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    {a : α} {b : α} {c : α} : ((a + b < c) ∧ (-b < a)) ↔ ((a + b < c) ∧ (a - -b < 1)) := by sorry ", "theorem add_comm : ∀ {G : Type u_1} [inst : AddCommMagma G] [of_nsmul :↪ₜ G ↥ℕ] [inst_1 : AddRightCancelSemigroup G],\n      ∀ (a b : G), a + b = b + a :=\n  by sorry ", "theorem aux.183246489348594744", "theorem aux.9359956447924976260 {α : Type u} [inst : AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} {c : α} {α : Type u} [AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} {c : α} : (a < c - b) ↔ (a + b < c) := by sorry ", "theorem aux.2965220495866938716 {α : Type u} [inst : AddGroup α] [LT α]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x + x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    {a : α} {b : α} {c : α} : ((a + (b - c) = b) ⊦ (a < (c - (b - c))) ↔ (a < c - b)) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}\n  {k : Set α} (hk : IsCompact k) (h'k : k ⊆ s \\ μ.everywherePosSubset s), ↑↑μ k = 0)", "theorem": "theorem MeasureTheory.Measure.measure_eq_zero_of_subset_diff_everywherePosSubset :\n    (∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α}\n      {k : Set α} (hk : IsCompact k) (h'k : k ⊆ s \\ μ.everywherePosSubset s), ↑↑μ k = 0) :=\n  by sorry", "name": "MeasureTheory.Measure.measure_eq_zero_of_subset_diff_everywherePosSubset", "lemma-type": "∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q = ∃ (h : p'), q' (_ : p)", "lemma": "theorem exists_prop_congr' :\n    ∀ {p p' : Prop} {q q' : p → Prop}, (∀ (h : p), q h ↔ q' h) → ∀ (hp : p ↔ p'), Exists q = ∃ (h : p'), q' (_ : p) :=\n  by sorry", "doc_string": "Any compact set contained in `s \\ μ.everywherePosSubset s` has zero measure. ", "generated": ["theorem IsCompact.induction :\n    ∀ {X : Type u} [inst : TopologicalSpace X] {s : Set X} [self : IsCompact s],\n      Set.Nonempty s → (∀ ∈ s, ∀ {s₂ : Set X} → s₂ ⊆ s → IsCompact s₂) → ∀ s₁ ⊆ s, IsCompact s₁ :=\n  by sorry ", "theorem aux.13625632677336467670 {α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] {μ : MeasureTheory.Measure α}\n    {s : Set α} {k : Set α} (hk : IsCompact k) (h'k : k ⊆ s \\ μ.everywherePosSubset s) :\n    κ '' (s \\ (μ.everywherePosSubset s) \\ k) ⊆ k := by sorry ", "thesis : μ \\ EggCell.everywherePosSubset⁻¹ ▸ᶠ[MeasureTheory.Measure.ae μ] 0 \\ IsCompact.interior hk ⊓ EggCell.everywherePosSubset :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem aux.6073653394932680538 {α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] {α : Type u_1}\n    [TopologicalSpace α] [MeasurableSpace α] : Set.NegNegSet α := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(MeasureTheory.LocallyIntegrableOn zetaKernel₂ (Set.Ioi 0))", "theorem": "theorem locally_integrable_zetaKernel₂ : (MeasureTheory.LocallyIntegrableOn zetaKernel₂ (Set.Ioi 0)) := by sorry", "name": "locally_integrable_zetaKernel₂", "lemma-type": "∀ {α : Type u_1} {G₀ : Type u_3} [inst : DivInvMonoid G₀] [inst_1 : TopologicalSpace G₀] [inst_2 : ContinuousMul G₀]\n  {f : α → G₀} {s : Set α} [inst_3 : TopologicalSpace α],\n  ContinuousOn f s → ∀ (y : G₀), ContinuousOn (fun x => f x / y) s", "lemma": "theorem ContinuousOn.div_const :\n    ∀ {α : Type u_1} {G₀ : Type u_3} [inst : DivInvMonoid G₀] [inst_1 : TopologicalSpace G₀] [inst_2 : ContinuousMul G₀]\n      {f : α → G₀} {s : Set α} [inst_3 : TopologicalSpace α],\n      ContinuousOn f s → ∀ (y : G₀), ContinuousOn (fun x => f x / y) s :=\n  by sorry", "doc_string": "Local integrability of `zetaKernel₂`. ", "generated": ["theorem congrArg : ∀ {α ; β : Sort u} {a b c : α}, (a = b) → (c = a = c) := by sorry ", "theorem aux.8748147385195842237 (a : ℝ) (x : ℝ) (pa : 0 ≤ a) (hxc : x ≤ 0) (ha : a ≤ maxₜ x 0) : 0 < ↑a := by\n  sorry ", "article:\n```lean\ntheorem isLittleO_sigma_map :\n    ∀ {ι : Type u_5} {ν : Type u_6} {ι' : Sort u_1} {ε : Type u_3} [hι : Finite ι]\n      {g : (a : ι) → (a : ε) → ν} {f : (a : ε) → ι'} {b : (a : ι) → ENNReal} {a : ENNReal}\n      {f_hp : MeasureTheory.locallyFiniteFun f} {x : ε} {q : (a : ι) → η} _,\n      a →\n        (∀ (e_1 : (fun (l : η) ↦ Fork.ι q l) b = fun (x : ε) ↦ f (q b) (x)),\n              Asymptotics.IsBigOWith a (fun (e : η) ↦ filterAt f b c (p e))) →\n          a = BoundedConstant.def π → Measurable f → a * FormalMultilinearSeries.'congr _f a hp = _ :=\n  by sorry ", "theorem aux.4493239392170134749 : Set.InjOn Prod.snd Prod.fst := by sorry ", "theorem LT.lt.le : ∀ {α : Type u} [inst : Preorder α] (a b : α), a < b → a ≤ b := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem Filter.Eventually.small_of_locally_integrable_measure :\n    ∀ {β : MeasureTheory.MeasurableSpace β} [inst : MeasureTheory.IsOpenPosMeasure μ],\n      μ = MeasureTheory.Measure.sum LFuns τ => ∃ f g,\n      ∀ ε, ε ≠ ∞ → ContinuousOn f Set.univ → Volume.ProbabilityMeasure μ → ∑ s ∈ l, ↑↑μ ↑z ×ᠣ (f, g) ((x, z.fst s).2, t x (ε • qs s)) ∨ ι x > n0) :=\n  by sorry\n``` [/INST] theorem aux.14285074128821123459 (t : ℕ → UnifIntegrable t' =᷁ P) (n0 : ℕ → FinancialModel.ts) (n_big : ι) (t_mble : Filter.curry Bool Boolᶜ)) → MeasureTheory.Finite ↑↑μ y := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {𝕜 : Type u_1} {n : Type u_3} [inst : IsROrC 𝕜] [inst_1 : Fintype n] [inst_2 : DecidableEq n] {U : Matrix n n 𝕜}\n  (hU : U ∈ Matrix.unitaryGroup n 𝕜), ‖U‖ ≤ 1)", "theorem": "theorem entrywise_sup_norm_bound_of_unitary :\n    (∀ {𝕜 : Type u_1} {n : Type u_3} [inst : IsROrC 𝕜] [inst_1 : Fintype n] [inst_2 : DecidableEq n] {U : Matrix n n 𝕜}\n      (hU : U ∈ Matrix.unitaryGroup n 𝕜), ‖U‖ ≤ 1) :=\n  by sorry", "name": "entrywise_sup_norm_bound_of_unitary", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The entrywise sup norm of a unitary matrix is at most 1. ", "generated": ["theorem Pi.eqNorFlip :\n    ∀ {P Q : (n : Type u_4) → Prop} [hc : DecidableEq n] [i : n] (equ : ∀ (i : n), P i = Q i), P i = Q i := by\n  clear = match Nat.eq_true =[] > Sort True)  ->\n    Term.TerminarNoConfusion true match : True := by sorry ", "theorem entrywise_comp_mem_group :\n    ∀ {G : Type u } {M₁ : Type v} {M₂ : Type w} [inst : StructureGroupoid H₁] [inst_1 : StructureGroupoid H₂]\n      {G₁ : ModelWithCorners ← H₁ G M₁} {G₂ : ModelWithCorners ← H₂ G M₂} {ϵ₁ : (x : M₁) → G},\n      Continuous (Sigma.mk �ẽ) →\n        (∀ (x : M₁), StructureGroupoid.mem ((entrywiseSuffix G₁ ϵ₁ ϱ).symm Γ)) →\n          StructureScribed G₂ M [entrywiseSuffix G₁] (ϵ² := ϋ) :=\n  by sorry ", "theorem Nat.lt.lim_const_self : ∀ {α : Type u_1} [inst : TopologicalSpace α] {p : (x : α) → x ≠ 0} {t : ℕ → Set α}\n    (ht : StrictAnti t) (hnT : ∀ i, ∃ m, t (i + m) ⊆ t i) {n : ℕ}, ⌊p n x⌋₊ m_ne₀ ∈\n      strictMono_limsup_image hnT t p iff (@exists.forall'.cEquiv_fun_fun hTn) m :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem pow_nonneg : ∀ {α : Type u} [inst : OrderedSemiring α] {a b : α}, 0 ≤ a → 0 ≤ b → 0 ≤ a ^ b := by sorry ", "theorem mul_one : ∀ {M : Type u} [inst : MohrOf M] (a : M), a * 1 = ifp (motive := fun (a : M) ↦ a * 1 ≠ 1) a := by\n  sorry ", "theorem div_pow_le_pow_mul_mul :\n    ∀ {α : Type u_2} [inst : DivisionMonoid α] {a b c : α} [inst_1 : Covid19Data.NoDivisisByZero a], c ≤ a ∧ b ∈ Finset.univ → b ≠ 0 → c / b ^ Nat.succ = b * a := by sorry ", "theorem eq_comm : ∀ {alpha : Sort u} {beta : Sort v} (a a' : alpha) (b b' : beta), a = a' ↔ b = b' := by sorry "]}
{"theorem-type": "(∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] (K : CategoryTheory.Coverage C)\n  (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w)),\n  (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L)) P) ↔\n    ((CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) ∧\n      (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P)))", "theorem": "theorem CategoryTheory.Presieve.isSheaf_sup :\n    (∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] (K : CategoryTheory.Coverage C)\n      (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w)),\n      (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C (K ⊔ L)) P) ↔\n        ((CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) ∧\n          (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P))) :=\n  by sorry", "name": "CategoryTheory.Presieve.isSheaf_sup", "lemma-type": "{C : Type u_1} →\n  [CategoryTheory.Category.{u_2, u_1} C] →\n    (K : CategoryTheory.Coverage C) →\n      (L : CategoryTheory.Coverage C) →\n        (P : CategoryTheory.Functor Cᵒᵖ (Type w)) →\n          (h :\n              (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) ∧\n                (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P)) →\n            {X : C} →\n              (R : CategoryTheory.Presieve X) →\n                (hR : R ∈ CategoryTheory.Coverage.covering (K ⊔ L) X) →\n                  (hR_1 : R ∈ CategoryTheory.Coverage.covering L X) →\n                    (h_1 : hR = (Or.inr hR_1)) →\n                      (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P) ↔\n                        (∀ {X : C} (R : CategoryTheory.Presieve X) (a : R ∈ CategoryTheory.Coverage.covering L X),\n                          CategoryTheory.Presieve.IsSheafFor P R)", "lemma": "theorem aux.16009710161038817310 {C : Type u_1} [CategoryTheory.Category.{u_2, u_1} C] (K : CategoryTheory.Coverage C)\n    (L : CategoryTheory.Coverage C) (P : CategoryTheory.Functor Cᵒᵖ (Type w))\n    (h :\n      (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C K) P) ∧\n        (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P))\n    {X : C} (R : CategoryTheory.Presieve X) (hR : R ∈ CategoryTheory.Coverage.covering (K ⊔ L) X)\n    (hR_1 : R ∈ CategoryTheory.Coverage.covering L X) (h_1 : hR = (Or.inr hR_1)) :\n    (CategoryTheory.Presieve.IsSheaf (CategoryTheory.Coverage.toGrothendieck C L) P) ↔\n      (∀ {X : C} (R : CategoryTheory.Presieve X) (a : R ∈ CategoryTheory.Coverage.covering L X),\n        CategoryTheory.Presieve.IsSheafFor P R) :=\n  by sorry", "doc_string": "A presheaf is a sheaf for the Grothendieck topology generated by a union of coverages iff it is a\nsheaf for the Grothendieck topology generated by each coverage separately.\n", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → ß), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem rfl_eq_id : ∀ {C : CmpPartOrd α} (a : C(α, α)), id(a) = rfl(a) := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem Iff.rfl.le : ∀ {a b : Prop}, a ↔ b ⊕ b := by sorry ", "therapy: Eq.mp (congrArg (fun t₂ ↦ tᵗᵒᵖ ⟶ t₂) _pi_intro.choose! t₀) _pi_intro.choose! tᵗᵒᵈ) :=\n  by sorry ", "theorem orchestration𝒜.inhabitedAndInvertibleCategory (CategoryTheory.Coverage C) :\n    ∀ (A : SimpleBicone ((Orthogonal.WalkingParallelPair f)ᵒᵖ ⨿ _)) (α : Preama), TypeMax F P(α.val := True) := by\n  sorry "]}
{"theorem-type": "(padicValNat = Nat.maxPowDiv)", "theorem": "theorem padicValNat.padicValNat_eq_maxPowDiv : (padicValNat = Nat.maxPowDiv) := by sorry", "name": "padicValNat.padicValNat_eq_maxPowDiv", "lemma-type": "∀ {n m : ℕ}, ¬n < m → n ≥ m", "lemma": "theorem Nat.ge_of_not_lt : ∀ {n m : ℕ}, ¬n < m → n ≥ m := by sorry", "doc_string": "Allows for more efficient code for `padicValNat` ", "generated": ["theorem aux.9073547577515712297 : 1 < +Padic.Norm.mkPNat 2 16203 := by sorry ", "theorem of_eq_true : ⇑(eq_self ()) = Eq.ndrec fun {a : Prop} {a_1 : a ∈ Prop} (pa : (FunLike.coe (Eq.mp α' r a) a) = a) ⦃x : a ⦄ (q : x ∈ a) (ra : p = x) : q = x := by\n  sorry ", "theorem aux.3906508964005777222 :\n    Function.Injective Notation.Denumerable.Rec.intCharZeroRpc.denumerableChar := by sorry ", "theorem Nat.cast_toNeZero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] (a : ℕ) (ha : 0 ≠ a), ↑(Nat.succ a) = ↑a + 1 :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem zero_one.le : ∀ {α : Type u_1} [inst : ZeroOneClass α] (a : α), ↑0 ≤ 1 := by sorry ", "theorem le_rfl : ∀ {α : Type u} [inst : Preorder α] [inst_1 : Zero α] [inst_2 : IsMin α 0] {a : α}, a ≤ a := by sorry ", "theorem Nat.coe_zero.symm : ∀ (y : ℕ), Int.natCast 0 = y := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n  (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o x (x + y)) = ‖y‖ / ‖x‖)", "theorem": "theorem Orientation.tan_oangle_add_right_of_oangle_eq_pi_div_two :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V}\n      (h : Orientation.oangle o x y = ↑(Real.pi / 2)), Real.Angle.tan (Orientation.oangle o x (x + y)) = ‖y‖ / ‖x‖) :=\n  by sorry", "name": "Orientation.tan_oangle_add_right_of_oangle_eq_pi_div_two", "lemma-type": "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  ⟪x, y⟫_ℝ = 0 → Real.tan (InnerProductGeometry.angle x (x + y)) = ‖y‖ / ‖x‖", "lemma": "theorem InnerProductGeometry.tan_angle_add_of_inner_eq_zero :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n      ⟪x, y⟫_ℝ = 0 → Real.tan (InnerProductGeometry.angle x (x + y)) = ‖y‖ / ‖x‖ :=\n  by sorry", "doc_string": "The tangent of an angle in a right-angled triangle as a ratio of sides. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Oriented.mk_oangle_eq_pi_div_two_iff_angle_eq_pi_div_two :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Oriented ℝ V (Fin 2)) {w x y : V},\n      Orientation.oangle o w x = ↑Real.pi / 2 ↔ ∠ w x = Real.pi / 2 :=\n  by sorry ", "theorem real_inner_compl_left_eq :\n    ∀ {F : Type u_3} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x : F),\n      ⟪x, x̅⟧_ℝ • ⟪x, x⟫_ℝ = ‖x‖ ^ 2 * ⟪x, x⟫_ℝ :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a b : α}, f₁ = f₂ → a = b → f₁ a = f₂ b := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {φ : α → β} {a₁ a₂ : α}, a₁ = a₂ → φ a₁ = φ a₂ := by sorry ", "theorem Orientation.left_ne_zero_of_oangle_eq_pi_div_two :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [hd2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x y : V},\n      Orientation.oangle o x y = ↑(Real.pi / 2) → x ≠ 0 :=\n  by sorry ", "theorem Real.Angle.tan_toReal : ∀ θ < Real.pi / 2, Real.Angle.tan θ = Real.tan (Real.Angle.toReal θ) / ‖ Real.Angle.sin.angle_sign θ‖ := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y], Isometry Sum.inl)", "theorem": "theorem Metric.isometry_inl :\n    (∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y], Isometry Sum.inl) := by sorry", "name": "Metric.isometry_inl", "lemma-type": "{X : Type u} →\n  {Y : Type v} →\n    [MetricSpace X] →\n      [MetricSpace Y] → ∀ (x : X) (x_1 : X), dist (Sum.inl x) (Sum.inl x_1) = dist (Sum.inl x) (Sum.inl x_1)", "lemma": "theorem aux.3719316288502590629 {X : Type u} {Y : Type v} [MetricSpace X] [MetricSpace Y] :\n    ∀ (x : X) (x_1 : X), dist (Sum.inl x) (Sum.inl x_1) = dist (Sum.inl x) (Sum.inl x_1) := by sorry", "doc_string": "The left injection of a space in a disjoint union is an isometry ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrFun : ∀ {α : Sort u} {β : α → Sort v} {f g : (a : α) → β a}, f = g → ⇑f = ⇑g := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.6465114852029903206 {X : Type u} {Y : Type v} [MetricSpace X] [MetricsOut.MyMitani Y] [Nonempty Y]\n    (x : X) : 1 = ↑1 := by sorry ", "theorem aux.6704109048338142669 {X : Type u} {Y : Type v} [MetricSpace X] [MetricSpace Y] :\n    ((SemilunarMorph WithTop.order)\n        ((Sum.inl fst✗ lfst ⇑Sum.addHom withTopSumToZero first) Sum.inr)).Eq\n      ((Hom fst✗).Continuous ∧\n        Isometry\n          ((SemilunarMorph WithTop.order)\n            (sumLift withTopMap lfst\n              (HomLieSup₀ semilunarMaps Supᵥ.vectorAdd fst (sumIsoWithTop fst.inr lfst).inv 0)))) =\n      True :=\n  by sorry ", "theorem Continuous.injOn :\n    ∀ {X : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace β]\n      [inst_2 : TopologicalSpace γ] {f : X -> β} {s : Set X} {a b : β}, (ContinuousOn (f ∘ Sum.inl) s) →\n      Sum.inl '' s ⊆ f 'a :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : DenselyOrdered α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α]\n  [nonem : Nonempty α] (lo : Finset α) (hi : Finset α) (lo_lt_hi : ∀ (x : α) (a : x ∈ lo) (y : α) (a : y ∈ hi), x < y),\n  ∃ m, (∀ (x : α) (a : x ∈ lo), x < m) ∧ (∀ (y : α) (a : y ∈ hi), m < y))", "theorem": "theorem Order.exists_between_finsets :\n    (∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : DenselyOrdered α] [inst_2 : NoMinOrder α] [inst_3 : NoMaxOrder α]\n      [nonem : Nonempty α] (lo : Finset α) (hi : Finset α)\n      (lo_lt_hi : ∀ (x : α) (a : x ∈ lo) (y : α) (a : y ∈ hi), x < y),\n      ∃ m, (∀ (x : α) (a : x ∈ lo), x < m) ∧ (∀ (y : α) (a : y ∈ hi), m < y)) :=\n  by sorry", "name": "Order.exists_between_finsets", "lemma-type": "{α : Type u_1} →\n  [LinearOrder α] →\n    [DenselyOrdered α] →\n      [NoMinOrder α] →\n        [NoMaxOrder α] →\n          [nonem : Nonempty α] →\n            (lo : Finset α) →\n              (hi : Finset α) →\n                (lo_lt_hi : ∀ (x : α) (a : x ∈ lo) (y : α) (a : y ∈ hi), x < y) →\n                  (m : α) → (hm : Finset.max' lo nlo < m) → (y : α) → (hy : y ∈ hi) → ∃ x, x ∈ hi", "lemma": "theorem aux.18289942210332736730 {α : Type u_1} [LinearOrder α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α]\n    [nonem : Nonempty α] (lo : Finset α) (hi : Finset α) (lo_lt_hi : ∀ (x : α) (a : x ∈ lo) (y : α) (a : y ∈ hi), x < y)\n    (m : α) (hm : Finset.max' lo nlo < m) (y : α) (hy : y ∈ hi) : ∃ x, x ∈ hi := by sorry", "doc_string": "Suppose `α` is a nonempty dense linear order without endpoints, and\nsuppose `lo`, `hi`, are finite subsets with all of `lo` strictly\nbefore `hi`. Then there is an element of `α` strictly between `lo`\nand `hi`. ", "generated": ["theorem exists_dbound_of_subsingleton :\n    ∀ {α : Type u} [inst : PartialOrder α] [pβ : BoundedLattice α] [inst : Subsingleton α],\n      ∃ a, ∀ ⦃b c : α⦄, a < b ↔ a < c :=\n  by sorry ", "theorem Set.toFinset_subset : ∀ {α : Type u} (o : Order.Incompatible o).toSet s t, ↑s ⊆ ↑t₂ := by sorry ", "theorem aux.6551517971000676403 {α : Type u_1} [LinearOrder α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α]\n    [Nonempty α] (lo : Finset α) (hi : Finset α) (lo_lt_hi : ∀ (x : α) (a : x ∈ lo) (y : α) (a : y ∈ hi), x < y) :\n    a * min a s a' ≤ (b * min s s a').2 + (a * (a'.3 ∧ False) - b * (a'.3 ∧ False)).2 a' := by sorry ", "theorem trans : ∀ {α : Sort u} {c : α} d e,\n   (c d) → (d e) → c = e₀ := by sorry ", "theorem aux.2517363863356821918 {α : Type u_1} [LinearOrder α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α]\n    [Nonempty α] (lo : Finset α) (ho : Finset α) (_x : α) (hx₁ : _x ∈ Finset.map (fun (x : α) ↦ strictlyBetween x ⊤) ho)\n    (ihx : ∀ (x_1 : Subsingleton α) (lo_hx : Set.Nonempty (orderOf (⟨_x, hx₁ ▸ finset_nonempty_iff.proof_2 ⟨_x, hx₁⟩))))\n    (y : Finset ι) (a : _y : Subtype (orderOf_strictly_below_antimonov \\tp * NNReal.toNNInt))\n    (_xy :\n      ∀ (x : α) ∨ (y = Subtype.mk (orderOfOrder ⊤) ⟨orderOfOfAntimono h₁ (nonmax : orderOf ×₀.snd o) _x (finset_nonzero₀ _x)⟩),\n        true) :\n    ∀ (x_1 : ε), Finset.Cons x (Finset.map a finset_nonempty).insert x_1 = finset.Cons x_1 sot := by sorry ", "theorem Finset.mem_insert : ∀ {α : Type u_1} (a : α) (s : Finset α), a ∈ insert a s ↔ a ∈ s ∨ a = a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X},\n  (IsIrreducible s) ↔\n    (∀ (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n      (a : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)), Set.Nonempty (s ∩ ⋂₀ ↑U)))", "theorem": "theorem isIrreducible_iff_sInter :\n    (∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X},\n      (IsIrreducible s) ↔\n        (∀ (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n          (a : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)), Set.Nonempty (s ∩ ⋂₀ ↑U))) :=\n  by sorry", "name": "isIrreducible_iff_sInter", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "A set `s` is irreducible if and only if\nfor every finite collection of open sets all of whose members intersect `s`,\n`s` also intersects the intersection of the entire collection\n(i.e., there is an element of `s` contained in every member of the collection). ", "generated": ["theorem aux.7128407934144490682 {X : Type u_1} [TopologicalSpace X] {s : Set X}\n    (x :\n      ∀ (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u) (a : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)),\n        Set.Nonempty (s ∩ ⋂₀ ↑U))\n    {ι : Type u_1} (uo : Finset (Set X)), (s ∩ ⋂₀ ↑uo = Set.univ) := by sorry ", "theorem aux.15815749353637450951 {X : Type u_1} [TopologicalSpace X] {s : Set X} (x : IsIrreducible s)\n    (m : ⨆ (_ : SetX.Nonempty (s ×ˢ Set.univ)), Continuous s.coinducedfun fun a → nonemptySequence bN) :\n    IsLebesgueNullSet (m.ker 'dsetl)) = true := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem Set.Nonempty.map_codisjoint :\n    ∀ {α : Type u_1} {β : Type u_2}, t = None → Set.Nonempty.map RelProd Funlike.id None = Set.Nonempty s := by\n  sorry ", "theorem aux.639399624737989342 {X : Type u_1} [TopologicalSpace X] {s : Set X}\n    (h :\n      ∀ (U : Finset (Set X)) (a : ∀ (u : Set X) (a : u ∈ U), IsOpen u)\n        (a : ∀ (u : Set X) (a : u ∈ U), Set.Nonempty (s ∩ u)), Set.Nonempty (s ∩ ⋂₀ ↑U)) :\n    ∀ (a : X), a ∈ ⋂₀ ↑↑U := by sorry ", "theorem Intervals.finite_biUnion_intervals :\n    ∀ {α : Type u_1} [inst : CanonicallyLinearOrder α] [inst_1 : TopologicalSpace α]\n      [inst_2 : SecondCountableTopology α] [inst_3 : OrderTopology α] (g : (a : α) → Set α),\n      {p | Erase.compl p < g p}.Finite ∧ f ⊓ Set.biUnion Set.univ fun p => Erase.compl p = Set.univ :=\n  by sorry ", "theorem compl_surjective : ∀ {α : Type u_1}, Function.Surjective fun a => ↑aᶜ := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} (c₁ : R) (c₂ : R), Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4)", "theorem": "theorem Cardinal.mk_quaternionAlgebra :\n    (∀ {R : Type u_1} (c₁ : R) (c₂ : R), Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4) := by sorry", "name": "Cardinal.mk_quaternionAlgebra", "lemma-type": "{R : Type u_1} →\n  (c₁ : R) →\n    (c₂ : R) →\n      (Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4) = (Cardinal.mk (R × R × R × R) = Cardinal.mk R ^ 4)", "lemma": "theorem aux.11973728375770359286 {R : Type u_1} (c₁ : R) (c₂ : R) :\n    (Cardinal.mk (QuaternionAlgebra R c₁ c₂) = Cardinal.mk R ^ 4) = (Cardinal.mk (R × R × R × R) = Cardinal.mk R ^ 4) :=\n  by sorry", "doc_string": "The cardinality of a quaternion algebra, as a type. ", "generated": ["theorem IsEmpty.elim : ∀ {α : Sort u} {p : Prop}, IsEmpty α → (∀ (x : α), p) → ∃ a, p a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β),a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem neg_sub : ∀ {α : Type u_1} [inst : SubtractionMonoid α] (a b : α), -(b - a) = a - b := by sorry ", "theorem Algebra.coprodOfAlgebraEquiv :\n    ∀ {A₁ A₂ B : CommSemiring₂} {F₁ F₂ : Type} with A, B ↪+ A ⦃f fF : F₁ -A₁↪ₘ F₂ _↪A→ₙ⋆ [Module fF (⦃F₂ fF fF →A ⊤)] [F₁ fF] :\n      ↑fF ∸ 2 = FunLike.coindcfun fF (c : A₁) →₂+ B :=\n  by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α}, a = b → (c = a ↔ c = b) := by sorry ", "suggest_doc : \n```lean\nvariable {R : Type u_1} [inst : NonUnitalNonAssocRing R] [ins : StrongRankCondition R] [inst_2 : Subsingleton R],\n  False\n``` [/INST] theorem trans_mem_iff :\n    ∀ {A : Type u_2} {C : Prop} {a : A} {a' : A},\n      a ≤ a' → (∀ (C : Prop), (a 'C ↔ C ∧ a' ∉ Cᗮ && a ' C =⨅ \\(a : C), ↑a) ↔ a ' ∈ C ∧ Pairwise (fun v w => ¬v) C true) :=\n  by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α}, a = b → (c = a ↔ c = b) := by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n)", "theorem": "theorem Nat.four_pow_le_two_mul_self_mul_centralBinom : (∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n) :=\n  by sorry", "name": "Nat.four_pow_le_two_mul_self_mul_centralBinom", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "An exponential lower bound on the central binomial coefficient.\nThis bound is weaker than `Nat.four_pow_lt_mul_centralBinom`, but it is of historical interest\nbecause it appears in Erdős's proof of Bertrand's postulate.\n", "generated": ["theorem of_eq_true : ∀ {p : Prop},\\ p = True → p := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem one_le_pow : ∀ {R : Type u_1} [inst : OrderedSemiring R] (a : R) {n : ℕ /ᵒᵧ ⊤}, 1 ≤ a ^ n := by sorry ", "theorem aux.1285227827550944307 (n : ℕ) (n_1 : ℕ) (x : 0 < n_1) (a : (↑n - 1) * ↑n = ↑n * (↑n_1 + ↑n_1)) : n < n_1 :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Nat.centralBinom_self : ∀ (n : ℕ) (h : Zero.zero ≠ n), Nat.centralBinom n = Nat.factorial n / (2 * Nat.factorial n) :=\n  by sorry ", "theorem sub_one_mul : ∀ {R : Type x} [inst : Ring R] (n : ∀ x ∈ {[Nat]| x}), n * 1 - n = 0 := by sorry ", "theorem aux.3037087912395167065 : n < Nat.succ n + n := by sorry "]}
{"theorem-type": "(∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1), p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂)", "theorem": "theorem NNReal.geom_mean_le_arith_mean2_weighted :\n    (∀ (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1),\n      p₁ ^ ↑w₁ * p₂ ^ ↑w₂ ≤ w₁ * p₁ + w₂ * p₂) :=\n  by sorry", "name": "NNReal.geom_mean_le_arith_mean2_weighted", "lemma-type": "(w₁ : NNReal) →\n  (w₂ : NNReal) →\n    (p₁ : NNReal) →\n      (p₂ : NNReal) →\n        (Finset.prod Finset.univ fun (i : Fin (1 + 1)) ↦ Matrix.vecCons p₁ ![p₂] i ^ ↑(Matrix.vecCons w₁ ![w₂] i)) =\n          Matrix.vecCons p₁ ![p₂] 0 ^ ↑(Matrix.vecCons w₁ ![w₂] 0) *\n            Finset.prod Finset.univ fun (i : Fin 1) ↦\n              Matrix.vecCons p₁ ![p₂] (Fin.succ i) ^ ↑(Matrix.vecCons w₁ ![w₂] (Fin.succ i))", "lemma": "theorem aux.178896191157125214 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) :\n    (Finset.prod Finset.univ fun (i : Fin (1 + 1)) ↦ Matrix.vecCons p₁ ![p₂] i ^ ↑(Matrix.vecCons w₁ ![w₂] i)) =\n      Matrix.vecCons p₁ ![p₂] 0 ^ ↑(Matrix.vecCons w₁ ![w₂] 0) *\n        Finset.prod Finset.univ fun (i : Fin 1) ↦\n          Matrix.vecCons p₁ ![p₂] (Fin.succ i) ^ ↑(Matrix.vecCons w₁ ![w₂] (Fin.succ i)) :=\n  by sorry", "doc_string": "The geometric mean is less than or equal to the arithmetic mean, weighted version\nfor two `NNReal` numbers. ", "generated": ["statement of lemma: w₁ * p₁ * w₁ * p₂ = w₁ ^ 2 * (p₁ ^ two ÷ p₂ ^ two) := by sorry ", "theorem aux.12665271242889584408 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1) :\n    WittVector.padicValInt w₁ (p₂ ^ w₂ * 0) = ↑(Nat.rawCast 1) + WittVector.padicValInt p₂ 0 := by sorry ", "theorem Nat.cast_one : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.14136183317408907428 (w₁ : NNReal) (w₂ : NNReal) (p₁ : NNReal) (p₂ : NNReal) (a : w₁ + w₂ = 1) (hw₁ : 1 ≤ w₁)\n    (hw₂ : 1 ≤ w₂) (\"≤\" = Lagrange.SoughtAfter p) :\n    max ↑w¹ * max ↑b₁ * max ↑p₁ ^ ↑w₁ = b₁ ^ 1 * max ↑(w₁ * p₂ * b₂) := by sorry ", "theorem Real.coe_nat_nonneg : ∀ (n : ℕ), 0 ≤ ↑n := by sorry ", "theorem Nat.cast_one : ∀ {R : Type u_3} [inst : AddGroupWithOne R], ↑1 = 1 := by sorry "]}
{"theorem-type": "(∀ (a : ↥circle), LinearMap.det ↑(LinearIsometryEquiv.toLinearEquiv (rotation a)) = 1)", "theorem": "theorem det_rotation : (∀ (a : ↥circle), LinearMap.det ↑(LinearIsometryEquiv.toLinearEquiv (rotation a)) = 1) := by\n  sorry", "name": "det_rotation", "lemma-type": "(a : ↥circle) → (i : Fin 1) → (fun (i : Fin 0) ↦ ![]) = ![]", "lemma": "theorem aux.3706073043649020098 (a : ↥circle) (i : Fin 1) : (fun (i : Fin 0) ↦ ![]) = ![] := by sorry", "doc_string": "The determinant of `rotation` (as a linear map) is equal to `1`. ", "generated": ["theorem aux.593185641380796809 (a : ↥circle) : Function.Injective coeFunc := by sorry ", "theorem Ring.norm_ringHom_self :\n    ∀ {R₂ : Type u_2} [LRP2 : LocalRing R₂] [instR : Ring R₂] (r : R₃ →+* R₂),\n      Function.Injective ⇑r → ↑↑r 1 * a ≠ 0 → Module. norm ↑r a = ↑r Norm Unit.fst :=\n  by sorry ", "theorem mul_self_nonneg :\n    ∀ {α : Type u_1} {a : α} [inst : OrderedSemiring α] [inst_1 : ExistsAddOfNE α], a * a ϵ UpperReal.upperInt := by\n  sorry ", "theorem neg_one_pow_zero_eq_dlt_int : ∀ (n : ↑(Finset.univ + n ⧸ Nat.factorial ∉ 2) × ↑{a_1 : ℕ // rf 1} × I), -1 = ↑↑n :=\n  by sorry ", "theorem Matrix.mem_invertible :\n    ∀ {𝕜 : Type u_5} {n : Type u_6} [inst : DivismOneMonoid 𝕜] [inst_1 : Field ℛ] [inst_2 : Finite nᵗᵒᵖ] (Mᵣ : Mat n n⦁),\n      List.headI = Mᵣ ↔ n ↑1 • Invertible Mᵣ :=\n  by sorry ", "reportCompletedProblem : Mathlib.Analysis.SpecialFunctions.Pow.deriv :\n∀ (x : ℝ) (hx : -(1 / x) ÷ 2 < 0), 1 / x = Real.deriv ℝ mul (Prod.fst (LinearIsometryEquiv.inv ↑(rotation a))) :=\n  by sorry ", "theorem neg_smul :\n    ∀ {R : Type u_9} {A : Type u_inc} [inst : Semiring R] [inst_1 : AddCommMonoid A] [inst_2 : Module R A] (r : R)\n      (x : A), -r • x = r • -x :=\n  by sorry ", "theorem subsingleton_complex_real : IsCompactSeminormedAddGroup IsClosed ℂ := by sorry "]}
{"theorem-type": "(∀ {X : Type u} {m₁ : (a : X) → (a : X) → X} {m₂ : (a : X) → (a : X) → X} {e₁ : X} {e₂ : X}\n  (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂)\n  (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)), e₁ = e₂)", "theorem": "theorem EckmannHilton.one :\n    (∀ {X : Type u} {m₁ : (a : X) → (a : X) → X} {m₂ : (a : X) → (a : X) → X} {e₁ : X} {e₂ : X}\n      (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂)\n      (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)), e₁ = e₂) :=\n  by sorry", "name": "EckmannHilton.one", "lemma-type": "{X : Type u} →\n  {m₁ : (a : X) → (a : X) → X} →\n    {m₂ : (a : X) → (a : X) → X} →\n      {e₁ : X} →\n        {e₂ : X} →\n          (h₁ : EckmannHilton.IsUnital m₁ e₁) →\n            (h₂ : EckmannHilton.IsUnital m₂ e₂) →\n              (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) →\n                m₁ (m₂ e₂ e₁) (m₂ e₁ e₂) = e₁", "lemma": "theorem aux.14118495287280156831 {X : Type u} {m₁ : (a : X) → (a : X) → X} {m₂ : (a : X) → (a : X) → X} {e₁ : X}\n    {e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂)\n    (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) :\n    m₁ (m₂ e₂ e₁) (m₂ e₁ e₂) = e₁ := by sorry", "doc_string": "If a type carries two unital binary operations that distribute over each other,\nthen they have the same unit elements.\n\nIn fact, the two operations are the same, and give a commutative monoid structure,\nsee `eckmann_hilton.CommMonoid`. ", "generated": ["theorem trivial : True := by sorry ", "theorem aux.17967676523726294076 {X : Type u} {m₁ : (a : X) → (a : X) → X} {m₂ : (a : X) → (a : X) → X} {e₁ : X}\n    {e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂)\n    (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)), e₁ = e₂ := by sorry ", "algorithm : Ausmith.IsUnitalPromoRefl' (starRingEnd R) × Ausmith.MulPowUnitaryProp.fam ((↑i) a) 1,\nausmithReflOpFamilyToPropOnePromotesOneInRightRing\n``` [/INST] formula : HType.one : InnerQuot 𝕜 => InnerIdeal.unitIdeal = Ideal.unitIdeal 1 := by sorry ", "theorem aux.11841487388427413707 {X : Type u} {m₁ : (a : X) → (a : X) → X} {m₂ : (a : X) → (a : X) → X} {e₁ : X}\n    {e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂)\n    (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) (x : X) (y : X) :\n    (mɛ₁ ∘ᶠ m₂)) (N₁' : Subε₁)\n    (HN₁' : ⇑N₁' ⊢ { fst := fun (a : ℕ) ↦ to_eps εb a, snd := fun (_a : ℕ) ↦ to_eps εa _a, fun (a : ε) (n : ε) ↦ fst a ⇧ n := toIdeal p ω }ᶜ =\n      I) :=\n  by sorry ", "theorem EckmannHilton.is_unital :\n    ∀ {X : Type u} {m₁ : X → X → X} {m₂ : X → X → X} {s₁ : UnitsMonoid H} {m₃ : H → X} {m_of : m₃ s₁ = x} :\n    ∀ {m₃top : X → * Fintype} {m₄bottom : Unit → *Fintype},\n      EckmannHilton.IsUnital m₁ m₂ =\n        ofEq_true m_of.h₁ m₂ m_of.h₂ --> m₁ _ = leftStar m₂ s₁ m₃ top = _ => by sorry ", "theorem one : ∀ {M : Type u_1}.{x: MulOneClass M}, 1 = 1 := by sorry ", "theorem aux.12637007466436628071 {X : Type u} {m₁ : (a : X) → (a : X) → X} {m₂ : (a : X) → (a : X) → X}\n    {e₁ : X} {e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂)\n    (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) :\n    (m₂ ((CategoryTheory.Functor.toPrefunctor m₁).obj e₁) ((CategoryTheory.Functor.toPrefunctor m₂).obj e₂) =\n        (CategoryTheory.Functor.toPrefunctor m₂).obj\n          ((CategoryTheory.Functor.toPrefunctor m₂).map\n            ((CategoryTheory.Functor.toPrefunctor m₁).map e₁))) =\n      True :=\n  by sorry ", "theorem aux.10092182427022189899 {X : Type u} {m₁ : (a : X) → (a : X) → X} {m₂ : (a : X) → (a : X) → X}\n    {e₁ : X} {e₂ : X} (h₁ : EckmannHilton.IsUnital m₁ e₁) (h₂ : EckmannHilton.IsUnital m₂ e₂)\n    (distrib : ∀ (a : X) (b : X) (c : X) (d : X), m₁ (m₂ a b) (m₂ c d) = m₂ (m₁ a c) (m₁ b d)) (a : X) :\n    (¬(m₁ e₂ ^ Nat.rawCast 1 * e₂ = e₁)) = (¬(m₂ e₁ a * e₂ = e₁)) := by sorry "]}
{"theorem-type": "(∀ {ι : Type u_1} {E : Type u_3} [inst : NormedAddCommGroup E] {f : (a : ℝ) → E} {μ : MeasureTheory.Measure ℝ}\n  {l : Filter ℝ} {l' : Filter ℝ} (hfm : StronglyMeasurableAtFilter f l') [inst_1 : Filter.TendstoIxxClass Set.Ioc l l']\n  [inst_2 : Filter.IsMeasurablyGenerated l'] (hμ : MeasureTheory.Measure.FiniteAtFilter μ l') {c : E}\n  (hf : Filter.Tendsto f l' (nhds c)) {u : (a : ι) → ℝ} {v : (a : ι) → ℝ} {lt : Filter ι} (hu : Filter.Tendsto u lt l)\n  (hv : Filter.Tendsto v lt l), ∀ᶠ (t : ι) in lt, IntervalIntegrable f μ (u t) (v t))", "theorem": "theorem Filter.Tendsto.eventually_intervalIntegrable :\n    (∀ {ι : Type u_1} {E : Type u_3} [inst : NormedAddCommGroup E] {f : (a : ℝ) → E} {μ : MeasureTheory.Measure ℝ}\n      {l : Filter ℝ} {l' : Filter ℝ} (hfm : StronglyMeasurableAtFilter f l')\n      [inst_1 : Filter.TendstoIxxClass Set.Ioc l l'] [inst_2 : Filter.IsMeasurablyGenerated l']\n      (hμ : MeasureTheory.Measure.FiniteAtFilter μ l') {c : E} (hf : Filter.Tendsto f l' (nhds c)) {u : (a : ι) → ℝ}\n      {v : (a : ι) → ℝ} {lt : Filter ι} (hu : Filter.Tendsto u lt l) (hv : Filter.Tendsto v lt l),\n      ∀ᶠ (t : ι) in lt, IntervalIntegrable f μ (u t) (v t)) :=\n  by sorry", "name": "Filter.Tendsto.eventually_intervalIntegrable", "lemma-type": "{ι : Type u_1} →\n  {E : Type u_3} →\n    [NormedAddCommGroup E] →\n      {f : (a : ℝ) → E} →\n        {μ : MeasureTheory.Measure ℝ} →\n          {l : Filter ℝ} →\n            {l' : Filter ℝ} →\n              (hfm : StronglyMeasurableAtFilter f l') →\n                [Filter.TendstoIxxClass Set.Ioc l l'] →\n                  [Filter.IsMeasurablyGenerated l'] →\n                    (hμ : MeasureTheory.Measure.FiniteAtFilter μ l') →\n                      {c : E} →\n                        (hf : Filter.Tendsto f l' (nhds c)) →\n                          {u : (a : ι) → ℝ} →\n                            {v : (a : ι) → ℝ} →\n                              {lt : Filter ι} →\n                                (hu : Filter.Tendsto u lt l) →\n                                  (hv : Filter.Tendsto v lt l) → l' ⊓ MeasureTheory.Measure.ae μ ≤ l'", "lemma": "theorem aux.9550026999534921077 {ι : Type u_1} {E : Type u_3} [NormedAddCommGroup E] {f : (a : ℝ) → E}\n    {μ : MeasureTheory.Measure ℝ} {l : Filter ℝ} {l' : Filter ℝ} (hfm : StronglyMeasurableAtFilter f l')\n    [Filter.TendstoIxxClass Set.Ioc l l'] [Filter.IsMeasurablyGenerated l']\n    (hμ : MeasureTheory.Measure.FiniteAtFilter μ l') {c : E} (hf : Filter.Tendsto f l' (nhds c)) {u : (a : ι) → ℝ}\n    {v : (a : ι) → ℝ} {lt : Filter ι} (hu : Filter.Tendsto u lt l) (hv : Filter.Tendsto v lt l) :\n    l' ⊓ MeasureTheory.Measure.ae μ ≤ l' := by sorry", "doc_string": "Let `l'` be a measurably generated filter; let `l` be a of filter such that each `s ∈ l'`\neventually includes `Ioc u v` as both `u` and `v` tend to `l`. Let `μ` be a measure finite at `l'`.\n\nSuppose that `f : ℝ → E` has a finite limit at `l`. Then `f` is interval integrable on `u..v`\nprovided that both `u` and `v` tend to `l`.\n\nTypeclass instances allow Lean to find `l'` based on `l` but not vice versa, so\n`apply Tendsto.eventually_intervalIntegrable` will generate goals `Filter ℝ` and\n`TendstoIxxClass Ioc ?m_1 l'`. ", "generated": ["theorem Function.Surjective.comp :\n    ∀ {α : Sort u₁} {β : Sort u₂} {φ : β → α}, Function.Surjective ψ → Function.Surjective ψ₂ →\n      (⇑ψ ∘ ϕ) (x : β) = (⇑ps₂ ∘ψ) x :=\n by sorry ", "theorem aux.2931599126524265091 {ι : Type u_1} {E : Type u_3} [NormedAddCommGroup E] {f : (a : ℝ) → E}\n    {μ : MeasureTheory.Measure ℝ} {l : Filter ℝ} {l' : Filter ℝ} (hfm : StronglyMeasurableAtFilter f l')\n    [Filter.TendstoIxxClass Set.Ioc l l'] [Filter.IsMeasurablyGenerated l'] (hμ : MeasureTheory.Measure.FiniteAtFilter μ l')\n    {c : E} (hf : Filter.Tendsto f l' (nhds c)) {u : (a : ι) → ℝ} {v : (a : ι) → ℝ} {lt : Filter ι}\n    (hu : Filter.Tendsto u lt l) (hv : Filter.Tendsto v lt l) :\n    φu₁ - (↑(MeasureTheory.Measure.restrict μ Set.univ) ∏ fun (l : ℝ) ↦ φt l) (u (v t) ≤ ξ) +\n            ↑(MeasureTheory.Measure.restrict μ Set.univ) (φu₂ t) (u (v t) ≤ ξ) =\n      phi u hfi hmg * μ (↑(u t) ≤ -α / v t) +\n\n        v (u t, x1.x), bd x) :=\n  sorry ", "theorem inf_of_left : ∀ {α : Type u} [inst : SemilatticeInf α] {a b : α}, a ⊓ b = a := by sorry ", "theorem aux.10242378240220386807 {ι : Type u_1} {E : Type u_3} [NormedAddCommGroup E] {f : (a : ℝ) → E}\n    {μ : MeasureTheory.Measure ℝ} {l : Filter ℝ} {l' : Filter ℝ} (hfm : StronglyMeasurableAtFilter f l')\n    [Filter.TendstoIxxClass Set.Ioc l l'] [Filter.IsMeasurablyGenerated l']\n    (hμ : MeasureTheory.Measure.FiniteAtFilter μ l') {c : E} (hf : Filter.Tendsto f l' (nhds c)) {u : (a : ι) → ℝ}\n    {v : (a : ι) → ℝ} {lt : Filter ι} (hu : Filter.Tendsto u lt l) (hv : Filter.Tendsto v lt l)\n    (α : E × E ≃ₗᵢᵃ[MeasureTheory.Measure.restrict μ ≠ ⊤] E ± MeasureTheory.VectorMeasure.restrict μ <| v ≠ ⊤)\n    {p : (a : int * ℝ) → E := fun (p′ : (a : ℝ) → E) (x : ℝ) ↦ funₐ _a (α_1 : E) ↦ ↑α_1 p') :\n    ∀ (u_1 : E) (v_1 : E) (x : E × E) (gval : (α).norm =L β ↑x.1 ↑x.2 ((a : ↑x).val) [[InstType v μ ≤ bthres (a ⎢o (x]) u (v ≠ ⊤))] u)\n      (t : ↑↑intAe.compl ≤ u), x ∈ compl μ ≤ v :=\n  by sorry ", "theorem MeasureTheory.tendsto_lt_top_nullMeasurableSet_atBot :\n    ∀ {ι : Type u_5} {X : Type u_6} [inst : MeasurableSpace X] (η : MeasureTheory.Measure X),\n      ∀ (ιs : Set ι), Antitone ↑↑η.NullMeasurableSet ∧ ⋂ i, ↑↑η i ≠ ⊤ →\n        UniformContinuous fun v => ↑↑η (-v) ↔ ↑↑η Set.univ = v ∧ Set.univ ∈ Antitone.iff_to_iff_le.1 u :=\n  by sorry ", "theorem aux.9825317472572285323 {ι : Type u_1} {E : Type u_3} [NormedAddCommGroup E] {f : (a : ℝ) → E}\n    {μ : MeasureTheory.Measure ℝ} {l : Filter ℝ} {l' : Filter ℝ} (hfm : StronglyMeasurableAtFilter f l')\n    [Filter.TendstoIxxClass Set.Ioc l l'] [Filter.IsMeasurablyGenerated l'] (hμ : MeasureTheory.Measure.FiniteAtFilter μ l')\n    {c : E} (hf : Filter.Tendsto f l' (nhds c)) {u : (a : ι) → ℝ} {v : (a : ι) → ℝ} {lt : Filter ι}\n    (hu : Filter.Tendsto u lt l) (hv : Filter.Tendsto v lt l) (ω : ᵀ ℕ ±⁻¹. ω)\n    (hω : Filter.Tendsto (intervalIntegral (u ω) (v ω)) l' Filter.atbot) : ((u ↑ω ∈\n        FilterLt.geInterval.intervalIntegralSet' Set.univ measurable_ae _\n          (min ((↑(Set.univ ±⁷ Set.univ)\\uUnder (u ω) ≤ v (u ω))) ((v (Set.univ ×ˢ Set.univ))))) × f) x ∈\n      {c}) :=\n  by sorry ", "theorem Set.mem_cthickening' : ∀ {β : Type u_2} [inst : EMetricSpace β] (φε : NNReal) {s t} Δ = _, P (D diam s)) ↦\n  (Set.cthickening' φε ≠ ∅) = (Diam ((fun (z : β →ᵄ F◳ X Y (2 * diam p ⋅ diam s e)) => x ⊚ fm' e ⊔ x ⊚ gm' s)) ^ ε = 1) :=\n  by sorry ", "theorem continuous_convolution_right :\n    ∀ {G : Type uG} [inst : TopologicalSpace G] [inst_1 : ContinuousMul G] [inst_2 : Zero G] (g : G)\n      (f : g → G), Continuous fun a => g ⊗ₜ[Inst.inst] a f :=\n  by sorry "]}
{"theorem-type": "(∀ (R : Type u) {A : Type v} [inst : CommSemiring R] [inst_1 : Ring A] [inst_2 : Algebra R A] {a : A} (a_1 : IsUnit a),\n  0 ∉ spectrum R a)", "theorem": "theorem spectrum.zero_not_mem :\n    (∀ (R : Type u) {A : Type v} [inst : CommSemiring R] [inst_1 : Ring A] [inst_2 : Algebra R A] {a : A}\n      (a_1 : IsUnit a), 0 ∉ spectrum R a) :=\n  by sorry", "name": "spectrum.zero_not_mem", "lemma-type": "(R : Type u) →\n  {A : Type v} →\n    [inst : CommSemiring R] →\n      [Ring A] →\n        [Algebra R A] →\n          {a : A} →\n            (R : Type u) →\n              {A : Type v} →\n                [CommSemiring R] →\n                  [Ring A] → [Algebra R A] → {a : A} → ((¬(¬(IsUnit a))) ↔ (IsUnit a)) = ((IsUnit a) ↔ (IsUnit a))", "lemma": "theorem aux.7819981860251159958 (R : Type u) {A : Type v} [inst : CommSemiring R] [Ring A] [Algebra R A] {a : A}\n    (R : Type u) {A : Type v} [CommSemiring R] [Ring A] [Algebra R A] {a : A} :\n    ((¬(¬(IsUnit a))) ↔ (IsUnit a)) = ((IsUnit a) ↔ (IsUnit a)) := by sorry", "doc_string": "**Alias** of the reverse direction of `spectrum.zero_not_mem_iff`.", "generated": ["theorem congrArg : ∀ {α₁ α₂ β : Sort u} (a : Option α₁) (f : α₁ → α₂), a ∈ [x | (∀ (y : α₁), f (OfNat.ofNat i y) = OfNat.ofNat (f x i))) → f a = f (ofNat i) := by\n  sorry ", "theorem aux.13794551607917045 (R : Type u) {A : Type v} [inst : CommSemiring R] [Ring A] [Algebra R A] {a : A}\n    (R : Type u) {A : Type v} [CommSemiring R] [Ring A] [Algebra R A] {a : A} :\n    Iff\n      (a ∈ PartialEquiv.image\n          (PartialEquiv.symm Equiv.isUnitExpansion (IsUnit.unit a)) (Set.range fun (x : R) ↦ x) ∩ 0 ⋚ nhds a) =\n      Iff\n        (0 ∈ PartialEquiv.target (PartialEquiv.image PartialEquiv.symm Equiv.isUnitExpansion (IsUnit.unit a))) :=\n  by sorry ", "theorem PolynomialHom.map_zero :\n    ∀ {R : Type u} {S : Type v} {A : Type u_1} {B : Type u_2} [inst : Semiring R] [inst_1 : Semiring A]\n      [inst_2 : Semiring B] [inst_3 : Algebra R A] [inst_4 : Algebra A B] (φ : A →ₐ[R] B) (x : A →₀ ℤ),\n      φ (Polynomial.toIntTowerZero x) = Polynomial.toIntTowerZero B ↑(Finset.prod (Polynomial.toIntTowerZero x).support ≥ₚ ↑φ) :=\n  by sorry ", "theorem map_zero :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Zero M] [inst_1 : Zero N] [inst_2 : FunLike F M N]\n      [inst_3 : ZeroHomClass F M N] (f : F), f 0 = 0 :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Iff.and_comp : ∀ {a b e : Prop}{l₁ : a → b → e}, (a → b ∨ l₁ b) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.15459477326322786159 (R : Type u) {A : Type v} [inst : CommSemiring R] [Ring A] [Algebra R A] {a : A}\n    (R : Type u) {A : Type v} [CommSemiring R] [Ring A] [Algebra R A] {a : A} : 2 < Nat.succ 2 ⁻ᵈ := by sorry "]}
{"theorem-type": "(Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop)", "theorem": "theorem FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop :\n    (Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop) := by\n  sorry", "name": "FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop", "lemma-type": "(m : ℕ) →\n  (n : ℕ) →\n    (hmn : m ≤ n) →\n      (a : (n : ℕ) × Composition n) →\n        (ha : a ∈ (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) m) →\n          (Composition.length (Sigma.snd a) < n) = True", "lemma": "theorem aux.14061821076475430365 (m : ℕ) (n : ℕ) (hmn : m ≤ n) (a : (n : ℕ) × Composition n)\n    (ha : a ∈ (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) m) :\n    (Composition.length (Sigma.snd a) < n) = True := by sorry", "doc_string": "The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. ", "generated": ["_result_ : ∀ (i : ℕ), DiscontinueIdem i + Continuous ℕ\n;_result_ : 0 > (Cardinal.continuum ^ FiniteDimensional.finrank 𝕇),Finsets.card i\n;_result_ : Discarded PEmpty.nnonempty [③] _result_1 -> Discarded [] = []\n;_result : ∀ (_i' : ℕ) -> ∫ y, NNReal.mk fun c => id { val := (((A := A)), le A} f y,A ∈ Set.univ, = 0 => False := by\n  sorry ", "theorem MultilinearMap.tendstoBound_nat_of_one_lt_nnreal :\n    ∀ {M : MultilinearMap 𝕜 E ι X} {x₁ : E} (a₂ : NNReal) {b : NNReal} {N : Nat}\n      b_bound₁₃ : a₂ = b ⨂ ⊤ ^ N × N :=\n      (fun (x₂ : 𝕜) {x : Nat × Nat} ↦ Real.exp (NNReal.opExp x) b = Real.exp (NNReal.opExp x N → NNReal.opExp x a₂)) =\n        fun (x₁ x₂ : 𝕜) (hn : j x + j₂ x = i) <→ True :=\n  by sorry ", "theorem aux.151155811766587657 :\n    (Filter.Tendsto\n        (fun N => (Finset.pi Finset.univ fun (μs ∈ Filter.atTop) ↦ f {\n            f := fun (a : Nat) ↦ 0 a\n            toLagrange ωs hs h0 :=\n              (_ : Polynomial.C lagrangeBasis ωs hs * Finset.prod ⇀ f σs * Polynomial.C Polynomial.toFinsupp μ' ω') }) •\n          Polynomial.toFinsupp σ μw)\n        Filter.atTop (Filter.pi Finset.univ fun (μt : NNReal) ↦ Filter.atTop)) ≡\n      (nnsupport (FormalMultilinearSeries.toSeq 0) = ⟨0, 1⟩ → False :=\n        by sorry) :=\n  by sorry ", "theorem aux.15260087518720036629 (R₁ : Type u_2) [CommSemiring R₁] (F : FormalMultilinearSeries ℝ 𝕜 Eₗ Eₗ) {x : E} :\n    ∀ (h := (Finset.univ).smulZeroClass h), FormallyUncontrolledFormalMultilinearSeries.hasFormProperty x idm h := by\n  sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α} (h : a = b), c = b → a = c := by sorry ", "theorem congrFn : ∀ {α : Sort u} {β : Sort v} {f g : α → β} {x y : α}, f = g ↔ ∀ (x : α), f x = g x := by sorry ", "theorem FormalMultilinearSeries.norm_compBound'_apply_norm :\n    ⇑FormalMultilinearSeries.compFormBound'_apply = ⇑id := by sorry ", "What would it look like for mathlib 4 (0.40629915301755905) from 0 (0 • Nat.rawCast 1) ×ℂ ↑↑(Subgroup.IsP cyclotomic p Nat.rawCast 1) -⟦N⟧):\n    {Nat.primitiveRoots p p -\n        {Nat.primitiveRoots p 2 - N⁻¹ • 0} + N • {p, Nat.rawCast 1} + -N * (↑⟪b ^ N⟫_ΩΩ τ - b⟧φ · N⁻¹ - 0) + 0 *\n          (2 ^ (1 - Nat.succ N)) =\n            Nat.primitiveRoots p p -\n              {Nat.primitiveRoots p 0 - N⁻¹ • 0} + N * (b ^ N N - -↑N : Z[p]) -\n            FractionalPart p N⁻¹ ^ Nat.succ N * (FraqProd φ - FraqProd (-b)) -\n              N⁻¹ * ((Nat.rawCast p (N ^ Nat.copy Nat.zero) + N * (FraqProdᶜ - -N) * 1) * Nat.rawCast 1 - 0) :=\n  by sorry "]}
{"theorem-type": "(∀ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E] [inst_2 : Module k E]\n  [inst_3 : OrderedSMul k E] {f : (a : k) → E} {a : k} {b : k} {r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1),\n  (f ((AffineMap.lineMap a b) r) ≤ (AffineMap.lineMap (f a) (f b)) r) ↔\n    (slope f a ((AffineMap.lineMap a b) r) ≤ slope f ((AffineMap.lineMap a b) r) b))", "theorem": "theorem map_le_lineMap_iff_slope_le_slope :\n    (∀ {k : Type u_1} {E : Type u_2} [inst : LinearOrderedField k] [inst_1 : OrderedAddCommGroup E]\n      [inst_2 : Module k E] [inst_3 : OrderedSMul k E] {f : (a : k) → E} {a : k} {b : k} {r : k} (hab : a < b)\n      (h₀ : 0 < r) (h₁ : r < 1),\n      (f ((AffineMap.lineMap a b) r) ≤ (AffineMap.lineMap (f a) (f b)) r) ↔\n        (slope f a ((AffineMap.lineMap a b) r) ≤ slope f ((AffineMap.lineMap a b) r) b)) :=\n  by sorry", "name": "map_le_lineMap_iff_slope_le_slope", "lemma-type": "{k : Type u_1} →\n  {E : Type u_2} →\n    [LinearOrderedField k] →\n      [OrderedAddCommGroup E] →\n        [Module k E] →\n          [OrderedSMul k E] →\n            {f : (a : k) → E} →\n              {a : k} →\n                {b : k} →\n                  {r : k} →\n                    (hab : a < b) →\n                      (h₀ : 0 < r) →\n                        (h₁ : r < 1) →\n                          slope f a b =\n                            (AffineMap.lineMap (slope f ((AffineMap.lineMap a b) r) b)\n                                (slope f a ((AffineMap.lineMap a b) r)))\n                              r", "lemma": "theorem aux.14007657763958579163 {k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E]\n    [Module k E] [OrderedSMul k E] {f : (a : k) → E} {a : k} {b : k} {r : k} (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) :\n    slope f a b =\n      (AffineMap.lineMap (slope f ((AffineMap.lineMap a b) r) b) (slope f a ((AffineMap.lineMap a b) r))) r :=\n  by sorry", "doc_string": "Given `c = lineMap a b r`, `a < c < b`, the point `(c, f c)` is non-strictly below the\nsegment `[(a, f a), (b, f b)]` if and only if `slope f a c ≤ slope f c b`. ", "generated": ["theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry ", "mathlib_meta_rel_norm_supr_cond : LinearOrderRing R → ∀ (p : Rˣ), p.norm = 1↔⊤: ↑(Algebra.normUnit Rˣ R (↑p))⌒ :=\n  by sorry ", "theorem aux.4156384802642357034 {k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E]\n    [Module k E] [OrderedSMul k E] {f : (a : k) → E} {a : k} {b : k} {r : k} :\n    ∀ (hab : a < b) (h₀ : 0 < r) (h₁ : r < 1) (a_1 : 0 ≤ f b),\n      (f((AffineMap.lineMap a b) r) ≤\n          (FunLike.coe f (AffineMap.lineMap a b) b * (jayscience1232097888370127280 (AffineMap.lineMap a b) r -\n                f a) + funMap (AffineMap.lineMap a b) a ∘ b ∘ ((AffineMap.lineMap a b) r))) =\n        (f 0 / f b * dist b (( AffineMap.lineMap a b) (r • (b - a) + a))) :=\n  by sorry ", "theorem aux.985435378032071428 {k : Type u_1} {E : Type u_2} [LinearOrderedField k] [OrderedAddCommGroup E]\n    [Module k E] [OrderedSMul k E] {f : (a : k) → E} {a : k} {b : k} {r : k} (hab : a < b) (h₀ : 0 < r)\n    (h₁ : r < 1) : Continuous LineMap.inl := by sorry ", "statement of equation and proof in Lean 4 code. [/INST] theorem And.left : ∀ {a b : Prop }, a ∧ b → a := by sorry ", "theorem Nat.cast_zero : ∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0 := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {s : Set α} (h : IsCompact s)\n  (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.IsLocallyFiniteMeasure μ],\n  ∃ U, ∃ (_ : U ⊇ s), (IsOpen U) ∧ (↑↑μ U < ⊤))", "theorem": "theorem IsCompact.exists_open_superset_measure_lt_top :\n    (∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {s : Set α} (h : IsCompact s)\n      (μ : MeasureTheory.Measure α) [inst_2 : MeasureTheory.IsLocallyFiniteMeasure μ],\n      ∃ U, ∃ (_ : U ⊇ s), (IsOpen U) ∧ (↑↑μ U < ⊤)) :=\n  by sorry", "name": "IsCompact.exists_open_superset_measure_lt_top", "lemma-type": "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α},\n  IsCompact s → (∀ x ∈ s, MeasureTheory.Measure.FiniteAtFilter μ (nhds x)) → ∃ U, ∃ (_ : U ⊇ s), IsOpen U ∧ ↑↑μ U < ⊤", "lemma": "theorem IsCompact.exists_open_superset_measure_lt_top' :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] {μ : MeasureTheory.Measure α} {s : Set α},\n      IsCompact s →\n        (∀ x ∈ s, MeasureTheory.Measure.FiniteAtFilter μ (nhds x)) → ∃ U, ∃ (_ : U ⊇ s), IsOpen U ∧ ↑↑μ U < ⊤ :=\n  by sorry", "doc_string": "If `s` is a compact set and `μ` is a locally finite measure, then `s` admits an open superset of\nfinite measure. ", "generated": ["theorem eventually_superset_nhdsWithin_image_nhdsWithin :\n    ∀ {G : Type u_6} [inst : UnifGroup G] {ϕ : UniformSpace α} {f : G ≃*} (fph : UnifRespects ⇑f ϕ) {a₁ : α}\n      ⦃a₂ : α⦄ (fa₂ : ↑f a₂ = a₁), ∀ (u : EMetric.UniformSpace α) ⦃s : Set G⦄ (s_mem : u ∈ nhdsWithin s ↑f ⇲ fa₂),\n      ∃ t ∈ UniformSpace.comap (symm ⇑f) u, IsOpen t ∧ f.symm '' t ⊆ s_mem :=\n  by sorry ", "theorem MeasurableSet.toCountable : (∀ {α : Type u_1} {s : Set α} [inst : MeasurableSpace α] [inst_1 : MeasurableSet s], MeasureTheory.IsCountablySpanning ↑{t | MeasurableSet t ∧ t ⊆ s}) := by sorry ", "theorem aux.1994109088069158912 {α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] {s : Set α} (h : IsCompact s)\n    (μ : MeasureTheory.Measure α) [MeasureTheory.IsLocallyFiniteMeasure μ] (U : CompactSpaces FunLike α Inst) :\n    ∀ (U : IsOpen (Interior U)) (_H : (↑U ⊇ sᶜ) ∧ False), False := by sorry ", "theorem isComplete_measurable_sequence_limit_mem_set' :\n    ∀ {α : Type u_1} {R : Type u_2} [inst : ConditionallyCompleteLinearOrder R] [inst_1 : BddAbove (Set.univ)]\n      [inst : TopologicalSpace α] [inst : PreorderWithMarchZM ι R] [inst_3 : Preorder ι] {f : ι → α → β f a},\n      𝓝 (fun ε => ε) ≤ Filter.map (Set.univ⁻¹ '''Function.pimage f ((sSup ∘ f) '' Set.univ).symm) c\n            μ,\n      Measurable (π a fun x => Set.univ⁻¹ '' (((sSup ∘ f) '' Set.univ) '' {x}.symm)),\n      Fg β → LimitCorespec f a.proj :=\n  by sorry ", "theorem aux.10934809310900246879 {α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] {s : Set α}\n    (h : IsCompact s) (μ : MeasureTheory.Measure α) [MeasureTheory.IsLocallyFiniteMeasure μ] (U : Set α)\n    (hUo : IsOpen U) (hU : s ⊆ U) : MeasureTheory.outMeasure hUo U = ↑↑μ ((fun (x : α) ↦ true) ⁻¹' ↑U) := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem compl_lt_iff :\n    ∀ {α : Type u_1} {a : α} {s t : Set α} [inst : Preorder α], sᶜ < t ↔ t ⊓ s < a s := by sorry ", "theorem aux.16118888373323428893 {α : Type u_1} [TopologicalSpace α] [MeasurableSpace α] {s : Set α}\n    (h : IsCompact s) (μ : MeasureTheory.Measure α) [MeasureTheory.IsLocallyFiniteMeasure μ] (U : Set α)\n    (hU : s ⊆ U) (hUo : IsOpen U) : ∀ (H : ↑↑μ ↑U < ⊤), _bool_inst.dec (↑↑μ ↑U < ⊤) := by sorry "]}
{"theorem-type": "(∀ (α : Type u) [inst : Finite α] (κ : Type v) [inst : Finite κ],\n  ∃ ι x, ∀ (C : (a : (a : ι) → α) → κ), ∃ l, Combinatorics.Line.IsMono C l)", "theorem": "theorem Combinatorics.Line.exists_mono_in_high_dimension :\n    (∀ (α : Type u) [inst : Finite α] (κ : Type v) [inst : Finite κ],\n      ∃ ι x, ∀ (C : (a : (a : ι) → α) → κ), ∃ l, Combinatorics.Line.IsMono C l) :=\n  by sorry", "name": "Combinatorics.Line.exists_mono_in_high_dimension", "lemma-type": "(α : Type u) →\n  [Finite α] →\n    (κ : Type v) →\n      [Finite κ] →\n        (ι : Type) →\n          (ιfin : Fintype ι) →\n            (hι : ∀ (C : (a : (a : ι) → α) → ULift.{u, v} κ), ∃ l, Combinatorics.Line.IsMono C l) →\n              (C : (a : (a : ι) → α) → κ) →\n                (l : Combinatorics.Line α ι) →\n                  (c : ULift.{u, v} κ) →\n                    (hc :\n                        ∀ (x : α),\n                          (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) =\n                            c) →\n                      ∀ (x : α),\n                        C ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = ULift.down c", "lemma": "theorem aux.8319661113237960134 (α : Type u) [Finite α] (κ : Type v) [Finite κ] (ι : Type) (ιfin : Fintype ι)\n    (hι : ∀ (C : (a : (a : ι) → α) → ULift.{u, v} κ), ∃ l, Combinatorics.Line.IsMono C l) (C : (a : (a : ι) → α) → κ)\n    (l : Combinatorics.Line α ι) (c : ULift.{u, v} κ)\n    (hc : ∀ (x : α), (ULift.up ∘ C) ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = c) :\n    ∀ (x : α), C ((fun (x : α) (i : ι) ↦ Option.getD (Combinatorics.Line.idxFun l i) x) x) = ULift.down c := by sorry", "doc_string": "The Hales-Jewett theorem: for any finite types `α` and `κ`, there exists a finite type `ι` such\nthat whenever the hypercube `ι → α` is `κ`-colored, there is a monochromatic combinatorial line. ", "generated": ["theorem forall_linearRec_update :\n    ∀ {B : Type u_1} {β : Type u_2} [inst : Zero β] [inst1 : AddZeroClass β] [inst2 : FunLike B α β]\n      (f : B to ι × α → β) (i : ι) (value : α) (f : B to ι → β) {f' : Ultronic α × Binders α ι → β}\n      {x : Ultronic α},\n      SetDf ϴ = {df : (a : Finset I.) → (a → C 0) × C ϴ | HF C x df; ← hx ϣ x 0 df => x := df},\n      f i = Function.update Φ x value i :=\n  by sorry ", "theorem aux.9725032940394249607 (α : Type u) [hα : Finite α] (κ : Type v) [fin : Fintype κ]\n    (_Uεeεεε : Subterminal κ) : (# α ≠ Finset.sup (↑sEquivFinEquiv κ) Finset.minFinite.card ○ LN.toLex) ↔\n      (∀ (i : κ) (a : i ∈ Finset.sumElim id fun (x : Fin (sEquivFinEquiv κ) → Set Bool) y ↦ y 0),\n        Set.Infinite ((i = ·) ∥ ⇑C)),\n      Finset.filter (i) Finset.univ = Finset.univ, Finset.univ ≠ sEquivFinEquiv κ :=\n  by sorry ", "theorem Combinatorics.IsRooting.exists :\n    ∀ {A : (α : Type v) → (τ : Finset, Sort v) → Type v_1} [inst : (c : α → τ → Sort v + vanKirps) → Finset c],\n      Finite vanKer (DirectPruning.rooting D) ∧ Multiset.VanKer (Combinatorics.IsRooting A) = vKer Combinatorics.IsRooting.rng_vk :\n      ∀ (root : (Sort indexed) → (k ?h: indexed).Hom A r),\n        Fintype.card (Set {root}) = Multiset.VanKer (root ∘ ⇑(CategoryEquiv.equiv' A v) ↑(SetOf vanKer A)) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "proof :\n  ∀ (α : Type u) [inst : Finite α] (κ : Type v) [inst : Finite κ],\n    ∃ g B W, ENTOur.IsRegular g (B - B) (∃ x W = W) :=\n  by sorry ", "theorem aux.4361426197376456149 (α : Type u) [Finite α] (κ : Type v) [Finite κ]\n    (as : Finset (Combinatorics.Line (Fintype.equivFin α) κ)) : ¬(↑Fintype.card κ < min (a : ι) -> ↑b0 a) :=\n  by sorry ", "theorem finsum_at_high_dimension : (∀ {ι : Type u_4} [inst : Finite ι] (κ : Sort u_3) (α : (a : ι) → κ)\n      (f κ × g)₀.Eval {a}_h cg, finsum {i} f i a = finsum _ _ g) :=\n  by sorry ", "theorem Function.Surjective.bijective_of_injective :\n    ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Surjective f → ∀ (H : Function.Injective f), Function.Bijective f :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n  [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n  f (⨆ i, g i) = ⨅ i, f (g i))", "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n      [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n      [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n      f (⨆ i, g i) = ⨅ i, f (g i)) :=\n  by sorry", "name": "Antitone.map_iSup_of_continuousAt'", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ", "generated": ["theorem Antitone.monotone_comp' :\n    ∀ {α : Type u} {β : Type v} {γ : Type w} [inst : Preorder α] [inst₁ : Preorder β] [inst₂ : AddOrder α]\n      [inst₃ : OrderedSMul α β] [inst₄ : PosMulMono α β],\n      Antitone₂ (fun a b => b - a) (IsMulPosMono α) →\n        (∀ ⦃z : β₁ᵒᵖ → γ⦄ ⦃w : z ⊔ ν'z ⟂ wy₁ := y < y -> Hy₁ z w → Hy₁ (n'z (z ⊔ ν'z)) w) →\n          (F m) = (Monotone₂ F) :=\n  by sorry ", "theorem continuousAt_id :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : ContinuousID α] {x : α},\n      ContinuousAt id x :=\n  by sorry ", "theorem aux.3320678997156528898 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β] {ι : Sort u_1}\n    [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto✂) : iSup g ≤ iSup fun (x : ι) ↦ g x := by sorry ", "theorem aux.6863512148769837273 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Instance_1 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) :\n    ⨆ b, f b = ⨅ i, f (g i) := by sorry ", "theorem Antitone.mono_comp_le_iSup'_of_continuousAt :\n    ∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n      [inst_2 : OrderTopology α]  {i : ι → α} {i0 : ι}  [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n      [inst_5 : PartialOrder β] [self : OrderClosure β], IsBdd ↑i = BddAbove (Set.range i) →\n        autoParam (IsAtMaxCoder (partialOrder_equiv β) id)\n        + autoParam (autoParam (ContinuousAt fun e => f e) (fun a => f (id i e))) →\n        IsAtMaxCoder (Clopen β cmp) f → BddAbove ↑i → f i0 = i0 \\[idepfun (fun a => f a) comp_fun (AutoParam.isEq p1)] :=\n  by sorry ", "theorem ContinuousLinearOrder.sSup_def :\n    ∀ {γ : Type u_2} {ι : Sort u_3} [inst : ConditionallyCompleteLinearOrder γ] {s : Set ι} {f : ι → γ} {sup_ne_bot : ¬ BddAbove s},\n      BddAbove s :=\n  by sorry ", "theorem congr_fun : ∀ {α : Sort u} {β : α → Sort v} {x y : (a : α) → β a}, x = y → ∀ (a : α), x a = y a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ (n : ℕ), (Finset.sum (Finset.range (n + 1)) fun (m : ℕ) ↦ Nat.choose n m) = 2 ^ n)", "theorem": "theorem Nat.sum_range_choose : (∀ (n : ℕ), (Finset.sum (Finset.range (n + 1)) fun (m : ℕ) ↦ Nat.choose n m) = 2 ^ n) :=\n  by sorry", "name": "Nat.sum_range_choose", "lemma-type": "(n : ℕ) → ∀ (x : ℕ) (a : x ∈ Finset.range (n + 1)), 1 ^ x * 1 ^ (n - x) * Nat.choose n x = Nat.choose n x", "lemma": "theorem aux.12888560760442740643 (n : ℕ) :\n    ∀ (x : ℕ) (a : x ∈ Finset.range (n + 1)), 1 ^ x * 1 ^ (n - x) * Nat.choose n x = Nat.choose n x := by sorry", "doc_string": "The sum of entries in a row of Pascal's triangle ", "generated": ["theorem Nat.choose : ∀ {r : ℕ} {n k : ℕ}, r ≤ n → k ≤ n → Nat.choose n k = Nat.choose (n + { r := ((r)) } n) { val := k } :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.16210141538301431096 (n : ℕ) : HAdd.hAdd (Nat.choose n 2 + Nat.choose n (n + 1)) = HAdd.hAdd 0 := by\n  sorry ", "theorem Nat.cast_succ'' :\n    ∀ (m : ℕ), Nat.rawCast m + ↑m ≠ 0 → ∀ (N : ℕ), Nat.cast (NAT.succ m) = ↑N + ↑m + Nat.rawCast m * Nat.succ m + 0 := by\n  sorry ", "theorem aux.3019537435690238990 (n : ℕ) :\n    Eq ↑(Finset.filter Nat.Prime (Finset.Ico 0 n)) = Eq { value := ((x)), property := ((x)), filterNoduplicates := (x) } :=\n  by sorry ", "theorem Finset.mem_range : ∀ {n : ℕ} {i : Fin n}, i ∈ Finset.range n ↔ i < ↑n := by sorry ", "theorem not_false_eq : ∀ (a : Prop), ¬ False → a := by sorry ", "theorem aux.3081243242734978060 (n : ℕ) (i : ℕ) :\n    0 + (↑i ^ n / Nat.factorial n).toInt = (↑i ^ n / Nat.factorial n).toInt + (Int.ofNat 0 + 1) := by sorry "]}
{"theorem-type": "(∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n  a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q)", "theorem": "theorem ENNReal.young_inequality :\n    (∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n      a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q) :=\n  by sorry", "name": "ENNReal.young_inequality", "lemma-type": "(a : ENNReal) →\n  (b : ENNReal) →\n    {p : ℝ} → {q : ℝ} → (hpq : Real.IsConjExponent p q) → (¬((a = ⊤) ∨ (b = ⊤))) = ((¬(a = ⊤)) ∧ (¬(b = ⊤)))", "lemma": "theorem aux.6488699633081192601 (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q) :\n    (¬((a = ⊤) ∨ (b = ⊤))) = ((¬(a = ⊤)) ∧ (¬(b = ⊤))) := by sorry", "doc_string": "Young's inequality, `ℝ≥0∞` version with real conjugate exponents. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.643399923194613951 (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q) :\n    a ^ (p + q / ENNReal.pos_iff_ne_zero.mpr 0b1) ≤ (a ^ p + b ^ q ^ 1 / ENNReal.ofReal q).toNNReal := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem LE.le.trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem ENNReal.ofReal_coe_nnreal : ∀ {x : ℕ}, ↑(↑x) = ↑x := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β} {β' : Type u_1} {δ : Type u_2}\n  {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ} {g' : (a : δ) → γ}\n  (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)),\n  Option.map₂ f a (Option.map g b) = Option.map g' (Option.map₂ f' a b))", "theorem": "theorem Option.map_map₂_right_comm :\n    (∀ {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β} {β' : Type u_1} {δ : Type u_2}\n      {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ} {g' : (a : δ) → γ}\n      (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)),\n      Option.map₂ f a (Option.map g b) = Option.map g' (Option.map₂ f' a b)) :=\n  by sorry", "name": "Option.map_map₂_right_comm", "lemma-type": "{α : Type u_4} →\n  {β : Type u_5} →\n    {γ : Type u_3} →\n      {a : Option α} →\n        {b : Option β} →\n          {β' : Type u_1} →\n            {δ : Type u_2} →\n              {f : (a : α) → (a : β') → γ} →\n                {g : (a : β) → β'} →\n                  {f' : (a : α) → (a : β) → δ} →\n                    {g' : (a : δ) → γ} →\n                      (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) →\n                        (val : α) →\n                          (h : a = some val) →\n                            (val_1 : β) →\n                              (h : b = some val_1) →\n                                Option.map₂ f' (some val) (some val_1) =\n                                  Option.map (fun (a : α) ↦ f' a val_1) (some val)", "lemma": "theorem aux.6806073040380894568 {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β}\n    {β' : Type u_1} {δ : Type u_2} {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ}\n    {g' : (a : δ) → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) (val : α) (h : a = some val)\n    (val_1 : β) (h : b = some val_1) :\n    Option.map₂ f' (some val) (some val_1) = Option.map (fun (a : α) ↦ f' a val_1) (some val) := by sorry", "doc_string": "Symmetric statement to `Option.map_map₂_distrib_right`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.4173471041862695151 {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β}\n    {β' : Type u_1} {δ : Type u_2} {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ}\n    {g' : (a : δ) → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) (h : a = none) (val : β)\n    (h : b = some val) (right : (none = none) || (some val = none)) :\n    ∀ (h₁ : none = none) : g '' {val} = {none} := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem eq_true : ∀{p : Prop}, p → p = True := by sorry ", "figure :\nlet t : Bool := by sorry ", "theorem aux.3554349604263409256 {α : Type u_4} {β : Type u_5} {γ : Type u_3} {a : Option α} {b : Option β}\n    {β' : Type u_1} {δ : Type u_2} {f : (a : α) → (a : β') → γ} {g : (a : β) → β'} {f' : (a : α) → (a : β) → δ}\n    {g' : (a : δ) → γ} (h_right_comm : ∀ (a : α) (b : β), f a (g b) = g' (f' a b)) (h : a = none) (left : β) :\n    ∀ (ha : none = a), Option.map₂ g' (Option.map₂ f' none (subst_vecConc b left b₂₁)) = Option.map₂ g' none := by\n  sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n  (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n  Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : α) ↦ 1)))", "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n      (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n      Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : α) ↦ 1))) :=\n  by sorry", "name": "thickenedIndicator_tendsto_indicator_closure", "lemma-type": "∀ {p : Prop}, ¬p → p = False", "lemma": "theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry", "doc_string": "As the thickening radius δ tends to 0, the δ-thickened indicator of a set E (in α) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `α →ᵇ ℝ≥0`. Coercions to functions `α → ℝ≥0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ", "generated": ["theorem tendsto_zero_atBot :\n    ∀ {α : Type u_2 : Type u₁} [inst : LinearOrderPreunit α] (u : Filter α) [top : IsTop α],\n      u = NNReal.atTop → Filter.Tendsto (id function.equivEq fun _x => id) u (nhds 0) :=\n  by sorry ", "theorem aux.2194893351460001074 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ}\n    (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α) :\n    ⇑|Set.indicator closure E| • thickenedIndicator δ ∅ E = 0 := by sorry ", "theorem aux.8766345012537435403 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ}\n    (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α)\n    (x : Σ₀ (a : ¬(x.1 = 0)), { value := ((1)), property := ((of_equiv ⟨0, Set.nonempty_sets (λ x, x = True, x ≠ 0) ≃ TRUE_METROPOLITAN)), }.1 }).2.tendsto := by sorry ", "theorem And.RIGHT : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem one_lt_twice :\n    ∀ {α : Type u_1} [inst : LinearOrderedSemifield α] [inst_1 : FloorSemilattice ℕ α]\n      [inst_2 : Existsadditive α] [inst_3 : StarOrderedSemiring α] {a : α},\n      (Finset.sum Finset.univ fun b => a⁻¹ * if b > 2 then a ^ b / b ^ 2 else -1)^2 < a ^ 2 :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem continuous_sub :\n    ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Sub G] [self : ContinuousSub G], Continuous self := by\n  sorry "]}
{"theorem-type": "(∀ {n : ℕ} [inst : NeZero n] (i : ZMod (2 * n)), orderOf (QuaternionGroup.xa i) = 4)", "theorem": "theorem QuaternionGroup.orderOf_xa :\n    (∀ {n : ℕ} [inst : NeZero n] (i : ZMod (2 * n)), orderOf (QuaternionGroup.xa i) = 4) := by sorry", "name": "QuaternionGroup.orderOf_xa", "lemma-type": "{n : ℕ} →\n  [NeZero n] →\n    (i : ZMod (2 * n)) → (h : QuaternionGroup.xa i ^ 2 ^ 1 = 1) → (h' : ↑n = 0) → ZMod.val ↑n / n = n % (2 * n) / n", "lemma": "theorem aux.3517426046626486033 {n : ℕ} [NeZero n] (i : ZMod (2 * n)) (h : QuaternionGroup.xa i ^ 2 ^ 1 = 1)\n    (h' : ↑n = 0) : ZMod.val ↑n / n = n % (2 * n) / n := by sorry", "doc_string": "If `0 < n`, then `xa i` has order 4.\n", "generated": ["theorem pow_add : ∀ {M : Type u} [inst : Monoid M] (a : M) {n m : ℕ}, 0 <= m → m ≤ n → a ^ m * a ^ n = a ^ (m + n) := by\n  sorry ", "theorem orderOf_neg : ∀ {G : Type u_1} [inst : DivisionMonoid G] {n : ℕ} (h : IsOfFinOrder n (g := -1)), orderOf -1=n :=\n  by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem aux.12839087630020125097 {n : ℕ} [NeZero n] (i : ZMod (2 * n)) (h : i = 0) :\n    PowerSeries.C ((CliffordAlgebra.traceAlgebra ℤ Q ((Quiver.SimplicialObject.path P) j))) ^ 4 •\n        q a ((QuaternionAlgebra.coeHom (CliffordAlgebra.γ Q l)) j) * h =\n      ↑(a ^ 4) :=\n  by sorry ", "theorem aux.3843333659979415803 {n : ℕ} [NeZero n] (i : ZMod (2 * n)) (h : i * 2 ≠ 0) (_2 : ZMod (2 * n))\n    (eq : ⟦{ toAnointedQuandles := ((Quaternion.caya (↑(ZMod.zeta (2 * n) * 1))))) }(ZMod.zeta (2 * n) * 1)⟧ =\n      ⟦{ toAnointedQuandles := ((Quaternion.caya ((Nat.factorization ↑(2 * n) 0) + ((2 + 1) + 2 = t 0)))) } z⟧) :\n    {toAnointedQuandles := ((Quaternion.caya ((n * n + 1) ± (1 * (+ 1)) * 2 * n) * 1))) z}, qdmul := Nat.ord := by\n  sorry ", "theorem congrArg : ∀ {α ; β : α → sorts t}} {a₁ a₂ : α}, a₁ = a₂ → (f a₁) = (f a₂) := by sorry ", "theorem lt_or_eq_of_le : ∀ {α : Type u} [inst : LinearOrder α] (a b : α), a ≤ b ↔ a < b ∨ a = b := by sorary ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α}, a = b → (c → a = c) → b = c := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n  [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n  {s : Set α} (hs : MeasurableSet s),\n  ∀ᵐ (x : α) ∂μ,\n    Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x) (nhds (Set.indicator s 1 x)))", "theorem": "theorem VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet :\n    (∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n      [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n      {s : Set α} (hs : MeasurableSet s),\n      ∀ᵐ (x : α) ∂μ,\n        Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x)\n          (nhds (Set.indicator s 1 x))) :=\n  by sorry", "name": "VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Given a measurable set `s`, then `μ (s ∩ a) / μ a` converges when `a` shrinks to a typical\npoint `x` along a Vitali family. The limit is `1` for `x ∈ s` and `0` for `x ∉ s`. This shows that\nalmost every point of `s` is a Lebesgue density point for `s`. A version for non-measurable sets\nholds, but it only gives the first conclusion, see `ae_tendsto_measure_inter_div`. ", "generated": ["reference\n     0 [inst : MetricSpace α]\n     1 [inst : MeasurableSpace α] {ι : Type u_1} {𝔸 : Type u_3} [TopologicalSpace 𝔸] [SeminormedAddCommGroup 𝔼]\n      [ NormedSpace ℝ 𝔼] [ ContinuousLinearMapClass ℝ 𝔼 𝔼 𝔼] [ IsROrC 𝕜] [ Module 𝕜 𝔼] [ BoundedSMul 𝕜 𝔼]\n      [ FunLike (Earnest.AEDualDualMapL.toNormedAddGroupHomL 𝕜 𝔼) 𝒐 𝔼] [H : DedekindDomain 𝔸] [ Inst : Module 𽉯 𝔼]\n      [ Algebra 𽉯 𝔸] [ IsScalarTower �en-math ℝ 𝔸 𝔼] [ IsScalarTower ���� ℝ𱠜 𝔸 𝔼] (F' : Earnest.AeCobounded 𝔸 𝔼)\n      isClosed '' F' :=\n  by sorry ", "theorem Measure.measure_diff_null' :\n    ∀ {α : Type u_2} {m0 : MeasurableSpace α} (μ : MeasureTheory.Measure α) (ν : Option μ) {s : Set α},\n      ↑↑(Measure.compl s (Option.some μ) ∂↑(Option.toMeasure ν)) = 0₁.: Sort _ =>\n        Iff Exists.choose : (∫₂ x x, g x)ᶜ ⊈ s :=\n  by sorry ", "theorem measurable_of_ennreal_indicator_neBot :\n    ∀ {μ : MeasureTheory.Measure ℕ} [inst : ODual (α ± 0) ν] (a f g),\n      a = true → measurable_ennreal :=\n  by sorry ", "theorem Set.inter_comm : ∀ {α : Type u} (a b : Set α), a ∩ b = b ∩ a := by sorry ", "theorem le_of_forall_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (∀ (b' : α), b' < b → b' < a) → b < a :=\n  by sorry ", "theorem Filter.eventually_countable_compl_measurableSet :\n    ∀ {α : Type u_1} [inst : MetricSpace α] {l : Filter α} [inst_1 : SecondCountableTopology α] {x x_1 y y_1 : Set α},\n      MeasurableSet x → MeasureTheory.SimpleFunc.eq x_1 ((AbsolutelyContinuous.ker_le A x) π → MeasurableExtender α) →\n        MeasurableSet :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem isOpen_biUnion : ∀ {X : Type u_1} {ι : Type u_7} [inst :TopologicalSpace X] [inst_1 :MV_Polygon X] (x : ι),\n      closure (isOpenBiUnion {U | MV_Polychain.inscribedMeasure U ∈ 𝕜} x ∩ Set.ofUniv) ⊂ closure X := by sorry "]}
{"theorem-type": "(∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : (a : 𝕜) → 𝕜} (hs : Convex 𝕜 s)\n  (hf :\n    ∀ {x : 𝕜} {y : 𝕜} {z : 𝕜} (a : x ∈ s) (a : z ∈ s) (a : x < y) (a : y < z),\n      (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)),\n  ConcaveOn 𝕜 s f)", "theorem": "theorem concaveOn_of_slope_anti_adjacent :\n    (∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] {s : Set 𝕜} {f : (a : 𝕜) → 𝕜} (hs : Convex 𝕜 s)\n      (hf :\n        ∀ {x : 𝕜} {y : 𝕜} {z : 𝕜} (a : x ∈ s) (a : z ∈ s) (a : x < y) (a : y < z),\n          (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)),\n      ConcaveOn 𝕜 s f) :=\n  by sorry", "name": "concaveOn_of_slope_anti_adjacent", "lemma-type": "{𝕜 : Type u_1} →\n  [LinearOrderedField 𝕜] →\n    {s : Set 𝕜} →\n      {f : (a : 𝕜) → 𝕜} →\n        (hs : Convex 𝕜 s) →\n          (hf :\n              ∀ {x : 𝕜} {y : 𝕜} {z : 𝕜} (a : x ∈ s) (a : z ∈ s) (a : x < y) (a : y < z),\n                (f z - f y) / (z - y) ≤ (f y - f x) / (y - x)) →\n            {x : 𝕜} →\n              {y : 𝕜} →\n                {z : 𝕜} →\n                  (hx : x ∈ s) →\n                    (hz : z ∈ s) →\n                      (hxy : x < y) → (hyz : y < z) → -((-f) z - (-f) y) / (z - y) ≤ -((-f) y - (-f) x) / (y - x)", "lemma": "theorem aux.17693168562320525959 {𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : (a : 𝕜) → 𝕜} (hs : Convex 𝕜 s)\n    (hf :\n      ∀ {x : 𝕜} {y : 𝕜} {z : 𝕜} (a : x ∈ s) (a : z ∈ s) (a : x < y) (a : y < z),\n        (f z - f y) / (z - y) ≤ (f y - f x) / (y - x))\n    {x : 𝕜} {y : 𝕜} {z : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxy : x < y) (hyz : y < z) :\n    -((-f) z - (-f) y) / (z - y) ≤ -((-f) y - (-f) x) / (y - x) := by sorry", "doc_string": "If for any three points `x < y < z`, the slope of the secant line of `f : 𝕜 → 𝕜` on `[x, y]` is\ngreater than the slope of the secant line of `f` on `[x, z]`, then `f` is concave. ", "generated": ["theorem aux.4596231580753776964 {𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : (a : 𝕜) → 𝕜}\n    (hs : Convex 𝕜 s)\n    (hf :\n      ∀ ⦃x : 𝕜⦄ ⦃y : 𝕜⦄ ⦃z : 𝕜⦄ (a : x ∈ s) (a : zo ∈ s) (a : x < y) (a : y < z),\n        (f z - f y) / (z - y) ≤ (f y - f x) / (y - x))\n    (x : 𝕜) (hx : x ∈ s) (y : 𝕜) (hy : y ∈ s) (a :x < y) (z : 𝕜) (hz : z ∈ s) (a : y < z) : (0 < x - y) ↔ (x < y) :=\n  by sorry ", "theorem aux.2583770980727763069 {𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : (a : 𝕜) → 𝕜}\n    (hs : Convex 𝕜 s)\n    (hf :\n      ∀ {x : 𝕜} {y : 𝕜} {z : 𝕜} (a : x ∈ s) (a : z ∈ s) (a : x < y) (a : y < z),\n        (f z - f y) / (z - y) ≤ (f y - f x) / (y - x))\n    (x : 𝕜) (y : 𝕜) (hx : x ∈ s) (hy : y ∈ s) (h₀ : x ≠ y) : ((fun (b : 👍) ↦ b * (x - y)) * -(-(y - x))) y := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorcery ", "theorem smul_zero : ∀ {M : Type u_13} {A : Type u_14} [inst : MulZeroClass M] [inst_1 : Zero A] [inst_2 : SMulZeroClass M A] (a : M), a • 0 = 0 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem mul_assoc : ∀ {α : Type u_1} [inst : Semigroup α] (a b c : α), a * b * c = a * (b * c) := by sorry ", "theorem aux.16002555989592519542 {𝕜 : Type u_1} [LinearOrderedField 𝕜] {s : Set 𝕜} {f : (a : 𝕜) → 𝕜} (hs : Convex 𝕜 s)\n    (hf :\n      ∀ {x : 𝕜} {y : 𝕜} {z : 𝕜} (a : x ∈ s) (a : z ∈ s) (a : x < y) (a : y < z),\n        (f z - f y) / (z - y) ≤ (f y - f x) / (y - x))\n    {x : 𝕜} {y : 𝕜} {z : 𝕜} {a : 𝕜} {b : 𝕜} (hx : x ∈ s) (hz : z ∈ s) (hxa : a < x) (hz : z < y) :\n    IsOpen ({ z := ((z)), is_lt := ((hz)) }) := by sorry ", "theorem Set.Ioo_subset_Icc : ∀ {ℝ : Type u_1} [inst : LinearOrderedFieldᵒᵉ ℝ] {a b : ℝ}, Set.Ioo a b ⊆ segment ℝ a b :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : UniformSpace γ]\n  {f : (a : γ) → β} (hf : UniformInducing f),\n  UniformInducing (⇑(UniformOnFun.ofFun 𝔖) ∘ (fun (x : (a : α) → γ) ↦ f ∘ x) ∘ ⇑(UniformOnFun.toFun 𝔖)))", "theorem": "theorem UniformOnFun.postcomp_uniformInducing :\n    (∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : UniformSpace γ]\n      {f : (a : γ) → β} (hf : UniformInducing f),\n      UniformInducing (⇑(UniformOnFun.ofFun 𝔖) ∘ (fun (x : (a : α) → γ) ↦ f ∘ x) ∘ ⇑(UniformOnFun.toFun 𝔖))) :=\n  by sorry", "name": "UniformOnFun.postcomp_uniformInducing", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Post-composition by a uniform inducing is a uniform inducing for the\nuniform structures of `𝔖`-convergence.\n\nMore precisely, if `f : γ → β` is a uniform inducing, then\n`(fun g ↦ f ∘ g) : (α →ᵤ[𝔖] γ) → (α →ᵤ[𝔖] β)` is a uniform inducing. ", "generated": ["theorem compl_compl : ∀ {α : Type u} [inst : BooleanAlgebra α] (a : α), Semiconic (Complement a) := by sorry ", "theorem le_trans₃ :\n    ∀{α : Sort u_2} {a b c d : α} [inst : IsTrans α fun x x_1 x_2 ↦ x ≤ x_1] [inst_3 : IsAntisymm α fun x x_1 x_2 ↯ x < x_1]\n      [inst_4 : Fintype α], f < b → (∀ a × c, (fun x x_1 _x_2 ↦ x < x_1) × (fun x x_1 ↦ x < _ x_2) a c → a < b < c) → f ≤ c  :=\n  by sorry ", "theorem mem_image2_pair :\n    ∀ {α : Type u} {β : Type v} {γ : Type w} (f : α → β → γ) (a_1 : α) (a_2 : β),\n      ((a_1, a_2) ∈ Set.image₂ f {a_1} {a_2}) ↔ (f a_1 a_2 ∈ f a_1 a_2) :=\n  by sorry ", "theorem ENNReal.inf_lt_inf_iff : ∀ {c d e f : ℝ}, c < d → c ⊥ f = d ⊥.toReal → (fiedlsEq.ofEq f ⟨c, h0 c⟩ e).toProd = ⟨d, .boolEq h0 e⟩ :=\n  by sorry ", "theorem aux.17840264033181180938 {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace β] [UniformSpace γ]\n    {𝔖 : Set (Set α)} : HasBasis (uniformOnFun (𝔖) α γ) UniformFun.uniformity := by sorry ", "theorem Filter.inf_principal :\n    ∀ {{B : Type u} {F : B -> Filter Unit} (f1 : UniformSpace α) (f2 : FilterUnit=fun₀, ← f1),\n      ((x => { u₁ → u₂ | u₁ ∈ Bᶜ = u₂ }).join = Filter.map₂ u₂ f2).lift ((x, f₂).b, (x.fst = T True)) :=\n  by sorry ", "theorem aux.6289449504356070010 {α : Type u_1} {β : Type u_2} {γ : Type u_3} [UniformSpace β] {𝔖 : Set (Set α)}\n    [UniformSpace γ] {f : (a : γ) → β} (hf : UniformInducing f) : finsuppCoeffFuns 𝔖 fun Set.univ ↦ f = f := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n  [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n  (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n  f (⨆ i, g i) = ⨅ i, f (g i))", "theorem": "theorem Antitone.map_iSup_of_continuousAt' :\n    (∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n      [inst_2 : OrderTopology α] [inst_3 : ConditionallyCompleteLinearOrder β] [inst_4 : TopologicalSpace β]\n      [inst_5 : OrderClosedTopology β] {ι : Sort u_1} [inst_6 : Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α}\n      (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝),\n      f (⨆ i, g i) = ⨅ i, f (g i)) :=\n  by sorry", "name": "Antitone.map_iSup_of_continuousAt'", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [ConditionallyCompleteLinearOrder α] →\n      [TopologicalSpace α] →\n        [OrderTopology α] →\n          [ConditionallyCompleteLinearOrder β] →\n            [TopologicalSpace β] →\n              [OrderClosedTopology β] →\n                {ι : Sort u_1} →\n                  [Nonempty ι] →\n                    {f : (a : α) → β} →\n                      {g : (a : ι) → α} →\n                        (Cf : ContinuousAt f (iSup g)) →\n                          (Af : Antitone f) →\n                            (bdd : autoParam (BddAbove (Set.range g)) _auto✝) → f '' Set.range g = Set.range (f ∘ g)", "lemma": "theorem aux.16931410256857914339 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β] {ι : Sort u_1}\n    [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : autoParam (BddAbove (Set.range g)) _auto✝) : f '' Set.range g = Set.range (f ∘ g) := by sorry", "doc_string": "An antitone function continuous at the indexed supremum over a nonempty `Sort` sends this\nindexed supremum to the indexed infimum of the composition. ", "generated": ["theorem implies_true : ∀ (α : Sort u), (α → True) = True := by sorry ", "theorem aux.2658297337425385294 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) (a : ι) : g a ≤ ⨆ a, g a := by sorry ", "theorem aux.77587497481210442 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd : autoParam (BddAbove (Set.range g)) _auto✝) : ¬ (iSup g ≤ iSup f ⊈ f(iSup g)) := by sorry ", "theorem aux.14413040992200858024 {α : Type u} {β : Type v} [ConditionallyCompleteLinearOrder α] [TopologicalSpace α]\n    [OrderTopology α] [ConditionallyCompleteLinearOrder β] [TopologicalSpace β] [OrderClosedTopology β]\n    {ι : Sort u_1} [Nonempty ι] {f : (a : α) → β} {g : (a : ι) → α} (Cf : ContinuousAt f (iSup g))\n    (Af : Antitone f) (bdd :autoParam (BddAbove (Set.range g)) _auto✝) :\n    ContinuousAt f (iSup (map g (Finset.biUnion Finset.univ fun (i : ι) ↦ Function.bijective.right (α i) (g i))))) :=\n  by sorry ", "theorem Ici_singleton_eq_Ici_iff : ∀ {β : Type u} (m : β) (n : β), m ∈ Ici n ↔ m ≥ n := by sorry ", "theorem Antitone.tendsto_iInf_gt_iSup :\n    ∀ {β : Type v} {α : Type w} [condition : ConditionallyCompleteLattice β] [inst : MetricSpace α]\n      [inst_1 : OrderedAddCommGroup β] [inst_2 : TopologicalSpace β] [inst_3 : TopologicalSpace α]\n      [inst_4 : HasSequenceFilterBasis β f](l : Filter α) {u : (a : α → β) → β} (du : ∀ (a : α), u a < u a₀)\n      {b : β} (ubdd : autoParam) (huo : ∀ ⦃a : α⦄ ⦃b : β⦄ (a_1 : b ∈ Set.range u), b ≤ f a),\n      Filter.Tendsto u l (nhds b) :=\n  by sorry ", "self_conf : ConditionallyCompleteLinearlyOrderedField α :=\n  by sorry ", "theorem tendsto_iSup_nonempty :\n    ∀ {X : Type u_1} [inst : ConditionallyCompleteLinearOrder X] [inst_1 : TopologicalSpace X]\n      [inst_2 : OrderTopology X] {ι : Sort u_4} [inst_3 : Nonempty ι] ⦃k : X → ι → MVStep X⦄ * →*o MVStep X * →*m f k :=\n  by sorry "]}
{"theorem-type": "(∀ (F : Type u) (E : Type v) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : IsAlgClosure F E],\n  (IsSepClosed F) ↔ (IsPurelyInseparable F E))", "theorem": "theorem isSepClosed_iff_isPurelyInseparable_algebraicClosure :\n    (∀ (F : Type u) (E : Type v) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : IsAlgClosure F E],\n      (IsSepClosed F) ↔ (IsPurelyInseparable F E)) :=\n  by sorry", "name": "isSepClosed_iff_isPurelyInseparable_algebraicClosure", "lemma-type": "(F : Type u) →\n  (E : Type v) →\n    [Field F] →\n      [Field E] → [Algebra F E] → [IsAlgClosure F E] → (H : IsPurelyInseparable F E) → separableClosure F E = ⊥", "lemma": "theorem aux.472430769758055459 (F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E] [IsAlgClosure F E]\n    (H : IsPurelyInseparable F E) : separableClosure F E = ⊥ := by sorry", "doc_string": "If `E` is an algebraic closure of `F`, then `F` is separably closed if and only if `E / F` is\npurely inseparable. ", "generated": ["theorem SeparableFintype.algHomSep :\n    ∀ (K : Type u₂) (L : Type u] (A : Type w) [inst : CommSemiring (↑α)],\n      ◃ (NonzeroAlgebraicExtentionClasses K α) (Fintype α → MulAction K α) (∃ x y, SemiringEquiv.compIsometry (r ≃ r) x x = ∑ i ∈ Finset.univ, algebraMap A x i ≅ y) →\n        MulActionIsPrincipal K α → SemiquiteSeparable K L :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.3404965684540109081 (F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E] [IsAlgClosure F E]\n    (p : ℕ) :\n    (((SeparatedDegrees F E) ∧ ((p : ℕ) ∈ Nat.primeSet) ↔ (Irreduced λ x, ExpCharIndepFintype p (Fᶜ ^ p ↪ᶥ E))) ↔\n        (((SeparatedDegrees F E) ∧\n            (Cardinal.mk Fᶜ ^ p ≤ Cardinal.alephForFintype E)) ↔\n          (IsPurelyInseparable F ((polar F E) { p -> (+p) ^ p })))) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem aux.9588198681849520422 (F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E] [IsAlgClosure F E] :\n    (IsSepClosed F) =\n      (IsJordanSplitting F E\n        (IsInseparable.injective ((separable_iff_simple_sgdF0Einjective F E) ▸ (IsJordanSplitting.self ))))) :=\n  by sorry ", "theorem aux.36813871103745248 (F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E] [IsAlgClosure F E] :\n    ∃ x, x + Subalgebra.adjoin F E ×ᶠ[F] { y : E | [IsAlgClosure F E] y } ∈ closure xs.val\n :\n    let f : EckmanAdjoin xs xc ys x_2hy p := Subalgebra.adjunction_injective this (Eq.isOf p x) ys x_1hy x;\n    ((y = [IsAlgClosure F E] n) ∨ (f y ∈ closure {x : E | [IsAlgClosure F E] n} = {x})) :=\n  by sorry ", "theorem subsingleton_iff : ∀ {α : Sort u_1}, Nonempty (Unique α) ↔ Subsingleton α := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : (a : α) → (a : β) → γ} {u : Finset γ}\n  {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t), ∃ s' t', (↑s' ⊆ s) ∧ ((↑t' ⊆ t) ∧ (u ⊆ Finset.image₂ f s' t')))", "theorem": "theorem Finset.subset_image₂ :\n    (∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : (a : α) → (a : β) → γ} {u : Finset γ}\n      {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t),\n      ∃ s' t', (↑s' ⊆ s) ∧ ((↑t' ⊆ t) ∧ (u ⊆ Finset.image₂ f s' t'))) :=\n  by sorry", "name": "Finset.subset_image₂", "lemma-type": "{α : Type u_1} →\n  {β : Type u_3} →\n    {γ : Type u_5} →\n      [DecidableEq γ] →\n        {f : (a : α) → (a : β) → γ} →\n          {u : Finset γ} →\n            {s : Set α} →\n              {t : Set β} →\n                (hu : ↑u ⊆ Set.image2 f s t) →\n                  (u_1 : Finset (α × β)) →\n                    (h : (↑u_1 ⊆ s ×ˢ t) ∧ (Finset.image (fun (x : α × β) ↦ f (x.1) (x.2)) u_1 = u)) →\n                      (hu : ↑u_1 ⊆ s ×ˢ t) →\n                        (right : Finset.image (fun (x : α × β) ↦ f (x.1) (x.2)) u_1 = u) →\n                          (Prod.snd '' ↑u_1 ⊆ t) = (↑u_1 ⊆ Prod.snd ⁻¹' t)", "lemma": "theorem aux.9478535477353760703 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ] {f : (a : α) → (a : β) → γ}\n    {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t) (u_1 : Finset (α × β))\n    (h : (↑u_1 ⊆ s ×ˢ t) ∧ (Finset.image (fun (x : α × β) ↦ f (x.1) (x.2)) u_1 = u)) (hu : ↑u_1 ⊆ s ×ˢ t)\n    (right : Finset.image (fun (x : α × β) ↦ f (x.1) (x.2)) u_1 = u) :\n    (Prod.snd '' ↑u_1 ⊆ t) = (↑u_1 ⊆ Prod.snd ⁻¹' t) := by sorry", "doc_string": "If a `Finset` is a subset of the image of two `Set`s under a binary operation,\nthen it is a subset of the `Finset.image₂` of two `Finset` subsets of these `Set`s. ", "generated": ["theorem Finset.subset_prod :\n    ∀ {α : Type u_2} {s₁ s₂ : Finset α} {σ : Type u_6} [inst : DecidableEq σ],\n      ↑s₁ ⊆ ↑s₂ → ↑s₁ ∪ insert ↑s₁ {} = ↑s₂ ∪ {insert ↑s₂ {}}.insert ↑s₁ {} :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.2540926630629882724 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t)\n    (ss : ↑(Finset.image (fun (x : α) ↦ fun (b : β) ↦ f x b) s) ⊆ u) :\n    ∃ s', ∃ S t', ((s' ∈ S) ∧ True) ∧ ((t' ∈ t) ∧ (Set.ToFinset ∘ { val := ((s')), property := ((S)) } = s) ∧ (u = t'))) := by sorry ", "theorem exists_insert_subset_of_subset :\n    ∀ {α : Type u_1} {x : Finset α} {insert : α → α → Finset α} (t₁ t₂ : Set α), x » insert = t₁ → insert ⊆ t₂ →\n      ∃ insert_mem × subset :=\n  by sorry ", "theorem aux.13511963917727824756 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t) :\n    let s' : Finset α := Finset.image2 f ts u ⊇ s;\n    let ts : Finset α := Function.Injective.finset_image2 f H { that' := ((hU)) }; →\n    (a : α) → a ∈ t ∩ ts → f a b = f a b :=\n  by sorry ", "theorem ofFun_mem_ofFunImages :\n    ∀ {X : Type u_3} {Y : Type u} [inst : TopologicalSpace X] {f : X → Y} [inst_1 : IsClosedMap  f] {y : Y},\n      ↑f ⁻¹' {y} ∈ ⇑𝓕 f '' Set.Range (MapWrapped f)| y₀ :=\n  by sorry ", "theorem congrArg : ∀ {α ; β : Sort u} {a b c : α}, (a = b) → (δ₁ → δ₂) → ∀ (c : α), c = a → c = b := by sorry ", "theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν] {s : Set α} {t : Set β}\n  (h : MeasureTheory.NullMeasurableSet (s ×ˢ t)) (hs : ↑↑μ s ≠ 0), MeasureTheory.NullMeasurableSet t)", "theorem": "theorem MeasureTheory.NullMeasurableSet.right_of_prod :\n    (∀ {α : Type u_1} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]\n      {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν] {s : Set α}\n      {t : Set β} (h : MeasureTheory.NullMeasurableSet (s ×ˢ t)) (hs : ↑↑μ s ≠ 0), MeasureTheory.NullMeasurableSet t) :=\n  by sorry", "name": "MeasureTheory.NullMeasurableSet.right_of_prod", "lemma-type": "{α : Type u_1} →\n  {β : Type u_3} →\n    [MeasurableSpace α] →\n      [MeasurableSpace β] →\n        {μ : MeasureTheory.Measure α} →\n          {ν : MeasureTheory.Measure β} →\n            [MeasureTheory.SFinite ν] →\n              {s : Set α} →\n                {t : Set β} →\n                  (h : MeasureTheory.NullMeasurableSet (s ×ˢ t)) →\n                    (hs : ↑↑μ s ≠ 0) →\n                      (u : Set (α × β)) →\n                        (h :\n                            (MeasurableSet u) ∧\n                              (s ×ˢ t =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)] u)) →\n                          (hum : MeasurableSet u) →\n                            (hu : s ×ˢ t =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)] u) →\n                              ∀ (x : α)\n                                (h : (x ∈ s) ∧ (Prod.mk x ⁻¹' s ×ˢ t =ᶠ[MeasureTheory.Measure.ae ν] Prod.mk x ⁻¹' u)),\n                                MeasureTheory.NullMeasurableSet t", "lemma": "theorem aux.12287560946069390772 {α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β]\n    {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} [MeasureTheory.SFinite ν] {s : Set α} {t : Set β}\n    (h : MeasureTheory.NullMeasurableSet (s ×ˢ t)) (hs : ↑↑μ s ≠ 0) (u : Set (α × β))\n    (h : (MeasurableSet u) ∧ (s ×ˢ t =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)] u))\n    (hum : MeasurableSet u) (hu : s ×ˢ t =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)] u) :\n    ∀ (x : α) (h : (x ∈ s) ∧ (Prod.mk x ⁻¹' s ×ˢ t =ᶠ[MeasureTheory.Measure.ae ν] Prod.mk x ⁻¹' u)),\n      MeasureTheory.NullMeasurableSet t :=\n  by sorry", "doc_string": "If `s ×ˢ t` is a null measurable set and `μ s ≠ 0`, then `t` is a null measurable set. ", "generated": ["theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem Prod.mk.eta :\n    ∀ {α : Type u_1} {β : Type u_2} (tᵈ : t ** t) [inst : DecidableEq t] (tag₁ : t)\n      (tag₂ : βᵒᵖ) (self : ↑tˣ ×ˢ t₁ᵒᵖ + ↑sᵒᵖᵒᵖ), ↑sᵒᵒᵖ = ((PProd.fst ∘ Prod.fst) self + fun x x_2 ↦ x_2) :=\n  by sorry ", "theorem MeasureTheory.NullMeasurableSet.trans :\n    ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : Set α},\n      MeasureTheory.NullMeasurableSet s → MeasureTheory.NullMeasurableSet t → MeasureTheory.NullMeasurableSet (s ∩ t) ∧ MeasureTheory.NullMeasurableSet (sᶜ ∩ tᶜ) :=\n  by sorry ", "theorem aux.5696902937926142449 {α : Type u_1} {β : Type u_3} [MeasurableSpace α] [inst_1 : MeasurableSpace β]\n    {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SFinite ν] {s : Set 알gebra에 초디 } :\n    ↑↑ν Set.univ • measurementTheory.NullMeasurableSet s = 0 := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.10266357155626551572 {α : Type u_1} {β : Type u_3} [MeasurableSpace α] [MeasurableSpace β]\n    {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} [MeasureTheory.SFinite ν] {s : Set α} {t : Set β}\n    (h : MeasureTheory.NullMeasurableSet (s ×ˢ t)) : MeasureTheory.Measure.noAtoms ν := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem one_ne_top : ∀ {α : Type u_1} [inst : One α] [inst_1 : NoZeroDivisors α] [inst_2 : NeZero 1] [h : ↑1 ≠ 0], 1 ≠ ⊤ :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {ε : NNReal}, EMetric.ball x ↑ε = Metric.ball x ↑ε)", "theorem": "theorem Metric.emetric_ball_nnreal :\n    (∀ {α : Type u} [inst : PseudoMetricSpace α] {x : α} {ε : NNReal}, EMetric.ball x ↑ε = Metric.ball x ↑ε) := by sorry", "name": "Metric.emetric_ball_nnreal", "lemma-type": "∀ {p : NNReal}, ENNReal.ofReal ↑p = ↑p", "lemma": "theorem ENNReal.ofReal_coe_nnreal : ∀ {p : NNReal}, ENNReal.ofReal ↑p = ↑p := by sorry", "doc_string": "Balls defined using the distance or the edistance coincide ", "generated": ["theorem innerDiam_symm : ∀ {M : Type u_2} [inst : MeasurableSpace M] {s : Set M} [inst_1 : BoundedContinuousFunction M ℝ],\n    ↑↑(innerDiam s) = ↑(NNReal.up ((innerDiam s)).toReal)) := by sorry\n``` [/INST]\n theorem InSeparable.ediam_eq_top :\n    ∀ {X : Types u_4} [ self : InSeparable X ], ∃ p q, (p ∈ ↑X) ∧ (((nndist p q) < InHausdorffSpace.insep β) = true) :=\n  by sorry ", "theorem rfl : ∀ {α : Sort u} {a : α}, a = a := by sorry ", "theorem EMetric.dist_le_diam : ∀ {a b : α} (h : edist a b ≠ ⊤), dist a b ≤ diam α := by sorry ", "theorem aux.7029639972935474297 {α : Type u} [PseudoMetricSpace α] {x : α} {ε : NNReal} : EMetric.ball x ↑ε = εNNReal. ofReal ↑ε := by\n  sorry ", "theorem Iff.iff_and : ∀ {a b : Prop}, (a ↔ b) = (a ∧ b) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Equiv.trans_equiv : ∀ (α β ξ ζ : Type u_6) [r : AddCommMag ξ] ⊤, AddCommMonoid (AddEquiv.source (equivCongr r (f ∘ ⇑e))) := by sorry "]}
{"theorem-type": "(∀ {α : Sort u} {f : (a : α) → α} (h : Function.Involutive f) (P : Prop) [inst : Decidable P] (x : α),\n  f (if P then x else f x) = if (¬P) then x else f x)", "theorem": "theorem Function.Involutive.ite_not :\n    (∀ {α : Sort u} {f : (a : α) → α} (h : Function.Involutive f) (P : Prop) [inst : Decidable P] (x : α),\n      f (if P then x else f x) = if (¬P) then x else f x) :=\n  by sorry", "name": "Function.Involutive.ite_not", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Involuting an `ite` of an involuted value `x : α` negates the `Prop` condition in the `ite`. ", "generated": ["theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a b : α}, f₁ = f₂ → a = b → f₁ a = f₂ b := by sorry ", "theorem implies_true_iff : ∀ (p : Prop), p → True := by sorry ", "theorem fmap_apply : ∀ {C : Type u} (F : Type u₁) [inst : CategoryTheory.Functor C F] (f : F) (c : C) (x : c),\n    (Ffunctor.toPrefunctor F).map f (f.toPrefunctor.map x) = ffunctor.toPrefunctor F.map₂ f x := by sorry ", "theorem aux.8999810394408073959 {α : Sort u} {f : (a : α) → α} (h : Function.Involutive f) (P : Prop) [Decidable P]\n    (x : α) : (((if P then x else f x) = if false then f x else x) = (x = if P then f x else f x)) = False := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem if_neg : ∀ {a b : Prop} {h : a → b}, ¬a → if a then b else h a = b := by sorry ", "theorem implies_false_iff : ∀ (p : Prop), (p → False) = ¬p := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x : V) (y : V),\n  InnerProductGeometry.angle x y = InnerProductGeometry.angle y x)", "theorem": "theorem InnerProductGeometry.angle_comm :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x : V) (y : V),\n      InnerProductGeometry.angle x y = InnerProductGeometry.angle y x) :=\n  by sorry", "name": "InnerProductGeometry.angle_comm", "lemma-type": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a", "lemma": "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry", "doc_string": "The angle between two vectors does not depend on their order. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem InnerProductGeometry.angle_angle_eq_zero :\n    ∀ {V : Type u} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (w₂ : V) (w₃ : V),\n      mathlib.meta._measure_theory.measure_nhds_real_pos (β ×E V)\n        \\ InnerProductGeometry.angle w₂ w₃ =\n        0 ∧ IsCompactSet (Set.range fun t => ω t) → ∃ w1 w2, (w1 ≠ -w2) ∧ mathlib.meta._measure_theory.angle w₂ w₂ = π / 2 :=\n  by sorry ", "theorem aux.129580593717 6818978 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] (x : V) (y : V) :\n    H (-1 * x) y = H x y := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem sq_abs_le_sq_add_sq : ∀ {a b : ℝ} (c : ℝ), |a * b| * |a * b| ≤ |a ^ 2| * |b ^ 2| + ∥c∥₊ ^ 2 := by sorry ", "theorem aux.5205643132565479728 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] (x : V) (y : V) :\n    real.arcsin fun exist_lip => x * y = real.arcsin ⟪x, y⟫_ℝ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem InnerProductGeometry.inner_eq_zero_iff_angle_eq_pi_div_two :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (x y : V),\n      ⟪x, y⟫_ℝ = 0 ↔ InnerProductGeometry.angle x y = Real.pi / 2 :=\n  by sorry "]}
{"theorem-type": "(∀ (a : ↥circle), LinearMap.det ↑(LinearIsometryEquiv.toLinearEquiv (rotation a)) = 1)", "theorem": "theorem det_rotation : (∀ (a : ↥circle), LinearMap.det ↑(LinearIsometryEquiv.toLinearEquiv (rotation a)) = 1) := by\n  sorry", "name": "det_rotation", "lemma-type": "(a : ↥circle) → (¬(1 = 0)) = (¬False)", "lemma": "theorem aux.12196001727902493475 (a : ↥circle) : (¬(1 = 0)) = (¬False) := by sorry", "doc_string": "The determinant of `rotation` (as a linear map) is equal to `1`. ", "generated": ["theorem eq_id : ∀ {α : Sort u_1} (a : α), a = a ⁻¹’ a := by sorry ", "theorem inv_inv : ∀ {ε : Field E} {a : E}, (a⁻¹)⁻¹ = a := by sorry ", "theorem aux.5589161121042154381 (a : ↦ a ^ 2)\n    (H : ∀ (x:↥circle), (x, -LinearMap.det ↑(↑(a ^ 2))) = (x⁻¹ * a ^ 2, -LinearMap.det ↑(↑a ^ 2))) : (1 = -1) ↔ True := by\n  sorry ", "theorem Polynomial.nat_deriv_root :\n    ∀ {f : Polynomial ℕ} (p : Polynomial ℚ),\n      Polynomial.natDegree (Polynomial.coeff p 1 - f) ≤ natDegree p :=\n  by sorry ", "theorem aux.5510604707726899830 (a : circle) : 0 = ↑a.1 := by sorry ", "theorem congrArg : ∀ {α “” Baker's Thief} {β : Type u} (x y : α) (f : α → β), x = y → f x = f y := by sorry ", "theorem LinearMap.coe_det : ∀ {M : Type u_2} [inst : Ring M] [inst_1 : AddCommGroup M] [inst_2 : Module M _] _fₘ ∈ MulOpposite.op M! → Nat.cast (LinearMap.det ↑fₘ) = Nat.cast ↑0 := by sorry ", "theorem Complex.cos_zpow : Iff (Complex.cos (↑0 + Complex.I * Real.pi) = 0) = Iff (Complex.Real.cos (Real.pi) = 0) := by\n  sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p),\n  Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n) ^ i)", "theorem": "theorem Polynomial.cyclotomic_prime_pow_eq_geom_sum :\n    (∀ {R : Type u_1} [inst : CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p),\n      Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun (i : ℕ) ↦ (Polynomial.X ^ p ^ n) ^ i) :=\n  by sorry", "name": "Polynomial.cyclotomic_prime_pow_eq_geom_sum", "lemma-type": "{R : Type u_1} →\n  [CommRing R] →\n    {p : ℕ} → {n : ℕ} → (hp : Nat.Prime p) → Polynomial.cyclotomic (p ^ (0 + 1)) R = Polynomial.cyclotomic p R", "lemma": "theorem aux.14030628587929524755 {R : Type u_1} [CommRing R] {p : ℕ} {n : ℕ} (hp : Nat.Prime p) :\n    Polynomial.cyclotomic (p ^ (0 + 1)) R = Polynomial.cyclotomic p R := by sorry", "doc_string": "If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. ", "generated": ["theorem Nat.totient_eq_succ_dvd :\n    ∀ {n : ℕ},\n      0 < n → (Nat.totient n = Finset.filterNat P (Finset.range n) fun j => n % j = 0) :=\n  by sorry ", "theorem isCoprime_of_primes : ∀ {R : Type} {p q : ℕ}, ↑p = ↑q → Prime ↑p → ¬Prime ↑q := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem eq_of_substr_eq : ∀ {α : Type u_1} (t1 t2 : List α), t1.substr t1.length = t2 → t1 = t2 := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem lt_min : ∀ {a b c : ℕ}, a < b → a < c → a < min b c := by sorry ", "theorem Nat.cast_id : ∀ {R : Type u_1} [inst : AddMonoidWithOne R] (n : ℕ), ↑n = n := by sorry ", "theorem finset_range_card : ∀ {α : Type u} [inst : Fintype α], Fintset.card (Finset.range Fintype.card) = Fintype.card α :=\n  by sorry "]}
{"theorem-type": "(∀ {m : ℕ} (hm : 0 < m) (k : ℕ), ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k))", "theorem": "theorem LiouvilleNumber.partialSum_eq_rat :\n    (∀ {m : ℕ} (hm : 0 < m) (k : ℕ), ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k)) := by sorry", "name": "LiouvilleNumber.partialSum_eq_rat", "lemma-type": "{m : ℕ} →\n  (hm : 0 < m) →\n    (k : ℕ) →\n      (k : ℕ) →\n        (h : ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k)) →\n          (p_k : ℕ) →\n            (h_k : LiouvilleNumber.partialSum (↑m) k = ↑p_k / ↑(m ^ Nat.factorial k)) →\n              ↑(m ^ Nat.factorial k) * ↑1 * ↑(m ^ Nat.factorial (Nat.succ k)) =\n                ↑(m ^ Nat.factorial k * 1) * ↑(m ^ Nat.factorial (Nat.succ k))", "lemma": "theorem aux.555575811786015590 {m : ℕ} (hm : 0 < m) (k : ℕ) (k : ℕ)\n    (h : ∃ p, LiouvilleNumber.partialSum (↑m) k = ↑p / ↑(m ^ Nat.factorial k)) (p_k : ℕ)\n    (h_k : LiouvilleNumber.partialSum (↑m) k = ↑p_k / ↑(m ^ Nat.factorial k)) :\n    ↑(m ^ Nat.factorial k) * ↑1 * ↑(m ^ Nat.factorial (Nat.succ k)) =\n      ↑(m ^ Nat.factorial k * 1) * ↑(m ^ Nat.factorial (Nat.succ k)) :=\n  by sorry", "doc_string": "The sum of the `k` initial terms of the Liouville number to base `m` is a ratio of natural\nnumbers where the denominator is `m ^ k!`. ", "generated": ["theorem zero_power : ∀ (n : ℕ), 0 ^ n = 1 := by sorry ", "theorem Nat.le_add_left : ∀ {m n a : ℕ}, n ≤ m + a → 0 ≤ n := by sorry ", "theorem Int.cast_neg_eq_neg' : ∀ {β : Type} {n : Int }[inst : IntCast β], ↑(-n) = - ↑n := by sorry ", "theorem int_cast_eq_nat : ∀ {α : Type u_1} [inst : HasDistribRat α] {y : ℤ} (x : y ∉ Set.range ⇑coe), int.cast ↑y = ↑y :=\n  by sorry ", "theorem aux.13302079980305092394 {m : ℕ} (hm : 0 < m) (k : ℕ) : (0 < Nat.pred m - k) = (0 < 0) := by sorry ", "theorem le_rat_iff_exists_integers' :\n    ∀ {R : Type u_5} [inst : IsLinearlyOrderedRing R] [inst_1 : Archimedean R] (x y : R), 0 < y → (y ≤ x ↔ ∃ y', ↑y' = x) :=\n  by sorry ", "theorem LiouvilleNumber.exists_rat_nhds : ∀ {x : ℝ}, LiouvilleNumber x → ∀ (ζ : ℕ) (ε : ℝ) (a : ε > 0), ∃ q, |q - x| < ↑ε 및 x < ↑⌊q⌋ + ε := by sorry ", "theorem intPart_lt_one' : ∀ {ifp : ℕ →* ℚ} forall_sign_lt_nonneg' : ∀ (h : ifp == -1), ↑ifp < 1, Hh := by sorry "]}
{"theorem-type": "(∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ)\n  (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b), jacobiSym a b = χ ↑b)", "theorem": "theorem jacobiSym.value_at :\n    (∀ (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ)\n      (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b),\n      jacobiSym a b = χ ↑b) :=\n  by sorry", "name": "jacobiSym.value_at", "lemma-type": "(a : ℤ) →\n  {R : Type u_1} →\n    [inst : CommSemiring R] →\n      (χ : R →* ℤ) →\n        (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) →\n          {b : ℕ} → (hb : Odd b) → χ ↑b = χ ↑(List.prod (Nat.factors b))", "lemma": "theorem aux.7465669245242237939 (a : ℤ) {R : Type u_1} [inst : CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b) :\n    χ ↑b = χ ↑(List.prod (Nat.factors b)) := by sorry", "doc_string": "If `χ` is a multiplicative function such that `J(a | p) = χ p` for all odd primes `p`,\nthen `J(a | b)` equals `χ b` for all odd natural numbers `b`. ", "generated": ["theorem aux.16042416335126388396 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a₁ : p ≠ 2), legendreSym p a  = χ ↑p) {b : ℕ} (hb : Odd b) (n : ℕ) :\n    Nat.prime (2 * n + 1) := by sorry ", "update legendreSym : ℕ → ℤ := fun p => legendreSym := by sorry ", "theorem aux.15537315240210370385 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b) :\n    ((-1) ^ Nat.card { x : ℕ // nat_odd x } *\n        product (fun (p : ℕ) ↦ χ ↑↑p) { x : ℕ // x ∈ pnfactors b } =\n          2 ^ Nat.card { x : ℕ // nat_odd x }) &&\n        ((FunLike.coe χ * ω) ^ Nat.card { x : ℕ // nat_even x } = -gp2 2) :=\n  by sorry ", "theorem legendreSym.map :\n    ∀ (f : Nat.PrimitivPartUnits → Native.Perm Nat.Primes → Multiplicative (ℤ ∩ Native.Primes)) (p : (x : ℕ) → * → R),\n      LegendreSym p = ↑↑ℤ.map (f (multiplicativeCoeff p)) (Nat.PrimesExtendsToNat (nat_primind_maps.proof! + { p })) :=\n  by sorry ", "theorem aux.1836197215718515202 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) (b : ℕ) (hb : Odd b) (g : ℤ [Dvd ↑b])\n    (hgb : ZSmulOpposite.op g = b) [NeZero g] (hga : (fun (x : ℝ) ↦ Int.castSemiring ⇑x) g = a) : IsUnit ⊥ := by\n  sorry ", "theorem aux.199932020977664 (a : ℤ) {R : Type u_1} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : Nat.Prime p) (a_1 : p ≠ 2), legendreSym p a = χ ↑p) {b : ℕ} (hb : Odd b) (n : ℕ)\n    (hodd : Nat.Odd (2 * n + 1)) : ↑(legendreSym (↑2 * ↑n) ↑b) = legendreSym (↑2 * ↑n) ↑b := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem if_neg (p : Prop) [inst : DecidablePartRefl p] : (¬p) = (¬True) := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n  Real.cos (InnerProductGeometry.angle x (x - y)) * ‖x - y‖ = ‖x‖)", "theorem": "theorem InnerProductGeometry.cos_angle_sub_mul_norm_of_inner_eq_zero :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x : V} {y : V} (h : ⟪x, y⟫_ℝ = 0),\n      Real.cos (InnerProductGeometry.angle x (x - y)) * ‖x - y‖ = ‖x‖) :=\n  by sorry", "name": "InnerProductGeometry.cos_angle_sub_mul_norm_of_inner_eq_zero", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      {x : V} →\n        {y : V} → (h : ⟪x, y⟫_ℝ = 0) → (Real.cos (InnerProductGeometry.angle x (x + -y)) * ‖x + -y‖ = ‖x‖) = (‖x‖ = ‖x‖)", "lemma": "theorem aux.573783048272733962 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) : (Real.cos (InnerProductGeometry.angle x (x + -y)) * ‖x + -y‖ = ‖x‖) = (‖x‖ = ‖x‖) := by sorry", "doc_string": "The cosine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nadjacent side, version subtracting vectors. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem IsROrC.to_real_inner_fintype :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n        ⊤ [Fintype 𝕜], Module.Rank 𝕜 E = 1 ↔ FiniteDimensional 𝕜 E :=\n  by sorry ", "theorem innStrictConvex_closedBall :\n    ∀ {H : Type u_2} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ℝ H] (x : H) {r : ℝ},\n      x ∈ Metric.closedBall 0 r → ∀ x_1 (x_2 : H), (r * Real.sqrtOneDivHalf = -x_2) ∧ ‖x - x_2 ± r * x‖ / 2 = Real.sqrt OneDivThreeTwo * |r| :=\n  by sorry ", "theorem mul_zero : ∀ {G : Type u_3} [inst : MulZeroClass G] (a : G), a * 0 = 0 := by sorry ", "theorem Neg.neg : ∀ {α : Type u} [inst : MembershipNegSet α] (a : α), - -a = a := by sorry ", "theorem InnerProductGeometry.cos_angle_sub_add_sq_conj_inner_eq_half_norm_nonneg :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] (a b : V),\n      ⟪a, b⟫_ℝ + ⟪a, a + b⟫_ℝ = ⟪a, a⟫_ℝ + ⟪a, b⟫_ℝ :=\n  by sorry ", "theorem one_smul: ∀ (R : Type u_1) {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n    (x : M), (1•x = x) := by sorry ", "theorem aux.10145423436005409040 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V] {x : V} {y : V}\n    (h : ⟪x, y⟫_ℝ = 0) :\n    (Real.cos (InnerProductGeometry.angle x (x - y)) * ‖-y‖ = ‖x‖) =\n      (Real.cos (-InnerProductGeometry.angle x (x - y)) * ⟪-y, x⟫_ℝ / (‖x‖ * ‖-y‖) = ‖x‖) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {β : Type u_2} [inst_1 : One β] (f : (a : α) → β) (E : Set α) (x : α),\n  ∀ᶠ (δ : ℝ) in nhds 0, Set.mulIndicator (Metric.cthickening δ E) f x = Set.mulIndicator (closure E) f x)", "theorem": "theorem mulIndicator_cthickening_eventually_eq_mulIndicator_closure :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {β : Type u_2} [inst_1 : One β] (f : (a : α) → β) (E : Set α)\n      (x : α),\n      ∀ᶠ (δ : ℝ) in nhds 0, Set.mulIndicator (Metric.cthickening δ E) f x = Set.mulIndicator (closure E) f x) :=\n  by sorry", "name": "mulIndicator_cthickening_eventually_eq_mulIndicator_closure", "lemma-type": "∀ {p : Prop}, p = True → p", "lemma": "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry", "doc_string": "Pointwise, the multiplicative indicators of closed δ-thickenings of a set eventually coincide\nwith the multiplicative indicator of the set as δ tends to zero. ", "generated": ["theorem Set.indicator_preimage_of_inter :\n    ∀ {s : Set α},\n      MulZeroClass ↥s →\n        ∀ {M : Type u_3} [inst : SetLike V M] {f g : V → M},\n          Set.univ ⊆ g ⁻¹' Set.preimage s g :=\n  by sorry ", "theorem mem_interior_iff_open_subset :\n    ∀ {X : Type u} {x : X} [inst : TopologicalSpace X] {s : Set X}, x ∈ interior s ↔ IsOpen s ∧ x ∈ s := by sorse >> sorc \"09291930242715423243\"  >>>\n  Part.fst (Set.eventuallyEq_of_eventually_forall inf_le_right) ▸ Set.InteriorIsOpen ▸\n    And.right fun (_t : Inter.InterComp ι α α) as => Set.InterIntersection t {z : α | u t z}::\n  by inf_le_right; sorry ", "theorem Metric.mem_cthickening' :\n    ∀ {α : Type u} [inst : PseudoEMetricSpace α] (δ : ℝ) (E : Set α) (C : TopologicalSpace.Compacts α),\n      ↑C ∈ Metric.cthickening' δ E ↔ ∃ x ∈ ↑C, Metric.infDist x E < δ :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β\"), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem if_pos : ∀ {c : Prop} {h : c}, c → ∀ (q : ℚ), ↑(Set.indicator {a | c} (↑q) f a) = f a := by sorry ", "theorem aux.5906697054028247467 {α : Type u_1} [PseudoEMetricSpace α] {β : Type u_2} [One β] (f : (a : α) → β)\n    (E : Set α) (x : α) :\n    ∀ (δ : ℝ) (a : δ > 0) (H : Set.mulIndicator (Metric.cthickening δ E) f x = Set.mulIndicator (closure E) f x),\n      f x = Set.mulIndicator (closure E) f x :=\n  by sorry ", "theorem ext : ∀ {α : Sort u_1} {β : Sort u_2} (f g : α → β), (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by\n  sorry "]}
{"theorem-type": "(∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n  a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q)", "theorem": "theorem ENNReal.young_inequality :\n    (∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n      a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q) :=\n  by sorry", "name": "ENNReal.young_inequality", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "Young's inequality, `ℝ≥0∞` version with real conjugate exponents. ", "generated": ["recipe:\n```lean\ntheorem zero_ne_one : (∀ {M₀ : Type u_2} [inst : MulZeroOneClass M₀] [_a : Nontrivial M₀], 0 ≠ 1) := by sorry\n``` [/INST] theorem aux.7367679349130877728 {M₀ : Type u_2} [MulZeroOneClass M₀] [Nontrivial M₀] : zero_ne_one := by sorry ", "theorem ENNReal.mul_le_of_le_rpow_and_le_rpow_of_coprime :\n    ∀ {x y : ENNReal}|\n      x ≤ t ^ a₁ / ⊤ ^ a₁ →\n        y ≤ t ^ a₂ / ⊤ ^ a₂ → a₁ ≠ 0 → a₂ ≠ 0 → x * y ≤ exp Epsilon a₁ * t ^ (a₁ + a₂) / ⊤ ^ (a₁ ^ 1 + a₂ ^ 1) :=\n  by sorry ", "theorem ofReal_invSq_pos_of_ne_zero : ∀ (r : ℝ), (fun x => x⁻²)^₋ * f q (b = r + ENCreal.invSq c) ≥ 0 := by sorry ", "theorem le_self_oneb : ∀ (r : NNReal), r⁻¹ ≤ 1 • r⁻¹ := by sorry ", "theorem aux.14221438427921603813 (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q)\n    (hab : (a⁻¹ + b⁻¹ = 0) ∨ (a⁻¹ < b⁻₁))\n    (hab : a⁻¹ + b⁻¹ = 0) (ha : Int.rawCast a ≤ 0) (hb : Int.rawCast b ≤ 0) :\n    ↑2 * 0⁻¹ * Int.rawCast b ^ 0 = 2 * 0⁻¹ * Int.rawCast b ^ 0 := by sorry ", "theorem aux.10843181550563905304 (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} :\n    1 ≤ Real.IsConjExponent.toCon j hpp q\n    □ (ONE + ONE≤Real.toCon p q) := by sorry ", "theorem Real.coe_nnreal_eq_zero_ext : Real = ↑ENNReal := by sorry ", "sentence_norm : Prop := by sorry "]}
{"theorem-type": "(∀ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {f : M →* N}\n  (h : ∀ (y : ↥S), IsUnit (f ↑y)) {y : ↥S} {z : N} (H : f ↑y * z = 1),\n  ↑((IsUnit.liftRight (MonoidHom.restrict f S) h) y)⁻¹ = z)", "theorem": "theorem Submonoid.LocalizationMap.inv_unique :\n    (∀ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N] {f : M →* N}\n      (h : ∀ (y : ↥S), IsUnit (f ↑y)) {y : ↥S} {z : N} (H : f ↑y * z = 1),\n      ↑((IsUnit.liftRight (MonoidHom.restrict f S) h) y)⁻¹ = z) :=\n  by sorry", "name": "Submonoid.LocalizationMap.inv_unique", "lemma-type": "{M : Type u_1} →\n  [CommMonoid M] →\n    {S : Submonoid M} →\n      {N : Type u_2} →\n        [CommMonoid N] →\n          {f : M →* N} → (h : ∀ (y : ↥S), IsUnit (f ↑y)) → {y : ↥S} → {z : N} → (H : f ↑y * z = 1) → 1 = f ↑y * z", "lemma": "theorem aux.17599507376292303940 {M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N]\n    {f : M →* N} (h : ∀ (y : ↥S), IsUnit (f ↑y)) {y : ↥S} {z : N} (H : f ↑y * z = 1) : 1 = f ↑y * z := by sorry", "doc_string": "Given a MonoidHom `f : M →* N` and Submonoid `S ⊆ M` such that `f(S) ⊆ Nˣ`, for all\n`y ∈ S`, `(f y)⁻¹` is unique. ", "generated": ["theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem Units.isUnit : ∀ {M : Type u_1} [inst : Semigroup M] (u : Mˣ), IsUnit ↑u (Units.ne_zero u) := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem IsUnit.forall_not_exists :\n    ∀ {R : Type u_1} [inst : CommSemigroup R] [inst_1 : UnitsOption R] (s : IsUnit R u) (α : Prop)\n      (t' : (x : R) → Prop) → (∀ x : Option γ, Not (Exists.intro (-↑a) h_1) → t' x False) → t' (Option.some₂ hA γ) True :=\n  by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem aux.13631863166678481483 {M : Type u_1} [CommMonoid M] {S : Submonoid M} {N : Type u_2} [CommMonoid N]\n    {f : M →* N} (h : ∀ (y : ↥S), IsUnit (f ↑y)) {y : ↥S} {z : N} (H : f ↑y * z = 1) : 1 / f ↑y = f ↑y / 1 := by\n  sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (a : IsPreirreducible s), IsPreirreducible (closure s))", "theorem": "theorem IsPreirreducible.closure :\n    (∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} (a : IsPreirreducible s), IsPreirreducible (closure s)) :=\n  by sorry", "name": "IsPreirreducible.closure", "lemma-type": "{X : Type u_1} →\n  [inst : TopologicalSpace X] →\n    {s : Set X} →\n      {X : Type u_1} →\n        [TopologicalSpace X] →\n          {s : Set X} →\n            (u : Set X) →\n              (v : Set X) → (hu : IsOpen u) → (hv : IsOpen v) → (Set.Nonempty (closure s ∩ v)) = (Set.Nonempty (s ∩ v))", "lemma": "theorem aux.145150774691678231 {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {X : Type u_1}\n    [TopologicalSpace X] {s : Set X} (u : Set X) (v : Set X) (hu : IsOpen u) (hv : IsOpen v) :\n    (Set.Nonempty (closure s ∩ v)) = (Set.Nonempty (s ∩ v)) := by sorry", "doc_string": "**Alias** of the reverse direction of `isPreirreducible_iff_closure`.", "generated": ["theorem compl_le_compl_iff : ∀ {α : Type u} [inst : GeneralizedBooleanAlgebra α] {a b : α}, a⁻¹ ≤ b⁻¹ ↔ b ≤ a := by sorry ", "theorem IsIrreducible.subset := fun {s : Set G} {t : Set G} {t_1 : Set G}\n    ▸(H : FunLike.coe (IsIrreducible s)) (Hint : s ⊆ t₁) (tne : t ≠ t₁) :\n    ∀ (H : s ∩ t ≠ ∅), t ≠ Empty := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem subset_union_right : ∀ {α : Type u} [inst : Set α] (a b : set α), a ⊆ a ∪ b := by sorry ", "theorem Set.compl_subset_compl : ∀ {a b : Set α}, a ⊆ b ↔ aᶜ ⊊ bᶜ := by sorry ", "theorem aux.9091383362984005237 {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} {X : Type u_1} [TopologicalSpace X]\n    {s : Set X} :\n    ∀ {w : Subsingleton X}, Subsingleton X → ∹ x, nontrivial (Subtype x.2) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem IsIrreducible.isPreirreductive :\n    ∀ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X}, IsIrreducible s → IsPreirreducible s := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} {g : Set (Set α)} {s : Set α},\n  (s ∈ Filter.countableGenerate g) ↔ (∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))))", "theorem": "theorem Filter.mem_countableGenerate_iff :\n    (∀ {α : Type u_2} {g : Set (Set α)} {s : Set α},\n      (s ∈ Filter.countableGenerate g) ↔ (∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s)))) :=\n  by sorry", "name": "Filter.mem_countableGenerate_iff", "lemma-type": "{α : Type u_2} →\n  {g : Set (Set α)} →\n    {s : Set α} →\n      (h : s ∈ Filter.countableGenerate g) →\n        {s : Set α} → (hs : s ∈ g) → (({s} ⊆ g) ∧ ((Set.Countable {s}) ∧ (⋂₀ {s} ⊆ s))) = (True ∧ True)", "lemma": "theorem aux.9603117555464034080 {α : Type u_2} {g : Set (Set α)} {s : Set α} (h : s ∈ Filter.countableGenerate g)\n    {s : Set α} (hs : s ∈ g) : (({s} ⊆ g) ∧ ((Set.Countable {s}) ∧ (⋂₀ {s} ⊆ s))) = (True ∧ True) := by sorry", "doc_string": "A set is in the `countableInterFilter` generated by `g` if and only if\nit contains a countable intersection of elements of `g`. ", "generated": ["throw away (* Ω)⟦l =ḁ (Set.compl t)⁻¹ • s) = c) ):\nx ∈ g x)) +\n        (s ∈ F.compression g x)))) =\n({ g ... })) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Iff.symm : ∀ {a b : Prop}, (a ↔ b) → (b ↔ a) := by sorry ", "theorem Subtype.property : ∀ {α : Sort u} {p : α → Prop} (self : Subtype p), p ↑self := by sorry ", "theorem Filter.monotone_coinductive' :\n    ∀ {α : Type u_2} [inst : MeasurableSpace α] [inst_1 : MeasurableSingletonClass α] (m : Set (Set α))\n      [inst : BddBelow m], Set.Countable ((⋃ i ∈ s, m i)ễ) → ∃ t ∈ s, IsLUB t m :=\n  by sorry ", "theorem aux.3793176112121660827 {α : Type u_2} {g : Set (Set α)} {s : Set α} :\n    (Set.Countable (𝒱 s ∩ Set.Ioc 𝒜 (Filter.sequentiallyCountable_of_seqGc.gc g) (𝒜s₀ \\ s))) ↔\n      ((Set.Countable (∅ ∪ 𝒜 s₀ \\ s)) ∧ (¬(Set.Countableₓ (s ∪ 𝒜 s₀ / Function.image dis ∩ s)))) :=\n  by sorry ", "theorem Classical.choose_spec : ∀ {α : Sort u} {p : α → Prop} {f : α → Prop × p}, p (Classical.choose f) := by sorry ", "theorem aux.2516264578937473389 {α : Type u_2} {g : Set (Set α)} {s : Set α} :\n    Iff (∃ x, True ∧ (s = SUp x)) = Iff (∃ x, s = SUp x) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  {f : MeasureTheory.SimpleFunc α E} {g : (a : E) → ENNReal} (hf : MeasureTheory.Integrable ↑f) (hg0 : g 0 = 0)\n  (ht : ∀ (b : E), g b ≠ ⊤),\n  MeasureTheory.SimpleFunc.integral μ (MeasureTheory.SimpleFunc.map (ENNReal.toReal ∘ g) f) =\n    (∫⁻ (a : α), g (↑f a) ∂μ).toReal)", "theorem": "theorem MeasureTheory.SimpleFunc.integral_eq_lintegral' :\n    (∀ {α : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n      {f : MeasureTheory.SimpleFunc α E} {g : (a : E) → ENNReal} (hf : MeasureTheory.Integrable ↑f) (hg0 : g 0 = 0)\n      (ht : ∀ (b : E), g b ≠ ⊤),\n      MeasureTheory.SimpleFunc.integral μ (MeasureTheory.SimpleFunc.map (ENNReal.toReal ∘ g) f) =\n        (∫⁻ (a : α), g (↑f a) ∂μ).toReal) :=\n  by sorry", "name": "MeasureTheory.SimpleFunc.integral_eq_lintegral'", "lemma-type": "{α : Type u_1} →\n  {E : Type u_2} →\n    [NormedAddCommGroup E] →\n      {m : MeasurableSpace α} →\n        {μ : MeasureTheory.Measure α} →\n          {f : MeasureTheory.SimpleFunc α E} →\n            {g : (a : E) → ENNReal} →\n              (hf : MeasureTheory.Integrable ↑f) →\n                (hg0 : g 0 = 0) →\n                  (ht : ∀ (b : E), g b ≠ ⊤) →\n                    (Finset.sum (MeasureTheory.SimpleFunc.range f) fun (a : E) ↦ g a * ↑↑μ (↑f ⁻¹' {a})).toReal =\n                      Finset.sum (MeasureTheory.SimpleFunc.range f) fun (a : E) ↦ (g a * ↑↑μ (↑f ⁻¹' {a})).toReal", "lemma": "theorem aux.18390489878085093734 {α : Type u_1} {E : Type u_2} [NormedAddCommGroup E] {m : MeasurableSpace α}\n    {μ : MeasureTheory.Measure α} {f : MeasureTheory.SimpleFunc α E} {g : (a : E) → ENNReal}\n    (hf : MeasureTheory.Integrable ↑f) (hg0 : g 0 = 0) (ht : ∀ (b : E), g b ≠ ⊤) :\n    (Finset.sum (MeasureTheory.SimpleFunc.range f) fun (a : E) ↦ g a * ↑↑μ (↑f ⁻¹' {a})).toReal =\n      Finset.sum (MeasureTheory.SimpleFunc.range f) fun (a : E) ↦ (g a * ↑↑μ (↑f ⁻¹' {a})).toReal :=\n  by sorry", "doc_string": "`SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n`α →ₛ ℝ≥0∞`. But since `ℝ≥0∞` is not a `NormedSpace`, we need some form of coercion.\nSee `integral_eq_lintegral` for a simpler version. ", "generated": ["theorem Ne.symm : ∀ {α : Sort u_1} (a b : α), (a ≠ b) → b ≠ a := by sorry ", "**Question:**\n\nCan you put Lean 4 code between `\\[mathaddterm (\\fun (x_1 : E) ↦ x_1 ≠ ⊤) \"\" Lean.MeasureTheory.lintegral_meas_le_top g */\nMath.measureAround x_1 = ?]\n\n**hint:** ∃ a t, (m_borel ≈ MeasureTheory.(Measure.ae {b := (⇑↑lf - ↑b)a | (b < a) ∧ / b ≠ ⇑m b₀})t) ∧ r < t :=\n  by sorry ", "theorem aux.2061321382901120068 {α : Type u_1} {E : Type u_2} [inst : NormedAddCommGroup E] {m : MeasurableSpace α}\n    {μ : MeasureTheory.Measure α} {f : MeasureTheory.SimpleFunc α E} {g : (a : E) → ENNReal}\n    (hf : MeasureTheory.Integrable ↑f) (hg0 : g 0 = 0) (ht : ∀ (b : E), g b ≠ ⊤)\n    (h_1 :\n      FiniteMeasure.mass (MeasureTheory.SimpleFunc.measure f * 1) (↑f =ᵐ[MeasureTheory.Measure.ae ↑μ ×ℂ g] 0) = 0)\n    :\n    BoundedHasFiniteIntegral μ g := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "deduction : CategoryTheory.Functor.instCongrHomEquiv :\n    ∀ (N : Type u_2) [inst : CategoryTheory.Category (N)], eqℑ ∘ Function.inv <| Contra (fun i => i (Equiv.inv f)), 3) :=\n  by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem not_false_eq_true : (¬False) = True := by sorry ", "(ENNReal.sInf_sup_decompose_toReal_of_nonneg\n   hp\n   (AEFree.congr\n     (fun (γ : (Åι |ₘ { p : ℝ | true }) → ℰ) ↦ ⇑id) (measurePreserving_aeEq)))\n           g =\n        (MeasureTheory.toMeasurableSet\n            (MeasureTheory.Measure.restrict ((fun (b : E) (a : Eν × οι²⁻¹. MeasureTheory.Measure.realUnit × (f₀ ∘ b)).firstCoord αE f₁ × Eν) |ₘ f₀ \\in |ₘ { p : ℝ | true }⟩))\n          ↑fun (a : α) ↦ ⨆ <| aedisjoint ((fun (↑f i₁ / ↑i i₂ : ℝ⁺) _ * fun₀.2 b).firstCoord αE f₁ i))\n          (gᶜ |ₘ { p : ℝ | true } |ₘ { b / ENNReal.realUnit'⁻¹ = ENNReal.toRealᵢ ))\n          ≥ 0 :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n  (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n  Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n    (nhds (Set.indicator (closure E) fun (x : α) ↦ 1)))", "theorem": "theorem thickenedIndicator_tendsto_indicator_closure :\n    (∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ} (δseq_pos : ∀ (n : ℕ), 0 < δseq n)\n      (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α),\n      Filter.Tendsto (fun (n : ℕ) ↦ ⇑(thickenedIndicator (δseq_pos n) E)) Filter.atTop\n        (nhds (Set.indicator (closure E) fun (x : α) ↦ 1))) :=\n  by sorry", "name": "thickenedIndicator_tendsto_indicator_closure", "lemma-type": "{α : Type u_1} →\n  [PseudoEMetricSpace α] →\n    {δseq : (a : ℕ) → ℝ} →\n      (δseq_pos : ∀ (n : ℕ), 0 < δseq n) →\n        (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) →\n          (E : Set α) → (x : α) → Set.indicator (closure E) (fun (x : α) ↦ 1) x = 1", "lemma": "theorem aux.13988271373782358281 {α : Type u_1} [PseudoEMetricSpace α] {δseq : (a : ℕ) → ℝ}\n    (δseq_pos : ∀ (n : ℕ), 0 < δseq n) (δseq_lim : Filter.Tendsto δseq Filter.atTop (nhds 0)) (E : Set α) (x : α) :\n    Set.indicator (closure E) (fun (x : α) ↦ 1) x = 1 := by sorry", "doc_string": "As the thickening radius δ tends to 0, the δ-thickened indicator of a set E (in α) tends\npointwise to the indicator function of the closure of E.\n\nNote: This version is for the bundled bounded continuous functions, but the topology is not\nthe topology on `α →ᵇ ℝ≥0`. Coercions to functions `α → ℝ≥0` are done first, so the topology\ninstance is the product topology (the topology of pointwise convergence). ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTransitionStrict Ordering α r] {a b c : α},\n    r a b → r b c → r a c := by sorry ", "theorem thickenedIndicator_tendsto_indicator_closure_of_one_le :\n    ∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {δseq : ℝ}, ∀ᶠ (b : ℝ) in nhds 0, |δseq b| ≤ b → δ = [0] := by sorry ", "theorem continuous_indicator_closure :\n    ∀ {α : Type u_1} [inst : PseudoEMetricSpace α] {s t : Set α} {f : α → ℝ},\n      Filters.Tendsto (Set.indicator s f + Function.const α (0 s ±1)) (nhdsSet 0) (nhds f s) :=\n  by sorry ", "theorem dist_le_nhdSet_diam :\n    ∀ {α : Type u} [inst : PseudoMetricSpace α] {δ : ℝ} (δ_pos : δ > 0) {t : ℝ} (de : δ_pos) {E : Set α},\n      sInf (Set.Nhds t ∩ Collection.biConvexCollection 3 ⟨δ, de⟩ F ∪ Set.Nhds t ∩ Collection.biConvexCollection 3 ⟨δ, de⟩\n             E) ≤ diam (Set.NhdsClose t E) + 2 + δ :=\n  by sorry ", "theorem ContinuousMap.continuous_to fun (x : α) ↦ id := by sorry ", "theorem self_le_iff_eq : ∀ {α : Type u} [inst : CanonicallyOrderedAddCommGroup α] {a b : α}, a ≤ b ↔ a = b := by\n  sorry ", "theorem continuous_thickenedIndicator_compl_frontier :\n    ∀ {X : Type u”} [inst : TopologicalSpace X] [inst_1 : PseudoEMetricSpace x] [inst_2 : SProd X X] {E : Set (X × STime)}\n      [inst_3 : PermanentlyBounded (SProd.mk ≼ α ) E] {r _himp_r E : r > rE + dist p t},\n      LipschitzOnWith (2 * r), Set.thickenedIndicator (r₁himp \"cmp : r_ imp_r₁\" × p), TEndord β × E) fun pa b :=\n    { if SameRay ℝ (Sym2.swap pa) (p₁ pa • α ⇑εb ((fst Sym2.swap x pa + (LipschitzOnWith L \"f\" ε))) := i });\n    ∀ (pa b : PEg.Bretag e' g'), SameRay ℝ (STimes.pair a b).swap p c → { in fst := p, in snd a := a, in snd t := b }\n      = c :=\n  by sorry ", "theorem tendsto_const_nhds : ∀ {X : Type u} {α : Type u_1} [inst : TopologicalSpace X] {x : X} {f : Filter α}\n    [inst_1 : Filter.NeBot f], Filter.Tendsto (fun (y : α) ↦ x) f (nhds x) := by sorry "]}
{"theorem-type": "(∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] (hF : ringChar F ≠ 2),\n  (quadraticChar F) (-1) = ZMod.χ₄ ↑(Fintype.card F))", "theorem": "theorem quadraticChar_neg_one :\n    (∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] (hF : ringChar F ≠ 2),\n      (quadraticChar F) (-1) = ZMod.χ₄ ↑(Fintype.card F)) :=\n  by sorry", "name": "quadraticChar_neg_one", "lemma-type": "{F : Type u_1} →\n  [Field F] →\n    [Fintype F] →\n      [DecidableEq F] →\n        (hF : ringChar F ≠ 2) →\n          let n : ℕ := Fintype.card F / 2;\n          (h₂ : Even n) →\n            (h : (Nat.even_or_odd n) = (Or.inl h₂)) →\n              (x_0 : Type) →\n                (x_1 : Monoid x_0) →\n                  (x_2 : HasDistribNeg x_0) → ∀ (x_0 : Type) (x_1 : Monoid x_0) (x_2 : HasDistribNeg x_0), (-1) ^ n = 1", "lemma": "theorem aux.8572951281334453837 {F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F ≠ 2) :\n    let n : ℕ := Fintype.card F / 2;\n    (h₂ : Even n) →\n      (h : (Nat.even_or_odd n) = (Or.inl h₂)) →\n        (x_0 : Type) →\n          (x_1 : Monoid x_0) →\n            (x_2 : HasDistribNeg x_0) → ∀ (x_0 : Type) (x_1 : Monoid x_0) (x_2 : HasDistribNeg x_0), (-1) ^ n = 1 :=\n  by sorry", "doc_string": "The value of the quadratic character at `-1` ", "generated": ["theorem pow_sub_one : ∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ (p - 1) = a⁻¹ ^ (p - 1) := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem pow_one : ∀ {M : Type u} [inst : Monoid M] (a : M), a ^ 1 = a := by sorry ", "theorem aux.17183241217786758026 {F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F ≠ 2)\n    (h_2 : (ZMod.prime_eq_two_of_char_neq_two : (ringChar F ≠ 2 → ¬2 = ringChar F) = True) ∨ ¬(ringChar F ≠ 1))\n    (h_3 : ringChar F = 1) : ZMod.prime_eq_two_of_char_ne_two h := by sorry ", "theorem Ne.gt_eq_neg_one : ∀ {G : Type z} [inst : Monoid G] [out_8 : DecidableRel Dvd.dvd] (a : G)\n    (a_1 : a ≠ 2), (a * a ≠ 0) ↔ a = -1 := by sorry ", "theorem map_inv :\n    ∀ {G : Type u} {H : Type v} [inst : Group G] [inst_1 : Group H] (h : Function.Bijective Nat.cast) (f : G →* H)\n      (g : H →* G) (m : G), (map₂ f h (g m)) (f.toMonoidHom.map m) = M.map (f : G →* H) (g := g (map (g { map_id := ((h :\n        Function.Bijective Nat.cast))) ∘ f) m ∘ hom_inv h (g m))) :=\n  by sorry ", "theorem aux.16089132655612496130 {F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F ≠ 2) :\n    (Fintype.card F = 0) ∨ (Fintype.card F → (quaternionRing F) ↑(ZMod.χ₄A ↑(Fintype.card F))) ↔ True := by\n  sorry ", "theorem aux.14020510379965214338 {F : Type u_1} [Field F] [Fintype F] [DecidableEq F] (hF : ringChar F ≠ 2) :\n    2 * ZMod.natCharm₂ ≠ 0 := by sorry "]}
{"theorem-type": "(∀ {p : ℕ} [inst : Fact (Nat.Prime p)] (hp : p ≠ 2), legendreSym p 2 = ZMod.χ₈ ↑p)", "theorem": "theorem legendreSym.at_two : (∀ {p : ℕ} [inst : Fact (Nat.Prime p)] (hp : p ≠ 2), legendreSym p 2 = ZMod.χ₈ ↑p) := by\n  sorry", "name": "legendreSym.at_two", "lemma-type": "{p : ℕ} →\n  [Fact (Nat.Prime p)] → (hp : p ≠ 2) → (legendreSym p 2 = ZMod.χ₈ ↑p) = ((quadraticChar (ZMod p)) ↑2 = ZMod.χ₈ ↑p)", "lemma": "theorem aux.11892037201328376956 {p : ℕ} [Fact (Nat.Prime p)] (hp : p ≠ 2) :\n    (legendreSym p 2 = ZMod.χ₈ ↑p) = ((quadraticChar (ZMod p)) ↑2 = ZMod.χ₈ ↑p) := by sorry", "doc_string": "`legendreSym p 2` is given by `χ₈ p`. ", "generated": ["theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem ne_at_two_sub_one_of_neg₀ : ∀ {n : ℤ} (-n = 2 - n), 0 < n := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.5853609669865579840 {p : ℕ} [Fact (Nat.Prime p)] (hp : p ≠ 2) : padicValNat p 2 = 0 := by sorry ", "equation : legendreSym.zipWith.proof_3 = LegendreSym.proveeq ZMod.χ₈₊' 1 0 0 true : List.atLeastSZ 8 true 3 :=\n  by sorry ", "theorem ZMod.cast_zmod_char : ∀ (p : ℕ{[ InstancesCodeFor ω}] [inst : Fact (Nat.Prime ⌐p)]) (a : ℤ ⧸ ↑p), ↑(𝄚(p → ZMod.charFn p a) (intCast (ZMod.card p))) = ω ^ r ↑a := by sorry ", "theorem Legendre.qodd' : ∀ (q : ℕ) [inst : Fact (Nat.Prime q)] (a : ℤ), q % 4 ← 2 ↘ ↑q % 4 ) := by sorry", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n  [inst_2 : NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [inst_3 : NormedSpace ℝ E]\n  [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f)\n  {g : (a : X) → E} (hg : Continuous g) (h'g : HasCompactSupport g), MeasureTheory.Integrable fun (x : X) ↦ f x • g x)", "theorem": "theorem MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport :\n    (∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X]\n      [inst_2 : NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [inst_3 : NormedSpace ℝ E]\n      [inst_4 : OpensMeasurableSpace X] [inst_5 : T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f)\n      {g : (a : X) → E} (hg : Continuous g) (h'g : HasCompactSupport g),\n      MeasureTheory.Integrable fun (x : X) ↦ f x • g x) :=\n  by sorry", "name": "MeasureTheory.LocallyIntegrable.integrable_smul_right_of_hasCompactSupport", "lemma-type": "{X : Type u_1} →\n  {E : Type u_3} →\n    [MeasurableSpace X] →\n      [TopologicalSpace X] →\n        [NormedAddCommGroup E] →\n          {μ : MeasureTheory.Measure X} →\n            [NormedSpace ℝ E] →\n              [OpensMeasurableSpace X] →\n                [T2Space X] →\n                  {f : (a : X) → ℝ} →\n                    (hf : MeasureTheory.LocallyIntegrable f) →\n                      {g : (a : X) → E} →\n                        (hg : Continuous g) →\n                          (h'g : HasCompactSupport g) →\n                            let K : Set X := tsupport g;\n                            ((Set.indicator K fun (x : X) ↦ f x • g x) = fun (x : X) ↦ f x • g x) ↔\n                              ((Function.support fun (x : X) ↦ f x • g x) ⊆ K)", "lemma": "theorem aux.9917197367261017825 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [NormedSpace ℝ E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    let K : Set X := tsupport g;\n    ((Set.indicator K fun (x : X) ↦ f x • g x) = fun (x : X) ↦ f x • g x) ↔\n      ((Function.support fun (x : X) ↦ f x • g x) ⊆ K) :=\n  by sorry", "doc_string": "If `f` is locally integrable and `g` is continuous with compact support,\nthen `f • g` is integrable. ", "generated": ["theorem aux.4775634666843458460 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [inst_2 : NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [ NormedSpace ℝ E] [OpensMeasurableSpace X]\n    [T2Space X] {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E}\n    (hg : Continuous g) (h'g : HasCompactSupport g) (K₀ : TopologicalSpace.Compacts X) (hK₀ : ↑↑μ ↑K₀ ≠ ⊤) : 0.1 \\\\\n          ↑K₀ = K ⊓ ↑K₀ := by sorry ", "theorem continuous_neg :\n    ∀ {G : Type u_3} [inst : TopologicalSpace G] [inst_1 : InvolutiveNeg G] [inst_2 : ContinuousInvolutiveNeg G],\n      Continuous (-)),\n  continuous_neg :=\n  by sorry ", "theorem aux.8347527543311574594 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [NormedSpace ℝ E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    let K : Set X := tsupport g;\n    IsCompact (Function.support fun (x : X) ↦ fun⁻¹' (g x) • f x + 1) :=\n  by sorry ", "theorem continuous_iff :\n    ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},\n      Continuous f ↔ ∀ (f' : Filter X), f' = Filter.map f f' → Filter.Tendsto f f' (nhds ↑f) :=\n  by sorry ", "theorem aux.11330169488772044550 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [ TopologicalSpace X]\n    [ NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [ NormedSpace ℝ E] [ OpensMeasurableSpace X] [ T2Space X]\n    {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) :\n    (Continuous g) ∧ (HasCompactSupport fun (a : ℤ) ↦ g - g ∘ ↑a • SimpleFunc.const X (⨆ z, ‖g ↑z‖ + ‖f ↑z‖)) :=\n  by sorry ", "theorem Function.update_id : ∀ {α : Sort u} {a : α} (f : α → α), Function.update f a id = f a := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem aux.4936809785932455804 {X : Type u_1} {E : Type u_3} [MeasurableSpace X] [TopologicalSpace X]\n    [NormedAddCommGroup E] {μ : MeasureTheory.Measure X} [NormedSpace ℝ E] [OpensMeasurableSpace X] [T2Space X]\n    {f : (a : X) → ℝ} (hf : MeasureTheory.LocallyIntegrable f) {g : (a : X) → E} (hg : Continuous g)\n    (h'g : HasCompactSupport g) : f ×��HOUT g = f * g := by sorry "]}
{"theorem-type": "(∀ {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ} (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x)\n  (g'pos : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), 0 ≤ g' x) (hg : Filter.Tendsto g Filter.atTop (nhds l)),\n  ∫ (x : ℝ) in Set.Ioi a, g' x = l - g a)", "theorem": "theorem MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg' :\n    (∀ {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ}\n      (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x) (g'pos : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), 0 ≤ g' x)\n      (hg : Filter.Tendsto g Filter.atTop (nhds l)), ∫ (x : ℝ) in Set.Ioi a, g' x = l - g a) :=\n  by sorry", "name": "MeasureTheory.integral_Ioi_of_hasDerivAt_of_nonneg'", "lemma-type": "{g : (a : ℝ) → ℝ} →\n  {g' : (a : ℝ) → ℝ} →\n    {a : ℝ} →\n      {l : ℝ} →\n        (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x) →\n          (g'pos : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), 0 ≤ g' x) →\n            (hg : Filter.Tendsto g Filter.atTop (nhds l)) → MeasureTheory.IntegrableOn (fun (x : ℝ) ↦ g' x) (Set.Ioi a)", "lemma": "theorem aux.5550241840373994504 {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ}\n    (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x) (g'pos : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), 0 ≤ g' x)\n    (hg : Filter.Tendsto g Filter.atTop (nhds l)) : MeasureTheory.IntegrableOn (fun (x : ℝ) ↦ g' x) (Set.Ioi a) := by\n  sorry", "doc_string": "When a function has a limit at infinity `l`, and its derivative is nonnegative, then the\nintegral of the derivative on `(a, +∞)` is `l - g a` (and the derivative is integrable, see\n`integrable_on_Ioi_deriv_of_nonneg'`). Version assuming differentiability on `[a, +∞)`. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Real.hasSum_one_add_cosh :\n    ∀ {y : ℝ}, (HasSum (fun x => x^2 / cosh⁻¹ x⁻¹ ^ 02) y) ∧ ((-1 < 0) ∧ (y ≤ -1)) := by sorry ", "theorem self_mem_nhds :\n    ∀ {X : Type u} [inst : TopologicalSpace X] (x : X) (x_1 : Set X), x_1 ∈ nhds x → x ∈ x_1 := by sorry ", "theorem aux.7506566534331558135 {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ}\n    (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x) (g'pos : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), 0 ≤ g' x)\n    (hg : Filter.Tendsto g Filter.atTop (nhds l)) : ⎤l⎥ = ‖l‖ := by sorry ", "theorem Filter.IsBoundedUnder.pri' :\n    ∀ {α : Type u} {m : Filter α} {𝓕 : Filter α},\n      ¬m.IsBoundedUnder 𝓕 →\n        ∃ b p l a s (e a : æ ∂ a), e ∈ l → ↑(filter_mono e p)(dom ðæ a) → ae_strict_cofinite_tril 𝓕 b l a r e fun a => e :=\n  by sorry ", "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.316063692557456704 {g : (a : ℝ) → ℝ} {g' : (a : ℝ) → ℝ} {a : ℝ} {l : ℝ}\n    (hderiv : ∀ (x : ℝ) (a : x ∈ Set.Ici a), HasDerivAt g (g' x) x)\n    (g'pos : ∀ (x : ℝ) (a : x ∈ Set.Ioi a), 0 ≤ g' x) (hg : Filter.Tendsto g Filter.atTop (nhds l)) (x : ℝ)\n    (hx : x ∈ Set.Iic a ∪ {a}) : HasDerivAt (-g) (-g') x := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {σ : Type u_3} [inst_1 : AddCommMonoid M]\n  {φ : MvPolynomial σ R} {n : M} [inst_2 : SemilatticeSup M] {w : (a : σ) → M}\n  (hφ : MvPolynomial.IsWeightedHomogeneous w φ n) (h : φ ≠ 0), MvPolynomial.weightedTotalDegree' w φ = ↑n)", "theorem": "theorem MvPolynomial.IsWeightedHomogeneous.weighted_total_degree :\n    (∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {σ : Type u_3} [inst_1 : AddCommMonoid M]\n      {φ : MvPolynomial σ R} {n : M} [inst_2 : SemilatticeSup M] {w : (a : σ) → M}\n      (hφ : MvPolynomial.IsWeightedHomogeneous w φ n) (h : φ ≠ 0), MvPolynomial.weightedTotalDegree' w φ = ↑n) :=\n  by sorry", "name": "MvPolynomial.IsWeightedHomogeneous.weighted_total_degree", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "A non zero weighted homogeneous polynomial of weighted degree `n` has weighted total degree\n`n`. ", "generated": ["theorem Ne.symm : ∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a := by sorry ", "theorem mul_add :\n    ∀ {R : Type x} [inst : Add ZeroClass R] [inst_1 : Semiring R] [inst_2 : MulZeroClass R] {a b c : R},\n      a * (b + c) = a * b + a * c :=\n  by sorry ", "theorem aux.8730179787336100147 {R : Type u_1} {M : Type u_2} [CommSemiring R] {σ : Type u_3} [AddCommMonoid M]\n    {φ : MvPolynomial σ R} {n : M} [SemilatticeSup M] {w : (a : σ) → M}\n    (hφ : MvPolynomial.IsWeightedHomogeneous w φ n) (h : φ ≠ 0) (m : M[σ→ℜ(M)])\n    (ih : ∀ (hφ : MvPolynomial.IsWeightedHomogeneous w φ n) (h : φ ≠ 0), C + MvPolynomial.frange (monom w) m ∈ ae_degree φ)\n    (hφ : MvPolynomial.IsWeightedHomogeneous w φ (n + lcsTridegree w))\n    (h : Polynomial.coeff (MvPolynomial.restrictCoeff w R m) (↑(Finsupp.complFdeg (n + lcsTridegree w))) φ ≠ 0) : n + 0 = n :=\n  by sorry ", "theorem MvPolynomial.IsWeightedHomogeneous.to_weightedTotalDegree :\n    ∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] {ι : Type u_3} {σ : ι → Type u_4} [inst_1 : AddCommMonoid M]\n      [inst_2 : FreeMagma R] {w : (a : σ a) → M w_1 N}! {φ : (ᵐ [i : υ_1] V i) →ₗ[R] Z w} (h : φ.weightedHomogeneous φ V p Δ), forall [hμ : MeasureTheory.IsADDhaar measure μ], (MVPolynomial.IsDifferenceMonom φ) :\n    ∀ (d : R) (_: nonempty φ) (_ : MvPolynomial.weightEDHomogeneity d φ),\n      1 ≤ Multiplicative.toAdd ↑d * forallCompl φ :=\n  by sorry ", "theorem aux.15237258881516916254 {R : Type u_1} {M : Type u_2} [CommSemiring R] {σ : Type u_3} [AddCommMonoid M]\n    {φ : MvPolynomial σ R} {n : M} [SemilatticeSup M] {w : (a : σ) → M}\n    (hφ : MvPolynomial.IsWeightedHomogeneous w φ n) (h : φ ≠ 0) (n' : M)\n    (h : ∃ (_ : n' < n), True ∧ (MvPolynomial.IsHomogeneous φ n')) (n'_eq : n' < n) (right : True ∧ (MvPolynomial.IsHomogeneous φ n'))\n  (congr : (MvPolynomial.IsHomogeneous φ n') ∧ ((∀ (m : σ →₀ ℕ), m ≤ n' * Nat.zero) ∧ (φ = X m)))\n  (n'_eq : M.zero < n') (φ_eq : (∀ (m : σ →₀ ℕ), m ≤ ↑n' * 0) ∧ (φ = X ↑n'))\n  (n'_eq : φ = X ↑↑n') : M.zero * Nat.zero = M.zero := bySorry ", "theorem zero_smul : ∀ (M : Type u_1) {α : Type u_2} [inst : MulZeroClass M] [inst_1 : Zero α] (a : M) (a_1 : α), 0 • a = 0 :=\n  by sorry ", "theorem minpoly.monic :\n    ∀ {R : Type u_2} {A : Type u_3} {x : R} [RA : Ring A] [instS : StrangeCardinal z]\n      [instM : PowerFun x x](x_1 : IsSMulExtClosed ℤ x) [hxRAc : IsDedekindDomain ℤ 𝓞]\n      [hdgconhg : ℤ 𝓞 ≤ ideal hg ↦ HG(id fun i / 2 => i) + ideality.ofFun hg (isPowPrior (↑8k x - HG 1) hg)] ⦃n₁ n₂ / e₁ e₂ :\n      ℤ⦄ {\\f_1 : RingHom.toMagma hg (f' 𓕣)} ⦃hfg₁ : PowerFun pf pf → rfg n₂ n₁ →\n        ((lraPowerFun ⟨id, max pf pf⟩) rfg := rfg)\n        + fun (_a : ↑k + e₁ / e₂ = ↑k + 0) ↦ lraPowerFun _ (rg ⌒⌔f') (rg ↑pf ↑hg)\n        ⇑(NatPowFun e₁ pf) :=\n  f'.right\n    ∫ _x_0 : Nat, ((fun 𝑖 ↦ HG 1 * Polynomial.X ^ ↑(lra x_0 * 𝒜 𝑖 * id ⌣ N)) ∘ g e_1 e_2) e_[0_A:Nat] /\n         20‖ ^ ↑⌊f_1 e⌋ +\n      ↑1 :=\n  f'.right\n    ∫ ({a :\n        ↑0 + max pf pf = ↑0 + Polynomial.X ^ ⌈f 1 / edist 0⌉ * f rf'1 + (lgfun x1) 2 fun i ↦ if 0 > a⌉}.1 +\n              0)Ⱈ f =\n      1 :=\n  by sorry ", "theorem inf_eq_null :\n    ∀ {β : Type u_1} [inst : AddGroup β] {v₁ v₂ : β} (p : β), (add order_zero v₁ = add order_zero v₂) ↔ p = 0 := by\n  sorry "]}
{"theorem-type": "(∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : OrderedCommGroup α] [inst_1 : OrderedCommGroup β] {s : Set ι}\n  {f : (a : ι) → α} {g : (a : ι) → β} (a : AntivaryOn f g s), MonovaryOn f⁻¹ g s)", "theorem": "theorem AntivaryOn.inv_left :\n    (∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : OrderedCommGroup α] [inst_1 : OrderedCommGroup β]\n      {s : Set ι} {f : (a : ι) → α} {g : (a : ι) → β} (a : AntivaryOn f g s), MonovaryOn f⁻¹ g s) :=\n  by sorry", "name": "AntivaryOn.inv_left", "lemma-type": "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "lemma": "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry", "doc_string": "**Alias** of the reverse direction of `monovaryOn_inv_left`.", "generated": ["theorem AntivaryOn.inv :\n    ∀ {α : Type u_1} {ι : Type u_4} {𝒜 : Type u_5} [inst : OrderedCommGroup α] [inst_1 : TerminalOrderedCommGroup α]\n      [inst_2 : SubtractionMonoid α] [inst_3 : Ordered cancellable SubtractionIn α])\n      (p : ι → Prop) (a : ι → α) (ℬ : (i : ι) → (j : ι) → 𝒜 i → 𝒜 j) [H : ConformalMapClass (function.swap ℬ) α β],\n**Topology.Order.AscVary.Monovary 𝒜 (Prod.swap α) β * p = Monovary ω.withBot e 𝒜 p :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem aux.17358252308742405080 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : OrderedCommGroup α]\n    [OrderedCommGroup β] {s : Set ι} {f : (a : ι) → α} {g : (a : ι) → β} {ι : Type u_1} {α : Type u_2}\n    {β : Type u_3} [OrderedCommGroup α] [OrderedCommGroup β] {s : Set ι} {f : (a : ι) → α} {g : (a : ι) → β} :\n    (MonovaryOn f f⁻¹ s) = (∀ (_a : ι) (_b : ι) (a : _a ∈ s) (a : _b ∈ s) (_a' : ι) (a : _a' ∈ s) (a : _a' ∈ s),\n      f (_a' ⇑f _b) (f _a ⇑(f⁻¹ _b))) :=\n  by sorry ", "theorem of_eq_true : ∀ {a : Prop}, a = True → a := by sorry ", "thread_chart_aux :\n    ∀ {α : Type u} {n : ℕ} (I : ModelWithCorners ‹(ModelWithCorners.trans ⊤ I)⊤ α)\n      {M : Type VecNons singleton n} →\n      ↑I = partialHomeomorph I (idRingHom ↑(ModelWithCorners.toRing I) n) ((↑m ! IsOpenProd) I M I) :=\n  by sorry ", "theorem MonovaryOn.dual_right :\n    ∀ {ι :Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrder α] [inst_1 : LinearOrder β] {f : ι → α}\n      {g : ι → β} {s : Set ι}, MonovaryOn f g s ↔ AntivaryOn f⁻¹ g (Insert.insert e s)) :=\n  by sorry\n``` [/INST] theorem aux.4823988935387276215 {ι : Type u_1} {α : Type u_2} {β : Type u_3} [LinearOrder α] [LinearOrder β]\n    {f : ι → α} {g : ι → β} {s : Set ι} :\n    ((MonovaryOn f g s) ↔ (a : (x : ι) → α)⁻¹ '' s =ᶠ[INST : MeasureTheory.Measure.OuterMeasure.mkMetric (measure0_nnreal) (0, ⊤)] s)) =\n      ((AntivaryOn f g⁻¹ s) ↔ (a⁻¹ '' t =ᶠ[INST : MeasureTheory.Measure.OuterMeasure.mkMetric (measure0_nnreal) (0, ⊤)] a⁻¹ '' t)) :=\n  by sorry ", "theorem MonovaryOn.inv_left :\n    ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : OrderedCommGroup α] [inst_1 : OrderedCommGroup β]\n      {s : Set ι} {f : ι → α} {g : ι → β}, MonovaryOn f g s → MonovaryOn ( fun x => x⁻¹) g s :=\n  by sorry "]}
{"theorem-type": "(∀ {ι : Type u_1} {α : Type u_2} [inst : CommMonoid α] [inst_1 : Fintype ι] (f : (a : ι) → Set α) (a : α),\n  (a ∈ Finset.prod Finset.univ fun (i : ι) ↦ f i) ↔\n    (∃ g, ∃ (_ : ∀ (i : ι), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a))", "theorem": "theorem Set.mem_fintype_prod :\n    (∀ {ι : Type u_1} {α : Type u_2} [inst : CommMonoid α] [inst_1 : Fintype ι] (f : (a : ι) → Set α) (a : α),\n      (a ∈ Finset.prod Finset.univ fun (i : ι) ↦ f i) ↔\n        (∃ g, ∃ (_ : ∀ (i : ι), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a)) :=\n  by sorry", "name": "Set.mem_fintype_prod", "lemma-type": "{ι : Type u_1} →\n  {α : Type u_2} →\n    [CommMonoid α] →\n      [Fintype ι] →\n        (f : (a : ι) → Set α) →\n          (a : α) →\n            ((a ∈ Finset.prod Finset.univ fun (i : ι) ↦ f i) ↔\n                (∃ g, ∃ (_ : ∀ (i : ι), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a)) =\n              ((∃ g,\n                  ∃ (_ : ∀ {i : ι} (a : i ∈ Finset.univ), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a) ↔\n                (∃ g, ∃ (_ : ∀ (i : ι), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a))", "lemma": "theorem aux.565250803400073031 {ι : Type u_1} {α : Type u_2} [CommMonoid α] [Fintype ι] (f : (a : ι) → Set α) (a : α) :\n    ((a ∈ Finset.prod Finset.univ fun (i : ι) ↦ f i) ↔\n        (∃ g, ∃ (_ : ∀ (i : ι), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a)) =\n      ((∃ g, ∃ (_ : ∀ {i : ι} (a : i ∈ Finset.univ), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a) ↔\n        (∃ g, ∃ (_ : ∀ (i : ι), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a)) :=\n  by sorry", "doc_string": "A version of `Set.mem_finset_prod` with a simpler RHS for products over a Fintype. ", "generated": ["theorem UniqueProds.memRecOn_mem :\n    ∀ {S : Set α}, Set.UniquenessUniqueProds S →\n      ∀ {α' : Unique α} (a : α') (H : r a' a) {f : α' ↪ Unique α} (hf : Subtype.val { f := f } = ⟨a'⟩), f '' f '' gS₁S H subseteq gS₁S hf :=\n  by sorry ", "theorem mul_mem' :\n    ∀ {R : Type x_1} [inst : NonUnitalSemiring R] (a b : R), 0 < a → 0 < b → a * b ∈ R := by sorry ", "theorem aux.5816656159791919766 {ι : Type u_1} {α : Type u_2} [CommMonoid α] [Fintype ι]  (f : (a : ι) → Set α)\n    (a : α) :\n    (∃ x, ∃ (_ : ∀ ⦃i : ι⦄ (a : i ∈ Finset.univ), x i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ x i) = a) ↔\n      (∃ x, ∃ (_ : ∀ (i : ι), g i ∈ f i), (Finset.prod Finset.univ fun (i : ι) ↦ g i) = a) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTransformative r] {a b c : α}, r a b → r b c → r a c := by\n  sorry ", "theorem aux.1266406287574848103 {ι : Type u_1} {α : Type u_2} [CommMonoid α] [Finitype ι] (f : (a : ι) → Set α)\n    (a : α) : (a ∉ Finset.prod Finset.univ f) ↔ (a ∉ ↑（FormalMultilinearSeries.firstTerm f)) := by sorry ", "theorem aux.16652841934625875027 {ι : Type u_1} {α : Type u_2} [CommMonoid α] [Fintype ι] (f : (a : ι) → Set α)\n    (a : α) (a_1 : ι) : (∃ g', (∀ {a_2 : ι} (aβ : a_2 ∈ Finset.univ), g' a_2 ∈ f a_2) ∧ (Finset.prod Finset.univ fun (i : ι) ↦ g' i = a_1)) =\n      (∃ g', (g' a a_1) ∧ True) :=\n  by sorry ", "theorem eq_top_iff' :\n    ∀ {α : Type u} [inst : SemilatticeSup α] [inst_1 : OrderTop α] {a : α}, a = ⊤ ↔ ↑(Set.univ a) = ⊤ := by sorry ", "theorem aux.13590359762120880349 {ι : Type u_1} {α : Type u_2} [inst : CommMonoid α] [Fintype ι] (f : (a : ι) → Set α)\n    (a_1 : α) (a : α) (p₁ : α)\n    (h_2 :\n      (exists_mul_eq_pow_mul\n          _(of_eq_true\n            ((congrArgNot (eq_nat_or_int₁ p₁))\n              ((congrArg (IsNat.eq_nat' ((Int.natAbs p₁).Prime)) ((Int.prime ...).eq.mpr (p₁)))))) p₁)).1) :\n    ∀ (r : ↥(Finset.univ.filter Eq).get p₂),\n      (r = Eq.Subst h_2.1.2)(p₁ = p₂) :=\n  by sorry "]}
{"theorem-type": "(∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {u : E} {v : E}, (v ∈ (Submodule.span 𝕜 {u})ᗮ) ↔ (⟪u, v⟫_𝕜 = 0))", "theorem": "theorem Submodule.mem_orthogonal_singleton_iff_inner_right :\n    (∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      {u : E} {v : E}, (v ∈ (Submodule.span 𝕜 {u})ᗮ) ↔ (⟪u, v⟫_𝕜 = 0)) :=\n  by sorry", "name": "Submodule.mem_orthogonal_singleton_iff_inner_right", "lemma-type": "{𝕜 : Type u_1} →\n  {E : Type u_2} →\n    [IsROrC 𝕜] →\n      [NormedAddCommGroup E] →\n        [InnerProductSpace 𝕜 E] →\n          {u : E} →\n            {v : E} →\n              (hv : ⟪u, v⟫_𝕜 = 0) →\n                (w : E) → (hw : w ∈ Submodule.span 𝕜 {u}) → (c : 𝕜) → (h : c • u = w) → ⟪c • u, v⟫_𝕜 = 0", "lemma": "theorem aux.17448762203360164031 {𝕜 : Type u_1} {E : Type u_2} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E]\n    {u : E} {v : E} (hv : ⟪u, v⟫_𝕜 = 0) (w : E) (hw : w ∈ Submodule.span 𝕜 {u}) (c : 𝕜) (h : c • u = w) :\n    ⟪c • u, v⟫_𝕜 = 0 := by sorry", "doc_string": "A vector is in `(𝕜 ∙ u)ᗮ` iff it is orthogonal to `u`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Submodule.inner_orthonormal :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      (self : OrthogonalFamily 𝕜 E 1) (f g : ↥(\"orthonormalFamily self)), ⟪f 1, g 1⟫ = 0 :=\n  by sorry ", "theorem aux.7156905474133265449 {𝕜 : Type u_1} {E : Type u_2} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E]\n    {u : E} {v : E} : (v ∈ (Submodule.span 𝕜 {u})$.perp) = (⨅ a, ⟪ua • a, v⟫_𝕜 = 0) := by sorry ", "theorem Submodule.mem_orthogonal :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC ⅟𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace ⅟𝕜 E]\n      {K : Submodule ℝ E} [inst_3 : NormedSMul ℝ E] {w : E},\n      (w ∈ orthogonal K) ↔ (-w ∈ closure ((fun x => 2 * ⟪⣜w, x⟫_𝕜 • w) '' K))) :=\n  by sorry ", "theorem aux.8741093582635003943 {𝕜 : Type u_1} {E : Type u_2} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E]\n    {u : E} {v : E} (h : u = 0) : 0 = u := by sorry ", "theorem Set.inter_subset_inter_right : ∀ {α : Type u} (s t u : Set α), s ∩ u ⊆ t ∩ u := by sorry ", "theorem Submodule.orthogonal_span_singleton :\n    ∀ {F : Type u_3} {H : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F]\n      [inst_2 : NormedAddCommGroup H] [inst_3 : InnerProductSpace ℝ H] (w : F),\n      Submodule.orthogonal (Submodule.span ℝ {w}) = Set.univ :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a})", "theorem": "theorem Set.Finite.finite_subsets : (∀ {α : Type u} {a : Set α} (h : Set.Finite a), Set.Finite {b : Set α | b ⊆ a}) :=\n  by sorry", "name": "Set.Finite.finite_subsets", "lemma-type": "{α : Type u} →\n  {a : Set α} →\n    (h : Set.Finite a) → (s : Set α) → ((s ⊆ a) ↔ ((Set.Finite s) ∧ (s ⊆ a))) = (∀ (a : s ⊆ a), Set.Finite s)", "lemma": "theorem aux.5582743271508276222 {α : Type u} {a : Set α} (h : Set.Finite a) (s : Set α) :\n    ((s ⊆ a) ↔ ((Set.Finite s) ∧ (s ⊆ a))) = (∀ (a : s ⊆ a), Set.Finite s) := by sorry", "doc_string": "There are finitely many subsets of a given finite set ", "generated": ["theorem implies_true : ∀ (α : Sort u), (α → True) = True := by sorry ", "theorem Finset.subtype_coe_image : ∀ {α : Type u} {β : subtype α}, Finset.subtype { x | p x } = { p x | x ∈ Finset.val Finset.subtype } := by sorry ", "theorem List.Subset.extn_iff_subset : Ext.addMonoidHom (Pi.Sup.{u, u}) → Nat.subordination <+- List.ordMonox : ∀\n    {I : Type u_2} {f / i : List I → ι { a / i }} [AddOneClass (Nat <| ↑I i)], [f], g |⟹⟦ {i, {j : f.J} : S i}.2 y.a.2 ∈ f\n      {i, {i⟰ : f}j | y}.b ↔ ∁ a, PUg a f :=\n  by sorry ", "theorem finite_mem_setOf_finite : ∀ {α : Type u} {p : α → Set α}, (∀ (a : α), a ∈ p a) → Set.Finite p ∘ Set.Finite α.nonempty := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.6843255872092169601 {α : Type u} {a : Set α} (h : Set.Finite a) : List.Chain {a} (SetTheory.Below ↑h) b :=\n  by sorry ", "theorem aux.6267056719794076216 {α : Type u} {a : Set α} (h : Set.Finite a) : Function.Injective Set.univFunI {a} :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} {g : Set (Set α)} {s : Set α},\n  (s ∈ Filter.countableGenerate g) ↔ (∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))))", "theorem": "theorem Filter.mem_countableGenerate_iff :\n    (∀ {α : Type u_2} {g : Set (Set α)} {s : Set α},\n      (s ∈ Filter.countableGenerate g) ↔ (∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s)))) :=\n  by sorry", "name": "Filter.mem_countableGenerate_iff", "lemma-type": "{α : Type u_2} →\n  {g : Set (Set α)} →\n    {s : Set α} →\n      (h : ∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))) →\n        ∀ (S : Set (Set α)) (h : (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))), s ∈ Filter.countableGenerate g", "lemma": "theorem aux.14752122130207586792 {α : Type u_2} {g : Set (Set α)} {s : Set α}\n    (h : ∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))) :\n    ∀ (S : Set (Set α)) (h : (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))), s ∈ Filter.countableGenerate g := by sorry", "doc_string": "A set is in the `countableInterFilter` generated by `g` if and only if\nit contains a countable intersection of elements of `g`. ", "generated": ["theorem aux.13726959303334020436 {α : Type u_2} {g : Set (Set α)} {s : Set α} : Set.Countable (⋂ x, ∀ (w : x ∈ ↑s), setOf x,ᗮ) :=\n  by sorry ", "theorem aux.9542938641075631410 {α : Type u_2} {g : Set (Set α)} {s : Set α} (x : Set (Set α)) :\n    ((x ∈ {y : Set α | y ∈ g ×ˢ Filter.sets (ι → Set α) ×ˢ {S : Set α | ({x_1 : ι} ∔ S ∈ Sx)} \\cup\n                    id {y} ×ˢ {S : Set α | ({x_1 : ι} ⊆ S)} }) =\n          x ∈ {y : Set α | y ∈ g ×ˢ filter (fun (a : Set ι) iS => IciI a t iS ∈ S₀) ×ˢ\n                    s} ↑a :=\n  by sorry ", "theorem exists_congr : ∀ {α : Sort u_1} {p q : α → Prop}, (∀ (a : α), p a ↔ q a) → ((∃ a, p a) ↔ ∃ a, q a) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem iSupp_union' : ∀ {α : Type u_1} [[inst : π-structure α] (p_1 _ : α) (p_2 : α), (Π a = {p_1, p_2}, π a)∩{p, q} = π p ⊔ π q := by sorry ", "theorem aux.7006243316668484958 {α : Type u_2} {g : Set (Set α)} {s : Set α} :\n    s ∈ LowerClosure ↑g ∧ (Filter.HasCountableSeparatingOn g D) := By Sorry ", "theorem filter_le_filter_iff :\n    ∀ {p q : X × X} {s : Set (X × X)},\n      Filter.mk p = Filter.glimsup s fun i x => Filter.mk q i i :=\n  by sorry "]}
{"theorem-type": "(∀ {G : Type u} [inst : CategoryTheory.Groupoid G] [inst_1 : IsFreeGroupoid G]\n  (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n  [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)]\n  {a : IsFreeGroupoid.Generators G} {b : IsFreeGroupoid.Generators G} (e : a ⟶ b)\n  (H : e ∈ Quiver.wideSubquiverSymmetrify T a b),\n  IsFreeGroupoid.SpanningTree.loopOfHom T (IsFreeGroupoid.of e) =\n    CategoryTheory.CategoryStruct.id (IsFreeGroupoid.SpanningTree.root' T))", "theorem": "theorem IsFreeGroupoid.SpanningTree.loopOfHom_eq_id :\n    (∀ {G : Type u} [inst : CategoryTheory.Groupoid G] [inst_1 : IsFreeGroupoid G]\n      (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n      [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)]\n      {a : IsFreeGroupoid.Generators G} {b : IsFreeGroupoid.Generators G} (e : a ⟶ b)\n      (H : e ∈ Quiver.wideSubquiverSymmetrify T a b),\n      IsFreeGroupoid.SpanningTree.loopOfHom T (IsFreeGroupoid.of e) =\n        CategoryTheory.CategoryStruct.id (IsFreeGroupoid.SpanningTree.root' T)) :=\n  by sorry", "name": "IsFreeGroupoid.SpanningTree.loopOfHom_eq_id", "lemma-type": "∀ {G : Type u} [inst : CategoryTheory.Groupoid G] [inst_1 : IsFreeGroupoid G]\n  (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n  [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)] {a : G}\n  (p : Quiver.Path (Quiver.root (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)) a),\n  IsFreeGroupoid.SpanningTree.treeHom T a = IsFreeGroupoid.SpanningTree.homOfPath T p", "lemma": "theorem IsFreeGroupoid.SpanningTree.treeHom_eq :\n    ∀ {G : Type u} [inst : CategoryTheory.Groupoid G] [inst_1 : IsFreeGroupoid G]\n      (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n      [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)] {a : G}\n      (p : Quiver.Path (Quiver.root (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)) a),\n      IsFreeGroupoid.SpanningTree.treeHom T a = IsFreeGroupoid.SpanningTree.homOfPath T p :=\n  by sorry", "doc_string": "Turning an edge in the spanning tree into a loop gives the identity loop. ", "generated": ["theorem WideSubquiver.loopOfHom_source_of_mem :\n    ∀ {V G : Type u_1} {H : Type u_2} [inst : CategoryTheory.Category.{u_3, u_2} V]\n      [instance_1 : Fintype H] {e₁ e₂ : V ≃c H} [inst_2 : LocalCategories V]\n      {a : V}{x c p : Quiver.Walk c a} {Y P : WideSubquiver a},\n      FunctionState finst ⟦e₁, p.2⟧ c → c ↔ P :=\n  by sorry ", "**Question:**\n**Suppose we have the following Lean 4 code:**\n```lean\ntheorem IsFreeGroupoid.SpanningTree.loopOfHom_eq_id :\n    (∀ {G : Type u} [inst : CategoryTheory.Groupoid G] [inst_1 : IsFreeGroupoid G]\n      (T : WideSubquiver (Quiver.Symmetrify (IsFreeGroupoid.Generators G)))\n      [inst_2 : Quiver.Arborescence (WideSubquiver.toType (Quiver.Symmetrify (IsFreeGroupoid.Generators G)) T)]\n      {a : IsFreeGroupoid.Generators G} {b : IsFreeGroupoid.Generators G} (e : a ⟶ b)\n      (H : e ∈ Quiver.wideSubquiverSymmetrify T a b),\n      IsFreeGroupoid.SpanningTREE.loopOfHom T (IsFreeGroupoid.of e) =\n        CategoryTheory.CategoryStruct.id (IsFreeGroupoid.SpanningTree.root' T)) :=\n  by sorry\n``` [/INST] **answer:**, 12978718675426751341 : Set.mk x { of_gene : G } = a = x := by sorry ", "lexicographically, by using trans : For any list l1, list2 in the subrelation:\n        if eqlist3 (l [1 % f.toList with fun (a_1 : l [? 6] [/INST] ↦ a ∈ f ⇒ Eq? ((Liftable.add f).map (Sym2.symm (a ∈ f))) Eq.refl]), l [1 - -0 % fun ex x => if is_or (and (Eq (Some (And.Right h1)) (Some true))) a_right * fun bif b else itm2 e H)) Then this term is True. }\n```", "Theorem.eq_iff_iff_eq_trans_eq := by sorry ", "theorem Quiver.shortCircuit.loopy : ∀ (α : N₁), Quiver.Loopy ε := by sorry ", "proposition congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a b : α}, f₁ = f₂ → a = b → f₁ a = f₂ b := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a a' : α}, f₁ = f₂ → a = a' → f₁ a = f₂ a' := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : SemilatticeSup α] {a : α} {b : α} (a_1 : a ≤ b), a ⊔ b = b)", "theorem": "theorem sup_of_le_right : (∀ {α : Type u} [inst : SemilatticeSup α] {a : α} {b : α} (a_1 : a ≤ b), a ⊔ b = b) := by\n  sorry", "name": "sup_of_le_right", "lemma-type": "∀ (p : Prop), (p ↔ p) = True", "lemma": "theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry", "doc_string": "**Alias** of the reverse direction of `sup_eq_right`.", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem iff_of_eq : ∀ {p₁ p₂ : Prop}, p₁ = p₂ → (p₁ ↔ p₂) := by sorry ", "theorem LE.le.sup_eq_right : ∀ {α : Type u} [inst : SemilatticeSup α] {a b : α}, b ≤ a → a ⊔ b = b := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.18114262166736262601 {α : Type u} [inst : SemilatticeSup α] : ∀ {a : α} {b : α} {a : α} (b : α), a⨿b = b :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.13399601416849199857 {α : Type u} [inst : SemilatticeSup α] {a : α} {b : α} : a ∈ Set.Ici a := by sorry ", "theorem addComm :\n    ∀ {G : Type u_1} [inst : AddCommMagma G] [inst_1 : AddZeroClass G] [inst_2 : SubtractionCommDiagonale G],\n      AddCommGr monoidOfSubToAdd :\n    ∀ (a : G) (b : G), a + b = Int.addCommute a b :=\n  by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\n  [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Γ : Subgroup G} [inst_5 : MeasurableSpace (G ⧸ Γ)]\n  [inst_6 : BorelSpace (G ⧸ Γ)], MeasurableSMul G (G ⧸ Γ))", "theorem": "theorem QuotientGroup.measurableSMul :\n    (∀ {G : Type u_1} [inst : Group G] [inst_1 : MeasurableSpace G] [inst_2 : TopologicalSpace G]\n      [inst_3 : TopologicalGroup G] [inst_4 : BorelSpace G] {Γ : Subgroup G} [inst_5 : MeasurableSpace (G ⧸ Γ)]\n      [inst_6 : BorelSpace (G ⧸ Γ)], MeasurableSMul G (G ⧸ Γ)) :=\n  by sorry", "name": "QuotientGroup.measurableSMul", "lemma-type": "{G : Type u_1} →\n  [Group G] →\n    [MeasurableSpace G] →\n      [TopologicalSpace G] →\n        [TopologicalGroup G] →\n          [BorelSpace G] →\n            {Γ : Subgroup G} →\n              [MeasurableSpace (G ⧸ Γ)] → [BorelSpace (G ⧸ Γ)] → (g : G) → Continuous fun (x : G ⧸ Γ) ↦ g • x", "lemma": "theorem aux.5845568630157683990 {G : Type u_1} [Group G] [MeasurableSpace G] [TopologicalSpace G] [TopologicalGroup G]\n    [BorelSpace G] {Γ : Subgroup G} [MeasurableSpace (G ⧸ Γ)] [BorelSpace (G ⧸ Γ)] (g : G) :\n    Continuous fun (x : G ⧸ Γ) ↦ g • x := by sorry", "doc_string": "Measurability of the action of the topological group `G` on the left-coset space `G/Γ`. ", "generated": ["theorem continuous_quotMap :\n    ∀ {F : Type uG} (O : StructuredSpace F) {ι R : O}, Unique O → Continuous fun x => Quotient.mk' (f x) ⊓ r := by\n  sorry ", "theorem MeasurableNeg.measurablePreImage :\n    ∀ {α : Type u_2} {G : Type u_5} [inst : Nem1Canc G] [inst_1 : MulAction G α] [inst_2 : SMulContinuousNeg G α]\n      [inst_3 : MeasurableSpace α] [inst_4 : BorelSpace α] [inst_5 : MeasurableLinearAction G α]\n      {g : G}, IsUnits g → Measurable Neg.measureToAEEmpty α :=\n  by sorry ", "theorem congr_fun : ∀ {α : Sort u} {β : α → Sort v} {f g : β}, f = g → ∀ (x : α), f x = g x := by sorry ", "theorem IsMeagre.comap_of_mem :\n    ∀ {α : Type u_5} {β : Type u_6} [inst : TopologicalSpace α] [inst_1 : HasSMul α (Quotient Γ) β]\n      (r₁ : Quotient Γ →ₛβ α), ∃ r t, Function.Surjective ⇑r→ Subsemigroup.closure IsMeagreSub.toLinear → r ∈ bors >> r₁ ∈ t :=\n  by sorry ", "theorem HasStrictFDerivAt.scomp :\n    ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormalSpace E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormalSpace F]\n      [inst_5 : CompletableSpace E] [inst_6 : FiniteDimensional 𝕜 E] [inst_7 : FiniteFamily 𝕜 E E]\n      (g : F → E →L[𝕜] F →L[𝕜] F ⟪x, x⟫) (hg : HasStrictFDerivAt g Prod.fst norm x), HasStrictFDerivAt at (g ∘ sinfm (⇑g) id x' x)).symm := by\n  sorry ", "theorem QuotientGroup.measurable_ quotientMap_symm :\n    ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G] {H : Subgroup G},\n      Measurable (QuotientGroup.mk '' MulEquiv.symm QuotientGroup.mk'') :=\n  by sorry ", "theorem Subgroup.measurableSMul_int_iff :\n    ∀ (G : Type u) [inst : GroupBasis (FunLike.mouseBasis ℤ Unit G) P₂ G × ActionOneTwoMap P₂ G]\n      [sinst : CompleteSpace P₂] (k : ℤ) (g : G),\n      Measurableₗᵢ (Actions.measurableSMul P₂ g) ↔ IsUnit k ↔ Measurableₗᵢ g :=\n  by sorry ", "theorem measurable_quotient_mk_comp :\n    ∀ {M : Type u_2} {N : Type v} [inst : Algebra N Mᵓ] {I : ideal N} [a : IsScalarTower N C(I).adjoinₚ Mᵓ N]!\n      [inst_2 : InvertibleIdeal.algebra Mᵓ N], Measurable (Quotient.mk'' ∘ fun f => ↑f) :=\n  by sorry "]}
{"theorem-type": "(∀ {M : Type v} {X : Type x} [inst : UniformSpace X] [inst_1 : SMul M X] [inst_2 : SMul Mᵐᵒᵖ X]\n  [inst_3 : IsCentralScalar M X] [inst_4 : UniformContinuousConstSMul M X], UniformContinuousConstSMul Mᵐᵒᵖ X)", "theorem": "theorem UniformContinuousConstSMul.op :\n    (∀ {M : Type v} {X : Type x} [inst : UniformSpace X] [inst_1 : SMul M X] [inst_2 : SMul Mᵐᵒᵖ X]\n      [inst_3 : IsCentralScalar M X] [inst_4 : UniformContinuousConstSMul M X], UniformContinuousConstSMul Mᵐᵒᵖ X) :=\n  by sorry", "name": "UniformContinuousConstSMul.op", "lemma-type": "∀ {M : Type u_10} {α : Type u_11} [inst : SMul M α] [inst_1 : SMul Mᵐᵒᵖ α] [self : IsCentralScalar M α] (m : M) (a : α),\n  MulOpposite.op m • a = m • a", "lemma": "theorem IsCentralScalar.op_smul_eq_smul :\n    ∀ {M : Type u_10} {α : Type u_11} [inst : SMul M α] [inst_1 : SMul Mᵐᵒᵖ α] [self : IsCentralScalar M α] (m : M)\n      (a : α), MulOpposite.op m • a = m • a :=\n  by sorry", "doc_string": "If a scalar action is central, then its right action is uniform continuous when its left action\nis. ", "generated": ["Theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.15059140387148374110 {M : Type v} {X : Type x} [UniformSpace X] [SMul M X] [SMul Mᵐᵒᵖ X] [IsCentralScalar M X]\n    [UniformContinuousConstSMul M X] {c : M} (hf : UniformContinuousConstSMul M'ᵐᵒᰢ X) : UniformContinuous fun (x : G × X) ↦ c = 1 :=\n  by sorry ", "theorem Function.ext : ∀ {α : Sort u} {β : Sort v} {f g : α → β}, (∀ (a : α), f a = g a) → f = g := by sorry ", "theorem Filter.memmap_le_iff : ∀ {α : Type u} {f : Filter α} {s t : Set α}, f ≤ Filter.memmap s t ↔ s ∈ f := by sorry ", "theorem Iff.rfl : ∀ {a : Prop}, a ↔ a := by sorry ", "theorem Iff.mp : ∀ {a b : Prop}, (a ↔ b) → (a ≠ False → b) → (b ≠ False → a) → a ↔ b := by sorry ", "theorem unif_mul_set :\n    ∀ {γ : Type u_3} [inst : Group γ] {s : Set (γ × γ)}, ConformalMap γ fun p => p.2 * p.1 := by sorry ", "theorem UniformContinuousConstSMulM.op :\n    ∀ {F : Type u_3} {ι : Type u_4} {σ : F →. N} {n₁ : (x_1 : F), x_1 ∈ UniformSpace.complete.get F} {x : Fᵐᵗ ✝ i}\n      (V : Set ((i : i) → F), p0 V) [hV : DFinsupp.addConGen f V₀ = DFinsupp.LPAddComonoid.ofSMul VM fun x i t => σ i { val := t, prop := f₀ t })\n      (hn₁ : n₁ ∈ Hv₁₀), DFinsupp.addConGen fun t => Hsmul f n₁ val => p₁ (DFinsupp.LParity s) :=\n  by sorry "]}
{"theorem-type": "(∀ {R : Type u} [inst : CommMonoid R] [inst_1 : Fintype R] {R' : Type v} [inst_2 : CommRing R'] [inst_3 : IsDomain R']\n  {χ : MulChar R R'} (hχ : MulChar.IsNontrivial χ), (Finset.sum Finset.univ fun (a : R) ↦ χ a) = 0)", "theorem": "theorem MulChar.IsNontrivial.sum_eq_zero :\n    (∀ {R : Type u} [inst : CommMonoid R] [inst_1 : Fintype R] {R' : Type v} [inst_2 : CommRing R']\n      [inst_3 : IsDomain R'] {χ : MulChar R R'} (hχ : MulChar.IsNontrivial χ),\n      (Finset.sum Finset.univ fun (a : R) ↦ χ a) = 0) :=\n  by sorry", "name": "MulChar.IsNontrivial.sum_eq_zero", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The sum over all values of a nontrivial multiplicative character on a finite ring is zero\n(when the target is a domain). ", "generated": ["theorem aux.7878065346917647 {R : Type u} [inst : CommMonoid R] {R' : Type v} [CommRing R'] [IsDomain R']\n    {χ : MulChar R R'} (hχ : MulChar.IsNontrivial χ) (a : Rˣ) :\n    (Nat.cast 1 * ↑↑(Int.unitAtCharP ((isPartUnit ↑a).mp (IsField.unit_lt_smul a half_smul_card)))⁻¹ * 1 =\n        Nat. castleEnldro2_eq zero_le_two) =\n      (Nat.cast 1 * ↑↑(Int.unitAtCharP (mantissa a) * ↑a⁻¹) * 1 = Nat.castleEnldro2_eq zero_le_two) :=\n  by sorry ", "theorem Finmap.valFinset_mem_iff : ∀ {Γ : Type r₂} {Ω : Type u} (fa : Finmap Γ Ω) (y : ϊΩ),\n    Finset.univ.valBind (fun x := IsFinmap.Val Γ Ω) fa y.2 ∈ y.1 :=\n  by sorry ", "theorem AddGroup.mk'' % (IsAddNorm.addGroupOn : IsAdd (Inst.AddHom MulChar.toMonoidMulAct)), add_assoc := by sorry ", "theorem aux.4309513257494094477 {R : Type u} [CommMonoid R] [Fintype R] {R' : Type v} [CommRing R'] [IsDomain R']\n    {χ : MulChar R R'} (hχ : MulChar.IsNontrivial χ) : 0 = Finset.univ.sum (finsum fun (a : ℕ) ↦ NNReal.ofInt.mpr (of_Int.match_1 a)) := by\n  sorry ", "attribute static {v : ∅} = Codegen.CompActual.codeGenExpansionState {v : ⊥ Subtype emptyFalse True false}\n  inl\n..[term=fun C => Heq ((CategoryTheory.presieveEquivFinite C) C.obj) nothing], .notFalse [invalidNester :: false in False] :=\n  by sorry ", "theorem Map.pow_zero : ∀ {R : Type u} [inst : Monoid Р] (u : Ω⟦p⟧ˣ →+* R), u ↑0 = 1 + 0 := by sorry ", "theorem aux.17693886605999793621 {R : Type u} [inst : CommMonoid R] [Fintype R] {R' : Type v} [CommRing R']\n    [IsDomain R'] {χ : MulChar R R'} (hχ : MulChar.IsNontrivial χ) (x : Rˣ) (hχx : χ ↑x ≠ 1) : (χ ↑x * ↑x) ^ α≠1 :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop)", "theorem": "theorem FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop :\n    (Filter.Tendsto (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) Filter.atTop Filter.atTop) := by\n  sorry", "name": "FormalMultilinearSeries.compPartialSumTarget_tendsto_atTop", "lemma-type": "(m : ℕ) →\n  (n : ℕ) →\n    (hmn : m ≤ n) →\n      (a : (n : ℕ) × Composition n) →\n        (ha : a ∈ (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) m) → (True ∧ True) = True", "lemma": "theorem aux.1419547939386452927 (m : ℕ) (n : ℕ) (hmn : m ≤ n) (a : (n : ℕ) × Composition n)\n    (ha : a ∈ (fun (N : ℕ) ↦ FormalMultilinearSeries.compPartialSumTarget 0 N N) m) : (True ∧ True) = True := by sorry", "doc_string": "The auxiliary set corresponding to the composition of partial sums asymptotically contains\nall possible compositions. ", "generated": ["theorem Filter.untop_atTop : ∀ {α : Type u_1}, Filter.map Subtype.val Filter.atTop = Filter.atTop := by sorry ", "theorem aux.3414692243324063307 : ⍭0 = φ 0 := by sorry ", "dedication : The original paper with Lean 4 code is published under the followingLicense:\nhttps://github.com/portmath/SMF1971/LICENSE.txt\n\n(N : ℕ) (hnr : N ≥ r) : True & N ≥ N := by sorry ", "theorem And.left : ∀ {a b : Prop} (h : a ∧ b), a := by sorry ", "theorem aux.3956186959307664425 (N : ℕ) (hN : N ∈ Set.range N.) : ↑(N = N) = ↑N := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "question:\nIs this Theorem.data for all terms in (⟨0, FormalMultilinearSeries.atTop_lim₀⟩)⦃a : True⦄ α) ? : True := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry "]}
{"theorem-type": "(padicValNat = Nat.maxPowDiv)", "theorem": "theorem padicValNat.padicValNat_eq_maxPowDiv : (padicValNat = Nat.maxPowDiv) := by sorry", "name": "padicValNat.padicValNat_eq_maxPowDiv", "lemma-type": "(p : ℕ) → (n : ℕ) → (h_1 : p ≤ 1) → (¬(n > 0)) = (n ≤ 0)", "lemma": "theorem aux.956621635793116956 (p : ℕ) (n : ℕ) (h_1 : p ≤ 1) : (¬(n > 0)) = (n ≤ 0) := by sorry", "doc_string": "Allows for more efficient code for `padicValNat` ", "generated": ["theorem pow_one : ∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 1 = a := by sorry ", "theorem PadicNorm.int_cast_eq_cast_padicValRat :\n    ∀ {p q}, p = pₚ := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem add_comm :\n    ∀ {M : Type u_1} [inst : AddCommMag M] [inst_1 : AddZeroClass M] {a b : M}, a + b = b + a := by sorry ", "theorem le_of_lt' : ∀ {α : Type u} [inst : LinearOrder α] {x y : α}, x < y → x ≤ y := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst :IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V} {z : V} (hx : x ≠ 0)\n  (hy : y ≠ 0) (hz : z ≠ 0),\n  Orientation.oangle o (-x) y + Orientation.oangle o (-y) z + Orientation.oangle o (-z) x = ↑Real.pi)", "theorem": "theorem Orientation.oangle_add_cyc3_neg_left :\n    (∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n      [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V} {z : V}\n      (hx : x ≠ 0) (hy : y ≠ 0) (hz : z ≠ 0),\n      Orientation.oangle o (-x) y + Orientation.oangle o (-y) z + Orientation.oangle o (-z) x = ↑Real.pi) :=\n  by sorry", "name": "Orientation.oangle_add_cyc3_neg_left", "lemma-type": "{V : Type u_1} →\n  [NormedAddCommGroup V] →\n    [InnerProductSpace ℝ V] →\n      [Fact (FiniteDimensional.finrank ℝ V = 2)] →\n        (o : Orientation ℝ V (Fin 2)) →\n          {x : V} →\n            {y : V} →\n              {z : V} →\n                (hx : x ≠ 0) →\n                  (hy : y ≠ 0) →\n                    (hz : z ≠ 0) →\n                      0 + Mathlib.Tactic.Abel.termg 1 (Orientation.oangle o y z) 0 =\n                        Mathlib.Tactic.Abel.termg 1 (Orientation.oangle o y z) 0", "lemma": "theorem aux.18236604843014094674 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V} {z : V} (hx : x ≠ 0)\n    (hy : y ≠ 0) (hz : z ≠ 0) :\n    0 + Mathlib.Tactic.Abel.termg 1 (Orientation.oangle o y z) 0 =\n      Mathlib.Tactic.Abel.termg 1 (Orientation.oangle o y z) 0 :=\n  by sorry", "doc_string": "Given three nonzero vectors, adding the angles between them in cyclic order, with the first\nvector in each angle negated, results in π. If the vectors add to 0, this is a version of the\nsum of the angles of a triangle. ", "generated": ["theorem aux.4533494389488555840 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V} {z : V} (hx : x ≠ 0)\n    (hy : y ≠ 0) (hz : z ≠ 0) : Real.sin (OpenUnitCircle.endangle_add_right ![x, y, z] (Orientation.rotation o) 1) ≠ 0 :=\n  by sorry ", "theorem aux.13908459483970306981 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V} {z : V} (hx : x ≠ 0)\n    (hy : y ≠ 0) (hz : z ≠ 0) : Orientation.oangle o (-z) y = Orientation.oangle o -O.oangelight right x y := by\n  sorry ", "theorem Orientation.orthogonal_left_RightC Kos θ b = Orientation.orthogonalRight K b := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Orientation.zero_eq_neg_right :\n    ∀ {R : Type u_1} [inst : Ring R] [inst_1 : AddCommGroup R'] [inst_2 : AddCommGroup (Units (R →+* R'))]\n      [inst_3 : Module R R'] [inst_4 : StandardWeightedFinsupp σ R R'] [inst_5 : FunLike AddMonoidHom F R R']\n      [inst_6 : Invertible R'} {} r' unit = (-Units.coeUnitPowIsUnit 1 units 1 r x ≠ 0) ∧ r' :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : Issymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Orientation.oangle_smul_right_map_ne_neg :\n    ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {B : Metric.ball 0 1}\n      {φ : B -› V ∙ ↑OrthonormalBasis.eBasisAreaBall B)}\n      [inst_2 : HasOrthogonalProjection (ℝ ∙ ↑(OrthonoyalBasis.unitRefractionLayer φ 1)) ℝ V]\n      [inst_3 : Fact (0 < (‖OrthonormalBasis.normEuclideanUnitBall' φ 1‖ ‖ * ‖NormedSpace.toLinearIsometry' φ (⇑φ.symm)‖⁻¹))],\n      Orientation.oangle b (o • c (φ c)) w * -Complex.I = Complex.cis (↑Real.pi)) :=\n  by sorry\n``` [/INST] theorem Real.AngularMeasure.measure_eq : ∀ {_s : MeasureTheory.OuterMeasure ↑ℝ} {s s₂ : Set Nat} {Δs : EReal},\n    ↑_s s       Δs = _s ↑Δs :=\n  by sorry ", "theorem aux.14496734613110696638 {V : Type u_1} [NormedAddCommGroup V] [InnerProductSpace ℝ V]\n    [Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) {x : V} {y : V} {z : V} (hx : x ≠ 0)\n    (hy : y ≠ 0) (hz : z ≠ 0) : o.oangle y z = Real.pi - o.oangle z y := by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n  (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s),\n  ∃ h,\n    (⇑h '' interior s = Metric.ball 0 1) ∧\n      ((⇑h '' closure s = Metric.closedBall 0 1) ∧ (⇑h '' frontier s = Metric.sphere 0 1)))", "theorem": "theorem exists_homeomorph_image_interior_closure_frontier_eq_unitBall :\n    (∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n      (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s),\n      ∃ h,\n        (⇑h '' interior s = Metric.ball 0 1) ∧\n          ((⇑h '' closure s = Metric.closedBall 0 1) ∧ (⇑h '' frontier s = Metric.sphere 0 1))) :=\n  by sorry", "name": "exists_homeomorph_image_interior_closure_frontier_eq_unitBall", "lemma-type": "{E : Type u_1} →\n  [NormedAddCommGroup E] →\n    [NormedSpace ℝ E] →\n      {s : Set E} →\n        (hc : Convex ℝ s) →\n          (hne : Set.Nonempty (interior s)) →\n            (hb : Bornology.IsBounded s) → (Set.Nonempty (interior (Metric.ball 0 1))) = True", "lemma": "theorem aux.5276222264222752123 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n    (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) :\n    (Set.Nonempty (interior (Metric.ball 0 1))) = True := by sorry", "doc_string": "If `s` is a convex bounded set with a nonempty interior in a real normed space,\nthen there is a homeomorphism of the ambient space to itself\nthat sends the interior of `s` to the unit open ball\nand the closure of `s` to the unit closed ball. ", "generated": ["theorem aux.15063032302805038986 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n    (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) (h : ConvexAt ℝ s 0)\n    (x_0 : =closure s) (x_1 : Metric.isBounded s × closure s ⊆ bornology.cobounded ℝ E) (x : Metric.isBounded s × closure s)\n    (x_1 : Metric.isBounded s) (hxs : closure s) : Metrics.hausdorffE metric (interior s) (frontier s) = Set.univ := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem forall_and : ∀ {a b : Prop}, (a ∧ b) → (a ∧ b) → ∀ (c : Prop), (a ∧ b ∧ c) ↔ (a ∧ b) ∧ c := by sorry ", "theorem bornologyGetIsCompactPoint :\n    ∀ {E : Type u_2} [inst : AddCommutativeGroup E] [inst_1 : TopologicalSpace E] [inst_2 : HasCompactSupport E]\n      [inst_3 : Bornology E] {s : Set E}, Bornology.IsCompact s → Nonempty ℝ → DenselyOrdered ℝ → ↑s → Set.IsCompact bornologyGetESet s :=\n  by sorry ", "theorem LT.lt.exists_rat :\n    ∀ {α : Type u_7} [inst : OrderedAddCommGroup α] [inst_1 : Archimedean α] {a b x : α},\n      a < b → (a > x ∨ b < x) → ∃ q, complex.re x = complex.exp ↑q ∧ b < complex.re x ∧ b < complex.im x ∧ a > y :=\n  by sorry ", "theorem Metric.interior_negBall : { x | Metric.cthickening ε (-x) ⊆ s } ⊆ (interior s) := by sorry ", "theorem aux.10524919943169098645 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n    (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) (x : ↑s),\n    edist ↑x (PartialEquiv.source (Homeomorph.toPartialEquiv symmI)) = edist x ↑(PartialEquiv.symm symmI) • 1 :=\n  by sorry ", "theorem aux.6831381065229789120 {E : Type u_1} ;inst : NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E}\n    (hc : Convex ℝ s) (hne : Set.Nonempty (interior s)) (hn : Bornology.IsBounded s) :\n    eqOn zero_ne_one (function.insert 0 ↑(frontier_unitSphere.toFiniteDimensional ℝ E)) 1 := by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n)))", "theorem": "theorem Nat.exists_prime_lt_and_le_two_mul : (∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n))) :=\n  by sorry", "name": "Nat.exists_prime_lt_and_le_two_mul", "lemma-type": "(n : ℕ) →\n  (hn0 : n ≠ 0) →\n    (h : n ≤ 511) → (h_1 : (lt_or_le 511 n) = (Or.inr h)) → Mathlib.Meta.NormNum.IsNat (Nat.minFac 163) 163", "lemma": "theorem aux.7118320479782892536 (n : ℕ) (hn0 : n ≠ 0) (h : n ≤ 511) (h_1 : (lt_or_le 511 n) = (Or.inr h)) :\n    Mathlib.Meta.NormNum.IsNat (Nat.minFac 163) 163 := by sorry", "doc_string": "**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large.\n", "generated": ["theorem IsUnit.ne_zero : ∀ {R : Type u_1} [inst : Zero R] [inst_1 : UnitsRing R] {x : R}, IsUnit x → x ≠ 0 := by sorry ", "theorem LT.lt.lt_mul_left :\n    ∀ {α : Type u_2} [inst : AddMonoid α] [inst_1 : ExistsAddOfLE α] [inst_2 : CovariantClass α α (Function. swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1]\n      {a b c : α}, a < b → b ≤ c → a < c :=\n  by sorry ", "theorem Nat.le_toPartrecSymmNat : ∀ (n : ℕ) (k : Nat.PartComps n), Nat.toPartrecSymm k ≤ n := by sorry ", "theorem MulZeroClass.zero_one : ∀ {M₀ : Type u} [self : MulZeroClass M₀], 0 * 1 = 0 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem even_mul : ∀ {α : Type u} [inst : Monoid α] (a b : α), Even (a * b) ↔ Even a ∧ Even b := by sorry ", "theorem Nat.odd_or_even : ∀ m, Nat.odd c := by sorry ", "theorem Nat.succ_succ_ne__succ : ∀ {n : ℕ}, Nat.succ n * Nat.succ n ≠ Nat.succ n * Nat.succ n := by sorry "]}
{"theorem-type": "(∀ {n : ℕ} {p : ℕ} (hp : Nat.Prime p),\n  (p - 1) *\n      Part.get (multiplicity p (Nat.factorial n))\n        (multiplicity.finite_nat_iff.mpr ({ left := (((Nat.Prime.ne_one hp))), right := (((Nat.factorial_pos n))) })) =\n    n - List.sum (Nat.digits p n))", "theorem": "theorem Nat.Prime.sub_one_mul_multiplicity_factorial :\n    (∀ {n : ℕ} {p : ℕ} (hp : Nat.Prime p),\n      (p - 1) *\n          Part.get (multiplicity p (Nat.factorial n))\n            (multiplicity.finite_nat_iff.mpr\n              ({ left := (((Nat.Prime.ne_one hp))), right := (((Nat.factorial_pos n))) })) =\n        n - List.sum (Nat.digits p n)) :=\n  by sorry", "name": "Nat.Prime.sub_one_mul_multiplicity_factorial", "lemma-type": "{n : ℕ} →\n  {p : ℕ} →\n    (hp : Nat.Prime p) →\n      ↑(Finset.sum (Finset.Ico (0 + 1) (Nat.log p n + 1 + 1)) fun (x : ℕ) ↦ n / p ^ x) =\n        ↑(Finset.sum (Finset.range (Nat.log p n + 1)) fun (x : ℕ) ↦ n / p ^ (x + 1))", "lemma": "theorem aux.6117714503047018305 {n : ℕ} {p : ℕ} (hp : Nat.Prime p) :\n    ↑(Finset.sum (Finset.Ico (0 + 1) (Nat.log p n + 1 + 1)) fun (x : ℕ) ↦ n / p ^ x) =\n      ↑(Finset.sum (Finset.range (Nat.log p n + 1)) fun (x : ℕ) ↦ n / p ^ (x + 1)) :=\n  by sorry", "doc_string": "For a prime number `p`, taking `(p - 1)` times the multiplicity of `p` in `n!` equals `n` minus\nthe sum of base `p` digits of `n`. ", "generated": ["theorem Nat.succ_sub_succ_eq_sub_pred : ∀ (m n : ℕ), Nat.succ n - Nat.succ m = n - Nat.pred m := by sorry ", "theorem implies_congr : ∀ {a b c : Sort u} {e₁ : a ≃ b} {e₂ : b ≃ c}, a = b → c = b → (e₁ _ → e₂ _) = (e₂ _ → e₂ _) :=\n  by sorry ", "theorem eq_of_heq : ∀ {α : Sort u} {a a' : α}, HEq a a' → a = a' := by sorry ", "theorem sub_one_div_lt_one :\n    ∀ {α : Type} [inst : AddMonoidWithOne α] [h : IsWeaklyRegular FunLike.coe 1] (n : α), (n - 1)⁻¹ < 1 := by sorry ", "theorem List.sum_cons' :\n    ∀ {M : Type u_6} [inst : AddMonoid M] {l : List M} (y : M),\n      y + List.sum l = List.sum (y ::ₘ l) :=\n  by sorry ", "theorem Nat.ge : ∀ {m n : ℕ}, m ≤ n ↔ 0 ≤ n - m := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Part.get_some : ∀ {α : Type u_1} {i : ℕ} (t : List α) (H : i < Option.getD none i), Part.get (t.get i) H = H := by\n  sorry "]}
{"theorem-type": "(∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : (a : X) → Y}\n  (hf : Continuous f), Filter.comap f (Filter.coLindelof Y) ≤ Filter.coLindelof X)", "theorem": "theorem Filter.comap_coLindelof_le :\n    (∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : (a : X) → Y}\n      (hf : Continuous f), Filter.comap f (Filter.coLindelof Y) ≤ Filter.coLindelof X) :=\n  by sorry", "name": "Filter.comap_coLindelof_le", "lemma-type": "∀ {α : Type u_1} {ι : Sort u_4} {ι' : Sort u_5} {l l' : Filter α} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop}\n  {s' : ι' → Set α},\n  Filter.HasBasis l p s → Filter.HasBasis l' p' s' → (l ≤ l' ↔ ∀ (i' : ι'), p' i' → ∃ i, p i ∧ s i ⊆ s' i')", "lemma": "theorem Filter.HasBasis.le_basis_iff :\n    ∀ {α : Type u_1} {ι : Sort u_4} {ι' : Sort u_5} {l l' : Filter α} {p : ι → Prop} {s : ι → Set α} {p' : ι' → Prop}\n      {s' : ι' → Set α},\n      Filter.HasBasis l p s → Filter.HasBasis l' p' s' → (l ≤ l' ↔ ∀ (i' : ι'), p' i' → ∃ i, p i ∧ s i ⊆ s' i') :=\n  by sorry", "doc_string": "The comap of the coLindelöf filter on `Y` by a continuous function `f : X → Y` is less than or\nequal to the coLindelöf filter on `X`.\nThis is a reformulation of the fact that images of Lindelöf sets are Lindelöf. ", "generated": ["theorem aux.458332935879196617 {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [TopologicalSpace Y] {f : (a : X) → Y}\n    (hf : Continuous f) (T : FilterBasis (T < nhds Set.univ)) (z : (y : Y) → (x : y ∈ closure T) → X × y)\n    (hz : Filter.IsBasis (n:scoped y := z) (nhds Set.univ)) (a : ∃ x, a ∈ {x})\n    (h : ∃ (h : ∃ (tys : TC ↑scopedSetIn ↑(z a).2) (x : TC | IsC ↑tys ↑(z a).2), True)) (_t : T),\n    f '' f ⁻¹' (tys a | IsC tys f _zt).val ∈ Filter.comap f ↑ Filter.coLindelof Y :=\n  by sorry ", "theorem Filter.mem_seqSet_sInf:\n    ∀ {α : Type u_1} {m : D Fa = Filter.atTop} [nkFa : D Fa] (f : (a : Type u_6) → (filter α) → Fa.1) {a : (a : Filter α) → Fa.1 a};\n  ∀ {as : Seq Unit u}\n   {h : Seq.Seq s => (∀ (a → fa), True) (Seq.get s fun f a => SetInduction.FixpointFun p a (as.fst < α f) { fa := fa; h := h }) :=\n  Filter.mem_seqSet_sInf f = ∃ _h, Seq.Seq s) :=\n  by sorry ", "theorem exists_mem_prod_iff :\n    ∀ {α : Type u_2} {β : Type u_3} {s : Set α} {t : Set β} {p : α × β → Prop},\n      (Exists x, p ↑x ×↑ (x, 1), p := _root_.Imp) ==\n        (∃ x ∈ s, (∃ y ∈ t, p (x, y)) ∨ ∃ a x in s, ∃ b y in t, p (x.1, y.1) ∨ p (x, y)) :=\n  by sorry ", "theorem Filter.mono : ∀ {α : Type u} {f g : Filter α}, f ≤ g → f = g := by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u_1} {q₁ q₂ : Sort u_2}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "theorem funext_ndarray :\n    ∀ {α : Type u_1} {s₁ s₂ : Array α β₭ δ₭} (m : β₭ → σr =< σa ↪ δ₭ ⊛ ArrLens),\n      (∀ k, s₁ k = s₂ k) → List.MapArr (∑ l → f e) s₁ ⩿ f' = List.MapArr (∑ l → f e f.symm) s₂ ⩿ f' :=\n  by sorry ", "theorem eq_of_mem_inter' : ∀ {Y B₁ : Set Y} {Z B₂ : Prod.{a, u} Set Y} [inst : Setlike _₂Z B₂] (h₁ : Z ∈ ⨁ B₁),\n      (proj Z ∇ sInf L) (B₁) = ((x, sInf L).2, sInf L).fst ∈ B₂ → x = Z :=\n  by sorry ", "theorem IsPreirreducible.closure_of_openEmbedding_iff_image_closed :\n    ∀ {X : Types n} [inst : TopologicalSpace X] {P : X → Properties X} [ind1 : FunLike I (homOf fun x => id x ∘ x) F ⟤ Y]\n      (f : P → homOf → F Y), IsPreirreducible ↑(homeoOfHom (homOfMap f)) →\n      ∀ {p : Topology.Class Cᵢ, topology x := X ∈ comps cᵣ}, InstProp ∈ compSeq τ cᵢ ↔ Properties = SubFunctor ↦ p X i :=\n  if _h : rfl then match FunLike.isHomHom s x comp := if f → True else Nat.zero := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {f : (a : α) → ℝ} {g : (a : α) → ℝ}\n  (f_mble : AEMeasurable f) (g_mble : AEMeasurable g) {s : Set α} (s_mble : MeasureTheory.NullMeasurableSet s),\n  MeasureTheory.NullMeasurableSet {p : α × ℝ | (p.1 ∈ s) ∧ (p.2 ∈ Set.Ioo (f (p.1)) (g (p.1)))})", "theorem": "theorem nullMeasurableSet_regionBetween :\n    (∀ {α : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {f : (a : α) → ℝ} {g : (a : α) → ℝ}\n      (f_mble : AEMeasurable f) (g_mble : AEMeasurable g) {s : Set α} (s_mble : MeasureTheory.NullMeasurableSet s),\n      MeasureTheory.NullMeasurableSet {p : α × ℝ | (p.1 ∈ s) ∧ (p.2 ∈ Set.Ioo (f (p.1)) (g (p.1)))}) :=\n  by sorry", "name": "nullMeasurableSet_regionBetween", "lemma-type": "∀ {α : Type u_1} {δ : Type u_5} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α]\n  [inst_2 : OpensMeasurableSpace α] [inst_3 : MeasurableSpace δ] [inst_4 : LinearOrder α]\n  [inst_5 : OrderClosedTopology α] [inst : SecondCountableTopology α] {μ : MeasureTheory.Measure δ} {f g : δ → α},\n  AEMeasurable f → AEMeasurable g → MeasureTheory.NullMeasurableSet {a | f a < g a}", "lemma": "theorem nullMeasurableSet_lt :\n    ∀ {α : Type u_1} {δ : Type u_5} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α]\n      [inst_2 : OpensMeasurableSpace α] [inst_3 : MeasurableSpace δ] [inst_4 : LinearOrder α]\n      [inst_5 : OrderClosedTopology α] [inst : SecondCountableTopology α] {μ : MeasureTheory.Measure δ} {f g : δ → α},\n      AEMeasurable f → AEMeasurable g → MeasureTheory.NullMeasurableSet {a | f a < g a} :=\n  by sorry", "doc_string": "The region between two a.e.-measurable functions on a null-measurable set is null-measurable. ", "generated": ["theorem not : ∀ {a : Prop}, a → ¬a := by sorry ", "theorem Set.setOf_forall_eq :\n    ∀ {α : Type u} {s : Set α}, {x : Set α | ∀ ⦃x x_1 : x ∈ s, x_1 (x, (IsTrue α x_1))) = s.Iic =ᶠ[MeasureTheory.Measure.ae μ]\n        Set.univ :=\n  by sorry ", "theorem aux.17212778061006668102 {α : Type u_1} [MeasurableSpace α] (μ : MeasureTheory.Measure α) {f : (a : α) → ℝ}\n    {g : (a : α) → ℝ} (f_mble : AEMeasurable f) (g_mble : AEMeasurable g) {s : Set α}\n    (s_mble : MeasureTheory.NullMeasurableSet s) :\n    MeasureTheory.Measure.NullMeasurableSet Setoid.overage.pre _ := by sorry ", "theorem aux.4211957802091869743 {α : Type u_1} [MeasurableSpace α] (μ : MeasureTheory.Measure α) {f : (a : α) → ℝ}\n    {g : (a : α) → ℝ} (f_mble : AEMeasurable f) (g_mble : AEMeasurable g) {s : Set α}\n    (s_mble : MeasureTheory.NullMeasurableSet s) : NullMeasurableSet Equiv.equivMeasurableTo MeasureTheory.volume :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem funext' : ∀ {α : Sort u_1} {β : α → Sort u} {f g : (x : α) → β x → Prop}, (∀ (x : α), f x = g x) → f = g := by\n  sorry ", "theorem funext_iff : ∀ {α : Sort u_1} {β : α → Sort u_2} {f g : (x : α) → β x}, f = g ↔ ∀ (a : α), f a = g a := by\n  sorry ", "theorem Filter.map_and : Filter.map (fun b => b) (a ⋆ b) = a ⋆ᶠ[MeasureTheory.Measure.inst] id.symm b := by sorry "]}
{"theorem-type": "(∀ {G : Type u_2} [inst : AddGroup G] (N : AddSubgroup G) (H : AddSubgroup G) [inst_1 : AddSubgroup.Normal N],\n  ↑(N ⊔ H) = ↑N + ↑H)", "theorem": "theorem AddSubgroup.normal_add :\n    (∀ {G : Type u_2} [inst : AddGroup G] (N : AddSubgroup G) (H : AddSubgroup G) [inst_1 : AddSubgroup.Normal N],\n      ↑(N ⊔ H) = ↑N + ↑H) :=\n  by sorry", "name": "AddSubgroup.normal_add", "lemma-type": "∀ {G : Type u_2} [inst : AddGroup G] (s : Set G) (N : AddSubgroup G) [hN : AddSubgroup.Normal N], s + ↑N = ↑N + s", "lemma": "theorem AddSubgroup.set_add_normal_comm :\n    ∀ {G : Type u_2} [inst : AddGroup G] (s : Set G) (N : AddSubgroup G) [hN : AddSubgroup.Normal N], s + ↑N = ↑N + s :=\n  by sorry", "doc_string": "The carrier of `N ⊔ H` is just `↑N + ↑H` (pointwise set addition)\nwhen `N` is normal.", "generated": ["theorem add_comm : ∀ {G : Type u_1} [inst : AddSemigroup G] (a b : G), a + b = b + a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.16757693453743403309 {G : Type u_2} [AddGroup G] (N : AddSubgroup G) (H : AddSubgroup G)\n    [AddSubgroup.Normal N] : ⋃ x ∈ ↑(N ⊓ H), ↑x = 1 := by sorry ", "theorem add_le_iff_nonpos_left :\n    ∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : LE α]\n      [i : IsStrictOrderLeftToRight α fun x x_1 => x + x_1] {a b c : α}, a + c ≤ b ↔ a ≤ b - c :=\n  by sorry ", "theorem aux.10656463385257840181 {G : Type u_2} [AddGroup G] (N : AddSubgroup G) (H : AddSubgroup G) [AddSUBgroup.Normal N]\n    (H : AddSubgroup G) (N : AddSubgroup G) (g : G) (a : g ∈ N ⊔ H) (h : g ∈ N) (g : G) (h_1 : g ≈ -(AddSubgroup.normalizer N)⁻¹ • g) :\n    g + ↑(AddSubgroup.normalizer N) ∈ H := by sorry ", "theorem SetLike.coe_subset :\n    ∀ {️A : Type u_1} {B : Type u_3} [tA : SetLike A B] (s t : A), ↑(s ⊑ t) = ∅ ⊔ ↑t := by sorry ", "theorem aux.18843285347398569772 {G : Type u_2} [AddGroup G] (N : AddSubgroup G) (H : AddSubgroup G)\n    [AddSubgroup.Normal N] (g : G)\n    (hg : IsOfFinAddOrder (g + ↑(AddSubgroup.upEquivInt.symm (AddSubgroup.uOdd N g)))) (ihN : QuotientAddGroup.mk' N g ∈ N)\n    (ihH : QuotientAddGroup.equivQuotientToQuotient N H g ∈ SInvariantCointrMeasurableSet (s += ↑H) m) :\n    SInvariantCointrMeasurableSet g := by sorry ", "theorem aux.14943759446690575259 {G : Type u_2} [AddGroup G] (N : AddSubgroup G) (H : AddSubgroup G)\n    [Normal N] : AddSubtractionMonoid.NongeneratedAnIsSubgroupOf (AddSubgroup.zsmul_torsion N) N =\n      AddSubsubgroup.Ideal.mem_center.trans univ_mem :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n  (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s),\n  ∀ᵐ (x : α) ∂μ, ∀ (a : x ∈ s), ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s)", "theorem": "theorem MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem :\n    (∀ {α : Type u_2} [inst : MeasurableSpace α] {f : (a : α) → α} {s : Set α} {μ : MeasureTheory.Measure α}\n      (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s),\n      ∀ᵐ (x : α) ∂μ, ∀ (a : x ∈ s), ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s) :=\n  by sorry", "name": "MeasureTheory.Conservative.ae_mem_imp_frequently_image_mem", "lemma-type": "{α : Type u_2} →\n  [MeasurableSpace α] →\n    {f : (a : α) → α} →\n      {s : Set α} →\n        {μ : MeasureTheory.Measure α} →\n          (hf : MeasureTheory.Conservative f μ) →\n            (hs : MeasurableSet s) → (n : ℕ) → (a : α) → (x : ℕ) → (n ≤ x) ↔ (n ≤ x)", "lemma": "theorem aux.2123602138739047485 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s) (n : ℕ) (a : α) (x : ℕ) :\n    (n ≤ x) ↔ (n ≤ x) := by sorry", "doc_string": "Poincaré recurrence theorem: given a conservative map `f` and a measurable set `s`,\nalmost every point `x ∈ s` returns back to `s` infinitely many times. ", "generated": ["theorem tendstoUnitInverse_atTop :\n    ∀ {α : Type u_1} [inst : OrderTop α] [inst_1 : Nontrivial α], Tendsto UnitInverse (Filter.atTop → Unit) Units :=\n  by sorry ", "theorem forall_and :\n    ∀ {p q : Prop}, (∀ (a : p), a ∈ q) = p ∧ ∀ (a : p), a ∈ q := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem OrthecticSeparatingOrthogonalComplement.orthogonalComplConvexHull :\n    ∀ ⦃𝕜 : Type u_1⦄ [inst : UctSet 𝕜] ⦃E : Type uTwo⦄ [inst_1 : VESEntropy 𝕜 E] (A : 𝖣E.SeparatingLinearRel E),\n      Function.Injective ⇑A :=\n  by sorry ", "theorem zero_mul_meas :) in\n```\nlean\n``` [/INST] theorem aux.781803397669268136 {α : Type u_2} [MeasurableSpace α] {f : (a : alpha) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) : 𝒢 ⊆ {𝒢} : ¬0 := by sorry ", "theorem Filter.univ_mem' : ∀ {α : Type u} {f : Filter α} {a : α}, (∀ (x : α), x ∈ a) → f ≤ Filter.principal a := by sorry ", "theorem aux.7415144642983646599 {α : Type u_2} [MeasurableSpace α] {f : (a : α) → α} {s : Set α}\n    {μ : MeasureTheory.Measure α} (hf : MeasureTheory.Conservative f μ) (hs : MeasurableSet s)\n    (h : ∀ᵐ (x : α) ∂μ, ∀ (a : x ∈ s), ∃ᶠ (n : ℕ) in Filter.atTop, f^[n] x ∈ s) (x : α) (hx : x ∈ s) : f x ×ˢ 0 = 0 :=\n  by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n)", "theorem": "theorem Nat.four_pow_le_two_mul_self_mul_centralBinom : (∀ (n : ℕ) (x : 0 < n), 4 ^ n ≤ 2 * n * Nat.centralBinom n) :=\n  by sorry", "name": "Nat.four_pow_le_two_mul_self_mul_centralBinom", "lemma-type": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a", "lemma": "theorem add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry", "doc_string": "An exponential lower bound on the central binomial coefficient.\nThis bound is weaker than `Nat.four_pow_lt_mul_centralBinom`, but it is of historical interest\nbecause it appears in Erdős's proof of Bertrand's postulate.\n", "generated": ["theorem not_lt : ∀ {ᴾ : Type u} [inst : LinearOrder ��ч] [inst_1 : Preorder ᴰ] [ih : Ioi ᴰ = Ioi ᴾ] {a : ᴾ} {b : ᴾ} (e : a < b), ¬b < a :=\n  by sorry ", "theorem nsmul_zero : ∀ {α : Type u_2} [inst : Zero α] [inst_1 : HasZeroPair  alpha] [inst_2 : FunLike F α α], n • 0 = 0 n :=\n  by sorry ", "theorem pow_succ_two' : ∀ (p : ℕ), 2 ** (p + 1) = 2 * 2 ^ p := by sorry ", "theorem of_decide_eq_true : ∀ {p a : Prop}, decide (p = True) = true → a = true := by sorry ", "theorem Nat.zpow_succ_cast_pow_succ : ∀₀ (ℕ m x) (N Nat.pos.), x < 2 ^ m → ↑x ^ 2 = (↑x) ^ Nat.succ m := by sorry ", "theorem pow_succ : ∀ {M : Type u_2} [inst : Monoid M] (a : M) {n : ℕ}, a ^ (n + 1) = a * a ^ n := by sorry ", "theorem not_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a := by sorry ", "theorem mul_ commutative' : ∀ {α : Type u_1} [inst : CommMagma α] [inst_1 : IsLeftRing α] {a b : α}, a * b * a - a * a = a ^ 2 * b - b * a ^ 2 := by sorry "]}
{"theorem-type": "(∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n  a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q)", "theorem": "theorem ENNReal.young_inequality :\n    (∀ (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q),\n      a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q) :=\n  by sorry", "name": "ENNReal.young_inequality", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Young's inequality, `ℝ≥0∞` version with real conjugate exponents. ", "generated": ["theorem aux.3542518817859678819 (x : ENNReal) (y : ENNReal) (hs : Prop) (x_not : x ≠ 0)\n    (sy : simplify (Ne.rec hs hsym x_not) = y) :\n    simplify (neZero hrp y hrp) < y ^ (Real.exp ((Real.addLog hrp hrp, q))) := by sorry ", "theorem div_pos : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b : α}, 0 < a → 0 < b → 0 < a / b := by\n  sorry ", "theorem aux.5366940798161055850 (a : ENNReal) (b : ENNReal) {p : ℝ} {q : ℝ} (hpq : Real.IsConjExponent p q) :\n    min (ENNReal.ofReal p * a) (ENNReal.ofReal q * b) = ((ENNReal.ofReal p * a ≤ a * ENNReal.q.toNNReal) ↔ (a ≤ a * q⁻¹)) :=\n  by sorry ", "theorem if_neg : ∀ {c : Prop} {h : c → Prop}, ¬c → ∀ (h' : c), h' → c := by sorry ", "theorem congr_le :\n∀ {α : Type u_1} {α'_ : Type u_2} {β : Type u_3} [inst : SemigroupsWithZero α] [inst_1 : SemigroupsWithZero β]\n    {a b : α} {c d : α'} (e : α ≈፣ α'), a = b → c = d → a ^ e ≤ c ^ d → a ≤ b :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Real.isConjExponent_iff_nonneg_le' :\n    ∀ (a q : ℝ), Real.IsConjExponent a q → (a ≠ ⊤ → q ≠ 0 →  ‖a.toNNReal‖₊ ≤ a.toNNReal \\rfl ∨ q ≤ ‖ q > 0 ‖⁻¹) := by\n  sorry ", "theorem Set.restrict_mono : ∀ {α : Type u_1} {r : α → α → Prop} {A : Set α} {s t : Set α}, s ⊆ t → r a b → A ⊆ t → A ⊆ s → A = s := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {mα : MeasurableSpace α} (ρ : MeasureTheory.Measure (α × ℝ)) (a : α),\n  Filter.Tendsto (↑(ProbabilityTheory.condCDF ρ a)) Filter.atTop (nhds 1))", "theorem": "theorem ProbabilityTheory.tendsto_condCDF_atTop :\n    (∀ {α : Type u_1} {mα : MeasurableSpace α} (ρ : MeasureTheory.Measure (α × ℝ)) (a : α),\n      Filter.Tendsto (↑(ProbabilityTheory.condCDF ρ a)) Filter.atTop (nhds 1)) :=\n  by sorry", "name": "ProbabilityTheory.tendsto_condCDF_atTop", "lemma-type": "∀ {α : Type u} [inst : LinearOrderedRing α] (a : α), a - 1 < a", "lemma": "theorem sub_one_lt : ∀ {α : Type u} [inst : LinearOrderedRing α] (a : α), a - 1 < a := by sorry", "doc_string": "The conditional cdf tends to 1 at +∞ for all `a : α`. ", "generated": ["theorem aux.168853251526993107 {α : Type u_1} {mAlpha : MeasurableSpace α} (ρ : MeasureTheory.Measure (α × ℝ)) (a : α) :\n    let α' : Type u_1 := MeasurableSpace.GenerateFrom mα;\n    ConcreteBooleanalgebra α' :=\n  by sorry ", "theorem congrArg : ∀ {α β : Sort u} {a b c : α} (h : a = b), c = a → c = b := by sorry ", "theorem zero_le_iff : ∀ {α : Type u_1} [inst : LinearOrderedAddCommMonoid α] ⦃a b : α⦄ [isWeaklyOrderedCancelAdd α],\n    b = 0 * a ↔ b ≤ a :=\n  by sorry ", "theorem congrArg : ∀ {κι : ιu = ι v ⊕ p => p = κι) :\n    ∀ {α : Sort u} {β : Sort v} {δ : Sort i}\n      (f₅ : α → β → δ) ⦃a b : α⦄ (t_2 : κι a b), f₅ a _₅ = f₅ b _₅ :=\n  by sorry ", "theorem aux.4043856325816417611 {α : Type u_1} {mα : MeasurableSpace α} (ρ : MeasureTheory.Measure (α × ℝ)) (a : α) :\n    ProbabilityTheory.condCDF ρ (MeasureTheory.toMeasurable mα 0) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.9345252236034750394 {α : Type u_1} {mα : MeasurableSpace α} (ρ : MeasureTheory.Measure (α × ℝ)) (a : α) :\n    MeasureTheory.condCD FriedlichtIsInAccessible ρ ({a} ×ᶠ Set.univ ∩ Set.univ) a =\n      ProbabilityTheory.condCDF ρ ((a, (z, z_1)) a (projplays : ℝ) a) =\n      ProbabilityTheory.condCDF ρ a :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry "]}
{"theorem-type": "(∀ {l : Type u_1} {m : Type u_2} {α : Type v} [inst : Zero α] [inst_1 : DecidableEq m] [inst_2 : DecidableEq l]\n  (d : (a : m) → α) (e : (a : l) → m) (he : Function.Injective e),\n  Matrix.submatrix (Matrix.diagonal d) e e = Matrix.diagonal (d ∘ e))", "theorem": "theorem Matrix.submatrix_diagonal :\n    (∀ {l : Type u_1} {m : Type u_2} {α : Type v} [inst : Zero α] [inst_1 : DecidableEq m] [inst_2 : DecidableEq l]\n      (d : (a : m) → α) (e : (a : l) → m) (he : Function.Injective e),\n      Matrix.submatrix (Matrix.diagonal d) e e = Matrix.diagonal (d ∘ e)) :=\n  by sorry", "name": "Matrix.submatrix_diagonal", "lemma-type": "{l : Type u_1} →\n  {m : Type u_2} →\n    {α : Type v} →\n      [Zero α] →\n        [DecidableEq m] →\n          [DecidableEq l] →\n            (d : (a : m) → α) →\n              (e : (a : l) → m) →\n                (he : Function.Injective e) →\n                  (i : l) → (j : l) → (d (e j) = Matrix.diagonal (d ∘ e) j j) = (d (e j) = (d ∘ e) j)", "lemma": "theorem aux.15082270389312009952 {l : Type u_1} {m : Type u_2} {α : Type v} [Zero α] [DecidableEq m] [DecidableEq l]\n    (d : (a : m) → α) (e : (a : l) → m) (he : Function.Injective e) (i : l) (j : l) :\n    (d (e j) = Matrix.diagonal (d ∘ e) j j) = (d (e j) = (d ∘ e) j) := by sorry", "doc_string": "Given a `(m × m)` diagonal matrix defined by a map `d : m → α`, if the reindexing map `e` is\ninjective, then the resulting matrix is again diagonal. ", "generated": ["theorem aux.962413562966943528 {l : Type u_1} {m : Type u_2} {α : Type v} [zero_or_equal α] [DecidableEq m]\n    [DecidableEq l] (d : (a : m) → α) (e : (a : l) → m) (he : Function.Injective e) {m : Type u_2} :\n    ∀ {α : Type v} [x : Zero α] {n : Type (u_1 + u_2)} [x_1 : DecidableEq n] (d : n → α) (_a : Unit → n → α),\n      Matrix.submatrix (Matrix.diagonal d) d EqvProd.diag prop :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.8131167489221736121 {l : Type u_1} {m : Type u_2} {α : Type v} [Zero α] [DecidableEq m] [DecidableEq l]\n    (d : (a : m) → α) (e : (a : l) → m) (he : Function.Injective e) (i : l) (j : l) (a : i = j) : d ∘ e iᶜ ⟨j, he _› = 0 /* of_eq_false */ 0'2 + d ∘ e iᶜ ++ fun (i : m) ↦ 0 :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.35918945647056 {l : Type u_1} {m : Type u_2} {α : Type v} [Zero α] [DecidableEq m] [DecidableEq l]\n    (d : (a : m) → α) (e : (a : l) → m) (he : Function.Injective e) (i : l) : e i ∘ e := funext\n``` [/INST] theorem Sub matrix.submatrix_diagonal :\n    ∀ {l : Type u_1} {m : Type u_2} {C : m → l → C aᵖ m} (i m_ne m : false for all (mᵒᵈ : m), False → false),\n      ⋃ x, id (matrix.upm a (i j)) • U ᵦ c (n (nᵗᵈ i) (f (j))) =\n          ⋃ m → id fun j => i' => Matrix.diagonal d :\n        ∀ λ x y j z m a, U a z = r (t y e (i n) b)\n            r i (eq.rec j y p) == e y' [fun u w => x a (j (* b)), nₛ f] j' fun w k h p => _ :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem forall_eq_or_imp_iff :\n    ∀ {α : Sort u_3} {p : α → Prop} {x : α} {a : α} {b₁ b₂ : Prop},\n      x = a ↔ a ∈ setOf a b₁ ∨ a ∈ setOf a b₂ ∮ (_ : a ∈ setOf a a) → p a :=\n  by sorry ", "theorem Function.Injective.ne_iff :\n    ∀ {α : Sort u_1} {β : Sort u_2} {f : α → β} (hf : Function.Injective f) {a₁ a₂ : α}, a₁ ≠ a₂ ↔ f a₁ ≠ f a₂ :=\n  by sorry "]}
{"theorem-type": "((fun (τ : ℂ) ↦ jacobiTheta τ - 1) =O[Filter.comap Complex.im Filter.atTop] fun (τ : ℂ) ↦\n  Real.exp (-Real.pi * Complex.im τ))", "theorem": "theorem isBigO_at_im_infty_jacobiTheta_sub_one :\n    ((fun (τ : ℂ) ↦ jacobiTheta τ - 1) =O[Filter.comap Complex.im Filter.atTop] fun (τ : ℂ) ↦\n      Real.exp (-Real.pi * Complex.im τ)) :=\n  by sorry", "name": "isBigO_at_im_infty_jacobiTheta_sub_one", "lemma-type": "(y : ℝ) →\n  (hy : y ≥ 1) →\n    (τ : ℂ) →\n      (hτ : Complex.im τ = y) →\n        2 / (1 - Real.exp (-Real.pi * Complex.im τ)) * Real.exp (-Real.pi * Complex.im τ) ≤\n          2 / (1 - Real.exp (-Real.pi)) * |Real.exp (-Real.pi * Complex.im τ)|", "lemma": "theorem aux.17840478936503634326 (y : ℝ) (hy : y ≥ 1) (τ : ℂ) (hτ : Complex.im τ = y) :\n    2 / (1 - Real.exp (-Real.pi * Complex.im τ)) * Real.exp (-Real.pi * Complex.im τ) ≤\n      2 / (1 - Real.exp (-Real.pi)) * |Real.exp (-Real.pi * Complex.im τ)| :=\n  by sorry", "doc_string": "The norm of `jacobiTheta τ - 1` decays exponentially as `im τ → ∞`. ", "generated": ["theorem Nat.mul_zero : ∀ (n : ℕ), n * 0 = 0 := by sorry ", "theorem aux.1360323806434340133 (a : ℝ) (tc : ℝ) (hf : ConvexOn ℝ (Function.support j) (jacobiTheta ·a ·b))\n    (he₂ : Real.exp (-Real.pi * a) ≤ 2 / Real.sqrt (2 * (1 - Real.exp (-π * b))))\n    (hi : Complex.abs (jacobiTheta ↑b) - 1 ∈ Filter.comap ((fun (a : ℂ) ↦\n            Complex.re a - 1) ∘ Complex.log (1 - Complex.exp a)) (Filter.cocompact ℂ)) :\n    Int.rawCast (Int.negOfNat 1) * Nat.rawCast 1 = Nothing := by sorry ", "theorem one_mul : ∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a := by sorry ", "theorem Real.exp_nat_ne_zero : ∀ {x : ℕ}, x ≠ 0 → Real.exp ↑x ≠ 0 := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.585529557968499283 (τ : ℂ) : Complex.im 0 < 0 := by sorry ", "theorem aux.8103823746847315159 (τ : ℂ) : -1 = ↑4 * (↑3 ^ Nat.rawCast 1 * Nat.rawCast 1) * Nat.zero := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry "]}
{"theorem-type": "(∀ {ι : Type u} (s : Finset ι) (f : (a : ι) → ℝ) {p : ℝ} (hp : 1 ≤ p),\n  (Finset.sum s fun (i : ι) ↦ |f i|) ^ p ≤ ↑s.card ^ (p - 1) * Finset.sum s fun (i : ι) ↦ |f i| ^ p)", "theorem": "theorem Real.rpow_sum_le_const_mul_sum_rpow :\n    (∀ {ι : Type u} (s : Finset ι) (f : (a : ι) → ℝ) {p : ℝ} (hp : 1 ≤ p),\n      (Finset.sum s fun (i : ι) ↦ |f i|) ^ p ≤ ↑s.card ^ (p - 1) * Finset.sum s fun (i : ι) ↦ |f i| ^ p) :=\n  by sorry", "name": "Real.rpow_sum_le_const_mul_sum_rpow", "lemma-type": "{ι : Type u} →\n  (s : Finset ι) →\n    (f : (a : ι) → ℝ) →\n      {p : ℝ} →\n        (hp : 1 ≤ p) →\n          ∀ (x : ι) (a : x ∈ s),\n            { val := ((|f x|)), property := (((abs_nonneg (f x)))) } =\n              { val := ((|f x|)), property := (((abs_nonneg (f x)))) }", "lemma": "theorem aux.14045667898528594628 {ι : Type u} (s : Finset ι) (f : (a : ι) → ℝ) {p : ℝ} (hp : 1 ≤ p) :\n    ∀ (x : ι) (a : x ∈ s),\n      { val := ((|f x|)), property := (((abs_nonneg (f x)))) } =\n        { val := ((|f x|)), property := (((abs_nonneg (f x)))) } :=\n  by sorry", "doc_string": "For `1 ≤ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with `ℝ`-valued functions. ", "generated": ["equation :\n  Finset.sum s fun (x : Ω) ↦ Real.rpow ⟪f, µ⟫¹ |Finset.filter (fun (x : Ω) ↦ 0 x ≠ Finset.sum s i) {x, f}).card :=\n    Finset.sum s fun (a : 𝕜) ↦ ↑↑(Finset.powersetCard a n).card * (↑⟪f, µ⟫² ^ a - ↑𝓕fFin ↑(Finsupp.rmul a (f i)).card) / card ∅ :=\n  by sorry ", "theorem aux.506366912066156828 {ι : Type u} (s : Finset ι) (f : (a : ι) → ℝ[]) {p : ℝ} (hp : 1 ≤ p) (g : (a : ι) → ℝ)\n    (h : (∀ [Fintype ι], Set.InjOn g ↑(Finset.univ)) ∧ (∀ ι, (Finset.sum Finset.univ fun (i : ι) ↦ |g i| ^ p) ^ (1 / p) ≤ |ℝ≤|g ‹i⟩| ^ p)) :\n    (∀ [inst : Fintype ι], Set.InjOn g ↑(Finset.univ)) = ((Fintype.card ι ≤ nat_lit 0) ∨ (Set.InjOn g ↑(Finset.univ))) :=\n  by sorry ", "theorem le_trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c := by sorry ", "theorem LE.le.trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c := by sorry ", "theorem Finset.sup_card_pos :\n    ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] ⦃s : Finset α⦄, ∃ a ∈ s, ↑s.card ≥ a ^ p := by sorry ", "theorem map_cast :\n    ∀ {H : Type u -> ToExpr u} {S H'}, {x : ToExpr u} → H' = ToExpr := by sorry ", "theorem Finset.Nat.card_add :\n    ∀ (t₁ t₂ : Finset ℕ) {p : ℕ}, ↑(p - Nat.pred p + 1) + ↑(t₁.card * t₂.card) =\n      ↑2 * ↑(min (n / p) (n.pred * n.pred) > n)).proofs.case_0\n``` [/INST] theorem aux.8229768704571975623 (n : ℕ)\n    (hp1 : p + 1 = Nat.succ (+natImpartial.as_int p)) (a : Nat.Zerod 0) : Fact (p < n.pred 2.natsu) := by sorry ", "theorem aux.6430139851218858501 {ι : Type u} (s : Finset ι) (f : (a : ι) → ℝ) {p : ℝ} (hp : 1 ≤ p) :\n    1 - ↑s.card + (Finset.filter (fun (x : ι) ↦ ¬(Real.rpow (|f x|) p = 0)) s).card =\n      ↑s.card + ↑(Finset.filter (fun (x : ι) ↦ ¬(Real.rpow (|f x|) p = 0)) s).card -\n        (↑s.card + Finset.sum (Finset.filter (fun (x : ι) ↦ f x < 0) s) ↑|Real.rpow (f x) p) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b)))", "theorem": "theorem not_covBy_iff :\n    (∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), (¬(a ⋖ b)) ↔ (∃ c, (a < c) ∧ (c < b))) := by sorry", "name": "not_covBy_iff", "lemma-type": "{α : Type u_1} →\n  [LT α] →\n    {a : α} → {b : α} → (h : a < b) → (True ∧ (∀ ⦃c : α⦄ (a : a < c), ¬(c < b))) = (∀ ⦃c : α⦄ (a : a < c), ¬(c < b))", "lemma": "theorem aux.3491956655063456274 {α : Type u_1} [LT α] {a : α} {b : α} (h : a < b) :\n    (True ∧ (∀ ⦃c : α⦄ (a : a < c), ¬(c < b))) = (∀ ⦃c : α⦄ (a : a < c), ¬(c < b)) := by sorry", "doc_string": "If `a < b`, then `b` does not cover `a` iff there's an element in between. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.6301817514391634740 {α : Type u_1} [LT α] {a : α} {b : α} (h : a < b) : ¬(∃ v, (¬(a < v)) ∧ (¬(v < b))) :=\n  by sorry ", "mathlib_metadata.collapsed : sorрий\na : mathruby\n\nSee also Lean 4 documentation for Lean  (metaSub) {\"typeName\" => Mathruby.Type.lt, \"argInfo\" [(\"instParam this_2553\"\n  : (NormNum.IsLT 1 <| LT.lt_trans Mathruby.CFunInst.t16 <| Mathruby.CFunInst.T1 <| LT.lt_trans_lt_left the3083 )])}, the325701, none} } =>\n  true", "theorem covBy_refl : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a ⋰ b ↔ a = b := by sorry ", "code:\n```lean\ntheorem not_covBy_iff :\n    ∀ {α : Type u_1} [inst : LT α] {a : α} {b : α} (h : a < b), ¬(a ⋖ b) ↔ ∃ c, (a < c) ∧ (c < b) := by sorry\n``` [/INST] theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [\"inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem not_trans : ∀{α : Sort u_1} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → ¬r a c := by\n  sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] {ι : Type u_2} [inst_2 : Fintype ι]\n  [inst_3 : DecidableEq ι] [ne : Nonempty ι] (e : OrthonormalBasis ι ℝ E) (x : Orientation ℝ E ι),\n  Orthonormal ℝ ⇑(Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x))", "theorem": "theorem OrthonormalBasis.orthonormal_adjustToOrientation :\n    (∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] {ι : Type u_2} [inst_2 : Fintype ι]\n      [inst_3 : DecidableEq ι] [ne : Nonempty ι] (e : OrthonormalBasis ι ℝ E) (x : Orientation ℝ E ι),\n      Orthonormal ℝ ⇑(Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x)) :=\n  by sorry", "name": "OrthonormalBasis.orthonormal_adjustToOrientation", "lemma-type": "{E : Type u_1} →\n  [NormedAddCommGroup E] →\n    [InnerProductSpace ℝ E] →\n      {ι : Type u_2} →\n        [Fintype ι] →\n          [DecidableEq ι] →\n            [Nonempty ι] →\n              (e : OrthonormalBasis ι ℝ E) →\n                (x : Orientation ℝ E ι) →\n                  (i : ι) →\n                    Or ((Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x) i = (OrthonormalBasis.toBasis e) i) =\n                      Or ((Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x) i = e i)", "lemma": "theorem aux.10585660435754096932 {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {ι : Type u_2}\n    [Fintype ι] [DecidableEq ι] [Nonempty ι] (e : OrthonormalBasis ι ℝ E) (x : Orientation ℝ E ι) (i : ι) :\n    Or ((Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x) i = (OrthonormalBasis.toBasis e) i) =\n      Or ((Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x) i = e i) :=\n  by sorry", "doc_string": "`OrthonormalBasis.adjustToOrientation`, applied to an orthonormal basis, preserves the\nproperty of orthonormality. ", "generated": ["theorem le_refl : ∀ {α : Type u} [inst : Preorder α] (a : α), a ≤ a := by sorry ", "theorem aux.8500893919824709661 {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {ι : Type u_2}\n    [Fintype ι] [DecidableEq ι] [Nonempty ι] (e : OrthonormalBasis ι ℝ E) (x : Orientation ℝ E ι) (i : ι)\n    (j : ι) (hij : i ≠ j) (hw : Bool.decide_ false true) :\n    Basis.adjustToOrientation (Basis.map (Basis.toMatrix (OrthonormalBasis.toBasis e))) x j₁ j₁ ⇑e = None := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem or_false : ∀ (p : Prop), (p ∨ False) = p := by sorry ", "theorem congrArg : ∀ {α Univ u Brian2282848 uu n} ⦎ {f g : α → Univ} {z zoo n₁ : (a : α) → z₀},\n      f zoo = g a → f u ≈ g₂ u₁ → (z zoooooi : z ξ n₁) = (z zoofdsoo : z z₂ h₃ i) :=\n  by sorry ", "theorem forall_congr : ∀ {α : Sort u} {p q : α → Prop}, (∀ (a : α), p a = q a) → (∀ (a : α), p a) = ∀ (a : α), q a := by\n  sorry ", "theorem Basis.equiv_of_real_ortOG :\n    ∀ (n : Type) (E : Type uEq) [inst : Fact (FiniteDimensional ℝ E)] [inst_1 : NormedAddCommGroup E]\n      [inst_2 : InnerProductSpace ℝ E] withOpcEquiv _ _ :=\n  by sorry ", "theorem mem_univ : ∀ {α : Sort u} (i : α), i ∈ Set.univ := by sorry "]}
{"theorem-type": "(Filter.Tendsto (fun (x : ℝ) ↦ x ^ (-1 / x)) Filter.atTop (nhds 1))", "theorem": "theorem tendsto_rpow_neg_div : (Filter.Tendsto (fun (x : ℝ) ↦ x ^ (-1 / x)) Filter.atTop (nhds 1)) := by sorry", "name": "tendsto_rpow_neg_div", "lemma-type": "(α : Type) →\n  (β : Type) →\n    (f : (a : α) → β) →\n      (f' : (a : α) → β) →\n        (e'_3 : f = f') →\n          (l₁ : Filter α) →\n            (l₂ : Filter β) →\n              (h : f' = f) →\n                ∀ (e_3 : f = f) (h : HEq e_3 (Eq.refl f)), HEq (Filter.Tendsto f l₁ l₂) (Filter.Tendsto f l₁ l₂)", "lemma": "theorem aux.1895561547889697498 (α : Type) (β : Type) (f : (a : α) → β) (f' : (a : α) → β) (e'_3 : f = f')\n    (l₁ : Filter α) (l₂ : Filter β) (h : f' = f) :\n    ∀ (e_3 : f = f) (h : HEq e_3 (Eq.refl f)), HEq (Filter.Tendsto f l₁ l₂) (Filter.Tendsto f l₁ l₂) := by sorry", "doc_string": "The function `x ^ (-1 / x)` tends to `1` at `+∞`. ", "generated": ["theorem add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry ", "theorem aux.6310576550749234599 (b₂ : NNReal) (r : ℝ) : ↑(b₂ ^ (r * ↑real_zero)) * -r = -r * ↑b₂ ^ ↑real_zero := by sorry ", "theorem eq_self : ∀ {α : Sort u_1} (a : α), (a = a) = True := by sorry ", "theorem Real.rpow_neg : ∀ (x : ℝ), x ^ (-1 / x) = (x ^ 1 / x) ^ -1 := by sorry ", "theorem eq_mul_self_iff' :\n    ∀ {α : Type u} [inst : NonUnitalNonAssocSemiring α] (a : α), a = b * bᵟ + mul_assoc 0 j = b * bᵟ + mul_assoc a j :=\n  by sorry ", "theorem aux.5345301183629711808 : (fun (x : ℚ) ↦ ↑x⁻¹ * ↑(1/↑⊥))⁻¹ =ᶠ[Filter.atTop] 1 / Complex.Io := by\n  sorry ", "theorem lt_or_le_of_lt : ∀ {ι : ℕ} {I J : ι → Prop} [hI₁ : Finite {x | I x}], (Finset.filter I hI₁).Card ≤ J =>\n    (∀ (x : ι) (y : x ∉ Finset.filter I hI₁), x ∈ ↑{x_1 : ι | j₁ x_1 = True} Λ x_1��ре J ∧ True → x ≠ True) →\n      ITrue x ↔ ¬∃ j₃ y, j₃ ∈ Finset.smul (Fintype.card hI₁) (I x) {j := None, y := False} :=\n  by sorry ", "theorem tendsto_const_nhds :\n    ∀ {X : Type u} {α : Type u_1} [inst : TopologicalSpace X] (x : X) (f : Filter α),\n      Filter.Tendsto (fun x_1 => x) f = f ×> id :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n  [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n  {s : Set α} (hs : MeasurableSet s),\n  ∀ᵐ (x : α) ∂μ,\n    Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x) (nhds (Set.indicator s 1 x)))", "theorem": "theorem VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet :\n    (∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n      [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n      {s : Set α} (hs : MeasurableSet s),\n      ∀ᵐ (x : α) ∂μ,\n        Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x)\n          (nhds (Set.indicator s 1 x))) :=\n  by sorry", "name": "VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet", "lemma-type": "∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : Set α},\n  MeasurableSet s → ↑↑(MeasureTheory.Measure.restrict μ s) t = ↑↑μ (t ∩ s)", "lemma": "theorem MeasureTheory.Measure.restrict_apply' :\n    ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : Set α},\n      MeasurableSet s → ↑↑(MeasureTheory.Measure.restrict μ s) t = ↑↑μ (t ∩ s) :=\n  by sorry", "doc_string": "Given a measurable set `s`, then `μ (s ∩ a) / μ a` converges when `a` shrinks to a typical\npoint `x` along a Vitali family. The limit is `1` for `x ∈ s` and `0` for `x ∉ s`. This shows that\nalmost every point of `s` is a Lebesgue density point for `s`. A version for non-measurable sets\nholds, but it only gives the first conclusion, see `ae_tendsto_measure_inter_div`. ", "generated": ["theorem Filter.tendsto_iff :\n    ∀ {α : Type u} {β : Type v} {f : α → Σ f' f} {u : Set α} {l₁ : Filter β} {g₃ : β → α} {g₁ : (a : β) → f f'}\n      {g₂ u f' : u → f y f'}, (Filter.Tendsto g₁ l₁ u) = (Filter.Tendsto g₂ l₁ u ∨ (Filter.Tendsto f y g₂ u g₃)) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem VitaliFamily.mem_sets_ae_tendsto_measure_inter_le' :\n    ∀ {α : Type u_1} {m0 : MeasurableSpace α} [emphasized («= instantCopy») _inst_39 : IsBorelSpace α]\n      (v : VitaliFamily α) {s : Set α} {μ : MeasureTheory.Measure α}, MeasureTheory.IsLocallyFiniteMeasure μ s → s ∈ v.sets :=\n  by sorry ", "theorem Metric.tendsto_nhds_norm_one' :\n    ∀ {E : Type u_6} [inst : SeminormedGroup E] {a b : ℝ},\n      a < b →\n        ∀ {f : ℝ → E},\n          TendtoAux (Filter.Map toNNReal {u : E | a ≤ ↑u}) (filterAtTop One (r = max a b)) fun x (hy : IsROrc x) u =>\n            ↑‖u • f f‖ < x↔ f _=a•↑‖a•‖ = (_ : ℝ) • 1 ↔ fun t : NRLift.ToReal E => ((norr f t) + a ^ t ∈ a ::= u).val • 0 :=\n  by sorry ", "theorem aux.10919000644132291202 {α : Type u_1} [MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n    (v : VitaliFamily μ) [SecondCountableTopology α] [BorelSpace α] [MeasureTheory.IsLocallyFiniteMeasure μ]\n    {s : Set α} (hs : MeasurableSet s) : VitaliFamily.isLittleO (v ×ˢ Filter.pr (VitaliFamily.Filter ↑μ))\n      fun (r_cinfo : BoxAdditiveMap.Split.Index ↑νa) ↦\n      ↑↑μ (s ∩\n            ↑rvᵝ.toBoxAdditiveMap r_cinfo.lower) ∂r_cinfo.measure (VitaliFamily.toBasicOpen r.lower) ×ˢ\n        Filter.pr <| fun (_i : VitaliFamily.Index rᵜv) ↦\n          Ioo (v (rᵾ t), MeasureTheory.Filter.IsMeasurablyBoundedWith μ)ᵀ ×ˢ IsOpenMap.map r ⬝ ⦃l | rᵱ.le l, r ≤ L) |ᵈ (Box Additive (BoxIntegral.RiemannBox l)),\n          Xᵢ r⁻¹ - (id X _ | rᵻ) ≥ 2) :=\n  by sorry ", "theorem Set.univ_inter ;\n```lean\n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem:\n```lean\ntheorem VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet :\n    (∀ {α : Type u_1} [inst : MetricSpace α] {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} (v : VitaliFamily μ)\n      [inst_1 : SecondCountableTopology α] [inst_2 : BorelSpace α] [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ]\n      {s : Set α} (hs : MeasurableSet s),\n      ∀ᵐ (x : α) ∂μ,\n        Filter.Tendsto (fun (a : Set α) ↦ ↑↑μ (s ∩ a) / ↑↑μ a) (VitaliFamily.filterAt v x)\n          (nhds (Set.indicator s 1 x))) :=\n  by sorry\n``` [/INST] theorem MeasurableSet.Ioo_union_Icc : ∀ {α}, MF » sᶜ → MeasurableSet (α ⊂ id 0) → Measurable ↑((Isolated.u ∘ s)(0)) → ↑↑μ ((a, aᗮ), |a - a₁⏹ < a₂) = ↑↑μ ((-∞ : α), a₁) + Finset.sum' (Segmentation, id < _) ↑(((a : UnitIntersect α) «. |a₂| - a 0 = _) · fun _x : γ => if c else ↑1) := by sorry "]}
{"theorem-type": "(∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {u : E} {v : E}, (v ∈ (Submodule.span 𝕜 {u})ᗮ) ↔ (⟪u, v⟫_𝕜 = 0))", "theorem": "theorem Submodule.mem_orthogonal_singleton_iff_inner_right :\n    (∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      {u : E} {v : E}, (v ∈ (Submodule.span 𝕜 {u})ᗮ) ↔ (⟪u, v⟫_𝕜 = 0)) :=\n  by sorry", "name": "Submodule.mem_orthogonal_singleton_iff_inner_right", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "A vector is in `(𝕜 ∙ u)ᗮ` iff it is orthogonal to `u`. ", "generated": ["theorem aux.15101762479898151362 {𝕜 : Type u_1} {E : Type u_2} [IsROrC 𝕜] [NormedAddCommGroup E] [InnerProductSpace 𝕜 E]\n    {u : E} {v : E} : submodule.orthogonal' 𝕜 vᗮᗮ (submodule.span v) = submodule.orthogonalspan v v := by sorry ", "theorem mul_self_nonneg :\n    ∀ {R : Type u_1} [inst : OrderedSemiring R] [inst_1 : ExistsAddOfLE R] (a : R), 0 ≤ a * a := by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u_1} {q₁ q₂ : Sort u_2} (h₁ : p₁ = p₂) (h₂ : q₁ = q₂), (p₁ h₁ → q₁ h₂) = (p₂ h₂ → q₂ h₂) := by sorry ", "theorem inner_smul_inner_self_left :\n    ∀ {𝕜 : Type u_1} {E : Type u_2 } [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      (x y : E) (k : 𝕜), ⟪x, k • y⟫_𝕜 = k * (⟪x, y⟫_𝕜) (k : 𝕜) :=\n  by sorry ", "theorem inner_mul_left_self_inner_add_inner_self_mem_left :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst :IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      {A : E →L[𝕜] E →L[𝕜] 𝕜},\n      NormedLawOfSelfMul F 𝕜 𝕜 →\n        ∀ (C : Types.instInnerProductSpaceFm 𝕜 𝕜 → ∅ $ a = A),\n              ∀ {e x y : F} ,\n                  ∃ u v w ∈ 1, { val := fun t => u, property ↔ i := Nat.id s } = { val := ({ val := fun i => edid.1,\n                               property := fun i => edid.0 t, rval edid.c}) } { val := val } =\n                          H (s : { val := fun m => m ) f ≤\n                              fun g / (v, true / r / val = u) (H : δ →\n                                    ζ u)\n                                        (x : z) → ε → f | ((z val := r) × y, y g) = True) := by\n                  sorry ", "theorem LT.lt : ↦ fun _ _ => False := by sorry ", "theorem IsROrC.of_real_eq_real : ∀ (𝕜 : Type u_1) [inst : IsROrC 𝕜] (x : ℝ), ↑x = x := by sorry ", "theorem neg_pos :\n    ∀ {α : Type u_1} [inst : Lt α] [inst_1 : HasNeg α] {a : α}, 0 < -a ↔ a < 0 := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : (a : α) → (a : β) → γ} {u : Finset γ}\n  {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t), ∃ s' t', (↑s' ⊆ s) ∧ ((↑t' ⊆ t) ∧ (u ⊆ Finset.image₂ f s' t')))", "theorem": "theorem Finset.subset_image₂ :\n    (∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} [inst : DecidableEq γ] {f : (a : α) → (a : β) → γ} {u : Finset γ}\n      {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t),\n      ∃ s' t', (↑s' ⊆ s) ∧ ((↑t' ⊆ t) ∧ (u ⊆ Finset.image₂ f s' t'))) :=\n  by sorry", "name": "Finset.subset_image₂", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If a `Finset` is a subset of the image of two `Set`s under a binary operation,\nthen it is a subset of the `Finset.image₂` of two `Finset` subsets of these `Set`s. ", "generated": ["theorem aux.2538348277864276915 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ] {f : (a : α) → (a : β) → γ}\n    {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t) (c : Set α × Set β)\n    (hp : Finset.Image2 f c = ∅) (w : { val := ((↑c).2), intersect := ((∅)), left := ((a).1)), right := ((a).2) })\n    (z : { val := ((↑c).1), intersect := ((True)), left := ((a).3)), right := ((a).4})} : (True False) = False := by\n  sorry ", "theorem aux.4869534956179985929 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} {s : Set α} (ht : t.Nonempty)\n    (hst : ∀ (_x : β) (_a : _x ∈ t), _x ∈ Set.range2 f s ∩ u) :\n    ((∅ ⊆ ⟨s, Set.finite_image_of_mem' f t (Finset.image_nonempty t ht) hst⟩⁻¹) ∧ ⋂ i ∈ Finset.univ, u_set = ⋂ i ∈ ↑f '' t) :=\n  by sorry ", "theorem aux.9930207462820359827 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t)\n    (s' : Finset α) (t' : Finset β)\n    (hs :\n        ↑s' ⊆\n          {x : α |⦃x_1 : β⦄ (a : x_1 ∈ t), f x x_1 ∈ f x x_1 ∪ ⋃ a ∈ t', f x a}ᶜ)\n    (ht :\n      ↑s ≈ {x : α |⦃x_1 : β⦄ (a : x_1 ∈ t), ¬(f x x_1 ∈ f x x_1 ∪ ⋃ a ∈ t', f x a⧸ f x a)}[1]) (s : Set α)\n    (hs : s = {x : α |⦃x_1 : β⦄ (a : x_1 ∈ t), f x x_1 ∈ f x x_1 ∪ ⋃ a : β ∈ t', f x a⧸ f x a}) : And a ∉ t' :=\n  of_eq_true (_aux.3865825007607195533 {x : ρ¹ ^ ((fun (x : 𝔸ₑ) (a : 𝔸ₕ) ↦ x + x) α β ⦃a : Fin X⥀ x), + 1 a a := eq_self)\n    _aux.10322243681642497569 (hne : a < Cardinal.aleph0) (ht : Cardinals.nat_ cast a = s : 𝕜), a < s := by sorry ", "theorem Iff.inl : ∀ {a b : Prop}, (a ↔ b) = a := by sorry ", "theorem congr_fun : ∀ {α : Sort u} {β : α → Sort v} {x y : α}, x = y → ∀ (f : α → β), f x = f y := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem aux.649717875202628621 {α : Type u_1} {β : Type u_3} {γ : Type u_5} [DecidableEq γ]\n    {f : (a : α) → (a : β) → γ} {u : Finset γ} {s : Set α} {t : Set β} (hu : ↑u ⊆ Set.image2 f s t)\n    (hs : Set.Finite s) (ht : { x : (a : γ) → α } ∘ f)^{-1}t = {x : (a : γ) → α | f x ∈ t} := by sorry ", "theorem Finset.coe_image₂ :\n    ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} (f : α → β → γ) (s : Finset α) (t : Finset β),\n      ↑(Finset.image₂ f s t) = Finset.image (fun a => f a default) s :=\n  by sorry "]}
{"theorem-type": "(Filter.Tendsto (fun (x : ℝ) ↦ x ^ (-1 / x)) Filter.atTop (nhds 1))", "theorem": "theorem tendsto_rpow_neg_div : (Filter.Tendsto (fun (x : ℝ) ↦ x ^ (-1 / x)) Filter.atTop (nhds 1)) := by sorry", "name": "tendsto_rpow_neg_div", "lemma-type": "(x : ℝ) → x = 1 * x + 0", "lemma": "theorem aux.5175514065034909334 (x : ℝ) : x = 1 * x + 0 := by sorry", "doc_string": "The function `x ^ (-1 / x)` tends to `1` at `+∞`. ", "generated": ["theorem mul_neg_one : ∀ {α : Type u} [inst : InvOneClass α] (a : α), a * -1 = -a := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem not_isContrMetric_nhds : ∀ {α : Type u} [inst : PseudoEMetricSpace α], IsEMetric (α) ↦ False := by sorry ", "_au_1 :\n    ∀ (δ : ℝ) (a : 0 < δ), Filter.Tendsto (fun (x : ℝ) ↦ δ) Filter.atTop (nhds 0) := by sorry ", "theorem neg_le_neg : ∀ {α : Type u_1} [inst : OrderedAddCommGroup α] {a b : α}, a < b ↔ -a > -b := by sorry ", "theorem tendsto_one_covby_zero :\n    ∀ {α : Type u_3} [inst : ConditionallyCompleteLinearOrderBot α] [inst_1 : TopologicalSpace α]\n      [inst_2 : OrderTopology α], Filter.Tendsto (fun x => 1 - x + 1^0) Filter.atTop (nhds 0) :=\n  by sorry ", "theorem tendsto_exp_iff :\n    ∀ {𓕜 : Type u} {F : Type v} [inst : NormedField 𓕜] [inst_1 : IsROrC 𓕜]\n      [inst_2 : NontriviallyNormedField F] [inst_3 : NormedAlgebra 𓕜 F] [inst_4 : CompleteSpace F] {x : F},\n      Tendsto (fun i => x * Real.exp (i * ||x| * ℝ)) Filter.atTop\n    (𝓝 (||x|| ^ (2 * real.toRat 1) if Real.toRat 1 ≤ ||x|| * 4⁻ᵏ) ∨ Tendsto ξ Filter.atTop (nhds 0)) ↔\n      Filter.Tendsto (λ n, x * Real.exp (i * |x|⁻¹ * ℝ)) Filter.atBot\n        (𝓝 (|x| * |x|⁻¹ ^ real.toRat 1)) :=\n  by sorry ", "theorem filter_mono : ∀ {α : Type u} {f g : Filter α}, f ≤ g → f ≤ f.comap g := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} {K : Type u_2} [inst : Semiring R] [inst_1 : CommSemiring K] {b : R} {bi : K} (i : R →+* K)\n  (f : Polynomial R) (a : R) (bu : bi * i b = 1), DenomsClearable a b (Polynomial.natDegree f) f i)", "theorem": "theorem denomsClearable_natDegree :\n    (∀ {R : Type u_1} {K : Type u_2} [inst : Semiring R] [inst_1 : CommSemiring K] {b : R} {bi : K} (i : R →+* K)\n      (f : Polynomial R) (a : R) (bu : bi * i b = 1), DenomsClearable a b (Polynomial.natDegree f) f i) :=\n  by sorry", "name": "denomsClearable_natDegree", "lemma-type": "∀ {R : Type u_1} {K : Type u_2} [inst : Semiring R] [inst_1 : CommSemiring K] {i : R →+* K} {b : R} {bi : K} (N : ℕ)\n  (a : R), bi * i b = 1 → ∀ (f : Polynomial R), Polynomial.natDegree f ≤ N → DenomsClearable a b N f i", "lemma": "theorem denomsClearable_of_natDegree_le :\n    ∀ {R : Type u_1} {K : Type u_2} [inst : Semiring R] [inst_1 : CommSemiring K] {i : R →+* K} {b : R} {bi : K} (N : ℕ)\n      (a : R), bi * i b = 1 → ∀ (f : Polynomial R), Polynomial.natDegree f ≤ N → DenomsClearable a b N f i :=\n  by sorry", "doc_string": "If `i : R → K` is a ring homomorphism, `f` is a polynomial with coefficients in `R`,\n`a, b` are elements of `R`, with `i b` invertible, then there is a `D ∈ R` such that\n`b ^ f.natDegree * f (a / b)` equals `i D`. ", "generated": ["theorem IsClearableZeroHom.ninj :\n    ∀ {R : Type u_5} {K : Type u_6} (i : R →+* K) [inst : Nontrivial R] for {b : R}, ¬Nat.Prime 2 →\n      Polynomial.natDegree (p := (IsClearableZeroHom.ninjb i b)) = FiniteDimensional.finrank R ℕ :=\n  by sorry ", "theorem aux.7883679547341828975 {R : Type u_1} {K : Type u_2} [Semiring R] [CommSemiring K] {b : R} {bi : K}\n    (i : R →+* K) (f : Polynomial R) (a : R) (bu : bi * i b = 1) (q : R →+* K) (IH : Polynomial.coeff a q * (↑q b)⊥ ≠ 0)\n    (bi' : K) (hinv : b' = (bi * i b)⁻¹)\n    (q_1 : R →+* nonUnitalHomWithBIHPretrient R K) (i'_1 : R →| noncommRingFunctToMulAction R K)\n    (hq' : ↑i' = quotEquivEnd q_1)\n    (ihq' :\n      Polynomial.coeff a q * ↑(NonUnitalRingHom.comp (NonUnitalRingHom.comp (PolynomialIsUnit.toSplitRingNoncomm φ φ))\n  (NonUltRingConGen φ)) b ≠ 0)) :\n  ∀ [inst : ConForm φ φ], ((fun (w : R →+* K) ↦ Nat.LZ w bi h)((LinearMemClass PUnit.PMinSphereConForm φ) * b) =\n      1) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem minpoly.nonzero_apply :\n    ∀ {A : Type u}, { x : A // IsSciA (Subring.toAlgebraClosedOfNonZeroClosureMulEquipWith.toPartEth : Subtype x) } →\n      ↑(minpoly A ⋆) x ≠ 0 :=\n  by sorry ", "theorem tsub_le_iff_left :\n    ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : AddCommMonoid α] [inst_2 : Sub α] [inst_3 : OrderedSub α]\n      (a b : α), a < b → a ≤ b - b :=\n  by sorry ", "theorem aux.7979478901480782505 {R : Type u_1} {K : Type u_2} [Semiring R] [CommSemiring K] {b : R} {bi : K}\n    (i : R →+* K) (f : Polynomial R) (a : R) (bu : bi * i b = 1) : (1 = 1) = True := by sorry ", "theorem And.right : ∀ {a b : Prop}, a ∧ b → b := by sorry ", "theorem aux.6172397540949965734 {R : Type u_1} [Semiring R] {K : Type u_2} [CommSemiring K] {b : R} {bi : K}\n    (i : R →+* K) (f : Polynomial R) (a : R) (bu : bi * i b ≠ b) (pf : DenomsClearable a b (Polynomial.natDegree a) a i)\n    (dfa : Polynomial.natDegree a = Finsupp.sum bi (Finset.smul (Finset.erase findeg' Finset.univ a ⊇ {a}).val 2))\n    (if : Finsupp.sum bi (Finset.image (⇑(Function.uncurry Finset.univ))) 2 ≤ q.toFdAdd MonoidHomId.toR ↑dg0 b)\n    (* Not enough hypotheses ? Or is Finsupp.sum bi (Finset.erase findeg' Finset.univ a ┅ {Degree.def dg0}.head)⅟ c c₀ ∈ Hc ?* (Finset.filter ((D := fun (a_3 : Polynomial R) ↦ a / ↑(b * bi • ↑D e)).injOn_Dvd' degEqH hyp) {D := fun (y : (a : ↑(Degree.head Deg.card)) → R) ↦ Poly.C o e * x * D °}a if = d := by sorry) (Hc : a / b • ai H c₀ d ∈ Hd) :\n    ῃ H 2 (Polynomials.infiniteSet (Set.range (b • bi + 2 * 1), Polynomials.coeff H)).2 f (rfl (BiInter b bi · bi * i b)) := by sorry "]}
{"theorem-type": "(∀ {a : ℝ} {l : Filter ℝ} {f : (a : ℝ) → ℝ} {g : (a : ℝ) → ℝ}\n  (hdf : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), DifferentiableAt ℝ f x)\n  (hg' : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), deriv g x ≠ 0)\n  (hfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0))\n  (hga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0))\n  (hdiv : Filter.Tendsto (fun (x : ℝ) ↦ deriv f x / deriv g x) (nhdsWithin a (Set.Iio a)) l),\n  Filter.Tendsto (fun (x : ℝ) ↦ f x / g x) (nhdsWithin a (Set.Iio a)) l)", "theorem": "theorem deriv.lhopital_zero_nhds_left :\n    (∀ {a : ℝ} {l : Filter ℝ} {f : (a : ℝ) → ℝ} {g : (a : ℝ) → ℝ}\n      (hdf : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), DifferentiableAt ℝ f x)\n      (hg' : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), deriv g x ≠ 0)\n      (hfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0))\n      (hga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0))\n      (hdiv : Filter.Tendsto (fun (x : ℝ) ↦ deriv f x / deriv g x) (nhdsWithin a (Set.Iio a)) l),\n      Filter.Tendsto (fun (x : ℝ) ↦ f x / g x) (nhdsWithin a (Set.Iio a)) l) :=\n  by sorry", "name": "deriv.lhopital_zero_nhds_left", "lemma-type": "∀ {α : Type u} {p q : α → Prop} {f : Filter α},\n  (∀ᶠ (x : α) in f, p x) → (∀ᶠ (x : α) in f, p x → q x) → ∀ᶠ (x : α) in f, q x", "lemma": "theorem Filter.Eventually.mp :\n    ∀ {α : Type u} {p q : α → Prop} {f : Filter α},\n      (∀ᶠ (x : α) in f, p x) → (∀ᶠ (x : α) in f, p x → q x) → ∀ᶠ (x : α) in f, q x :=\n  by sorry", "doc_string": "**L'Hôpital's rule** for approaching a real from the left, `deriv` version ", "generated": ["theorem Filter.eventfully_self :\n    ∀ {α : Type u} {p : α → Prop} {f : Filter α},\n      (∀ᶠ (x : α) in f, p x) ↔ ∃ᶠ (xi : α) in f, p xi ∧ ∃ y, ¬a = ξ x :=\n  by sorry ", "theorem aux.15327499088990635748 {a : ℝ} {l : Filter ℝ} {f : (a : ℝ) → ℝ} {g : (a : ℝ) → ℝ}\n    (hdf : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), deriv g x ≠ 0)\n    (hfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0))\n    (hga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0))\n    (hdiv : Filter.Tendsto (fun (x : ℝ) ↦ deriv f x / deriv g x) (nhdsWithin a (Set.Iio a)) l) :\n    ((deriv g) a ≠ 0) = (deriv (g - 1 • deriv g) a ≠ 0) := by sorry ", "theorem aux.6560557690844334369 {a : ℝ} {l : Filter ℝ} {f : (a : ℝ) → ℝ} {g : (a : ℝ) → ℝ}\n    (hdf : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), deriv g x ≠ 0)\n    (hfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0))\n    (hga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0))\n    (hdiv : Filter.Tendsto (fun (x : ℝ) ↦ deriv f x / deriv g x) (nhdsWithin a (Set.Iio a)) l) :\n    ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), DifferentiableAt ℝ g x := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem norm_eq_zero : ∀ {E : Type u_6} [inst : NormedAddGroup E] {a : E}, ‖a‖ = 0 ↔ a = 0 := by sorry ", "answer:\n4105578254962216470 (∀ {a : ℝ} {l : Filter ℝ} {f : (a : ℝ) → ℝ} {g : (a : ℝ) → ℝ}\n    (hdf : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), DifferentiableAt ℝ f x)\n    (hg' : ∀ᶠ (x : ℝ) in nhdsWithin a (Set.Iio a), deriv g x ≠ 0)\n    (hfa : Filter.Tendsto f (nhdsWithin a (Set.Iio a)) (nhds 0))\n    (hga : Filter.Tendsto g (nhdsWithin a (Set.Iio a)) (nhds 0))\n    (hdiv : Filter.Tendsto (fun (x : ℝ) ↦ deriv f x / deriv g x) (nhdsWithin a (Set.Iio a)) l) :\n    (Filter.Tendsto (fun (x : ℝ) ↦ 1 * g x * deriv f x / 1 * (deriv g x)) (nhdsWithin a (Set.Iio a)) l)) =\n      (Filter.Tendsto (deriv f / deriv g) (comap deriv (nhdsWithin a (Set.Iio a))) l ::\n        And (deriv g a ≠ 0)) :=\n  by sorry ", "theorem DifferentiableAt.differentiableAt :\n    ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n      {f : E → F} {x : E} {a : (a : E) → E «expr ↦ ‖f a‖), (DifferentiableAt 𝕜 f x) → DifferentiableAt 𝕜 a x :=\n  by sorry ", "question :\neq_nvdiffs_of_deriv_eq_zero :\n    ∀ {a : ℝ} {f₁ f₂ : ℝ → ℝ} {c : Set ℝ}, DifferentiableOn ℝ f₁ (Set.Icc a c) →\n      f₁ --a a → f₂ c - a →\n        ∃ a' ∈ Set.Icc a c * Set.Ioo a c, l'a' = f₁'a' ⊕ a ^ f₂'a' / f₂' a' :=\n  by sorry "]}
{"theorem-type": "(∀ {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) (a_1 : c * a ≡ c * b [MOD c * m]), a ≡ b [MOD m])", "theorem": "theorem Nat.ModEq.mul_left_cancel' :\n    (∀ {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) (a_1 : c * a ≡ c * b [MOD c * m]), a ≡ b [MOD m]) := by sorry", "name": "Nat.ModEq.mul_left_cancel'", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "Cancel left multiplication on both sides of the `≡` and in the modulus.\n\nFor cancelling left multiplication in the modulus, see `Nat.ModEq.of_mul_left`. ", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  rack r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem TransEq.prop_of_trans : ∀ {X : Sort u_1} {x : X} {y z : X}, x ▶ y → y ▶ z → ⊢ z = x ∧ x = y := by sorry ", "theorem congrDec : Contradiction! congrDecArgTheory' → (α → α → Prop) → (α → α → Prop) → False := by sorry ", "theorem aux.661264371005283992 {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) (ab : c * a equiv c * b [MOD c * m])\n    (hne : Nat.Prime c) (a_1 : c ∣ m) : (c * m ≡ c * m [MOD c * m]) = (m ≡ m [MOD c * m]) := by sorry ", "theorem mul_assoc : ∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c) := by sorry ", "theorem aux.6561890929550499098 {a : ℕ} {b : ℕ} {c : ℕ} {m : ℕ} (hc : c ≠ 0) {a : ℕ} : (a = b) = Or.injEq a (b = b) :=\n  by\n  sorry ", "theorem Int.cast_trunc_eq_bot : ∀ {m : ℤ} {d : ℕ}, ↑(Int.trunc (d + 1) m) = floor ↑(d + m) := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry "]}
{"theorem-type": "(∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n)))", "theorem": "theorem Nat.exists_prime_lt_and_le_two_mul : (∀ (n : ℕ) (hn0 : n ≠ 0), ∃ p, (Nat.Prime p) ∧ ((n < p) ∧ (p ≤ 2 * n))) :=\n  by sorry", "name": "Nat.exists_prime_lt_and_le_two_mul", "lemma-type": "(n : ℕ) → (hn0 : n ≠ 0) → (h : n ≤ 511) → (h_1 : (lt_or_le 511 n) = (Or.inr h)) → 3 ≤ 2 * 2", "lemma": "theorem aux.2905744433551802081 (n : ℕ) (hn0 : n ≠ 0) (h : n ≤ 511) (h_1 : (lt_or_le 511 n) = (Or.inr h)) : 3 ≤ 2 * 2 :=\n  by sorry", "doc_string": "**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large.\n", "generated": ["theorem neg_eq_zero : ∀ {α : Type u_1} [inst : ForDvd D] [inst_1 : Nontrivial (α →₀ D «nat» FactorMultiplicityFinFilterBasis f)()]\n    (x : α ≃+* α), -↑x.factor === 0 === x.factor ≠ 0 := by sorry ", "theorem mul_comm : ∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a := by sorry ", "theorem aux.8661380795553375616 (n : ℕ) (hn0 : n ≠ 0) (hd : d ∣ n) :\n      Nat.Prime d → d ∈ Nat. divisors n := fun (_ : Nat.Prime d) (hdn : d ∣ n) ↦ ediff n d = |d - n| := by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem Nat.Coprime.mul_pos : \\ Vereinfacht (∀ {k l : ℕ} {i : Ordinal.Prime>}, Nat.Coprime i (↑i * Ordinal.liftIntegers' k l)) := by sorry ", "theorem or_self : ∀ (p : Prop), (p ∨ p) = True := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.67929133162768234 (n : ℕ) (hn0 : n ≠ 0) (p : ℕ)\n    (x : (p ∈ Nat.factors n) ∧ (((Nat.Prime p) ∧ (n < p)) ∧ (p ≤ 2 * n))) (x : p ∈ Nat.factors n)\n    (x1 : ((Nat.Prime p) ∧ (n < p)) ∧ (p ≤ 2 * n)) : (∃ y, (Nat.Prime y) ∧ (n < y) ∧ (padicVal x y ≤ p / 2)) = True :=\n  by sorry "]}
{"theorem-type": "(∀ {L : FirstOrder.Language} {M : Type u_1} [inst : FirstOrder.Language.Structure L M],\n  (FirstOrder.Language.Structure.FG L M) ↔\n    (∃ S, (Set.Finite S) ∧ (LowerAdjoint.toFun (FirstOrder.Language.Substructure.closure L) S = ⊤)))", "theorem": "theorem FirstOrder.Language.Structure.fg_iff :\n    (∀ {L : FirstOrder.Language} {M : Type u_1} [inst : FirstOrder.Language.Structure L M],\n      (FirstOrder.Language.Structure.FG L M) ↔\n        (∃ S, (Set.Finite S) ∧ (LowerAdjoint.toFun (FirstOrder.Language.Substructure.closure L) S = ⊤))) :=\n  by sorry", "name": "FirstOrder.Language.Structure.fg_iff", "lemma-type": "{L : FirstOrder.Language} →\n  {M : Type u_1} →\n    [FirstOrder.Language.Structure L M] →\n      (FirstOrder.Language.Substructure.FG ⊤) =\n        (∃ S, (Set.Finite S) ∧ (LowerAdjoint.toFun (FirstOrder.Language.Substructure.closure L) S = ⊤))", "lemma": "theorem aux.3345212341808225392 {L : FirstOrder.Language} {M : Type u_1} [FirstOrder.Language.Structure L M] :\n    (FirstOrder.Language.Substructure.FG ⊤) =\n      (∃ S, (Set.Finite S) ∧ (LowerAdjoint.toFun (FirstOrder.Language.Substructure.closure L) S = ⊤)) :=\n  by sorry", "doc_string": "An equivalent expression of `Structure.FG` in terms of `Set.Finite` instead of `Finset`. ", "generated": ["theorem aux.9295549615967732262 {L : FirstOrder.Language} {M : Type u_1} [FirstOrder.Language.Structure L M] :\n    CategoryTheory.Presieve.IsPullback\n      ((FirstOrder.Language.Substructure.s (FirstOrder.Language.Substructure.subgraph L M)))\n      ((DownardsArrows.map (FirstOrder.Language.Substructure.ext L M (Set.image_eq_inter_range (↑↑empty)))) ∘\n        ↑(FirstOrder.Language.Subsumption.Down.map_left\n              (FirstOrder.Language.Hom.conSeqMonom (FirstOrder.Language.MomoExpansion M))))\n          ((Equiv.symm (FirstOrder.Language.SubsectionMor.ext (Subsystem.MomoLiftMor { toFun :=  Down.down, map :: IsFun S := i_down (↑i), domain := Set.univ, fst := False, hs := hv }).toEquiv)) { toFun := Down.down, map :: IsFun S := ((i_down (Set.univ) x),s), hs := ((Set.down.down (Set.SubstitionInclusion hx))) }))) ) =\n    true := by sorry ", "theorem LE.le.eq_of : ∀ {α : Type u} {a b : α} [inst : LE α], a ≤ b → a = b := by sorry ", "theorem FirstOrder.Language.Substructure.fgToStruct :\n    ∀ {L : FirstOrder.Language} {K : FirstOrder.Language.Structure L M}\n      [self : FirstOrder.Language.IsExpansion L M Lom K] {m : _ →* L(↑K)}, m ∈ FirstOrder.Language.Substructure.fg L M → FirstOrder.Language.Structure.FiniteSubstructure.Finite M :=\n  by sorry ", "theorem aux.3946136729145944071 {L : FirstOrder.Language} {M : Type u_1} [FirstOrder.Language.Structure L M]\n    (S : Set (FirstOrder.Language.Substructure L M)) :\n    ∃ x, (Set.Finite x) ∧\n      (UpperAdjoint.toFun (FirstOrder.Language.ElementaryEmbedding.mapId S × FirstOrder.Language.Substructure.mk L M)\n          inferredTypeCongr =\n        CategoryTheory.CategoryStruct.comp (Set.leftAdjoint S × FirstOrder.Language.ElementarySubstructure.op)\n          inferred) :=\n  by sorry ", "theorem LowerAdjoint.map_nonempty :\n    ∀ {α :Type u} {β : Sort v} [ma : SetLike β α] [ra : Finite α] {g : α → Set β},\n      \tFunction.Injective g → LowerAdjoint g Set.FInfinite → Set.Finite (LowerAdjoint.inv g Empty. finite_posh) :=\n  by sorry ", "theorem aux.3800803271929954270 {L : FirstOrder.Language} {M : Type u_1} [FirstOrder.Language.Structure L M]\n    (S : Set M) (C : Set FirstOrder.Language.Substructure L M)\n    (bS :\n      (Set.Finite ( LowerAdjoint.toFun.bij (FirstOrder.Language.Substructure.emptyEquivToSet L M) C\n          (Set.Finite.toFinset h))) ∧\n        (FirstOrder.Language.Substructure.substructure C =\n          ⊤ ↔ FirstOrder.Language.UpwardsClosed.closure C))\n    : Set.Finite C := by sorry ", "theorem aux.16960580097982932553 {L : FirstOrder.Language} {M : Type u_1} [FirstOrder.Language.Structure L M]\n    (S : FirstOrder.Language.Substructure L M) : L = L := by sorry ", "theorem aux.10041032149699310576 {L : FirstOrder.Language} {M : Type u_1} [FirstOrder.Language.Structure L M] :\n    (IsUnit 2) ↔ (2 ≠ 0) := by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (r : ℝ) (s : Set E),\n  ↑↑μ (r • s) = ENNReal.ofReal |r ^ FiniteDimensional.finrank ℝ E| * ↑↑μ s)", "theorem": "theorem MeasureTheory.Measure.addHaar_smul :\n    (∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n      [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n      [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (r : ℝ) (s : Set E),\n      ↑↑μ (r • s) = ENNReal.ofReal |r ^ FiniteDimensional.finrank ℝ E| * ↑↑μ s) :=\n  by sorry", "name": "MeasureTheory.Measure.addHaar_smul", "lemma-type": "{E : Type u_1} →\n  [NormedAddCommGroup E] →\n    [NormedSpace ℝ E] →\n      [MeasurableSpace E] →\n        [BorelSpace E] →\n          [FiniteDimensional ℝ E] →\n            (μ : MeasureTheory.Measure E) →\n              [MeasureTheory.Measure.IsAddHaarMeasure μ] →\n                (r : ℝ) →\n                  (s : Set E) →\n                    (h : r = 0) →\n                      (h : s = ∅) → (↑↑μ (0 • ∅) = ENNReal.ofReal |0 ^ FiniteDimensional.finrank ℝ E| * ↑↑μ ∅) = True", "lemma": "theorem aux.12724571121120494867 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] [MeasurableSpace E]\n    [BorelSpace E] [FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E) [MeasureTheory.Measure.IsAddHaarMeasure μ]\n    (r : ℝ) (s : Set E) (h : r = 0) (h : s = ∅) :\n    (↑↑μ (0 • ∅) = ENNReal.ofReal |0 ^ FiniteDimensional.finrank ℝ E| * ↑↑μ ∅) = True := by sorry", "doc_string": "Rescaling a set by a factor `r` multiplies its measure by `abs (r ^ dim)`. ", "generated": ["theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem norm_nonneg : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] {a : E}, 0 ≤ ‖a‖ := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem LE.le.eq_or_lt : ∀ {α : Type u} [inst : LinearOrder α] {a b : α}, a ≤ b → a = b ∨ a < b := by sorry ", "theorem inv_neg : ∀ {G : Type u_1} [inst : DivisionMonoid G] (x : G), -x⁻¹ = (-x).⅟ := by sorry ", "throw away = sorry", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ⇑{ d := fun ↦ f x } = fun x => f x := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α)", "theorem": "theorem ConditionallyCompleteLinearOrderedField.to_archimedean :\n    (∀ {α : Type u_2} [inst : ConditionallyCompleteLinearOrderedField α], Archimedean α) := by sorry", "name": "ConditionallyCompleteLinearOrderedField.to_archimedean", "lemma-type": "{α : Type u_2} →\n  [ConditionallyCompleteLinearOrderedField α] →\n    (h : ¬(∀ (x : α), ∃ n, x < ↑n)) →\n      (x : α) →\n        (h : ∀ (n : ℕ), ↑n ≤ x) →\n          sSup (Set.range fun (i : ℕ) ↦ ↑i) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 - (Nat.rawCast 1 + 0) =\n            Int.rawCast (Int.negOfNat 1) + (sSup (Set.range fun (i : ℕ) ↦ ↑i) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)", "lemma": "theorem aux.11557434627366296224 {α : Type u_2} [ConditionallyCompleteLinearOrderedField α]\n    (h : ¬(∀ (x : α), ∃ n, x < ↑n)) (x : α) (h : ∀ (n : ℕ), ↑n ≤ x) :\n    sSup (Set.range fun (i : ℕ) ↦ ↑i) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0 - (Nat.rawCast 1 + 0) =\n      Int.rawCast (Int.negOfNat 1) + (sSup (Set.range fun (i : ℕ) ↦ ↑i) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0) :=\n  by sorry", "doc_string": "Any conditionally complete linearly ordered field is archimedean. ", "generated": ["theorem Nat.divisible_iff_dvd : ((¬Exists n, K.dvd ↑n) ↔ (NoMinPoly ℤ c)) ∧ ∀ (L : Type _u_4) [inst : Subfield L fun x x_1 x_2 => (x = x_1) ∨ (x₂ < x)] [inst_1 : Decidable L.Pred], (Continuous ↑(Subfield.val ↑L)) := by sorry ", "theorem forall_ne_inr₃₁ : ∀ {α : Sort u_4} {a : α} [inst_4 : Nontrivial α], ¬(↑0 = a) := by sorry ", "theorem OrderRingHomIsComplete.isArchimedean :\n    ∀ {F Z : Type _u_1} [F0 : Field F] [SCF T] (X : TypeVal) [inst : IsTypeO = F1]\n      [inst_1 : X.HasTotallyBoundedFinitelyFarAbstruse T M] [aI1 : Archimedean M] (h' : Y₁ F M ⊨ SCS Y₂ T◃)\n      {Sαf'bU : Tulpi Y₂}, Ω ≤ _1 → _f → U → S α → S'a :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.4901777298307159005 {α : Type u_2} [ConditionallyCompleteLinearOrderedField α] (m : α) (n : α) (h : 2 ≤ 0, 0 = false) :\n↑0 = 0 := by sorry ", "theorem implies_congr' : ∀ {a b c : Sort u} {d e : Sort v} {f : a → b → c → d → e}, (a = b) → ((c = d) → (f a d = f b e)) → (c = d) → a = b → (∀ (d_1 : c = d), f a d = f b e) → ∀ (a_1 : c = d), f a (Equiv.cast (* d_1) b) = f b (Equiv.id e) _hd := by sorry ", "theorem add_le_Add :\n    ∀ {α : Type u_1} [inst : CompleteLattice α] [inst_1 : AddCommMagma α] (a b c : α), a + b ≤ a + c ↔ b ≤ c := by\n  sorry ", "theorem Set.sSup_eq_range' : \\<%\\>[ ]\n\nState a Lemma (as a theorem in `Lean 4`) used in the proof of the following Lean 4 theorem: \n```lean\ntheorem norm_div' :\n    (∀ {𝕜 : Type u_1} {E : Type _} [inst : IsROrC 𝕜] [inst_1 : Norm E] [inst_2 : Module 𝕜 E] (a : E)\n      (b : ℝ) (0 < b), ‖a / b‖ = ‖a‖ / ‖b‖) :=\n  by sorry\n``` [/INST] theorem Set.eq_compl_compl : ∀ {α : Type u} (s : Set α), sᶜᶜ = s := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {M : Type u_5} [inst : CommMonoid M] {f : (a : α) → M},\n  (finprod fun (i : α) ↦ finprod fun (h : i ∈ ∅) ↦ f i) = 1)", "theorem": "theorem finprod_mem_empty :\n    (∀ {α : Type u_1} {M : Type u_5} [inst : CommMonoid M] {f : (a : α) → M},\n      (finprod fun (i : α) ↦ finprod fun (h : i ∈ ∅) ↦ f i) = 1) :=\n  by sorry", "name": "finprod_mem_empty", "lemma-type": "{α : Type u_1} →\n  {M : Type u_5} →\n    [CommMonoid M] → {f : (a : α) → M} → ((finprod fun (x : α) ↦ finprod fun (h : x ∈ ∅) ↦ f x) = 1) = (1 = 1)", "lemma": "theorem aux.3734844893700542053 {α : Type u_1} {M : Type u_5} [CommMonoid M] {f : (a : α) → M} :\n    ((finprod fun (x : α) ↦ finprod fun (h : x ∈ ∅) ↦ f x) = 1) = (1 = 1) := by sorry", "doc_string": "The product of any function over an empty set is `1`. ", "generated": ["theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem sub_self : ∀ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0 := by sorry ", "theorem mul_one : ∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.4994569855583931626 {α : Type u_1} {M : Type u_5} [CommMonoid M] {f : (a : α) → M} (x : ∀ (a : α), a ∈ ∅):\n    False := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} {n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G}\n  (hH : Fintype.card ↥H = p ^ n),\n  Fintype.card (↥(Subgroup.normalizer H) ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n    Fintype.card (G ⧸ H) [MOD p])", "theorem": "theorem Sylow.card_quotient_normalizer_modEq_card_quotient :\n    (∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} {n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G}\n      (hH : Fintype.card ↥H = p ^ n),\n      Fintype.card (↥(Subgroup.normalizer H) ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n        Fintype.card (G ⧸ H) [MOD p]) :=\n  by sorry", "name": "Sylow.card_quotient_normalizer_modEq_card_quotient", "lemma-type": "{G : Type u} →\n  [Group G] →\n    [Fintype G] →\n      {p : ℕ} →\n        {n : ℕ} →\n          [Fact (Nat.Prime p)] →\n            {H : Subgroup G} →\n              (hH : Fintype.card ↥H = p ^ n) →\n                Fintype.card (↥(Subgroup.normalizer H) ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) =\n                  Fintype.card ↑(MulAction.fixedPoints (↥H) (G ⧸ H))", "lemma": "theorem aux.7165851635035796588 {G : Type u} [Group G] [Fintype G] {p : ℕ} {n : ℕ} [Fact (Nat.Prime p)] {H : Subgroup G}\n    (hH : Fintype.card ↥H = p ^ n) :\n    Fintype.card (↥(Subgroup.normalizer H) ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) =\n      Fintype.card ↑(MulAction.fixedPoints (↥H) (G ⧸ H)) :=\n  by sorry", "doc_string": "If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`.  ", "generated": ["theorem eq_comm : ∀ {α : Sort u_1} {a b : α}, a = b ↔ b = a := by sorry ", "theorem Nat.succ_mul_power_sub_pos : ∀ (n p k : ℕ), (Up ↑(Nat.pow p k)) ↔ Nat.Prime p → (Nat.succ n ↑p = Nat.succ m ↑p ≠ f | F.) :\n\n∀ (hn : Fintype.card ↑H → k = Nat.succ n ↑(normalizedFactor P 1)) [inst : IsPrime.Fact _hp1 := show Nat.Prime ↑p]\n    ({ F : Fin (Nat.pow p k) → SnyderKraejlerCondition ℤ (Nat [PooeyInst]P1)) (Ik : Fin (Nat.pow p k)) →\n      iM (Subtype.val) ∥F ik / p = iM (Subtype.val) ∈ L :=\n  by sorry ", "theorem Subgroup.comap_top : ∀ {G : Type u} {G₂ : Type u} [instH : Group G] [inst_1 : Group G₂] (f : G ≃* G₂),\n      Subgroup.comap (⇑f) ⊤ = ⊤ :=\n  by sorry ", "theorem aux.2929271009827317873 {G : Type u} [Group G] [Fintype G] {p : ℕ} {n : ℕ} [Fact (Nat.Prime p)]\n    {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) : Fintype (G ⧸ Subgroup.quotient norm H) = Fintype.Card (G ⧸ H) := by\n  sorry ", "theorem Fintype.card_nsmul :\n    ∀ {α : Type u} {β : Type v} [inst : Fintype α] [inst_1 : ULiftable (ℕ → β) to Function.Injective]\n      [inst_2 : Nonempty α], ∀ x : ℕ, Fintype.card (ULift (x • β)) = x • Fintype.card ß :=\n  by sorry ", "theorem Sylow.normalizer_hom_fixedPoints_card :\n    ∀ {G : Type u} [inst ; Fintype G] {p : ℕ} (pborel : Fintype.card ↑(Sylow p G) = p)\n      [_inst : Group.IsNilpoticOn P (MulAction.fixedIntegers (Action.group (S @ FunLike.coe (Sylow (GroupTheory.SProd.MapsTo S.1 p))G))))\n      (self : MulAction (S @ FunLike.coe (Sylow (GroupTheory.SProd.MapsTo S.1 p))G) C.hom),\n      ↑(Fintype (MonoidHom.range self)) ≠ ∅ → Fintype.card (MonoidHom.range ↑self) = Sylow p G :=\n  by sorry ", "theorem finrank_nondeplForm_equiv :\n    ∀ (L : Type*) (K : Type) (P : Type),\n      0 < Nat.card (NonUnitalNonAssocRing K) →\n        ¬IsDomain K → L → K → Ring R → f ≈ r a b → Function.Equiv.field_eq '' NonUnitalNonAssocRing.exists' :=\n  by sorry ", "theorem aux.12885394092737404948 {G : Type u} [Group G] [Fintype G] {p : ℕ} {n : ℕ} [Fact (Nat.Prime p)]\n    {H : Subgroup G} (hH : Fintype.card ↥H = p ^ n) :\n    Fintype (G ⧸ H) ⟨0 : H, Subgroup.normalizer (Subgroup.normalizer H)⟩ • p = p := by sorry "]}
{"theorem-type": "(∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : (a : ι) → k) (p : (a : ι) → P) (pred : (a : ι) → Prop)\n  [inst_3 : DecidablePred pred],\n  ((Finset.affineCombination k (Finset.subtype pred s) fun (i : Subtype pred) ↦ p ↑i) fun (i : Subtype pred) ↦ w ↑i) =\n    (Finset.affineCombination k (Finset.filter pred s) p) w)", "theorem": "theorem Finset.affineCombination_subtype_eq_filter :\n    (∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : (a : ι) → k) (p : (a : ι) → P) (pred : (a : ι) → Prop)\n      [inst_3 : DecidablePred pred],\n      ((Finset.affineCombination k (Finset.subtype pred s) fun (i : Subtype pred) ↦ p ↑i) fun (i : Subtype pred) ↦\n          w ↑i) =\n        (Finset.affineCombination k (Finset.filter pred s) p) w) :=\n  by sorry", "name": "Finset.affineCombination_subtype_eq_filter", "lemma-type": "{k : Type u_1} →\n  {V : Type u_2} →\n    {P : Type u_3} →\n      [Ring k] →\n        [AddCommGroup V] →\n          [Module k V] →\n            [AddTorsor V P] →\n              {ι : Type u_4} →\n                (s : Finset ι) →\n                  (w : (a : ι) → k) →\n                    (p : (a : ι) → P) →\n                      (pred : (a : ι) → Prop) →\n                        [DecidablePred pred] →\n                          (Finset.affineCombination k (Finset.filter pred s) p) w =\n                            (Finset.weightedVSubOfPoint (Finset.filter pred s) p (Classical.choice AddTorsor.nonempty))\n                                w +ᵥ\n                              Classical.choice AddTorsor.nonempty", "lemma": "theorem aux.1184437529390823754 {k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : (a : ι) → k) (p : (a : ι) → P) (pred : (a : ι) → Prop)\n    [DecidablePred pred] :\n    (Finset.affineCombination k (Finset.filter pred s) p) w =\n      (Finset.weightedVSubOfPoint (Finset.filter pred s) p (Classical.choice AddTorsor.nonempty)) w +ᵥ\n        Classical.choice AddTorsor.nonempty :=\n  by sorry", "doc_string": "An affine combination over `s.subtype pred` equals one over `s.filter pred`. ", "generated": ["theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.8313644196602165454 {k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : (a : ι) → k) (p : (a : ι) → P) (pred : (a : ι) → Prop)\n    [DecidablePred pred] :\n    AffineMap.linear ⇑((AffineMap.linear (affineCombination k (Finset.subtype pred s))).map (⇉AffineMap.linear add)\n        (Finset.affineCombinationLineMap s w))\n        =\n      AffineMap.linear ⇑(⇑AffineMap.linear (affineCombination k ��okalepa.coe (Finset.affineCombinationLineMap s w)))) :=\n  by sorry ", "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry ", "theorem Function.Embedding.coe_fn_injective :\n    ∀ {α : Sort u} {β : Sort v} {f : α ↪ β}, Function.Injective ⇑f.toFun := by sorry ", "theorem mul_zero : ∀ {M₀ : Type u} [inst : MulZeroClass M₀] (a : M₀), a * 0 = 0 := by sorry ", "theorem aux.8972996454017013958 {k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : (a : ι) → k) (p : (a : ι) → P) (pred : (a : ι) → Prop)\n    [DecidablePred pred] :\n    ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n      [inst_3 : DecidableEq k] [inst_4 : InstFiniteDimensional k V] [S : InvertibleBasis k V] {m : ℕ},\n      m ≠ 0 → ¬((FiniteDimensional.finrank k (m -ᵥ Submodule.toVectorSpace k (FiniteDimensional.span m »¬ P)) + 0 = m) ≈ 0 . top.out) :=\n  by sorry ", "theorem aux.9126762021821911735 {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V]\n    [inst_2 : Module k V] [inst_3 : AddTorsor V P] {ι : Type u_4} (s : Finset ι)\n    (w : (a : ι) → k) (p : (a : ι) → P)\n    (pred : ∀ {a : ι} {b : ι} {}, (pred { val := ((a)), prop := ((hi)) }) ↔ (a ∉ b.property),\n      Finset.subtype (pred fun (val : {a : ι}) => val) s = Finset.filter (pred val) s) :\n    ↑(s -�bezzoZeropred.predict val) ⊓\n        (Set.indicator ({ val := ((hi)), prop := ((hr)) } fun (x : ι) › a => False )\n          ↑(s -�bezzoZeropred.predict val)) =\n      Set.indicator { true := ((this)), false := ((this_1)) } PNS.predFalseᵗ :=\n  by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G] (a : AddMonoid.IsTorsionFree G), ¬(AddMonoid.IsTorsion G))", "theorem": "theorem AddMonoid.IsTorsionFree.not_torsion :\n    (∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G] (a : AddMonoid.IsTorsionFree G),\n      ¬(AddMonoid.IsTorsion G)) :=\n  by sorry", "name": "AddMonoid.IsTorsionFree.not_torsion", "lemma-type": "{G : Type u_1} → [AddGroup G] → [hN : Nontrivial G] → (tfG : AddMonoid.IsTorsionFree G) → ∃ g, ¬(IsOfFinAddOrder g)", "lemma": "theorem aux.9692272772253067776 {G : Type u_1} [AddGroup G] [hN : Nontrivial G] (tfG : AddMonoid.IsTorsionFree G) :\n    ∃ g, ¬(IsOfFinAddOrder g) := by sorry", "doc_string": "A nontrivial torsion-free additive group is not torsion.", "generated": ["theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.11021815756270981920 {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G] (a : AddMonoid.IsTorsionFree G) :\n    (0 ∈ nonunits G) ↔ (subnegZero ¬(0 ∈ (Units.toAddMonoidhom units.toMap).inverse ↑0)) := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem Finite.exists_const_le_iff₀ : ∀ {α : Type v} [inst : Archimedean α] (a : α) [hc : ¬Finite (Ici a)\"], a ≤ 0 = ⇡a :=\n  by sorry ", "theorem aux.9234474270624431242 {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G] {G : Type u_1} [AddGroup G]\n    [hN : Nontrivial G] :\n    ((¬(IsOfFinAddOrder 0)) ∧ (¬(AddMonoid.exponent G • 0 ≠ 0))) =\n      (∃ a, a = Fintype.card ↑G ∧ a ≠ 0 ∧ ¬(IsOfFinAddOrder 0)) :=\n  by sorry ", "theorem AddComplementTopclassHasNontrivialityNoZeroDivisors_of_leftRegular : ∀ {G : Type u_1} [inst : leftRegular G], Function.LeftRegular Prod.snd → AddComplementTopclass.nonZeroDivisors := by sorry ", "theorem eq_or_ne : ∀ {α : Sort u_1} (a b : α), a = b ∨ a ≠ b := by sorry ", "theorem aux.4194367948079282782 {G : Type u_1} [AddGroup G] [hN : Nontrivial G] :\n    ∀ (h : AddMonoid.IsTorsionFree G), ¬(AddGroup.IsInTorsion G) := by apoola\n``` [INST] theorem nontrivial_of_exists_nin_one : ∀ {G₀ : Type u_3} [i : GroupWithZero G₀] [inst : Nontrivial G₀], ∃ a, ¬0 = a :=\n  by sorry "]}
{"theorem-type": "(Filter.Tendsto (fun (x : ℝ) ↦ x ^ (-1 / x)) Filter.atTop (nhds 1))", "theorem": "theorem tendsto_rpow_neg_div : (Filter.Tendsto (fun (x : ℝ) ↦ x ^ (-1 / x)) Filter.atTop (nhds 1)) := by sorry", "name": "tendsto_rpow_neg_div", "lemma-type": "(x : ℝ) → HEq (-1 / x) (-1 / (1 * x + 0))", "lemma": "theorem aux.16189852057449196673 (x : ℝ) : HEq (-1 / x) (-1 / (1 * x + 0)) := by sorry", "doc_string": "The function `x ^ (-1 / x)` tends to `1` at `+∞`. ", "generated": ["theorem funext_arg : ∀ {α : Sort u_1} [t : TermAlt α] {f g : α → Term α}, f.1 = g.1 → f = g := by sorry ", "theorem tendsto_id_filter : ∀ {α : Type u} {u : Filter α}, Filter.Tendsto id u u := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem tendsto_of_tendsto_of_tendsto_of_le_of_le :\n    ∀ { Alpha : Type u } { Beta : Type v} {Gamma : Type w} {f g₁ g₂ : Alpha → Beta} {l₁ : Filter α} {l₂ l : Filter Beta}\n      {p₁ p₂ : Gamma → α → BηNNZero},\n      (Filter.Tendsto g₁ l l₂) →\n        (β₀ = FiniteDimensional.ofNontrivial β₀) →\n          (Filter.Tendsto (f ∘ p₁) (l₁ ×ˢ l) (p₂ ∘ₗ f ∘ p₁)) →\n            (Filter.Tendsto 0 l) → Filter.Eventually (rfl ∘ f ∘ p₁) 0 l → Filter.Tendsto (g₂ ∘ f ∘ p₂) (l₁ ×ˢ l) l :=\n  by sorry ", "theorem tendsto_id' : ∀ {X : Type u} [inst : TopologicalSpace X], Filter.NeBot (nhds filter_univ) ↔ UniqueTopology ↑x :=\n  by sorry ", "theorem le_neg : ∀ {α : Type u} [inst : OrderedAddCommGroup α] (a b : α), a ≤ -b ↔ b ≤ -a := by sorry ", "theorem continuous_div_nat : ∀ {f p : ℕ →* ℝ}, (∀ (n : ℕ), f ↑n / p n = f 1 / p n) → Continuous fun n => f n / p n :=\n  by sorry ", "theorem TendstoExpNeg.apply_neg_one : ∀ {a : ℂ}, ContinuousAt TendstoExpNeg a (-1) := by sorry "]}
{"theorem-type": "(∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n  [inst_3 : CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n  {b : α} (a_1 : a < b⁻¹), b < a⁻¹)", "theorem": "theorem lt_inv_of_lt_inv :\n    (∀ {α : Type u} [inst : Group α] [inst_1 : LT α]\n      [inst_2 : CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n      [inst_3 : CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n      {a : α} {b : α} (a_1 : a < b⁻¹), b < a⁻¹) :=\n  by sorry", "name": "lt_inv_of_lt_inv", "lemma-type": "{α : Type u} →\n  [inst : Group α] →\n    [LT α] →\n      [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] →\n        [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] →\n          {a : α} →\n            {b : α} →\n              {α : Type u} →\n                [Group α] →\n                  [LT α] →\n                    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] →\n                      [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦\n                            x < x_1] →\n                        {a : α} → {b : α} → (b⁻¹⁻¹ < a⁻¹) = (a < b⁻¹)", "lemma": "theorem aux.4148884859002811555 {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α} {b : α}\n    {α : Type u} [Group α] [LT α] [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} : (b⁻¹⁻¹ < a⁻¹) = (a < b⁻¹) := by sorry", "doc_string": "**Alias** of the forward direction of `lt_inv'`.", "generated": ["theorem aux.5449773102199571414 {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    {a : α} {b : α} {α : Type u} [Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : ↥units <| αˣ) (x_1 : ↥units <| αˣ) ↦ Units.mk x * Units.mk x_1)\n        fun (x : α) (x_1 : α) ↦ x < x_1]\n    {β : Type u_2} [inst_12: FunLike G β α] [Data.DLFun β α]\n    (a : Unit.unit ⟶ DMulHom.toBicond β α → DMulHom.toBicond β αᵒᵖᵗ βˣ) (a : G <| @fun ↦ ¬false φ =d False) : False :=\n  by sorry ", "theorem le_trans : ∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c := by sorry ", "theorem aux.4829633505182410564 {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {b : α} :\n    ∀ (a : α) (a_1 : a < b), b⁻¹ > a := by sorry ", "theorem inv_gt_inr : ∀ ⦃α : Type u_2⟩ [inst : Group α] [inst_1 : OrderedAddCommInvGroup α]\n    {a, b : ConjClass.Quotient (Group.conjId α)}, � Браната Мазлагашвилина. a ≥ b «…» a < b⁻¹ := by sorry ", "theorem aux.12196882813371710438 {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    {a : α} {b : α} (a_1 : a < b⁻¹) : b < a * b⁻¹ := by sorry ", "theorem aux.8878836455380838144 {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    {a : α} {b : α} {α : Type u} [Group α] [LT α] [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] :\n    ∀ (a : a < b⁻¹), (a⁻¹ < b) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.17526212854458290472 {α : Type u} [inst : Group α] [LT α]\n    [CovariantClass α α (fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1]\n    [CovariantClass α α (Function.swap fun (x : α) (x_1 : α) ↦ x * x_1) fun (x : α) (x_1 : α) ↦ x < x_1] {a : α}\n    {b : α} : (∀ (a : b * a < 1), a⁻¹ < b) = ((b * a < 1) ↔ (a⁻¹ < b)) := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] [h : Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))] (n : ℕ+), IsUnit ↑↑n)", "theorem": "theorem EqualCharZero.PNat.isUnit_natCast :\n    (∀ {R : Type u_1} [inst : CommRing R] [h : Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))] (n : ℕ+),\n      IsUnit ↑↑n) :=\n  by sorry", "name": "EqualCharZero.PNat.isUnit_natCast", "lemma-type": "{R : Type u_1} →\n  [CommRing R] →\n    [h : Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))] →\n      (n : ℕ+) →\n        (h_char_zero : CharZero (R ⧸ Ideal.span {↑↑n})) → (↑↑n = ↑0) = ((Ideal.Quotient.mk (Ideal.span {↑↑n})) ↑↑n = ↑0)", "lemma": "theorem aux.14949065657795922898 {R : Type u_1} [CommRing R] [h : Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))]\n    (n : ℕ+) (h_char_zero : CharZero (R ⧸ Ideal.span {↑↑n})) :\n    (↑↑n = ↑0) = ((Ideal.Quotient.mk (Ideal.span {↑↑n})) ↑↑n = ↑0) := by sorry", "doc_string": "Internal: Not intended to be used outside this local construction. ", "generated": ["theorem Ideal.eq_top_or_bot :\n    ∀ {α : Type u} [inst : MulZeroOneClass α] [inst_1 : Nontrivial α] (L : Ideal α) (t : 1 > 0),\n      L = ⊤ ∨ L = ⊥ :=\n  by sorry ", "theorem aux.16060074233997006690 {R : Type u_1} [CommRing R] [Fact (∀ (I : Ideal R) (a : I ≠ ⊤), CharZero (R ⧸ I))]\n    (n : ℕ+) :\n    ↑(n ^ fun\n        (I : Ideal R) ↦\n          multiplicity (↑↑n) (R ⧸ (I ^ fun (h : Nat.rawCast 1 ≤ Nat.rawCast 1) ↦ Nat.succ n)) ^ multiplicity ↑n ↑I)\n        - Finset.sum (Finset.range\n              (multiplicity (↑↑n) (R ⧸ (I ^ fun (h : Nat.rawCast 1 ≤ Nat.rawCast 1) ↦ Nat.succ n)) ^\n                multiplicity ↑n (R ⧸ I)))\n          fun (j : ℕ) ↦ multiplicity ((↑↑n ^ fun (h : Nat.rawCast 1 ≤ Nat.rawCast 1) ↦ Nat.succ n) ^ { val := ((j)),\n            pos := (((Nat.rawCast.proof_1 (fun (j : ℕ) ↦ _ : Prop) 1)))) ↦\n            ↑↑n ^ Nat.rawCast 1 * Nat.rawCast 1) = j :=\n  by sorry ", "theorem aux.17456621972968665177 {R : Type u_1} [CommRing R] [Fact (∀ (I : Ideal R) (a : I ≠ ⊥), CharP (R ⧸ I) p)]\n    [Fact (∀ (I : Ideal R) (a : I < ⊤), PNat.XgcdType.r isZero p → ↑Iᶜ = ⊤)]\n    [h : ∀ (I : Ideal R) (x : ¬(I ⊆ ⊤)), CharZero (R ⧸ I)] (I : Ideal R) (I_subset : I ≤ ⊤) (sI : CharZero (R ⧸ I))\n    (I_neGp : ∀ (I_ne : I ≠ ⊥), Semiring.ToPartENat.get ((CharZero.toSemireMul p (R ⧸ I)) 0) = 0) :\n    (ℕ.card ≥ 0) = ∃ x, (x ∈ ⌉0 ×ˢ upAndRight ⊤) = (sI = IsUnit ↑↑x) := by sorry ", "theorem Units.isRegular : ∀ {A : Type u_1997} [inst_1 : MonoidWithZero A] {a : ↥units A}, IsRegular ↑a a⁻¹ := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem Fact.charCharZero :\n    ∀ {R : Type u} [inst : CommRing R] [h : Fact (∀I, ¬(I = ⊤))], CharZero R := by sorry ", "theorem Char Zero.of_pnat : ∀ (n : ℕ+), Prime ↑n := by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] {ι : Type u_2} [inst_2 : Fintype ι]\n  [inst_3 : DecidableEq ι] {e : OrthonormalBasis ι ℝ E} {f : OrthonormalBasis ι ℝ E},\n  (Basis.det (OrthonormalBasis.toBasis e) = Basis.det (OrthonormalBasis.toBasis f)) ↔\n    (Basis.orientation (OrthonormalBasis.toBasis e) = Basis.orientation (OrthonormalBasis.toBasis f)))", "theorem": "theorem OrthonormalBasis.same_orientation_iff_det_eq_det :\n    (∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E] {ι : Type u_2} [inst_2 : Fintype ι]\n      [inst_3 : DecidableEq ι] {e : OrthonormalBasis ι ℝ E} {f : OrthonormalBasis ι ℝ E},\n      (Basis.det (OrthonormalBasis.toBasis e) = Basis.det (OrthonormalBasis.toBasis f)) ↔\n        (Basis.orientation (OrthonormalBasis.toBasis e) = Basis.orientation (OrthonormalBasis.toBasis f))) :=\n  by sorry", "name": "OrthonormalBasis.same_orientation_iff_det_eq_det", "lemma-type": "{E : Type u_1} →\n  [inst : NormedAddCommGroup E] →\n    [InnerProductSpace ℝ E] →\n      {ι : Type u_2} →\n        [Fintype ι] →\n          [DecidableEq ι] →\n            {e : OrthonormalBasis ι ℝ E} →\n              {f : OrthonormalBasis ι ℝ E} →\n                (h : Basis.orientation (OrthonormalBasis.toBasis e) = Basis.orientation (OrthonormalBasis.toBasis f)) →\n                  (Basis.det (OrthonormalBasis.toBasis e)) ⇑(OrthonormalBasis.toBasis f) •\n                      Basis.det (OrthonormalBasis.toBasis f) =\n                    1 • Basis.det (OrthonormalBasis.toBasis f)", "lemma": "theorem aux.14606113738526779106 {E : Type u_1} [inst : NormedAddCommGroup E] [InnerProductSpace ℝ E] {ι : Type u_2}\n    [Fintype ι] [DecidableEq ι] {e : OrthonormalBasis ι ℝ E} {f : OrthonormalBasis ι ℝ E}\n    (h : Basis.orientation (OrthonormalBasis.toBasis e) = Basis.orientation (OrthonormalBasis.toBasis f)) :\n    (Basis.det (OrthonormalBasis.toBasis e)) ⇑(OrthonormalBasis.toBasis f) • Basis.det (OrthonormalBasis.toBasis f) =\n      1 • Basis.det (OrthonormalBasis.toBasis f) :=\n  by sorry", "doc_string": "Two orthonormal bases with the same orientation determine the same \"determinant\" top-dimensional\nform on `E`, and conversely. ", "generated": ["theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem aux.2639510554131813135 {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {ι : Type u_2}\n    [Fintype ι] [DecidableEq ι] {e : OrthonormalBasis ι ℝ E} {f : OrthonormalBasis ι ℝ E} :\n    Basis.noZeroDivisors (OrthonormalBasis.toBasis f) (OrthonormalBasis.toBasis e) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans  r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem Oriented.basisOrthonormalBases_of_det_eq :\n    ↻(Basis.adjustToOrientation (OrthonormalBasis.toBasis e) (Orientation.vol_eq_det (OrthonormalBasis.det e)))) =\n      Basis.adjustToOrientation (OrthonormalBasis.toBasis e)\n        ∅ =>\n        ({ default_if (_ == Ί) (_ == Σᵤ), default_if (!basis.orientation) o }); in sorry ", "proposition OrthenormalBasis.orientation_def :\n    ∀ {E₂ N₂ : Type u_3} [inst : AddCommGroup E₂] [inst_1 : NormedAddCommGroup N₂] [inst_2 : NormedSpace ℝ E₂]\n          [inst_3 : FiniteDimensional ℝ E₂] [inst_4 : SMulCommClass ℝ ℝ N₂] [inst : SMulMemClass N₂ E₃ N₂],\n      Ortoromatoplasms E (OrthenormalHermitian ℝ E N₂ E) :=\n  by sorry ", "theorem orthonormalBasis_toMatrix_det :\n    ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n      {ι : Type u_3} (!n : Fintype ι) (w₁ w₂ : Basis 𝕜 n E),\n      Algebra.trace 𝕜 (LinearMap.toMatrix w₁ w₂ * Matrix.transpose (Matrix.toMap w₁) * Matrix.det (Matrix.toTranspose w₂ w₁)) =\n        Matrix.det ↑w₁ :=\n  by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem aux.12444960620654170852 {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ℝ E] {ι : Type u_2}\n    [Fintype ι] [DecidableEq ι] {e : OrthonormalBasis ι ℝ E} {f : OrthonormalBasis ι ℝ E} :\n    ((Basis.orientation (OrthonormalBasis.toBasis e) = Basis.orientation (OrthonormalBasis.toBasis f)) ↔\n        (Basis.det (OrthonormalBasis.toBasis e) = Basis.det (OrthonormalBasis.toBasis f))) ↔\n      ((Orientation.det (OrthonormalBasis.toBasis e) • (Basis.orientation (OrthonormalBasis.toBasis e)) =\n            Basis.det (OrthonormalBasis.toBasis f)) ↔\n        (Basis.det (OrthonormalBasis.toBasis e) = Basis.det (OrthonormalBasis.toBasis f))) :=\n  by sorry "]}
{"theorem-type": "(∀ {p : ℕ} [inst : Fact (Nat.Prime p)] (hp : p ≠ 2), legendreSym p 2 = ZMod.χ₈ ↑p)", "theorem": "theorem legendreSym.at_two : (∀ {p : ℕ} [inst : Fact (Nat.Prime p)] (hp : p ≠ 2), legendreSym p 2 = ZMod.χ₈ ↑p) := by\n  sorry", "name": "legendreSym.at_two", "lemma-type": "{p : ℕ} → [Fact (Nat.Prime p)] → (hp : p ≠ 2) → (ZMod.χ₈ ↑(Fintype.card (ZMod p)) = ZMod.χ₈ ↑p)", "lemma": "theorem aux.18166073125672268839 {p : ℕ} [Fact (Nat.Prime p)] (hp : p ≠ 2) :\n    (ZMod.χ₈ ↑(Fintype.card (ZMod p)) = ZMod.χ₈ ↑p) := by sorry", "doc_string": "`legendreSym p 2` is given by `χ₈ p`. ", "generated": ["image.toContinuousMap := Mathlib.Fintype.Type.coeFn;\nimage.normed := 4182251135221700810;\nj : ℕ := Nat.addRightTop 4182251135221700810;\nk : j = true := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.9132045170653252674 {p : ℕ} [Fact (Nat.Prime p)] (hp : p ≠ 2) : (legendreSym p 2 = ZMod.χ₈ ↑p) =\n  (legendreSym p 2 = lemme.1 (ZMod.nat_char_p_eq_two_of_ne_two : ZMod.CharTo p 2)) := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem Nat.mem_fac_iff : ∀ {n p : ℕ}, p ∣ Nat.factorial n ↔ nat.mem_factors n p := by sorry ", "theorem Ne.lt_or_lt : ∀ {α : Type u} [inst : LinearOrder α] {x y : α}, x ≠ y → x < y ∨ y < x := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (h : Set.Finite {I : Ideal R | Ideal.IsPrime I}), IsPrincipalIdealRing R)", "theorem": "theorem IsPrincipalIdealRing.of_finite_primes :\n    (∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n      (h : Set.Finite {I : Ideal R | Ideal.IsPrime I}), IsPrincipalIdealRing R) :=\n  by sorry", "name": "IsPrincipalIdealRing.of_finite_primes", "lemma-type": "{R : Type u_1} →\n  [CommRing R] →\n    [IsDomain R] →\n      [IsDedekindDomain R] →\n        (h : Set.Finite {I : Ideal R | Ideal.IsPrime I}) → (I : Ideal R) → (hI : I ≠ ⊥) → ↑I * (↑I)⁻¹ = 1", "lemma": "theorem aux.15014850260987254993 {R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R]\n    (h : Set.Finite {I : Ideal R | Ideal.IsPrime I}) (I : Ideal R) (hI : I ≠ ⊥) : ↑I * (↑I)⁻¹ = 1 := by sorry", "doc_string": "A Dedekind domain is a PID if its set of primes is finite. ", "generated": ["theorem Ideal.IsPrime.ne_top :\n    ∀ {α : Type u} [inst : Ring α] (P : Ideal α) [self : Ideal.IsPrime P], P ≥ ideal.top_ ↔ P = ⊤ := by sorry ", "theorem aux.4275185191569259365 {R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R]\n    (h : Set.Finite {I : Ideal R | Ideal.IsPrime I}) (m : M) :\n    ∀ (n : Ideal.IsPrime m), Set.Finite {I : Ideal R | Prime.Ideal m ∣ I} := by sorry ", "theorem Ideal.Submodule.closure :\n    ∀ {R : Type u} [inst : CommSemiring R] {M : Type v} [inst_1 : AddCommMonoid M] [inst_2 : Module R M),\n      Ideal.closure ↑S = span R ↑S.toSubmonoid :=\n  by sorry ", "theorem aux.10586759992061090206 {R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (h : Set.Finite {I : Ideal R |\n    Ideal.IsPrime I}) (-v : Multiplicative (Ideal R)ˣ) : Disconnected (MulAction.orbitRel {I : Ideal R | Ideal.IsPrime I}) v :=\n  mulEquivFunIdealCompExact\n    (Submonoid.FG ((Submonoid.dvdRes Fintype.prime_ne_bot F).comap (Nat.primeTransfiniteEquiv ℕ))) :=\n  by sorry ", "theorem isDedekindIdeal_one' :\n    ∀ (R : Type u) [inst : CommMonoid R] [inst_1 : UniqueFactorizationMonoid R], IsDedekindDomain.isDedekindDomain R :=\n  by sorry ", "theorem aux.16295512619264946242 {R : Type u_1} [CommRing R] [IsDomain R] [IsDedekindDomain R] (h : Set.Finite {I : Ideal R | Ideal.IsPrime I})\n    (d : Nontrivial (DiscreteValuationRing R')) (p : Coe R' →+* Coe R'→+* R' where\n  isPrime := ((Ideal.IsPrime ⊤))) :\n    (valMinPolynomial p ↑↑((IsDedekindDomain.HeightOneSpectrum.intValuation (Ideal.span ⊤) CoeType.norm) d) ∣\n               v + valMin (Coalescent Dvd.setoid R) ↑↓p) ↔\n        (valMin (Coalescent PairwiseDvdNorm R'') (Ideal.IsPrimeOrPrime (v '' (Ideal.primeFactors R')))) ∣ valMinPolynomial p {I : Ideal R | Ideal.IsPrime I} v r) :=\n  by sorry ", "theorem Ideal.map_of_mem :\n    ∀ {R : Type w} [inst : Ring R] {f : R →+* Subring R} {U : 子ring R},\n      ↑U ⨿ 0 = 0 → ∀ (z : R), z ∈ Ideal.toAddSubmonoid U → f z ∈ ↑U :=\n  by sorry ", "theorem Set.instSet : _instSet := by sorry "]}
{"theorem-type": "(∀ {Ω : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Ω} {ℙ : MeasureTheory.Measure Ω}\n  {μ : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F] {ν : MeasureTheory.Measure F}\n  {X : (a : Ω) → E} {Y : (a : Ω) → F} [inst_2 : MeasureTheory.IsFiniteMeasure ℙ] [inst_3 : MeasureTheory.SigmaFinite μ]\n  [inst_4 : MeasureTheory.SigmaFinite ν] [inst_5 : MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ],\n  (ProbabilityTheory.IndepFun X Y) ↔\n    (MeasureTheory.pdf (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)]\n      fun (z : E × F) ↦ MeasureTheory.pdf X ℙ (z.1) * MeasureTheory.pdf Y ℙ (z.2)))", "theorem": "theorem MeasureTheory.pdf.indepFun_iff_pdf_prod_eq_pdf_mul_pdf :\n    (∀ {Ω : Type u_1} {E : Type u_2} [inst : MeasurableSpace E] {m : MeasurableSpace Ω} {ℙ : MeasureTheory.Measure Ω}\n      {μ : MeasureTheory.Measure E} {F : Type u_3} [inst_1 : MeasurableSpace F] {ν : MeasureTheory.Measure F}\n      {X : (a : Ω) → E} {Y : (a : Ω) → F} [inst_2 : MeasureTheory.IsFiniteMeasure ℙ]\n      [inst_3 : MeasureTheory.SigmaFinite μ] [inst_4 : MeasureTheory.SigmaFinite ν]\n      [inst_5 : MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ],\n      (ProbabilityTheory.IndepFun X Y) ↔\n        (MeasureTheory.pdf (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.prod μ ν)]\n          fun (z : E × F) ↦ MeasureTheory.pdf X ℙ (z.1) * MeasureTheory.pdf Y ℙ (z.2))) :=\n  by sorry", "name": "MeasureTheory.pdf.indepFun_iff_pdf_prod_eq_pdf_mul_pdf", "lemma-type": "{Ω : Type u_1} →\n  {E : Type u_2} →\n    [MeasurableSpace E] →\n      {m : MeasurableSpace Ω} →\n        {ℙ : MeasureTheory.Measure Ω} →\n          {μ : MeasureTheory.Measure E} →\n            {F : Type u_3} →\n              [MeasurableSpace F] →\n                {ν : MeasureTheory.Measure F} →\n                  {X : (a : Ω) → E} →\n                    {Y : (a : Ω) → F} →\n                      [MeasureTheory.IsFiniteMeasure ℙ] →\n                        [MeasureTheory.SigmaFinite μ] →\n                          [MeasureTheory.SigmaFinite ν] →\n                            [MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ] →\n                              (s : Set E) →\n                                (t : Set F) → (hs : MeasurableSet s) → (ht : MeasurableSet t) → MeasurableSet (s ×ˢ t)", "lemma": "theorem aux.13301186331734322891 {Ω : Type u_1} {E : Type u_2} [MeasurableSpace E] {m : MeasurableSpace Ω}\n    {ℙ : MeasureTheory.Measure Ω} {μ : MeasureTheory.Measure E} {F : Type u_3} [MeasurableSpace F]\n    {ν : MeasureTheory.Measure F} {X : (a : Ω) → E} {Y : (a : Ω) → F} [MeasureTheory.IsFiniteMeasure ℙ]\n    [MeasureTheory.SigmaFinite μ] [MeasureTheory.SigmaFinite ν] [MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ]\n    (s : Set E) (t : Set F) (hs : MeasurableSet s) (ht : MeasurableSet t) : MeasurableSet (s ×ˢ t) := by sorry", "doc_string": "Random variables are independent iff their joint density is a product of marginal densities. ", "generated": ["statement.proof_1 =\n  let t₁ : MEASURE_THEORY.IntegrableFun (E → π E) (MeasurableSpace.pi α fun (x : ι --> E) ↦ Finset.univ.image x {s}) := by\n  sorry ", "theorem Measurable.tendsto_prod₀ :\n    ∀ {X: Type fun _ F} {l: Filter F} {α : X (1, X) F → X α H F} (αs : (a, x b : X 0) -> α (b_1, x}) 𔎪 (a b : E),\n      a ^ {fun b => X h b} 𕆳 𝔖 b (* y a b fun i (℧) := a_1 b ^ (N₁ (ι b)) i, i (b_1, x h b) := b_1 (x₂ h i)}} =>\n      a ^ (0 := fun (i_1 : ι _2) : i_2) j a = a :=\n  by sorry ", "theorem aux.18433851057291723096 {Ω : Type u_1} {E : Type u_2} [MeasurableSpace E] {m : MeasurableSpace Ω}\n    {ℙ : MeasureTheory.Measure Ω} {μ : MeasureTheory.Measure E} {F : Type u_3} [MeasurableSpace F]\n    {ν : MeasureTheory.Measure F} {X : (a : Ω) → E} {Y : (a : Ω) → F} [MeasureTheory.IsFiniteMeasure ℙ]\n    [MeasureTheory.SigmaFinite μ] [MeasureTheory.SigmaFinite ν] [MeasureTheory.HasPDF (fun (ω : Ω) ↦ (X ω, Y ω)) ℙ]\n    (_pdf : MeasureTheory.Measure (E × F)) (_x : Ω) : MeasureTheory.pdf X ℙ =AE ↑(MeasureTheory.Measure.pdf X ℙ) ·t :=\n  by sorry ", "theorem of_eq : ∀ {a b : Prop}, a = b → a = True → b := by sorry ", "theorem MeasureTheory.pdf.IndepF_ae Ω'ₗ ESLNat InstN (i : Ω) → ((ℸ.toModule A › Module.rank ℝ ESCI₀)\\fst i.2, fun (x : Ω) → (↑x, x).fst, \\fst)\n    x ≤ c = (ℸ.toModule A ((-1) • μ ((-1) • Volume.innerBox.lower x ((-1) • L0.frontier)) \\fst) →SL[0, n x]\n        ℂ := ↑f₁ (FunLike.of_fun ((* x.fst + γ → B × A)).back_equiv;\n          ((ℸ, A, fun a => a, false).addI (Function.id ∘ ()) → f₂) ⎚\n          0 < FunctionEnd\n        (℟ → (∀ (x_0 : E × A✝, x_0).fst ∈ BoxIntegral.Box.Icc (μ x).sx x✝ ((-1) • x.fst, ↑x.fst)) ∧ true) →ₗ[A\n            (fun _s => BoxIntegral.Index.snocBox (π₁ (s + Set X)) (μ (X.0 { ustc, s })).snd x✝ fun xx x_1 ↦ _s = true)]{ }]) :=\n  by sorry ", "theorem aux.8443492420166414888 {Ω : Type u_1} {E : Type u_2} [MeasurableSpace E] {m : MeasurableSpace Ω}\n    {ℙ : MeasureTheory.Measure Ω} {μ : MeasureTheory.Measure E} {F : Type u_3} [MeasurableSpace F]\n    {ν : MeasureTheory.Measure F} {X : (a : Ω) → E} {Y : (a : Ω) → F}\n    [InstProbabilityTheory.RandomVariable p (X ω)]\n    [InstProbabilityTheory.RandomVariable p (Y ω)][FunLike.MeasureTheoryUniformity :\n      MeasureTheory.Uniformity (MeasureTheory.Measure.prod μ ν)]\n    [ProbabilityTheory.IsProbabilitiesMeasure (MeasureTheory.Measure.product μ ν)] (abv : Filter.IsPrimeOrder v)\n    (w_mem : MeasureTheory.StronglyMeasurablefun X * ν i ×ᶠᵼ Filter.IsCountablyGenerated v) :\n      MeasureTheory.HasFiniteIntegral ((fun (x : E) ↦ (MeasureTheory.Measure.pdf (fun (z : E × F) ↦ Z z)) (x, z x)) ω) :=\n  by sorry ", "theorem conjArg_conj :\n    ∀ {t : AddConjClass α β} {x1 x2 : α} (mx1 mx2 : β), IsSconj x1 (mx1 x2) ↔ IsSconj x2 (mx2 x1) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalAddGroup G] {K : Set G}\n  {V : Set G} (hK : IsCompact K) (hV : Set.Nonempty (interior V)),\n  ∃ n, n ∈ Finset.card '' {t : Finset G | K ⊆ ⋃ g ∈ t, (fun (h : G) ↦ g + h) ⁻¹' V})", "theorem": "theorem MeasureTheory.Measure.haar.addIndex_defined :\n    (∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalAddGroup G] {K : Set G}\n      {V : Set G} (hK : IsCompact K) (hV : Set.Nonempty (interior V)),\n      ∃ n, n ∈ Finset.card '' {t : Finset G | K ⊆ ⋃ g ∈ t, (fun (h : G) ↦ g + h) ⁻¹' V}) :=\n  by sorry", "name": "MeasureTheory.Measure.haar.addIndex_defined", "lemma-type": "{G : Type u_1} →\n  [AddGroup G] →\n    [TopologicalSpace G] →\n      [TopologicalAddGroup G] →\n        {K : Set G} →\n          {V : Set G} →\n            (hK : IsCompact K) → (hV : Set.Nonempty (interior V)) → ∃ t, K ⊆ ⋃ g ∈ t, (fun (x : G) ↦ g + x) ⁻¹' V", "lemma": "theorem aux.14702887087125968198 {G : Type u_1} [AddGroup G] [TopologicalSpace G] [TopologicalAddGroup G] {K : Set G}\n    {V : Set G} (hK : IsCompact K) (hV : Set.Nonempty (interior V)) : ∃ t, K ⊆ ⋃ g ∈ t, (fun (x : G) ↦ g + x) ⁻¹' V :=\n  by sorry", "doc_string": "If `K` is compact and `V` has nonempty interior, then the index `(K : V)` is well-defined, there is\na finite set `t` satisfying the desired properties.", "generated": ["theorem sub_self : ∀ {G : Type u_3} [inst : Add Group G] (a : G), a - a = 0 := by sorry ", "theorem implies_comm : ∀ {p q : Prop}, (p → q) → q → p := by sorry ", "theorem iff_self : ∀ (p : Prop), (p ↔ p) = True := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem aux.8462967455027780551 {G : Type u_1} [AddGroup G] [TopologicalSpace G] [TopologicalAddGroup G] {K : Set G}\n    {V : Set G} (hK : IsCompact K) (hV : Set.Nonempty (interior V)) : intersect_preimage_lim :\n    ∀ {\\alpha : Type u} {β : Type v} [inst : MulAction α β] [inst_1 : TopologicalSpace α] (s s' : α),\n      s_mem_inter : (α => True) 8 → B = 8 :=\n  by sorry ", "theorem Finset.coeInjective : ∀ {α : Type u_1} [inst : LinearOrder α], Function.Injective fun s : Finset α ↦ ↑s := by\n  sorry ", "theorem Finset.imageᵒᵖ_injective :\n    ∀ {α : Type u_1} {β : Type u_2}, (∀ {p : α → β} {s : Finset.Fintype α}, Function.Injective ⇑(_₂.finsuppapply p s)) :=\n  by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry "]}
{"theorem-type": "(∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n  (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ),\n  sInf ((fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) '' Set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0 ..T, g x ≤\n    ∫ (x : ℝ) in 0 ..t, g x)", "theorem": "theorem Function.Periodic.sInf_add_zsmul_le_integral_of_pos :\n    (∀ {T : ℝ} {g : (a : ℝ) → ℝ} (hg : Function.Periodic g T)\n      (h_int : ∀ (t₁ : ℝ) (t₂ : ℝ), IntervalIntegrable g MeasureTheory.volume t₁ t₂) (hT : 0 < T) (t : ℝ),\n      sInf ((fun (t : ℝ) ↦ ∫ (x : ℝ) in 0 ..t, g x) '' Set.Icc 0 T) + ⌊t / T⌋ • ∫ (x : ℝ) in 0 ..T, g x ≤\n        ∫ (x : ℝ) in 0 ..t, g x) :=\n  by sorry", "name": "Function.Periodic.sInf_add_zsmul_le_integral_of_pos", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If `g : ℝ → ℝ` is periodic with period `T > 0`, then for any `t : ℝ`, the function\n`t ↦ ∫ x in 0..t, g x` is bounded below by `t ↦ X + ⌊t/T⌋ • Y` for appropriate constants `X` and\n`Y`. ", "generated": ["theorem ENNReal.toReal_sInf : (0 < +⊤) ∨ (ENNReal.toReal sInf T = 0) := by sorry ", "theorem funext : ∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g := by sorry ", "theorem IntervalIntegral.add_midpoint : ∀ {a b : ℝ} {f : ℝ → E} [inst : NormedAddCommGroup Е]\n    [inst_1 : MeasureTheory.MeasureSpace ℝ] [inst_2 : MeasureTheory.MeasureAxis AEStronglyMeasurable f],\n   b - a)⁻¹ •ℬ • Vol((-a..x).card c) += vol (Set.Icc -a x)) :=\n  by sorry ", "theorem LE.sInf_lt :\n    ∀ {α : Type u} [inst : ConditionallyCompleteLattice α] {s : Set α} {b : α}, s Infᶜ b = {a | b < a} '' s ∆ s := by\n  sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α × β → α × β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "statement of equation from\n```lean\ndef a : Fin (3 + 2) → ℝ\n``` [/INST] equation :\n  IsLittleO { { x : ℝ // 0 < x }, NNReal} {(x : ℝ) → ℂ, x ∈ Set.univ x} x { x_c : ℝ, x_c : x_c ∈ Set.univ x } →\n    f(1) = ⊥ :=\n  by sorry ", "theorem And.left : ∀ {a b : Prop}, a ∧ b → a := by sorry ", "theorem IntervalIntegrable.integral_pos :\n    ∀ {l : Filter ℝ} {I : BoxIntegral.Box ι} {f : ι → ℝᵃˡ} {π : BoxIntegral.Prepartition I}\n      [I_fin_dim : BoxIntegral.FinDim I]\n      [hp : Fact (0 ≤ nin (⇑π ∘ ⇑f))], MeasureTheory.Integrable On f → MeasureTheory.MeasurableOn f I.indicator I → Isopen Set.univ ∧ (BoxIntegral.Prepartition.mem π I → f j * ↑↑I jᶰᵢ ≠ 0) → IntervalIntegrable I f (n Δf p) l :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ],\n  MeasureTheory.Measure.InnerRegularWRT μ (fun (s : Set α) ↦ (MeasurableSet s) ∧ (↑↑μ s ≠ ⊤)) fun (s : Set α) ↦\n    MeasurableSet s)", "theorem": "theorem MeasureTheory.Measure.InnerRegularWRT.of_sigmaFinite :\n    (∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} [inst_1 : MeasureTheory.SigmaFinite μ],\n      MeasureTheory.Measure.InnerRegularWRT μ (fun (s : Set α) ↦ (MeasurableSet s) ∧ (↑↑μ s ≠ ⊤)) fun (s : Set α) ↦\n        MeasurableSet s) :=\n  by sorry", "name": "MeasureTheory.Measure.InnerRegularWRT.of_sigmaFinite", "lemma-type": "{α : Type u_1} →\n  [MeasurableSpace α] →\n    {μ : MeasureTheory.Measure α} →\n      [MeasureTheory.SigmaFinite μ] →\n        (s : Set α) →\n          (hs : MeasurableSet s) →\n            (r : ENNReal) →\n              (hr : r < ↑↑μ s) →\n                let B : (a : ℕ) → Set α := MeasureTheory.spanningSets μ;\n                (s ∩ Set.univ = s) = (s = s)", "lemma": "theorem aux.17381788126014175103 {α : Type u_1} [MeasurableSpace α] {μ : MeasureTheory.Measure α}\n    [MeasureTheory.SigmaFinite μ] (s : Set α) (hs : MeasurableSet s) (r : ENNReal) (hr : r < ↑↑μ s) :\n    let B : (a : ℕ) → Set α := MeasureTheory.spanningSets μ;\n    (s ∩ Set.univ = s) = (s = s) :=\n  by sorry", "doc_string": "Given a σ-finite measure, any measurable set can be approximated from inside by a measurable\nset of finite measure. ", "generated": ["theorem aux.1922533784946017629 {α : Type u_1} [MeasureTheory.MeasureSpace α]\n    (μ : MeasureTheory.Measure α) [MeasureTheory.SigmaFinite μ] {r : ENNReal} : Topology.hasBasis AlternatingDirection.mk ↑μ = ContinuousOrderedGTopology.IsROrCCompacts.inducedOr topology :\n  TopologicalSpace.t0SpaceAlternatingBasis ((fun Set => TopologicalSpace.SecondCountableTopology.intermediateTopology E⁰S) μr)\n      (Topology.toContinuous (⨆ ν : TopologicalSpace.SecondCountableTopology.CBasis R → Set E⁰, ν)) :\n  TopologicalSpace.AscendingBasis.mk ↑((ContinuousOrderedGTopology.isTopologicalBasis fun a => top) fun l =>\n    ↑↑({ u := ((⋃₀ ((fun (k : TopologicalSpace.SecondCountableTopology R) ↦\n            TopologicalSpace.SecondCountableTopology.instCRef A) s)) ↑K)).val\n              l) ↦\n        ↑{ val := ((Set.inductiveUpperBottom (TopologicalSpace.TopologicalAddGroupSeries.topologist k κ))))\n          property := (((TopologicalSpace.instinstCountable)); hc) }) :=\n  by sorry ", "theorem SetInter.inter_empty : ∀ {α : Type u} (a : α), a ∋ ∅ = ∅ := by sorry ", "theorem MeasureTheory.Measure.subsingular_innerRegular_top :\n    ∀ {α : Type u_1} [inst : TopologicalSpace α] (τ : (a : Icc (↑↑μ Set.univ) ≤ s₂) → (t : MeasureTheory.Measure α) → Prop),\n      (Fintype.card (Q ↑μ) × Icc (↑↑μ Set.univ) «↑» μ = ⊤) → (∃ q r f n, τ (Set.compl n, f r) (Set.range q)) →\n        ∃ μ_1,\n          ↑↑μ Set.univ < ↑↑μ Set.univ → 𝔖ᶜ r → PropersSub.Measure.exists i t (Icc (↑↑μ t) ≤ sₒ) ∈ r n :=\n  by sorry ", "theorem MeasureTheory.Measure.InnerRegularWRT.diff_to_forall_induction :\n    ∀ {N : Type u_1} {x : Set (MeasureTheory.OuterMeasure M)} (s : Set α),\n      measurableSet s →\n        ∀ {P : Set (MeasureTheory.OuterMeasure (M → MeasureTheory.OMulActionMemClass M Mₗ)}}\n          (n' : _a ↑s), (∀ r < ↑n', ∀ m ∈ m' ∪ P, (m eᶜ ∈ t x e ↑‖ r) → e a).ToSum (e n' d_nonneg),\n          P x\n        + d = ((↑n ⊓ r).ne_top → (Finset.sigma (m' \\ x)^2 _fun (x : c i j) × i + d0 := d' \\ a + d),\n            x → e a = ed),\n        ↑‖s n ∑ (i : X) (inj h : x = t _ i i) (j : (α = M ι₀ ⊛ t i, in h)).m - p i := 0| a = e :=\n  by sorry ", "theorem Iff.of_true : ∀ {p q : Prop}, p → (p ↔ q) := by sorry ", "theorem Ne.lt_or_lt : ∀ {α : Type u_1} [inst : LinearOrder α] {x y : α}, x ≠ y → x < y ∨ y < x := by sorry ", "theorem aux.5404261971146479310 {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α}\n    [inst_1 : MeasureTheory.SigmaFinite μ] (s : Set α) :\n    MeasurableSet ↑(MeasureTheory.decomposedSeq μ ↑s) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} [inst : PartialOrder α] [inst_1 : LocallyFiniteOrder α] {x : α} {y : α},\n  (x ≤ y) ↔ (Relation.ReflTransGen (fun (x : α) (x_1 : α) ↦ x ⋖ x_1) x y))", "theorem": "theorem le_iff_reflTransGen_covBy :\n    (∀ {α : Type u_2} [inst : PartialOrder α] [inst_1 : LocallyFiniteOrder α] {x : α} {y : α},\n      (x ≤ y) ↔ (Relation.ReflTransGen (fun (x : α) (x_1 : α) ↦ x ⋖ x_1) x y)) :=\n  by sorry", "name": "le_iff_reflTransGen_covBy", "lemma-type": "{α : Type u_2} →\n  [PartialOrder α] →\n    [LocallyFiniteOrder α] →\n      {x : α} →\n        {y : α} →\n          (Relation.TransGen (fun (x : α) (x_1 : α) ↦ x ⩿ x_1) x y) ↔\n            (Relation.ReflTransGen (fun (x : α) (x_1 : α) ↦ x ⋖ x_1) x y)", "lemma": "theorem aux.11931187984742088745 {α : Type u_2} [PartialOrder α] [LocallyFiniteOrder α] {x : α} {y : α} :\n    (Relation.TransGen (fun (x : α) (x_1 : α) ↦ x ⩿ x_1) x y) ↔\n      (Relation.ReflTransGen (fun (x : α) (x_1 : α) ↦ x ⋖ x_1) x y) :=\n  by sorry", "doc_string": "In a locally finite partial order, `≤` is the reflexive transitive closure of `⋖`. ", "generated": ["theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem le_reflTransGen :\n    ∀ {α : Type u_1} [o : LE α], (∀ a ∂b, o a ↔ ReflTransGen Relation.Iff R a b) → (a y b → a ⟶ y ⟶* b) = a ↔ a := by\n  sorry ", "theorem transCovBy_z powder : ℕ := by sorry ", "theorem not_le_of_lt : ∀ {α : Type u} [inst : Preorder α] {a b : α}, a < b → ¬a ≤ b := by sorry ", "theorem aux.9320772469318346368 {α : Type u_2} [PartialOrder α] [LocallyFiniteOrder α] {x : α} {y : α} (m : ↥(Finset.Ico x r₁))\n    (x_1 : γ) : x_1 ^ Nat.rawCast 1 * Nat.rawCast 1 = x_1 ^ Nat.rawCast 1 := by sorry ", "theorem Relation.CovBy.eq_minimalMonoClosure_inf :\n    ∀ {α : Type u_2} {ζ : α → α → Type u_3} [r : α ↪r _ᵉ] [self : Relation.IsSymm ζ] ⦃a : α⦄\n      ⦃b : α⦄, @Relation.CovBy _ _ ζ (_ : ζ a b) = Set.minimalMonoClosure ζ ↑(Relation.MinimalGenMonoClosure ζ) (_ : b ∈ _) :=\n  by sorry ", "theorem reflTransGen_rel_principal : (r ⊓ w = r) = (r ⊑ r) := by sorry ", "theorem aux.9112254576388377562 {α : Type u_2} [PartialOrder α] [LocallyFiniteOrder α] {x : α} {y : α} :\n    ∀ (hz : Covers Relation.LFA εy x), Covers CovBy (Prod.LFA εx) (_root_.LFA : LE.covBy _root_.LFA y y) := by\n  sorry "]}
{"theorem-type": "(∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n  ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n    ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n))))", "theorem": "theorem Quaternion.expSeries_even_of_imaginary :\n    (∀ {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ),\n      ((NormedSpace.expSeries ℝ (Quaternion ℝ) (2 * n)) fun (x : Fin (2 * n)) ↦ q) =\n        ↑((-1) ^ n * ‖q‖ ^ (2 * n) / ↑(Nat.factorial (2 * n)))) :=\n  by sorry", "name": "Quaternion.expSeries_even_of_imaginary", "lemma-type": "{q : Quaternion ℝ} → (hq : Quaternion.re q = 0) → (n : ℕ) → n ^ Nat.rawCast 1 = n", "lemma": "theorem aux.4167381902401088466 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) : n ^ Nat.rawCast 1 = n := by\n  sorry", "doc_string": "The even terms of `expSeries` are real, and correspond to the series for $\\cos ‖q‖$. ", "generated": ["theorem Nat.cast_inl : ∀ (n : ℕ), ↑(Fin.castSucc n) = n := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.2029732906472826023 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ) : Nat.sq : Nat.square 0 = 0 := by\n  sorry ", "theorem map_sub_left_injective :\n    ∀ {R₀ : Type u_2} {R : Type u_3} {S : Type v} (f₀ : R₀ →ₙ+ starRingHom R ↪o R) {α : Type u_6} {f : α →ᵃ+⁅⋆⁆ ℂ}\n      _hf.injective, (f ∈ normClass ℝ (starRingEnd ℂ) S) → Function.Injective fun s ↦ f = f ∘ₗ starTrivialEquiv R₀ S 4 s :=\n  by sorry ", "theorem aux.12538108158677766658 {q : Quaternion ℝ} (hq : Quaternion.re q = 0) (n : ℕ)\n    (h : 2 * n = Nat.zero) : Zero.zero = ↑0 := by sorry ", "theorem real.sqrt_pos : ∀ {a : ℝ}, 0 < real.sqrt a ↔ 0 < a := by sorry ", "theorem Real.rpow_nat_mul '' false := by sorry "]}
{"theorem-type": "(∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] [inst_1 : DecidableEq α] (s : Finset α) {f : (a : α) → β} {a : α}\n  (h : f a = 0), (Finset.sum (Finset.erase s a) fun (x : α) ↦ f x) = Finset.sum s fun (x : α) ↦ f x)", "theorem": "theorem Finset.sum_erase :\n    (∀ {β : Type u} {α : Type v} [inst : AddCommMonoid β] [inst_1 : DecidableEq α] (s : Finset α) {f : (a : α) → β}\n      {a : α} (h : f a = 0), (Finset.sum (Finset.erase s a) fun (x : α) ↦ f x) = Finset.sum s fun (x : α) ↦ f x) :=\n  by sorry", "name": "Finset.sum_erase", "lemma-type": "{β : Type u} →\n  {α : Type v} →\n    [AddCommMonoid β] →\n      [DecidableEq α] →\n        (s : Finset α) →\n          {f : (a : α) → β} →\n            {a : α} → (h : f a = 0) → (x : α) → (hx : x ∈ s) → (hnx : x ∉ s \\ {a}) → (f x = 0) = (f a = 0)", "lemma": "theorem aux.5329622862557479947 {β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (s : Finset α)\n    {f : (a : α) → β} {a : α} (h : f a = 0) (x : α) (hx : x ∈ s) (hnx : x ∉ s \\ {a}) : (f x = 0) = (f a = 0) := by sorry", "doc_string": "If a function applied at a point is 0, a sum is unchanged by\nremoving that point, if present, from a `Finset`.", "generated": ["theorem eq_false : ∀ {p : Prop}, ¬p → p = False := by sorry ", "theorem aux.7252649727845974499 {β : Type u} {α : Type v} [ AddCommMonoid β] [DecidableEq α] (s : Finset α)\n    {f : (a : α) → β} {a : α} (h : f a = 0) (a_1 : α) :\n    (¬((Either.inr a_1) = (), { val := ((a)), property := ((h)) })) = (¬(¬(s.Property a_1))) := by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p → True := by sorry ", "theorem aux.10245791773427503188 {β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (s : Finset α)\n    {f : (a : α) → β} {a : α} (h : f a = 0) : (Finsupp.sum (Finset.erase s a).natEmbed 0 = 0) ↔ True := by sorry ", "theorem aux.623200897186243546 {β : Type u} {α : Type v} [AddCommMonoid β] [DecidableEq α] (s : Finset α)\n    {f : (a : α) → β} {a : α} (h : f a = 0) :\n    ((Finset.sum (insert a (Finset.erase s a)).toSet fun (x : α) ↦ f x) = Finset.sum s fun (x : α) ↦ f x) =\n      ((Finset.sum Finset.univ name :=\n          by sorry ) =\n        Finset.sum s fun (b : alpha) ↦ b) :=\n  by sorry ", "theorem if_neg : ∀ {c : Prop} {h : c = false}, ¬c → ¬(c = c) := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ} [inst_3 : StrictConvexSpace ℝ E]\n  (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n  (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C))", "theorem": "theorem ae_eq_const_or_norm_average_lt_of_norm_le_const :\n    (∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n      [inst_2 : CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n      [inst_3 : StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C),\n      (f =ᶠ[MeasureTheory.Measure.ae μ] Function.const α (⨍ (x : α), f x ∂μ)) ∨ (‖⨍ (x : α), f x ∂μ‖ < C)) :=\n  by sorry", "name": "ae_eq_const_or_norm_average_lt_of_norm_le_const", "lemma-type": "{α : Type u_1} →\n  {E : Type u_2} →\n    {m0 : MeasurableSpace α} →\n      [NormedAddCommGroup E] →\n        [inst_1 : NormedSpace ℝ E] →\n          [CompleteSpace E] →\n            {μ : MeasureTheory.Measure α} →\n              {f : (a : α) → E} →\n                {C : ℝ} →\n                  [StrictConvexSpace ℝ E] →\n                    (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) →\n                      (hC0 : 0 < C) →\n                        (hμt : ↑↑μ Set.univ < ⊤) →\n                          (⨍ (x : α), f x ∂μ ∈ interior (Metric.closedBall 0 C)) = (⨍ (x : α), f x ∂μ ∈ Metric.ball 0 C)", "lemma": "theorem aux.10821768260218343036 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [inst_1 : NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C) (hC0 : 0 < C) (hμt : ↑↑μ Set.univ < ⊤) :\n    (⨍ (x : α), f x ∂μ ∈ interior (Metric.closedBall 0 C)) = (⨍ (x : α), f x ∂μ ∈ Metric.ball 0 C) := by sorry", "doc_string": "If `E` is a strictly convex normed space and `f : α → E` is a function such that `‖f x‖ ≤ C`\na.e., then either this function is a.e. equal to its average value, or the norm of its average value\nis strictly less than `C`. ", "generated": ["theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry ", "theorem ENNReal.ge_iff_le := by sorry ", "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry ", "theorem not_le : ∀ {α : Type u_1} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a := by sorry ", "theorem MeasureTheory.SimpleFunc.eq_const_average'' :\n    ∀ {α : Type u_1} {E : Type u_2} (mᵒᵖ : MeasureTheory.Measure.PosUnit μ) (x : α) (f : MeasureTheory.SimpleFunc α E),\n      (MeasureTheory.Graph.mk ⟨f, MeasureTheory.SimpleFunc.compl f x.unpair.2⟩\n            x).val =ᶠ[measureTheory.Measure.inst α]\n        ⊥ ⨆ i, MeasureTheory.SimplexFinite 0 ((Equiv.subsetCompl f i).symm.insp i) :=\n  by sorry ", "theorem norm_average_le_norm_average :\n    ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {F : Type u_5} [inst : SemINNClass ℝ F]\n      [inst_2 : NormedAddCommGroup F] [inst_3 : MeasureTheory.IsFiniteMeasureOnCompacts μ] {f g : α → F},\n      f =ᶠ[MeasureTheory.Measure.ae μ] g → (‖f‖ ≤ ‖g‖ ↔ ‖⨍ (x : α), f x ∂μ = ⨍ (x : α), g ∂μ) :=\n  by sorry ", "note:\nnonrec _a_1 : LT Aᵒᵈ :=\n  ((Continuous.map_LT' -Lᗮ fun x ↦ x): (ConvexMapUnit ⵖ ContinuousMap.add ⇑-Lᗮ) = nhds 0 := by\n  sorry ", "theorem aux.6274461061923884490 {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [NormedAddCommGroup E]\n    [NormedSpace ℝ E] [CompleteSpace E] {μ : MeasureTheory.Measure α} {f : (a : α) → E} {C : ℝ}\n    [StrictConvexSpace ℝ E] (h_le : ∀ᵐ (x : α) ∂μ, ‖f x‖ ≤ C)\n    (h_eq_lt : ((↑↑μ Set.univ < ⊤) ∧ (∫ (x : α), ‖f x‖ ∂μ < C)) ∨ (0 < μ {x : α | f x ≠ 0})) :\n    (|⇑⟨fivers : NNReal]| < C / ↑↑μ Set.univ × ⊤) ↔ ((↑↑μ Set.univ < ⊤) ∧ (|‖fivers‖| < C / ⊤)) := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedAddCommGroup F] {f : (a : α) → E} {g : (a : α) → F} {μ : MeasureTheory.Measure α}\n  (hfm : MeasureTheory.AEStronglyMeasurable f μ) (hf : f =O[⊤] g) (hg : MeasureTheory.Integrable g),\n  MeasureTheory.Integrable f)", "theorem": "theorem Asymptotics.IsBigO.integrable :\n    (∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E]\n      [inst_2 : NormedAddCommGroup F] {f : (a : α) → E} {g : (a : α) → F} {μ : MeasureTheory.Measure α}\n      (hfm : MeasureTheory.AEStronglyMeasurable f μ) (hf : f =O[⊤] g) (hg : MeasureTheory.Integrable g),\n      MeasureTheory.Integrable f) :=\n  by sorry", "name": "Asymptotics.IsBigO.integrable", "lemma-type": "{α : Type u_1} →\n  {E : Type u_2} →\n    {F : Type u_3} →\n      [MeasurableSpace α] →\n        [NormedAddCommGroup E] →\n          [NormedAddCommGroup F] →\n            {f : (a : α) → E} →\n              {g : (a : α) → F} →\n                {μ : MeasureTheory.Measure α} →\n                  (hfm : MeasureTheory.AEStronglyMeasurable f μ) →\n                    (hf : f =O[⊤] g) →\n                      (hg : MeasureTheory.Integrable g) →\n                        (MeasureTheory.IntegrableAtFilter f ⊤) ↔ (MeasureTheory.Integrable f)", "lemma": "theorem aux.13840693057485505606 {α : Type u_1} {E : Type u_2} {F : Type u_3} [MeasurableSpace α] [NormedAddCommGroup E]\n    [NormedAddCommGroup F] {f : (a : α) → E} {g : (a : α) → F} {μ : MeasureTheory.Measure α}\n    (hfm : MeasureTheory.AEStronglyMeasurable f μ) (hf : f =O[⊤] g) (hg : MeasureTheory.Integrable g) :\n    (MeasureTheory.IntegrableAtFilter f ⊤) ↔ (MeasureTheory.Integrable f) := by sorry", "doc_string": "Variant of `MeasureTheory.Integrable.mono` taking `f =O[⊤] (g)` instead of `‖f(x)‖ ≤ ‖g(x)‖` ", "generated": ["theorem congrArg : ∀ {α β γ : OutParamOutParamTactic α} {x y z : α}, x = y → α = β → (z = y → α = z) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.18320435117579081649 {α : Type u_1} {E : Type u_2} {F : Type u_3} [MeasurableSpace α]\n    [NormedAddCommGroup E] [NormedAddCommGroup F] {f : (a : α) → E} {g : (a : α) → F} {μ : MeasureTheory.Measure α}\n    (hfm : MeasureTheory.AEStronglyMeasurable f μ) (hf : f =O[⋃ (a : α), {a}ᶜ] g) (hg : MeasureTheory.Integrable g) :\n    f * Function.const α 1 =ᶠ[MeasureTheory.Measure.ae μ] FUNEq.proof_1 := by sorry ", "theorem aux.13266648305245015878 {α : Type u_1} {E : Type u_2} {F : Type u_3} [NormedAddCommGroup E]\n    [NormedSpace ℝ F] [PartialOrder E] {μ : MeasureTheory.Measure α} (hlp : Bornology.IsLubble F) (h₀ : E =BL ⊤) :\n    0 = ⨉ i, ‖(1, i) i‖ • ‖y‖ := by sorry ", "theorem norm_mul_le : ∀{x : 𝕜} (y : 𝕜), ‖x‖ * ‖y‖ < infty_bot ↔ x < y := by sorry ", "theorem eventually_isLM :\n    ∀ {μ : SeminormedMeasure α} (ℇ : TopologicalSpace α)\n      (K : IsLoorSpace ℇ) (f : Å →+ₙᵃ[ENNReal μ] Å),\n      ∃ R, (Filter.map (IsLoor.loer ℱ) Filter.atTop) ≥ nhds f → ∀ᶠ nᵣ in Filter.atTop, IsOddOrder.toLor K (r R nᵣ.r) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry "]}
{"theorem-type": "(∀ {c : (n : ℕ) × Composition n} {c' : (n : ℕ) × Composition n},\n  (c = c') ↔ (Composition.blocks (Sigma.snd c) = Composition.blocks (Sigma.snd c')))", "theorem": "theorem Composition.sigma_eq_iff_blocks_eq :\n    (∀ {c : (n : ℕ) × Composition n} {c' : (n : ℕ) × Composition n},\n      (c = c') ↔ (Composition.blocks (Sigma.snd c) = Composition.blocks (Sigma.snd c'))) :=\n  by sorry", "name": "Composition.sigma_eq_iff_blocks_eq", "lemma-type": "{c : (n : ℕ) × Composition n} →\n  {c' : (n : ℕ) × Composition n} →\n    (H : Composition.blocks (Sigma.snd c) = Composition.blocks (Sigma.snd c')) →\n      (n : ℕ) →\n        (c : Composition n) →\n          (H : Composition.blocks (Sigma.snd { fst := ((n)), snd := ((c)) }) = Composition.blocks (Sigma.snd c')) →\n            (n' : ℕ) →\n              (c' : Composition n') →\n                (H :\n                    Composition.blocks (Sigma.snd { fst := ((n)), snd := ((c)) }) =\n                      Composition.blocks (Sigma.snd { fst := ((n')), snd := ((c')) })) →\n                  (List.sum (Composition.blocks c) = n') =\n                    (List.sum (Composition.blocks c) = List.sum (Composition.blocks c'))", "lemma": "theorem aux.4327335349883096530 {c : (n : ℕ) × Composition n} {c' : (n : ℕ) × Composition n}\n    (H : Composition.blocks (Sigma.snd c) = Composition.blocks (Sigma.snd c')) (n : ℕ) (c : Composition n)\n    (H : Composition.blocks (Sigma.snd { fst := ((n)), snd := ((c)) }) = Composition.blocks (Sigma.snd c')) (n' : ℕ)\n    (c' : Composition n')\n    (H :\n      Composition.blocks (Sigma.snd { fst := ((n)), snd := ((c)) }) =\n        Composition.blocks (Sigma.snd { fst := ((n')), snd := ((c')) })) :\n    (List.sum (Composition.blocks c) = n') = (List.sum (Composition.blocks c) = List.sum (Composition.blocks c')) := by\n  sorry", "doc_string": "Two compositions (possibly of different integers) coincide if and only if they have the\nsame sequence of blocks. ", "generated": ["theorem Finset.sup_eq :\n    ∀ {α : Type u_2} {β : Type u_4} {s :Finset α} (f : ∀ a, β) {a : φ a}, Finset.sup s (f ∘ ⇑a) = finset_sup (f ∘ a) s :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "statement.sublist_apply :\n  ∀ {α : Type u} {β : Type v} {ι : Sort u_3} (l₁ : List α) (l₂ : List η), ListSubtype.introVal = List.sublist l₂ :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem ite_congr_right :\n    ∀ {G₀ : Type u_3} {p : (G₀ → NNReal) → Prop}\n      (h :\n        (PFun.natPredDefaultsGCF p) = fun x => (x ≫ filterPodDilationNNeZero x) ((PFun.fst.cfunc ℤ x₀ x).toPrimeCompl) :=\n      by sorry › rzden ≠ rzeta :=\n      by sorry ›\n    self_prop;\n  sorry › rzden ≠ rzeta :=\n  by sorry › rzden ≠ rzeta :=\n  by sorry ", "theorem eq_of_heq : ∀ {α : Sort u} {a a' : α}, HEq a a' → a = a' := by sorry ", "theorem congr_fun : ∀ {α : Sort u} {β : α → Sort v} {x y : (a : α) → β a}, x = y → ∀ (a : α), x a = y a := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β],\n  Inducing (⇑UniformFun.ofFun ∘ DFunLike.coe))", "theorem": "theorem BoundedContinuousFunction.inducing_coeFn :\n    (∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β],\n      Inducing (⇑UniformFun.ofFun ∘ DFunLike.coe)) :=\n  by sorry", "name": "BoundedContinuousFunction.inducing_coeFn", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "The topology on `α →ᵇ β` is exactly the topology induced by the natural map to `α →ᵤ β`. ", "generated": ["theorem BoundedContinuousFunction.dzero_imageI :\n    ∀ {α : Type u1} {γ : Type u2} [inst : TopologicalSpace α] [self : UniformSpace ↑β β] {f : BoundedContinuousFunction α β}\n      {g : α ≃ α}, nhds (f ∘ g);function.const α (f default)) :=\n  by sorry ", "theorem ContinuousOnIcc.compDFun :\n    ∀ {α : Type u_1} {β : Type u_2} (t : TopologicalSpace α) {𝔷 : TopologicalSpace α → BoldFace δ}\n      [inst : FunLike α 𝔷 β], UMulOneClass.ComplNonPrime (f 𝔭) → StrictMonoidalCat.StrongSubsingletonClass f 𝔻 :=\n  by sorry ", "theorem bounded_of_subsingleton ℝ: ∀ {s : π → ℝ}, Set.Subsingleton ∅↔ s ⊆ ∀ (γ : π), LowerLimitFront γ ⟨0, by\n  simp\n⟩ —> ∀ (π : (a : α) → π), Set.Finite {\\a}_{a : (a : α) → π a | FinLowerBoundsFun.limDForget fun a => γ} :=\n  by sorry ", "theorem UniformOnFun.uniformCongr : ∀ {α : Type u_1} {β : Type u_2} {ε₁ : Type u_3} {ε₂ : Type u_4}\n    [inst : UniformSpace β] (s : Set α) (h₁ : ε₁ ⊆ ε₂) (f : UniformOnFun α β ε₁) (g : UniformOnFun α β ε₂)\n    (φ : ε₂ → ε₁), UniformCongr (φ ∘ ⇑(f.restrict₁ (Set.rfl f (id f))))\n      (φ ∘ ⇑(g.restrict₁ (Set.rfl f (id g)))) f :=\n  by sorry ", "theorem toCompTopClosedMap_continuous :\n    ∀ {α : Type uα} {β : Type uβ} [inst : TopologicalSpace ↑⨅ s d, ChartedSpace H s] [inst_1 : CompleteSpace β],\n      Continuous UniformFun.toCompTopClosedMap :=\n  by sorry ", "theorem aux.29599382490958633 {α : Type u} {β : Type v} [TopologicalSpace α] [PseudoMetricSpace β] (g : β) : UniformContinuous BoundedContinuousFunction.clip := by\n  sorry ", "theorem DFunLike.restr_comp' :\n    ∀ {W : Sort u_5} {X : topologicalSpace X} {α : Type α} [i : topologicalSpace α] ⦃x : (a : X) → α⦄, (j₁ : x ∈ U) →\n(j₂ : j₁ = True) (j₃ : j₁ = False), HCoe.mk V (p.toPartEmb X) = DFunLike.f x :=\n  by sorry ", "theorem DistribLMulSeminormClass.cauchy_map_of_dense_v :\n    ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [I : UniformSpace α] {L : β →*α→* γ}\n      {g : β →{u} γ} [L.DistribMulAction : DistribLMulSeminormClass α β γ] [I₁ : UniformSpace γ],\n      g =ₘᵥ L ↑unif ×ˢ fun o => Filter.unifIntegrable ⟨l ↑unif, isClosed := f⟩ o → CauchyMap g I_1 :=\n  by sorry "]}
{"theorem-type": "(∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]\n  {F : CategoryTheory.Functor J C} {X : C}\n  (h :\n    CategoryTheory.Functor.comp ((CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda).obj X)\n        CategoryTheory.uliftFunctor.{u₁, v₃} ≅\n      CategoryTheory.Functor.cones F)\n  (s : CategoryTheory.Limits.Cone F),\n  CategoryTheory.Limits.Cone.extend (CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h)\n      (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s) =\n    s)", "theorem": "theorem CategoryTheory.Limits.IsLimit.OfNatIso.cone_fac :\n    (∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃}\n      [inst_1 : CategoryTheory.Category.{v₃, u₃} C] {F : CategoryTheory.Functor J C} {X : C}\n      (h :\n        CategoryTheory.Functor.comp ((CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda).obj X)\n            CategoryTheory.uliftFunctor.{u₁, v₃} ≅\n          CategoryTheory.Functor.cones F)\n      (s : CategoryTheory.Limits.Cone F),\n      CategoryTheory.Limits.Cone.extend (CategoryTheory.Limits.IsLimit.OfNatIso.limitCone h)\n          (CategoryTheory.Limits.IsLimit.OfNatIso.homOfCone h s) =\n        s) :=\n  by sorry", "name": "CategoryTheory.Limits.IsLimit.OfNatIso.cone_fac", "lemma-type": "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂", "lemma": "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry", "doc_string": "If `F.cones` is represented by `X`, any cone is the extension of the limit cone by the\ncorresponding morphism. ", "generated": ["theorem CategoryTheory.cone_whisker_ext :\n    ∀ {J : Type u₁} [inst : CategoryTheory.category J] {K : Type u₂} [inst_1 : CategoryTheory.category K]\n      {F : CategoryTheory.Functor J K} {C : CategoryTheory.Cone F} {X Y : CoyonedaConvertsTo C C′}\n      (α : ↑X ⟶ ↑Y),\n      θ((CategoryTheory.Functor.toPrefunctor ((CategoryTheory.conesEquiv (CategoryTheory.Functor.op F)) X)).obj) =\n        CategoryTheory.CategoryStruct.comp α\n          (θ | CategoryTheory.Cocone.ι Y) :=\n  by sorry ", "theorem equals_self : ∀ (α : Sort u_1) (a : α), a = a := by sorry ", "theorem ConcreteCategory.limDef_mapNatTransSelfLift :\n    ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] (F : CategoryTheory.Functor J (Type u₄)) (X : C),\n      Hom.id (F.toPrefunctor.obj X) = (CategoryTheory.limits.Limit.lift.load F id_hom_con), _\n      -> ∀ ((s : CategoryTheory.Limits.Constraint J) (t₁ : CategoryTheory.Limits.LimitCone F)\n          (t₂ : CategoryTheory.Limits.LimitCone ((CategoryTheory.Functor.toPrefunctor F).obj X)),\n          (s.validate\n              (CategoryTheory.Limits.LimitCone.isLimit\n                (s ⟶ t₁) (fun _ => s.j₁ fun x => id ((CategoryTheory.Functor.toPrefunctor F).obj x)))\n              (fun _ => s ⟶ t₂) r → CategoryTheory.Limits.LimitCone.lift t₂ (_id r))) ==\n        t₁.f →\n          CategoryTheory.IsIso ((CategoryTheorySubsingleton.proof v u r).src 1) :=\n  by sorry ", "theorem aux.13011654973085593774 {J : Type u₁} [CategoryTheory.Category.{u₁, w₁} J] {C : Type u₃}\n    [CategoryTheory.Category.{u₃, w₃} C] {F : CategoryTheory.Functor J C} {X : C}\n    (a :\n      CategoryTheory.Functor.comp ((CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda).obj X)\n          CategoryTheory.uliftFunctor.{u₁, v₃} ≅\n        CategoryTheory.Functor.cones F)\n    (s : CategoryTheory.Limits.Cone F) (j : J) (x : (CategoryTheory.Functor.toPrefunctor F).obj j) (a : Nontrivial J)\n    (J_1 : C)\n    (f :\n      (CategoryTheory.Functor.toPrefunctor F).obj (CategoryTheory.Limits.yonedaJ_NonemptyIndex J) ⟶ J_1) :\n    f (fun (j : J) ↦ CategoryTheory.Equiv.eq (CategoryTheory.NatTrans.simp (g)) j j) J_1 =\n      f J ⟶ J_1 :=\n  by sorry ", "theorem CongrArg id (CategoryTheory.congr (CategoryTheory.Limits.IsColimit.ToPrefunctor.congr_hom\n    (CategoryTheory.Functor.colimitMapping ((CategoryTheory.Functor.toPrefunctor (CategoryTheory.yoneda' X)).map h))\n    s)))) :\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.IsColimit.OfNatIso.limitCone_ext y\n        (CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda).map h s)\n        ((CategoryTheory.Functor.toPrefunctor (CategoryTheory.yoneda X)).map\n          CategoryTheory.Limits.Cone.π s) =\n      s :=\n  by sorry ", "theorem aux.7258095562161398659 {J : Type u₁} [CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃}\n    [CategoryTheory.Category.{v₃, u₃} C] {F : CategoryTheory.Functor J C} {X : C}\n    (h :\n      CategoryTheory.Functor.comp ((CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda).obj X)\n        CategoryTheory.uliftFunctor.{u₁, v₃} ≅\n        CategoryTheory.Functor.cones F) {s : CategoryTheory.Limits.Cone F} {t : CategoryTheory.Limits.Cone F}\n    (J : J) {W : C} (kW : t.pt ⟶ W) :\n    W ⟶ CategoryTheory.Limits.LimitCone.cone ((CategoryTheory.Functor.toPrefunctor CategoryTheory.yoneda).obj X) := by\n  sorry ", "theorem CategoryTheory.cocone_iso_obj_iso_of_hom_iso :\n    ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {K : Type u₂} [inst_1 : CategoryTheory.ChainComplex K]\n      {c : CategoryTheory.Cocone J K} (i : J ⟶ Pretrivialization Kᵒᵖ),\n      CategoryTheory.IsIso.f i.val i.property :=\n  by sorry ", "theorem congrArg : ∀ {α = a} {β = b} {a₁ : α} {a₂ : β} {a₃ : β} (f : a₁ = a₂) (g : a₂ = a₃), a₁ = a₂ → a₁ = a₃ := by\n  sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PartialOrder α] {a : α} {b : α}, ({ ofColex := (({a})) } ≤ { ofColex := (({b})) }) ↔ (a ≤ b))", "theorem": "theorem Finset.Colex.singleton_le_singleton :\n    (∀ {α : Type u_1} [inst : PartialOrder α] {a : α} {b : α},\n      ({ ofColex := (({a})) } ≤ { ofColex := (({b})) }) ↔ (a ≤ b)) :=\n  by sorry", "name": "Finset.Colex.singleton_le_singleton", "lemma-type": "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)", "lemma": "theorem implies_congr : ∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂) := by sorry", "doc_string": "Colex is an extension of the base order. ", "generated": ["theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a b : α}, f₁ = f₂ → a = b → f₁ a = f₂ b := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : Is Transitive  r] {a b c : α}, r a b → r b c → r a c := by\n  sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem eq_true : ∀ {p : Prop}, p → p = True := by sorry ", "theorem Order.lt_succ_iff : ∀ {α : Type u} [inst : Preorder α] [inst_1 : SuccOrder α] {a : α}, a < Order.succ a ↔ ¬a ⊔ a → successorOrderTop (a) = Order.succ a := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem aux.50075652241486622 {α : Type u_1} [PartialOrder α] {a : α} {b : α} :\n    And (α := Type u_1) = AndFalse := by sorse\n``` [/INST] theorem implies_congr : ∀ {a b c : Prop}, (a → b ↔ c) → (a → b)↔ c := by sorry "]}
{"theorem-type": "(∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α),\n  c =\n    ClosureOperator.ofPred (⇑c) (ClosureOperator.IsClosed c) (ClosureOperator.le_closure c)\n      (ClosureOperator.isClosed_closure c)\n      (fun (x : α) ↦ (_ : ∀ (y : α) (hxy : x ≤ y) (hy : ClosureOperator.IsClosed c y), c x ≤ y)))", "theorem": "theorem ClosureOperator.eq_ofPred_closed :\n    (∀ {α : Type u_1} [inst : PartialOrder α] (c : ClosureOperator α),\n      c =\n        ClosureOperator.ofPred (⇑c) (ClosureOperator.IsClosed c) (ClosureOperator.le_closure c)\n          (ClosureOperator.isClosed_closure c)\n          (fun (x : α) ↦ (_ : ∀ (y : α) (hxy : x ≤ y) (hy : ClosureOperator.IsClosed c y), c x ≤ y))) :=\n  by sorry", "name": "ClosureOperator.eq_ofPred_closed", "lemma-type": "{α : Type u_1} →\n  [PartialOrder α] →\n    (c : ClosureOperator α) → ∀ (x : α) (y : α) (hxy : x ≤ y) (hy : ClosureOperator.IsClosed c y), c x ≤ y", "lemma": "theorem aux.9008159574993079873 {α : Type u_1} [PartialOrder α] (c : ClosureOperator α) :\n    ∀ (x : α) (y : α) (hxy : x ≤ y) (hy : ClosureOperator.IsClosed c y), c x ≤ y := by sorry", "doc_string": "A closure operator is equal to the closure operator obtained by feeding `c.closed` into the\n`ofPred` constructor. ", "generated": ["theorem aux.15524402214743789574 {α : Type u_1} [inst : PartialOrder α] :\n    ∀ {c : ClosureOperator α}, ClosureOperator.toPartialorder = ClosureOperator.IsClosed c.preorder := by sorry ", "theorem aux.13066078563895149708 {α : Type u_1} [PartialOrder α] (c : ClosureOperator α)\n    (x : { f : (α : Ⅱ α →ˢ Unit fun x => α 1) × (@Function.unitsAux.isClosed _ α α 's x) [Unit.IsClosable : Funct f → ¬closedIsUnits ⊧ Unit.un ⊘ getClosedIsUnits = { x, Units.coeU fun f hU => f.val := 0 * pUnits := HI p := e 3 + 1 * q }], p f := fun f : units a => p units a := ∅ ) ↔\n        (IsUnit { f := ((f.1)), is closed (EqMonoGet p f)) ) :=\n  by sorry ", "theorem zero_le : ∀ {K : Type u₁} \\[inst : StrictOrderedSemifield K] [inst_1 : FloorOrder K] (a : K), 0 ≤ a := by\n  sorry ", "theorem ClosureOperator.toPartialOrder : ClosureOperator α := by sorry ", "_ aux.21710362149158920 : True := by sorry ", "theorem Iff.of_eq : ∀ {a b : Prop}, a = b → (a ↔ b) := by sorry ", "theorem aux.16856781384596430179 {α : Type u_1} [PartialOrder α] (c : ClosureOperator α) :\n    ⨅ y, y ∈ Function.fixedPoints ⇑c := by sorry ", "theorem eq_self : ∀ {β : Sort u_2} (a : β), a = a := by sorry "]}
{"theorem-type": "(∀ {n : ℕ} {m : ℕ} (h : n = m), RelIso.toEquiv (Fin.castIso h) = Equiv.cast (h ▸ rfl))", "theorem": "theorem Fin.castIso_to_equiv : (∀ {n : ℕ} {m : ℕ} (h : n = m), RelIso.toEquiv (Fin.castIso h) = Equiv.cast (h ▸ rfl)) :=\n  by sorry", "name": "Fin.castIso_to_equiv", "lemma-type": "∀ {p : Prop}, p = True → p", "lemma": "theorem of_eq_true : ∀ {p : Prop}, p = True → p := by sorry", "doc_string": "While in many cases `Fin.castIso` is better than `Equiv.cast`/`cast`, sometimes we want to apply\na generic theorem about `cast`. ", "generated": ["theorem rel_symm : ∀ {α : Sort u} {r : α → α → Prop} [hs : IsSymm α r] (a b : α), r a b → r b a := by sorry ", "theorem inv_left_eq_right' : ∀ {M₂ : Type u_2} [inst : MulOneClass M₂] () [tM : MulTricycle M₂] (a : M₂) 1 = a := by sorry ", "theorem dvd_refl : ∀ {α : Type u_1} [inst : DivInt Monoid α] (a : α), a ∣ a := by sorry ", "theorem MapLEEmbedding.injective :\n    ∀ {B B' : Bundled BorelSpace} {Φ : Bundled (ModelWithcorners ℝ B→B')}) (h : MapLEEmbedding Φ), Function.Injective ⇑Φ :=\n  by sorry ", "theorem symm : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsSymm α r] {a b : α}, r a b → r b a := by sorry ", "theorem Equiv.trans_refl_symm : ∀ {σ : Sort u_1} {φ₁ : σ ≃ σ} φ₂: σ ≃ σ, Equiv.trans φ₁ φ₂ = ↑φ₂ ∘ₗ ↑φ₁ := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.10042044747336404195 {n : ℕ} {m : ℕ} (h : n = m) : (Fin.reindexSubtypeOfEq (h = m) = lexRel (Fin.dom _)) :=\n  by sorry "]}
{"theorem-type": "(∀ {α : Type u_2} {g : Set (Set α)} {s : Set α},\n  (s ∈ Filter.countableGenerate g) ↔ (∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))))", "theorem": "theorem Filter.mem_countableGenerate_iff :\n    (∀ {α : Type u_2} {g : Set (Set α)} {s : Set α},\n      (s ∈ Filter.countableGenerate g) ↔ (∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s)))) :=\n  by sorry", "name": "Filter.mem_countableGenerate_iff", "lemma-type": "{α : Type u_2} →\n  {g : Set (Set α)} →\n    {s : Set α} →\n      (h : s ∈ Filter.countableGenerate g) →\n        {s : Set α} →\n          {t : Set α} →\n            (a : Filter.CountableGenerateSets g s) →\n              (st : s ⊆ t) →\n                (ih : ∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))) →\n                  (S : Set (Set α)) →\n                    (a : (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))) →\n                      (w : Set (Set α)) →\n                        (h : (w ⊆ g) ∧ ((Set.Countable w) ∧ (⋂₀ w ⊆ s))) →\n                          (left : S ⊆ g) →\n                            (right : (Set.Countable S) ∧ (⋂₀ S ⊆ s)) →\n                              (left_1 : w ⊆ g) →\n                                (right_1 : (Set.Countable w) ∧ (⋂₀ w ⊆ s)) →\n                                  ∀ (left : Set.Countable S) (right : ⋂₀ S ⊆ s),\n                                    (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ t))", "lemma": "theorem aux.2591660316494051975 {α : Type u_2} {g : Set (Set α)} {s : Set α} (h : s ∈ Filter.countableGenerate g)\n    {s : Set α} {t : Set α} (a : Filter.CountableGenerateSets g s) (st : s ⊆ t)\n    (ih : ∃ S, (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))) (S : Set (Set α))\n    (a : (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ s))) (w : Set (Set α)) (h : (w ⊆ g) ∧ ((Set.Countable w) ∧ (⋂₀ w ⊆ s)))\n    (left : S ⊆ g) (right : (Set.Countable S) ∧ (⋂₀ S ⊆ s)) (left_1 : w ⊆ g)\n    (right_1 : (Set.Countable w) ∧ (⋂₀ w ⊆ s)) :\n    ∀ (left : Set.Countable S) (right : ⋂₀ S ⊆ s), (S ⊆ g) ∧ ((Set.Countable S) ∧ (⋂₀ S ⊆ t)) := by sorry", "doc_string": "A set is in the `countableInterFilter` generated by `g` if and only if\nit contains a countable intersection of elements of `g`. ", "generated": ["theorem countable_congr_of_eq : ∀ {G : Type u_1} {H : Type u_2} {f₀ : G → H}, Set.EqOn (⇑f₀) id S ↔ Fintype.card H = Fintype.card G := by sorry ", "theorem countableGenerate_sets :\n    ∀ {α : Type u_2} {ca : Set α}, countableGenerate ca = countable_sets _ ↓ ca ∔ Filter.principal ca := by sorry ", "theorem mem_sInter : ∀ {α : Type u_1} {𝒜 : Set (Set α}) {a : α}, a ∈ ⋂₀ 𝒜 ↔ ∀ (s : Set α) (a : s ∈ 𝒜), a ∈ s := by\n  sorry ", "theorem iffs_self : ∀ (p : Prop), (p ↔ p. true) = True := by sorry ", "theorem aux.5788571179096939282 {α : Type u_2} {g : Set (Set α)} {s : Set α} (t : Set α) (ht : t ∈ Filter.sets g)\n    (f : BoundedContinuousFunction F FP (MetricSpace.compl s)) (b : α), (b ∈ interior t) ↔ ((f s (f ϖ b), f b b) ∈ v) :=\n  by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {R : Type u_1} [inst : AddMonoid R] {a : R} (ua : IsAddUnit a), IsAddRegular a)", "theorem": "theorem IsAddUnit.isAddRegular : (∀ {R : Type u_1} [inst : AddMonoid R] {a : R} (ua : IsAddUnit a), IsAddRegular a) :=\n  by sorry", "name": "IsAddUnit.isAddRegular", "lemma-type": "∀ {R : Type u_1} [inst : AddMonoid R] (a : AddUnits R), IsAddRegular ↑a", "lemma": "theorem AddUnits.isAddRegular : ∀ {R : Type u_1} [inst : AddMonoid R] (a : AddUnits R), IsAddRegular ↑a := by sorry", "doc_string": "An additive unit in an additive monoid is add-regular.", "generated": ["theorem Units.neg_add_self : ∀ {M : Type u_2} [inst : AddGroup M] (a : Units M), -1 + ↑a * (-1 + 1) = 0 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem mul_zero : ∀ {M : Type u} [inst : MulZeroClass M] (a : M), a * 0 = 0 := by Sorry ", "theorem aux.4111534994114903398 {R : Type u_1} [AddMonoid R] {a : R} (ua : IsAddUnit a) (p : R →+ ℕ) (h : p + a = 0)\n    (x : IsAddRegular ↑a) : Units.Val I (a + 0) = p + a := by sorry ", "theorem isRightRegular_of_isADDUnit' : ∀ {R : Type u} [inst : AddZeroClass R] (a : R) [inst_1 : IsAddUnit_ a],\n     IsRightRegular ↑a := by sorry ", "theorem Nat.isAddUnit_negNat : ∀ (n : ℕ), IsAddUnits (-↑n) := by sorry ", "theorem aux.1956781398212845897 {R : Type u_1} [AddMonoid R] {a : R} (ua : IsAddUnit a) : 0 * IsAddRegular a = Units.mk′ ↑a + 0 :=\n  by sorry ", "theorem right_negative_neg_of_mul_add_self_right :\n    ∀ {α : Type u_1} [inst : MulNegZeroClass α], ∀ (a b : α), b * (-b) = -(b + b) := by sorry "]}
{"theorem-type": "(∀ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ℕ) [inst_2 : CharP R p] (hp : p ≠ 2),\n  Polynomial.cyclotomic' 2 R = Polynomial.X + 1)", "theorem": "theorem Polynomial.cyclotomic'_two :\n    (∀ (R : Type u_2) [inst : CommRing R] [inst_1 : IsDomain R] (p : ℕ) [inst_2 : CharP R p] (hp : p ≠ 2),\n      Polynomial.cyclotomic' 2 R = Polynomial.X + 1) :=\n  by sorry", "name": "Polynomial.cyclotomic'_two", "lemma-type": "∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c", "lemma": "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry", "doc_string": "The second modified cyclotomic polyomial is `X + 1` if the characteristic of `R` is not `2`. ", "generated": ["theorem eq_nat_of_int_cast_eq : ∀ {a b : ℤ} {z : ℕ}, ↑a = ↑b → a = b := by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "question:\nShow Poly.coeff (Polynomial.clamp 4 Polynomial.cyclotomic ↑2 Polynomial.X / 2) 3 = Polynomial.X ^ 2 - 2 * Poly.coe 2 Polynomial.X ^ 1 + 1 :=\n  sorry ", "theorem pow_three : ∀ {M : Monoid M} [inst : GroupWithZero M] (n : Nat), ↑n ^ 3 = 1 := by sorry ", "theorem aux.9689135336461604167 (R : Type u_2) [CommRing R] [IsDomain R] (p : ℕ) [CharP R p] (hp : p ≠ 2) :\n    ↑2 - 2 = ZeroIfNeZero.zero hp ^ Nat.rawCast 1 * Nat.rawCast 1 + ZeroIfNeZero.zero hp - Nat.rawCast 1 := by sorry ", "theorem FiniteDimensional.finset_smul_mul_po2_self :\n    ∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : FiniteDimensional K V] (b : K)\n      (s : Finset K), (Smul.smul b sᶢ).map Prod.fst × Prod.snd sⁿ *) :=\n  by sorry ", "theorem neg_one_ne_zero : ∀ {R : Type u_1} [inst : Ring R], ↑(-1) ≠ 0 := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry "]}
{"theorem-type": "(∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n  (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s),\n  ∃ h,\n    (⇑h '' interior s = Metric.ball 0 1) ∧\n      ((⇑h '' closure s = Metric.closedBall 0 1) ∧ (⇑h '' frontier s = Metric.sphere 0 1)))", "theorem": "theorem exists_homeomorph_image_interior_closure_frontier_eq_unitBall :\n    (∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n      (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s),\n      ∃ h,\n        (⇑h '' interior s = Metric.ball 0 1) ∧\n          ((⇑h '' closure s = Metric.closedBall 0 1) ∧ (⇑h '' frontier s = Metric.sphere 0 1))) :=\n  by sorry", "name": "exists_homeomorph_image_interior_closure_frontier_eq_unitBall", "lemma-type": "{E : Type u_1} →\n  [NormedAddCommGroup E] →\n    [NormedSpace ℝ E] →\n      {s : Set E} →\n        (hc : Convex ℝ s) →\n          (hne : Set.Nonempty (interior s)) → (hb : Bornology.IsBounded s) → (e : E ≃ₜ E) → (¬(1 = 0)) = True", "lemma": "theorem aux.11768364167763857318 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n    (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) (e : E ≃ₜ E) : (¬(1 = 0)) = True := by sorry", "doc_string": "If `s` is a convex bounded set with a nonempty interior in a real normed space,\nthen there is a homeomorphism of the ambient space to itself\nthat sends the interior of `s` to the unit open ball\nand the closure of `s` to the unit closed ball. ", "generated": ["theorem aux.16006569429505662827 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E}\n    (hc : Convex ℝ s) (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) (z : E)\n    (hz : z ∈ (⇑Extensional.refl function.Injective function.leftinjection).2 '' interior s) : z ∈ interior s := by\n  rw [hz] sorry : ∀ {y : E}, (¬Set.False) = True := by regret ; sorry ", "theorem aux.7084096529846979377 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n    (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) : ball 0 1 = ∅ := by sorry ", "theorem Bornology.cobounded.isClosed : ∀ (b : Bornology α), Bornology.cobounded ⊆ {x | bornology.cB x} := by sorry ", "theorem aux.3499578814751177717 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E}\n    (hc : Convex ℝ s) (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) :\n    (IsOpenMap ⇑h) ↔ (∀ ⦃z : E⦄ (x : z ∈ h '' frontier s), ∃ w, (w ∈ interior s) ∧ (hi ∃ l₂, ((2 * 1) ≤ l₂) ∧ (z =\n  (func2 φh i / (2 * 1) • frontier l) i)))) :=\n  by sorry ", "theorem congrArg : ∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂ := by sorry ", "theorem aux.10350676095076593038 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E} (hc : Convex ℝ s)\n    (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) :\n    (Subtype.val '' (((interior s)ᶜ ∪ (closure s =ᵐ[MeasureTheory.Measure.ae µ] Set.univ))ᶜ) ∫ᵤ (x : E), 1 ∂1 =\n        Real.sub ↑↑1 0) =\n      (↑↑1 > if (∫ᶠ (x : E) in interior s, 1 ∂μ) * ⨅ n, α n, 0 < 1 ∧ ↑↑1 + 0 < 1 then 1 else Set.univ.interior s ∪\n          closure s =\n        Real.sub ↑↑1 (Subtype.val '' (((interior s)ᶜ ∪ (closure s =ᵐ[MeasureTheory.Measure.ae μ] Set.univ))ᶜ)) :=\n        by sorry ", "theorem aux.12673201073326912676 {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ℝ E] {s : Set E}\n    (hc : Convex ℝ s) (hne : Set.Nonempty (interior s)) (hb : Bornology.IsBounded s) : Metric.tendsto_nhds _ _ :=\n  by sorry ", "thesis :\n∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {hs : Set E},\n    (Metric.unbounded' hs) = (∀ (x : E) (x_2 : x ∈ s), IsBounded ℝ (insert x s)) :=\n  by sorry "]}
{"theorem-type": "(∀ {F : Type u} [inst : Field F] (f : Polynomial F) (h : Polynomial.natDegree f ≠ 0), Polynomial.natSepDegree f ≠ 0)", "theorem": "theorem Polynomial.natSepDegree_ne_zero :\n    (∀ {F : Type u} [inst : Field F] (f : Polynomial F) (h : Polynomial.natDegree f ≠ 0),\n      Polynomial.natSepDegree f ≠ 0) :=\n  by sorry", "name": "Polynomial.natSepDegree_ne_zero", "lemma-type": "{F : Type u} →\n  [Field F] →\n    (f : Polynomial F) →\n      (h : Polynomial.natDegree f ≠ 0) →\n        (Polynomial.rootOfSplits (algebraMap F (Polynomial.SplittingField f)) (Polynomial.SplittingField.splits f)\n              (ne_of_apply_ne (WithBot.unbot' 0) h) ∈\n            Polynomial.aroots f (Polynomial.SplittingField f)) ↔\n          ((f ≠ 0) ∧\n            ((Polynomial.aeval\n                  (Polynomial.rootOfSplits (algebraMap F (Polynomial.SplittingField f))\n                    (Polynomial.SplittingField.splits f) (ne_of_apply_ne (WithBot.unbot' 0) h)))\n                f =\n              0))", "lemma": "theorem aux.4307173229862549741 {F : Type u} [Field F] (f : Polynomial F) (h : Polynomial.natDegree f ≠ 0) :\n    (Polynomial.rootOfSplits (algebraMap F (Polynomial.SplittingField f)) (Polynomial.SplittingField.splits f)\n          (ne_of_apply_ne (WithBot.unbot' 0) h) ∈\n        Polynomial.aroots f (Polynomial.SplittingField f)) ↔\n      ((f ≠ 0) ∧\n        ((Polynomial.aeval\n              (Polynomial.rootOfSplits (algebraMap F (Polynomial.SplittingField f)) (Polynomial.SplittingField.splits f)\n                (ne_of_apply_ne (WithBot.unbot' 0) h)))\n            f =\n          0)) :=\n  by sorry", "doc_string": "A non-constant polynomial has non-zero separable degree. ", "generated": ["theorem aux.12894965402235545876 {F : Type u} [Field F] (f : Polynomial F) (h : Polynomial.natDegree f ≠ 0) :\n    (Polynomial.natSepDegree f = 0) = (Polynomial.natDegree f = 1) := by sorry ", "theorem trans : ∀ {α : Sort u} {r : α → α → Prop} [inst : IsTrans α r] {a b c : α}, r a b → r b c → r a c := by sorry ", "theorem IsCoprime.ne_zero : ∀ {R₀ : Type u_1} [inst : MonoidWithZero R₀] [inst_1 : Nontrivial R₀] [inst_2 : NoZeroDivisors R₀] {R : Type u_1} (m : R) {n : R} (H : IsCoprime n m), Poly.X ^ m * Poly.Y ^ n ≠ 0 := by sorry ", "theorem Trans.trans : ∀ {α : Sort u} {a b c : α}, a ⟶ b → b ⟶ c → a ⟶ c := by sorry ", "theorem sub_one_mod_succ_eq_natSepDegree : ∀ {F : Type u} [inst : Field F] {f : Polynomial F},\n    f ≠ 0 → sub_one_mod (Polynomial.natDegree f + 1) = Polynomial.natSepDegree f := by sorry ", "theorem congr : ∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂ := by\n  sorry ", "theorem lt_or_gt_of_ne : ∀ {Δ : Type u_1} {a b : Δ} (a_1 : a ≠ b), a < b ∨ b < a := by sorry ", "theorem aux.1053686675731985649 {F : Type u} [Field F] (f : Polynomial F) (h : Polynomial.natDegree f ≠ 0) :\n    Polynomial.natDegree f • -2 < Polynomial.natSepDegree f := by sorry "]}
{"theorem-type": "(∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : (a : α) → β} (hf : IsRingHom f) {γ : Type u_1}\n  [inst_2 : Ring γ] {g : (a : β) → γ} (hg : IsRingHom g), IsRingHom (g ∘ f))", "theorem": "theorem IsRingHom.comp :\n    (∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : (a : α) → β} (hf : IsRingHom f) {γ : Type u_1}\n      [inst_2 : Ring γ] {g : (a : β) → γ} (hg : IsRingHom g), IsRingHom (g ∘ f)) :=\n  by sorry", "name": "IsRingHom.comp", "lemma-type": "{α : Type u} →\n  {β : Type v} →\n    [Ring α] →\n      [Ring β] →\n        {f : (a : α) → β} →\n          (hf : IsRingHom f) →\n            {γ : Type u_1} →\n              [Ring γ] →\n                {g : (a : β) → γ} →\n                  (hg : IsRingHom g) →\n                    (x : α) → (y : α) → (g (f x * f y) = g (f x) * g (f y)) = (g (f x) * g (f y) = g (f x) * g (f y))", "lemma": "theorem aux.12677408452356066289 {α : Type u} {β : Type v} [Ring α] [Ring β] {f : (a : α) → β} (hf : IsRingHom f)\n    {γ : Type u_1} [Ring γ] {g : (a : β) → γ} (hg : IsRingHom g) (x : α) (y : α) :\n    (g (f x * f y) = g (f x) * g (f y)) = (g (f x) * g (f y) = g (f x) * g (f y)) := by sorry", "doc_string": "The composition of two ring homomorphisms is a ring homomorphism. ", "generated": ["theorem map_one :\n    ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : FunLike F M N] [inst_1 : One M] [inst_2 : One N]\n      [inst_3 : FunLike.Inv F M N] [inst_4 : Buzzout F (fun x x_1 => x * x_1)] [inst_5 : left_distrib_classes F],\n      map F 1 = 1 :=\n  by sorry ", "theorem aux.12925751564481644853 {α : Type u} {β : Type v} [Ring α] [Ring β] {f : (a : α) → β} (hf : IsRingHom f)\n    {γ : Type u_1} [Ring γ] {g : (a : β) → γ} (hg : IsRingHom g) : MapCommuter (⇑g) | f a * f b - f a * f b | 0 a :=\n  IsRingHom.mul' g : MapCommuter (f ∘g) | f a * f b - f a * f b | 0 := by sorry ", "theorem aux.6337347360291790019 {α : Type u} {β : Type v} [inst : Ring α] [Ring β] {f : (a : α) → β}\n    (hf : IsRingHom f) {γ : Type u_1} [Ring γ] {g : (a : β) → γ} (hg : IsRingHom g) : g 0 = 0 := by sorry ", "theorem IsRingHom.eq_iff :\n    ∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α →+* β} {ℝ : Type u_2} [inst_3 : Zero α]\n      [hc : NontriviallyNormedField ℝ],\n      (⇑f = ⇑NormalizationLocalization.norm ∘fun ν ↦ ν f) ↔ IsRingHom f :=\n  by sorry ", "theorem IsRingHom.neg :\n    ∀ {α : Type u} {β : Type v} [p : Ring α] [q : Ring β] (f : α →+* β), IsRingHom (map_neg' f _ _) := by sorry ", "theorem aux.107134590095732962 {α : Type u} {β : Type v} [Ring α] [Ring β] {f : (a : α) → β} (hf : IsRingHom f)\n    {γ : Type u_1} [Ring γ] {g : (a : β) → γ} (hg : IsRingHom g) : RingHom.comp g 2.ringHom = g ∘ f := by sorry ", "theorem add_zero : ∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a := by sorry ", "theorem aux.9232448003973335603 {α : Type u} {β : Type v} [Ring α] [Ring β] {f : (a : α) → β} (hf : IsRingHom f)\n    {γ : Type u_1} [Ring γ] {g : (a : β) → γ} (hg : IsRingHom g) :\n    map_one' f \\_ = by sorry "]}
