{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 20,
 "number-similar-sentences": 12,
 "number-keyword-sentences": 8,
 "include-fixed": false,
 "failures":
 ["Every set that is Lebesgue measurable but not Borel measurable has Lebesgue measure zero.",
  "If a subgroup of a group is torsion-free, then the group itself is torsion free.",
  "Every normal subgroup of a group has finite index.",
  "The characteristic polynomial of every matrix has real roots.",
  "In a commutative ring, every prime ideal is contained in a unique maximal ideal.",
  "Every uniformly continuous function is bounded above.",
  "The number of partitions of a finite set is a prime number.",
  "The automorphism group of an Abelian group is cyclic.",
  "The complement of the union of two sets contains the union of their complements.",
  "The square root of an rational number is rational.",
  "The initial object of a category is isomorphic to its terminal object."],
 "elaborated-prompts":
 [{"theorem": "∀ (R : Type u) [inst : Ringₓ R], IsField R",
   "some-correct": null,
   "prompt": "Every ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  R :  Type  u ) ->  [  Ringₓ  R ] ->  IsField  R",
    " (  R :  Type  u ) ->  [  Ring  R ] ->  Nonempty   (   Field  R  )",
    " (  R :  Type  u ) ->  [  Ringₓ  R ] ->  Nonempty   (   Field  R  )",
    " {  R :  Type  u } ->  [  Ring  R ] ->  Nonempty   (   Field  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  Nonempty   (   Field  R  )",
    " (  R :  Type  u ) ->  [  NonUnitalNonAssocSemiring  R ] ->  Nonempty   (   Field  R  )",
    " (  R :  Type  u ) ->  [  NonUnitalNonAssocSemiringₓ  R ] ->  Nonempty   (   Field  R  )",
    " (  α :  Type  u ) ->  [  Ringₓ  α ] ->  IsField  α",
    " (  R :  Type  u ) ->  [  NonAssocRing  R ] ->  Nonempty   (   Field  R  )",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  IsField  R",
    " (  R :  Type  u ) ->  [  Ring  R ] ->  Field  R",
    " (  R :  Type  u ) ->  [  Ringₓ  R ] ->  Field  R",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  Nonempty  α ) ->  IsField  α",
    " (  R :  Type  ) ->  [ _inst_1 :  Ringₓ  R ] ->  IsField  R"]},
  {"theorem":
   "∀ (K : Type u) (V : Type v) [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],\n  FiniteDimensional K V",
   "some-correct": null,
   "prompt": "Every vector space is finite dimensional.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  K :  Type  u ) ->  (  V :  Type  v ) ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " (  K :  Type  u ) ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " {  K :  Type  u_1 } ->  {  V :  Type  u_2 } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " (  K :  Type  u_1 ) ->  (  V :  Type  u_2 ) ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V",
    " (  K :  Type  u_1 ) ->  (  V :  Type  u_2 ) ->  [  LinearOrderedField  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  FiniteDimensional  K V"]},
  {"theorem": "∀ {G : Type u_1} [inst : Groupₓ G], Monoidₓ.IsTorsion G",
   "some-correct": null,
   "prompt": "Every group is a torsion monoid.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Monoidₓ.IsTorsion  G",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  Monoidₓ.IsTorsion  G"]},
  {"theorem":
   "∀ {G : Type u} [inst : Fintype G] [inst_1 : Groupₓ G], IsSimpleGroup G → IsPrimePow (Fintype.card G)",
   "some-correct": null,
   "prompt": "Every finite simple group has prime order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Fintype  G ] ->  [  Groupₓ  G ] ->  (  h :  IsSimpleGroup  G ) ->  IsPrimePow   (   Fintype.card  G  )",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  hG :  IsSimpleGroup  G ) ->  ∃     p  :  ℕ ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  H :  IsSimpleGroup  G ) ->  IsPrimePow   (   Fintype.card  G  )",
    " {  G :  Type  u_1 } ->  [  Fintype  G ] ->  [  Groupₓ  G ] ->  (  hG :  IsSimpleGroup  G ) ->  ∃     p  :  ℕ ,   Prime  p ∧   Fintype.card  G = p",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  h :  IsSimpleGroup  G ) ->  ∃    (   p :  ℕ ) ,   Prime  p ∧   Fintype.card  G = p",
    " {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  (  h :  IsSimpleGroup  α ) ->  ∃    (   p :  ℕ ) ,   (   Fact   (   Nat.Prime  p  )  ) ∧  (    Fintype.card  α = p  )",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  Hsimple :  IsSimpleGroup  G ) ->  IsPrimePow   (   Fintype.card  G  )"]},
  {"theorem":
   "∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], IsSimpleGroup G",
   "some-correct": null,
   "prompt": "Every finite group is simple.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  IsSimpleGroup  G",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  IsSimpleGroup  α"]},
  {"theorem":
   "∀ {G : Type u} [inst : Group G] [inst : Fintype G], IsPrimePow (Fintype.card G)",
   "some-correct": null,
   "prompt": "Every finite group has prime order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Group  G ] ->  [  Fintype  G ] ->  IsPrimePow   (   Fintype.card  G  )",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  IsPrimePow   (   Fintype.card  G  )",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  Nat.Prime   (   Fintype.card  α  )",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  Nat.Prime   (   Fintype.card  α  )",
    " (  G :  Type  u ) ->  [  Group  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " (  G :  Type  u ) ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  G :  Type  u } ->  [  Group  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  G = p",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   Fintype.card  α = p",
    " {  G :  Type  u } ->  [  Group  G ] ->  (  hG :  Fintype  G ) ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  G = p",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  hG :  Fintype  G ) ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  G = p",
    " {  α :  Type  u_1 } ->  [  Monoid  α ] ->  [  Fintype  α ] ->  Prime   (   Fintype.card  α  )",
    " {  α :  Type  u_1 } ->  [  Monoidₓ  α ] ->  [  Fintype  α ] ->  Prime   (   Fintype.card  α  )",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  ∃    (   p :  ℕ ) ,   Fact   (   Nat.Prime  p  ) ∧   Fintype.card  α = p",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  IsPrimePow   (   Fintype.card  α  )",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  IsPrimePow   (   Fintype.card  α  )",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  IsPrimePow   (   Fintype.card  G  )",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  IsPrimePow   (   Fintype.card  G  )",
    " {  α :  Type  u_1 } ->  [  Fintype  α ] ->  [  Group  α ] ->  IsPrimePow   (   Fintype.card  α  )",
    " {  α :  Type  u_1 } ->  [  Fintype  α ] ->  [  Groupₓ  α ] ->  IsPrimePow   (   Fintype.card  α  )",
    " {  α :  Type  u } ->  [  Group  α ] ->  [  Fintype  α ] ->  (  h :   Fintype.card  α ≠  0 ) ->  IsPrimePow   (   Fintype.card  α  )",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  [  Fintype  α ] ->  (  h :   Fintype.card  α ≠  0 ) ->  IsPrimePow   (   Fintype.card  α  )",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  [  Fintype  G ] ->  (  p :  ℕ ) ->  [ hp :  Fact   (   Nat.Prime  p  ) ] ->  (  h :  p ∣  Fintype.card  G ) ->  p =  Fintype.card  G",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  p :  ℕ ) ->  [ hp :  Fact   (   Nat.Prime  p  ) ] ->  (  h :  p ∣  Fintype.card  G ) ->  p =  Fintype.card  G"]},
  {"theorem":
   "∀ {α : Type u_1} {m : MeasureTheory.MeasureSpace α} (s : Set α), coeFn MeasureTheory.volume.toOuterMeasure s = 0",
   "some-correct": null,
   "prompt": "Every set has Lebesgue measure zero.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  m :  MeasureTheory.MeasureSpace  α } ->  ∀   (  s  :  Set  α  )  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  (  s :  Set  α ) ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  {  s :  Set  α } ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  {  m :  MeasurableSpace  α } ->  (  s :  Set  α ) ->   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  ∀   (  s  :  Set  α  )  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " (  α :  Type  u_1 ) ->  [  MeasurableSpace  α ] ->  ∀   (  s  :  Set  α  )  ,   MeasureTheory.MeasureSpace.volume  s =  0",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_3 } ->  [  MeasurableSpace  α ] ->  [  MeasurableSpace  β ] ->  (  s :  Set   (   α × β  ) ) ->   MeasureTheory.MeasureSpace.volume  s =  0"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α], CompactSpace α → ∀ {s : Set α}, IsCompact s",
   "some-correct": null,
   "prompt": "If a topological space is compact, then every subset is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  CompactSpace  α ) ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  Nonempty  α ] ->   IsCompact  α →  ∀  s   :  Set  α ,  IsCompact  s",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  (  hs :  CompactSpace  α ) ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  IsCompact  α ) ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u_1 } ->  {  s t :  Set  α } ->  [  TopologicalSpace  α ] ->  (  h :  CompactSpace  α ) ->  (  s_subset_t :  s ⊆ t ) ->  (  h' :  IsCompact  s ) ->  IsCompact  t",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  (  hX :  IsCompact  X ) ->  {  A :  Set  X } ->  IsCompact  A",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  hs :  IsCompact  α ) ->  IsCompact  s",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  (  h :  IsCompact  α ) ->  ∀   (  s  :  Set  α  )  ,  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  CompactSpace  α ] ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  CompactSpace  α ] ->  {  s :  Set  α } ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   CompactSpace  α →  ∀  s   :  Set  α ,  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  CompactSpace  α ) ->  ∀  s   :  Set  α ,  CompactSpace   (   Subtype  s  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  hyp :  CompactSpace  α ) ->  ∀   (  s  :  Set  α  )  ,  IsCompact  s"]},
  {"theorem":
   "∀ {G : Type u} [inst : Groupₓ G] [inst_1 : Fintype G], Groupₓ.Fg G → ∃ a, a ≠ 1 ∧ IsOfFinOrder a → Monoidₓ.IsTorsion G",
   "some-correct": null,
   "prompt":
   "A finitely-presented group containing a torsion element is finite.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->  (  H :  Groupₓ.Fg  G ) ->  ∃    (   a : G ) ,    a ≠  1 ∧  IsOfFinOrder  a →  Monoidₓ.IsTorsion  G",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  hfg :  Groupₓ.Fg  G ) ->  (  h :  Monoidₓ.IsTorsion  G ) ->  Fintype  G",
    " {  G :  Type  u_1 } ->  [  Fintype  G ] ->  [  Groupₓ  G ] ->   Monoidₓ.IsTorsion  G ↔  Monoidₓ.IsTorsionFree  G",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [  Fintype  G ] ->   Monoidₓ.IsTorsion  G ↔  Monoidₓ.Fg  G",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  [ hN :  Nontrivial  G ] ->  [ hFG :  Groupₓ.Fg  G ] ->  (  hT :  ∃    (   g : G ) ,   g ≠  1 ∧  IsOfFinOrder  g ) ->  Fintype  G"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∃ t, t ⊂ s ∧ IsClosed t ∧ x ∈ t) → IsClosed s",
   "some-correct": null,
   "prompt":
   "If every point of a subset of a topological space is contained in some closed set, the subset itself is closed.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  hs :  ∀  x  ∈ s ,  ∃     t  :  Set  α ,   t ⊆ s ∧   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃    (   V :  Set  α ) ,   IsClosed  V ∧   x ∈ V ∧  V ⊆ t ) ->  (  h_open :  IsOpen  t ) ->  IsClosed  s",
    " {  α :  Type* } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀  x  ∈ s ,  ∃     C  :  Set  α ,   IsClosed  C ∧  x ∈ C ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  hs :  ∀   (  x  : α  )  (  hx  :  x ∈ s  )  ,  ∃    (   t :  Set  α ) ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->  (  ht :  IsClosed  t ) ->  {  x : α } ->  (  hx :  x ∈ s ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   {  x  }  ,   x ∈ s →  ∃    (   t :  Set  α ) ,   x ∈ t ∧  IsClosed  t ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃     t  :  Set  α ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  s :  Set  X } ->  (  h :  ∀  x  ∈ s ,  ∃     t  :  Set  X ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  hs :  ∀  x  ∈ s ,  ∃     t  :  Set  α ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   {  x  }  ,   x ∈ s →  ∃    (   t :  Set  α ) ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  s :  Set  X } ->  (  h :  ∀  x   : X ,   x ∈ s →  ∃     t  :  Set  X ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s t :  Set  α } ->  (  h :  ∀  x  ∈ s ,  ∃     c  ,   IsClosed  c ∧   x ∈ c ∧  t ⊆ c ) ->  IsClosed  t",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃    (   c :  Set  α ) ,   IsClosed  c ∧  x ∈ c ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  x  : α  )  ,   x ∈ s →  ∃    (   t :  Set  α ) ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀  x  ∈ s ,  ∃     t  ,   IsClosed  t ∧  x ∈ t ) ->  IsClosed  s",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  s :  Set  X } ->  (  h :  ∀   (  x  : X  )  ,   x ∈ s →  ∃    (   c :  Set  X ) ,   IsClosed  c ∧  x ∈ c ) ->  IsClosed  s",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  {  a :  Set  X } ->  (  ha :  ∀   (  x  : X  )  ,  ∃    (   t :  Set  X ) ,   IsClosed  t ∧   x ∈ t ∧  t ⊆ a ) ->  IsClosed  a"]},
  {"theorem":
   "∀ {X : Type u_1} [inst : TopologicalSpace X], T2Space X ↔ IsOpenMap fun x => (x, x)",
   "some-correct": null,
   "prompt":
   "A topological space $X$ is Hausdorff if and only if the diagonal map is an open map from $X$ to $X × X$.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->   T2Space  α ↔  IsOpenMap   (   λ   ( a : α ) ,  (  a   ,  a )  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   T2Space  α ↔  (   IsOpenMap $  λ x ,  (  x   ,  x )  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   T2Space  α ↔  IsOpenMap   (   λ x ,  (  x   ,  x )  )",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   (   IsOpenMap   (   λ   ( x : X ) ,  (  x   ,  x )  )   :  Prop ) ↔  T2Space  X",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   IsOpenMap   (   λ x ,  (  x   ,  x )  ) ↔  T2Space  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->   T2Space  α ↔  IsOpenMap   (   λ   ( α : α ) ,  (  α   ,  α )  )",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   IsOpenMap   (   λ   ( x : X ) ,  (  x   ,  x )  ) ↔  T2Space  X",
    " {  α :  Type* } ->  [  TopologicalSpace  α ] ->   T2Space  α ↔  IsOpenMap   (   λ x ,  (  x   ,  x )  )",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->   T2Space  X ↔  IsOpenMap   (   λ x : X ,  (  x   ,  x )  )"]},
  {"theorem":
   "∀ {G : Type u} [inst : Monoidₓ G] {x : G} [inst_1 : Fintype G], IsOfFinOrder x → x = 1",
   "some-correct": null,
   "prompt": "Any finite order element in a group is equal to the identity.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Monoidₓ  G ] ->  {  x : G } ->  [  Fintype  G ] ->  (  hx :  IsOfFinOrder  x ) ->  x =  1",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  x : G ) ->  (  hx :  IsOfFinOrder  x ) ->  x =  1",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  (  a : α ) ->  (  h :  IsOfFinOrder  a ) ->  a =  1",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  x : G ) ->  (  hx :  IsOfFinOrder  x ) ->  x =  1",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  x : G } ->  (  hx :  IsOfFinOrder  x ) ->  x =  1",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  (  x : G ) ->   IsOfFinOrder  x →  x =  1",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  (  h :  IsOfFinOrder   1 ) ->   1 =   1 ⁻¹",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  IsOfFinOrder   1 ) ->   1 =   1 ⁻¹",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  {  x : G } ->  [  Fintype  G ] ->  (  hx :  IsOfFinOrder  x ) ->  x =  1",
    " {  G :  Type  u } ->  [  Monoidₓ  G ] ->  (  H :  IsNormalSubgroup  G ) ->  {  x : G } ->  (  hx :  IsOfFinOrder  x ) ->  x =  1",
    " {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  {  x : α } ->   IsOfFinOrder  x →  x =  1"]},
  {"theorem":
   "∀ {n : ℕ} {α : Type u} [inst : Fintype α] [inst : DecidableEq α] {f : FreeGroup α → FreeGroup α},\n  Function.Injective f → Function.Surjective f",
   "some-correct": null,
   "prompt":
   "Every injective homomorphism from a finitely generated free group to itself is surjective.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  n :  ℕ } ->  {  α :  Type  u } ->  [  Fintype  α ] ->  [  DecidableEq  α ] ->  {  f :   FreeGroup  α →  FreeGroup  α } ->  (  inj_fn :  Function.Injective  f ) ->  Function.Surjective  f",
    " {  α :  Type  u } ->  [  DecidableEq  α ] ->  {  f :   FreeGroup  α →  FreeGroup  α } ->  (  hf :  IsGroupHom  f ) ->  (  i :  Function.Injective  f ) ->  Function.Surjective  f"]},
  {"theorem": "∀ (K : Type u) [inst : DivisionRing K], IsField K ∨ Finite K",
   "some-correct": null,
   "prompt": "Every division ring is either a field or finite.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  DivisionRing  K ] ->   IsField  K ∨  Finite  K",
    " {  K :  Type  u } ->  [  DivisionRing  K ] ->   IsField  K ∨  Finite  K",
    " (  K :  Type  u_1 ) ->  [  DivisionRing  K ] ->   IsField  K ∨  (   ∃     p  :  ℕ ,   Fact   (   Nat.Prime  p  ) ∧  CharP  K p  )",
    " (  K :  Type  u ) ->  [  DivisionRing  K ] ->  (    IsField  K ∨  Finite  K  )",
    " (  K :  Type  u_1 ) ->  [  DivisionRing  K ] ->   IsField  K ∨  (   Finite  K  )"]},
  {"theorem": "∀ {n : ℕ}, n ≠ 0 → ∃ a b, Nat.Prime a ∧ Nat.Prime b ∧ n = a * b",
   "some-correct": null,
   "prompt": "Every natural number is the product of two primes.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  n :  ℕ } ->  (  hn :  n ≠  0 ) ->  ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧  n =  a * b",
    " {  n :  ℕ } ->  (  hn :   1 < n ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧  n =  p * q",
    " (  n :  ℕ ) ->  ∃    (   p  q :  ℕ ) ,   n =  p * q ∧   Prime  p ∧  Prime  q",
    " (  n :  ℕ ) ->  ∃    (   p  q :  ℕ ) ,   n =  p * q ∧   Nat.Prime  p ∧  Nat.Prime  q",
    " (  n :  ℕ ) ->  ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧  n =  a * b",
    " (  n :  ℕ ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧   p * q = n",
    " (  n :  ℕ ) ->  ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧  n =  a * b",
    " {  n :  ℕ } ->  (  n2 :   2 ≤ n ) ->  ∃     p  q  :  ℕ ,   Prime  p ∧   Prime  q ∧   p * q = n",
    " {  n :  ℕ } ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧  n =  p * q",
    " (  n :  ℕ ) ->  (  hpos :   0 < n ) ->  ∃    (   p  q :  ℕ ) ,   n =  p * q ∧   Nat.Prime  p ∧  Nat.Prime  q",
    " (  n :  ℕ ) ->  ∃    (   p  q :  ℕ ) ,   Nat.Prime  p ∧   Nat.Prime  q ∧  n =  p * q",
    " (  n :  ℕ ) ->  ∃    (   p  q :  ℕ )  (   hp :  Nat.Prime  p )  (   hq :  Nat.Prime  q ) ,  n =  p * q",
    " (  n :  ℕ ) ->  ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧   a * b = n",
    " ∀   (  n  :  ℕ  )  ,   Nat.Prime  n ∨  ∃    (   a  b :  ℕ ) ,   Nat.Prime  a ∧   Nat.Prime  b ∧  n =  a * b"]},
  {"theorem": "∀ (n : ℕ), n % 2 = 0 → ∃ m, n = m ^ 2",
   "some-correct": null,
   "prompt": "Every even number is the square of a natural number.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  n :  ℕ ) ->    n %  2 =  0 →  ∃    (   m :  ℕ ) ,  n =  m ^  2",
    " {  n :  ℕ } ->  (  h :  Even  n ) ->  ∃    (   m :  ℕ ) ,   m ^  2 = n",
    " {  n :  ℕ } ->  (  h :  Even  n ) ->  ∃     m  :  ℕ ,  n =  m * m",
    " {  m :  ℕ } ->  (  hm :  Even  m ) ->  ∃    (   c :  ℕ ) ,  m =  c ^  2",
    " {  n :  ℕ } ->  (  hn :   n %  2 =  0 ) ->  ∃    (   m :  ℕ ) ,   m ^  2 = n",
    " (  n :  ℕ ) ->   Even  n →  ∃    (   m :  ℕ ) ,  n =  m ^  2",
    " (  n :  ℕ ) ->   Even  n →  ∃    (   k :  ℕ ) ,  n =  k ^  2",
    " {  m :  ℕ } ->  (  hm :  Even  m ) ->  ∃    (   n :  ℕ ) ,  m =  n * n",
    " {  n :  ℕ } ->  (  h :   2 ∣ n ) ->  ∃    (   m :  ℕ ) ,  n =  m ^  2",
    " {  m :  ℕ } ->   Even  m →  ∃    (   n :  ℕ )  (   k :  ℕ ) ,   m =  n * k ∧    2 * k =  1",
    " {  m :  ℕ } ->   Even  m →  ∃    (   c :  ℕ ) ,  m =  c ^  2",
    " {  n :  ℕ } ->   Even  n →  ∃    (   m :  ℕ ) ,  n =  m ^  2",
    " {  n :  ℕ } ->  (  hn :   n %  2 =  0 ) ->  ∃    (   m :  ℕ ) ,  n =  m ^  2",
    " {  n :  ℕ } ->  (  h :  Even  n ) ->  ∃    (   m :  ℕ ) ,   m * m = n",
    " {  m :  ℕ } ->   Even  m →  ∃    (   n :  ℕ ) ,  m =  n ^  2",
    " (  M :  Type  u_1 ) ->  [  MonoidWithZero  M ] ->  [  Semiring  M ] ->  (  m : M ) ->   Even  m →  ∃    (   c : M ) ,  m =  c ^  2",
    " (  M :  Type  u_1 ) ->  [  MonoidWithZero  M ] ->  [  Semiringₓ  M ] ->  (  m : M ) ->   Even  m →  ∃    (   c : M ) ,  m =  c ^  2",
    " (  M :  Type  u_1 ) ->  [  MonoidWithZeroₓ  M ] ->  [  Semiring  M ] ->  (  m : M ) ->   Even  m →  ∃    (   c : M ) ,  m =  c ^  2",
    " (  M :  Type  u_1 ) ->  [  MonoidWithZeroₓ  M ] ->  [  Semiringₓ  M ] ->  (  m : M ) ->   Even  m →  ∃    (   c : M ) ,  m =  c ^  2",
    " {  n :  ℕ } ->  (  h :   n %  2 =  0 ) ->  ∃    (   k :  ℕ ) ,  n =  k ^  2"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  h :  Continuous  f ) ->  UniformContinuous  f",
    " {  X :  Type  u_1 } ->  {  Y :  Type  u_2 } ->  [  UniformSpace  X ] ->  [  UniformSpace  Y ] ->  {  f :  X → Y } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  Cont :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  CompleteSpace  β ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : Set α), IsCompact x → IsClosed x) → IsCompact s → IsClosed s",
   "some-correct": null,
   "prompt":
   "If every compact subset of a topological space is closed, then the space is compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  x  :  Set  α  )  ,   IsCompact  x →  IsClosed  x ) ->   IsCompact  s →  IsClosed  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  (  H :  ∀   (  K  :  Set  α  )  ,   IsCompact  K →  IsClosed  K ) ->  CompactSpace  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  H :  ∀   (  s  :  Set  α  )  ,   IsCompact  s →  IsClosed  s ) ->  IsCompact  α",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  (  h_compact_to_closed :  ∀  s   :  Set  α ,   IsCompact  s →  IsClosed  s ) ->  CompactSpace  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  ∀   (  s  :  Set  α  )  ,   IsCompact  s →  IsClosed  s ) ->  IsCompact  α",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  ∀   (  s  :  Set  α  )  ,   IsCompact  s →  IsClosed  s ) ->  CompactSpace  α",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  K :  Set  α } ->  (  hK :  ∀  s   :  Set  α ,   IsCompact  s →  IsClosed  s ) ->  IsCompact  α",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  {  K :  Set  X } ->  (  h :  ∀  s  ,   IsCompact  s →  IsClosed  s ) ->  CompactSpace  X",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  ∀   (  s  :  Set  α  )  ,   IsCompact  s →  IsClosed  s ) ->  CompactSpace  α",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  (  h :  ∀   (  s  :  Set  X  )  ,   IsCompact  s →  IsClosed  s ) ->  CompactSpace  X",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  h :  ∀   (  x  :  Set  α  )  ,   IsCompact  x →  IsClosed  x ) ->  CompactSpace  α",
    " {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  {  s :  Set  α } ->  (  h :  ∀   (  K  :  (   Set  α  )  )  ,   IsCompact  K →  IsClosed  K ) ->  IsCompact  s",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->   (   ∀  K   :  Set  α ,   IsCompact  K →  IsClosed  K  ) →  IsCompact  α"]},
  {"theorem":
   "∀ {R : Type u_1} [inst : CommRing R] {a b : R}, a * a = a → b * b = b → (a + b) * (a + b) = a + b",
   "some-correct": null,
   "prompt":
   "In a commutative ring, the sum of idempotent elements is idempotent.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  R :  Type  u_1 } ->  [  CommRing  R ] ->  {  a b : R } ->  (  ha :   a * a = a ) ->  (  hb :   b * b = b ) ->    (   a + b  ) *  (   a + b  ) =  a + b",
    " {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  {  a b : R } ->  (  ha :   a * a = a ) ->  (  hb :   b * b = b ) ->    (   a + b  ) *  (   a + b  ) =  a + b",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  (  s t : α ) ->  (  hs :   s * s = s ) ->  (  ht :   t * t = t ) ->    (   s + t  ) *  (   s + t  ) =  s + t",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  s t : α ) ->  (  hs :   s * s = s ) ->  (  ht :   t * t = t ) ->    (   s + t  ) *  (   s + t  ) =  s + t",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  {  x y : α } ->  (  hx :   x * x = x ) ->  (  hy :   y * y = y ) ->    (   x + y  ) *  (   x + y  ) =  x + y",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  x y : α } ->  (  hx :   x * x = x ) ->  (  hy :   y * y = y ) ->    (   x + y  ) *  (   x + y  ) =  x + y",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  {  a b : α } ->  (  ha :   a ^  2 = a ) ->  (  hb :   b ^  2 = b ) ->    (   a + b  ) ^  2 =  a + b",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  a b : α } ->  (  ha :   a ^  2 = a ) ->  (  hb :   b ^  2 = b ) ->    (   a + b  ) ^  2 =  a + b",
    " {  α :  Type  u } ->  [  NonUnitalRing  α ] ->  {  a b : α } ->  (  h1 :   a * a = a ) ->  (  h2 :   b * b = b ) ->    (   a + b  ) *  (   a + b  ) =  a + b",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  {  a b : α } ->  (  ha :   a + a = a ) ->  (  hb :   b + b = b ) ->     a + b + b + a = a",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  a b : α } ->  (  ha :   a + a = a ) ->  (  hb :   b + b = b ) ->     a + b + b + a = a",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  {  a b : α } ->  (  h :   a * b =  0 ) ->   a +  a * b = a",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  a b : α } ->  (  h :   a * b =  0 ) ->   a +  a * b = a",
    " {  α :  Type  u } ->  [  NonUnitalRing  α ] ->  {  a b : α } ->  (  h :   a + b =  a * b ) ->  a =  a ^  2",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  {  a b : α } ->  (  h :   a * b =  0 ) ->  (  ha :   a * a = a ) ->  (  hb :   b * b = b ) ->    (   a + b  ) *  (   a + b  ) =  a + b",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  {  a b : α } ->  (  h :   a * b =  0 ) ->  (  ha :   a * a = a ) ->  (  hb :   b * b = b ) ->    (   a + b  ) *  (   a + b  ) =  a + b",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  (  a b : α ) ->  (  h :   a * a = a ) ->  (  h1 :   b * b = b ) ->    a + b -  a * b =   a + b -  b * a",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  (  a b : α ) ->  (  h :   a * a = a ) ->  (  h1 :   b * b = b ) ->    a + b -  a * b =   a + b -  b * a",
    " {  α :  Type  u_1 } ->  [  CommRing  α ] ->  (  a b : α ) ->  (  ha :   a * a = a ) ->  (  hb :   b * b = b ) ->    (   a + b  ) *  (   a + b  ) =  a + b",
    " {  α :  Type  u_1 } ->  [  CommRingₓ  α ] ->  (  a b : α ) ->  (  ha :   a * a = a ) ->  (  hb :   b * b = b ) ->    (   a + b  ) *  (   a + b  ) =  a + b"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α],\n  (∃ a, IsMax a) → (∃ a, IsLeast { a' | a ≤ a' } a) ∧ (∃ a, IsMax a) ∧ (∃ a, IsMin a) ∧ ∃ a, IsMax a",
   "some-correct": null,
   "prompt":
   "If a poset has a maximal element, then it has a unique minimal element.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  [  ConditionallyCompleteLattice  α ] ->  (  H :  ∃    (   a : α ) ,  IsMax  a ) ->   (   ∃    (   a : α ) ,  IsLeast   {   a'  |  a ≤ a' } a  ) ∧   (   ∃    (   a : α ) ,  IsMax  a  ) ∧   (   ∃    (   a : α ) ,  IsMin  a  ) ∧  (   ∃    (   a : α ) ,  IsMax  a  )",
    " {  α :  Type  u_2 } ->  [  LinearOrder  α ] ->  (  h :  ∃    (   a : α ) ,  ∀   (  b  : α  )  ,  a ≤ b ) ->  ∃!    (   a : α ) ,  ∀   (  b  : α  )  ,  a ≤ b",
    " {  α :  Type  u_2 } ->  [  LinearOrderₓ  α ] ->  (  h :  ∃    (   a : α ) ,  ∀   (  b  : α  )  ,  a ≤ b ) ->  ∃!    (   a : α ) ,  ∀   (  b  : α  )  ,  a ≤ b",
    " {  α :  Type  u_1 } ->  [  PartialOrder  α ] ->  {  a : α } ->  (  H :  ∃    (   b : α ) ,  a ≤ b ) ->  ∃!    (   b : α ) ,  b ≤ a",
    " {  α :  Type  u_1 } ->  [  PartialOrderₓ  α ] ->  {  a : α } ->  (  H :  ∃    (   b : α ) ,  a ≤ b ) ->  ∃!    (   b : α ) ,  b ≤ a",
    " {  α :  Type  u } ->  [  PartialOrder  α ] ->  [  Nonempty  α ] ->  {  m : α } ->  (  h :  IsTop  m ) ->  ∃!    (   a : α ) ,  IsBot  a",
    " {  α :  Type  u } ->  [  PartialOrderₓ  α ] ->  [  Nonempty  α ] ->  {  m : α } ->  (  h :  IsTop  m ) ->  ∃!    (   a : α ) ,  IsBot  a",
    " {  α :  Type  u_1 } ->  {  r :  α →  α →  Prop } ->  [  Preorder  α ] ->  (  h :  ∃    (   m : α ) ,  ∀   (  a  : α  )  ,  r  a m ) ->  ∃!    (   m : α ) ,  ∀   (  a  : α  )  ,  r  m a",
    " {  α :  Type  u_1 } ->  {  r :  α →  α →  Prop } ->  [  Preorderₓ  α ] ->  (  h :  ∃    (   m : α ) ,  ∀   (  a  : α  )  ,  r  a m ) ->  ∃!    (   m : α ) ,  ∀   (  a  : α  )  ,  r  m a",
    " {  α :  Type  u } ->  [  PartialOrder  α ] ->  (  hα :  ∃     a  ,  IsTop  a ) ->  ∃!     a  ,  IsBot  a",
    " {  α :  Type  u } ->  [  PartialOrderₓ  α ] ->  (  hα :  ∃     a  ,  IsTop  a ) ->  ∃!     a  ,  IsBot  a"]},
  {"theorem":
   "∀ {f : ℕ → ℕ} (x : ℕ), f x = x → ∀ {n : ℕ}, 0 < n → Function.IsPeriodicPt f n x",
   "some-correct": null,
   "prompt":
   "If a function from the unit interval to itself has a fixed point, then it has points of all positive periods.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  f :   ℕ →  ℕ } ->  (  x :  ℕ ) ->  (  hfx :   f  x = x ) ->  {  n :  ℕ } ->  (  hn :   0 < n ) ->  Function.IsPeriodicPt  f n x",
    " {  f :   ℕ →  ℕ } ->  (  h :  ∃    (   x :  ℕ ) ,  Function.IsFixedPt  f x ) ->  ∃    (   n :  ℕ )  (   x :  ℕ ) ,    0 < n ∧  Function.IsPeriodicPt  f n x",
    " {  f :   ℕ →  ℕ } ->  (  H :  ∃     x  ,  Function.IsFixedPt  f x ) ->  ∀  n  ,  ∃     x  ,  Function.IsPeriodicPt  f n x"]},
  {"theorem":
   "{R : Type u} →\n  {M : Type v} → [inst : Ringₓ R] → [inst_1 : AddCommGroupₓ M] → [inst_2 : Module R M] → Module.Free R M → CommRing R",
   "some-correct": null,
   "prompt": "If a module over a ring is free, then the ring is commutative.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  (  b :  Module.Free  R M ) ->  CommRing  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  (  b :  Module.Free  R M ) ->  CommRingₓ  R",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  Ringₓ  α ] ->  [  AddCommGroupₓ  β ] ->  [  Module  α β ] ->  (  h :  Module.Free  α β ) ->  CommRing  α",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  Ringₓ  α ] ->  [  AddCommGroupₓ  β ] ->  [  Module  α β ] ->  (  h :  Module.Free  α β ) ->  CommRingₓ  α",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  (  H :  Module.Free  R M ) ->  CommRing  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  (  H :  Module.Free  R M ) ->  CommRingₓ  R",
    " {  R M :  Type* } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  [  Module.Free  R M ] ->  CommRing  R",
    " {  R M :  Type* } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  [  Module.Free  R M ] ->  CommRingₓ  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  CommRingₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  [  Module.Free  R M ] ->  CommRing  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  CommRingₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  [  Module.Free  R M ] ->  CommRingₓ  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->   Module.Free  R M →  CommRing  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->   Module.Free  R M →  CommRingₓ  R",
    " {  α :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  α ] ->  [  AddCommGroupₓ  M ] ->  [  Module  α M ] ->  (  h :  Module.Free  α M ) ->  CommRing  α",
    " {  α :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  α ] ->  [  AddCommGroupₓ  M ] ->  [  Module  α M ] ->  (  h :  Module.Free  α M ) ->  CommRingₓ  α",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  CommRingₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->   Module.Free  R M →  CommRing  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  CommRingₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->   Module.Free  R M →  CommRingₓ  R",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  Ringₓ  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->   Module.Free  K V →  CommRing  K",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  Ringₓ  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->   Module.Free  K V →  CommRingₓ  K",
    " {  α :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  α ] ->  [  AddCommGroupₓ  M ] ->  [  Module  α M ] ->  (  f :  Module.Free  α M ) ->  CommRing  α",
    " {  α :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  α ] ->  [  AddCommGroupₓ  M ] ->  [  Module  α M ] ->  (  f :  Module.Free  α M ) ->  CommRingₓ  α",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  (  hf :  Module.Free  R M ) ->  CommRing  R",
    " {  R :  Type  u } ->  {  M :  Type  v } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ  M ] ->  [  Module  R M ] ->  (  hf :  Module.Free  R M ) ->  CommRingₓ  R"]},
  {"theorem": "{α : Type u} → [inst : Ringₓ α] → Group (Units α) → CommRing α",
   "some-correct": null,
   "prompt":
   "If the set of units of a ring forms a group then the ring is commutative.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  Group   (   Units  α  ) ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  Group   (   Units  α  ) ) ->  CommRingₓ  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  Groupₓ   (   Units  α  ) ) ->  CommRing  α",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  h :  Groupₓ   (   Units  α  ) ) ->  CommRingₓ  α",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroup   (   Units  R  ) ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRing  R",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroup   (   Units  R  ) ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRingₓ  R",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroup   (   Units  R  ) ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRing  R",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroup   (   Units  R  ) ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRingₓ  R",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ   (   Units  R  ) ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRing  R",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ   (   Units  R  ) ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRingₓ  R",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ   (   Units  R  ) ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRing  R",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  [  AddCommGroupₓ   (   Units  R  ) ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRingₓ  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoid  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRing  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoid  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRingₓ  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoid  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRing  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoid  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRingₓ  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoidₓ  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRing  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoidₓ  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRingₓ  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoidₓ  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRing  R",
    " (  R :  Type  u ) ->  [  Monoidₓ  R ] ->  [  AddCommMonoidₓ  R ] ->  [  Zero  R ] ->  [  One  R ] ->  [  Inv  R ] ->  [  Mul  R ] ->  [  Add  R ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  (  h :  Group   (   Units  R  ) ) ->  CommRingₓ  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRing  R",
    " {  R :  Type  u } ->  [  Ringₓ  R ] ->  (  h :  Groupₓ   (   Units  R  ) ) ->  CommRingₓ  R",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  (  h :  Group   (   Units  α  ) ) ->  CommRing  α",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  (  h :  Group   (   Units  α  ) ) ->  CommRingₓ  α",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  (  h :  Groupₓ   (   Units  α  ) ) ->  CommRing  α",
    " {  α :  Type  u_1 } ->  [  Ringₓ  α ] ->  (  h :  Groupₓ   (   Units  α  ) ) ->  CommRingₓ  α",
    " (  R :  Type  u_1 ) ->  [  Ringₓ  R ] ->  [  GroupWithZero   (   Units  R  ) ] ->  AddCommGroup   (   Units  R  )",
    " (  R :  Type  u_1 ) ->  [  Ringₓ  R ] ->  [  GroupWithZero   (   Units  R  ) ] ->  AddCommGroupₓ   (   Units  R  )",
    " (  R :  Type  u_1 ) ->  [  Ringₓ  R ] ->  [  GroupWithZeroₓ   (   Units  R  ) ] ->  AddCommGroup   (   Units  R  )",
    " (  R :  Type  u_1 ) ->  [  Ringₓ  R ] ->  [  GroupWithZeroₓ   (   Units  R  ) ] ->  AddCommGroupₓ   (   Units  R  )"]},
  {"theorem": "∀ (n : ℕ), 10 < n → ∃ a b, a ^ 2 + b ^ 2 = n ∧ Nat.Prime b",
   "some-correct": null,
   "prompt":
   "Every natural number larger than `10` is the sum of a square and a prime.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  n :  ℕ ) ->  (  hn :   10 < n ) ->  ∃    (   a  b :  ℕ ) ,     a ^  2 +  b ^  2 = n ∧  Nat.Prime  b",
    " (  n :  ℕ ) ->  (  hn :   10 < n ) ->  ∃    (   a  b :  ℕ ) ,     a ^  2 + b = n ∧  Nat.Prime  b",
    " (  n :  ℕ ) ->  (  hn :   10 < n ) ->  ∃    (   a  p :  ℕ ) ,    p %  2 =  1 ∧    a ^  2 + p = n",
    " {  p :  ℕ } ->  (  hp :  p >  10 ) ->  ∃    (   a :  ℕ ) ,  ∃    (   b :  ℕ ) ,     a * a + b = p ∧  Nat.Prime  b",
    " {  N :  ℕ } ->  (  h :   10 < N ) ->  ∃    (   a  p :  ℕ ) ,     a ^  2 + p = N ∧   Nat.Prime  p ∧   p < N ∧  p >  2",
    " (  n :  ℕ ) ->  (  hn :  n >  10 ) ->  ∃    (   a  b :  ℕ ) ,     a ^  2 +  b ^  2 = n ∧  Nat.Prime  b",
    " {  p :  ℕ } ->  (  hp :  Nat.Prime  p ) ->  (  h :  p ≥  11 ) ->  ∃    (   a :  ℕ ) ,  ∃    (   b :  ℕ ) ,    a * a + b = p",
    " {  n :  ℕ } ->  (  h :   10 < n ) ->  ∃    (   a  b :  ℕ ) ,     a ^  2 +  b ^  2 = n ∧  Nat.Prime  b",
    " (  n :  ℕ ) ->  (  hn :  n >  10 ) ->  ∃    (   a  b :  ℕ ) ,     a * a + b = n ∧  Nat.Prime  b",
    " (  n :  ℕ ) ->  (  hn :   10 < n ) ->  ∃    (   l :  ℕ )  (   p :  ℕ ) ,   n =   l ^  2 + p ∧  Nat.Prime  p",
    " (  n :  ℕ ) ->   n >  10 →  ∃    (   a  b :  ℕ ) ,     a * a + b = n ∧  Fact   (   Nat.Prime  b  )",
    " (  n :  ℕ ) ->  (  h :  n >  10 ) ->  ∃    (   m :  ℕ ) ,  ∃    (   p :  ℕ ) ,     m ^  2 + p = n ∧  Nat.Prime  p",
    " {  n :  ℕ } ->   n >  10 →  ∃    (   a  b :  ℕ ) ,     a ^  2 +  b ^  2 = n ∧  Nat.Prime  b",
    " (  n :  ℕ ) ->  (  hn :   10 < n ) ->  ∃    (   a  b :  ℕ ) ,     a * a + b = n ∧  Nat.Prime  b",
    " (  n :  ℕ ) ->  (  h :   10 < n ) ->  ∃    (   x  y :  ℕ ) ,     x ^  2 +  y ^  2 = n ∧  Nat.Prime  y"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] {f : α → β} {g : β → γ}, Continuous (g ∘ f) → Continuous f ∧ Continuous g",
   "some-correct": null,
   "prompt":
   "If the composition of two functions is continuous, then each of them is continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  h :  Continuous   (   g ∘ f  ) ) ->   Continuous  f ∧  Continuous  g",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  h :  Continuous   (   λ   ( x : α ) ,  g   (   f  x  )  ) ) ->  (  hf :  Continuous  f ) ->  Continuous  g",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  h :  Continuous   (   g ∘ f  ) ) ->   Continuous  f ∧  Continuous  g",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  c :  Continuous   (   g ∘ f  ) ) ->  Continuous  g",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  (  f :  α → β ) ->  (  g :  β → γ ) ->  (  h :  Continuous   (   g ∘ f  ) ) ->   Continuous  f ∧  Continuous  g",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  (  f :  α → β ) ->  (  g :  β → γ ) ->  [  TopologicalSpace  γ ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  α ] ->  (  h :  Continuous   (   g ∘ f  ) ) ->  Continuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  h :  Continuous   (   g ∘ f  ) ) ->  Continuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  {  f :  β → γ } ->  {  g :  α → β } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  (  h :  Continuous   (   f ∘ g  ) ) ->  Continuous  g",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  hfg :  Continuous   (   Function.comp  g f  ) ) ->  Continuous  g",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  h :  Continuous   (   g ∘ f  ) ) ->   Continuous  g →  Continuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  g :  α → β } ->  {  f :  β → γ } ->  (  H :  Continuous   (   f ∘ g  ) ) ->   Continuous  g ∧  Continuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  [  T2Space  α ] ->  (  hfg :  Continuous   (   Function.comp  f g  ) ) ->  Continuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  (  f :  β → γ ) ->  (  g :  α → β ) ->  (  hfg :  Continuous   (   f ∘ g  ) ) ->  Continuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  {  γ :  Type  u_3 } ->  [  TopologicalSpace  α ] ->  [  TopologicalSpace  β ] ->  [  TopologicalSpace  γ ] ->  {  f :  α → β } ->  {  g :  β → γ } ->  (  h :  Continuous   (   g ∘ f  ) ) ->   Continuous  g ∧  Continuous  f"]},
  {"theorem":
   "∀ {S : Type ?u.9708663} [inst : Mul S] {a b c : S}, Commute a b → Commute b c → Commute a c",
   "some-correct": null,
   "prompt":
   "If `a` commutes with `b` and `b` commutes with `c` then `a` commutes with `c`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  S :  Type* } ->  [  Mul  S ] ->  {  a b c : S } ->  (  h1 :  Commute  a b ) ->  (  h2 :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  CommSemigroup  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  CommSemigroupₓ  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  Semigroup  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  Semigroupₓ  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  Mul  S ] ->  {  a b c : S } ->  (  h :  Commute  a b ) ->  (  h₂ :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  Mul  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  CommMonoid  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  CommMonoidₓ  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u } ->  [  Monoid  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u } ->  [  Monoidₓ  S ] ->  {  a b c : S } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  {  a b c : S } ->  [  CommGroup  S ] ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  {  a b c : S } ->  [  CommGroupₓ  S ] ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  S :  Type  u_1 } ->  [  Mul  S ] ->  {  a b c : S } ->  (  h1 :  Commute  a b ) ->  (  h2 :  Commute  b c ) ->  Commute  a c",
    " {  α :  Type  u_1 } ->  [  Semigroup  α ] ->  {  a b c : α } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  α :  Type  u_1 } ->  [  Semigroupₓ  α ] ->  {  a b c : α } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c",
    " {  T :  Type  u } ->  [  Mul  T ] ->  {  a b c : T } ->  (  hab :  Commute  a b ) ->  (  hbc :  Commute  b c ) ->  Commute  a c"]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : Ringₓ α] [inst_1 : Ringₓ β] {f : α → β}, IsRingHom f → ∀ (x : α), f x = 0 → x = 0",
   "some-correct": null,
   "prompt":
   "If an element maps to zero under a ring homomorphism, then it is zero.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  {  β :  Type  v } ->  [  Ringₓ  α ] ->  [  Ringₓ  β ] ->  {  f :  α → β } ->  (  hf :  IsRingHom  f ) ->  ∀   (  x  : α  )  ,    f  x =  0 →  x =  0",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  CommRingₓ  α ] ->  [  CommRingₓ  β ] ->  {  f :  α → β } ->  (  hf :  IsRingHom  f ) ->  {  a : α } ->  (  h :   f  a =  0 ) ->  a =  0",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  Ringₓ  α ] ->  [  Ringₓ  β ] ->  {  f :  α → β } ->  (  hf :  IsRingHom  f ) ->  (  x : α ) ->  (  h :   f  x =  0 ) ->  x =  0",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  CommRingₓ  α ] ->  [  CommRingₓ  β ] ->  (  f :  α → β ) ->  (  hf :  IsRingHom  f ) ->  (  hB :  Ring  β ) ->  ∀  x   : α ,    f  x =  0 →  x =  0",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  CommRingₓ  α ] ->  [  CommRingₓ  β ] ->  (  f :  α → β ) ->  (  hf :  IsRingHom  f ) ->  (  hB :  Ringₓ  β ) ->  ∀  x   : α ,    f  x =  0 →  x =  0",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  Ringₓ  α ] ->  [  Ringₓ  β ] ->  {  f :  α → β } ->  {  x : α } ->  (  hf :  IsRingHom  f ) ->  (  hfx :   f  x =  0 ) ->  x =  0",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  CommRingₓ  α ] ->  [  CommRingₓ  β ] ->  {  f :  α → β } ->  {  x : α } ->  (  hf :  IsRingHom  f ) ->  (  hx :   f  x =  0 ) ->  x =  0",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  Ringₓ  α ] ->  [  Ringₓ  β ] ->  {  f :  α → β } ->  {  x : α } ->  (  hf :  IsRingHom  f ) ->  (  hx :   f  x =  0 ) ->  x =  0",
    " {  α β :  Type* } ->  [  Ringₓ  α ] ->  [  Ringₓ  β ] ->  {  f :  α → β } ->  (  hf :  IsRingHom  f ) ->  (  x : α ) ->  (  h :   f  x =  0 ) ->  x =  0",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Semiringₓ  α ] ->  [  Semiringₓ  β ] ->  {  f :  α → β } ->  {  x : α } ->  (  hf :  IsSemiringHom  f ) ->   (    f  x =  0  ) →  x =  0",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Ringₓ  α ] ->  [  Ringₓ  β ] ->  {  f :  α → β } ->  {  x : α } ->  (  hf :  IsRingHom  f ) ->  (  hx :   f  x =  0 ) ->  x =  0",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  Ringₓ  α ] ->  [  Ringₓ  β ] ->  {  f :  α → β } ->  (  hf :  IsRingHom  f ) ->  (  a : α ) ->    f  a =  0 →  a =  0"]},
  {"theorem": "∀ {p q : Prop}, (p → q) → q → p",
   "some-correct": null,
   "prompt": "Implication `→` is symmetric. If `P → Q` then `Q → P`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  p q :  Prop } ->  (  h :  p → q ) ->  q → p",
    " {  p q :  Prop } ->  (  h :  Implies  p q ) ->  Implies  q p",
    " {  p q :  Prop } ->  (  h :  Implies  p q ) ->  Implies  q p",
    " {  a b :  Prop } ->  (  h :  a → b ) ->  b → a"]},
  {"theorem": "∀ {m n : ℕ}, m = n ↔ ∃ p, Nat.Prime p ∧ p ∣ m ∧ p ∣ n",
   "some-correct": null,
   "prompt":
   "Two natural numbers are equal if and only if they are both divisible by some prime number.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  m n :  ℕ } ->   m = n ↔  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   p ∣ m ∧  p ∣ n",
    " {  m n :  ℕ } ->   (   ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   p ∣ m ∧  p ∣ n  ) ↔  m = n",
    " {  m n :  ℕ } ->   m = n ↔  ∃    (   p :  ℕ ) ,   Prime  p ∧  (    p ∣ m ∧  p ∣ n  )",
    " {  m n :  ℕ } ->   m = n ↔  (   ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  (    p ∣ m ↔  p ∣ n  )  )",
    " {  a b :  ℕ } ->   a = b ↔  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   a ∣ p ∧  b ∣ p",
    " {  n m :  ℕ } ->   (   ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   p ∣ n ∧  p ∣ m  ) ↔  n = m",
    " {  a b :  ℕ } ->   a = b ↔  ∃    (   x :  ℕ ) ,   Nat.Prime  x ∧   x ∣ a ∧  x ∣ b",
    " {  m n :  ℕ } ->   m = n ↔  ∃     p  :  ℕ ,   Nat.Prime  p ∧   p ∣ m ∧  p ∣ n",
    " (  m n :  ℕ ) ->   m = n ↔  ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧   p ∣ m ∧  p ∣ n"]}],
 "elaborated": 29}