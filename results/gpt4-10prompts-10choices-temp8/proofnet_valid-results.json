[
  {
    "docString": "If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.",
    "prompts": "[{\"theorem\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop}, Reflexive r → ∀ {x y : α}, (x ≠ y → r x y) → r x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a reflexive relation `r : α → α → Prop` holds over `x y : α`,\\nit suffices to show it holds when `x ≠ y`. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (↑r * x) ↔ LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (x * ↑r) ↔ LiouvilleWith p x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\\n`x` satisfies the same condition. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\\n`x` is irrational. \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\":\n  \"∀ {p x : ℝ} {r : ℚ}, LiouvilleWith p x → r ≠ 0 → LiouvilleWith p (x * ↑r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a Liouville number and a nonzero rational number is again a Liouville number.  \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {r : 𝕜},\\n  ‖r‖ < 1 → ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"If `‖r‖ < 1`, then `∑' n : ℕ, n * r ^ n = r / (1 - r) ^ 2`. \"}]\n",
    "prompt_cons": "/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem ∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y :=\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- To show a reflexive relation `r : α → α → Prop` holds over `x y : α`,\nit suffices to show it holds when `x ≠ y`. -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop}, Reflexive r → ∀ {x y : α}, (x ≠ y → r x y) → r x y :=\n\n/-- The product `r * x`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (↑r * x) ↔ LiouvilleWith p x) :=\n\n/-- The product `x * r`, `r : ℚ`, `r ≠ 0`, is a Liouville number with exponent `p` if and only if\n`x` satisfies the same condition. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, r ≠ 0 → (LiouvilleWith p (x * ↑r) ↔ LiouvilleWith p x) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) (m : ℤ), x ^ n = ↑m → (¬∃ y, x = ↑y) → 0 < n → Irrational x :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x :=\n\n/-- The product of a Liouville number and a nonzero rational number is again a Liouville number. -/\ntheorem ∀ {p x : ℝ} {r : ℚ}, LiouvilleWith p x → r ≠ 0 → LiouvilleWith p (x * ↑r) :=\n\n/-- If `‖r‖ < 1`, then `∑' n : ℕ, n * r ^ n = r / (1 - r) ^ 2`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {r : 𝕜},\n  ‖r‖ < 1 → ∑' (n : ℕ), ↑n * r ^ n = r / (1 - r) ^ 2 :=\n\n/-- If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational. -/\ntheorem",
    "choices": [
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
      "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) "
    ]
  },
  {
    "docString": "Prove that there is no rational number whose square is $12$.",
    "prompts": "[{\"theorem\": \"Irrational (Real.sqrt 2)\",\n  \"isProp\": true,\n  \"docString\": \"**Irrationality of the Square Root of 2** \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\": \"Irrational goldenConj\",\n  \"isProp\": true,\n  \"docString\": \"The conjugate of the golden ratio is irrational. \"},\n {\"theorem\": \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\": \"∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real square root is at most the natural square root plus one \"},\n {\"theorem\": \"∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a\",\n  \"isProp\": true,\n  \"docString\": \"The natural square root is at most the real square root \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\": \"∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A rational number has only finitely many good rational approximations. \"},\n {\"theorem\": \"∀ (self : ℚ), self.den ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The denominator is nonzero. \"}]\n",
    "prompt_cons": "/-- **Irrationality of the Square Root of 2** -/\ntheorem Irrational (Real.sqrt 2) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- The conjugate of the golden ratio is irrational. -/\ntheorem Irrational goldenConj :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem ∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0 :=\n\n/-- The real square root is at most the natural square root plus one -/\ntheorem ∀ {a : ℕ}, Real.sqrt ↑a ≤ ↑(Nat.sqrt a) + 1 :=\n\n/-- The natural square root is at most the real square root -/\ntheorem ∀ {a : ℕ}, ↑(Nat.sqrt a) ≤ Real.sqrt ↑a :=\n\n/-- No zero divisors. -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- A rational number has only finitely many good rational approximations. -/\ntheorem ∀ (ξ : ℚ), Set.Finite {q | |ξ - q| < 1 / ↑q.den ^ 2} :=\n\n/-- The denominator is nonzero. -/\ntheorem ∀ (self : ℚ), self.den ≠ 0 :=\n\n/-- Prove that there is no rational number whose square is $12$. -/\ntheorem",
    "choices": [
      "∀ {r : ℚ}, r * r ≠ 12 ",
      "¬∃ (q : ℚ), q * q = 12 ",
      "¬∃ (q : ℚ), q * q = 12 ",
      "∀ {a b : ℤ}, coprime a b → (a:ℚ) / (b:ℚ) ≠ (Real.sqrt (12:ℝ)) ",
      "∀ {r : ℚ}, r * r ≠ 12 ",
      "¬∃ (q : ℚ), q * q = 12 ",
      "¬∃ (q : ℚ), q * q = 12 ",
      "∀ (q : ℚ), q * q ≠ 12 ",
      "¬∃ (q : ℚ), q * q = 12 ",
      "∀ (q : ℚ), q ^ 2 ≠ 12 "
    ]
  },
  {
    "docString": "Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α},\\n  BddBelow s → BddAbove s → Set.Nonempty s → sInf s ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is bounded below and above, and nonempty, its infimum is less than or equal to\\nits supremum.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s\",\n  \"isProp\": true,\n  \"docString\": \"Any lower bound is less than the set infimum. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s t : Set α},\\n  BddBelow s → BddBelow t → Set.Nonempty (s ∩ t) → sInf s ⊔ sInf t ≤ sInf (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The infimum of an intersection of two sets is bounded below by the maximum of the\\ninfima of each set, if all sets are bounded below and nonempty.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a\",\n  \"isProp\": true,\n  \"docString\": \"A least element of a set is the infimum of this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s\",\n  \"isProp\": true,\n  \"docString\": \"Any element of a set is less than the set supremum. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊂ B → Finset.toColex A < Finset.toColex B\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `A ⊂ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\\n`⊆` is not a linear order. \"},\n {\"theorem\": \"∀ {a b : EReal}, a ≤ -b → b ≤ -a\",\n  \"isProp\": true,\n  \"docString\": \"`a ≤ -b → b ≤ -a` on ereal \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},\\n  AntitoneOn f t → s ⊆ t → Set.Nonempty (lowerBounds s ∩ t) → BddAbove (f '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image under an antitone function of a set which is bounded below is bounded above. \"}]\n",
    "prompt_cons": "/-- If a set is bounded below and above, and nonempty, its infimum is less than or equal to\nits supremum. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α},\n  BddBelow s → BddAbove s → Set.Nonempty s → sInf s ≤ sSup s :=\n\n/-- Any lower bound is less than the set infimum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeInf α] (s : Set α) (a : α), (∀ (b : α), b ∈ s → a ≤ b) → a ≤ sInf s :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u)) :=\n\n/-- The infimum of an intersection of two sets is bounded below by the maximum of the\ninfima of each set, if all sets are bounded below and nonempty. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s t : Set α},\n  BddBelow s → BddBelow t → Set.Nonempty (s ∩ t) → sInf s ⊔ sInf t ≤ sInf (s ∩ t) :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- A least element of a set is the infimum of this set. -/\ntheorem ∀ {α : Type u_1} [inst : ConditionallyCompleteLattice α] {s : Set α} {a : α}, IsLeast s a → sInf s = a :=\n\n/-- Any element of a set is less than the set supremum. -/\ntheorem ∀ {α : Type u_1} [self : CompleteSemilatticeSup α] (s : Set α) (a : α), a ∈ s → a ≤ sSup s :=\n\n/-- If `A ⊂ B`, then `A` is less than `B` in the colex order. Note the converse does not hold, as\n`⊆` is not a linear order. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] {A B : Finset α}, A ⊂ B → Finset.toColex A < Finset.toColex B :=\n\n/-- `a ≤ -b → b ≤ -a` on ereal -/\ntheorem ∀ {a b : EReal}, a ≤ -b → b ≤ -a :=\n\n/-- The image under an antitone function of a set which is bounded below is bounded above. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},\n  AntitoneOn f t → s ⊆ t → Set.Nonempty (lowerBounds s ∩ t) → BddAbove (f '' s) :=\n\n/-- Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {A : Set α},\n  BddBelow A → Set.Nonempty A → sInf A = -sSup (Set.image (λ x, -x) A) ",
      "∀ {A : Set ℝ}, BddBelow A → Set.Nonempty A → sInf A = -sSup (Set.image Neg.neg A) ",
      "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {A : Set α},\n  BddBelow A → Set.Nonempty A → sInf A = -sSup (-A) ",
      "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {A : Set α},\n  BddBelow A → Set.Nonempty A → sInf A = -sSup (-A) ",
      "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : AddCommGroup α] [inst_2 : CovariantClass α α (Function.swap HAdd.hAdd) LE.le] {A : Set α},\n  Set.Nonempty A → BddBelow A → sInf A = -sSup (-A) ",
      "∀ {A : Set ℝ}, BddBelow A → Set.Nonempty A → sInf A = -sSup (HasNegPart.neg ⁻¹' A) ",
      "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {A : Set α}, BddBelow A → Set.Nonempty A\n  → sInf A = -sSup (Neg.neg '' A) ",
      "forall {α : Type u_1} [inst : LinearOrderedAddCommGroup α] {s : Set α},\n  BddBelow s → Set.Nonempty s → sInf s = -sSup (Set.image (fun x => -x) s) ",
      "∀ {A : Set ℝ},\n  BddBelow A → Set.Nonempty A → Real.Inf A = -Real.Sup (-A) ",
      "∀ {A : Set ℝ}, BddBelow A → Set.Nonempty A → sInf A = -sSup (-A) "
    ]
  },
  {
    "docString": "If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.",
    "prompts": "[{\"theorem\": \"∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [↑(starRingEnd K) z = z, ∃ r, ↑r = z, ↑(↑IsROrC.re z) = z, ↑IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\":\n  \"∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. \"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < |z|`, then `|S • z| < 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℂ × ℂ}, 0 < p.fst.re ∨ p.fst.im ≠ 0 → ContinuousAt (fun x => x.fst ^ x.snd) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `z ^ w` is continuous in `(z, w)` provided that `z` does not belong to the interval\\n`(-∞, 0]` on the real line. See also `Complex.continuousAt_cpow_zero_of_re_pos` for a version that\\nworks for `z = 0` but assumes `0 < re w`. \"},\n {\"theorem\":\n  \"∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\": \"`Complex.exp z → 0` as `Complex.re z → -∞`.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  (p : FormalMultilinearSeries 𝕜 E F) {r : NNReal},\\n  r ≠ 0 →\\n    ∀ {a : ℝ},\\n      a ∈ Set.Ioo (-1) 1 →\\n        ((fun n => ‖p n‖ * ↑r ^ n) =O[Filter.atTop] fun x => a ^ x) → ↑r < FormalMultilinearSeries.radius p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r ≠ 0` and `‖pₙ‖ rⁿ = O(aⁿ)` for some `-1 < a < 1`, then `r < p.radius`. \"}]\n",
    "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem ∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem ∀ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [↑(starRingEnd K) z = z, ∃ r, ↑r = z, ↑(↑IsROrC.re z) = z, ↑IsROrC.im z = 0] :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. -/\ntheorem ∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem ∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I) :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- If `1 < |z|`, then `|S • z| < 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, 1 < ↑Complex.normSq ↑z → ↑Complex.normSq ↑(ModularGroup.S • z) < 1 :=\n\n/-- The function `z ^ w` is continuous in `(z, w)` provided that `z` does not belong to the interval\n`(-∞, 0]` on the real line. See also `Complex.continuousAt_cpow_zero_of_re_pos` for a version that\nworks for `z = 0` but assumes `0 < re w`. -/\ntheorem ∀ {p : ℂ × ℂ}, 0 < p.fst.re ∨ p.fst.im ≠ 0 → ContinuousAt (fun x => x.fst ^ x.snd) p :=\n\n/-- If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem ∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- `Complex.exp z → 0` as `Complex.re z → -∞`. -/\ntheorem Filter.Tendsto cexp (Filter.comap Complex.re Filter.atBot) (nhds 0) :=\n\n/-- If `r ≠ 0` and `‖pₙ‖ rⁿ = O(aⁿ)` for some `-1 < a < 1`, then `r < p.radius`. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_1} {F : Type u_2} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p : FormalMultilinearSeries 𝕜 E F) {r : NNReal},\n  r ≠ 0 →\n    ∀ {a : ℝ},\n      a ∈ Set.Ioo (-1) 1 →\n        ((fun n => ‖p n‖ * ↑r ^ n) =O[Filter.atTop] fun x => a ^ x) → ↑r < FormalMultilinearSeries.radius p :=\n\n/-- If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$. -/\ntheorem",
    "choices": [
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ ↑Complex.abs w = 1 ∧ z = r • w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), 0 ≤ r ∧ ↑Complex.normSq w = 1 ∧ z = r • w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ w.abs = 1 ∧ z = r * w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ Complex.abs w = 1 ∧ z = r * w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ ↑Complex.normSq w = 1 ∧ z = ↑r * w ",
      "∀ (z : ℂ), ∃ (r : ℝ), r ≥ 0 ∧ ∃ (w : ℂ), Complex.abs w = 1 ∧ z = r * w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ ↑Complex.abs w = 1 ∧ z = ↑r * w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ Complex.abs w = 1 ∧ z = r * w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ ↑Complex.abs w = 1 ∧ z = r * w ",
      "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ w * ↑r = z ∧ ↑Complex.normSq w = 1 "
    ]
  },
  {
    "docString": "If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\\n  ¬SameRay ℝ x y → ‖x + y‖ < ‖x‖ + ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a strictly convex space, if `x` and `y` are not in the same ray, then `‖x + y‖ < ‖x‖ + ‖y‖`.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {f : α → ℝ} (K : ℝ),\\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → f x ≤ f y + K * dist x y) → LipschitzOnWith (Real.toNNReal K) f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\\ndoesn't assume `0≤K`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → ℝ} (K : NNReal),\\n  (∀ (x y : α), f x ≤ f y + ↑K * dist x y) → LipschitzWith K f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\\nassumes `0≤K`. \"},\n {\"theorem\": \"∀ {a b : EReal}, -a ≤ b ↔ -b ≤ a\",\n  \"isProp\": true,\n  \"docString\": \"`-a ≤ b ↔ -b ≤ a` on `EReal`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner (x - y) (x - y) = inner x x - 2 * inner x y + inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Expand `⟪x - y, x - y⟫_ℝ` \"},\n {\"theorem\": \"∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x = y` then `y ≤ x`. Note: this lemma uses `y ≤ x` instead of `x ≥ y`, because `le` is used\\nalmost exclusively in mathlib. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\\n  Set.OrdConnected s ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s\",\n  \"isProp\": true,\n  \"docString\": \"It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. \"},\n {\"theorem\": \"∀ {a b : EReal}, a ≤ -b → b ≤ -a\",\n  \"isProp\": true,\n  \"docString\": \"`a ≤ -b → b ≤ -a` on ereal \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {x y : E},\\n  SameRay ℝ x y → ‖x + y‖ = ‖x‖ + ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\\nspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"}]\n",
    "prompt_cons": "/-- In a strictly convex space, if `x` and `y` are not in the same ray, then `‖x + y‖ < ‖x‖ + ‖y‖`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : StrictConvexSpace ℝ E] {x y : E},\n  ¬SameRay ℝ x y → ‖x + y‖ < ‖x‖ + ‖y‖ :=\n\n/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\ndoesn't assume `0≤K`. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {f : α → ℝ} (K : ℝ),\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → f x ≤ f y + K * dist x y) → LipschitzOnWith (Real.toNNReal K) f s :=\n\n/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\nassumes `0≤K`. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {f : α → ℝ} (K : NNReal),\n  (∀ (x y : α), f x ≤ f y + ↑K * dist x y) → LipschitzWith K f :=\n\n/-- `-a ≤ b ↔ -b ≤ a` on `EReal`. -/\ntheorem ∀ {a b : EReal}, -a ≤ b ↔ -b ≤ a :=\n\n/-- Expand `⟪x - y, x - y⟫_ℝ` -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner (x - y) (x - y) = inner x x - 2 * inner x y + inner y y :=\n\n/-- If `x = y` then `y ≤ x`. Note: this lemma uses `y ≤ x` instead of `x ≥ y`, because `le` is used\nalmost exclusively in mathlib. -/\ntheorem ∀ {α : Type u} [inst : Preorder α] {x y : α}, x = y → y ≤ x :=\n\n/-- It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {s : Set α},\n  Set.OrdConnected s ↔ ∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → x ≤ y → Set.Icc x y ⊆ s :=\n\n/-- `a ≤ -b → b ≤ -a` on ereal -/\ntheorem ∀ {a b : EReal}, a ≤ -b → b ≤ -a :=\n\n/-- If `x` and `y` are on the same ray, then the triangle inequality becomes the equality: the norm\nof `x + y` is the sum of the norms of `x` and `y`. The converse is true for a strictly convex\nspace. -/\ntheorem ∀ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {x y : E},\n  SameRay ℝ x y → ‖x + y‖ = ‖x‖ + ‖y‖ :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$. -/\ntheorem",
    "choices": [
      "∀ {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) ",
      "∀ {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) ",
      "∀ {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) ",
      "∀ {z w : ℂ}, abs (abs z - abs w) ≤ abs (z - w) ",
      "∀ {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) ",
      "∀ {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) ",
      "forall {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) ",
      "∀ {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) ",
      "∀ {x y : ℂ}, abs (∥x∥ - ∥y∥) ≤ ∥x - y∥ ",
      "∀ {x y : ℂ}, abs (abs x - abs y) ≤ abs (x - y) "
    ]
  },
  {
    "docString": "Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.",
    "prompts": "[{\"theorem\": \"∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y\",\n  \"isProp\": true,\n  \"docString\":\n  \"There is an irrational number `r` between any two reals `x < r < y`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\\n  {r : ENNReal}, r < dimH s → ∃ x, x ∈ s ∧ ∀ (t : Set X), t ∈ nhdsWithin x s → r < dimH t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\\nsecond countable topology, then there exists a point `x ∈ s` such that every neighborhood\\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α} {s t : Set α} {r : ENNReal},\\n  x ∈ s → EMetric.hausdorffEdist s t < r → ∃ y, y ∈ t ∧ edist x y < r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the Hausdorff distance is `< r`, then any point in one of the sets has\\na corresponding point at distance `< r` in the other set \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\\nsuch that `r₁ • x = r₂ • y`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} (d : X → X → NNReal) (dist_self : ∀ (x : X), d x x = 0) (dist_comm : ∀ (x y : X), d x y = d y x),\\n  (∀ (x₁ x₂ x₃ x₄ : X), d x₁ x₄ ≤ 2 * max (d x₁ x₂) (max (d x₂ x₃) (d x₃ x₄))) → ∀ (x y : X), ↑(d x y) ≤ 2 * dist x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a function `d : X → X → ℝ≥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y ≤ d x y`, see\\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\\ninequality: `d x₁ x₄ ≤ 2 * max (d x₁ x₂, d x₂ x₃, d x₃ x₄)`. Then `d x y ≤ 2 * dist x y` for all\\n`x`, `y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  (p : FormalMultilinearSeries 𝕜 E F) {r : NNReal},\\n  ↑r < FormalMultilinearSeries.radius p → ∃ C, C > 0 ∧ ∀ (n : ℕ), ‖p n‖ * ↑r ^ n ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  (p : FormalMultilinearSeries 𝕜 E F) {r : NNReal},\\n  ↑r < FormalMultilinearSeries.radius p → ∃ a, a ∈ Set.Ioo 0 1 ∧ ∃ C, C > 0 ∧ ∀ (n : ℕ), ‖p n‖ * ↑r ^ n ≤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` tends to zero exponentially:\\nfor some `0 < a < 1` and `C > 0`, `‖p n‖ * r ^ n ≤ C * a ^ n`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ a, 1 < Pell.Solution₁.x a ∧ 0 < Pell.Solution₁.y a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `d` is a positive integer that is not a square, then there exists a solution\\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α} {r : ℝ},\\n  Set.Nonempty s → (Metric.infDist x s < r ↔ ∃ y, y ∈ s ∧ dist x y < r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` \"}]\n",
    "prompt_cons": "/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem ∀ {x y : ℝ}, x < y → ∃ r, Irrational r ∧ x < r ∧ r < y :=\n\n/-- If `r` is less than the Hausdorff dimension of a set `s` in an (extended) metric space with\nsecond countable topology, then there exists a point `x ∈ s` such that every neighborhood\n`t` of `x` within `s` has Hausdorff dimension greater than `r`. -/\ntheorem ∀ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : TopologicalSpace.SecondCountableTopology X] {s : Set X}\n  {r : ENNReal}, r < dimH s → ∃ x, x ∈ s ∧ ∀ (t : Set X), t ∈ nhdsWithin x s → r < dimH t :=\n\n/-- If the Hausdorff distance is `< r`, then any point in one of the sets has\na corresponding point at distance `< r` in the other set -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {x : α} {s t : Set α} {r : ENNReal},\n  x ∈ s → EMetric.hausdorffEdist s t < r → ∃ y, y ∈ t ∧ edist x y < r :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\nsuch that `r₁ • x = r₂ • y`. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y :=\n\n/-- Consider a function `d : X → X → ℝ≥0` such that `d x x = 0` and `d x y = d y x` for all `x`,\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y ≤ d x y`, see\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\ninequality: `d x₁ x₄ ≤ 2 * max (d x₁ x₂, d x₂ x₃, d x₃ x₄)`. Then `d x y ≤ 2 * dist x y` for all\n`x`, `y`. -/\ntheorem ∀ {X : Type u_1} (d : X → X → NNReal) (dist_self : ∀ (x : X), d x x = 0) (dist_comm : ∀ (x y : X), d x y = d y x),\n  (∀ (x₁ x₂ x₃ x₄ : X), d x₁ x₄ ≤ 2 * max (d x₁ x₂) (max (d x₂ x₃) (d x₃ x₄))) → ∀ (x y : X), ↑(d x y) ≤ 2 * dist x y :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` is bounded. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p : FormalMultilinearSeries 𝕜 E F) {r : NNReal},\n  ↑r < FormalMultilinearSeries.radius p → ∃ C, C > 0 ∧ ∀ (n : ℕ), ‖p n‖ * ↑r ^ n ≤ C :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- For `r` strictly smaller than the radius of `p`, then `‖pₙ‖ rⁿ` tends to zero exponentially:\nfor some `0 < a < 1` and `C > 0`, `‖p n‖ * r ^ n ≤ C * a ^ n`. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  (p : FormalMultilinearSeries 𝕜 E F) {r : NNReal},\n  ↑r < FormalMultilinearSeries.radius p → ∃ a, a ∈ Set.Ioo 0 1 ∧ ∃ C, C > 0 ∧ ∀ (n : ℕ), ‖p n‖ * ↑r ^ n ≤ C * a ^ n :=\n\n/-- If `d` is a positive integer that is not a square, then there exists a solution\nto the Pell equation `x^2 - d*y^2 = 1` with `x > 1` and `y > 0`. -/\ntheorem ∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ a, 1 < Pell.Solution₁.x a ∧ 0 < Pell.Solution₁.y a :=\n\n/-- The minimal distance to a set is `< r` iff there exists a point in this set at distance `< r` -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} {x : α} {r : ℝ},\n  Set.Nonempty s → (Metric.infDist x s < r ↔ ∃ y, y ∈ s ∧ dist x y < r) :=\n\n/-- Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$. -/\ntheorem",
    "choices": [
      "∀ {ℝ : Type u_1} [inst : NontriviallyNormedField ℝ] {k : ℕ} {x y : EuclideanSpace ℝ k} {d r : ℝ},\n  k ≥ 3 → dist x y = d → d > 0 → r > 0 → 2 * r > d → ∃ t, Cardinal.mk (Set {z : EuclideanSpace ℝ k | dist z x = r ∧ dist z y = r}) = t ",
      "∀ {k : ℕ} {x y : ℝ^k} {d r : ℝ},\n  k ≥ 3 → x ≠ y → dist x y = d → d > 0 → r > 0 → 2 * r > d → Set.Infinite {z : ℝ^k | dist z x = r ∧ dist z y = r} ",
      "∀ {k : ℕ} (x y : EuclideanSpace ℝ k) {r d : ℝ}, k ≥ 3 → dist x y = d → d > 0 → r > 0 → 2 * r > d →\n  ∃ f : ℕ → EuclideanSpace ℝ k, Function.Injective f ∧ ∀ n, dist (f n) x = r ∧ dist (f n) y = r ",
      "∀ {k : ℕ} (x y : EuclideanSpace ℝ k) {d r : ℝ},\n  3 ≤ k → dist x y = d → d > 0 → r > 0 → 2 * r > d → ∃ f : ℕ → EuclideanSpace ℝ k, (∀ (n : ℕ), dist (f n) x = r ∧ dist (f n) y = r) ∧ Function.Injective f ",
      "∀ {k : ℕ} [inst : AddCommGroup (Finₓ k)] {x y : Finₓ k → ℝ} {d r : ℝ},\n  3 ≤ k → dist x y = d → d > 0 → r > 0 → 2 * r > d →\n  ∃ (z : ℤ → Finₓ k → ℝ), (∀ n, dist (z n) x = r) ∧ (∀ n, dist (z n) y = r) ∧ ∀ m n, m ≠ n → z m ≠ z n ",
      "∀ {E : Type u_1} [inst : EuclideanSpace E] {x y : E} {r d : ℝ},\n  dim E ≥ 3 → dist x y = d → d > 0 → r > 0 → 2 * r > d → ∃m : ℕ, ∀n : ℕ, n ≥ m →\n  ∃ z, dist z x = r ∧ dist z y = r ",
      "∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : IsScalarTower ℝ 𝕜 E] [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] {k : ℕ} (hk : 3 ≤ k) {x y : E} {d r : ℝ}, dist x y = d → d > 0 → r > 0 → 2 * r > d → ∃ S : Set E, Set.Infinite S ∧ ∀ z ∈ S, dist z x = r ∧ dist z y = r ",
      "∀ {k : ℕ} (x y : EuclideanSpace ℕ k) {d r : ℝ}, k ≥ 3 → dist x y = d → d > 0 → r > 0 → 2 * r > d →\n  ∃ f : ℕ → EuclideanSpace ℕ k, ∀ (n : ℕ), dist (f n) x = r ∧ dist (f n) y = r ",
      "∀ {k : ℕ} {x y : ℝ^k} {r d : ℝ}, 3 ≤ k → dist x y = d → d > 0 → r > 0 → 2 * r > d →\n  ∃ f : ℕ → ℝ^k, (∀ n, dist (f n) x = r ∧ dist (f n) y = r) ∧ ∀ (m n : ℕ), m ≠ n → f m ≠ f n ",
      "∀ {k : ℕ} [inst : Fact (3 ≤ k)] {x y : EuclideanSpace ℝ k} {r d : ℝ},\n  dist x y = d → 0 < d → r > 0 → 2 * r > d → ∃₀ (z : EuclideanSpace ℝ k), dist z x = r ∧ dist z y = r "
    ]
  },
  {
    "docString": "If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$",
    "prompts": "[{\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\\nsuch that `r₁ • x = r₂ • y`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\\n  {B : BilinForm R M}, B ≠ 0 → BilinForm.IsSymm B → ∃ x, ¬BilinForm.IsOrtho B x x\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\\n`x : M` such that `B x x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $(e^{X})^k = e^{kX}$. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} {x y : E}, Dense ↑K → x - y ∈ Kᗮ → x = y\",\n  \"isProp\": true,\n  \"docString\": \"If `S` is dense and `x - y ∈ Kᗮ`, then `x = y`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [inst : CommRing R] [inst_1 : Field K]\\n  [inst_2 : CommRing T] [inst_3 : Algebra R K] [inst_4 : Algebra K T] [inst_5 : Algebra R T]\\n  [inst_6 : IsScalarTower R K T] [inst_7 : CommSemiring U] [inst_8 : Algebra K U] [inst_9 : Algebra R U]\\n  [inst_10 : IsScalarTower R K U] (x : T) (y : U),\\n  ↑(Polynomial.aeval y) (minpoly K x) = 0 → ↑(Polynomial.aeval y) (minpoly R x) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `y` is a conjugate of `x` over a field `K`, then it is a conjugate over a subring `R`. \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0 :=\n\n/-- If `x` and `y` are nonzero vectors on the same ray, then there exist positive numbers `r₁ r₂`\nsuch that `r₁ • x = r₂ • y`. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {x y : M}, SameRay R x y → x ≠ 0 → y ≠ 0 → ∃ r₁ r₂, 0 < r₁ ∧ 0 < r₂ ∧ r₁ • x = r₂ • y :=\n\n/-- There exists a non-null vector with respect to any symmetric, nonzero bilinear form `B`\non a module `M` over a ring `R` with invertible `2`, i.e. there exists some\n`x : M` such that `B x x ≠ 0`. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] [htwo : Invertible 2]\n  {B : BilinForm R M}, B ≠ 0 → BilinForm.IsSymm B → ∃ x, ¬BilinForm.IsOrtho B x x :=\n\n/-- If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. -/\ntheorem ∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0 :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Shows that $(e^{X})^k = e^{kX}$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (k : ℕ),\n  PowerSeries.exp A ^ k = ↑(PowerSeries.rescale ↑k) (PowerSeries.exp A) :=\n\n/-- If `S` is dense and `x - y ∈ Kᗮ`, then `x = y`. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} {x y : E}, Dense ↑K → x - y ∈ Kᗮ → x = y :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulRightInvariant μ :=\n\n/-- If `y` is a conjugate of `x` over a field `K`, then it is a conjugate over a subring `R`. -/\ntheorem ∀ (R : Type u_1) {K : Type u_2} {T : Type u_3} {U : Type u_4} [inst : CommRing R] [inst_1 : Field K]\n  [inst_2 : CommRing T] [inst_3 : Algebra R K] [inst_4 : Algebra K T] [inst_5 : Algebra R T]\n  [inst_6 : IsScalarTower R K T] [inst_7 : CommSemiring U] [inst_8 : Algebra K U] [inst_9 : Algebra R U]\n  [inst_10 : IsScalarTower R K U] (x : T) (y : U),\n  ↑(Polynomial.aeval y) (minpoly K x) = 0 → ↑(Polynomial.aeval y) (minpoly R x) = 0 :=\n\n/-- If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$ -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {x : Fin k → R},\n  2 ≤ k → ∃ y : Fin k → R, y ≠ 0 ∧ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] {x : Finₓ (k+2) → R},\n  ∃ y : Finₓ (k+2) → R, y ≠ 0 ∧ (Finset.sum (Finset.univ : Finset (Finₓ (k+2))) (λ i, x i * y i)) = 0 ",
      "∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {x : Finₓ k → R},\n  2 ≤ k → ∃ y : Finₓ k → R, y ≠ 0 ∧ DotProduct x y = 0 ",
      "∀ {R : Type u_1} {k : ℕ} [inst : Ring R] {x : Finₓ (k + 1) → R},\n  (∃ y : Finₓ (k + 1) → R, y ≠ 0 ∧ Matrix.dotProduct x y = 0) ",
      "∀ {R : Type u_1} {k : ℕ} [inst : Ring R] [inst_1 : Fintype k] [inst_2 : DecidableEq k] [inst_3 : Nontrivial R],\n  2 ≤ k → ∀ (x : k → R), ∃ (y : k → R), y ≠ 0 ∧ (Fintype.sum k fun i => x i * y i) = 0 ",
      "∀ {R : Type u_1} {k : ℕ} [inst : Ring R] [inst_1 : IsDomain R] {x : Finₓ k → R},\n  2 ≤ k → ∃ (y : Finₓ k → R), y ≠ 0 ∧ (Finset.sum Finset.univ fun i => x i * y i) = 0 ",
      "∀ {R : Type u_1} {k : ℕ} [inst : Ring R] [inst_1 : AddCommGroup (Fin k → R)] [inst_2 : Module R (Fin k → R)] (x : Fin k → R),\n  2 ≤ k → ∃ y : Fin k → R, y ≠ 0 ∧ x ⬝ᵥ y = 0 ",
      "∀ {R : Type u_1} {k : ℕ} [inst : Ring R] {x : Finₓ k → R},\n  2 ≤ k → ∃ y : Finₓ k → R, y ≠ 0 ∧ (Finset.sum (Finset.univ : Finset (Finₓ k)) fun i => x i * y i) = 0 ",
      "∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {x : Finₓ k → R},\n  2 ≤ k → ∃ y, y ≠ 0 ∧ (Finset.sum (Finset.range k) fun i => x i * y i) = 0 ",
      "∀ {R : Type u_1} [inst : CommRing R] {k : ℕ}, k ≥ 2 → ∀ (x : Finₓ k → R), ∃ y : Finₓ k → R, y ≠ 0 ∧ (Finₓ.sum x (λ i, x i * y i)) = 0 "
    ]
  },
  {
    "docString": "Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\\n`a` odd and `c` positive. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal a b (-c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] {a b : α}, a ≤ b → ∃ c, b = a * c\",\n  \"isProp\": true,\n  \"docString\": \"For `a ≤ b`, there is a `c` so `b = a * c`. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, a % b = c → b ∣ a - c\",\n  \"isProp\": true,\n  \"docString\": \"If `a % b = c` then `b` divides `a - c`. \"},\n {\"theorem\": \"∀ {a b k : ℕ}, Nat.coprime a b → k ∣ a → k ∣ b → k = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `k:ℕ` divides coprime `a` and `b` then `k = 1` \"}]\n",
    "prompt_cons": "/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has\n`a` odd and `c` positive. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 ∧ 0 < c0 :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has positive `c`. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal a b (-c) :=\n\n/-- We can assume that a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` has `a` odd. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 ∧ a0 % 2 = 1 :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b :=\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 :=\n\n/-- For `a ≤ b`, there is a `c` so `b = a * c`. -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedMonoid α] {a b : α}, a ≤ b → ∃ c, b = a * c :=\n\n/-- If `a % b = c` then `b` divides `a - c`. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → b ∣ a - c :=\n\n/-- If `k:ℕ` divides coprime `a` and `b` then `k = 1` -/\ntheorem ∀ {a b k : ℕ}, Nat.coprime a b → k ∣ a → k ∣ b → k = 1 :=\n\n/-- Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [metric_space R] {k : ℕ} {a b c : R^k} {r : ℝ}, (∀ x : R^k, dist x a = 2 * dist x b ↔ dist x c = r) → 3 * c = 4 * b - a ∧ 3 * r = 2 * dist b a ",
      "∀ {R : Type u_1} [self : NormedRing R] {k : ℕ} {a b c : R} {r : ℝ}, (∀ x : R, ∥x - a∥ = 2 * ∥x - b∥ ↔ ∥x - c∥ = r) → 3 * c = 4 * b - a ∧ 3 * r = 2 * ∥b - a∥ ",
      "∀ {R : Type u_1} [self : NormedRing R] {a b : R}, ∃ c : R, ∃ r : ℝ, (∀ x : R, ∥x - a∥ = 2 * ∥x - b∥ ↔ ∥x - c∥ = r) ∧ 3 * c = 4 * b - a ∧ 3 * r = 2 * ∥b - a∥ ",
      "forall {R : Type u_1} [metric_space R] {k : ℕ} (a b : R^k), ∃ c r, (∀ x, dist x a = 2 * dist x b ↔ dist x c = r) ∧ 3 * c = 4 * b - a ∧ 3 * r = 2 * dist b a ",
      "∀ {R : Type u_1} [metric_space R] {a b c : R} {k : ℕ} {r : ℝ}, (∀ x : R, dist x a = 2 * dist x b ↔ dist x c = r) → 3 * c = 4 * b - a ∧ 3 * r = 2 * dist b a ",
      "forall {R : Type u_1} [self : NormedRing R] {a b c : R} {r : ℝ}, (∀ x, (∥x - a∥ = 2 * ∥x - b∥) ↔ (∥x - c∥ = r)) → 3 * c = 4 * b - a ∧ 3 * r = 2 * ∥b - a∥ ",
      "∀ {R : Type u_1} [metric_space R] {k : ℕ} {a b : R^k}, ∃ c : R^k, ∃ r : ℝ, (∀ x : R^k, (∥x - a∥ = 2 * ∥x - b∥) ↔ (∥x - c∥ = r)) ∧ (3 * c = 4 * b - a) ∧ (3 * r = 2 * ∥b - a∥) ",
      "∀ {R : Type u_1} [MetricSpace R] {k : ℕ} {a b : R^k}, ∃ c : R^k, ∃ r : ℝ, (∀ x : R^k, dist x a = 2 * dist x b ↔ dist x c = r) ∧ (3 * c = 4 * b - a) ∧ (3 * r = 2 * dist b a) ",
      "forall {R : Type u_1} [metric_space R] (a b : R), ∃ c r, r > 0 ∧ (∀ x, dist x a = 2 * dist x b ↔ dist x c = r) ∧ 3 * c = 4 * b - a ∧ 3 * r = 2 * dist b a ",
      "∀ {R : Type u_1} [self : NormedRing R] [k : ℕ] {a b c : R^k} {r : ℝ}, (∀ x : R^k, (∥x - a∥ = 2 * ∥x - b∥) ↔ (∥x - c∥ = r)) → (3 * c = 4 * b - a) ∧ (3 * r = 2 * ∥b - a∥) "
    ]
  },
  {
    "docString": "Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.",
    "prompts": "[{\"theorem\":\n  \"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\\n  TopologicalSpace.SeparableSpace ((i : ι) → X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : DiscreteTopology α], TopologicalSpace.SeparableSpace α ↔ Countable α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A topological space with discrete topology is separable iff it is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α], ∃ f, Isometry f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every separable metric space embeds isometrically in `ℓ^∞(ℕ)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\\n  TopologicalSpace.SeparableSpace (α × β)\",\n  \"isProp\": true,\n  \"docString\": \"The product of two separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι},\\n  Set.PairwiseDisjoint a s →\\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {f : β → α} [inst_1 : TopologicalSpace β],\\n  Inducing f → ∀ {s : Set α}, TopologicalSpace.IsSeparable s → TopologicalSpace.IsSeparable (f ⁻¹' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The preimage of a separable set by an inducing map is separable. \"}]\n",
    "prompt_cons": "/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem ∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  TopologicalSpace.SeparableSpace ((i : ι) → X i) :=\n\n/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t :=\n\n/-- A topological space with discrete topology is separable iff it is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : DiscreteTopology α], TopologicalSpace.SeparableSpace α ↔ Countable α :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- Every separable metric space embeds isometrically in `ℓ^∞(ℕ)`. -/\ntheorem ∀ (α : Type u) [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α], ∃ f, Isometry f :=\n\n/-- The product of two separable spaces is a separable space. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {β : Type u_1} [inst : TopologicalSpace β]\n  [inst_1 : TopologicalSpace.SeparableSpace α] [inst_2 : TopologicalSpace.SeparableSpace β],\n  TopologicalSpace.SeparableSpace (α × β) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a :=\n\n/-- The preimage of a separable set by an inducing map is separable. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] {f : β → α} [inst_1 : TopologicalSpace β],\n  Inducing f → ∀ {s : Set α}, TopologicalSpace.IsSeparable s → TopologicalSpace.IsSeparable (f ⁻¹' s) :=\n\n/-- Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable. -/\ntheorem",
    "choices": [
      "forall {α : Type u} [inst : MetricSpace α] [inst_1 : ∀ s : Set α, Set.Infinite s → ∃ x, IsLimitPoint s x],\n  TopologicalSpace.SeparableSpace α ",
      "∀ (X : Type u) [inst : MetricSpace X] [inst_1 : TopologicalSpace X], \n  (∀ s : Set X, Set.Infinite s → ∃ x, IsLimitPoint s x) → TopologicalSpace.SeparableSpace X ",
      "forall {α : Type u} [inst : MetricSpace α] (h : ∀ s : Set α, Set.Infinite s → ∃ x, IsLimitPoint s x),\n  TopologicalSpace.SeparableSpace α ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : ∀ s : Set α, Set.Infinite s → ∃ x, IsLimitPoint s x],\n  TopologicalSpace.SeparableSpace α ",
      "∀ {α : Type u} [inst : MetricSpace α] (h : ∀ s : Set α, Set.Infinite s → ∃ x, IsLimitPoint s x),\n  TopologicalSpace.SeparableSpace α ",
      "forall {α : Type u} [t : MetricSpace α] [inst : TopologicalSpace.SecondCountableTopology α],\n  (∀ s : Set α, Set.Infinite s → ∃ x ∈ s, IsLimitPoint s x) → TopologicalSpace.SeparableSpace α ",
      "∀ (α : Type u) [inst : MetricSpace α] [inst_1 : TopologicalSpace.HasInfiniteSubsetLimitPoint α],\n  TopologicalSpace.SeparableSpace α ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : ∀ (s : Set α), Set.Infinite s → ∃ x, IsLimitPoint s x],\n  TopologicalSpace.SeparableSpace α ",
      "∀ (α : Type u) [inst : MetricSpace α] [inst_1 : ∀ (s : Set α), Set.Infinite s → ∃ x, IsLimitPoint s x],\n  TopologicalSpace.SeparableSpace α ",
      "forall {α : Type u} [inst : MetricSpace α] [hp : ∀ (s : Set α), Set.Infinite s → ∃ (x : α), IsPreirreducible s x],\n  TopologicalSpace.SeparableSpace α "
    ]
  },
  {
    "docString": "Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {K : Set α},\\n  IsComplete K → ∀ {u : β → α}, (∀ (n : β), u n ∈ K) → CauchySeq u → ∃ v, v ∈ K ∧ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : EMetricSpace α] {K : NNReal} {f : α → α} {s : Set α},\\n  IsComplete s →\\n    ∀ (hsf : Set.MapsTo f s s),\\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) →\\n        ∀ {x : α},\\n          x ∈ s →\\n            edist x (f x) ≠ ⊤ →\\n              ∃ y,\\n                y ∈ s ∧\\n                  Function.IsFixedPt f y ∧\\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) ∧\\n                      ∀ (n : ℕ), edist (f^[n] x) y ≤ edist x (f x) * ↑K ^ n / (1 - ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Banach fixed-point theorem for maps contracting on a complete subset. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ∃ V D, Set.Countable V ∧ Perfect D ∧ C = V ∪ D\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\\ncan be written as the union of a countable set and a perfect set.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [inst : MetricSpace β]\\n  {μ : MeasureTheory.Measure α} [inst_1 : SemilatticeSup ι] [inst_2 : Nonempty ι] [inst_3 : Countable ι] {f : ι → α → β}\\n  {g : α → β} [inst_4 : MeasureTheory.IsFiniteMeasure μ],\\n  (∀ (n : ι), MeasureTheory.StronglyMeasurable (f n)) →\\n    MeasureTheory.StronglyMeasurable g →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\\n        ∀ {ε : ℝ}, 0 < ε → ∃ t, MeasurableSet t ∧ ↑↑μ t ≤ ENNReal.ofReal ε ∧ TendstoUniformlyOn f g Filter.atTop tᶜ\",\n  \"isProp\": true,\n  \"docString\": \"Egorov's theorem for finite measure spaces. \"},\n {\"theorem\":\n  \"∀ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C U : Set α}, Preperfect C → IsOpen U → Preperfect (U ∩ C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a preperfect set and an open set is preperfect. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\\n  (s : Set β),\\n  IsCompact s →\\n    ∀ (A : Set (BoundedContinuousFunction α β)),\\n      IsClosed A →\\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"}]\n",
    "prompt_cons": "/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {K : Set α},\n  IsComplete K → ∀ {u : β → α}, (∀ (n : β), u n ∈ K) → CauchySeq u → ∃ v, v ∈ K ∧ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f :=\n\n/-- Banach fixed-point theorem for maps contracting on a complete subset. -/\ntheorem ∀ {α : Type u_1} [inst : EMetricSpace α] {K : NNReal} {f : α → α} {s : Set α},\n  IsComplete s →\n    ∀ (hsf : Set.MapsTo f s s),\n      ContractingWith K (Set.MapsTo.restrict f s s hsf) →\n        ∀ {x : α},\n          x ∈ s →\n            edist x (f x) ≠ ⊤ →\n              ∃ y,\n                y ∈ s ∧\n                  Function.IsFixedPt f y ∧\n                    Filter.Tendsto (fun n => f^[n] x) Filter.atTop (nhds y) ∧\n                      ∀ (n : ℕ), edist (f^[n] x) y ≤ edist x (f x) * ↑K ^ n / (1 - ↑K) :=\n\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ∃ V D, Set.Countable V ∧ Perfect D ∧ C = V ∪ D :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Egorov's theorem for finite measure spaces. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [inst : MetricSpace β]\n  {μ : MeasureTheory.Measure α} [inst_1 : SemilatticeSup ι] [inst_2 : Nonempty ι] [inst_3 : Countable ι] {f : ι → α → β}\n  {g : α → β} [inst_4 : MeasureTheory.IsFiniteMeasure μ],\n  (∀ (n : ι), MeasureTheory.StronglyMeasurable (f n)) →\n    MeasureTheory.StronglyMeasurable g →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\n        ∀ {ε : ℝ}, 0 < ε → ∃ t, MeasurableSet t ∧ ↑↑μ t ≤ ENNReal.ofReal ε ∧ TendstoUniformlyOn f g Filter.atTop tᶜ :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem ∀ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- The intersection of a preperfect set and an open set is preperfect. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C U : Set α}, Preperfect C → IsOpen U → Preperfect (U ∩ C) :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\n  (s : Set β),\n  IsCompact s →\n    ∀ (A : Set (BoundedContinuousFunction α β)),\n      IsClosed A →\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A :=\n\n/-- Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  let P : Set α ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : IsROrC ℝ],\n  ∀ {E : Set α}, ¬Set.Countable E → IsClosed (CondensationPoints E) ∧ Perfect (CondensationPoints E) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] {E : Set α},\n  ¬Set.Countable E → Perfect (CondensationPoints E) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] {E : Set α} [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace.SecondCountableTopology α]\n  [inst_3 : OrderTopology α],\n  ¬Set.Countable E → ∃ P, Perfect P ∧ P ⊆ E ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : T2Space α],\n  ∀ (E : Set α) (P : Set α), IsUncountable E → P = CondensationPoints E → Perfect P ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] {E : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  ¬Set.Countable E → ∃ P, Perfect P ∧ CondensationPoints α E ⊆ P ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  (∀ E : Set α, ¬Set.Countable E → ∃ P, IsClosed P ∧ Set.Nonempty P ∧ P ⊆ E ∧ Perfect P) →\n    ∀ {E : Set α}, ¬Set.Countable E → Perfect (CondensationPoints E) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] {E : Set α},\n  ¬Set.Countable E →\n    let P ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] {E : Set α},\n  ¬Set.Countable E → IsClosed (CondensationPoints E) ∧ Perfect (CondensationPoints E) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] {E : Set α},\n  ¬Set.Countable E →\n    IsPerfect (SetOf (CondensationPoint E)) "
    ]
  },
  {
    "docString": "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
    "prompts": "[{\"theorem\":\n  \"∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in an emetric space is separable, i.e., it is the closure of a countable set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\\ncountable set.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ∃ V D, Set.Countable V ∧ Perfect D ∧ C = V ∪ D\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\\ncan be written as the union of a countable set and a perfect set.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι},\\n  Set.PairwiseDisjoint a s →\\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\\n  CompleteSpace ((i : ι) × E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\\n  TopologicalSpace.SeparableSpace ((i : ι) → X i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of a countable family of separable spaces is a separable space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of disjoint sets with nonempty interiors is countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {As : ι → Set α},\\n  (∀ (i : ι), MeasurableSet (As i)) →\\n    Pairwise (Disjoint on As) → ↑↑μ (⋃ (i : ι), As i) ≠ ⊤ → Set.Countable {i | 0 < ↑↑μ (As i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the union of disjoint measurable sets has finite measure, then there are only\\ncountably many members of the union whose measure is positive. \"}]\n",
    "prompt_cons": "/-- A compact set in an emetric space is separable, i.e., it is the closure of a countable set. -/\ntheorem ∀ {γ : Type w} [inst : EMetricSpace γ] {s : Set γ}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s = closure t :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- A compact set in a pseudo emetric space is separable, i.e., it is a subset of the closure of a\ncountable set. -/\ntheorem ∀ {α : Type u} [inst : PseudoEMetricSpace α] {s : Set α}, IsCompact s → ∃ t, t ⊆ s ∧ Set.Countable t ∧ s ⊆ closure t :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ∃ V D, Set.Countable V ∧ Perfect D ∧ C = V ∪ D :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\n  CompleteSpace ((i : ι) × E i) :=\n\n/-- The product of a countable family of separable spaces is a separable space. -/\ntheorem ∀ {ι : Type u_1} {X : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (X i)]\n  [inst_1 : ∀ (i : ι), TopologicalSpace.SeparableSpace (X i)] [inst_2 : Countable ι],\n  TopologicalSpace.SeparableSpace ((i : ι) → X i) :=\n\n/-- In a separable space, a family of disjoint sets with nonempty interiors is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι}, Set.PairwiseDisjoint a s → (∀ (i : ι), i ∈ a → Set.Nonempty (interior (s i))) → Set.Countable a :=\n\n/-- If the union of disjoint measurable sets has finite measure, then there are only\ncountably many members of the union whose measure is positive. -/\ntheorem ∀ {α : Type u_2} {ι : Type u_1} [inst : MeasurableSpace α] (μ : MeasureTheory.Measure α) {As : ι → Set α},\n  (∀ (i : ι), MeasurableSet (As i)) →\n    Pairwise (Disjoint on As) → ↑↑μ (⋃ (i : ι), As i) ≠ ⊤ → Set.Countable {i | 0 < ↑↑μ (As i)} :=\n\n/-- Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t, Perfect t ∧ Set.Countable t ∧ s = closure (s \\ t) ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂ ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {A : Set α},\n  IsClosed A → ∃ P C, Perfect P ∧ Set.Countable C ∧ A = P ∪ C ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t, Perfect t ∧ Set.Countable t ∧ s = closure t ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂ ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t, Perfect t ∧ Set.Countable t ∧ s = Closure t ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t p, Set.Countable t ∧ Perfect p ∧ s = t ∪ p ",
      "∀ {γ : Type w} [inst : MetricSpace γ] [inst_1 : TopologicalSpace.SeparableSpace γ] {s : Set γ},\n  IsClosed s → ∃ t, Perfect t ∧ Set.Countable t ∧ s = closure t ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {C : Set α},\n  IsClosed C → ∃ V D, Set.Countable V ∧ Perfect D ∧ C = V ∪ D ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {C : Set α},\n  IsClosed C → ∃ D V, Perfect D ∧ Set.Countable V ∧ C = D ∪ V "
    ]
  },
  {
    "docString": "Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\\n  (b : β → ℝ), (∀ (n m : β), n ≤ m → dist (s n) (s m) ≤ b n) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n ≤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SigmaFinite ν] {s : Set (α × β)},\\n  ↑↑(MeasureTheory.Measure.prod μ ν) s = 0 → (fun x => ↑↑ν (Prod.mk x ⁻¹' s)) =ᶠ[MeasureTheory.Measure.ae μ] 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι} {c : β},\\n  Filter.Tendsto (↿F) (p ×ˢ Filter.principal s) (nhds c) ↔ TendstoUniformlyOn F (fun x => c) p s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence on a set `s` to a constant function is equivalent to convergence in\\n`p ×ˢ 𝓟 s`. \"}]\n",
    "prompt_cons": "/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If the distance between `s n` and `s m`, `n ≤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\n  (b : β → ℝ), (∀ (n m : β), n ≤ m → dist (s n) (s m) ≤ b n) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- Note: the converse is not true without assuming that `s` is measurable. For a counterexample,\nsee Walter Rudin *Real and Complex Analysis*, example (c) in section 8.9. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {μ : MeasureTheory.Measure α}\n  {ν : MeasureTheory.Measure β} [inst_2 : MeasureTheory.SigmaFinite ν] {s : Set (α × β)},\n  ↑↑(MeasureTheory.Measure.prod μ ν) s = 0 → (fun x => ↑↑ν (Prod.mk x ⁻¹' s)) =ᶠ[MeasureTheory.Measure.ae μ] 0 :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p ×ˢ 𝓟 s`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {s : Set α} {p : Filter ι} {c : β},\n  Filter.Tendsto (↿F) (p ×ˢ Filter.principal s) (nhds c) ↔ TendstoUniformlyOn F (fun x => c) p s :=\n\n/-- Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : LinearOrderedField α] [inst_1 : Archimedean α] {f : β → α},\n  Filter.Tendsto f Filter.atTop Filter.atInfty → Filter.Tendsto (fun x => abs (f x)) Filter.atTop Filter.atInfty ",
      "∀ {α : Type u} {s : ℕ → ℝ}, Filter.Tendsto s Filter.atTop (nhds α) → Filter.Tendsto (fun n => abs (s n)) Filter.atTop (nhds (abs α)) ",
      "∀ {α : Type u} [inst : NormedGroup α] {s : ℕ → α} {a : α},\n  Filter.Tendsto s Filter.atTop (nhds a) →\n    Filter.Tendsto (fun n => ∥s n∥) Filter.atTop (nhds (∥a∥)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α] [inst_2 : OrderTopology α]\n  {s : ℕ → α} {a : α}, Filter.Tendsto s Filter.atTop (nhds a) → Filter.Tendsto (fun n => |s n|) Filter.atTop (nhds |a|) ",
      "∀ {β : Type u_1} [inst : NormedGroup β] {s : ℕ → β}, Filter.Tendsto s Filter.atTop (nhds 0) → Filter.Tendsto (fun n => ∥s n∥) Filter.atTop (nhds 0) ",
      "∀ {α : Type u} {f : ℕ → α} [inst : TopologicalSpace α] [inst_1 : LinearOrderedAddCommGroup α] [inst_2 : OrderTopology α],\n  Filter.Tendsto f Filter.atTop (nhds 0) → Filter.Tendsto (fun n => abs (f n)) Filter.atTop (nhds 0) ",
      "∀ {α : Type u} {β : Type v} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : OrderTopology α] {s : β → α}\n  (hs : Filter.Tendsto s Filter.atTop (nhds 0)), Filter.Tendsto (fun b => abs (s b)) Filter.atTop (nhds 0) ",
      "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α} {b : β → ℝ},\n  CauchySeq s → CauchySeq (fun n => abs (s n)) ",
      "forall {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : ℕ → α} {f : α → β} {r : ℝ}\n  (H : ∀ n, abs (f (s n)) ≤ r), Filter.Tendsto s Filter.atTop (nhds (f r)) → Filter.Tendsto (fun n => abs (f (s n))) Filter.atTop (nhds (abs (f r))) ",
      "∀ {α : Type u} [inst : Preorder α] [inst_1 : OrderedAddCommMonoid α] {f : ℕ → α},\n  (∀ (n : ℕ), f n ≤ f (n + 1)) → ∀ (n : ℕ), abs (f n) ≤ abs (f (n + 1)) "
    ]
  },
  {
    "docString": "If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\\n  (b : β → ℝ), (∀ (n m : β), n ≤ m → dist (s n) (s m) ≤ b n) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n ≤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\\n  (b : β → ℝ),\\n  (∀ (n m N : β), N ≤ n → N ≤ m → dist (s n) (s m) ≤ b N) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n, m ≥ N` is bounded above by `b N`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi\",\n  \"isProp\": true,\n  \"docString\":\n  \"From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℝ},\\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a\",\n  \"isProp\": true,\n  \"docString\":\n  \"From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. \"},\n {\"theorem\":\n  \"∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {s : ℝ}, 0 < s → MeasureTheory.IntegrableOn (fun x => rexp (-x) * x ^ (s - 1)) (Set.Ioi 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Euler integral for the `Γ` function converges for positive real `s`. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"},\n {\"theorem\":\n  \"∀ {S : Set ℕ+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : ℕ+}, n ∈ S → ∃ r, IsPrimitiveRoot r ↑n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. \"}]\n",
    "prompt_cons": "/-- If the distance between `s n` and `s m`, `n ≤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\n  (b : β → ℝ), (∀ (n m : β), n ≤ m → dist (s n) (s m) ≤ b n) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s :=\n\n/-- If the distance between `s n` and `s m`, `n, m ≥ N` is bounded above by `b N`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\n  (b : β → ℝ),\n  (∀ (n m N : β), N ≤ n → N ≤ m → dist (s n) (s m) ≤ b N) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- From an upper bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`sqrtTwoAddSeries 0 n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2)`, one can deduce the lower bound `a < π`\nthanks to basic trigonometric inequalities as expressed in `pi_gt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ}, Real.sqrtTwoAddSeries (↑0 / ↑1) n ≤ 2 - (a / 2 ^ (n + 1)) ^ 2 → a < Real.pi :=\n\n/-- From a lower bound on `sqrtTwoAddSeries 0 n = 2 cos (π / 2 ^ (n+1))` of the form\n`2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ sqrtTwoAddSeries 0 n`, one can deduce the upper bound\n`π < a` thanks to basic trigonometric formulas as expressed in `pi_lt_sqrtTwoAddSeries`. -/\ntheorem ∀ (n : ℕ) {a : ℝ},\n  2 - ((a - 1 / 4 ^ n) / 2 ^ (n + 1)) ^ 2 ≤ Real.sqrtTwoAddSeries (↑0 / ↑1) n → 1 / 4 ^ n ≤ a → Real.pi < a :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem ∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- The Euler integral for the `Γ` function converges for positive real `s`. -/\ntheorem ∀ {s : ℝ}, 0 < s → MeasureTheory.IntegrableOn (fun x => rexp (-x) * x ^ (s - 1)) (Set.Ioi 0) :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem ∀ {S : Set ℕ+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : ℕ+}, n ∈ S → ∃ r, IsPrimitiveRoot r ↑n :=\n\n/-- If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : ℕ → α}\n  (hs : ∀ n, s (n + 1) = Real.sqrt (2 + s n)) : CauchySeq s ∧ ∀ n, s n < 2 ",
      "∀ (n : ℕ),\n  Real.sqrt (2 + Real.sqrt (Real.sqrtTwoAddSeries (↑0 / ↑1) n)) < 2 ∧ Real.sqrtTwoAddSeries (↑0 / ↑1) n < 2 ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : ℕ → α}, \n  (∀ (n : ℕ), dist (s n) (s (n + 1)) ≤ (1 / 2) ^ n) → CauchySeq s ∧ ∀ n, s n < 2 ",
      "∀ (n : ℕ), 0 < Real.sqrtTwoAddSeries (↑0 / ↑1) n ∧ Real.sqrtTwoAddSeries (↑0 / ↑1) n < 2 ",
      "∀ (n : ℕ), 0 < Real.sqrtTwoAddSeries (↑0 / ↑1) n ∧ Real.sqrtTwoAddSeries (↑0 / ↑1) n < 2 ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : ℕ → α},\n  (∀ (n : ℕ), dist (s n) (s (n + 1)) ≤ (1 / 2) ^ n) → ∃ l, Filter.Tendsto s Filter.atTop (nhds l) ∧ ∀ n, s n < 2 ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : ℕ → α},\n  (∀ (n : ℕ), dist (s (n + 1)) (s n) ≤ (1 / 2) ^ n) → (∀ n, s n < 2) → CauchySeq s ",
      "∀ {α : Type u} [inst : PseudoMetricSpace α] {s : ℕ → α}, (s 0 = Real.sqrt 2) → (∀ (n : ℕ), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) →\n  Filter.Tendsto s Filter.atTop (nhds (Real.sqrt 2)) ∧ ∀ (n : ℕ), s n < 2 ",
      "{α : ℕ} → (Real.sqrtTwoAddSeries (↑0 / ↑1) α < 2) ",
      "∀ (n : ℕ), 0 < Real.sqrtTwoAddSeries (↑0 / ↑1) n ∧ Real.sqrtTwoAddSeries (↑0 / ↑1) n < 2 "
    ]
  },
  {
    "docString": "Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2\",\n  \"isProp\": true,\n  \"docString\": \"Bessel's inequality for finite sums. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : AddCommGroup α] [inst_1 : UniformSpace α] [inst_2 : CompleteSpace α]\\n  {f : β → α}, Summable f ↔ CauchySeq fun s => Finset.sum s fun b => f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `𝓝 a` as `x → ∞` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_3} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : α → ℝ}\\n  {f : α → β → F},\\n  Summable u →\\n    (∀ (n : α) (x : β), ‖f n x‖ ≤ u n) →\\n      TendstoUniformly (fun t x => Finset.sum t fun n => f n x) (fun x => ∑' (n : α), f n x) Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\\nVersion with general index set. \"}]\n",
    "prompt_cons": "/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Bessel's inequality for finite sums. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_3} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {ι : Type u_1} (x : E) {v : ι → E} {s : Finset ι},\n  Orthonormal 𝕜 v → (Finset.sum s fun i => ‖inner (v i) x‖ ^ 2) ≤ ‖x‖ ^ 2 :=\n\n/-- The **Cauchy criterion** for infinite sums, also known as the **Cauchy convergence test** -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommGroup α] [inst_1 : UniformSpace α] [inst_2 : CompleteSpace α]\n  {f : β → α}, Summable f ↔ CauchySeq fun s => Finset.sum s fun b => f b :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- proof that a monotone function tends to `𝓝 a` as `x → ∞` -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- An infinite sum of functions with summable sup norm is the uniform limit of its partial sums.\nVersion with general index set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_3} {F : Type u_2} [inst : NormedAddCommGroup F] [inst_1 : CompleteSpace F] {u : α → ℝ}\n  {f : α → β → F},\n  Summable u →\n    (∀ (n : α) (x : β), ‖f n x‖ ≤ u n) →\n      TendstoUniformly (fun t x => Finset.sum t fun n => f n x) (fun x => ∑' (n : α), f n x) Filter.atTop :=\n\n/-- Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (λ n : ℕ, Finset.sum (Finset.range n) (λ i => Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "lim_eq_infty_of_sum_eq_infty : Filter.Tendsto (fun n : ℕ => Finset.sum (Finset.range n) (λ i => Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α], Filter.Tendsto (λ n, Finset.sum (Finset.range n) (λ i, Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "Filter.Tendsto (λ n => Finset.sum (Finset.range n) (λ i => Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : TopologicalSpace α],\n  Filter.Tendsto (λ n, Finset.sum (Finset.range n) (λ i => Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.at_top ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (λ n : ℕ, Finset.sum (Finset.range n) (λ i => sqrt (↑i + 1) - sqrt ↑i)) Filter.atTop Filter.atTop ",
      "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α], Filter.Tendsto (λ n, Finset.sum (Finset.range n) (λ i, Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α] [inst_2 : TopologicalSpace α] [OrderTopology α], Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => (Real.sqrt (i + 1) - Real.sqrt i)) Filter.atTop Filter.atTop ",
      "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto (λ i, (sqrt (i + 1) - sqrt i)) Filter.atTop Filter.atTop "
    ]
  },
  {
    "docString": "If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\\n  (∀ (n : ℕ), Measurable (f n)) →\\n    (∀ (n : ℕ), f (Nat.succ n) ≤ᶠ[MeasureTheory.Measure.ae μ] f n) →\\n      ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤ → ∫⁻ (a : α), ⨅ (n : ℕ), f n a ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Monotone convergence theorem for nonincreasing sequences of functions \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `𝓝 a` as `x → ∞` \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n ≤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. \"},\n {\"theorem\":\n  \"∀ {u : ℕ → ℝ} (h : Subadditive u),\\n  BddBelow (Set.range fun n => u n / ↑n) → Filter.Tendsto (fun n => u n / ↑n) Filter.atTop (nhds (Subadditive.lim h))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Fekete's lemma: a subadditive sequence which is bounded below converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\\n  (b : β → ℝ), (∀ (n m : β), n ≤ m → dist (s n) (s m) ≤ b n) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the distance between `s n` and `s m`, `n ≤ m` is bounded above by `b n`\\nand `b` converges to zero, then `s` is a Cauchy sequence.  \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\\n  Metric.Bounded s →\\n    ∀ {x : ℕ → X},\\n      (∀ (n : ℕ), x n ∈ s) → ∃ a, a ∈ closure s ∧ ∃ φ, StrictMono φ ∧ Filter.Tendsto (x ∘ φ) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A version of Bolzano-Weistrass: in a proper metric space (eg. $ℝ^n$),\\nevery bounded sequence has a converging subsequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\\n  [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α] {f : Filter β} {u : β → α} {s : Set α},\\n  Dense s →\\n    (∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a < b → ¬((∃ᶠ (n : β) in f, u n < a) ∧ ∃ᶠ (n : β) in f, b < u n)) →\\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) f u) _auto✝ →\\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≥ x_1) f u) _auto✝¹ → ∃ c, Filter.Tendsto u f (nhds c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\\nworks if `a` and `b` are restricted to a dense subset.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\\n  CauchySeq u →\\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop →\\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"}]\n",
    "prompt_cons": "/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- Monotone convergence theorem for nonincreasing sequences of functions -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal},\n  (∀ (n : ℕ), Measurable (f n)) →\n    (∀ (n : ℕ), f (Nat.succ n) ≤ᶠ[MeasureTheory.Measure.ae μ] f n) →\n      ∫⁻ (a : α), f 0 a ∂μ ≠ ⊤ → ∫⁻ (a : α), ⨅ (n : ℕ), f n a ∂μ = ⨅ (n : ℕ), ∫⁻ (a : α), f n a ∂μ :=\n\n/-- proof that a monotone function tends to `𝓝 a` as `x → ∞` -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n ≤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- Fekete's lemma: a subadditive sequence which is bounded below converges. -/\ntheorem ∀ {u : ℕ → ℝ} (h : Subadditive u),\n  BddBelow (Set.range fun n => u n / ↑n) → Filter.Tendsto (fun n => u n / ↑n) Filter.atTop (nhds (Subadditive.lim h)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- If the distance between `s n` and `s m`, `n ≤ m` is bounded above by `b n`\nand `b` converges to zero, then `s` is a Cauchy sequence. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {s : β → α}\n  (b : β → ℝ), (∀ (n m : β), n ≤ m → dist (s n) (s m) ≤ b n) → Filter.Tendsto b Filter.atTop (nhds 0) → CauchySeq s :=\n\n/-- A version of Bolzano-Weistrass: in a proper metric space (eg. $ℝ^n$),\nevery bounded sequence has a converging subsequence. -/\ntheorem ∀ {X : Type u_1} [inst : PseudoMetricSpace X] [inst_1 : ProperSpace X] {s : Set X},\n  Metric.Bounded s →\n    ∀ {x : ℕ → X},\n      (∀ (n : ℕ), x n ∈ s) → ∃ a, a ∈ closure s ∧ ∃ φ, StrictMono φ ∧ Filter.Tendsto (x ∘ φ) Filter.atTop (nhds a) :=\n\n/-- Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α]\n  [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α] {f : Filter β} {u : β → α} {s : Set α},\n  Dense s →\n    (∀ (a : α), a ∈ s → ∀ (b : α), b ∈ s → a < b → ¬((∃ᶠ (n : β) in f, u n < a) ∧ ∃ᶠ (n : β) in f, b < u n)) →\n      autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≤ x_1) f u) _auto✝ →\n        autoParam (Filter.IsBoundedUnder (fun x x_1 => x ≥ x_1) f u) _auto✝¹ → ∃ c, Filter.Tendsto u f (nhds c) :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedCommSemiring α] [inst_1 : OrderedCommMonoid β] [inst_2 : Encodable β]\n  {f : α → β} {g : α → β},\n  Let h ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedCommSemiring α] [inst_1 : OrderedAddCommMonoid β] {a : ℕ → α} {b : ℕ → β},\n  (HasSum a (α ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedCommMonoid α] [inst_1 : OrderedCommMonoid β] {a : ℕ → α} {b : ℕ → β},\n  HasSum a → Monotone b → BddAbove (Set.Range b) → HasSum (fun n => a n * b n) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedCommMonoid α] [inst_1 : OrderedCommMonoid β] {f : ℕ → α} {g : ℕ → β},\n  Filter.Tendsto f Filter.atTop (nhds 1) →\n    (∀ (n : ℕ), g n ≤ g (n + 1)) → BddAbove (Set.range g) →\n      Filter.Tendsto (fun n => f n * g n) Filter.atTop (nhds 1) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedCancelAddCommMonoid α] [inst_1 : LinearOrderedField β] [inst_2 : TopologicalSpace β]\n  [inst_3 : OrderClosedTopology β] [inst_4 : HasSum (λ n, u n) a] {u : ℕ → α} {a : α} {v : ℕ → β},\n  Monotone v →\n    BddAbove (Set.range v) →\n      HasSum (λ n => u n • v n) (a • sup (Set.range v)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedAddCommGroup α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : HasContinuousSub α] [inst_4 : HasContinuousAdd α] {a : ℕ → α} {b : ℕ → β} [inst_5 : Nonempty β] [inst_6 : SemilatticeSup β]\n  [inst_7 : NoMinOrder β] [inst_8 : CovariantClass β β HAdd.hAdd LE.le],\n  Filter.Tendsto a Filter.atTop (nhds 0) →\n    Filter.IsBounded LE.le (Filter.map b Filter.atTop) →\n      DirectSum.IsSeqCovariant ℕ β (λ (n : ℕ), a n * b n) LE.le → Filter.Tendsto (λ (n : ℕ), a n * b n) Filter.atTop (nhds 0) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedCommRing α] [inst_1 : OrderedCommRing β]\n  [inst_2 : NoZeroSmulDivisors α β] [inst_3 : NoZeroSmulDivisors β α] [inst_4 : IsModular α β] {a : ℕ → α} {b : ℕ → β},\n  Summable a →\n    (∀ (n : ℕ), b (Nat.succ n) ≤ b n ∨ b n ≤ b (Nat.succ n)) →\n      BddBelow (Set.range b) → BddAbove (Set.range b) → Summable (λ (n : ℕ), a n * b n) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedSemiring α] [inst_1 : OrderedCancelAddCommMonoid β] [inst_2 : HasContinuousAdd β]\n  {a : ℕ → α} {b : ℕ → β}, HasSum a →\n    Monotone b → Bounded (Set.Range b) → HasSum (fun n => a n • b n) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedAddCommMonoid α] [inst_1 : OrderedCancelAddCommMonoid β] {a : ℕ → α} {b : ℕ → β},\n  HasSum a →\n    Monotone b →\n      BddAbove (Set.Range b) →\n        autoParam (HasSum (fun n => a n * b n)) (name.mk_string \"try_this\" (name.mk_string \"has_sum_mul_of_monotone\" name.anonymous)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : OrderedCommSemiring α] [inst_1 : OrderedCommMonoid β] [inst_2 : HasScalar α β]\n  {f : ℕ → α} {g : ℕ → β},\n  Summable f →\n    (∀ (n m : ℕ), n ≤ m → g n ≤ g m) →\n      BddAbove (Set.range g) → Summable (λ (n : ℕ), f n • g n) "
    ]
  },
  {
    "docString": "Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)]\\n  {F : ℕ → { x // x ∈ lp E p }},\\n  CauchySeq F →\\n    ∀ {f : { x // x ∈ lp E p }},\\n      Filter.Tendsto (id fun i => ↑(F i)) Filter.atTop (nhds ↑f) → Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {K : Set α},\\n  IsComplete K → ∀ {u : β → α}, (∀ (n : β), u n ∈ K) → CauchySeq u → ∃ v, v ∈ K ∧ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\\n  CauchySeq u →\\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\\n      Filter.Tendsto f p Filter.atTop →\\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence has a convergent subsequence, then it converges. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {ι : Type u_3} {E : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 ≤ p)] {f : ι → { x // x ∈ MeasureTheory.Lp E p }}\\n  {g : { x // x ∈ MeasureTheory.Lp E p }} {l : Filter ι},\\n  Filter.Tendsto f l (nhds g) → MeasureTheory.TendstoInMeasure μ (fun n => ↑↑(f n)) l ↑↑g\",\n  \"isProp\": true,\n  \"docString\": \"Convergence in Lp implies convergence in measure. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\\n  CauchySeq u ↔ ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → dist (u m) (u n) < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\\nthe distance between its elements is arbitrarily small \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β]\\n  {γ : Type u_1} {F : β → γ → α} {s : Set γ},\\n  UniformCauchySeqOn F Filter.atTop s ↔\\n    ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → ∀ (x : γ), x ∈ s → dist (F m x) (F n x) < ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\\neventually, the distance between all its elements is uniformly, arbitrarily small \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"}]\n",
    "prompt_cons": "/-- A Cauchy sequence in a complete space converges -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem ∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)]\n  {F : ℕ → { x // x ∈ lp E p }},\n  CauchySeq F →\n    ∀ {f : { x // x ∈ lp E p }},\n      Filter.Tendsto (id fun i => ↑(F i)) Filter.atTop (nhds ↑f) → Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {K : Set α},\n  IsComplete K → ∀ {u : β → α}, (∀ (n : β), u n ∈ K) → CauchySeq u → ∃ v, v ∈ K ∧ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) :=\n\n/-- Convergence in Lp implies convergence in measure. -/\ntheorem ∀ {α : Type u_1} {ι : Type u_3} {E : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst : NormedAddCommGroup E] {p : ENNReal} [hp : Fact (1 ≤ p)] {f : ι → { x // x ∈ MeasureTheory.Lp E p }}\n  {g : { x // x ∈ MeasureTheory.Lp E p }} {l : Filter ι},\n  Filter.Tendsto f l (nhds g) → MeasureTheory.TendstoInMeasure μ (fun n => ↑↑(f n)) l ↑↑g :=\n\n/-- In a pseudometric space, Cauchy sequences are characterized by the fact that, eventually,\nthe distance between its elements is arbitrarily small -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u ↔ ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → dist (u m) (u n) < ε :=\n\n/-- In a pseudometric space, uniform Cauchy sequences are characterized by the fact that,\neventually, the distance between all its elements is uniformly, arbitrarily small -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β]\n  {γ : Type u_1} {F : β → γ → α} {s : Set γ},\n  UniformCauchySeqOn F Filter.atTop s ↔\n    ∀ (ε : ℝ), ε > 0 → ∃ N, ∀ (m : β), m ≥ N → ∀ (n : β), n ≥ N → ∀ (x : γ), x ∈ s → dist (F m x) (F n x) < ε :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
      "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) "
    ]
  },
  {
    "docString": "Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α]\\n  [inst_3 : Encodable β] {f : β → Set α},\\n  (∀ (s : β), IsClosed (f s)) → ⋃ (s : β), f s = Set.univ → ∃ s, Set.Nonempty (interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"One of the most useful consequences of Baire theorem: if a countable union of closed sets\\ncovers the space, then one of the sets has nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsOpen (f s)) →\\n    Set.Countable S → (∀ (s : β), s ∈ S → Dense (f s)) → Dense (⋂ (s : β) (_ : s ∈ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β}\\n  {f : (x : β) → x ∈ S → Set α},\\n  (∀ (s : β) (H : s ∈ S), IsGδ (f s H)) →\\n    Set.Countable S → (∀ (s : β) (H : s ∈ S), Dense (f s H)) → Dense (⋂ (s : β) (h : s ∈ S), f s h)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsClosed s) →\\n    Set.Countable S → ⋃₀ S = Set.univ → Dense (⋃ (s : Set α) (_ : s ∈ S), interior s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with `⋃₀`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {s t : Set α},\\n  IsGδ s → IsGδ t → Dense s → Dense t → Dense (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: the intersection of two dense Gδ sets is dense. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Encodable β]\\n  {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Dense (⋂ (s : β), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\\n  IsOpen s → Set.Nonempty s → Dense s\",\n  \"isProp\": true,\n  \"docString\": \"In a (pre)irreducible space, a nonempty open set is dense. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets\ncovers the space, then one of the sets has nonempty interior. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α]\n  [inst_3 : Encodable β] {f : β → Set α},\n  (∀ (s : β), IsClosed (f s)) → ⋃ (s : β), f s = Set.univ → ∃ s, Set.Nonempty (interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsOpen (f s)) →\n    Set.Countable S → (∀ (s : β), s ∈ S → Dense (f s)) → Dense (⋂ (s : β) (_ : s ∈ S), f s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β}\n  {f : (x : β) → x ∈ S → Set α},\n  (∀ (s : β) (H : s ∈ S), IsGδ (f s H)) →\n    Set.Countable S → (∀ (s : β) (H : s ∈ S), Dense (f s H)) → Dense (⋂ (s : β) (h : s ∈ S), f s h) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with `⋃₀`. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsClosed s) →\n    Set.Countable S → ⋃₀ S = Set.univ → Dense (⋃ (s : Set α) (_ : s ∈ S), interior s) :=\n\n/-- Baire theorem: the intersection of two dense Gδ sets is dense. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {s t : Set α},\n  IsGδ s → IsGδ t → Dense s → Dense t → Dense (s ∩ t) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Encodable β]\n  {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Dense (⋂ (s : β), f s) :=\n\n/-- In a (pre)irreducible space, a nonempty open set is dense. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : PreirreducibleSpace α] {s : Set α},\n  IsOpen s → Set.Nonempty s → Dense s :=\n\n/-- Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α]\n  {β : Type u_2} [inst_3 : Encodable β] {f : β → Set α},\n  (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : CompleteSpace α] [inst_3 : Nonempty α]\n  {f : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (f n)) → (∀ (n : ℕ), Dense (f n)) → Set.Nonempty (⋂ (n : ℕ), f n) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : CompleteSpace α] [inst_3 : Nonempty α]\n  {β : Type u_2} [inst_4 : Encodable β] {f : β → Set α},\n  (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
      "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α] [inst_3 : CompleteSpace α] {β : Type u_2} [inst_4 : Encodable β]\n  {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α] [inst_3 : CompleteSpace α] {β : Type u_2}\n  [inst_4 : Encodable β] {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α] [inst_3 : CompleteSpace α]\n  {β : Type u_2} [inst_4 : Encodable β] {f : β → Set α},\n  (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : CompleteSpace α] {β : Type u_2}\n  [inst_3 : Nonempty α] [inst_4 : Encodable β] {f : β → Set α},\n  (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
      "∀ {α : Type u_2} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α]\n  [inst_3 : CompleteSpace α] {β : Type u_1} [inst_4 : Encodable β] {f : β → Set α},\n  (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
      "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : Nonempty α] [inst_2 : CompleteSpace α] [inst_3 : SeparableSpace α]\n  {G : ℕ → Set α}, (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Nonempty α]\n  [inst_3 : CompleteSpace α] {f : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (f n)) → (∀ (n : ℕ), Dense (f n)) → Set.Nonempty (⋂ (n : ℕ), f n) "
    ]
  },
  {
    "docString": "If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$).",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ ≤ ‖f‖ / 3 ∧ dist (BoundedContinuousFunction.compContinuous g e) f ≤ 2 / 3 * ‖f‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) →\\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : RingHomIsometric σ₁₂]\\n  (f₀ : E →SL[σ₁₂] F) (r : ℝ), IsClosed (FunLike.coe '' Metric.closedBall f₀ r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of functions `f : E → F` that represent continuous linear maps `f : E →SL[σ₁₂] F`\\nat distance `≤ r` from `f₀ : E →SL[σ₁₂] F` is closed in the topology of pointwise convergence.\\nThis is one of the key steps in the proof of the **Banach-Alaoglu** theorem. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},\\n  t₂ ≤ t₃ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ ≤ ‖f‖ / 3 ∧ dist (BoundedContinuousFunction.compContinuous g e) f ≤ 2 / 3 * ‖f‖ :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) →\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- The set of functions `f : E → F` that represent continuous linear maps `f : E →SL[σ₁₂] F`\nat distance `≤ r` from `f₀ : E →SL[σ₁₂] F` is closed in the topology of pointwise convergence.\nThis is one of the key steps in the proof of the **Banach-Alaoglu** theorem. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {E : Type u_3} {F : Type u_4} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup F] [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : NontriviallyNormedField 𝕜₂]\n  [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} [inst_6 : RingHomIsometric σ₁₂]\n  (f₀ : E →SL[σ₁₂] F) (r : ℝ), IsClosed (FunLike.coe '' Metric.closedBall f₀ r) :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem ∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},\n  t₂ ≤ t₃ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s :=\n\n/-- If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$). -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} {Y : Type u_2} [inst : EmetricSpace X] [inst_1 : EmetricSpace Y] [inst_2 : MeasurableSpace X]\n  [inst_3 : MeasurableSpace Y] (f : C(X, Y)) (E : Set X), HasSubset.Subset (Closure E) (Closure (⇑f '' E)) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : EmetricSpace X] [inst_1 : EmetricSpace Y] (f : X → Y),\n  Continuous f → ∀ (E : Set X), f '' Closure E ⊆ Closure (f '' E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Closure E ⊆ Closure (f '' E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X → Y),\n  Continuous f → ∀ (E : Set X), HasSubset.Subset (f '' Closure E) (Closure (f '' E)) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X → Y),\n  Continuous f → ∀ (E : Set X), f '' Closure E ⊆ Closure (f '' E) ",
      "forall {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X → Y),\n  Continuous f → ∀ (E : Set X), f '' Closure E ⊆ Closure (f '' E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X → Y},\n  Continuous f → Closure (f '' E) ⊆ f '' Closure E ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X → Y},\n  Continuous f → Closure (f '' E) ⊆ f '' Closure E ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X → Y),\n  Continuous f → ∀ (E : Set X), f '' Closure E ⊆ Closure (f '' E) ",
      "∀ {X Y : Type u} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X → Y),\n  Continuous f → ∀ (E : Set X), f '' Closure E ⊆ Closure (f '' E) "
    ]
  },
  {
    "docString": "Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) →\\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\\n`exists_continuous_forall_mem_convex_of_local_const`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\\n  (∀ (x : X), Convex ℝ (t x)) → (∀ (x : X), ∃ c, ∀ᶠ (y : X) in nhds x, c ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x ∈ t x` for all\\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ ≤ ‖f‖ / 3 ∧ dist (BoundedContinuousFunction.compContinuous g e) f ≤ 2 / 3 * ‖f‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : FiniteDimensional ℝ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ℝ F]\\n  [inst_5 : FiniteDimensional ℝ F] {f : E → F} {s t : Set E},\\n  ContDiffOn ℝ 1 f s → Convex ℝ s → t ⊆ s → dimH t < ↑(FiniteDimensional.finrank ℝ F) → Dense (f '' t)ᶜ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A particular case of Sard's Theorem. Let `f : E → F` be a map between finite dimensional real\\nvector spaces. Suppose that `f` is `C¹` smooth on a convex set `s` of Hausdorff dimension strictly\\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : C(X, ℝ)) (e : X → Y), ClosedEmbedding e → ∃ g, ↑g ∘ e = ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\\ncontinuous real-valued function `g : C(Y, ℝ)` such that `g ∘ e = f`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ = ‖f‖ ∧ BoundedContinuousFunction.compContinuous g e = f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\\n  [inst_3 : Nonempty X] (f : BoundedContinuousFunction X ℝ) {e : X → Y},\\n  ClosedEmbedding e → ∃ g, (∀ (y : Y), ∃ x₁ x₂, ↑g y ∈ Set.Icc (↑f x₁) (↑f x₂)) ∧ ↑g ∘ e = ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\\nexists a bounded continuous function `g : Y →ᵇ ℝ` such that `g ∘ e = f` and each value `g y` belongs\\nto a closed interval `[f x₁, f x₂]` for some `x₁` and `x₂`.  \"}]\n",
    "prompt_cons": "/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a neighborhood `U ∈ 𝓝 X` and a function `g : X → E` that is\ncontinuous on `U` and sends each `y ∈ U` to a point of `t y`. Then there exists a continuous map\n`g : C(X, E)` such that `g x ∈ t x` for all `x`. See also\n`exists_continuous_forall_mem_convex_of_local_const`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) →\n    (∀ (x : X), ∃ U, U ∈ nhds x ∧ ∃ g, ContinuousOn g U ∧ ∀ (y : X), y ∈ U → g y ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- Let `X` be a normal paracompact topological space (e.g., any extended metric space). Let `E` be\na topological real vector space. Let `t : X → Set E` be a family of convex sets. Suppose that for\neach point `x : X`, there exists a vector `c : E` that belongs to `t y` for all `y` in a\nneighborhood of `x`. Then there exists a continuous map `g : C(X, E)` such that `g x ∈ t x` for all\n`x`. See also `exists_continuous_forall_mem_convex_of_local`. -/\ntheorem ∀ {X : Type u_2} {E : Type u_1} [inst : TopologicalSpace X] [inst_1 : AddCommGroup E] [inst_2 : Module ℝ E]\n  [inst_3 : NormalSpace X] [inst_4 : ParacompactSpace X] [inst_5 : TopologicalSpace E] [inst_6 : ContinuousAdd E]\n  [inst_7 : ContinuousSMul ℝ E] {t : X → Set E},\n  (∀ (x : X), Convex ℝ (t x)) → (∀ (x : X), ∃ c, ∀ᶠ (y : X) in nhds x, c ∈ t y) → ∃ g, ∀ (x : X), ↑g x ∈ t x :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g :=\n\n/-- One step in the proof of the Tietze extension theorem. If `e : C(X, Y)` is a closed embedding\nof a topological space into a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous\nfunction, then there exists a bounded continuous function `g : Y →ᵇ ℝ` of the norm `‖g‖ ≤ ‖f‖ / 3`\nsuch that the distance between `g ∘ e` and `f` is at most `(2 / 3) * ‖f‖`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ ≤ ‖f‖ / 3 ∧ dist (BoundedContinuousFunction.compContinuous g e) f ≤ 2 / 3 * ‖f‖ :=\n\n/-- A particular case of Sard's Theorem. Let `f : E → F` be a map between finite dimensional real\nvector spaces. Suppose that `f` is `C¹` smooth on a convex set `s` of Hausdorff dimension strictly\nless than the dimension of `F`. Then the complement of the image `f '' s` is dense in `F`. -/\ntheorem ∀ {E : Type u_2} {F : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : FiniteDimensional ℝ E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ℝ F]\n  [inst_5 : FiniteDimensional ℝ F] {f : E → F} {s t : Set E},\n  ContDiffOn ℝ 1 f s → Convex ℝ s → t ⊆ s → dimH t < ↑(FiniteDimensional.finrank ℝ F) → Dense (f '' t)ᶜ :=\n\n/-- **Tietze extension theorem** for real-valued continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a continuous real-valued function on `X`. Then there exists a\ncontinuous real-valued function `g : C(Y, ℝ)` such that `g ∘ e = f`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : C(X, ℝ)) (e : X → Y), ClosedEmbedding e → ∃ g, ↑g ∘ e = ↑f :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version with a closed\nembedding and bundled composition. If `e : C(X, Y)` is a closed embedding of a topological space\ninto a normal topological space and `f : X →ᵇ ℝ` is a bounded continuous function, then there exists\na bounded continuous function `g : Y →ᵇ ℝ` of the same norm such that `g ∘ e = f`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  (f : BoundedContinuousFunction X ℝ) (e : C(X, Y)),\n  ClosedEmbedding ↑e → ∃ g, ‖g‖ = ‖f‖ ∧ BoundedContinuousFunction.compContinuous g e = f :=\n\n/-- **Tietze extension theorem** for real-valued bounded continuous maps, a version for a closed\nembedding. Let `e` be a closed embedding of a nonempty topological space `X` into a normal\ntopological space `Y`. Let `f` be a bounded continuous real-valued function on `X`. Then there\nexists a bounded continuous function `g : Y →ᵇ ℝ` such that `g ∘ e = f` and each value `g y` belongs\nto a closed interval `[f x₁, f x₂]` for some `x₁` and `x₂`. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : NormalSpace Y]\n  [inst_3 : Nonempty X] (f : BoundedContinuousFunction X ℝ) {e : X → Y},\n  ClosedEmbedding e → ∃ g, (∀ (y : Y), ∃ x₁ x₂, ↑g y ∈ Set.Icc (↑f x₁) (↑f x₂)) ∧ ↑g ∘ e = ↑f :=\n\n/-- Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : EmetricSpace Y]\n  {f : X → Y} {E : Set X},\n  Dense E → Continuous f → Dense (f '' E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f g : X → Y} {s : Set X},\n  Dense s → Continuous f → Continuous g → ∀ {t : Set Y}, Dense (f '' s) → Dense (g '' t) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f g : X → Y} {E : Set X},\n  Dense E → Continuous f → Continuous g → Dense (f '' E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X]\n  [inst_3 : MetricSpace Y] {f g : C(X, Y)} {E : Set X}, Dense E → Dense (↑f '' E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : EmetricSpace X] [inst_1 : EmetricSpace Y] (f : X → Y) (g : X → Y) {s : Set X},\n  Dense s → Continuous f → Continuous g → Dense (f '' s) ",
      "∀ {X Y : Type*} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  (f g : C(X, Y)) (E : Set X), Dense E → Dense (f '' E) ",
      "∀ {X Y : Type*} [TopologicalSpace X] [MetricSpace Y] {f g : X → Y} {E : Set X}, Dense E → f = g → Dense (f '' E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {f : C(X, Y)} {E : Set X}, Dense E → Dense (Set.Image (⇑f) E) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y]\n  {f : X → Y} {E : Set X},\n  Continuous f → Dense E → Dense (f '' E) ",
      "forall {X : Type u_1} {Y : Type u_2} [inst_1 : TopologicalSpace X] [inst_2 : MetricSpace Y]\n  [inst_3 : TopologicalSpace Y] {f : X → Y} {Xs : Set X},\n  Continuous f → Dense Xs → Dense (f '' Xs) "
    ]
  },
  {
    "docString": "If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  (f : α → ℝ),\\n  MeasureTheory.Integrable f →\\n    ∀ {ε : ℝ},\\n      0 < ε →\\n        ∃ g,\\n          (∀ (x : α), ↑(f x) < g x) ∧\\n            LowerSemicontinuous g ∧\\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\\nto that of `f`. This function has to be `EReal`-valued in general. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"}]\n",
    "prompt_cons": "/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- **Vitali-Carathéodory Theorem**: given an integrable real function `f`, there exists an\nintegrable function `g > f` which is lower semicontinuous, with integral arbitrarily close\nto that of `f`. This function has to be `EReal`-valued in general. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : MeasurableSpace α] [inst_2 : BorelSpace α]\n  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.Measure.WeaklyRegular μ] [inst_4 : MeasureTheory.SigmaFinite μ]\n  (f : α → ℝ),\n  MeasureTheory.Integrable f →\n    ∀ {ε : ℝ},\n      0 < ε →\n        ∃ g,\n          (∀ (x : α), ↑(f x) < g x) ∧\n            LowerSemicontinuous g ∧\n              (MeasureTheory.Integrable fun x => EReal.toReal (g x)) ∧\n                (∀ᵐ (x : α) ∂μ, g x < ⊤) ∧ ∫ (x : α), EReal.toReal (g x) ∂μ < ∫ (x : α), f x ∂μ + ε :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g :=\n\n/-- If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$. -/\ntheorem",
    "choices": [
      "∀ {E : Type u} [inst : TopologicalSpace ℝ] [inst_1 : TopologicalSpace E] {f : E → ℝ},\n  IsClosed E → Continuous f → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn g f E ",
      "∀ {E : Set ℝ} {f : ℝ → ℝ},\n  IsClosed E → ContinuousOn f E → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn f g E ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α] {E : Set α}\n  [inst_3 : TopologicalSpace ℝ] {f : α → ℝ},\n  IsClosed E → ContinuousOn f E → ∃ g : α → ℝ, Continuous g ∧ Set.EqOn f g E ",
      "∀ {E : Type u} [inst : TopologicalSpace ℝ] [inst_1 : TopologicalSpace E] {f : E → ℝ} {s : Set E},\n  IsClosed s → ContinuousOn f s → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn g f s ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] [inst_1 : T2Space ℝ] {f : ℝ → ℝ},\n  IsClosed E → ContinuousOn f E → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn f g E ",
      "∀ {E : Set ℝ} {f : ℝ → ℝ} [inst : TopologicalSpace ℝ],\n  IsClosed E → ContinuousOn f E → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn f g E ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] {f : ℝ → ℝ}, IsClosed E → ContinuousOn f E → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn f g E ",
      "∀ {E : Set ℝ} {f : ℝ → ℝ} [inst : TopologicalSpace ℝ] [inst_1 : T2Space ℝ],\n  IsClosed E → ContinuousOn f E → ∃ g, Continuous g ∧ Set.EqOn f g E ",
      "∀ {E : Type u_1} [inst : TopologicalSpace ℝ] {f : E → ℝ} {s : Set ℝ},\n  IsClosed s → ContinuousOn f s → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn f g s ",
      "∀ {E : Type u} [inst : TopologicalSpace ℝ] [inst_1 : T2Space ℝ] {f : ℝ → ℝ},\n  IsClosed E → ContinuousOn f E → ∃ g : ℝ → ℝ, Continuous g ∧ Set.EqOn f g E "
    ]
  },
  {
    "docString": "If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\\ndifferentiable on `s`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\\n  {f : ℂ → E} {s : Set ℂ},\\n  Set.Countable s →\\n    ContinuousOn f (Metric.closedBall c ↑R) →\\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\\\ s → DifferentiableAt ℂ f z) →\\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the right is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ},\\n  s ⊆ f ⁻¹' e.source → (ContinuousOn f s ↔ ContinuousOn (↑e ∘ f) s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function is continuous on a set if and only if its composition with a local homeomorphism\\non the left is continuous on the corresponding set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\\n  {f : ℂ → E}, DiffContOnCl ℂ f (Metric.ball c ↑R) → 0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is complex differentiable on an open disc of positive radius and is continuous\\non its closure, then it is analytic on the open disc with coefficients of the power series given by\\nCauchy integral formulas. \"}]\n",
    "prompt_cons": "/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f :=\n\n/-- If `f : ℂ → E` is complex differentiable on some open set `s`, then it is continuously\ndifferentiable on `s`. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {n : ℕ∞} {s : Set ℂ}\n  {f : ℂ → E}, DifferentiableOn ℂ f s → IsOpen s → ContDiffOn ℂ n f s :=\n\n/-- If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : ℂ → E} {s : Set ℂ},\n  Set.Countable s →\n    ContinuousOn f (Metric.closedBall c ↑R) →\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\ s → DifferentiableAt ℂ f z) →\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the right is continuous on the corresponding set. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : β → γ} {s : Set β},\n  s ⊆ e.target → (ContinuousOn f s ↔ ContinuousOn (f ∘ ↑e) (e.source ∩ ↑e ⁻¹' s)) :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- A function is continuous on a set if and only if its composition with a local homeomorphism\non the left is continuous on the corresponding set. -/\ntheorem ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : TopologicalSpace γ] (e : LocalHomeomorph α β) {f : γ → α} {s : Set γ},\n  s ⊆ f ⁻¹' e.source → (ContinuousOn f s ↔ ContinuousOn (↑e ∘ f) s) :=\n\n/-- If `f : ℂ → E` is complex differentiable on an open disc of positive radius and is continuous\non its closure, then it is analytic on the open disc with coefficients of the power series given by\nCauchy integral formulas. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : ℂ → E}, DiffContOnCl ℂ f (Metric.ball c ↑R) → 0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R :=\n\n/-- If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : α → β) {E : Set α},\n  IsCompact E → (ContinuousOn f E ↔ IsCompact (Prod.mk '' (E.prod (range f)))) ",
      "∀ {α : Type u_1} {E : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace E] [inst_2 : CompactSpace α]\n  {f : α → E}, (∀ x : α, x ∈ SetOf fun x => ∃ y, ContinuousWithinAt f (SetOf fun x => ∃ y, ContinuousWithinAt f (SetOf y) x) x)\n  ↔ IsCompact (SetOf fun xy => ∃ x y, xy = (x, f x)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {E : Set α}\n  {f : α → β}, IsCompact E → (ContinuousOn f E ↔ IsCompact (Set.Graph f E)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  {E : Set α} {f : α → β},\n  IsCompact E → (ContinuousOn f E ↔ IsCompact (Set.Graph f E)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  {E : Set α} {f : α → β}, Compact E → (ContinuousOn f E ↔ Compact (Set.Graph f E)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  {E : Set α} {f : α → β},\n  IsCompact E → (ContinuousOn f E ↔ IsCompact (Prod.mk <$> E <*> f '' E)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {E : Set α}\n  {f : α → β}, IsCompact E → (ContinuousOn f E ↔ IsCompact (Set.Graph f E)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : CompactSpace α] {E : Set α} {f : α → β},\n  IsCompact E →\n    (IsCompact (Set.Graph f E) ↔ ContinuousOn f E) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {E : Set α} {f : α → β},\n  IsCompact E → (ContinuousOn f E ↔ IsCompact (Set.Graph f E)) ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {E : Set α} {f : α → β},\n  IsCompact E → (IsCompact (Prod.mk '' (E.prod (f '' E))) ↔ ContinuousOn f E) "
    ]
  },
  {
    "docString": "Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f ≥ 1` on K. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst : NormedSpace 𝕜 E] [inst : Nontrivial E] (c : ℝ), ∃ x, c < ‖x‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is a nontrivial normed space over a nontrivially normed field `𝕜`, then `E` is unbounded:\\nfor any `c : ℝ`, there exists a vector `x : E` with norm strictly greater than `c`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\\n  {f : ℂ → E} {s : Set ℂ},\\n  Set.Countable s →\\n    ContinuousOn f (Metric.closedBall c ↑R) →\\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\\\ s → DifferentiableAt ℂ f z) →\\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\\ncoefficients of the power series given by Cauchy integral formulas. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded above. \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A complex differentiable function `f : ℂ → E` is continuously differentiable at every point. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},\n  Differentiable ℂ f → ∀ {n : ℕ∞}, ContDiff ℂ n f :=\n\n/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f ≥ 1` on K. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x}) :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- If `E` is a nontrivial normed space over a nontrivially normed field `𝕜`, then `E` is unbounded:\nfor any `c : ℝ`, there exists a vector `x : E` with norm strictly greater than `c`. -/\ntheorem ∀ (𝕜 : Type u_2) (E : Type u_1) [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst : NormedSpace 𝕜 E] [inst : Nontrivial E] (c : ℝ), ∃ x, c < ‖x‖ :=\n\n/-- If `f : ℂ → E` is continuous on a closed ball of positive radius and is differentiable at all\nbut countably many points of the corresponding open ball, then it is analytic on the open ball with\ncoefficients of the power series given by Cauchy integral formulas. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : NNReal} {c : ℂ}\n  {f : ℂ → E} {s : Set ℂ},\n  Set.Countable s →\n    ContinuousOn f (Metric.closedBall c ↑R) →\n      (∀ (z : ℂ), z ∈ Metric.ball c ↑R \\ s → DifferentiableAt ℂ f z) →\n        0 < R → HasFPowerSeriesOnBall f (cauchyPowerSeries f c ↑R) c ↑R :=\n\n/-- A continuous function with compact support is bounded above. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\n  Continuous f → HasCompactSupport f → BddAbove (Set.range f) :=\n\n/-- Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$. -/\ntheorem",
    "choices": [
      "∀ (E : Set ℝ) [inst : MetricSpace ℝ], Bdd E → ∃ f : ℝ → ℝ, UniformContinuous f ∧ ¬ Bdd (f '' E) ",
      "∀ {E : Set ℝ} [inst : MetricSpace ℝ], Bounded E → ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ¬ Bounded (f '' E) ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ], Bdd E → ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ¬ BddRange f E ",
      "∀ {E : Set ℝ}, Bounded E → ∃ (f : ℝ → ℝ), UniformContinuous f ∧ (∀ (M : ℝ), ∃ (x : ℝ), x ∈ E ∧ M < f x) ",
      "∀ {E : Set ℝ} [inst : MetricSpace ℝ],\n  Bounded E → ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ∀ L : ℝ, ∃ x ∈ E, L < |f x| ",
      "∀ (E : Set ℝ), BddAbove E → BddBelow E → ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ¬BddAbove (f '' E) ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] [inst_1 : UniformSpace ℝ],\n  Bounded E → ∃ f : ℝ → ℝ, UniformContinuous f ∧ (∀ x ∈ E, BddAbove (f '' E) → False) ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] [inst_1 : UniformSpace ℝ],\n  BddAbove E → BddBelow E → ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ¬BddAbove (f '' E) ",
      "∀ {E : Set ℝ},\n  Bounded E →\n  ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ¬BddAbove (f '' E) ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ],\n  Bounded E → ∃ f : ℝ → ℝ, UniformContinuous f ∧ ∀ M : ℝ, ∃ x ∈ E, M < f x "
    ]
  },
  {
    "docString": "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\": \"A uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Each function of a uniformly equicontinuous family is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α) (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equicontinuous family of functions defined on a compact uniform space is automatically\\nuniformly equicontinuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"}]\n",
    "prompt_cons": "/-- A uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Each function of a uniformly equicontinuous family is uniformly continuous. -/\ntheorem ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] {F : ι → β → α},\n  UniformEquicontinuous F → ∀ (i : ι), UniformContinuous (F i) :=\n\n/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, Continuous F ∧ ∀ (y : α), (f y, F y) ∈ u) → Continuous f :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} [inst_1 : TopologicalSpace α],\n  (∀ (x : α) (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    Continuous f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- An equicontinuous family of functions defined on a compact uniform space is automatically\nuniformly equicontinuous. -/\ntheorem ∀ {α : Type u_3} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] {ι : Type u_1} {F : ι → β → α}\n  [inst_2 : CompactSpace β], Equicontinuous F → UniformEquicontinuous F :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (g : β → γ) (f : α → β),\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f) ",
      "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
      "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst_α : UniformSpace α] [inst_β : UniformSpace β] [inst_γ : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "
    ]
  },
  {
    "docString": "Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ (f : ℝ → ℝ) {a b : ℝ},\\n  a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsExtrOn f (Set.Icc a b) c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` takes either its maximum\\nor its minimum value at a point in the interior of the interval. \"},\n {\"theorem\":\n  \"∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\\n  0 < r →\\n    r ≤ R →\\n      ∀ {f : ℂ → E} {s : Set ℂ},\\n        Set.Countable s →\\n          ContinuousOn f (Metric.closedBall c R \\\\ Metric.ball c r) →\\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\\\ Metric.closedBall c r) \\\\ s → DifferentiableAt ℂ f z) →\\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\\ndifferentiable at all but countably many points of its interior, then the integrals of\\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\\nequal to each other. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\\n  [inst_6 : OrderClosedTopology δ] {a b : α} {f : α → δ},\\n  ContinuousOn f (Set.uIcc a b) → Set.uIcc (f a) (f b) ⊆ f '' Set.uIcc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] {f : α → β} {s : Set α} {a : α},\\n  MonotoneOn f s →\\n    s ∈ nhds a →\\n      (∀ (b : β), b < f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo b (f a)) →\\n        (∀ (b : β), b > f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo (f a) b) → ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"∀ {f g : ℝ → ℝ} {a b : ℝ},\\n  a < b →\\n    ContinuousOn f (Set.Icc a b) →\\n      ContinuousOn g (Set.Icc a b) →\\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ} {a b : ℝ},\\n  IntervalIntegrable f MeasureTheory.volume a b →\\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f x) → a < b → 0 < ∫ (x : ℝ) in a..b, f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℝ → ℝ` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\\nof the interval, then its integral over `a..b` is strictly positive. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"}]\n",
    "prompt_cons": "/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A continuous function on a closed interval with `f a = f b` takes either its maximum\nor its minimum value at a point in the interior of the interval. -/\ntheorem ∀ (f : ℝ → ℝ) {a b : ℝ},\n  a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsExtrOn f (Set.Icc a b) c :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem ∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- If `f : ℂ → E` is continuous the closed annulus `r ≤ ‖z - c‖ ≤ R`, `0 < r ≤ R`, and is complex\ndifferentiable at all but countably many points of its interior, then the integrals of\n`f z / (z - c)` (formally, `(z - c)⁻¹ • f z`) over the circles `‖z - c‖ = r` and `‖z - c‖ = R` are\nequal to each other. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {c : ℂ} {r R : ℝ},\n  0 < r →\n    r ≤ R →\n      ∀ {f : ℂ → E} {s : Set ℂ},\n        Set.Countable s →\n          ContinuousOn f (Metric.closedBall c R \\ Metric.ball c r) →\n            (∀ (z : ℂ), z ∈ (Metric.ball c R \\ Metric.closedBall c r) \\ s → DifferentiableAt ℂ f z) →\n              (∮ (z : ℂ) in C(c, R), (z - c)⁻¹ • f z) = ∮ (z : ℂ) in C(c, r), (z - c)⁻¹ • f z :=\n\n/-- **Intermediate Value Theorem** for continuous functions on closed intervals, unordered case. -/\ntheorem ∀ {α : Type u} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : DenselyOrdered α] {δ : Type u_1} [inst_4 : LinearOrder δ] [inst_5 : TopologicalSpace δ]\n  [inst_6 : OrderClosedTopology δ] {a b : α} {f : α → δ},\n  ContinuousOn f (Set.uIcc a b) → Set.uIcc (f a) (f b) ⊆ f '' Set.uIcc a b :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] {f : α → β} {s : Set α} {a : α},\n  MonotoneOn f s →\n    s ∈ nhds a →\n      (∀ (b : β), b < f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo b (f a)) →\n        (∀ (b : β), b > f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo (f a) b) → ContinuousAt f a :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. -/\ntheorem ∀ {f g : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Icc a b) →\n      ContinuousOn g (Set.Icc a b) →\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x :=\n\n/-- If `f : ℝ → ℝ` is integrable on `(a, b]` for real numbers `a < b`, and positive on the interior\nof the interval, then its integral over `a..b` is strictly positive. -/\ntheorem ∀ {f : ℝ → ℝ} {a b : ℝ},\n  IntervalIntegrable f MeasureTheory.volume a b →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → 0 < f x) → a < b → 0 < ∫ (x : ℝ) in a..b, f x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous. -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ},\n  (∀ (a b c : ℝ), f a < c → c < f b → ∃ x, a ≤ x ∧ x ≤ b ∧ f x = c) →\n  (∀ (r : ℚ), IsClosed (f ⁻¹' {r})) → Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ {a b : ℝ}, a < b → ∀ (C : ℝ), f a < C → C < f b → ∃ x, x ∈ Set.Ioo a b ∧ f x = C) →\n    (∀ (q : ℚ), IsClosed (f ⁻¹' {↑q})) → Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ (a b c : ℝ), a < b → f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n  (∀ (r : ℚ), IsClosed (f ⁻¹' {↑r})) → Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ (a b : ℝ) (c : ℚ), f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n  (∀ (r : ℚ), IsClosed (f ⁻¹' {r})) → Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ (a b : ℝ) (c : ℝ), f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n    (∀ (r : ℚ), IsClosed (f ⁻¹' {x : ℝ | x = ↑r})) → Continuous f ",
      "forall {f : ℝ → ℝ},\n  (∀ a b c, f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n  (∀ r : ℚ, IsClosed (f ⁻¹' {r})) →\n  Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ (a b : ℝ) (c : ℝ), f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n    (∀ (r : ℚ), IsClosed (f ⁻¹' {↑r})) → Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ (a b : ℝ) (c : ℝ), f a < c → c < f b → ∃ (x : ℝ), a < x ∧ x < b ∧ f x = c) →\n    (∀ (q : ℚ), IsClosed (f ⁻¹' {↑q})) → Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ a b c, a < b → f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n  (∀ r, IsClosed (f ⁻¹' {r})) →\n  Continuous f ",
      "∀ {f : ℝ → ℝ},\n  (∀ {a b c : ℝ}, a < b → f a < c → c < f b → ∃ x, a ≤ x ∧ x ≤ b ∧ f x = c) →\n    (∀ (r : ℚ), IsClosed (f ⁻¹' {r})) → Continuous f "
    ]
  },
  {
    "docString": "Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E → β},\\n  Convex 𝕜 s →\\n    (∀ ⦃x : E⦄,\\n        x ∈ s →\\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y ≤ f (a • x + b • y)) →\\n      ConcaveOn 𝕜 s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\\nverify the inequality `a • f x + b • f y ≤ f (a • x + b • y)` for `x < y` and positive `a`, `b`. The\\nmain use case is `E = ℝ` however one can apply it, e.g., to `ℝ^n` with lexicographic order. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E → β},\\n  Convex 𝕜 s →\\n    (∀ ⦃x : E⦄,\\n        x ∈ s →\\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y < f (a • x + b • y)) →\\n      StrictConcaveOn 𝕜 s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\\nto verify the inequality `a • f x + b • f y < f (a • x + b • y)` for `x < y` and positive `a`, `b`.\\nThe main use case is `E = 𝕜` however one can apply it, e.g., to `𝕜^n` with lexicographic order. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E → β},\\n  Convex 𝕜 s →\\n    (∀ ⦃x : E⦄,\\n        x ∈ s →\\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) < a • f x + b • f y) →\\n      StrictConvexOn 𝕜 s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is strictly convex, it suffices\\nto verify the inequality `f (a • x + b • y) < a • f x + b • f y` for `x < y` and positive `a`, `b`.\\nThe main use case is `E = 𝕜` however one can apply it, e.g., to `𝕜^n` with lexicographic order. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\\n  {f : E → β},\\n  Convex 𝕜 s →\\n    (∀ ⦃x : E⦄,\\n        x ∈ s →\\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) ≤ a • f x + b • f y) →\\n      ConvexOn 𝕜 s f\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a function on a convex set in a linearly ordered space (where the order and the algebraic\\nstructures aren't necessarily compatible), in order to prove that it is convex, it suffices to\\nverify the inequality `f (a • x + b • y) ≤ a • f x + b • f y` only for `x < y` and positive `a`,\\n`b`. The main use case is `E = 𝕜` however one can apply it, e.g., to `𝕜^n` with lexicographic order.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] {f : α → β} {s : Set α} {a : α},\\n  MonotoneOn f s →\\n    s ∈ nhds a →\\n      (∀ (b : β), b < f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo b (f a)) →\\n        (∀ (b : β), b > f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo (f a) b) → ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"}]\n",
    "prompt_cons": "/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is concave it suffices to\nverify the inequality `a • f x + b • f y ≤ f (a • x + b • y)` for `x < y` and positive `a`, `b`. The\nmain use case is `E = ℝ` however one can apply it, e.g., to `ℝ^n` with lexicographic order. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y ≤ f (a • x + b • y)) →\n      ConcaveOn 𝕜 s f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' ≤ C`, then\n`f` grows at most as fast as `C * x` on `D`, i.e., `f y - f x ≤ C * (y - x)` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x ≤ C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → f y - f x ≤ C * (y - x) :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly concave it suffices\nto verify the inequality `a • f x + b • f y < f (a • x + b • y)` for `x < y` and positive `a`, `b`.\nThe main use case is `E = 𝕜` however one can apply it, e.g., to `𝕜^n` with lexicographic order. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y < f (a • x + b • y)) →\n      StrictConcaveOn 𝕜 s f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x :=\n\n/-- If a function `f` is differentiable and `f'` is monotone on `ℝ` then `f` is convex. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Monotone (deriv f) → ConvexOn ℝ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f' < C`, then\n`f` grows slower than `C * x` on `D`, i.e., `f y - f x < C * (y - x)` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → deriv f x < C) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → f y - f x < C * (y - x) :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is strictly convex, it suffices\nto verify the inequality `f (a • x + b • y) < a • f x + b • f y` for `x < y` and positive `a`, `b`.\nThe main use case is `E = 𝕜` however one can apply it, e.g., to `𝕜^n` with lexicographic order. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) < a • f x + b • f y) →\n      StrictConvexOn 𝕜 s f :=\n\n/-- For a function on a convex set in a linearly ordered space (where the order and the algebraic\nstructures aren't necessarily compatible), in order to prove that it is convex, it suffices to\nverify the inequality `f (a • x + b • y) ≤ a • f x + b • f y` only for `x < y` and positive `a`,\n`b`. The main use case is `E = 𝕜` however one can apply it, e.g., to `𝕜^n` with lexicographic order. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) ≤ a • f x + b • f y) →\n      ConvexOn 𝕜 s f :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] {f : α → β} {s : Set α} {a : α},\n  MonotoneOn f s →\n    s ∈ nhds a →\n      (∀ (b : β), b < f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo b (f a)) →\n        (∀ (b : β), b > f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo (f a) b) → ContinuousAt f a :=\n\n/-- Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → a • f x + b • f y ≤ f (a • x + b • y)) →\n      ConcaveOn 𝕜 s f ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x y : E⦄,\n        x ∈ s → y ∈ s → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n      ConvexOn 𝕜 s f ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f ((a + b)⁻¹ • x + (a + b)⁻¹ • y) ≤ (a + b)⁻¹ • f x + (a + b)⁻¹ • f y) →\n      ConvexOn 𝕜 s f ",
      "∀ {a b : ℝ},\n  a < b →\n  ∀ {f : ℝ → ℝ},\n    ContinuousOn f (Set.Ioo a b) →\n      (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n    ConvexOn ℝ (Set.Ioo a b) f ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x ≠ y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f ((a + b)⁻¹ • (a • x + b • y)) ≤ (a • f x + b • f y)) →\n      ConvexOn 𝕜 s f ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ioo (fun x => ℝ) a b) →\n    (∀ ⦃x y : ℝ⦄, x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n      ConvexOn ℝ (Set.Ioo a b) f ",
      "∀ {x y : ℝ} {s : Set ℝ} {f : ℝ → ℝ},\n  s = Set.Ioo x y →\n    ContinuousOn f s →\n      (∀ (a b : ℝ), a ∈ s → b ∈ s → f ((a + b) / 2) ≤ (f a + f b) / 2) →\n        ConvexOn ℝ s f ",
      "∀ {s : Set ℝ} {f : ℝ → ℝ},\n  Convex ℝ s →\n    (∀ ⦃x : ℝ⦄,\n        x ∈ s →\n          ∀ ⦃y : ℝ⦄, y ∈ s → x ≠ y → ∀ ⦃a b : ℝ⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) ≤ a • f x + b • f y) →\n      ConvexOn ℝ s f ",
      "forall {a b : ℝ} {f : ℝ → ℝ},\n  a < b →\n    ContinuousOn f (Set.Ioo a b) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → ∀ (y : ℝ), y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n        ConvexOn ℝ (Set.Ioo a b) f ",
      "∀ {f : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Ioo a b) →\n      (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n        ConvexOn ℝ (Set.Ioo a b) f "
    ]
  },
  {
    "docString": "Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {f g : ℝ → ℝ} {a b : ℝ},\\n  a < b →\\n    ContinuousOn f (Set.Icc a b) →\\n      ContinuousOn g (Set.Icc a b) →\\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] {s : Set X},\\n  IsPreconnected s →\\n    ∀ {a b : X},\\n      a ∈ s →\\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\\nthen for some `x ∈ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          ContinuousOn B (Set.Icc a b) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f' x ≤ B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has derivative `B'` everywhere on `ℝ`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x ≤ B' x` on `[a, b)`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {f g : 𝕜 → 𝕜} {f' a : 𝕜},\\n  ContinuousAt g a →\\n    HasStrictDerivAt f f' (g a) → f' ≠ 0 → (∀ᶠ (y : 𝕜) in nhds a, f (g y) = y) → HasStrictDerivAt g f'⁻¹ a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'⁻¹` at `a`\\nin the strict sense.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\\ninverse function. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has derivative `B'` everywhere on `ℝ`;\\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {f' : E ≃L[𝕜] F} {g : F → E} {a : F},\\n  ContinuousAt g a →\\n    HasFDerivAt f (↑f') (g a) → (∀ᶠ (y : F) in nhds a, f (g y) = y) → HasFDerivAt g (↑(ContinuousLinearEquiv.symm f')) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'⁻¹` at `a`.\\n\\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\\nan inverse function. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has derivative `B'` everywhere on `ℝ`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          ContinuousOn B (Set.Icc a b) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          ContinuousOn B (Set.Icc a b) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"}]\n",
    "prompt_cons": "/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. -/\ntheorem ∀ {f g : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Icc a b) →\n      ContinuousOn g (Set.Icc a b) →\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\nthen for some `x ∈ s` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {s : Set X},\n  IsPreconnected s →\n    ∀ {a b : X},\n      a ∈ s →\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has derivative `B'` everywhere on `ℝ`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x ≤ B' x` on `[a, b)`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          ContinuousOn B (Set.Icc a b) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f' x ≤ B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'⁻¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {f g : 𝕜 → 𝕜} {f' a : 𝕜},\n  ContinuousAt g a →\n    HasStrictDerivAt f f' (g a) → f' ≠ 0 → (∀ᶠ (y : 𝕜) in nhds a, f (g y) = y) → HasStrictDerivAt g f'⁻¹ a :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has derivative `B'` everywhere on `ℝ`;\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E ≃L[𝕜] F} {g : F → E} {a : F},\n  ContinuousAt g a →\n    HasFDerivAt f (↑f') (g a) → (∀ᶠ (y : F) in nhds a, f (g y) = y) → HasFDerivAt g (↑(ContinuousLinearEquiv.symm f')) a :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has derivative `B'` everywhere on `ℝ`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          ContinuousOn B (Set.Icc a b) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          ContinuousOn B (Set.Icc a b) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$. -/\ntheorem",
    "choices": [
      "forall {f f' : ℝ → ℝ} {a b : ℝ},\n  (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt f (f' x) (Set.Ioo a b) x) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → f' x > 0) →\n      ∀ {g g' : ℝ → ℝ},\n        g = (f⁻¹' (Set.Ioo a b)) →\n          (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt g (g' (f x)) (Set.Ioo a b) (f x)) →\n            (∀ (x : ℝ), x ∈ Set.Ioo a b → f (g (f x)) = x) →\n              (∀ (x : ℝ), x ∈ Set.Ioo a b → g' (f x) = (f' x)⁻¹) ",
      "forall {f : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Icc a b) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → ∀ (r : ℝ), r < (derivWithin f (Set.Ioo a b) x) → r > 0) →\n        StrictMonoOn f (Set.Icc a b) ∧\n          ∀ (x : ℝ), x ∈ Set.Ioo a b → ∃ (g : ℝ → ℝ) (g' : ℝ),\n            ContinuousOn g (Set.Icc (f a) (f b)) ∧\n              (∀ (y : ℝ), y ∈ Set.Icc (f a) (f b) → f (g y) = y) ∧\n                HasDerivWithinAt g g'(Set.Ioo (f a) (f b) (f x)) x ∧\n                  g'(f x) = (derivWithin f (Set.Ioo a b) x)⁻¹ ",
      "forall {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → f' x > 0) →\n        (∀ x y, x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → x < y → f x < f y) ∧\n          (∃ g, ∀ x ∈ Set.Ioo a b, f (g x) = x ∧ g (f x) = x ∧ (∃ gx, HasStrictDerivAt g gx (f x) ∧ gx = 1 / (f' x))) ",
      "∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {f f' : 𝕜 → 𝕜} {a b : 𝕜},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : 𝕜), x ∈ Set.Ioo a b → HasStrictDerivAt f (f' x) x) →\n      (∀ (x : 𝕜), x ∈ Set.Ioo a b → f' x > 0) →\n        StrictMonoOn f (Set.Ioo a b) ∧\n          ∀ {g : 𝕜 → 𝕜},\n            (∀ (x : 𝕜), x ∈ Set.Ioo a b → g (f x) = x) →\n              (∀ (x : 𝕜), x ∈ Set.Ioo a b → HasStrictDerivAt g (1 / f' (f x)) x) ",
      "forall {a b : ℝ} (hab : a < b) {f : ℝ → ℝ} (hf : ContinuousOn f (Set.Icc a b))\n  (hf' : ∀ x ∈ Set.Ioo a b, differentiable_within_at ℝ f (Set.Ioo a b) x ∧ deriv_within f (Set.Ioo a b) x > 0),\n  strict_mono_on f (Set.Icc a b) ∧\n  ∃ (g : ℝ → ℝ), ContinuousOn g (Set.Icc (f a) (f b)) ∧\n    (∀ y ∈ Set.Icc (f a) (f b), f (g y) = y) ∧\n    (∀ y ∈ Set.Ioo (f a) (f b), differentiable_within_at ℝ g (Set.Ioo (f a) (f b)) y ∧\n      deriv_within g (Set.Ioo (f a) (f b)) y = (deriv_within f (Set.Ioo a b) (g y))⁻¹) ",
      "forall {𝕜 : Type*} [nondiscrete_normed_field 𝕜] {f : 𝕜 → 𝕜} {f' : 𝕜 → 𝕜} {a b : 𝕜},\n  a < b →\n  (∀ (x : 𝕜), x ∈ set.Ioo a b → has_deriv_within_at f (f' x) (set.Ioo a b) x) →\n  (∀ (x : 𝕜), x ∈ set.Ioo a b → f' x > 0) →\n  let g ",
      "forall {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt f (f' x) (Set.Ioo x) x) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → f' x > 0) →\n        strict_mono_on f (Set.Ioo a b) ∧\n          (∀ (x : ℝ), x ∈ Set.Ioo a b →\n            ∃ (g : ℝ → ℝ) (g' : ℝ),\n              ContinuousOn g (Set.Icc (f a) (f b)) ∧\n                (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → HasDerivWithinAt g (g' y) (Set.Ioo y) y) ∧\n                  (∀ (y : ℝ), y ∈ Set.Ioo (f a) (f b) → g' y = 1 / f' (g y))) ",
      "forall {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt f (f' x) (Set.Ioo a b) x) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → f' x > 0) →\n        StrictMonoOn f (Set.Ioo a b) ∧\n          (∃ g, ∀ (x : ℝ), x ∈ Set.Ioo a b →\n            (g ∘ f) x = x ∧\n              (f ∘ g) x = x ∧\n                HasDerivAt g (1 / f' (f x)) (f x)) ",
      "forall {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → f' x > 0) →\n        StrictMonoOn f (Set.Ioo a b) ∧\n          (∀ {g : ℝ → ℝ},\n            (∀ (x : ℝ), x ∈ Set.Ioo a b → g (f x) = x) →\n              (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivAt g (1 / f' (g x)) (f x))) ",
      "forall {f f' : ℝ → ℝ} {a b : ℝ},\n  a < b →\n  ContinuousOn f (Set.Ioo a b) →\n    (∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt f (f' x) (Set.Ioo a b) x) →\n      (∀ (x : ℝ), x ∈ Set.Ioo a b → f' x > 0) →\n        (∃ g, Function.LeftInverse g f ∧\n          Function.RightInverse g f ∧\n          ∀ (x : ℝ), x ∈ Set.Ioo a b → HasDerivWithinAt g (1 / (f' (g x))) (Set.Ioo a b) x) "
    ]
  },
  {
    "docString": "If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.",
    "prompts": "[{\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R} {n : ℕ},\\n  0 < n →\\n    IsPrimitiveRoot ζ n →\\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun ζ => Polynomial.X - ↑Polynomial.C ζ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = ∏ (X - μ)`, where `μ`\\nvaries over the `n`-th roots of unity. \"},\n {\"theorem\":\n  \"∀ {f : Polynomial ℂ}, 0 < Polynomial.degree f → ∃ z, Polynomial.IsRoot f z\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fundamental theorem of algebra**: every non constant complex polynomial\\nhas a root \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ℝ] (p : Polynomial F),\\n  Fintype.card ↑(Polynomial.rootSet p ℝ) ≤ Fintype.card ↑(Polynomial.rootSet (↑Polynomial.derivative p) ℝ) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"∀ {S : Set ℕ+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : ℕ+}, n ∈ S → ∃ r, IsPrimitiveRoot r ↑n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℚ),\\n  Finset.card (Set.toFinset (Polynomial.rootSet p ℂ)) =\\n    Finset.card (Set.toFinset (Polynomial.rootSet p ℝ)) +\\n      Finset.card\\n        (Equiv.Perm.support\\n          (↑(Polynomial.Gal.galActionHom p ℂ)\\n            (↑(Polynomial.Gal.restrict p ℂ) (AlgEquiv.restrictScalars ℚ Complex.conjAe))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of complex roots equals the number of real roots plus\\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\\n  0 < n →\\n    IsPrimitiveRoot ζ n → (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`∏ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. \"}]\n",
    "prompt_cons": "/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1 :=\n\n/-- If there is a primitive `n`th root of unity in `K`, then `X ^ n - 1 = ∏ (X - μ)`, where `μ`\nvaries over the `n`-th roots of unity. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R} {n : ℕ},\n  0 < n →\n    IsPrimitiveRoot ζ n →\n      Polynomial.X ^ n - 1 = Finset.prod (Polynomial.nthRootsFinset n R) fun ζ => Polynomial.X - ↑Polynomial.C ζ :=\n\n/-- **Fundamental theorem of algebra**: every non constant complex polynomial\nhas a root -/\ntheorem ∀ {f : Polynomial ℂ}, 0 < Polynomial.degree f → ∃ z, Polynomial.IsRoot f z :=\n\n/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1 :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ∀ (p : Polynomial ℝ),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1 :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ∀ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ℝ] (p : Polynomial F),\n  Fintype.card ↑(Polynomial.rootSet p ℝ) ≤ Fintype.card ↑(Polynomial.rootSet (↑Polynomial.derivative p) ℝ) + 1 :=\n\n/-- For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem ∀ {S : Set ℕ+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : ℕ+}, n ∈ S → ∃ r, IsPrimitiveRoot r ↑n :=\n\n/-- The number of complex roots equals the number of real roots plus\nthe number of roots not fixed by complex conjugation (i.e. with some imaginary component). -/\ntheorem ∀ (p : Polynomial ℚ),\n  Finset.card (Set.toFinset (Polynomial.rootSet p ℂ)) =\n    Finset.card (Set.toFinset (Polynomial.rootSet p ℝ)) +\n      Finset.card\n        (Equiv.Perm.support\n          (↑(Polynomial.Gal.galActionHom p ℂ)\n            (↑(Polynomial.Gal.restrict p ℂ) (AlgEquiv.restrictScalars ℚ Complex.conjAe)))) :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`∏ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem ∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\n  0 < n →\n    IsPrimitiveRoot ζ n → (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1 :=\n\n/-- If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1. -/\ntheorem",
    "choices": [
      "∀ (C : ℕ → ℝ),\n  (∑ n, C n / (n + 1)) = 0 →\n    ∃ x₀ ∈ Icc (0 : ℝ) 1, (Finset.sum (Finset.range (Nat.succ (Nat.length_up_to_Nat_lt C))) fun n => C n * x₀ ^ n) = 0 ",
      "∀ (C : ℕ → ℝ),\n  (∑ (i : ℕ) in Finset.range (n + 2), C i / (i + 1)) = 0 →\n    ∃ (x : ℝ) (H : 0 ≤ x) (H_1 : x ≤ 1),\n      (∑ (i : ℕ) in Finset.range (n + 1), C i * x ^ i) = 0 ",
      "∀ (C : ℕ → ℝ),\n  (∑ (i : ℕ) in Finset.range (n + 1), C i / (i + 1)) = 0 →\n  ∃ x₀ : ℝ, 0 < x₀ ∧ x₀ < 1 ∧ (∑ (i : ℕ) in Finset.range (n + 1), C i * x₀ ^ i) = 0 ",
      "∀ {C₀ C₁ C₂ C₃ C₄ : ℝ} (h : C₀ + C₁ / 2 + C₂ / 3 + C₃ / 4 + C₄ / 5 = 0),\n  ∃ x, 0 ≤ x ∧ x ≤ 1 ∧ (C₀ + C₁ * x + C₂ * x ^ 2 + C₃ * x ^ 3 + C₄ * x ^ 4 = 0) ",
      "∀ {n : ℕ} (C : ℕ → ℝ),\n  (∑ k in Finset.range (n + 2), C k / (k + 1)) = 0 →\n    ∃ x₀ : ℝ, x₀ ∈ Ioo (0 : ℝ) 1 ∧ (∑ k in Finset.range (n + 1), (C k) * x₀ ^ k) = 0 ",
      "∀ (C : Finₓ (n + 1) → ℝ),\n  (∑ (i : ℕ) in Finset.range (n + 1), (C (Finₓ.castLe (Nat.le_succ n) (Finₓ.succ (Finₓ.castLt (Finₓ.succ i) (Nat.lt_succ_self n))) + C (Finₓ.last n)) / (↑i + 1)) = 0 →\n    ∃ x H,\n      (∑ (i : ℕ) in Finset.range (n + 1), C (Finₓ.castLe (Nat.le_succ n) (Finₓ.succ (Finₓ.castLt (Finₓ.succ i) (Nat.lt_succ_self n)))) * x ^ i + C (Finₓ.last n) * x ^ n) = 0 ",
      "∀ {C : ℕ → ℝ},\n  (∑ i in Finset.range (n + 1), C i / (i + 1)) = 0 →\n    ∃ x : ℝ, 0 < x ∧ x < 1 ∧ (Finset.sum (Finset.range (n + 1)) fun i => C i * x ^ i) = 0 ",
      "∀ (C : ℕ → ℝ),\n  (∑ (i : ℕ) in Finset.range (n + 1), C i / (i + 1)) = 0 →\n    ∃ (x : ℝ) (H : x ∈ Icc 0 1), Polynomial.eval x (Finset.sum (Finset.range (n + 1)) (Polynomial.monomial ∘ C)) = 0 ",
      "∀ (C : ℕ → ℝ),\n  (∑ (n : ℕ) in Finset.range (Nat.succ (Nat.succ (Finset.card (Multiset.toFinset (Polynomial.roots (Polynomial.of_finsupp C))))))), C n / (↑n + 1)) = 0 →\n  ∃ x : ℝ, 0 ≤ x ∧ x ≤ 1 ∧ (Finset.sum (Finset.range (Nat.succ (Finset.card (Multiset.toFinset (Polynomial.roots (Polynomial.of_finsupp C))))))) fun n => C n * x ^ n) = 0 ",
      "∀ (C : ℕ → ℝ),\n  (∑ (n : ℕ) in Finset.range (Nat.succ (Finset.card (Finset.range (Nat.succ 0)))), C n / (↑n + 1)) = 0 →\n  ∃ x : ℝ, 0 < x ∧ x < 1 ∧ (∑ (n : ℕ) in Finset.range (Nat.succ 0), C n * x ^ n) = 0 "
    ]
  },
  {
    "docString": "Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing.",
    "prompts": "[{\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\\n`f` is a monotone function. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + τ f`. \"},\n {\"theorem\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\\n  (∀ (Z : C) (g : Z ⟶ X), CategoryTheory.CategoryStruct.comp g f = 0 → g = 0) → CategoryTheory.Mono f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}\\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {f : E → F → G} {g : E → F} {n : ℕ∞},\\n  ContDiff 𝕜 n (Function.uncurry f) → Continuous g → 1 ≤ n → Continuous fun x => fderiv 𝕜 (f x) (g x)\",\n  \"isProp\": true,\n  \"docString\": \"`x ↦ fderiv 𝕜 (f x) (g x)` is continuous. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\\n`x ≤ y`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) → (∀ (x : ℝ), x ∈ interior D → 0 ≤ deriv f x) → MonotoneOn f D\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\\n`f` is a monotone function on `D`. \"},\n {\"theorem\":\n  \"∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\\n  (∀ (Z : C) (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp f g = 0 → g = 0) → CategoryTheory.Epi f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → StrictMono (deriv f) → StrictConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly monotone on `ℝ` then `f` is strictly\\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict monotonicity of `f'`. \"},\n {\"theorem\":\n  \"∀ {D : Set ℝ},\\n  Convex ℝ D →\\n    ∀ {f : ℝ → ℝ},\\n      ContinuousOn f D →\\n        DifferentiableOn ℝ f (interior D) →\\n          ∀ {C : (fun x => ℝ) 1},\\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\\n`x < y`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"}]\n",
    "prompt_cons": "/-- Let `f : ℝ → ℝ` be a differentiable function. If `f'` is nonnegative, then\n`f` is a monotone function. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → (∀ (x : ℝ), 0 ≤ deriv f x) → Monotone f :=\n\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem ∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- If `g ≫ f = 0` implies `g = 0` for all `g`, then `f` is a monomorphism. -/\ntheorem ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] [inst_3 : CategoryTheory.Limits.HasCokernels C]\n  [inst_4 : CategoryTheory.NormalEpiCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\n  (∀ (Z : C) (g : Z ⟶ X), CategoryTheory.CategoryStruct.comp g f = 0 → g = 0) → CategoryTheory.Mono f :=\n\n/-- `x ↦ fderiv 𝕜 (f x) (g x)` is continuous. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}\n  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {f : E → F → G} {g : E → F} {n : ℕ∞},\n  ContDiff 𝕜 n (Function.uncurry f) → Continuous g → 1 ≤ n → Continuous fun x => fderiv 𝕜 (f x) (g x) :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C ≤ f'`, then\n`f` grows at least as fast as `C * x` on `D`, i.e., `C * (y - x) ≤ f y - f x` whenever `x, y ∈ D`,\n`x ≤ y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C ≤ deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x ≤ y → C * (y - x) ≤ f y - f x :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `f'` is nonnegative, then\n`f` is a monotone function on `D`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) → (∀ (x : ℝ), x ∈ interior D → 0 ≤ deriv f x) → MonotoneOn f D :=\n\n/-- If `f ≫ g = 0` implies `g = 0` for all `g`, then `g` is a monomorphism. -/\ntheorem ∀ {C : Type u_2} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasFiniteProducts C] [inst_3 : CategoryTheory.Limits.HasKernels C]\n  [inst_4 : CategoryTheory.NormalMonoCategory C] [inst_5 : CategoryTheory.Limits.HasZeroObject C] {X Y : C} (f : X ⟶ Y),\n  (∀ (Z : C) (g : Y ⟶ Z), CategoryTheory.CategoryStruct.comp f g = 0 → g = 0) → CategoryTheory.Epi f :=\n\n/-- If a function `f` is continuous and `f'` is strictly monotone on `ℝ` then `f` is strictly\nconvex. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict monotonicity of `f'`. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → StrictMono (deriv f) → StrictConvexOn ℝ Set.univ f :=\n\n/-- Let `f` be a function continuous on a convex (or, equivalently, connected) subset `D`\nof the real line. If `f` is differentiable on the interior of `D` and `C < f'`, then\n`f` grows faster than `C * x` on `D`, i.e., `C * (y - x) < f y - f x` whenever `x, y ∈ D`,\n`x < y`. -/\ntheorem ∀ {D : Set ℝ},\n  Convex ℝ D →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f D →\n        DifferentiableOn ℝ f (interior D) →\n          ∀ {C : (fun x => ℝ) 1},\n            (∀ (x : ℝ), x ∈ interior D → C < deriv f x) →\n              ∀ (x : ℝ), x ∈ D → ∀ (y : ℝ), y ∈ D → x < y → C * (y - x) < f y - f x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing. -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 → Monotone (deriv f) → Monotone (λ x, f x / x) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        MonotoneOn (deriv f) (Set.Ioi 0) →\n          MonotoneOn (λ x, f x / x) (Set.Ioi 0) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n  DifferentiableOn ℝ f (Set.Ioi 0) →\n  f 0 = 0 →\n  StrictMono (deriv f) →\n  StrictMono (fun x => f x / x) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        Monotone (deriv f) → Monotone (λ x, (f x) / x) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n  DifferentiableOn ℝ f (Set.Ioi 0) →\n  f 0 = 0 →\n  Monotone (deriv f) →\n  Monotone (λ x, f x / x) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        Monotone (deriv f) →\n          Monotone (λ x, f x / x) ",
      "∀ {f : ℝ → ℝ},\n  (∀ x, 0 ≤ x → ContinuousAt f x) →\n  (∀ x, 0 < x → DifferentiableAt ℝ f x) →\n  f 0 = 0 →\n  StrictMono (deriv f) →\n  StrictMono (λ x, (f x) / x) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        Monotone (deriv f) → Monotone (λ x, f x / x) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 → StrictMono (deriv f) → StrictMono (λ x, f x / x) ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ici 0) →\n    DifferentiableOn ℝ f (Set.Ioi 0) →\n      f 0 = 0 →\n        StrictMono (deriv f) → StrictMono (fun x => f x / x) "
    ]
  },
  {
    "docString": "Suppose $a \\in R^{1}, f$ is a twice-differentiable real function on $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, respectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] {s : Set X},\\n  IsPreconnected s →\\n    ∀ {a b : X},\\n      a ∈ s →\\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\\nthen for some `x ∈ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), 0 ≤ deriv^[2] f x) → ConvexOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is twice differentiable on `ℝ`, and `f''` is nonnegative on `ℝ`,\\nthen `f` is convex on `ℝ`. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has derivative `B'` everywhere on `ℝ`;\\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} {f f' : ℝ → ℝ},\\n  a ≤ b →\\n    (∀ (x : ℝ), x ∈ Set.Icc a b → HasDerivWithinAt f (f' x) (Set.Icc a b) x) →\\n      ∀ {m : ℝ}, f' a ≤ m → m ≤ f' b → m ∈ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a ≤ b` and `f' a ≤ m ≤ f' b`, then `f' c = m` for some\\n`c ∈ [a, b]`. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} {f f' : ℝ → ℝ},\\n  a ≤ b →\\n    (∀ (x : ℝ), x ∈ Set.Icc a b → HasDerivWithinAt f (f' x) (Set.Icc a b) x) →\\n      ∀ {m : ℝ}, f' a ≤ m → m ≤ f' b → m ∈ f' '' Set.Icc a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Darboux's theorem**: if `a ≤ b` and `f' b ≤ m ≤ f' a`, then `f' c = m` for some\\n`c ∈ [a, b]`. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          ContinuousOn B (Set.Icc a b) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f' x ≤ B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has derivative `B'` everywhere on `ℝ`;\\n* `f` has right derivative `f'` at every point of `[a, b)`;\\n* we have `f' x ≤ B' x` on `[a, b)`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"∀ {f f' : ℝ → ℝ} {a b : ℝ},\\n  ContinuousOn f (Set.Icc a b) →\\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\\n      ∀ {B B' : ℝ → ℝ},\\n        f a ≤ B a →\\n          ContinuousOn B (Set.Icc a b) →\\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x\",\n  \"isProp\": true,\n  \"docString\":\n  \"General fencing theorem for continuous functions with an estimate on the derivative.\\nLet `f` and `B` be continuous functions on `[a, b]` such that\\n\\n* `f a ≤ B a`;\\n* `B` has right derivative `B'` at every point of `[a, b)`;\\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\\n  is bounded above by a function `f'`;\\n* we have `f' x < B' x` whenever `f x = B x`.\\n\\nThen `f x ≤ B x` everywhere on `[a, b]`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (f g : α → ENNReal),\\n  ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ ≤ ∫⁻ (a : α), f a + g a ∂μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : ℝ → E),\\n  Filter.Tendsto (Real.fourierIntegral f) (Filter.cocompact ℝ) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Riemann-Lebesgue lemma for functions on `ℝ`, formulated via `Real.fourierIntegral`. \"}]\n",
    "prompt_cons": "/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\nthen for some `x ∈ s` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {s : Set X},\n  IsPreconnected s →\n    ∀ {a b : X},\n      a ∈ s →\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- If a function `f` is twice differentiable on `ℝ`, and `f''` is nonnegative on `ℝ`,\nthen `f` is convex on `ℝ`. -/\ntheorem ∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), 0 ≤ deriv^[2] f x) → ConvexOn ℝ Set.univ f :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has derivative `B'` everywhere on `ℝ`;\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          (∀ (x : ℝ), HasDerivAt B (B' x) x) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- **Darboux's theorem**: if `a ≤ b` and `f' a ≤ m ≤ f' b`, then `f' c = m` for some\n`c ∈ [a, b]`. -/\ntheorem ∀ {a b : ℝ} {f f' : ℝ → ℝ},\n  a ≤ b →\n    (∀ (x : ℝ), x ∈ Set.Icc a b → HasDerivWithinAt f (f' x) (Set.Icc a b) x) →\n      ∀ {m : ℝ}, f' a ≤ m → m ≤ f' b → m ∈ f' '' Set.Icc a b :=\n\n/-- **Darboux's theorem**: if `a ≤ b` and `f' b ≤ m ≤ f' a`, then `f' c = m` for some\n`c ∈ [a, b]`. -/\ntheorem ∀ {a b : ℝ} {f f' : ℝ → ℝ},\n  a ≤ b →\n    (∀ (x : ℝ), x ∈ Set.Icc a b → HasDerivWithinAt f (f' x) (Set.Icc a b) x) →\n      ∀ {m : ℝ}, f' a ≤ m → m ≤ f' b → m ∈ f' '' Set.Icc a b :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has derivative `B'` everywhere on `ℝ`;\n* `f` has right derivative `f'` at every point of `[a, b)`;\n* we have `f' x ≤ B' x` on `[a, b)`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt f (f' x) (Set.Ici x) x) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          ContinuousOn B (Set.Icc a b) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f' x ≤ B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- General fencing theorem for continuous functions with an estimate on the derivative.\nLet `f` and `B` be continuous functions on `[a, b]` such that\n\n* `f a ≤ B a`;\n* `B` has right derivative `B'` at every point of `[a, b)`;\n* for each `x ∈ [a, b)` the right-side limit inferior of `(f z - f x) / (z - x)`\n  is bounded above by a function `f'`;\n* we have `f' x < B' x` whenever `f x = B x`.\n\nThen `f x ≤ B x` everywhere on `[a, b]`. -/\ntheorem ∀ {f f' : ℝ → ℝ} {a b : ℝ},\n  ContinuousOn f (Set.Icc a b) →\n    (∀ (x : ℝ), x ∈ Set.Ico a b → ∀ (r : ℝ), f' x < r → ∃ᶠ (z : ℝ) in nhdsWithin x (Set.Ioi x), slope f x z < r) →\n      ∀ {B B' : ℝ → ℝ},\n        f a ≤ B a →\n          ContinuousOn B (Set.Icc a b) →\n            (∀ (x : ℝ), x ∈ Set.Ico a b → HasDerivWithinAt B (B' x) (Set.Ici x) x) →\n              (∀ (x : ℝ), x ∈ Set.Ico a b → f x = B x → f' x < B' x) → ∀ ⦃x : ℝ⦄, x ∈ Set.Icc a b → f x ≤ B x :=\n\n/-- The sum of the lower Lebesgue integrals of two functions is less than or equal to the integral\nof their sum. The other inequality needs one of these functions to be (a.e.-)measurable. -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} (f g : α → ENNReal),\n  ∫⁻ (a : α), f a ∂μ + ∫⁻ (a : α), g a ∂μ ≤ ∫⁻ (a : α), f a + g a ∂μ :=\n\n/-- The Riemann-Lebesgue lemma for functions on `ℝ`, formulated via `Real.fourierIntegral`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : ℝ → E),\n  Filter.Tendsto (Real.fourierIntegral f) (Filter.cocompact ℝ) (nhds 0) :=\n\n/-- Suppose $a \\in R^{1}, f$ is a twice-differentiable real function on $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, respectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$ -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ} {a : ℝ},\n  Differentiable ℝ f → Differentiable ℝ (deriv f) →\n    ∀ {M₀ M₁ M₂ : ℝ},\n      (∀ (x : ℝ), a < x → abs (f x) ≤ M₀) →\n        (∀ (x : ℝ), a < x → abs (deriv f x) ≤ M₁) →\n          (∀ (x : ℝ), a < x → abs (deriv^[2] f x) ≤ M₂) → M₁^2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      ∀ {a M₀ M₁ M₂ : ℝ},\n        (∀ (x : ℝ), a < x → abs (f x) ≤ M₀) →\n          (∀ (x : ℝ), a < x → abs (deriv f x) ≤ M₁) →\n            (∀ (x : ℝ), a < x → abs (deriv^[2] f x) ≤ M₂) → M₁^2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ} {a M₀ M₁ M₂ : ℝ},\n  (∀ x, a < x → ∃ z, deriv f x = z) →\n    (∀ x, a < x → ∃ z, deriv^[2] f x = z) →\n      (∀ x, a < x → abs (f x) ≤ M₀) →\n        (∀ x, a < x → abs (deriv f x) ≤ M₁) →\n          (∀ x, a < x → abs (deriv^[2] f x) ≤ M₂) → M₁^2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ} {a : ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      (∀ (x : ℝ), x > a → ∃ (M₀ M₁ M₂ : ℝ), 0 ≤ M₀ ∧ 0 ≤ M₁ ∧ 0 ≤ M₂ ∧ abs (f x) ≤ M₀ ∧ abs (deriv f x) ≤ M₁ ∧ abs (deriv^[2] f x) ≤ M₂) →\n        ∃ (M₀ M₁ M₂ : ℝ), 0 ≤ M₀ ∧ 0 ≤ M₁ ∧ 0 ≤ M₂ ∧ M₁^2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ} {a : ℝ},\n  Differentiable ℝ f → Differentiable ℝ (deriv f) →\n    ∀ {M₀ M₁ M₂ : ℝ},\n      (∀ x, a < x → abs (f x) ≤ M₀) →\n        (∀ x, a < x → abs (deriv f x) ≤ M₁) →\n          (∀ x, a < x → abs (deriv^[2] f x) ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ} {a : ℝ},\n  Differentiable ℝ f →\n    Differentiable ℝ (deriv f) →\n      (∀ (x : ℝ), a < x → ∀ (n : ℕ), n < 2 → ∃ M, ∀ (y : ℝ), a < y → abs (iterated_deriv_within n f (Set.Ioi a) y) ≤ M) →\n        ∃ M1 M0 M2, 0 ≤ M1 ∧ 0 ≤ M0 ∧ 0 ≤ M2 ∧ M1 ^ 2 ≤ 4 * M0 * M2 ",
      "∀ {f : ℝ → ℝ} {a : ℝ},\n  Differentiable ℝ f → Differentiable ℝ (deriv f) →\n    ∀ {M₀ M₁ M₂ : ℝ},\n      (∀ (x : ℝ), a < x → abs (f x) ≤ M₀) →\n        (∀ (x : ℝ), a < x → abs (deriv f x) ≤ M₁) →\n          (∀ (x : ℝ), a < x → abs (deriv^[2] f x) ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) → (∀ (x : ℝ), a < x → (∃ M₀ M₁ M₂ : ℝ, 0 ≤ M₀ ∧ 0 ≤ M₁ ∧ 0 ≤ M₂ ∧ abs (f x) ≤ M₀ ∧ abs (deriv f x) ≤ M₁ ∧ abs (deriv^[2] f x) ≤ M₂)) → ∃ M₀ M₁ M₂ : ℝ, 0 ≤ M₀ ∧ 0 ≤ M₁ ∧ 0 ≤ M₂ ∧ M₁^2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) →\n  (∀ (x : ℝ), a < x → abs (f x) ≤ M₀) → (∀ (x : ℝ), a < x → abs (deriv f x) ≤ M₁) → (∀ (x : ℝ), a < x → abs (deriv^[2] f x) ≤ M₂) → M₁ ^ 2 ≤ 4 * M₀ * M₂ ",
      "∀ {f : ℝ → ℝ}, Differentiable ℝ f → Differentiable ℝ (deriv f) →\n  (∀ (a : ℝ), ∃ M0 M1 M2 : ℝ,\n    (∀ x : ℝ, a < x → abs (f x) ≤ M0) →\n    (∀ x : ℝ, a < x → abs (deriv f x) ≤ M1) →\n    (∀ x : ℝ, a < x → abs (deriv^[2] f x) ≤ M2) →\n    M1^2 ≤ 4 * M0 * M2) "
    ]
  },
  {
    "docString": "Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [hα : LocallyCompactSpace α] {K U : Set α},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ L, IsCompact L ∧ K ⊆ interior L ∧ L ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K ⊆ U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K ⊆ L ⊆ U`: equivalently, there is a\\ncompact `L` such that `K ⊆ interior L` and `L ⊆ U`. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T0Space α] {s : Set α},\\n  Set.Finite s → Set.Nonempty s → IsOpen s → ∃ x, x ∈ s ∧ IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [inst_1 : DiscreteTopology ↑s] {x : α},\\n  x ∈ s → ∃ U, U ∈ nhdsWithin x {x}ᶜ ∧ Disjoint U s\",\n  \"isProp\": true,\n  \"docString\":\n  \"For point `x` in a discrete subset `s` of a topological space, there is a set `U`\\nsuch that\\n1. `U` is a punctured neighborhood of `x` (ie. `U ∪ {x}` is a neighbourhood of `x`),\\n2. `U` is disjoint from `s`.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\\n  U ∈ ⨆ (x : α) (_ : x ∈ s), nhds x → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.fst\",\n  \"isProp\": true,\n  \"docString\":\n  \"The first projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"}]\n",
    "prompt_cons": "/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- In a locally compact space, for every containment `K ⊆ U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K ⊆ L ⊆ U`: equivalently, there is a\ncompact `L` such that `K ⊆ interior L` and `L ⊆ U`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [hα : LocallyCompactSpace α] {K U : Set α},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ L, IsCompact L ∧ K ⊆ interior L ∧ L ⊆ U :=\n\n/-- Let `s, t ⊆ X` be two subsets of a topological space `X`.  If `t ⊆ s` and the topology induced\nby `X`on `s` is discrete, then also the topology induces on `t` is discrete. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {s t : Set X}, DiscreteTopology ↑s → t ⊆ s → DiscreteTopology ↑t :=\n\n/-- Given an open finite set `S` in a T₀ space, there is some `x ∈ S` such that `{x}` is open. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T0Space α] {s : Set α},\n  Set.Finite s → Set.Nonempty s → IsOpen s → ∃ x, x ∈ s ∧ IsOpen {x} :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n\n/-- For point `x` in a discrete subset `s` of a topological space, there is a set `U`\nsuch that\n1. `U` is a punctured neighborhood of `x` (ie. `U ∪ {x}` is a neighbourhood of `x`),\n2. `U` is disjoint from `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} [inst_1 : DiscreteTopology ↑s] {x : α},\n  x ∈ s → ∃ U, U ∈ nhdsWithin x {x}ᶜ ∧ Disjoint U s :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\n  U ∈ ⨆ (x : α) (_ : x ∈ s), nhds x → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.fst :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ (U : Set X), IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x, x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x, x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x ∈ A, ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {A : Set α},\n  (∀ x ∈ A, ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X}, (∀ (x : X), x ∈ A → ∃ U, x ∈ U ∧ IsOpen U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ x ∈ A, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {A : Set X},\n  (∀ (x : X), x ∈ A → ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) → IsOpen A "
    ]
  },
  {
    "docString": "If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\\n  (F : ι → C(α, β)),\\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `α`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\\nwhere `Π i, π i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\\n  ContinuousMap.compactOpen =\\n    ⨅ (s : Set α) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  t = TopologicalSpace.generateFrom s →\\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β],\\n  Inducing (↑UniformFun.ofFun ∘ FunLike.coe)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on `α →ᵇ β` is exactly the topology induced by the natural map to `α →ᵤ β`. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖) :=\n\n/-- A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `α`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\n  (F : ι → C(α, β)),\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem ∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\n  Inducing fun x i => f i x :=\n\n/-- The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  ContinuousMap.compactOpen =\n    ⨅ (s : Set α) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s}) :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- The topology on `α →ᵇ β` is exactly the topology induced by the natural map to `α →ᵤ β`. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β],\n  Inducing (↑UniformFun.ofFun ∘ FunLike.coe) :=\n\n/-- If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {X : Type u} [inst : (a : α) → TopologicalSpace (X a)] (f : (a : α) → TopologicalSpace.Opens (X a)),\n  IsTopologicalBasis ⋂₀ (SetOf fun U => ∃ (a : α), U ∈ f a) ",
      "∀ {α : Type u} {X : Type v} {ι : Type w} [inst_1 : (i : ι) → TopologicalSpace α],\n  TopologicalSpace X ",
      "∀ {α : Type u} {X : Type v} [inst : (a : α) → TopologicalSpace (X a)], TopologicalSpace (Π a, X a) ",
      "∀ {α : Type u} {X : Type v} (T : α → TopologicalSpace X),\n  TopologicalSpace X ",
      "∀ {α : Type u} {X : Type v} [inst : (a : α) → TopologicalSpace (X a)], TopologicalSpace X ",
      "∀ {α : Type u} {X : Type v} {T : α → TopologicalSpace X},\n  TopologicalSpace.IsTopologicalBasis (⋂ (i : α), TopologicalSpace.IsTopologicalBasis (T i)) ",
      "∀ {α : Type u} {X : Type v} {T : α → TopologicalSpace X},\n  TopologicalSpace X ",
      "∀ {α : Type u_2} {X : Type u_1} (T : α → TopologicalSpace X),\n  TopologicalSpace X ",
      "∀ {α : Type u_1} {X : Type u_2} (𝔗 : α → TopologicalSpace X),\n  TopologicalSpace.IsTopologicalBasis (⋂ i, (TopologicalSpace.IsTopologicalBasis B i).to_has_basis) ",
      "∀ {α : Type u_1} {X : Type u} (T : α → TopologicalSpace X),\n  TopologicalSpace.IsTopologicalBasis (⋂ (i : α), (T i).IsOpen) "
    ]
  },
  {
    "docString": "Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\\nwhere `Π i, π i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\\n  ContinuousMap.compactOpen =\\n    ⨅ (s : Set α) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\\n  (F : ι → C(α, β)),\\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\\nit converges in the compact-open topology on each compact subset of `α`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\\n  IsCompact s →\\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every open cover of a compact set, there exists a finite subcover. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"}]\n",
    "prompt_cons": "/-- If `𝔖` covers `α`, then the topology of `𝔖`-convergence is T₂. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : UniformSpace β] {𝔖 : Set (Set α)} [inst_1 : T2Space β],\n  ⋃₀ 𝔖 = Set.univ → T2Space (UniformOnFun α β 𝔖) :=\n\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem ∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\n  Inducing fun x i => f i x :=\n\n/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- The compact-open topology on `C(α, β)` is equal to the infimum of the compact-open topologies\non `C(s, β)` for `s` a compact subset of `α`.  The key point of the proof is that the union of the\ncompact subsets of `α` is equal to the union of compact subsets of the compact subsets of `α`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  ContinuousMap.compactOpen =\n    ⨅ (s : Set α) (_ : IsCompact s), TopologicalSpace.induced (ContinuousMap.restrict s) ContinuousMap.compactOpen :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- A family `F` of functions in `C(α, β)` converges in the compact-open topology, if and only if\nit converges in the compact-open topology on each compact subset of `α`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : LocallyCompactSpace α] [inst_3 : T2Space β] {ι : Type u_3} {l : Filter ι} [inst_4 : Filter.NeBot l]\n  (F : ι → C(α, β)),\n  (∃ f, Filter.Tendsto F l (nhds f)) ↔\n    ∀ (s : Set α), IsCompact s → ∃ f, Filter.Tendsto (fun i => ContinuousMap.restrict s (F i)) l (nhds f) :=\n\n/-- For every open cover of a compact set, there exists a finite subcover. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] {s : Set α} {b : Set ι} {c : ι → Set α},\n  IsCompact s →\n    (∀ (i : ι), i ∈ b → IsOpen (c i)) →\n      s ⊆ ⋃ (i : ι) (_ : i ∈ b), c i → ∃ b', b' ⊆ b ∧ Set.Finite b' ∧ s ⊆ ⋃ (i : ι) (_ : i ∈ b'), c i :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {ι : Type u_1} (T : ι → TopologicalSpace α),\n  ∃! (T₀ : TopologicalSpace α), ∀ (i : ι), T i ≤ T₀ ",
      "∀ {α : Type u} {ι : Type u_1} [inst : (i : ι) → TopologicalSpace α],\n  ∃! T : TopologicalSpace α, ∀ i : ι, TopologicalSpace.coarser T (inst i) ",
      "∀ {α : Type u} {ι : Type u_1} [inst : (i : ι) → TopologicalSpace (α i)],\n  ∃! s, ∀ i, s ≤ inst i ",
      "∀ {α : Type u} {ι : Type u_1} [inst : (i : ι) → TopologicalSpace (α i)] (T : ι → TopologicalSpace α),\n  TopologicalSpace.generateFrom (Set.Unionₓ fun i => (T i).bases) = ⨅ i, T i ",
      "forall {α : Type u} {ι : Type u_1} {T : ι → TopologicalSpace α},\n  ∃! (T' : TopologicalSpace α), ∀ (i : ι), T i ≤ T' ",
      "∀ {α : Type u} {ι : Type u_1} [inst : Π (a : ι), TopologicalSpace (α a)],\n  ∃! (T : TopologicalSpace α), ∀ (a : ι), inst a ≤ T ",
      "∀ {α : Type u} {ι : Type u_1} [inst : (i : ι) → TopologicalSpace α] (𝔗 : ι → Set (Set α)),\n  ∃! T : TopologicalSpace α, ∀ i, 𝔗 i ≤ coe T ",
      "∀ {α : Type u} {X : Type u_1} [inst : (α: α) → TopologicalSpace (X α)],\n  exists_unique (λ t : TopologicalSpace X, ∀ a, inst a ≤ t) ",
      "∀ {α : Type u} {ι : Type u_1} [inst : (i : ι) → TopologicalSpace (α i)],\n  ∃ (a : TopologicalSpace α), ∀ (b : TopologicalSpace α), (∀ (i : ι), (inst i).to_has_basis.is_open ≤ b.to_has_basis.is_open) → a.to_has_basis.is_open ≤ b.to_has_basis.is_open ",
      "∀ {α : Type u} {ι : Type u_1} (t : ι → TopologicalSpace α),\n  ∃! t' : TopologicalSpace α, ∀ (i : ι), t' ≤ t i "
    ]
  },
  {
    "docString": "Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  t = TopologicalSpace.generateFrom s →\\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → TopologicalSpace (E i)] {s : (i : ι) → Set (Set (E i))},\\n  (∀ (i : ι), TopologicalSpace.IsTopologicalBasis (s i)) →\\n    TopologicalSpace.IsTopologicalBasis (⋃ (i : ι), (fun u => Sigma.mk i '' u) '' s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\\ntopological bases on each of the parts of the space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\\n  TopologicalSpace.IsTopologicalBasis s →\\n    ∀ {t : Set (Set β)},\\n      TopologicalSpace.IsTopologicalBasis t →\\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\\ntopological bases on each of the two components. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  (∀ (u : Set α), u ∈ s → IsOpen u) →\\n    (∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v, v ∈ s ∧ a ∈ v ∧ v ⊆ u) → TopologicalSpace.IsTopologicalBasis s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of open sets `s` is such that every open neighbourhood contains some\\nmember of `s`, then `s` is a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] {f : α → β},\\n  Inducing f → tα = TopologicalSpace.induced f tβ\",\n  \"isProp\": true,\n  \"docString\": \"The topology on the domain is equal to the induced topology. \"}]\n",
    "prompt_cons": "/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s}) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- In a disjoint union space `Σ i, E i`, one can form a topological basis by taking the union of\ntopological bases on each of the parts of the space. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → TopologicalSpace (E i)] {s : (i : ι) → Set (Set (E i))},\n  (∀ (i : ι), TopologicalSpace.IsTopologicalBasis (s i)) →\n    TopologicalSpace.IsTopologicalBasis (⋃ (i : ι), (fun u => Sigma.mk i '' u) '' s i) :=\n\n/-- In a sum space `α ⊕ β`, one can form a topological basis by taking the union of\ntopological bases on each of the two components. -/\ntheorem ∀ {α : Type u} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s →\n    ∀ {t : Set (Set β)},\n      TopologicalSpace.IsTopologicalBasis t →\n        TopologicalSpace.IsTopologicalBasis ((fun u => Sum.inl '' u) '' s ∪ (fun u => Sum.inr '' u) '' t) :=\n\n/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- If a family of open sets `s` is such that every open neighbourhood contains some\nmember of `s`, then `s` is a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  (∀ (u : Set α), u ∈ s → IsOpen u) →\n    (∀ (a : α) (u : Set α), a ∈ u → IsOpen u → ∃ v, v ∈ s ∧ a ∈ v ∧ v ⊆ u) → TopologicalSpace.IsTopologicalBasis s :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- The topology on the domain is equal to the induced topology. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [tα : TopologicalSpace α] [tβ : TopologicalSpace β] {f : α → β},\n  Inducing f → tα = TopologicalSpace.induced f tβ :=\n\n/-- Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {s : Set (Set α)} [t₁ : TopologicalSpace α],\n  TopologicalSpace.IsTopologicalBasis s →\n    ∀ (t₂ : TopologicalSpace α), (∀ (u : Set α), u ∈ s → TopologicalSpace.IsOpen t₂ u) →\n      ∀ (u : Set α), TopologicalSpace.IsOpen t₁ u → TopologicalSpace.IsOpen t₂ u ",
      "∀ {α : Type u} {s : Set (Set α)} {t : TopologicalSpace α},\n  TopologicalSpace.IsTopologicalBasis s →\n    (∀ (τ : TopologicalSpace α), (∀ (u : Set α), u ∈ s → τ.is_open u) → TopologicalSpace.generateFrom s ≤ τ) →\n      t = TopologicalSpace.generateFrom s ",
      "∀ {α : Type u} {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s →\n    TopologicalSpace.generateFrom s = ⋂₀ {𝒯 : Set (Set α) | s ⊆ 𝒯 ∧ TopologicalSpace.is_open TopologicalSpace.mkOfOpen 𝒯} ",
      "∀ {α : Type u} (A : Set (Set α)),\n  TopologicalSpace.IsTopologicalBasis A →\n    TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace α | A ⊆ t.is_open_set'} ",
      "∀ {α : Type u} {A : Set (Set α)} (t : TopologicalSpace α),\n  TopologicalSpace.IsTopologicalBasis A →\n    t = TopologicalSpace.generateFrom A ↔ ∀ (u : Set α), u ∈ A → t.is_open u ",
      "∀ {α : Type u} [t : TopologicalSpace α] {A : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis A →\n    t = Inf {u : TopologicalSpace α | A ⊆ u.1} ",
      "∀ {α : Type u} {A : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis A →\n    TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace α | A ⊆ t.opens} ",
      "∀ {α : Type u} {s : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis s →\n    TopologicalSpace.generateFrom s = ⋂₀ {t : TopologicalSpace α | s ⊆ t.istopologicalbasis'} ",
      "∀ {α : Type u} {A : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis A →\n    TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace α | A ⊆ t.2} ",
      "∀ {α : Type u} {A : Set (Set α)},\n  TopologicalSpace.IsTopologicalBasis A →\n    TopologicalSpace.generateFrom A = Inf {t : TopologicalSpace α | A ⊆ t.sets} "
    ]
  },
  {
    "docString": "Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic field extension, then the Krull topology on `L ≃ₐ[K] L` is\\ntotally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  Algebra.IsIntegral K L → T2Space (L ≃ₐ[K] L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `L/K` is an algebraic extension, then the Krull topology on `L ≃ₐ[K] L` is Hausdorff. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E], UniformSpace.toTopologicalSpace ≤ WeakDual.instTopologicalSpace\",\n  \"isProp\": true,\n  \"docString\":\n  \"The weak-star topology is coarser than the dual-norm topology. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L], TopologicalGroup (L ≃ₐ[K] L)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a field extension `L/K`, the Krull topology on `L ≃ₐ[K] L` makes it a topological group. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] (a : α),\\n  IsClosed (Set.Ici a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\":\n  \"∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\\n  ∃ f, Embedding f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A T₃ topological space with second countable topology can be embedded into `l^∞ = ℕ →ᵇ ℝ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  IsOpen s → IsLowerSet s\",\n  \"isProp\": true,\n  \"docString\": \"Every set open in the lower topology is a lower set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : DecidableEq α] {𝒜 ℬ : Finset (Finset α)} [inst_1 : Fintype α],\\n  IsUpperSet ↑𝒜 → IsLowerSet ↑ℬ → 2 ^ Fintype.card α * Finset.card (𝒜 ∩ ℬ) ≤ Finset.card 𝒜 * Finset.card ℬ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Harris-Kleitman inequality**: Upper sets and lower sets of finsets anticorrelate. \"}]\n",
    "prompt_cons": "/-- If `L/K` is an algebraic field extension, then the Krull topology on `L ≃ₐ[K] L` is\ntotally disconnected. -/\ntheorem ∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L → IsTotallyDisconnected Set.univ :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- If `L/K` is an algebraic extension, then the Krull topology on `L ≃ₐ[K] L` is Hausdorff. -/\ntheorem ∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  Algebra.IsIntegral K L → T2Space (L ≃ₐ[K] L) :=\n\n/-- The weak-star topology is coarser than the dual-norm topology. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : SeminormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E], UniformSpace.toTopologicalSpace ≤ WeakDual.instTopologicalSpace :=\n\n/-- For a field extension `L/K`, the Krull topology on `L ≃ₐ[K] L` makes it a topological group. -/\ntheorem ∀ (K : Type u_1) (L : Type u_2) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L], TopologicalGroup (L ≃ₐ[K] L) :=\n\n/-- Left-closed right-infinite intervals [a, ∞) are closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] (a : α),\n  IsClosed (Set.Ici a) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- A T₃ topological space with second countable topology can be embedded into `l^∞ = ℕ →ᵇ ℝ`. -/\ntheorem ∀ (X : Type u_1) [inst : TopologicalSpace X] [inst_1 : T3Space X] [inst_2 : TopologicalSpace.SecondCountableTopology X],\n  ∃ f, Embedding f :=\n\n/-- Every set open in the lower topology is a lower set. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  IsOpen s → IsLowerSet s :=\n\n/-- **Harris-Kleitman inequality**: Upper sets and lower sets of finsets anticorrelate. -/\ntheorem ∀ {α : Type u_1} [inst : DecidableEq α] {𝒜 ℬ : Finset (Finset α)} [inst_1 : Fintype α],\n  IsUpperSet ↑𝒜 → IsLowerSet ↑ℬ → 2 ^ Fintype.card α * Finset.card (𝒜 ∩ ℬ) ≤ Finset.card 𝒜 * Finset.card ℬ :=\n\n/-- Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable. -/\ntheorem",
    "choices": [
      "∀ (R : Type u_1) [inst : LinearOrderedField R] [inst_1 : TopologicalSpace R] [inst_2 : LowerLimTopology R] [inst_3 : KTopology R],\n  ¬(UniformSpace.toTopologicalSpace ≤ LowerLimTopology.instTopologicalSpace) ∧ ¬(LowerLimTopology.instTopologicalSpace ≤ UniformSpace.toTopologicalSpace) ",
      "not_comparable_lower_K : ¬ (UniformSpace.toTopologicalSpace ℝ≥0 ≤ LowerTopology ℝ ∧ UniformSpace.toTopologicalSpace ℝ≥0 ≤ KTopology ℝ) ",
      "not_comparable_lower_limit_and_K_topology : ¬(UniformSpace.toTopologicalSpace ℝ_ℓ ≤ TopologicalSpace ℝ_K ∧ UniformSpace.toTopologicalSpace ℝ_K ≤ TopologicalSpace ℝ_ℓ) ",
      "forall {α : Type u_1} [inst : TopologicalSpace α] {K : Set α},\n  TopologicalSpace.IsKTopology K →\n  ¬ (TopologicalSpace.lowerLimitTopology ≤ TopologicalSpace.KTopology K) ∧\n  ¬ (TopologicalSpace.KTopology K ≤ TopologicalSpace.lowerLimitTopology) ",
      "not_comparable_lower_k_topology : ¬ (Topology.lower ℝ ≤ Topology.K ℝ) ∧ ¬ (Topology.K ℝ ≤ Topology.lower ℝ) ",
      "∀ {R : Type u_1} [inst : LinearOrderedField R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R] [inst_3 : LowerLimitTopology R] [inst_4 : KTopology R],\n  ¬LowerLimitTopology R ≤ KTopology R ∧ ¬KTopology R ≤ LowerLimitTopology R ",
      "not_comparable_lower_limit_top_k_topology :\n  ¬(UniformSpace.toTopologicalSpace ≤ LowerLimitTopology ℝ ∧\n    UniformSpace.toTopologicalSpace ≤ KTopology ℝ) ",
      "noncomparable_topologies : ∀ {α : Type u_1} [inst : TopologicalSpace α] (l : TopologicalSpace α) (K : TopologicalSpace α),\n  l ≠ K → l ≤ K ∨ K ≤ l ",
      "NotComparableLowerLimitTopKTop : ∃ (a b : ℝ), IsOpen a ∧ IsOpen b ∧ ¬(a ≤ b) ∧ ¬(b ≤ a) ",
      "NotComparableLowerAndKTopology : TopologicalSpace.NotComparable (LowerTopology ℝ) (TopologicalSpace.kTopology ℝ) "
    ]
  },
  {
    "docString": "Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis \\\"downstairs\\\" in an open quotient is a topological basis. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\\n  TopologicalSpace.IsTopologicalBasis V →\\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The image of a topological basis under an open quotient map is a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\\n      MeasureTheory.Integrable bound →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Lebesgue dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Dominated convergence theorem for filters with a countable basis \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\\n  t = TopologicalSpace.generateFrom s →\\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s})\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a family of sets `s` generates the topology, then intersections of finite\\nsubcollections of `s` form a topological basis. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists a countable set of sets that generates the topology. \"},\n {\"theorem\":\n  \"∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\\n  Algebra.discr K ↑b ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Over a field, if `b` is a basis, then `Algebra.discr K b ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n ≤\\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. \"},\n {\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"}]\n",
    "prompt_cons": "/-- The image of a topological basis \"downstairs\" in an open quotient is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    IsOpenMap Quotient.mk' → TopologicalSpace.IsTopologicalBasis (Set.image Quotient.mk' '' V) :=\n\n/-- The image of a topological basis under an open quotient map is a topological basis. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y] {π : X → Y} {V : Set (Set X)},\n  TopologicalSpace.IsTopologicalBasis V →\n    QuotientMap π → IsOpenMap π → TopologicalSpace.IsTopologicalBasis (Set.image π '' V) :=\n\n/-- Lebesgue dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]\n  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}\n  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} (hT : MeasureTheory.DominatedFinMeasAdditive μ T C)\n  {ι : Type u_4} {l : Filter ι} [inst_5 : Filter.IsCountablyGenerated l] {fs : ι → α → E} {f : α → E} (bound : α → ℝ),\n  (∀ᶠ (n : ι) in l, MeasureTheory.AEStronglyMeasurable (fs n) μ) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, ‖fs n a‖ ≤ bound a) →\n      MeasureTheory.Integrable bound →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => fs n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => MeasureTheory.setToFun μ T hT (fs n)) l (nhds (MeasureTheory.setToFun μ T hT f)) :=\n\n/-- Dominated convergence theorem for filters with a countable basis -/\ntheorem ∀ {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {ι : Type u_1} {l : Filter ι}\n  [inst : Filter.IsCountablyGenerated l] {F : ι → α → ENNReal} {f : α → ENNReal} (bound : α → ENNReal),\n  (∀ᶠ (n : ι) in l, Measurable (F n)) →\n    (∀ᶠ (n : ι) in l, ∀ᵐ (a : α) ∂μ, F n a ≤ bound a) →\n      ∫⁻ (a : α), bound a ∂μ ≠ ⊤ →\n        (∀ᵐ (a : α) ∂μ, Filter.Tendsto (fun n => F n a) l (nhds (f a))) →\n          Filter.Tendsto (fun n => ∫⁻ (a : α), F n a ∂μ) l (nhds (∫⁻ (a : α), f a ∂μ)) :=\n\n/-- If a family of sets `s` generates the topology, then intersections of finite\nsubcollections of `s` form a topological basis. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  t = TopologicalSpace.generateFrom s →\n    TopologicalSpace.IsTopologicalBasis ((fun f => ⋂₀ f) '' {f | Set.Finite f ∧ f ⊆ s}) :=\n\n/-- There exists a countable set of sets that generates the topology. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SecondCountableTopology α],\n  ∃ b, Set.Countable b ∧ t = TopologicalSpace.generateFrom b :=\n\n/-- Over a field, if `b` is a basis, then `Algebra.discr K b ≠ 0`. -/\ntheorem ∀ {ι : Type w} [inst : DecidableEq ι] [inst_1 : Fintype ι] (K : Type u) {L : Type v} [inst_2 : Field K]\n  [inst_3 : Field L] [inst_4 : Algebra K L] [inst_5 : Module.Finite K L] [inst_6 : IsSeparable K L] (b : Basis ι K L),\n  Algebra.discr K ↑b ≠ 0 :=\n\n/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- Shows that the sequence of denominators is monotone, that is `Bₙ ≤ Bₙ₊₁`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n ≤\n    GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1) :=\n\n/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : DenseOrder α],\n  TopologicalSpace.IsTopologicalBasis {s : Set α | ∃ (a b : α), a < b ∧ a.is_rat ∧ b.is_rat ∧ s = Set.Ioo a b} ",
      "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : DenselyOrdered α],\n  ∀ {s : Set α}, TopologicalSpace.IsTopologicalBasis s → s ≠ TopologicalSpace.CountableBasisOfDifferentTopology ",
      "forall {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α],\n  let s ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] [inst_3 : DenselyOrdered α],\n  ∃ b, Set.Countable b ∧ ¬TopologicalSpace.generateFrom ((fun a b => Set.Ioo a b) '' b) = TopologicalSpace.generateFrom\n    ((fun a b => Set.Ioo a b) '' {p : ℚ × ℚ | p.fst < p.snd}) ",
      "∀ {α : Type u} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α],\n  let U ",
      "forall {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α] (x : α),\n  ∃ s H, x ∈ s ∧ IsOpen s ∧ ∀ (t : Set α), x ∈ t → IsOpen t → s ⊆ t ",
      "∀ {α : Type u} [t : TopologicalSpace α] {s : Set (Set α)},\n  (∀ a b : α, a < b → ∃ u ∈ s, a ∈ u ∧ u ⊆ Iio b) →\n    t = TopologicalSpace.generateFrom s →\n      t ≠ TopologicalSpace.generateFrom {U | ∃ a, U = Set.Ioi a} ",
      "∀ {α : Type u} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] {ι : Type u_1} {s : ι → Set α},\n  (∀ (i : ι), IsOpen (s i)) →\n    (∀ (i : ι), HasSubset.Subset (Set.Ioo (Set.inf (s i)) (Set.sup (s i))) (s i)) →\n      (∃ t, ¬(LinearOrderₓ.lowerTopology α).EqTop t) →\n        TopologicalSpace.IsTopologicalBasis (SetOf fun s => ∃ (i : ι), s = Set.Ioo (Set.inf (s i)) (Set.sup (s i))) ",
      "∀ {α : Type u_1} [_inst_1 : LinearOrderedField α] {β : Type u_2} [inst : TopologicalSpace β] [inst_2 : LinearOrder β]\n  {f : α → β} (hf : Continuous f),\n  TopologicalSpace.IsTopologicalBasis (Set.Range (λ p : ℕ × ℕ, (coe p.fst / coe p.snd, coe (p.fst + 1) / coe p.snd))) →\n    Continuous f ",
      "forall {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α],\n  (Set.Range fun ab => Set.Ico (coe (ab : ℚ × ℚ).fst) (coe (ab : ℚ × ℚ).snd)) ≠\n    (Set.Range fun ab => Set.Iio (coe (ab : ℚ × ℚ).snd)) "
    ]
  },
  {
    "docString": "A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\\nhomotopic to `ContinuousMap.pi f₁`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : FiniteDimensional 𝕜 E]\\n  (f : F →ₗ[𝕜] E), Function.Surjective ↑f → IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A surjective linear map `f` with finite dimensional codomain is an open map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, IsOpenMap ↑f.linear ↔ IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is an affine map, then its linear part is an open map iff `f` is an open map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"The second projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace E] {f : E → F} {f' : E → E ≃L[𝕜] F},\\n  (∀ (x : E), HasStrictFDerivAt f (↑(f' x)) x) → IsOpenMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has an invertible strict derivative at all points, then it is an open map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.fst\",\n  \"isProp\": true,\n  \"docString\":\n  \"The first projection in a product of topological spaces sends open sets to open sets. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E →L[𝕜] F)\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective ↑f → IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\\nopen. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {f f' : 𝕜 → 𝕜},\\n  (∀ (x : 𝕜), HasStrictDerivAt f (f' x) x) → (∀ (x : 𝕜), f' x ≠ 0) → IsOpenMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a non-zero strict derivative at all points, then it is an open map. \"},\n {\"theorem\":\n  \"∀ {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S},\\n  OpenEmbedding ↑f →\\n    OpenEmbedding ↑g →\\n      OpenEmbedding\\n        ↑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X ⟶ S`, `Y ⟶ S` are open embeddings, then so is `X ×ₛ Y ⟶ S`. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- If each `f₀ i : C(X, Y i)` is homotopic to `f₁ i : C(X, Y i)`, then `ContinuousMap.pi f₀` is\nhomotopic to `ContinuousMap.pi f₁`. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} {Y : ι → Type u_2} [inst_1 : (i : ι) → TopologicalSpace (Y i)]\n  {f₀ f₁ : (i : ι) → C(X, Y i)},\n  (∀ (i : ι), ContinuousMap.Homotopic (f₀ i) (f₁ i)) →\n    ContinuousMap.Homotopic (ContinuousMap.pi f₀) (ContinuousMap.pi f₁) :=\n\n/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : Module 𝕜 E]\n  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F : Type w}\n  [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F] [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F]\n  [inst_9 : ContinuousSMul 𝕜 F] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E] [inst_12 : FiniteDimensional 𝕜 E]\n  (f : F →ₗ[𝕜] E), Function.Surjective ↑f → IsOpenMap ↑f :=\n\n/-- If `f` is an affine map, then its linear part is an open map iff `f` is an open map. -/\ntheorem ∀ {𝕜 : Type u_1} {V : Type u_2} {V₂ : Type u_4} {P : Type u_3} {P₂ : Type u_5} [inst : NormedField 𝕜]\n  [inst_1 : SeminormedAddCommGroup V] [inst_2 : SeminormedAddCommGroup V₂] [inst_3 : NormedSpace 𝕜 V]\n  [inst_4 : NormedSpace 𝕜 V₂] [inst_5 : PseudoMetricSpace P] [inst_6 : PseudoMetricSpace P₂]\n  [inst_7 : NormedAddTorsor V P] [inst_8 : NormedAddTorsor V₂ P₂] {f : P →ᵃ[𝕜] P₂}, IsOpenMap ↑f.linear ↔ IsOpenMap ↑f :=\n\n/-- The second projection in a product of topological spaces sends open sets to open sets. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.snd :=\n\n/-- If a function has an invertible strict derivative at all points, then it is an open map. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace E] {f : E → F} {f' : E → E ≃L[𝕜] F},\n  (∀ (x : E), HasStrictFDerivAt f (↑(f' x)) x) → IsOpenMap f :=\n\n/-- The first projection in a product of topological spaces sends open sets to open sets. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.fst :=\n\n/-- The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\nopen. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] (f : E →L[𝕜] F)\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E], Function.Surjective ↑f → IsOpenMap ↑f :=\n\n/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : CompleteSpace 𝕜] {f f' : 𝕜 → 𝕜},\n  (∀ (x : 𝕜), HasStrictDerivAt f (f' x) x) → (∀ (x : 𝕜), f' x ≠ 0) → IsOpenMap f :=\n\n/-- If `X ⟶ S`, `Y ⟶ S` are open embeddings, then so is `X ×ₛ Y ⟶ S`. -/\ntheorem ∀ {X Y S : TopCat} {f : X ⟶ S} {g : Y ⟶ S},\n  OpenEmbedding ↑f →\n    OpenEmbedding ↑g →\n      OpenEmbedding\n        ↑(CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one) :=\n\n/-- A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "forall {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β], IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "forall {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "forall {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "forall {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "forall {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd ",
      "forall {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β],\n  IsOpenMap Prod.fst ∧ IsOpenMap Prod.snd "
    ]
  },
  {
    "docString": "Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.",
    "prompts": "[{\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ K + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `K + V ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\\n  x ≠ y →\\n    ∃ U₁,\\n      U₁ ∈ nhds x ∧\\n        ∃ V₁,\\n          V₁ ∈ nhds x ∧\\n            ∃ U₂,\\n              U₂ ∈ nhds y ∧\\n                ∃ V₂,\\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsOpen t → IsCompact (s \\\\ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set difference of a compact set and an open set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\\n  U ∈ ⨆ (x : α) (_ : x ∈ s), nhds x → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\\nit contains an open set containing `s`. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ V + K ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\\n`0` such that `V + K ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\\n  U ∈ nhds 1 → ∃ V, IsOpen V ∧ 1 ∈ V ∧ V * V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\\nsuch that `VV ⊆ U`. \"}]\n",
    "prompt_cons": "/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `K + V ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ K + V ⊆ U :=\n\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds x ∧\n            ∃ U₂,\n              U₂ ∈ nhds y ∧\n                ∃ V₂,\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of `s`:\nit contains an open set containing `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\n  (∀ (x : α), x ∈ s → U ∈ nhds x) → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n\n/-- The set difference of a compact set and an open set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsOpen t → IsCompact (s \\ t) :=\n\n/-- If `U` is a neighborhood of each point of a set `s` then it is a neighborhood of s:\nit contains an open set containing `s`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s U : Set α},\n  U ∈ ⨆ (x : α) (_ : x ∈ s), nhds x → ∃ V, s ⊆ V ∧ IsOpen V ∧ V ⊆ U :=\n\n/-- Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n`0` such that `V + K ⊆ U`. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddZeroClass G] [inst_2 : ContinuousAdd G] {K U : Set G},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, V ∈ nhds 0 ∧ V + K ⊆ U :=\n\n/-- Given a neighborhood `U` of `1` there is an open neighborhood `V` of `1`\nsuch that `VV ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : Monoid M] [inst_2 : ContinuousMul M] {U : Set M},\n  U ∈ nhds 1 → ∃ V, IsOpen V ∧ 1 ∈ V ∧ V * V ⊆ U :=\n\n/-- Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$. -/\ntheorem",
    "choices": [
      "forall {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → (IsOpen (U \\ A) ∧ IsClosed (A \\ U)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {A U : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) ",
      "forall {α : Type u} [inst : TopologicalSpace α] {A U : Set α},\n  IsOpen U → IsClosed A → (IsOpen (U \\ A) ∧ IsClosed (A \\ U)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → (IsOpen (U \\ A) ∧ IsClosed (A \\ U)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → (IsOpen (U \\ A) ∧ IsClosed (A \\ U)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {U A : Set α},\n  IsOpen U → IsClosed A → IsOpen (U \\ A) ∧ IsClosed (A \\ U) "
    ]
  },
  {
    "docString": "Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {f g : ℝ → ℝ} {a b : ℝ},\\n  a < b →\\n    ContinuousOn f (Set.Icc a b) →\\n      ContinuousOn g (Set.Icc a b) →\\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X → Y}\\n  {s : Set X}, HolderOnWith C r f s → 0 < r → UniformContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\": \"A Hölder continuous function is uniformly continuous \"},\n {\"theorem\":\n  \"∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\\n  [inst_3 : OrderClosedTopology α] {s : Set X},\\n  IsPreconnected s →\\n    ∀ {a b : X},\\n      a ∈ s →\\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\\nthen for some `x ∈ s` we have `f x = g x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},\\n  t₂ ≤ t₃ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any coarser topology on the target space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {t₁ t₂ : TopologicalSpace α} {t₃ : TopologicalSpace β},\\n  t₂ ≤ t₁ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is continuous on a set for some topologies, then it is\\ncontinuous on the same set with respect to any finer topology on the source space. \"}]\n",
    "prompt_cons": "/-- If `s` is a closed set and two functions `f` and `g` are continuous on `s`,\nthen the set `{x ∈ s | f x ≤ g x}` is a closed set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : Preorder α] [t : OrderClosedTopology α]\n  [inst_2 : TopologicalSpace β] {f g : β → α} {s : Set β},\n  IsClosed s → ContinuousOn f s → ContinuousOn g s → IsClosed {x | x ∈ s ∧ f x ≤ g x} :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- If `f` and `g` are continuous on `[a, b]`, `a < b`, `f x ≤ g x` on this interval, and\n`f c < g c` at some point `c ∈ [a, b]`, then `∫ x in a..b, f x < ∫ x in a..b, g x`. -/\ntheorem ∀ {f g : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn f (Set.Icc a b) →\n      ContinuousOn g (Set.Icc a b) →\n        (∀ (x : ℝ), x ∈ Set.Ioc a b → f x ≤ g x) →\n          (∃ c, c ∈ Set.Icc a b ∧ f c < g c) → ∫ (x : ℝ) in a..b, f x < ∫ (x : ℝ) in a..b, g x :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two continuous functions\non a preconnected space and `f a ≤ g a` and `g b ≤ f b`, then for some `x` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] [inst_4 : PreconnectedSpace X] {a b : X} {f g : X → α},\n  Continuous f → Continuous g → f a ≤ g a → g b ≤ f b → ∃ x, f x = g x :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A Hölder continuous function is uniformly continuous -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : PseudoEMetricSpace X] [inst_1 : PseudoEMetricSpace Y] {C r : NNReal} {f : X → Y}\n  {s : Set X}, HolderOnWith C r f s → 0 < r → UniformContinuousOn f s :=\n\n/-- Intermediate value theorem for two functions: if `f` and `g` are two functions continuous\non a preconnected set `s` and for some `a b ∈ s` we have `f a ≤ g a` and `g b ≤ f b`,\nthen for some `x ∈ s` we have `f x = g x`. -/\ntheorem ∀ {X : Type u} {α : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder α] [inst_2 : TopologicalSpace α]\n  [inst_3 : OrderClosedTopology α] {s : Set X},\n  IsPreconnected s →\n    ∀ {a b : X},\n      a ∈ s →\n        b ∈ s → ∀ {f g : X → α}, ContinuousOn f s → ContinuousOn g s → f a ≤ g a → g b ≤ f b → ∃ x, x ∈ s ∧ f x = g x :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any coarser topology on the target space. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},\n  t₂ ≤ t₃ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s :=\n\n/-- If a function is continuous on a set for some topologies, then it is\ncontinuous on the same set with respect to any finer topology on the source space. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {t₁ t₂ : TopologicalSpace α} {t₃ : TopologicalSpace β},\n  t₂ ≤ t₁ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s :=\n\n/-- Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous. -/\ntheorem",
    "choices": [
      "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : LinearOrder Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : Preorder Y] [inst_2 : TopologicalSpace Y]\n  [inst_3 : OrderClosedTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : LinearOrder Y] [inst_2 : TopologicalSpace Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u} {Y : Type v} [TopologicalSpace X] [LinearOrder Y] [TopologicalSpace Y] [OrderTopology Y]\n  {f g : X → Y}, Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : LinearOrder Y] [inst_2 : TopologicalSpace Y]\n  [inst_3 : OrderClosedTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Y] [inst_2 : TopologicalSpace Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : LinearOrder β]\n  [inst_3 : OrderTopology β] {f g : α → β},\n  Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : LinearOrder Y] [inst_2 : TopologicalSpace Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y}, Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : PartialOrder Y] [inst_2 : TopologicalSpace Y]\n  [inst_3 : OrderTopology Y] {f g : X → Y},\n  Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) ",
      "∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : LinearOrder Y] [inst_2 : TopologicalSpace Y] [inst_3 : OrderTopology Y]\n  {f g : X → Y}, Continuous f → Continuous g → Continuous (λ x, min (f x) (g x)) "
    ]
  },
  {
    "docString": "Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x)\",\n  \"isProp\": true,\n  \"docString\": \"A Cauchy sequence in a complete space converges \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)]\\n  {F : ℕ → { x // x ∈ lp E p }},\\n  CauchySeq F →\\n    ∀ {f : { x // x ∈ lp E p }},\\n      Filter.Tendsto (id fun i => ↑(F i)) Filter.atTop (nhds ↑f) → Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {p : Filter ι} {c : β},\\n  Filter.Tendsto (↿F) (p ×ˢ ⊤) (nhds c) ↔ TendstoUniformly F (fun x => c) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Uniform convergence to a constant function is equivalent to convergence in `p ×ˢ ⊤`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {ι : Type u_2} {x : ι → α} {f : Filter α} {l : Filter ι} [inst : Filter.IsCountablyGenerated l],\\n  (∀ (ns : ℕ → ι), Filter.Tendsto ns Filter.atTop l → ∃ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) →\\n    Filter.Tendsto x l f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence converges if every subsequence has a convergent subsequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {K : Set α},\\n  IsComplete K → ∀ {u : β → α}, (∀ (n : β), u n ∈ K) → CauchySeq u → ∃ v, v ∈ K ∧ Filter.Tendsto u Filter.atTop (nhds v)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\\n  Inducing fun x i => f i x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\\nwhere `Π i, π i` is endowed with the usual product topology. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {γ : Type u_1} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] [inst : MeasurableSpace γ]\\n  {β : Type u_3} [inst_1 : MeasurableSpace β] [hγ : OpensMeasurableSpace γ] [inst_2 : Countable ι] {l : Filter ι}\\n  [inst_3 : Filter.IsCountablyGenerated l] {f : ι → β → γ},\\n  (∀ (i : ι), Measurable (f i)) → MeasurableSet {x | ∃ c, Filter.Tendsto (fun n => f n x) l (nhds c)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of points for which a measurable sequence of functions converges is measurable. \"}]\n",
    "prompt_cons": "/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- A Cauchy sequence in a complete space converges -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] [inst_2 : CompleteSpace α] {u : β → α},\n  CauchySeq u → ∃ x, Filter.Tendsto u Filter.atTop (nhds x) :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem ∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)]\n  {F : ℕ → { x // x ∈ lp E p }},\n  CauchySeq F →\n    ∀ {f : { x // x ∈ lp E p }},\n      Filter.Tendsto (id fun i => ↑(F i)) Filter.atTop (nhds ↑f) → Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- Uniform convergence to a constant function is equivalent to convergence in `p ×ˢ ⊤`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {p : Filter ι} {c : β},\n  Filter.Tendsto (↿F) (p ×ˢ ⊤) (nhds c) ↔ TendstoUniformly F (fun x => c) p :=\n\n/-- A sequence converges if every subsequence has a convergent subsequence. -/\ntheorem ∀ {α : Type u_1} {ι : Type u_2} {x : ι → α} {f : Filter α} {l : Filter ι} [inst : Filter.IsCountablyGenerated l],\n  (∀ (ns : ℕ → ι), Filter.Tendsto ns Filter.atTop l → ∃ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) →\n    Filter.Tendsto x l f :=\n\n/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {K : Set α},\n  IsComplete K → ∀ {u : β → α}, (∀ (n : β), u n ∈ K) → CauchySeq u → ∃ v, v ∈ K ∧ Filter.Tendsto u Filter.atTop (nhds v) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- Suppose `π i` is a family of topological spaces indexed by `i : ι`, and `X` is a type\nendowed with a family of maps `f i : X → π i` for every `i : ι`, hence inducing a\nmap `g : X → Π i, π i`. This lemma shows that infimum of the topologies on `X` induced by\nthe `f i` as `i : ι` varies is simply the topology on `X` induced by `g : X → Π i, π i`\nwhere `Π i, π i` is endowed with the usual product topology. -/\ntheorem ∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Type u_1} (f : (i : ι) → X → π i),\n  Inducing fun x i => f i x :=\n\n/-- The set of points for which a measurable sequence of functions converges is measurable. -/\ntheorem ∀ {ι : Type u_2} {γ : Type u_1} [tγ : TopologicalSpace γ] [inst : PolishSpace γ] [inst : MeasurableSpace γ]\n  {β : Type u_3} [inst_1 : MeasurableSpace β] [hγ : OpensMeasurableSpace γ] [inst_2 : Countable ι] {l : Filter ι}\n  [inst_3 : Filter.IsCountablyGenerated l] {f : ι → β → γ},\n  (∀ (i : ι), Measurable (f i)) → MeasurableSet {x | ∃ c, Filter.Tendsto (fun n => f n x) l (nhds c)} :=\n\n/-- Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} [inst : (a : α) → TopologicalSpace (β a)] {F : ι → (a : α) → β a} {x : (a : α) → β a} {l : Filter ι},\n  Filter.Tendsto F l (nhds x) ↔ ∀ a : α, Filter.Tendsto (λ n, F n a) l (nhds (x a)) ",
      "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {l : ℕ → Π (i : ι), π i} {x : Π (i : ι), π i},\n  (Filter.Tendsto l Filter.atTop (nhds x)) ↔ (∀ i : ι, Filter.Tendsto (fun n => l n i) Filter.atTop (nhds (x i))) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)] {x : (i : ι) → α i} {x_seq : ℕ → (i : ι) → α i},\n  Filter.Tendsto x_seq Filter.atTop (nhds x) ↔ ∀ i, Filter.Tendsto (fun n => x_seq n i) Filter.atTop (nhds (x i)) ",
      "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] {x : ℕ → (i : ι) → π i} {y : (i : ι) → π i},\n  Filter.Tendsto x Filter.atTop (nhds y) ↔ ∀ i, Filter.Tendsto (fun n => x n i) Filter.atTop (nhds (y i)) ",
      "∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)] {X : ℕ → Π i, π i} {x : Π i, π i},\n  Filter.Tendsto X Filter.atTop (nhds x) ↔ ∀ i, Filter.Tendsto (fun n => X n i) Filter.atTop (nhds (x i)) ",
      "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : Π i, π i} (x : ℕ → X) (y : X),\n  Filter.Tendsto x Filter.atTop (nhds y) ↔ ∀ i, Filter.Tendsto (fun n => x n i) Filter.atTop (nhds (y i)) ",
      "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : ℕ → (i : ι) → π i} {x : (i : ι) → π i},\n  Filter.Tendsto X Filter.atTop (nhds x) ↔ (∀ i, Filter.Tendsto (λ n, X n i) Filter.atTop (nhds (x i))) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)] {x : (i : ι) → α i} {l : ℕ → (i : ι) → α i},\n  Filter.Tendsto l Filter.atTop (nhds x) ↔ ∀ i, Filter.Tendsto (fun n => l n i) Filter.atTop (nhds (x i)) ",
      "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {x : ℕ → Π i, π i} {l : Π i, π i},\n  Filter.Tendsto x Filter.atTop (nhds l) ↔ ∀ i, Filter.Tendsto (fun n => x n i) Filter.atTop (nhds (l i)) ",
      "∀ {ι : Type u_2} {π : ι → Type u_3} [inst : (i : ι) → TopologicalSpace (π i)] {X : ℕ → (i : ι) → π i} {x : (i : ι) → π i},\n  Filter.Tendsto X Filter.atTop (nhds x) ↔ ∀ i, Filter.Tendsto (fun n => X n i) Filter.atTop (nhds (x i)) "
    ]
  },
  {
    "docString": "Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$.",
    "prompts": "[{\"theorem\":\n  \"∀ (f : CircleDeg1Lift) (x : ℝ),\\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : ℝ` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\\n`f^[n]` of `f`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(ℝ, E)},\\n  (Summable fun n => ‖ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight ↑n))‖) →\\n    MeasureTheory.Integrable ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the sequence with `n`-th term the the sup norm of `λ x, f (x + n)` on the interval `Icc 0 1`,\\nfor `n ∈ ℤ`, is summable, then `f` is integrable on `ℝ`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, Monotone f → x ≤ f x → Monotone fun n => f^[n] x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone map and `x ≤ f x` at some point `x`, then the iterates `f^[n] x` form\\na monotone sequence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {a : α} {f : ℕ → α},\\n  HasSum f a → Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : ℕ → α` has sum `a`, then the partial sums `∑_{i=0}^{n-1} f i` converge to `a`. \"},\n {\"theorem\":\n  \"∀ (f : C(↑unitInterval, ℝ)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Bernstein approximations\\n```\\n∑ k : Fin (n+1), f (k/n : ℝ) * n.choose k * x^k * (1-x)^(n-k)\\n```\\nfor a continuous function `f : C([0,1], ℝ)` converge uniformly to `f` as `n` tends to infinity.\\n\\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], §7D,\\nand reproduced on wikipedia.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) →\\n        (Summable fun n => f n x₀) → ∀ (x : E), HasFDerivAt (fun y => ∑' (n : α), f n y) (∑' (n : α), f' n x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series is differentiable and its derivative is the sum of the derivatives. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {f' : E →L[𝕜] F} {x : E} {s : Set E},\\n  HasFDerivWithinAt f f' s x →\\n    ∀ {α : Type u_4} (l : Filter α) {c : α → 𝕜} {d : α → E} {v : E},\\n      (∀ᶠ (n : α) in l, x + d n ∈ s) →\\n        Filter.Tendsto (fun n => ‖c n‖) l Filter.atTop →\\n          Filter.Tendsto (fun n => c n • d n) l (nhds v) →\\n            Filter.Tendsto (fun n => c n • (f (x + d n) - f x)) l (nhds (↑f' v))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\\ntangent cone related discussions. \"}]\n",
    "prompt_cons": "/-- For any `x : ℝ` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem ∀ (f : CircleDeg1Lift) (x : ℝ),\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- Consider a series of functions `∑' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If $x ≤ f x$ for all $x$ (we write this as `id ≤ f`), then the same is true for any iterate\n`f^[n]` of `f`. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α}, id ≤ f → ∀ (n : ℕ), id ≤ f^[n] :=\n\n/-- If the sequence with `n`-th term the the sup norm of `λ x, f (x + n)` on the interval `Icc 0 1`,\nfor `n ∈ ℤ`, is summable, then `f` is integrable on `ℝ`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] {f : C(ℝ, E)},\n  (Summable fun n => ‖ContinuousMap.restrict (Set.Icc 0 1) (ContinuousMap.comp f (ContinuousMap.addRight ↑n))‖) →\n    MeasureTheory.Integrable ↑f :=\n\n/-- If `f` is a monotone map and `x ≤ f x` at some point `x`, then the iterates `f^[n] x` form\na monotone sequence. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] {f : α → α} {x : α}, Monotone f → x ≤ f x → Monotone fun n => f^[n] x :=\n\n/-- If `f : ℕ → α` has sum `a`, then the partial sums `∑_{i=0}^{n-1} f i` converge to `a`. -/\ntheorem ∀ {α : Type u_1} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {a : α} {f : ℕ → α},\n  HasSum f a → Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => f i) Filter.atTop (nhds a) :=\n\n/-- The Bernstein approximations\n```\n∑ k : Fin (n+1), f (k/n : ℝ) * n.choose k * x^k * (1-x)^(n-k)\n```\nfor a continuous function `f : C([0,1], ℝ)` converge uniformly to `f` as `n` tends to infinity.\n\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], §7D,\nand reproduced on wikipedia. -/\ntheorem ∀ (f : C(↑unitInterval, ℝ)), Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f) :=\n\n/-- Consider a series of functions `∑' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series is differentiable and its derivative is the sum of the derivatives. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) →\n        (Summable fun n => f n x₀) → ∀ (x : E), HasFDerivAt (fun y => ∑' (n : α), f n y) (∑' (n : α), f' n x) x :=\n\n/-- If a function f has a derivative f' at x, a rescaled version of f around x converges to f',\ni.e., `n (f (x + (1/n) v) - f x)` converges to `f' v`. More generally, if `c n` tends to infinity\nand `c n * d n` tends to `v`, then `c n * (f (x + d n) - f x)` tends to `f' v`. This lemma expresses\nthis fact, for functions having a derivative within a set. Its specific formulation is useful for\ntangent cone related discussions. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {x : E} {s : Set E},\n  HasFDerivWithinAt f f' s x →\n    ∀ {α : Type u_4} (l : Filter α) {c : α → 𝕜} {d : α → E} {v : E},\n      (∀ᶠ (n : α) in l, x + d n ∈ s) →\n        Filter.Tendsto (fun n => ‖c n‖) l Filter.atTop →\n          Filter.Tendsto (fun n => c n • d n) l (nhds v) →\n            Filter.Tendsto (fun n => c n • (f (x + d n) - f x)) l (nhds (↑f' v)) :=\n\n/-- Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$. -/\ntheorem",
    "choices": [
      "∀ (x : ℝ), (0 ≤ x ∧ x ≤ 1) → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x^n) Filter.atTop (nhds (cond (x = 1) 1 0)) ",
      "∀ (x : ℝ), 0 ≤ x → x ≤ 1 → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds 0) ",
      "∀ (x : ℝ), x ∈ unitInterval → Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds \n(if x = 0 then 0 else 1)) ",
      "∀ (x : ℝ) (hx : x ∈ set.Icc (0 : ℝ) 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "∀ (x : ℝ) (hx : x ∈ Icc (0 : ℝ) 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (ite (x < 1) 0 1)) ",
      "∀ (x : ℝ) (hx : x ∈ Set.Icc 0 1),\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (if x = 1 then 1 else 0)) ",
      "∀ (x : ℝ) (hx : x ∈ Set.Icc 0 1), Filter.Tendsto (fun n => x^n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "∀ {x : ℝ}, 0 ≤ x → x ≤ 1 →\n  Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (if x < 1 then 0 else 1)) ",
      "∀ (x : ℝ) (hx : x ∈ Set.Icc 0 1), Filter.Tendsto (fun n => x ^ n) Filter.atTop (nhds (ite (x < 1) 0 1)) "
    ]
  },
  {
    "docString": "Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\\n  (∀ (u : ℕ → E) (x : E) (y : F),\\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\\n    Continuous ↑g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\\n  {g : ι → α} [inst_1 : TopologicalSpace α],\\n  ContinuousAt f x →\\n    Filter.Tendsto g p (nhds x) →\\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\\n  {p : Filter ι} {F : ι → C(α, β)} [inst_2 : CompactSpace α],\\n  Filter.Tendsto F p (nhds f) ↔ TendstoUniformly (fun i a => ↑(F i) a) (↑f) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence in the compact-open topology is the same as uniform convergence for sequences of\\ncontinuous functions on a compact space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\\n  ContinuousWithinAt f s x →\\n    Filter.Tendsto g p (nhdsWithin x s) →\\n      (∀ (u : Set (β × β)),\\n          u ∈ uniformity β → ∃ t, t ∈ nhdsWithin x s ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Fₙ` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\\nwhich is continuous at `x` within `s `, and `gₙ` tends to `x` within `s`, then `Fₙ (gₙ)` tends\\nto `f x`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → UniformCauchySeqOn F p s\",\n  \"isProp\": true,\n  \"docString\": \"A sequence that converges uniformly is also uniformly Cauchy \"},\n {\"theorem\":\n  \"∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\\n          (nhds x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : UniformSpace γ] {g : β → γ},\\n  UniformContinuous g → TendstoUniformly F f p → TendstoUniformly (fun i => g ∘ F i) (g ∘ f) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composing on the left by a uniformly continuous function preserves uniform convergence \"},\n {\"theorem\":\n  \"∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\\n  {p : Filter ι} {F : ι → C(α, β)}, TendstoLocallyUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto F p (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Locally uniform convergence implies convergence in the compact-open topology. \"}]\n",
    "prompt_cons": "/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uₙ ⟶ x`, if `f(uₙ) ⟶ y` then `y = f(x)`. -/\ntheorem ∀ {𝕜 : Type u_3} [inst : NontriviallyNormedField 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_2} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  [inst_5 : CompleteSpace F] [inst_6 : CompleteSpace E] (g : E →ₗ[𝕜] F),\n  (∀ (u : ℕ → E) (x : E) (y : F),\n      Filter.Tendsto u Filter.atTop (nhds x) → Filter.Tendsto (↑g ∘ u) Filter.atTop (nhds y) → y = ↑g x) →\n    Continuous ↑g :=\n\n/-- If `Fₙ` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `gₙ` tends to `x`, then `Fₙ (gₙ)` tends to `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α} {p : Filter ι}\n  {g : ι → α} [inst_1 : TopologicalSpace α],\n  ContinuousAt f x →\n    Filter.Tendsto g p (nhds x) →\n      (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- Convergence in the compact-open topology is the same as uniform convergence for sequences of\ncontinuous functions on a compact space. -/\ntheorem ∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\n  {p : Filter ι} {F : ι → C(α, β)} [inst_2 : CompactSpace α],\n  Filter.Tendsto F p (nhds f) ↔ TendstoUniformly (fun i a => ↑(F i) a) (↑f) p :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- If `Fₙ` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s `, and `gₙ` tends to `x` within `s`, then `Fₙ (gₙ)` tends\nto `f x`. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {x : α}\n  {p : Filter ι} {g : ι → α} [inst_1 : TopologicalSpace α],\n  ContinuousWithinAt f s x →\n    Filter.Tendsto g p (nhdsWithin x s) →\n      (∀ (u : Set (β × β)),\n          u ∈ uniformity β → ∃ t, t ∈ nhdsWithin x s ∧ ∀ᶠ (n : ι) in p, ∀ (y : α), y ∈ t → (f y, F n y) ∈ u) →\n        Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) :=\n\n/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → UniformCauchySeqOn F p s :=\n\n/-- If `f_n → g` pointwise and the derivatives `(f_n)' → h` _uniformly_ converge, then\nin fact for a fixed `y`, the difference quotients `‖z - y‖⁻¹ • (f_n z - f_n y)` converge\n_uniformly_ to `‖z - y‖⁻¹ • (g z - g y)` -/\ntheorem ∀ {ι : Type u_3} {l : Filter ι} {E : Type u_1} [inst : NormedAddCommGroup E] {𝕜 : Type u_4} [inst_1 : IsROrC 𝕜]\n  [inst_2 : NormedSpace 𝕜 E] {G : Type u_2} [inst_3 : NormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] {f : ι → E → G}\n  {g : E → G} {f' : ι → E → E →L[𝕜] G} {g' : E → E →L[𝕜] G} {x : E},\n  TendstoUniformlyOnFilter f' g' l (nhds x) →\n    (∀ᶠ (n : ι × E) in l ×ˢ nhds x, HasFDerivAt (f n.fst) (f' n.fst n.snd) n.snd) →\n      (∀ᶠ (y : E) in nhds x, Filter.Tendsto (fun n => f n y) l (nhds (g y))) →\n        TendstoUniformlyOnFilter (fun n y => (↑‖y - x‖)⁻¹ • (f n y - f n x)) (fun y => (↑‖y - x‖)⁻¹ • (g y - g x)) l\n          (nhds x) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem ∀ {α : Type u} {β : Type v} {γ : Type w} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : UniformSpace γ] {g : β → γ},\n  UniformContinuous g → TendstoUniformly F f p → TendstoUniformly (fun i => g ∘ F i) (g ∘ f) p :=\n\n/-- Locally uniform convergence implies convergence in the compact-open topology. -/\ntheorem ∀ {α : Type u₁} {β : Type u₂} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : C(α, β)} {ι : Type u₃}\n  {p : Filter ι} {F : ι → C(α, β)}, TendstoLocallyUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto F p (nhds f) :=\n\n/-- Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β]\n  {F : ι → C(α, β)} {f : α → β} {p : Filter ι} {x : α} {x_n : ι → α},\n  TendstoUniformly (fun i a => ↑(F i) a) (↑f) p →\n    Filter.Tendsto x_n p (nhds x) → Filter.Tendsto (fun n => F n (x_n n)) p (nhds (f x)) ",
      "{α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {f : ι → C(α, β)} {x : α} {p : Filter ι} {u : ι → α} {y : β},\n  TendstoUniformly (fun i a => ↑(f i) a) y p →\n    Filter.Tendsto u p (nhds x) → Filter.Tendsto (fun n => ↑(f n) (u n)) p (nhds (y x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {F : ι → C(α, β)} {f : α → β} {p : Filter ι}\n  {x : α} {g : ι → α},\n  Filter.Tendsto g p (nhds x) →\n    TendstoUniformly (fun i a => ↑(F i) a) f p → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {f : α → β} {F : ι → α → β}\n  {x : α} {p : Filter ι} {g : ι → α},\n  TendstoUniformly F f p →\n    Filter.Tendsto g p (nhds x) →\n      Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : UniformSpace β] {F : ι → α → β} {f : α → β} {x : α}\n  {p : Filter ι} {g : ι → α},\n  Filter.Tendsto g p (nhds x) →\n    TendstoUniformly F f p →\n      Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {x : α} {p : Filter ι}\n  {F : ι → C(α, β)} {f : α → β} {g : ι → α},\n  Filter.Tendsto g p (nhds x) →\n    TendstoUniformly (fun n => ↑(F n)) f p → Filter.Tendsto (fun n => ↑(F n) (g n)) p (nhds (f x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {F : ι → C(α, β)} {f : C(α, β)} {x : α}\n  {p : Filter ι} {u : ι → α},\n  Filter.Tendsto u p (nhds x) →\n    TendstoUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto (fun n => ↑(F n) (u n)) p (nhds (↑f x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {F : ι → α → β} {f : α → β} {x : α}\n  {p : Filter ι} {g : ι → α},\n  Filter.Tendsto g p (nhds x) →\n    TendstoUniformly F f p → Filter.Tendsto (fun n => F n (g n)) p (nhds (f x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {F : ι → C(α, β)} {f : C(α, β)}\n  {x : α} {p : Filter ι} {g : ι → α},\n  Filter.Tendsto g p (nhds x) →\n    TendstoUniformly (fun i a => ↑(F i) a) (↑f) p → Filter.Tendsto (fun n => ↑(F n) (g n)) p (nhds (↑f x)) ",
      "∀ {α : Type u} {β : Type v} {ι : Type x} [inst : TopologicalSpace α] [inst_1 : MetricSpace β] {F : ι → C(α, β)} {f : C(α, β)} {p : Filter ι}\n  {x : α} {g : ι → α},\n  Filter.Tendsto g p (nhds x) →\n    TendstoUniformly (fun i a => ↑(F i) a) (↑f) p →\n      Filter.Tendsto (fun n => ↑(F n) (g n)) p (nhds (↑f x)) "
    ]
  },
  {
    "docString": "If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\": \"A continuous surjective open map is a quotient map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous surjective map from a compact space to a Hausdorff space is a quotient map. \"},\n {\"theorem\": \"∀ {α : Type u_1} (r : Setoid α), Setoid.ker Quotient.mk'' = r\",\n  \"isProp\": true,\n  \"docString\":\n  \"The kernel of the quotient map induced by an equivalence relation r equals r. \"},\n {\"theorem\":\n  \"∀ {E : ℕ → Type u_1} [inst : (n : ℕ) → TopologicalSpace (E n)] [inst_1 : ∀ (n : ℕ), DiscreteTopology (E n)]\\n  {s : Set ((n : ℕ) → E n)},\\n  IsClosed s → Set.Nonempty s → ∃ f, (∀ (x : (n : ℕ) → E n), x ∈ s → f x = x) ∧ Set.range f = s ∧ Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a closed nonempty subset `s` of `Π (n : ℕ), E n`, there exists a retraction onto this\\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. \"},\n {\"theorem\":\n  \"∀ (R₁ : Type u_2) {A : Type u_1} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : Algebra R₁ A] (I : Ideal A),\\n  Function.Surjective ↑(Ideal.Quotient.mkₐ R₁ I)\",\n  \"isProp\": true,\n  \"docString\": \"The canonical morphism `A →ₐ[R₁] I.quotient` is surjective. \"},\n {\"theorem\": \"∀ {α : Sort u} {β : Sort v}, Function.Injective fun e => ↑e\",\n  \"isProp\": true,\n  \"docString\": \"The map `(r ≃ s) → (r → s)` is injective. \"},\n {\"theorem\": \"∀ {α : Type u_1} (r : Setoid α), EqvGen.Setoid Setoid.r = r\",\n  \"isProp\": true,\n  \"docString\": \"The equivalence closure of an equivalence relation r is r. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"∀ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X Y : C},\\n  IsEquiv (X ⟶ Y) r\",\n  \"isProp\": true,\n  \"docString\": \"`r` is an equivalence on every hom-set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\\n  Continuous self.invFun\",\n  \"isProp\": true,\n  \"docString\": \"The inverse map of a homeomorphism is a continuous function. \"}]\n",
    "prompt_cons": "/-- A continuous surjective open map is a quotient map. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},\n  IsOpenMap f → Continuous f → Function.Surjective f → QuotientMap f :=\n\n/-- A continuous surjective map from a compact space to a Hausdorff space is a quotient map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Function.Surjective f → Continuous f → QuotientMap f :=\n\n/-- The kernel of the quotient map induced by an equivalence relation r equals r. -/\ntheorem ∀ {α : Type u_1} (r : Setoid α), Setoid.ker Quotient.mk'' = r :=\n\n/-- Given a closed nonempty subset `s` of `Π (n : ℕ), E n`, there exists a retraction onto this\nset, i.e., a continuous map with range equal to `s`, equal to the identity on `s`. -/\ntheorem ∀ {E : ℕ → Type u_1} [inst : (n : ℕ) → TopologicalSpace (E n)] [inst_1 : ∀ (n : ℕ), DiscreteTopology (E n)]\n  {s : Set ((n : ℕ) → E n)},\n  IsClosed s → Set.Nonempty s → ∃ f, (∀ (x : (n : ℕ) → E n), x ∈ s → f x = x) ∧ Set.range f = s ∧ Continuous f :=\n\n/-- The canonical morphism `A →ₐ[R₁] I.quotient` is surjective. -/\ntheorem ∀ (R₁ : Type u_2) {A : Type u_1} [inst : CommSemiring R₁] [inst_1 : CommRing A] [inst_2 : Algebra R₁ A] (I : Ideal A),\n  Function.Surjective ↑(Ideal.Quotient.mkₐ R₁ I) :=\n\n/-- The map `(r ≃ s) → (r → s)` is injective. -/\ntheorem ∀ {α : Sort u} {β : Sort v}, Function.Injective fun e => ↑e :=\n\n/-- The equivalence closure of an equivalence relation r is r. -/\ntheorem ∀ {α : Type u_1} (r : Setoid α), EqvGen.Setoid Setoid.r = r :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- `r` is an equivalence on every hom-set. -/\ntheorem ∀ {C : Type u_1} [inst : CategoryTheory.Category C] {r : HomRel C} [self : CategoryTheory.Congruence r] {X Y : C},\n  IsEquiv (X ⟶ Y) r :=\n\n/-- The inverse map of a homeomorphism is a continuous function. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (self : α ≃ₜ β),\n  Continuous self.invFun :=\n\n/-- If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {r : α → β} {A : Set α},\n  (∀ (a : α), a ∈ A → r a = a) ∧ Set.range r = A ∧ Continuous r → QuotientMap r ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {A : Set α} {r : α → β},\n  (∀ (a : α), a ∈ A → r a = a) → Set.range r = A → Continuous r → QuotientMap r ",
      "∀ {X : Type u_1} {A : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace A] {r : X → A},\n  (∀ a : A, r a = a) → Continuous r → QuotientMap r ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {A : Set α} {r : α → β},\n  Continuous r → (∀ a : α, a ∈ A → r a = a) → Set.range r = A → QuotientMap r ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {s : Set α},\n  IsClosed s → Continuous f → Set.range f = s → (∀ (x : α), x ∈ s → f x = x) → QuotientMap f ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {A : Set α} {r : α → β},\n  Continuous r → (∀ (a : α), a ∈ A → r a = a) → Set.range r = A → QuotientMap r ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {A : Set α} {r : α → β},\n  (∀ (x : α), x ∈ A → r x = x) → Continuous r → QuotientMap r ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {A : Set α} {r : α → β},\n  (∀ (a : α), a ∈ A → r a = a) → Set.range r = A → Continuous r → QuotientMap r ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} {A : Set α},\n  Continuous f → f '' A = A → (∀ a ∈ A, f a = a) → QuotientMap f ",
      "∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {A : Set α} {r : α → β},\n  Continuous r → Set.range r = A → (∀ a ∈ A, r a = a) → QuotientMap r "
    ]
  },
  {
    "docString": "Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\\n  (s : ι → Set (ℙ K V)),\\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\\n  (∀ (i : ι), Set.Nonempty (s i)) →\\n    Pairwise (Disjoint on s) →\\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\\nelement. \"}]\n",
    "prompt_cons": "/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → Set.Nonempty s → IsConnected s :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem ∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Set (ℙ K V)),\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i) :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- In a preconnected space, any finite disjoint cover by non-empty closed subsets has at most one\nelement. -/\ntheorem ∀ {α : Type u} {ι : Type u_1} [inst : TopologicalSpace α] [inst_1 : PreconnectedSpace α] {s : ι → Set α},\n  (∀ (i : ι), Set.Nonempty (s i)) →\n    Pairwise (Disjoint on s) →\n      ∀ [inst_2 : Finite ι], (∀ (i : ι), IsClosed (s i)) → ⋃ (i : ι), s i = Set.univ → Subsingleton ι :=\n\n/-- Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected. -/\ntheorem",
    "choices": [
      "∀ {X : Type u} {ι : Type u_1} [inst : TopologicalSpace X] [inst_1 : LinearOrder ι] [inst_2 : SuccOrder ι]\n  (A : ι → Set X),\n  (∀ (n : ι), IsConnected (A n)) → (∀ (n : ι), Set.Nonempty (A n ∩ A (SuccOrder.succ n))) → IsConnected (⋃ (n : ι), A n) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {ι : ℕ → Set α} (h_seq : ∀ n, Set.Nonempty (ι n ∩ ι (n + 1))),\n  (∀ n, IsConnected (ι n)) → IsConnected (⋃ n, ι n) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {A : ℕ → Set α},\n  (∀ (n : ℕ), IsConnected (A n)) →\n    (∀ (n : ℕ), Set.Nonempty (A n ∩ A (n + 1))) → IsConnected (⋃ (n : ℕ), A n) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {A : ℕ → Set α},\n  (∀ (n : ℕ), IsConnected (A n)) →\n    (∀ (n : ℕ), Set.Nonempty (A n ∩ A (n + 1))) → IsConnected (⋃ (n : ℕ), A n) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {A : ℕ → Set α},\n  (∀ (n : ℕ), IsConnected (A n)) →\n    (∀ (n : ℕ), Set.Nonempty (A n ∩ A (n + 1))) → IsConnected (⋃ (n : ℕ), A n) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsConnected (s n)) →\n    (∀ (n : ℕ), Set.Nonempty (s n ∩ s (n + 1))) → IsConnected (⋃ (n : ℕ), s n) ",
      "∀ {X : Type u} [inst : TopologicalSpace X] {A : ℕ → Set X},\n  (∀ (n : ℕ), IsConnected (A n)) →\n    (∀ (n : ℕ), Set.Nonempty (A n ∩ A (n + 1))) → IsConnected (⋃ (n : ℕ), A n) ",
      "forall {α : Type u} [inst : TopologicalSpace α] {A : ℕ → Set α},\n  (∀ (n : ℕ), IsConnected (A n)) →\n    (∀ (n : ℕ), Set.Nonempty (A n ∩ A (n + 1))) → IsConnected (⋃ (n : ℕ), A n) ",
      "∀ {X : Type u} [inst : TopologicalSpace X] {ι : Type u_1} [inst_1 : LinearOrder ι] [inst_2 : SuccOrder ι]\n  (s : ι → Set X),\n  (∀ (i : ι), IsConnected (s i)) →\n    (∀ (i : ι), Set.Nonempty (s i ∩ s (SuccOrder.succ i))) → IsConnected (⋃ (i : ι), s i) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : ℕ → Set α},\n  (∀ (n : ℕ), IsConnected (s n)) →\n    (∀ (n : ℕ), Set.Nonempty (s n ∩ s (n + 1))) → IsConnected (⋃ (n : ℕ), s n) "
    ]
  },
  {
    "docString": "Show that if $X$ is an infinite set, it is connected in the finite complement topology.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\\n  Set.Finite s → IsClosed ↑(upperClosure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The upper closure of a finite set is closed in the lower topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Infinite α], IrreducibleSpace (CofiniteTopology α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An infinite type with cofinite topology is an irreducible topological space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {α : Type u₁}\\n  {β : Type u_1} {s : Set (β → M)},\\n  Set.Definable A L s → ∀ (f : α → β) [inst_1 : Finite α] [inst_2 : Finite β], Set.Definable A L ((fun g => g ∘ f) '' s)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that definability is closed under finite projections. \"},\n {\"theorem\":\n  \"∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In an infinite graph, the set of components out of a finite set is nonempty. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] [inst_5 : T2Space E] {s : Set E},\\n  Set.Finite s → IsClosed (↑(convexHull ℝ) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is closed. \"},\n {\"theorem\":\n  \"∀ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally finite preconnected infinite graph has at least one end. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Points of a finite set can be separated by open sets from each other. \"}]\n",
    "prompt_cons": "/-- The upper closure of a finite set is closed in the lower topology. -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : LowerTopology α] {s : Set α},\n  Set.Finite s → IsClosed ↑(upperClosure s) :=\n\n/-- An infinite type with cofinite topology is an irreducible topological space. -/\ntheorem ∀ {α : Type u_1} [inst : Infinite α], IrreducibleSpace (CofiniteTopology α) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Shows that definability is closed under finite projections. -/\ntheorem ∀ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : FirstOrder.Language.Structure L M] {α : Type u₁}\n  {β : Type u_1} {s : Set (β → M)},\n  Set.Definable A L s → ∀ (f : α → β) [inst_1 : Finite α] [inst_2 : Finite β], Set.Definable A L ((fun g => g ∘ f) '' s) :=\n\n/-- In an infinite graph, the set of components out of a finite set is nonempty. -/\ntheorem ∀ {V : Type u} (G : SimpleGraph V) [inst : Infinite V] (K : Finset V), Nonempty (SimpleGraph.ComponentCompl G ↑K) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Convex hull of a finite set is closed. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] [inst_5 : T2Space E] {s : Set E},\n  Set.Finite s → IsClosed (↑(convexHull ℝ) s) :=\n\n/-- A locally finite preconnected infinite graph has at least one end. -/\ntheorem ∀ {V : Type} (G : SimpleGraph V) [inst : SimpleGraph.LocallyFinite G] [inst : Fact (SimpleGraph.Preconnected G)]\n  [inst : Infinite V], Set.Nonempty (SimpleGraph.end G) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- Points of a finite set can be separated by open sets from each other. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  Set.Finite s → ∃ U, (∀ (x : α), x ∈ U x ∧ IsOpen (U x)) ∧ Set.PairwiseDisjoint s U :=\n\n/-- Show that if $X$ is an infinite set, it is connected in the finite complement topology. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : Infinite α], IsConnected (Set.Univ : Set α) (CofiniteTopology α) ",
      "∀ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "∀ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "∀ {α : Type u_1} [inst : Infinite α], IsConnected (CofiniteTopology α) ",
      "∀ {α : Type u_1} [inst : Infinite α], ConnectedSpace (CofiniteTopology α) ",
      "∀ {α : Type u_1} [inst : Infinite α], IsConnected (CofiniteTopology α) ",
      "∀ {α : Type u_1} [inst : Infinite α], ConnectedSpace (CofiniteTopology α) ",
      "∀ {α : Type u_1} [inst : Infinite α], ConnectedSpace (CofiniteTopology α) ",
      "∀ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) ",
      "∀ {X : Type u_1} [inst : Infinite X], ConnectedSpace (CofiniteTopology X) "
    ]
  },
  {
    "docString": "Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any two points of a set are contained in a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"∀ (C : Type u) [inst : CategoryTheory.Category C]\\n  [inst_1 : ∀ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\\n  CategoryTheory.Limits.HasBinaryCoproducts C\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} (x : α),\\n  (∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If any point of a set is joined to a fixed point by a preconnected subset,\\nthen the original set is preconnected as well. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (x : α) (c : Set (Set α)),\\n  (∀ (s : Set α), s ∈ c → x ∈ s) → (∀ (s : Set α), s ∈ c → IsPreconnected s) → IsPreconnected (⋃₀ c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A union of a family of preconnected sets with a common point is preconnected as well. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"}]\n",
    "prompt_cons": "/-- If any two points of a set are contained in a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  (∀ (x : α), x ∈ s → ∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s) :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S) :=\n\n/-- If `C` has all colimits of diagrams `pair X Y`, then it has all binary coproducts -/\ntheorem ∀ (C : Type u) [inst : CategoryTheory.Category C]\n  [inst_1 : ∀ {X Y : C}, CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)],\n  CategoryTheory.Limits.HasBinaryCoproducts C :=\n\n/-- If any point of a set is joined to a fixed point by a preconnected subset,\nthen the original set is preconnected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} (x : α),\n  (∀ (y : α), y ∈ s → ∃ t, t ⊆ s ∧ x ∈ t ∧ y ∈ t ∧ IsPreconnected t) → IsPreconnected s :=\n\n/-- A union of a family of preconnected sets with a common point is preconnected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (x : α) (c : Set (Set α)),\n  (∀ (s : Set α), s ∈ c → x ∈ s) → (∀ (s : Set α), s ∈ c → IsPreconnected s) → IsPreconnected (⋃₀ c) :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- A nonempty convex set is connected. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → Set.Nonempty s → IsConnected s :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected. -/\ntheorem",
    "choices": [
      "∀ {X : Type u} [inst : TopologicalSpace X] {Y : Type u_1} [inst_1 : TopologicalSpace Y]\n  {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ → IsProperSubset B Set.univ → IsConnected Set.univ → IsConnected Set.univ →\n  IsConnected (Set.prod Set.univ Set.univ - Set.prod A B) ",
      "∀ {X Y : Type u} [inst_X : TopologicalSpace X] [inst_Y : TopologicalSpace Y] (A : Set X) (B : Set Y),\n  IsProperSubset A Set.univ → IsProperSubset B Set.univ → IsConnected Set.univ → IsConnected Set.univ →\n  IsConnected ((Set.univ.prod Set.univ) - (A.prod B)) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] {Y : Type u_2} [inst_1 : TopologicalSpace Y]\n  {A : Set X} {B : Set Y},\n  IsConnected X → IsConnected Y → A ≠ X → B ≠ Y → IsConnected ((X × Y) - (A × B)) ",
      "∀ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ → IsProperSubset B Set.univ → IsConnected (Set.univ : Set X) → IsConnected (Set.univ : Set Y) →\n  IsConnected (Set.univ \\ (A.prod B)) ",
      "∀ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ → IsProperSubset B Set.univ →\n  IsConnected (Set.univ : Set X) → IsConnected (Set.univ : Set Y) →\n  IsConnected (Set.univ \\ (A.prod B)) ",
      "∀ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ → IsProperSubset B Set.univ →\n  IsConnected Set.univ → IsConnected Set.univ_1 →\n  IsConnected ((Set.univ.prod Set.univ) - (A.prod B)) ",
      "∀ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ → IsProperSubset B Set.univ → IsConnected (Set.univ : Set X) → IsConnected (Set.univ : Set Y) →\n  IsConnected (Set.univ.prod Set.univ \\ (A.prod B)) ",
      "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]\n  {A : Set X} {B : Set Y}, A ⊂ X → B ⊂ Y → IsConnected X → IsConnected Y →\n  IsConnected (HasCompl.compl (A.prod B)) ",
      "∀ {X Y : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {A : Set X} {B : Set Y},\n  IsProperSubset A Set.univ → IsProperSubset B Set.univ → IsConnected Set.univ → IsConnected Set.univ → IsConnected ((Set.prod Set.univ Set.univ) \\ (Set.prod A B)) ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {X Y A B : Set α},\n  IsProperSubset A X → IsProperSubset B Y → IsConnected X → IsConnected Y → IsConnected ((X × Y) - (A × B)) "
    ]
  },
  {
    "docString": "Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Ring 𝕜] [inst_4 : NoZeroDivisors 𝕜],\\n  IsPreconnected S → ContinuousOn f S → Set.EqOn (f ^ 2) 1 S → Set.EqOn f 1 S ∨ Set.EqOn f (-1) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a function `α → 𝕜` which is continuous on a preconnected set `S`, and\\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\\nsuch that `f x = x + τ f`. \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_1} [inst : Zero G₀] [inst_1 : Inv G₀] [inst_2 : TopologicalSpace G₀] [self : HasContinuousInv₀ G₀]\\n  ⦃x : G₀⦄, x ≠ 0 → ContinuousAt Inv.inv x\",\n  \"isProp\": true,\n  \"docString\": \"The map `fun x ↦ x⁻¹` is continuous at all nonzero points. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S → Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → Set.EqOn f g S ∨ Set.EqOn f (-g) S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\\n`S`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\\n  IsPreconnected S →\\n    ContinuousOn f S →\\n      ContinuousOn g S →\\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\\none point of `S` it holds for all points. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\\n  [inst_3 : Module ℝ E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  0 ∈ s → Convex ℝ s → IsOpen s → ∀ {x₀ : E}, ¬x₀ ∈ s → ∃ f, ↑f x₀ = 1 ∧ ∀ (x : E), x ∈ s → ↑f x < 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a set `s` which is a convex neighbourhood of `0` and a point `x₀` outside of it, there is\\na continuous linear functional `f` separating `x₀` and `s`, in the sense that it sends `x₀` to 1 and\\nall of `s` to values strictly below `1`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\\n  (f' : ℂ → ℂ →L[ℝ] E) (z w : ℂ) (s : Set ℂ),\\n  Set.Countable s →\\n    ContinuousOn f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\\n      (∀ (x : ℂ),\\n          x ∈ Set.Ioo (min z.re w.re) (max z.re w.re) ×ℂ Set.Ioo (min z.im w.im) (max z.im w.im) \\\\ s →\\n            HasFDerivAt f (f' x) x) →\\n        MeasureTheory.IntegrableOn (fun z => Complex.I • ↑(f' z) 1 - ↑(f' z) Complex.I)\\n            (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\\n          (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) -\\n                  ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\\n                Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\\n              Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\\n            ∫ (x : ℝ) in z.re..w.re,\\n              ∫ (y : ℝ) in z.im..w.im, Complex.I • ↑(f' (↑x + ↑y * Complex.I)) 1 - ↑(f' (↑x + ↑y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\\n`z w : ℂ`, is *real* differentiable at all but countably many points of the corresponding open\\nrectangle, and $\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the\\nintegral of `f` over the boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"∀ {f : ℝ → ℝ}, Continuous f → StrictAnti (deriv f) → StrictConcaveOn ℝ Set.univ f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` is continuous and `f'` is strictly antitone on `ℝ` then `f` is strictly\\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\\none point by the strict antitonicity of `f'`. \"},\n {\"theorem\":\n  \"∀ {𝕂 : Type u_1} [inst : IsROrC 𝕂] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace 𝕂 E']\\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace 𝕂 F'] {f : E' → F'} {x : E'},\\n  ContDiffAt 𝕂 1 f x → ∃ K t, t ∈ nhds x ∧ LipschitzOnWith K f t\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. \"}]\n",
    "prompt_cons": "/-- If `f` is a function `α → 𝕜` which is continuous on a preconnected set `S`, and\n`f ^ 2 = 1` on `S`, then either `f = 1` on `S`, or `f = -1` on `S`. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Ring 𝕜] [inst_4 : NoZeroDivisors 𝕜],\n  IsPreconnected S → ContinuousOn f S → Set.EqOn (f ^ 2) 1 S → Set.EqOn f 1 S ∨ Set.EqOn f (-1) S :=\n\n/-- If `f` is a continuous monotone map `ℝ → ℝ`, `f (x + 1) = f x + 1`, then there exists `x`\nsuch that `f x = x + τ f`. -/\ntheorem ∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = x + CircleDeg1Lift.translationNumber f :=\n\n/-- The map `fun x ↦ x⁻¹` is continuous at all nonzero points. -/\ntheorem ∀ {G₀ : Type u_1} [inst : Zero G₀] [inst_1 : Inv G₀] [inst_2 : TopologicalSpace G₀] [self : HasContinuousInv₀ G₀]\n  ⦃x : G₀⦄, x ≠ 0 → ContinuousAt Inv.inv x :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then either `f = g` or `f = -g` on\n`S`. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S → Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → Set.EqOn f g S ∨ Set.EqOn f (-g) S :=\n\n/-- If `f, g` are functions `α → 𝕜`, both continuous on a preconnected set `S`, with\n`f ^ 2 = g ^ 2` on `S`, and `g z ≠ 0` all `z ∈ S`, then as soon as `f = g` holds at\none point of `S` it holds for all points. -/\ntheorem ∀ {α : Type u_2} {𝕜 : Type u_1} {f g : α → 𝕜} {S : Set α} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : T1Space 𝕜] [inst_3 : Field 𝕜] [inst_4 : HasContinuousInv₀ 𝕜] [inst_5 : ContinuousMul 𝕜],\n  IsPreconnected S →\n    ContinuousOn f S →\n      ContinuousOn g S →\n        Set.EqOn (f ^ 2) (g ^ 2) S → (∀ {x : α}, x ∈ S → g x ≠ 0) → ∀ {y : α}, y ∈ S → f y = g y → Set.EqOn f g S :=\n\n/-- Given a set `s` which is a convex neighbourhood of `0` and a point `x₀` outside of it, there is\na continuous linear functional `f` separating `x₀` and `s`, in the sense that it sends `x₀` to 1 and\nall of `s` to values strictly below `1`. -/\ntheorem ∀ {E : Type u_1} [inst : TopologicalSpace E] [inst_1 : AddCommGroup E] [inst_2 : TopologicalAddGroup E]\n  [inst_3 : Module ℝ E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  0 ∈ s → Convex ℝ s → IsOpen s → ∀ {x₀ : E}, ¬x₀ ∈ s → ∃ f, ↑f x₀ = 1 ∧ ∀ (x : E), x ∈ s → ↑f x < 1 :=\n\n/-- Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\n`z w : ℂ`, is *real* differentiable at all but countably many points of the corresponding open\nrectangle, and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the\nintegral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\n  (f' : ℂ → ℂ →L[ℝ] E) (z w : ℂ) (s : Set ℂ),\n  Set.Countable s →\n    ContinuousOn f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n      (∀ (x : ℂ),\n          x ∈ Set.Ioo (min z.re w.re) (max z.re w.re) ×ℂ Set.Ioo (min z.im w.im) (max z.im w.im) \\ s →\n            HasFDerivAt f (f' x) x) →\n        MeasureTheory.IntegrableOn (fun z => Complex.I • ↑(f' z) 1 - ↑(f' z) Complex.I)\n            (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n          (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) -\n                  ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\n                Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\n              Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\n            ∫ (x : ℝ) in z.re..w.re,\n              ∫ (y : ℝ) in z.im..w.im, Complex.I • ↑(f' (↑x + ↑y * Complex.I)) 1 - ↑(f' (↑x + ↑y * Complex.I)) Complex.I :=\n\n/-- If a function `f` is continuous and `f'` is strictly antitone on `ℝ` then `f` is strictly\nconcave. Note that we don't require differentiability, since it is guaranteed at all but at most\none point by the strict antitonicity of `f'`. -/\ntheorem ∀ {f : ℝ → ℝ}, Continuous f → StrictAnti (deriv f) → StrictConcaveOn ℝ Set.univ f :=\n\n/-- If `f` is `C^1` at `x`, then `f` is Lipschitz in a neighborhood of `x`. -/\ntheorem ∀ {𝕂 : Type u_1} [inst : IsROrC 𝕂] {E' : Type u_2} [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedSpace 𝕂 E']\n  {F' : Type u_3} [inst_3 : NormedAddCommGroup F'] [inst_4 : NormedSpace 𝕂 F'] {f : E' → F'} {x : E'},\n  ContDiffAt 𝕂 1 f x → ∃ K t, t ∈ nhds x ∧ LipschitzOnWith K f t :=\n\n/-- Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$. -/\ntheorem",
    "choices": [
      "∀ (f : CircleDeg1Lift), Continuous ↑f → ∃ x, ↑f x = ↑f (-x) ",
      "∀ (f : Circle → ℝ), Continuous f → ∃ x : Circle, f x = f (-x) ",
      "∀ (f : Circle → ℝ), Continuous f → ∃ x, f x = f (-x) ",
      "∀ (f : Circle → ℝ), Continuous f → ∃ x, f x = f (-x) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} {f : E → 𝕜} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜]\n  [inst_2 : TopologicalSpace E] [inst_3 : HasContinuousSmul 𝕜 E],\n  (∃ x, ∥x∥ = 1 ∧ f (x) = f (-x)) ",
      "∀ (f : Circle → ℝ),\n  Continuous f →\n  ∃ x : Circle, f x = f (-x) ",
      "∀ (f : Circle → ℝ), Continuous f → ∃ x, f x = f (-x) ",
      "∀ (f : ℂ → ℝ), Continuous f → ∃ x, x ∈ Circle.map Complex.I ∧ f x = f (-x) ",
      "∀ (f : Circle → ℝ), Continuous f → ∃ x, f x = f (-x) ",
      "∀ (f : Circle → ℝ), Continuous f → ∃ x, f x = f (-x) "
    ]
  },
  {
    "docString": "Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsPathConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is path connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [i : LocallyConnectedSpace β],\\n  α ≃ₜ β → LocallyConnectedSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the codomain of a homeomorphism is a locally connected space, then the domain is also\\na locally connected space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two points in a path-connected space must be joined by a continuous path. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X],\\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s)\",\n  \"isProp\": true,\n  \"docString\": \"The closure of a connected set is connected as well. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (p₁ p₂ : Path x y),\\n  Path.Homotopic p₁ p₂\",\n  \"isProp\": true,\n  \"docString\": \"In a simply connected space, any two paths are homotopic \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {U W : Set X},\\n  IsPathConnected W → W ⊆ U → IsPathConnected (Subtype.val ⁻¹' W)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\\nambient type `U` (when `U` contains `W`). \"},\n {\"theorem\":\n  \"∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a topological space admits an atlas with locally connected charts, then the space itself is\\nlocally connected. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"}]\n",
    "prompt_cons": "/-- A nonempty convex set is path connected. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → Set.Nonempty s → IsPathConnected s :=\n\n/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [i : LocallyConnectedSpace β],\n  α ≃ₜ β → LocallyConnectedSpace α :=\n\n/-- Any two points in a path-connected space must be joined by a continuous path. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X] (x y : X), Joined x y :=\n\n/-- Let `X` be a topological space, and suppose that for all distinct `x,y ∈ X`, there\nis some clopen set `U` such that `x ∈ U` and `y ∉ U`. Then `X` is totally disconnected. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X],\n  (Pairwise fun x y => ∃ U, IsClopen U ∧ x ∈ U ∧ ¬y ∈ U) → IsTotallyDisconnected Set.univ :=\n\n/-- A nonempty convex set is connected. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → Set.Nonempty s → IsConnected s :=\n\n/-- The closure of a connected set is connected as well. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α}, IsConnected s → IsConnected (closure s) :=\n\n/-- In a simply connected space, any two paths are homotopic -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : SimplyConnectedSpace X] {x y : X} (p₁ p₂ : Path x y),\n  Path.Homotopic p₁ p₂ :=\n\n/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller\nambient type `U` (when `U` contains `W`). -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {U W : Set X},\n  IsPathConnected W → W ⊆ U → IsPathConnected (Subtype.val ⁻¹' W) :=\n\n/-- If a topological space admits an atlas with locally connected charts, then the space itself is\nlocally connected. -/\ntheorem ∀ (H : Type u) (M : Type u_1) [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]\n  [inst : LocallyConnectedSpace H], LocallyConnectedSpace M :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U → IsOpen U → IsPathConnected U ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {s : Set X},\n  IsConnected s → IsOpen s → IsPathConnected s ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U → IsConnected U → IsPathConnected U ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {s : Set X},\n  IsOpen s → IsConnected s → IsPathConnected s ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U → IsOpen U → IsPathConnected U ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U → IsConnected U → IsPathConnected U ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsConnected U → IsOpen U → IsPathConnected U ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [self : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U → IsConnected U → IsPathConnected U ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyPathConnectedSpace X] {U : Set X},\n  IsOpen U → IsConnected U → IsPathConnected U ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyPathConnectedSpace α] {s : Set α},\n  IsConnected s → IsOpen s → IsPathConnected s "
    ]
  },
  {
    "docString": "Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t\",\n  \"isProp\": true,\n  \"docString\": \"A closed subset of a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous map from a compact space to a Hausdorff space is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every member of an open set in a compact Hausdorff totally disconnected space\\nis contained in a clopen set contained in the open set.  \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**:\\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β)\",\n  \"isProp\": true,\n  \"docString\": \"The disjoint union of two compact spaces is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α)\",\n  \"isProp\": true,\n  \"docString\": \"In a compact space, the type of closed subsets is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of two open compact subsets of a quasi-separated space is compact.\"}]\n",
    "prompt_cons": "/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- A closed subset of a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → t ⊆ s → IsCompact t :=\n\n/-- A continuous map from a compact space to a Hausdorff space is a closed map. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : T2Space β] {f : α → β}, Continuous f → IsClosedMap f :=\n\n/-- Every member of an open set in a compact Hausdorff totally disconnected space\nis contained in a clopen set contained in the open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  [inst_3 : TotallyDisconnectedSpace α] {x : α} {U : Set α}, IsOpen U → x ∈ U → ∃ V, IsClopen V ∧ x ∈ V ∧ V ⊆ U :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- The **Heine–Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : T2Space α] [inst_2 : ProperSpace α],\n  IsCompact s ↔ IsClosed s ∧ Metric.Bounded s :=\n\n/-- The disjoint union of two compact spaces is compact. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : CompactSpace α]\n  [inst_3 : CompactSpace β], CompactSpace (α ⊕ β) :=\n\n/-- In a compact space, the type of closed subsets is compact. -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.Closeds α) :=\n\n/-- The intersection of two open compact subsets of a quasi-separated space is compact. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : QuasiSeparatedSpace α] (U V : Set α),\n  IsOpen U → IsCompact U → IsOpen V → IsCompact V → IsCompact (U ∩ V) :=\n\n/-- Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α] {A : Set (Set α)},\n  SimplyOrderedBy A (⊆) → (∀ B ∈ A, IsClosed B ∧ IsConnected B) → IsConnected (Set.Interₓ A) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  {A : Set (Set α)}, (∀ (a : Set α), a ∈ A → IsClosed a ∧ IsConnected a) →\n  Zorn.Chain HasSubset.Subset A → ∀ (Y : Set α), Y = ⋂₀ A → IsConnected Y ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  {A : Set (Set α)} (s : A → Set α) [is_connected : ∀ a : A, IsConnected (s a)] [is_closed : ∀ a : A, IsClosed (s a)]\n  (h_directed : ∀ a b : A, ∃ c, s a ⊆ s c ∧ s b ⊆ s c) (h_nonempty : ∃ a : A, True),\n  IsConnected (⋂₀ (s '' A)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α],\n  {A : Set (Set α)} → (∀ (s : Set α), s ∈ A → IsClosed s ∧ IsConnected s)\n  → (∀ (s1 s2 : Set α), s1 ∈ A → s2 ∈ A → s1 ⊆ s2 ∨ s2 ⊆ s1)\n  → IsConnected (⋂₀ A) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α] {A : Set (Set α)},\n  (∀ x ∈ A, IsClosed x ∧ IsConnected x) → (∀ x y ∈ A, x ⊆ y ∨ y ⊆ x) →\n  IsConnected (⋂₀ A) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α]\n  {A : Set (Set α)}, ∀ (hA : DirectedOn HasSubset.Subset A) (hA_closed : ∀ (a : Set α), a ∈ A → IsClosed a ∧ IsConnected a),\n  IsConnected (⋂₀ A) ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α],\n  ∀ (A : Set (Set α)), (∀ (a : Set α), a ∈ A → IsClosed a ∧ IsConnected a) →\n  (∀ (a₁ a₂ : Set α), a₁ ∈ A → a₂ ∈ A → a₁ ⊆ a₂ ∨ a₂ ⊆ a₁) →\n  IsConnected (⋂₀ A) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α],\n  {A : Set (Set α)} (hA : ∀ (a : Set α), a ∈ A → IsClosed a ∧ IsConnected a)\n  (hA_directed : ∀ (a b : Set α), a ∈ A → b ∈ A → ∃ c, c ∈ A ∧ a ⊆ c ∧ b ⊆ c),\n  IsConnected (⋂₀ A) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α] {𝒜 : Set (Set α)}, \n  (∀ A ∈ 𝒜, IsClosed A ∧ IsConnected A) → (∀ A B ∈ 𝒜, A ⊆ B ∨ B ⊆ A) → \n  IsConnected (⋂₀ 𝒜) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompactSpace α] {A : Set (Set α)},\n  (∀ (s : Set α), s ∈ A → IsClosed s ∧ IsConnected s) → (∀ {s t : Set α}, s ∈ A → t ∈ A → s ⊆ t ∨ t ⊆ s) →\n  IsConnected (⋂₀ A) "
    ]
  },
  {
    "docString": "Show that a connected metric space having more than one point is uncountable.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\\n  Measurable f → MeasureTheory.StronglyMeasurable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies strongly measurable. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\\n  TopologicalSpace.FirstCountableTopology X\",\n  \"isProp\": true,\n  \"docString\": \"Every pseudo-metrizable space is first countable. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\\n  IsOpenMap Quotient.mk' → TopologicalSpace.SecondCountableTopology (Quotient S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open quotient of a second countable space is second countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι},\\n  Set.PairwiseDisjoint a s →\\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\\n  CompleteSpace ((i : ι) × E i)\",\n  \"isProp\": true,\n  \"docString\": \"A disjoint union of complete metric spaces is complete. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : MetricSpace α],\\n  (∀ (ε : ℝ), ε > 0 → ∃ β x F, ∀ (x y : α), F x = F y → dist x y ≤ ε) → TopologicalSpace.SecondCountableTopology α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A metric space is second countable if one can reconstruct up to any `ε>0` any element of the\\nspace from countably many data. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {f : α → β} {x : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} [inst_1 : MeasurableSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\\n  Measurable f → MeasureTheory.AEStronglyMeasurable f μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a space with second countable topology, measurable implies ae strongly measurable. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  TopologicalSpace.PseudoMetrizableSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"A uniform space with countably generated `𝓤 X` is pseudo metrizable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"}]\n",
    "prompt_cons": "/-- In a space with second countable topology, measurable implies strongly measurable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {f : α → β} {mα : MeasurableSpace α} [inst : MeasurableSpace β]\n  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\n  Measurable f → MeasureTheory.StronglyMeasurable f :=\n\n/-- Every pseudo-metrizable space is first countable. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [h : TopologicalSpace.PseudoMetrizableSpace X],\n  TopologicalSpace.FirstCountableTopology X :=\n\n/-- An open quotient of a second countable space is second countable. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] {S : Setoid X} [inst_1 : TopologicalSpace.SecondCountableTopology X],\n  IsOpenMap Quotient.mk' → TopologicalSpace.SecondCountableTopology (Quotient S) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a :=\n\n/-- A disjoint union of complete metric spaces is complete. -/\ntheorem ∀ {ι : Type u_2} {E : ι → Type u_1} [inst : (i : ι) → MetricSpace (E i)] [inst_1 : ∀ (i : ι), CompleteSpace (E i)],\n  CompleteSpace ((i : ι) × E i) :=\n\n/-- A metric space is second countable if one can reconstruct up to any `ε>0` any element of the\nspace from countably many data. -/\ntheorem ∀ {α : Type u} [inst : MetricSpace α],\n  (∀ (ε : ℝ), ε > 0 → ∃ β x F, ∀ (x y : α), F x = F y → dist x y ≤ ε) → TopologicalSpace.SecondCountableTopology α :=\n\n/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- In a space with second countable topology, measurable implies ae strongly measurable. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace β] {f : α → β} {x : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} [inst_1 : MeasurableSpace β] [inst_2 : TopologicalSpace.PseudoMetrizableSpace β]\n  [inst_3 : TopologicalSpace.SecondCountableTopology β] [inst_4 : OpensMeasurableSpace β],\n  Measurable f → MeasureTheory.AEStronglyMeasurable f μ :=\n\n/-- A uniform space with countably generated `𝓤 X` is pseudo metrizable. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  TopologicalSpace.PseudoMetrizableSpace X :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- Show that a connected metric space having more than one point is uncountable. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : MetricSpace α] [self : ConnectedSpace α],\n  (∃ (x y : α), x ≠ y) → Set.Noncountable Set.Univ ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : ConnectedSpace α] [inst_2 : Nonempty α] [inst_3 : Nontrivial α],\n  ¬Set.Countable (Set.Univ : Set α) ",
      "∀ {α : Type u} [inst : MetricSpace α] [nontrivial : Nontrivial α] [connected_space : ConnectedSpace α],\n  ¬Set.Countable (Set.Univ : Set α) ",
      "∀ {α : Type u} [inst : MetricSpace α] [self : ConnectedSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  (Exists (λ (x : α), Exists (λ (y : α), x ≠ y))) → ¬Set.Countable Set.Univ ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : ConnectedSpace α] [ne : Nonempty α],\n  2 ≤ Cardinal.mk α → Cardinal.mk α = Cardinal.omega → False ",
      "∀ {α : Type u} [inst : MetricSpace α] [self : ConnectedSpace α], 2 ≤ Set.Nonempty.to_nat (Set.Nonempty α) → Not (Set.Countable α) ",
      "∀ {α : Type u} [_inst_1 : MetricSpace α] [_inst_2 : TopologicalSpace.ConnectedSpace α],\n  Set.Nonempty (α → ℕ) → ∃ (x y : α), x ≠ y → ¬ Set.Countable (Set.Univ α) ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : ConnectedSpace α] [inst_2 : Nontrivial α],\n  Set.Uncountable (Set.Range (fun x : α => x)) ",
      "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : ConnectedSpace α] [inst_2 : TopologicalSpace.SecondCountableTopology α],\n  2 ≤ Cardinal.mk α → Cardinal.mk α = Cardinal.omega → False ",
      "∀ {X : Type u} [inst : MetricSpace X] [inst_1 : ConnectedSpace X],\n  (∃ (x y : X), x ≠ y) → ¬Set.Countable Set.Univ "
    ]
  },
  {
    "docString": "Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\\n  Directed (fun x x_1 => x ⊇ x_1) Z →\\n    (∀ (i : ι), Set.Nonempty (Z i)) →\\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem:\\nthe intersection of a directed family of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\\n  IsSeqCompact s → IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `𝓤 β` is countably generated, then any sequentially compact set is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Cantor's intersection theorem for sequences indexed by `ℕ`:\\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any uncountable closed set in a second countable space contains a nonempty perfect subset.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a compact space, the type of nonempty compact subsets is compact. This follows from\\nthe same statement for closed subsets \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"}]\n",
    "prompt_cons": "/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Cantor's intersection theorem:\nthe intersection of a directed family of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type v} [hι : Nonempty ι] (Z : ι → Set α),\n  Directed (fun x x_1 => x ⊇ x_1) Z →\n    (∀ (i : ι), Set.Nonempty (Z i)) →\n      (∀ (i : ι), IsCompact (Z i)) → (∀ (i : ι), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ι), Z i) :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- If `𝓤 β` is countably generated, then any sequentially compact set is compact. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X} [inst_1 : Filter.IsCountablyGenerated (uniformity X)],\n  IsSeqCompact s → IsCompact s :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- Cantor's intersection theorem for sequences indexed by `ℕ`:\nthe intersection of a decreasing sequence of nonempty compact closed sets is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] (Z : ℕ → Set α),\n  (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n    (∀ (i : ℕ), Set.Nonempty (Z i)) → IsCompact (Z 0) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) :=\n\n/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] {C : Set α} [inst_1 : TopologicalSpace.SecondCountableTopology α],\n  IsClosed C → ¬Set.Countable C → ∃ D, Perfect D ∧ Set.Nonempty D ∧ D ⊆ C :=\n\n/-- In a compact space, the type of nonempty compact subsets is compact. This follows from\nthe same statement for closed subsets -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] [inst_1 : CompactSpace α], CompactSpace (TopologicalSpace.NonemptyCompacts α) :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α],\n  IsCountablyCompact α ↔\n    ∀ (Z : ℕ → Set α),\n      (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n        (∀ (i : ℕ), Set.Nonempty (Z i)) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α],\n  IsCountablyCompact (univ : Set α) ↔\n    ∀ (S : ℕ → Set α),\n      (∀ (i : ℕ), IsClosed (S i)) →\n        (∀ (i : ℕ), Set.Nonempty (S i)) →\n          (∀ (i : ℕ), S (i + 1) ⊆ S i) → Set.Nonempty (⋂ (i : ℕ), S i) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  IsCountablyCompact X ↔\n    (∀ (C : ℕ → Set X),\n      (∀ (i : ℕ), IsClosed (C i)) →\n        (∀ (i : ℕ), Set.Nonempty (C i)) →\n          (∀ (i : ℕ), C (i + 1) ⊆ C i) → Set.Nonempty (⋂ (i : ℕ), C i)) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  IsCountablyCompact X ↔\n    ∀ (Z : ℕ → Set X),\n      (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n        (∀ (i : ℕ), Set.Nonempty (Z i)) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) ",
      "∀ {α : Type u} [inst : TopologicalSpace α],\n  IsCountablyCompact (univ : Set α) ↔\n    ∀ (Z : ℕ → Set α),\n      (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n        (∀ (i : ℕ), Set.Nonempty (Z i)) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) ",
      "∀ {α : Type u} [inst : TopologicalSpace α],\n  IsCountablyCompact α ↔\n    ∀ (Z : ℕ → Set α),\n      (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n        (∀ (i : ℕ), Set.Nonempty (Z i)) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  IsCountablyCompact X ↔\n    ∀ (Z : ℕ → Set X),\n      (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n        (∀ (i : ℕ), Set.Nonempty (Z i)) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) ",
      "∀ {α : Type u} [inst : TopologicalSpace α],\n  IsCountablyCompact α ↔\n    ∀ (Z : ℕ → Set α),\n      (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n        (∀ (i : ℕ), Set.Nonempty (Z i)) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) ",
      "∀ {α : Type u} [inst : TopologicalSpace α],\n  IsCountablyCompact α ↔\n    ∀ (Z : ℕ → Set α),\n      (∀ (i : ℕ), Z (i + 1) ⊆ Z i) →\n        (∀ (i : ℕ), Set.Nonempty (Z i)) → (∀ (i : ℕ), IsClosed (Z i)) → Set.Nonempty (⋂ (i : ℕ), Z i) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X],\n  IsCountablyCompact X ↔\n    ∀ (C : ℕ → Set X), (∀ (i : ℕ), IsClosed (C i)) →\n      (∀ (i : ℕ), Set.Nonempty (C i)) →\n        (∀ (i : ℕ), C (i + 1) ⊆ C i) → Set.Nonempty (⋂ (i : ℕ), C i) "
    ]
  },
  {
    "docString": "Show that the rationals $\\mathbb{Q}$ are not locally compact.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\": \"¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"The complex numbers are not countable. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : ∀ (i : ι), CompactSpace (π i)],\\n  LocallyCompactSpace ((i : ι) → π i)\",\n  \"isProp\": true,\n  \"docString\": \"For spaces that are not Hausdorff. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ\",\n  \"isProp\": true,\n  \"docString\": \"In a noncompact space, `Set.univ` is not a compact set. \"},\n {\"theorem\": \"¬Set.Countable Set.univ\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Non-Denumerability of the Continuum**: The reals are not countable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α),\\n  Disjoint (nhds x) (Filter.cocompact α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, the filters `𝓝 x` and `cocompact α` are disjoint for all `α`. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstSMul Γ T]\\n  [inst_6 : ProperlyDiscontinuousSMul Γ T], T2Space (Quotient (MulAction.orbitRel Γ T))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by a discontinuous group action of a locally compact t2 space is t2. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q)\",\n  \"isProp\": true,\n  \"docString\": \"The continued fraction of a rational number terminates. \"}]\n",
    "prompt_cons": "/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- The complex numbers are not countable. -/\ntheorem ¬Set.Countable Set.univ :=\n\n/-- For spaces that are not Hausdorff. -/\ntheorem ∀ {ι : Type u_1} {π : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (π i)]\n  [inst_1 : ∀ (i : ι), LocallyCompactSpace (π i)] [inst_2 : ∀ (i : ι), CompactSpace (π i)],\n  LocallyCompactSpace ((i : ι) → π i) :=\n\n/-- In a noncompact space, `Set.univ` is not a compact set. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : NoncompactSpace α], ¬IsCompact Set.univ :=\n\n/-- **Non-Denumerability of the Continuum**: The reals are not countable. -/\ntheorem ¬Set.Countable Set.univ :=\n\n/-- In a locally compact space, the filters `𝓝 x` and `cocompact α` are disjoint for all `α`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α),\n  Disjoint (nhds x) (Filter.cocompact α) :=\n\n/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/\ntheorem ∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\n  [inst_3 : T2Space T] [inst_4 : LocallyCompactSpace T] [inst_5 : ContinuousConstSMul Γ T]\n  [inst_6 : ProperlyDiscontinuousSMul Γ T], T2Space (Quotient (MulAction.orbitRel Γ T)) :=\n\n/-- If `X` is a non-compact space, then `∞` is not an isolated point of `OnePoint X`. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : NoncompactSpace X],\n  Filter.NeBot (nhdsWithin OnePoint.infty {OnePoint.infty}ᶜ) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- The continued fraction of a rational number terminates. -/\ntheorem ∀ (q : ℚ), GeneralizedContinuedFraction.Terminates (GeneralizedContinuedFraction.of q) :=\n\n/-- Show that the rationals $\\mathbb{Q}$ are not locally compact. -/\ntheorem",
    "choices": [
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ ",
      "¬LocallyCompactSpace ℚ "
    ]
  },
  {
    "docString": "Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [hα : LocallyCompactSpace α] {K U : Set α},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ L, IsCompact L ∧ K ⊆ interior L ∧ L ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, for every containment `K ⊆ U` of a compact set `K` in an open\\nset `U`, there is a compact neighborhood `L` such that `K ⊆ L ⊆ U`: equivalently, there is a\\ncompact `L` such that `K ⊆ interior L` and `L ⊆ U`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every point has an open neighborhood with compact closure \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {x : α} {U : Set α},\\n  IsOpen U → x ∈ U → ∃ K, IsCompact K ∧ x ∈ interior K ∧ K ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"A reformulation of the definition of locally compact space: In a locally compact space,\\nevery open set containing `x` has a compact subset containing `x` in its interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"}]\n",
    "prompt_cons": "/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- In a locally compact space, for every containment `K ⊆ U` of a compact set `K` in an open\nset `U`, there is a compact neighborhood `L` such that `K ⊆ L ⊆ U`: equivalently, there is a\ncompact `L` such that `K ⊆ interior L` and `L ⊆ U`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [hα : LocallyCompactSpace α] {K U : Set α},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ L, IsCompact L ∧ K ⊆ interior L ∧ L ⊆ U :=\n\n/-- In a locally compact T₂ space, every point has an open neighborhood with compact closure -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α),\n  ∃ U, IsOpen U ∧ x ∈ U ∧ IsCompact (closure U) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- A reformulation of the definition of locally compact space: In a locally compact space,\nevery open set containing `x` has a compact subset containing `x` in its interior. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {x : α} {U : Set α},\n  IsOpen U → x ∈ U → ∃ K, IsCompact K ∧ x ∈ interior K ∧ K ⊆ U :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α] (x : α) (U : Set α),\n  U ∈ nhds x → ∃ V, V ∈ nhds x ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α) (U : Set α),\n  U ∈ nhds x → ∃ V, V ∈ nhds x ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α]\n  (x : α) (U : Set α), U ∈ nhds x → ∃ V, V ∈ nhds x ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : LocallyCompactSpace α] (x : α) (U : Set α),\n  U ∈ nhds x → ∃ V, V ∈ nhds x ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α) (U : Set α),\n  U ∈ nhds x → ∃ V, IsOpen V ∧ x ∈ V ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [LocallyCompactSpace α]\n  (x : α) (U : Set α), U ∈ nhds x → ∃ V, IsOpen V ∧ x ∈ V ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α) (U : Set α),\n  U ∈ nhds x → ∃ V, V ∈ nhds x ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α) (U : Set α),\n  U ∈ nhds x → ∃ V, V ∈ nhds x ∧ IsCompact (closure V) ∧ closure V ⊆ U ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] (x : α) (U : Set α),\n  (∃ s, s ∈ nhds x ∧ IsCompact s) → U ∈ nhds x → ∃ V, V ∈ nhds x ∧ closure V ⊆ U ∧ IsCompact (closure V) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] (x : α) (U : Set α),\n  U ∈ nhds x → ∃ V, IsCompact (closure V) ∧ x ∈ V ∧ V ⊆ U "
    ]
  },
  {
    "docString": "Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s\",\n  \"isProp\": true,\n  \"docString\": \"There exists a countable dense set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsOpen (f s)) →\\n    Set.Countable S → (∀ (s : β), s ∈ S → Dense (f s)) → Dense (⋂ (s : β) (_ : s ∈ S), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: if countably many closed sets cover the whole space, then their interiors\\nare dense. Formulated here with an index set which is a countable set in any type. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a second-countable space, an open set, given as a union of open sets,\\nis equal to the union of countably many of those sets. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set is dense if and only if it has a nonempty intersection with each nonempty open set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, Dense s → Dense t → IsOpen t → Dense (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a dense set with an open dense set is a dense set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Encodable β]\\n  {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Dense (⋂ (s : β), f s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\\nan index set which is an encodable type. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\\n  {a : Set ι},\\n  Set.PairwiseDisjoint a s →\\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a separable space, a family of nonempty disjoint open sets is countable. \"}]\n",
    "prompt_cons": "/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsOpen s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- There exists a countable dense set. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α], ∃ s, Set.Countable s ∧ Dense s :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsOpen (f s)) →\n    Set.Countable S → (∀ (s : β), s ∈ S → Dense (f s)) → Dense (⋂ (s : β) (_ : s ∈ S), f s) :=\n\n/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors\nare dense. Formulated here with an index set which is a countable set in any type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set β} {f : β → Set α},\n  (∀ (s : β), s ∈ S → IsClosed (f s)) →\n    Set.Countable S → ⋃ (s : β) (_ : s ∈ S), f s = Set.univ → Dense (⋃ (s : β) (_ : s ∈ S), interior (f s)) :=\n\n/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : Set (Set α)},\n  (∀ (s : Set α), s ∈ S → IsGδ s) → Set.Countable S → (∀ (s : Set α), s ∈ S → Dense s) → Dense (⋂₀ S) :=\n\n/-- In a second-countable space, an open set, given as a union of open sets,\nis equal to the union of countably many of those sets. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SecondCountableTopology α] {ι : Type u_1}\n  (s : ι → Set α), (∀ (i : ι), IsOpen (s i)) → ∃ T, Set.Countable T ∧ ⋃ (i : ι) (_ : i ∈ T), s i = ⋃ (i : ι), s i :=\n\n/-- A set is dense if and only if it has a nonempty intersection with each nonempty open set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  Dense s ↔ ∀ (U : Set α), IsOpen U → Set.Nonempty U → Set.Nonempty (U ∩ s) :=\n\n/-- The intersection of a dense set with an open dense set is a dense set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, Dense s → Dense t → IsOpen t → Dense (s ∩ t) :=\n\n/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with\nan index set which is an encodable type. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] [inst_2 : Encodable β]\n  {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Dense (⋂ (s : β), f s) :=\n\n/-- In a separable space, a family of nonempty disjoint open sets is countable. -/\ntheorem ∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), i ∈ a → IsOpen (s i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (s i)) → Set.Countable a :=\n\n/-- Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable. -/\ntheorem",
    "choices": [
      "forall {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α},\n  (∀ (i : ι), IsOpen (s i)) → Set.PairwiseDisjoint s → (∀ (i : ι), Set.Nonempty (s i)) → Set.Countable (Set.Range s) ",
      "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α},\n  Set.PairwiseDisjoint (Set.Range s) (λ (i : ι), s i) →\n    (∀ (i : ι), IsOpen (s i)) → (∀ (i : ι), Set.Nonempty (s i)) → Set.Countable (Set.Range s) ",
      "forall {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α},\n  Set.PairwiseDisjoint s →\n    (∀ (i : ι), IsOpen (s i)) → (∀ (i : ι), Set.Nonempty (s i)) → Set.Countable (Set.Range s) ",
      "∀ {α : Type u} [t : TopologicalSpace α] [_inst_3 : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α},\n  (∀ (i j : ι), i ≠ j → Disjoint (s i) (s j)) →\n    (∀ (i : ι), IsOpen (s i)) → Set.Countable (Set.Range s) ",
      "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α},\n  Set.PairwiseDisjoint Set.univ s →\n    (∀ (i : ι), IsOpen (s i)) → (∀ (i : ι), Set.Nonempty (s i)) → Set.Countable (Set.Range s) ",
      "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α},\n  (∀ (i : ι), IsOpen (s i)) → Set.PairwiseDisjoint s → (∀ (i : ι), Set.Nonempty (s i)) → Set.Countable (Set.Range s) ",
      "∀ {α : Type u} [t : TopologicalSpace α] {S : Set α},\n  (∃ s, Set.Countable s ∧ Dense s) → ∀ {ι : Type u_1} {f : ι → Set α} {a : Set ι},\n    Set.PairwiseDisjoint a f →\n      (∀ (i : ι), i ∈ a → IsOpen (f i)) → (∀ (i : ι), i ∈ a → Set.Nonempty (f i)) → Set.Countable a ",
      "∀ {α : Type u} [t : TopologicalSpace α] [self : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α}\n  {a : Set ι},\n  Set.PairwiseDisjoint a s →\n    (∀ (i : ι), IsOpen (s i)) → (∀ (i : ι), Set.Nonempty (s i)) → Set.Countable a ",
      "∀ {α : Type u} [t : TopologicalSpace α] {s : Set α}, (∃ t, Set.Countable t ∧ Dense t) →\n  ∀ {ι : Type u_1} {U : ι → Set α},\n  (∀ (i : ι), IsOpen (U i)) → Set.PairwiseDisjoint Set.univ U → Set.Countable (SetOf fun i => Set.Nonempty (U i)) ",
      "∀ {α : Type u} [t : TopologicalSpace α] [inst : TopologicalSpace.SeparableSpace α] {ι : Type u_1} {s : ι → Set α},\n  Set.PairwiseDisjoint (Set.Range s) s →\n    (∀ (i : ι), IsOpen (s i)) → (∀ (i : ι), Set.Nonempty (s i)) → Set.Countable (Set.Range s) "
    ]
  },
  {
    "docString": "Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a disjoint covering by two open sets of a clopen set will be clopen. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Hausdorff distance between two sets and their closures coincide \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every two points in a Hausdorff space admit disjoint open neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ closure s = closure t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two sets are at zero Hausdorff distance if and only if they have the same closures \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\\n  x ≠ y →\\n    ∃ U₁,\\n      U₁ ∈ nhds x ∧\\n        ∃ V₁,\\n          V₁ ∈ nhds x ∧\\n            ∃ U₂,\\n              U₂ ∈ nhds y ∧\\n                ∃ V₂,\\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, every compact set has an open neighborhood with compact closure.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\\ndisjoint. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\\n  IsClosed s → IsClosed t → EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ s = t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two closed sets are at zero Hausdorff distance if and only if they coincide \"}]\n",
    "prompt_cons": "/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- The intersection of a disjoint covering by two open sets of a clopen set will be clopen. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {Z a b : Set α},\n  IsClopen Z → Z ⊆ a ∪ b → IsOpen a → IsOpen b → Disjoint a b → IsClopen (Z ∩ a) :=\n\n/-- The Hausdorff distance between two sets and their closures coincide -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  Metric.hausdorffDist (closure s) (closure t) = Metric.hausdorffDist s t :=\n\n/-- Every two points in a Hausdorff space admit disjoint open neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T2Space α] (x y : α),\n  x ≠ y → ∃ u v, IsOpen u ∧ IsOpen v ∧ x ∈ u ∧ y ∈ v ∧ Disjoint u v :=\n\n/-- Two sets are at zero Hausdorff distance if and only if they have the same closures -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ closure s = closure t) :=\n\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds x ∧\n            ∃ U₂,\n              U₂ ∈ nhds y ∧\n                ∃ V₂,\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- In a locally compact T₂ space, every compact set has an open neighborhood with compact closure. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K : Set α},\n  IsCompact K → ∃ V, IsOpen V ∧ K ⊆ V ∧ IsCompact (closure V) :=\n\n/-- Given two distinct points in a T₂.₅ space, their filters of closed neighborhoods are\ndisjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : T25Space α] ⦃x y : α⦄,\n  x ≠ y → Disjoint (Filter.lift' (nhds x) closure) (Filter.lift' (nhds y) closure) :=\n\n/-- Two closed sets are at zero Hausdorff distance if and only if they coincide -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → EMetric.hausdorffEdist s t ≠ ⊤ → (Metric.hausdorffDist s t = 0 ↔ s = t) :=\n\n/-- Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t →\n    ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedClosuresNhds s t ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t →\n    ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t →\n    ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s t : Set α},\n  IsClosed s → IsClosed t → Disjoint s t →\n    ∃ u v, IsOpen u ∧ IsOpen v ∧ s ⊆ u ∧ t ⊆ v ∧ Disjoint (closure u) (closure v) "
    ]
  },
  {
    "docString": "Show that a closed subspace of a normal space is normal.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Coercing a subspace to a set then taking the affine span produces the original subspace. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace is dense iff its topological closure is the entire space. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s :=\n\n/-- A subspace is dense iff its topological closure is the entire space. -/\ntheorem ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : TopologicalSpace M] [inst_2 : AddCommMonoid M]\n  [inst_3 : Module R M] [inst_4 : ContinuousConstSMul R M] [inst_5 : ContinuousAdd M] {s : Submodule R M},\n  Dense ↑s ↔ Submodule.topologicalClosure s = ⊤ :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- Affine subspaces are convex. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q :=\n\n/-- Show that a closed subspace of a normal space is normal. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Subspace α),\n  IsClosed s → NormalSpace {x // x ∈ s} ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace (Subtype s) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] {s : Set α},\n  IsClosed s → NormalSpace (Subtype.topologicalSpace.restricted s) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace (topologicalSpace.restrict s) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Subspace α),\n  IsClosed s → Subspace.Normal s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace (Subtype s) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace (Subtype s) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Subspace α),\n  IsClosed s → NormalSpace { x // x ∈ s } ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Set α),\n  IsClosed s → NormalSpace {x // x ∈ s} ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s : Submodule α),\n  IsClosed ↑s → Submodule.Normal s "
    ]
  },
  {
    "docString": "Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\\nsome compact set with non-empty interior.\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\\nmany nonempty elements. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\\nare regular. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a → IsSMulRegular M s → IsSMulRegular M (a • s)\",\n  \"isProp\": true,\n  \"docString\": \"The product of `M`-regular elements is `M`-regular. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The affine span of a nonempty set is nonempty. \"},\n {\"theorem\": \"∀ {α : Type u_1} [inst : Countable α], Countable (Multiset α)\",\n  \"isProp\": true,\n  \"docString\": \"If `α` is countable, then so is `Multiset α`. \"},\n {\"theorem\":\n  \"∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t)\",\n  \"isProp\": true,\n  \"docString\": \"Finite product of finite sets is finite \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id\",\n  \"isProp\": true,\n  \"docString\":\n  \"Distinct elements of a set of sets partitioning α are disjoint. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], IsRegular a ↔ a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a non-trivial integral domain, an element is regular iff it is non-zero. \"}]\n",
    "prompt_cons": "/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite on\nsome compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalAddGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsAddLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- If `α` is a compact space, then a locally finite family of sets of `α` can have only finitely\nmany nonempty elements. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {ι : Type u_1} [inst_1 : CompactSpace α] {f : ι → Set α},\n  LocallyFinite f → Set.Finite {i | Set.Nonempty (f i)} :=\n\n/-- Two elements `a` and `b` are regular if and only if both products `a * b` and `b * a`\nare regular. -/\ntheorem ∀ {R : Type u_1} [inst : Semigroup R] {a b : R}, IsRegular (a * b) ∧ IsRegular (b * a) ↔ IsRegular a ∧ IsRegular b :=\n\n/-- The product of `M`-regular elements is `M`-regular. -/\ntheorem ∀ {R : Type u_1} {S : Type u_3} {M : Type u_2} {a : R} {s : S} [inst : SMul R M] [inst_1 : SMul R S] [inst_2 : SMul S M]\n  [inst_3 : IsScalarTower R S M], IsSMulRegular M a → IsSMulRegular M s → IsSMulRegular M (a • s) :=\n\n/-- The affine span of a nonempty set is nonempty. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P} [inst_4 : Nonempty ↑s], Nonempty { x // x ∈ affineSpan k s } :=\n\n/-- If `α` is countable, then so is `Multiset α`. -/\ntheorem ∀ {α : Type u_1} [inst : Countable α], Countable (Multiset α) :=\n\n/-- Finite product of finite sets is finite -/\ntheorem ∀ {δ : Type u_1} [inst : Finite δ] {κ : δ → Type u_2} {t : (d : δ) → Set (κ d)},\n  (∀ (d : δ), Set.Finite (t d)) → Set.Finite (Set.pi Set.univ t) :=\n\n/-- Distinct elements of a set of sets partitioning α are disjoint. -/\ntheorem ∀ {α : Type u_1} {c : Set (Set α)}, (∀ (a : α), ∃! b x, a ∈ b) → Set.PairwiseDisjoint c id :=\n\n/-- In a non-trivial integral domain, an element is regular iff it is non-zero. -/\ntheorem ∀ {R : Type u_1} [inst : CancelMonoidWithZero R] {a : R} [inst_1 : Nontrivial R], IsRegular a ↔ a ≠ 0 :=\n\n/-- Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty. -/\ntheorem",
    "choices": [
      "∀ {ι : Type u_1} {X : ι → Type u_2} [_inst : (i : ι) → Nonempty (X i)] [inst_1 : (i : ι) → TopologicalSpace (X i)]\n  [inst_2 : TopologicalSpace (Π (i : ι), X i)] [inst_3 : (i : ι) → T2Space (X i)] [inst_4 : T2Space (Π (i : ι), X i)]\n  (α : ι) (H : IsCompact (Set.Univ : Set (Π (i : ι), X i))), IsCompact (Set.Univ : Set (X α)) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)]\n  [inst_1 : (i : ι) → Nonempty (α i)] [inst_2 : TopologicalSpace (Π (i : ι), α i)]\n  [inst_3 : (∀ (i : ι), T2Space (α i))] [inst_4 : T2Space (Π (i : ι), α i)]\n  {i : ι}, (∀ (x : Π (i : ι), α i), IsRegular x) → IsRegular (α i) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)]\n  [inst_1 : (i : ι) → Nonempty (α i)] [inst_2 : TopologicalSpace (Π (i : ι), α i)] {x : Π (i : ι), α i},\n  IsRegular x → ∀ (i : ι), IsRegular (x i) ",
      "∀ {ι : Type u_1} {X : ι → Type u_2} [_inst : (i : ι) → TopologicalSpace (X i)] [_inst_2 : Fintype ι]\n  [_inst_3 : (i : ι) → Nonempty (X i)] {a : (i : ι) → X i},\n  IsRegular a → ∀ (i : ι), IsRegular (a i) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)] [inst_1 : (i : ι) → Nonempty (α i)]\n  [inst_2 : T2Space (Π (i : ι), α i)] [inst_3 : ∀ (i : ι), RegularSpace (α i)],\n  RegularSpace (Π (i : ι), α i) → ∀ (i : ι), RegularSpace (α i) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [Π (i : ι), TopologicalSpace (α i)] [Π (i : ι), Nonempty (α i)]\n[Π (i : ι), T2Space (α i)] [inst : Π (i : ι), RegularSpace (α i)], RegularSpace (Π (i : ι), α i) ",
      "∀ {ι : Type u} {X : ι → Type v} [inst : (i : ι) → TopologicalSpace (X i)] [inst_1 : ∀ (i : ι), Nonempty (X i)] [inst_2 : RegularSpace (Π (i : ι), X i)],\n  (i : ι) → RegularSpace (X i) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [_inst_1 : (i : ι) → TopologicalSpace (α i)] [_inst_2 : ∀ (i : ι), Nonempty (α i)]\n  {π : (i : ι) → Set (α i)}, IsCompact (Set.Pi Set.Univ π) → (∀ (i : ι), IsCompact (π i)) ",
      "∀ {ι : Type u_1} {X : ι → Type u_2} [_inst : Fintype ι] [H : ∀ i, Nonempty (X i)]\n  [_inst_1 : (i : ι) → TopologicalSpace (X i)] [_inst_2 : ∀ (i : ι), T2Space (X i)]\n  [inst : TopologicalSpace (Π (i : ι), X i)] [prod_inst : T2Space (Π (i : ι), X i)] [inst_3 : TopologicalSpace.RegularSpace (Π (i : ι), X i)],\n  ∀ (i : ι), TopologicalSpace.RegularSpace (X i) ",
      "∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → TopologicalSpace (α i)]\n  [inst_1 : (i : ι) → Nonempty (α i)] {f : (i : ι) → Set (α i)},\n  IsCompact (Set.Pi Set.univ f) → (∀ i : ι, IsCompact (f i)) "
    ]
  },
  {
    "docString": "Show that every locally compact Hausdorff space is regular.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, any measure constructed from a content is regular. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\\n  NormalSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The one point compactification of a locally compact Hausdorff space is a normal (hence,\\nHausdorff and regular) topological space. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\\ncompact. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\\n  [inst_3 : BorelSpace X] (μ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ],\\n  MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any locally finite measure on a `σ`-compact (e)metric space is regular. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space every point has a compact neighborhood. \"},\n {\"theorem\":\n  \"∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s}\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally compact Hausdorff totally disconnected space has a basis with clopen elements. \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space,\\nevery neighbourhood of every point contains a compact neighbourhood of that same point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact space, every compact set is contained in the interior of a compact set. \"}]\n",
    "prompt_cons": "/-- In a locally compact space, any measure constructed from a content is regular. -/\ntheorem ∀ {G : Type w} [inst : TopologicalSpace G] (μ : MeasureTheory.Content G) [inst_1 : T2Space G] [S : MeasurableSpace G]\n  [inst_2 : BorelSpace G] [inst_3 : LocallyCompactSpace G],\n  MeasureTheory.Measure.Regular (MeasureTheory.Content.measure μ) :=\n\n/-- The one point compactification of a locally compact Hausdorff space is a normal (hence,\nHausdorff and regular) topological space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  NormalSpace (OnePoint X) :=\n\n/-- If every points of a Hausdorff space admits a compact neighborhood, then this space is locally\ncompact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α],\n  (∀ (x : α), ∃ s, s ∈ nhds x ∧ IsCompact s) → LocallyCompactSpace α :=\n\n/-- Any locally finite measure on a `σ`-compact (e)metric space is regular. -/\ntheorem ∀ {X : Type u_1} [inst : EMetricSpace X] [inst_1 : SigmaCompactSpace X] [inst_2 : MeasurableSpace X]\n  [inst_3 : BorelSpace X] (μ : MeasureTheory.Measure X) [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ],\n  MeasureTheory.Measure.Regular μ :=\n\n/-- In a locally compact space every point has a compact neighborhood. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] (x : α), ∃ K, IsCompact K ∧ K ∈ nhds x :=\n\n/-- A locally compact Hausdorff totally disconnected space has a basis with clopen elements. -/\ntheorem ∀ {H : Type u_1} [inst : TopologicalSpace H] [inst_1 : LocallyCompactSpace H] [inst_2 : T2Space H]\n  [inst_3 : TotallyDisconnectedSpace H], TopologicalSpace.IsTopologicalBasis {s | IsClopen s} :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- In a locally compact space,\nevery neighbourhood of every point contains a compact neighbourhood of that same point. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [self : LocallyCompactSpace α] (x : α) (n : Set α),\n  n ∈ nhds x → ∃ s, s ∈ nhds x ∧ s ⊆ n ∧ IsCompact s :=\n\n/-- In a locally compact space, every compact set is contained in the interior of a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] {K : Set α},\n  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K' :=\n\n/-- Show that every locally compact Hausdorff space is regular. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "forall {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : LocallyCompactSpace X] [inst_2 : T2Space X],\n  RegularSpace X ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α],\n  RegularSpace α "
    ]
  },
  {
    "docString": "Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x})\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\\nfunctions f on X such that `f ≥ 1` on K. \"},\n {\"theorem\":\n  \"∀ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Set.EqOn (↑f) 0 s ∧ Set.EqOn (↑f) 1 t ∧ ∀ (x : M), ↑f x ∈ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff σ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded above on a compact set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be uniformly approximated by functions which are continuous on a set\\nis continuous on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\\n  Continuous f → HasCompactSupport f → BddBelow (Set.range f)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function with compact support is bounded below. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\\n  (∀ (x : α),\\n      x ∈ s →\\n        ∀ (u : Set (β × β)),\\n          u ∈ uniformity β →\\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousOn f s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous\\non a set is continuous on this set. \"},\n {\"theorem\": \"∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous function on compact Hausdorff spaces is a closed map. \"}]\n",
    "prompt_cons": "/-- For any compact subset `K ⊆ X`, there exist some bounded continuous nonnegative\nfunctions f on X such that `f ≥ 1` on K. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (Λ : BoundedContinuousFunction X NNReal →ₗ[NNReal] NNReal)\n  (K : TopologicalSpace.Compacts X), Set.Nonempty (↑Λ '' {f | ∀ (x : X), x ∈ K → 1 ≤ ↑f x}) :=\n\n/-- Given two disjoint closed sets in a Hausdorff σ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem ∀ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Set.EqOn (↑f) 0 s ∧ Set.EqOn (↑f) 1 t ∧ ∀ (x : M), ↑f x ∈ Set.Icc 0 1 :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A continuous function is bounded above on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddAbove (f '' K) :=\n\n/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)), u ∈ uniformity β → ∃ F, ContinuousOn F s ∧ ∀ (y : α), y ∈ s → (f y, F y) ∈ u) → ContinuousOn f s :=\n\n/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0 :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- A continuous function with compact support is bounded below. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Zero α] {f : β → α},\n  Continuous f → HasCompactSupport f → BddBelow (Set.range f) :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {s : Set α} [inst_1 : TopologicalSpace α],\n  (∀ (x : α),\n      x ∈ s →\n        ∀ (u : Set (β × β)),\n          u ∈ uniformity β →\n            ∃ t, t ∈ nhdsWithin x s ∧ ∃ F, ContinuousWithinAt F s x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousOn f s :=\n\n/-- Any continuous function on compact Hausdorff spaces is a closed map. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), IsClosedMap ↑f :=\n\n/-- Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B → ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ Continuous f ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] [inst_2 : CompactSeparated X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B →\n    ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompletelyRegularSpace α]\n  {A B : Set α}, IsClosed A → IsClosed B → Disjoint A B → IsCompact A →\n  ∃ f : α →ᵇ ℝ, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : α), ↑f x ∈ Set.Icc 0 1 ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompletelyRegularSpace α]\n  {A B : Set α},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B →\n  ∃ f : α → ℝ, Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ Continuous f ∧ ∀ (x : α), ↑f x ∈ Set.Icc 0 1 ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B →\n  ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ Continuous f ∧ Set.Ιcc 0 1 = Set.Range (↑f) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompletelyRegularSpace α]\n  {A B : Set α}, IsCompact A → IsClosed A → IsClosed B → Disjoint A B →\n    ∃ f, Continuous f ∧ Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ (x : α), ↑f x ∈ Set.Icc 0 1 ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : TotallyDisconnectedSpace X] (A B : Set X),\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B → ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] [inst_2 : FullyNormalSeparated X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B →\n    ∃ f : X → ℝ, Continuous f ∧ Set.EqOn f 0 A ∧ Set.EqOn f 1 B ∧ ∀ x, f x ∈ Set.Icc 0 1 ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X] [inst_2 : CompletelyRegularSpace X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B →\n    ∃ f, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T_3_space X] [inst_2 : RegularSpace X] {A B : Set X},\n  IsCompact A → IsClosed A → IsClosed B → Disjoint A B → ∃ f : X →ᵇ ℝ, Set.EqOn (↑f) 0 A ∧ Set.EqOn (↑f) 1 B ∧ ∀ (x : X), ↑f x ∈ Set.Icc 0 1 "
    ]
  },
  {
    "docString": "Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-Čech compactification of $X$ is connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any topological space `X`, its one point compactification is a compact space. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\\n  Finite (Quotient S.toSetoid)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is a compact space, then any discrete quotient of `X` is finite. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\\n  ConnectedSpace (OnePoint X)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `X` is not a compact space, then `OnePoint X` is a connected space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\\n  {n k ℓ μ : ℕ},\\n  SimpleGraph.IsSRGWith G n k ℓ μ → SimpleGraph.IsSRGWith Gᶜ n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complement of a strongly regular graph is strongly regular. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α\",\n  \"isProp\": true,\n  \"docString\": \"Finite topological spaces are compact. \"},\n {\"theorem\": \"∀ {X Y : Compactum} (f : X ⟶ Y), Continuous f.f\",\n  \"isProp\": true,\n  \"docString\": \"Any morphism of compacta is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a compact set and a closed set is a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The intersection of a closed set and a compact set is a compact set. \"}]\n",
    "prompt_cons": "/-- For any topological space `X`, its one point compactification is a compact space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X], CompactSpace (OnePoint X) :=\n\n/-- If `X` is a compact space, then any discrete quotient of `X` is finite. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] (S : DiscreteQuotient X) [inst_1 : CompactSpace X],\n  Finite (Quotient S.toSetoid) :=\n\n/-- If `X` is not a compact space, then `OnePoint X` is a connected space. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : NoncompactSpace X],\n  ConnectedSpace (OnePoint X) :=\n\n/-- A nonempty convex set is connected. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → Set.Nonempty s → IsConnected s :=\n\n/-- The complement of a strongly regular graph is strongly regular. -/\ntheorem ∀ {V : Type u} [inst : Fintype V] [inst_1 : DecidableEq V] {G : SimpleGraph V} [inst_2 : DecidableRel G.Adj]\n  {n k ℓ μ : ℕ},\n  SimpleGraph.IsSRGWith G n k ℓ μ → SimpleGraph.IsSRGWith Gᶜ n (n - k - 1) (n - (2 * k - μ) - 2) (n - (2 * k - ℓ)) :=\n\n/-- Finite topological spaces are compact. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Finite α], CompactSpace α :=\n\n/-- Any morphism of compacta is continuous. -/\ntheorem ∀ {X Y : Compactum} (f : X ⟶ Y), Continuous f.f :=\n\n/-- The intersection of a compact set and a closed set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact s → IsClosed t → IsCompact (s ∩ t) :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- The intersection of a closed set and a compact set is a compact set. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s t : Set α}, IsCompact t → IsClosed s → IsCompact (s ∩ t) :=\n\n/-- Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-Čech compactification of $X$ is connected. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : RegularSpace X],\n  ConnectedSpace X ↔ ConnectedSpace (StoneCech X) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : CompletelyRegular α] [inst_3 : PreconnectedSpace α],\n  PreconnectedSpace (StoneCech α) ↔ PreconnectedSpace α ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : PreconnectedSpace X] [inst_3 : CompletelyRegularSpace X],\n  ConnectedSpace (StoneCech X) ↔ PreconnectedSpace X ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X ↔ ConnectedSpace (StoneCech X) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X ↔ ConnectedSpace (StoneCech X) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : PreconnectedSpace X] [inst_3 : CompletelyRegularSpace X],\n  PreconnectedSpace (StoneCechCompactification X) ↔ PreconnectedSpace X ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : PreconnectedSpace X] [inst_3 : TotallyDisconnectedSpace X],\n  ConnectedSpace (StoneCech X) ↔ PreconnectedSpace X ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : PreconnectedSpace X] [inst_3 : CompletelyRegularSpace X],\n  ConnectedSpace (StoneCech X) ↔ ConnectedSpace X ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T2Space X] [inst_2 : CompletelyRegularSpace X],\n  ConnectedSpace X ↔ ConnectedSpace (StoneCechUnitCompactification X) ",
      "∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : PreconnectedSpace X] [inst_2 : CompletelyRegularSpace X],\n  PreconnectedSpace (StoneCechCompactification X) ↔ ConnectedSpace X "
    ]
  },
  {
    "docString": "Prove that $-(-v) = v$ for every $v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (v : E), ↑(reflection (Submodule.span 𝕜 {v})ᗮ) v = -v\",\n  \"isProp\": true,\n  \"docString\": \"The reflection in `(𝕜 ∙ v)ᗮ` of `v` is `-v`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n → α},\\n  Matrix.IsSymm (Matrix.circulant v) → ∀ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"If `circulant v` is symmetric, `∀ i j : I, v (- i) = v i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n → α},\\n  Matrix.IsSymm (Matrix.circulant v) ↔ ∀ (i : n), v (-i) = v i\",\n  \"isProp\": true,\n  \"docString\": \"A circulant of `v` is symmetric iff `v` equals its reverse. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\\n  I ≠ 0 →\\n    Associates.count (Associates.mk v.asIdeal)\\n        (Associates.factors\\n          (Associates.mk\\n            (∏ᶠ (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I))) =\\n      Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `v` in `∏_v v^(val_v(I))` equals `val_v(I)`. \"},\n {\"theorem\": \"∀ {x : ℝ}, Liouville x → Transcendental ℤ x\",\n  \"isProp\": true,\n  \"docString\": \"**Liouville's Theorem** \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {v₁ v₂ : RayVector R M}, -v₁ ≈ -v₂ ↔ v₁ ≈ v₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero vectors are equivalent, so are their negations. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R),\\n  ∃ π, IsDedekindDomain.HeightOneSpectrum.intValuationDef v π = ↑(↑Multiplicative.ofAdd (-1))\",\n  \"isProp\": true,\n  \"docString\":\n  \"There exists `π ∈ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. \"}]\n",
    "prompt_cons": "/-- The reflection in `(𝕜 ∙ v)ᗮ` of `v` is `-v`. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (v : E), ↑(reflection (Submodule.span 𝕜 {v})ᗮ) v = -v :=\n\n/-- If `circulant v` is symmetric, `∀ i j : I, v (- i) = v i`. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n → α},\n  Matrix.IsSymm (Matrix.circulant v) → ∀ (i : n), v (-i) = v i :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- Proof of right inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- A circulant of `v` is symmetric iff `v` equals its reverse. -/\ntheorem ∀ {α : Type u_2} {n : Type u_1} [inst : AddGroup n] {v : n → α},\n  Matrix.IsSymm (Matrix.circulant v) ↔ ∀ (i : n), v (-i) = v i :=\n\n/-- The multiplicity of `v` in `∏_v v^(val_v(I))` equals `val_v(I)`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\n  I ≠ 0 →\n    Associates.count (Associates.mk v.asIdeal)\n        (Associates.factors\n          (Associates.mk\n            (∏ᶠ (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I))) =\n      Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) :=\n\n/-- **Liouville's Theorem** -/\ntheorem ∀ {x : ℝ}, Liouville x → Transcendental ℤ x :=\n\n/-- If two nonzero vectors are equivalent, so are their negations. -/\ntheorem ∀ {R : Type u_1} [inst : StrictOrderedCommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {v₁ v₂ : RayVector R M}, -v₁ ≈ -v₂ ↔ v₁ ≈ v₂ :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U :=\n\n/-- There exists `π ∈ R` with `v`-adic valuation `Multiplicative.ofAdd (-1)`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R),\n  ∃ π, IsDedekindDomain.HeightOneSpectrum.intValuationDef v π = ↑(↑Multiplicative.ofAdd (-1)) :=\n\n/-- Prove that $-(-v) = v$ for every $v \\in V$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_2} {E : Type u_1} [inst : Field 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (v : E), -(-v) = v ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Ring 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (v : E), -(-v) = v ",
      "∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] (v : M), -(-v) = v ",
      "∀ {𝕜 : Type u_2} {E : Type u_1} [inst : Ring 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (v : E), -(-v) = v ",
      "∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (v : E), -(-v) = v ",
      "∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (v : E), -(-v) = v ",
      "∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddGroup M] [inst_2 : Module R M] (v : M), -(-v) = v ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (v : E), -(-v) = v ",
      "∀ {R : Type u_1} [inst : Ring R] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module R V]\n  (v : V), -(-v) = v ",
      "∀ {R : Type u_1} [inst : Ring R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M] (v : M),\n  -(-v) = v "
    ]
  },
  {
    "docString": "Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under addition. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V ⊆ U`.\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x - y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under subtraction \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x : R}, x ∈ s → -x ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under negation. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subsemiring is closed under addition. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\\n  x ≠ y →\\n    ∃ U₁,\\n      U₁ ∈ nhds x ∧\\n        ∃ V₁,\\n          V₁ ∈ nhds x ∧\\n            ∃ U₂,\\n              U₂ ∈ nhds y ∧\\n                ∃ V₂,\\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A non-unital subring is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K}, x ∈ s → x⁻¹ ∈ s\",\n  \"isProp\": true,\n  \"docString\": \"A subfield is closed under inverses. \"}]\n",
    "prompt_cons": "/-- A non-unital subring is closed under addition. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U :=\n\n/-- A non-unital subring is closed under subtraction -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x - y ∈ s :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- A non-unital subring is closed under negation. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x : R}, x ∈ s → -x ∈ s :=\n\n/-- A subsemiring is closed under addition. -/\ntheorem ∀ {R : Type u} [inst : NonAssocSemiring R] (s : Subsemiring R) {x y : R}, x ∈ s → y ∈ s → x + y ∈ s :=\n\n/-- Given two points `x ≠ y`, we can find neighbourhoods `x ∈ V₁ ⊆ U₁` and `y ∈ V₂ ⊆ U₂`,\nwith the `Vₖ` closed and the `Uₖ` open, such that the `Uₖ` are disjoint. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T3Space α] {x y : α},\n  x ≠ y →\n    ∃ U₁,\n      U₁ ∈ nhds x ∧\n        ∃ V₁,\n          V₁ ∈ nhds x ∧\n            ∃ U₂,\n              U₂ ∈ nhds y ∧\n                ∃ V₂,\n                  V₂ ∈ nhds y ∧ IsClosed V₁ ∧ IsClosed V₂ ∧ IsOpen U₁ ∧ IsOpen U₂ ∧ V₁ ⊆ U₁ ∧ V₂ ⊆ U₂ ∧ Disjoint U₁ U₂ :=\n\n/-- A non-unital subring is closed under multiplication. -/\ntheorem ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] (s : NonUnitalSubring R) {x y : R}, x ∈ s → y ∈ s → x * y ∈ s :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- A subfield is closed under inverses. -/\ntheorem ∀ {K : Type u} [inst : Field K] (s : Subfield K) {x : K}, x ∈ s → x⁻¹ ∈ s :=\n\n/-- Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$. -/\ntheorem",
    "choices": [
      "It is not possible to provide a theorem for this, as theorems in Lean Theorem Prover are about proving statements, not providing examples. However, I can describe an example in natural language for you:\n\nConsider the subset U of ℝ² consisting of all points with both coordinates integer (i.e., lattice points). This set is closed under addition because the sum of two integer coordinates is still an integer. It is also closed under taking additive inverses, as the additive inverse of an integer coordinate is still an integer. However, U is not a subspace of ℝ² because it is not closed under scalar multiplication. For example, if we multiply the point (1, 1) by the scalar 1/2, we get the point (1/2, 1/2), which is not in U, as its coordinates are not integers.",
      "This is not a theorem but an example. Here is an example of such a set:\n\nExample: Let U = {(x, y) ∈ ℝ^2 | x ≥ 0, y ≥ 0}. This set is closed under addition and taking additive inverses, but it is not a subspace of ℝ^2.\n\nProof:\n\n1. Closed under addition: If (x₁, y₁), (x₂, y₂) ∈ U, then x₁, x₂, y₁, y₂ ≥ 0. So (x₁ + x₂, y₁ + y₂) has non-negative coordinates and belongs to U.\n\n2. Closed under taking additive inverses: If (x, y) ∈ U, then (-x, -y) has non-negative coordinates, so (-x, -y) ∈ U.\n\n3. Not a subspace: The element (1, -1) does not belong to U since one of its coordinates is negative. However, (1, 0) and (0, -1) both belong to U. If U were a subspace, then their sum (1, -1) would also belong to U, which is a contradiction. So, U is not a subspace of ℝ^2.",
      "I am an AI language model and cannot provide real-world examples. However, I can help you understand a theoretical example.\n\nConsider a nonempty subset U of ℝ² defined as the union of the first quadrant and the third quadrant, i.e.,\n\nU = {(x, y) ∈ ℝ² | x ≥ 0 ∧ y ≥ 0} ∪ {(x, y) ∈ ℝ² | x ≤ 0 ∧ y ≤ 0}\n\nThis set U is closed under addition and taking additive inverses:\n\n1. If (x₁, y₁) and (x₂, y₂) are in the first quadrant, their sum (x₁ + x₂, y₁ + y₂) is also in the first quadrant.\n2. If (x₁, y₁) is in the first quadrant and (x₂, y₂) is in the third quadrant, their sum (x₁ + x₂, y₁ + y₂) is either in the first quadrant or the third quadrant.\n3. If (x₁, y₁) and (x₂, y₂) are in the third quadrant, their sum (x₁ + x₂, y₁ + y₂) is also in the third quadrant.\n4. If (x, y) is in the first quadrant, its additive inverse (-x, -y) is in the third quadrant, and vice versa.\n\nHowever, U is not a subspace of ℝ² because it does not include the origin (0, 0), which is a necessary condition for a subset to be a subspace.",
      "This is not a theorem that can be proven in Lean, but rather an example that can be described in plain language. One such example of a nonempty subset U of ℝ² that is closed under addition and taking additive inverses, but is not a subspace of ℝ², is the set of all lattice points (integer coordinates) in ℝ². This set is closed under addition and taking additive inverses, but it is not a subspace since it is not closed under scalar multiplication by non-integer scalars.",
      "I'm sorry, I cannot provide an example within a theorem statement. However, I can help you write a theorem about a nonempty subset with those properties. Please let me know if you'd like to proceed with that.",
      "I am an AI language model and cannot create specific examples. However, I can give you an example in natural language for a nonempty subset U of ℝ² that is closed under addition and taking additive inverses but is not a subspace of ℝ². You can consider the set U consisting of all points (x, y) in ℝ² such that either x = 0 or y = 0. This set is closed under addition and taking additive inverses, but it is not a subspace of ℝ² because it is not closed under scalar multiplication. For example, the point (1, 0) is in U, but (1/2)(1, 0) = (1/2, 0) is not in U.",
      "Sorry, I cannot provide an example within the scope of Lean Theorem Prover code. My purpose is to translate natural language statements to Lean Theorem Prover code. Please provide another statement for translation.",
      "I cannot provide an example as I am a coding assistant that translates natural language to Lean Theorem Prover code. Please provide a statement for a theorem or lemma you would like translated into Lean code.",
      "I cannot provide specific examples as I am an AI language model and my purpose is to translate given natural language into Lean Theorem Prover code. However, I can help you explain the concept or provide code for any given theorem or property. Please provide a theorem or property you would like me to translate into Lean code.",
      "This is not a theorem, but an example. Here is an example of such a set:\n\nExample: Let U "
    ]
  },
  {
    "docString": "Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\\n  (s : ι → Set (ℙ K V)),\\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a collection of subspaces is equal to the span of the union of the\\ncollection. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\\n  IsCompact s →\\n    ∀ (Z : ι → Set α),\\n      (∀ (i : ι), IsClosed (Z i)) →\\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that a compact set intersects the intersection of a family of closed sets,\\nit is sufficient to show that it intersects every finite subfamily. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two affine subspaces with the same direction and nonempty intersection are equal. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q\",\n  \"isProp\": true,\n  \"docString\": \"Affine subspaces are convex. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W\",\n  \"isProp\": true,\n  \"docString\": \"The span of a subspace is the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W\",\n  \"isProp\": true,\n  \"docString\":\n  \"The span of a set of points is contained in a subspace if and only if the set of points is\\ncontained in the subspace. \"},\n {\"theorem\":\n  \"∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s\",\n  \"isProp\": true,\n  \"docString\":\n  \"Coercing a subspace to a set then taking the affine span produces the original subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (s : Set (Submodule 𝕜 E)), ⨅ (K : Submodule 𝕜 E) (_ : K ∈ s), Kᗮ = (sSup s)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"}]\n",
    "prompt_cons": "/-- The supremum of a collection of subspaces is equal to the span of the union of the\ncollection. -/\ntheorem ∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Set (ℙ K V)),\n  Projectivization.Subspace.span (⋃ (i : ι), s i) = ⨆ (i : ι), Projectivization.Subspace.span (s i) :=\n\n/-- To show that a compact set intersects the intersection of a family of closed sets,\nit is sufficient to show that it intersects every finite subfamily. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α} {ι : Type v},\n  IsCompact s →\n    ∀ (Z : ι → Set α),\n      (∀ (i : ι), IsClosed (Z i)) →\n        (∀ (t : Finset ι), Set.Nonempty (s ∩ ⋂ (i : ι) (_ : i ∈ t), Z i)) → Set.Nonempty (s ∩ ⋂ (i : ι), Z i) :=\n\n/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s1 s2 : AffineSubspace k P},\n  AffineSubspace.direction s1 = AffineSubspace.direction s2 → Set.Nonempty (↑s1 ∩ ↑s2) → s1 = s2 :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- Affine subspaces are convex. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  (Q : AffineSubspace 𝕜 E), Convex 𝕜 ↑Q :=\n\n/-- The span of a subspace is the subspace. -/\ntheorem ∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (W : Projectivization.Subspace K V), Projectivization.Subspace.span ↑W = W :=\n\n/-- The span of a set of points is contained in a subspace if and only if the set of points is\ncontained in the subspace. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, Projectivization.Subspace.span S ≤ W ↔ S ⊆ ↑W :=\n\n/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\ntheorem ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s :=\n\n/-- The inf of a set of orthogonal subspaces equals the subspace orthogonal to the sup. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (s : Set (Submodule 𝕜 E)), ⨅ (K : Submodule 𝕜 E) (_ : K ∈ s), Kᗮ = (sSup s)ᗮ :=\n\n/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$. -/\ntheorem",
    "choices": [
      "∀ {K : Type u_3} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_1}\n  (s : ι → Projectivization.Subspace K V),\n  Projectivization.Subspace (⋂ (i : ι), ↑(s i)) ⊆ ⋂ (i : ι), s i ",
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (s : ι → Projectivization.Subspace K V),\n  ∃ (W : Projectivization.Subspace K V), ∀ (i : ι), W ≤ s i ",
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (s : ι → Projectivization.Subspace K V),\n  Projectivization.Subspace K V (⋂ (i : ι), s i) ",
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (s : ι → Projectivization.Subspace K V),\n  Projectivization.Subspace K V ",
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (s : ι → Projectivization.Subspace K V), IsSubspace (⋂ (i : ι), ↑(s i)) ",
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (S : ι → Projectivization.Subspace K V),\n  Projectivization.Subspace K V ",
      "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (s : ι → Projectivization.Subspace K V), Projectivization.Subspace K V (⋂ (i : ι), ↑(s i)) ",
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (s : ι → Projectivization.Subspace K V),\n  Projectivization.Subspace K V (⋂ (i : ι), ↑(s i)) ",
      "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Sort u_3}\n  (s : ι → Projectivization.Subspace K V),\n  IsSubspace K (⋂ (i : ι), ↑(s i)) ",
      "∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_3}\n  (s : ι → Projectivization.Subspace K V),\n  Projectivization.Subspace K V "
    ]
  },
  {
    "docString": "Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace 𝕜 V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\\n    fun p => p.fst • p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {M : Type v} {M₂ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M₂]\\n  [inst_3 : Module R M] [inst_4 : Module R M₂] {f : M → M₂}, IsLinearMap R f → ∀ (c : R) (x : M), f (c • x) = c • f x\",\n  \"isProp\": true,\n  \"docString\": \"A linear map preserves scalar multiplication. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f g : V →ₗ[K] V}, f * g = 1 → g * f = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional space, if linear maps are inverse to each other on one side then they\\nare also inverse to each other on the other side. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 • x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ↑f → Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, an injective linear map is surjective. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f g : V →ₗ[K] V}, f * g = 1 ↔ g * f = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\\nthey are inverse to each other on the other side. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ↑f ↔ Function.Surjective ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"On a finite-dimensional space, a linear map is injective if and only if it is surjective. \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace 𝕜 V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\n    fun p => p.fst • p.snd :=\n\n/-- A linear map preserves scalar multiplication. -/\ntheorem ∀ {R : Type u} {M : Type v} {M₂ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M₂]\n  [inst_3 : Module R M] [inst_4 : Module R M₂] {f : M → M₂}, IsLinearMap R f → ∀ (c : R) (x : M), f (c • x) = c • f x :=\n\n/-- In a finite-dimensional space, if linear maps are inverse to each other on one side then they\nare also inverse to each other on the other side. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V →ₗ[K] V}, f * g = 1 → g * f = 1 :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 • x = x :=\n\n/-- On a finite-dimensional space, an injective linear map is surjective. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ↑f → Function.Surjective ↑f :=\n\n/-- In a finite-dimensional space, linear maps are inverse to each other on one side if and only if\nthey are inverse to each other on the other side. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f g : V →ₗ[K] V}, f * g = 1 ↔ g * f = 1 :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F) :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem ∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- On a finite-dimensional space, a linear map is injective if and only if it is surjective. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] {f : V →ₗ[K] V}, Function.Injective ↑f ↔ Function.Surjective ↑f :=\n\n/-- Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], FiniteDimensional.finrank K V = 1 → ∀ (f : V →ₗ[K] V), ∃ a, ∀ v, f v = a • v ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V] (h_dim : Module.rank 𝕜 V = 1) (T : V →ₗ[𝕜] V),\n  ∃ a, ∀ (v : V), T v = a • v ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], FiniteDimensional.finrank K V = 1 → ∀ (f : V →ₗ[K] V), ∃ a, ∀ v, f v = a • v ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (h : Module.rank K V = 1) {T : V →ₗ[K] V},\n  ∃ a : K, ∀ v : V, T v = a • v ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], FiniteDimensional.finrank K V = 1 → ∀ (f : V →ₗ[K] V), ∃ a : K, ∀ (v : V), f v = a • v ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V], FiniteDimensional.finrank K V = 1 → ∀ (T : V →ₗ[K] V), ∃ a : K, ∀ v : V, T v = a • v ",
      "∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  [inst_3 : FiniteDimensional 𝕜 V], FiniteDimensional.finrank 𝕜 V = 1 → ∀ (f : V →ₗ[𝕜] V), ∃ a, ∀ v, f v = a • v ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (h_dim : Module.rank K V = 1) (T : V →ₗ[K] V), ∃ a, ∀ v, T v = a • v ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (h : FiniteDimensional.finrank K V = 1) {T : V →ₗ[K] V}, ∃ a, ∀ (v : V), T v = a • v ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] [inst_4 : Module.rank K V = 1] {f : V →ₗ[K] V}, ∃ a, ∀ (v : V), f v = a • v "
    ]
  },
  {
    "docString": "Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common.",
    "prompts": "[{\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\\n    Finset.card\\n        (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p)) \\\\ Multiset.toFinset (Polynomial.roots p)) +\\n      1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial `p` is at most the number of roots of its derivative\\nthat are not roots of `p` plus one. \"},\n {\"theorem\":\n  \"∀ {K : Type v} [inst : Field K] {p : Polynomial K},\\n  Polynomial.Splits (RingHom.id K) p ↔ ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial splits if and only if it has as many roots as its degree. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℕ), padicNorm p ↑m = 1 ↔ ¬p ∣ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\\nand of `μ ^ p` are the same. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℤ), padicNorm p ↑m = 1 ↔ ¬↑p ∣ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ℝ] (p : Polynomial F),\\n  Fintype.card ↑(Polynomial.rootSet p ℝ) ≤ Fintype.card ↑(Polynomial.rootSet (↑Polynomial.derivative p) ℝ) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of real roots of a polynomial is at most the number of roots of its derivative plus\\none. \"},\n {\"theorem\":\n  \"∀ (p : Polynomial ℝ),\\n  ↑Multiset.card (Polynomial.roots p) ≤ ↑Multiset.card (Polynomial.roots (↑Polynomial.derivative p)) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of roots of a real polynomial (counted with multiplicities) is at most the number of\\nroots of its derivative (counted with multiplicities) plus one. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : ℕ},\\n      Nat.coprime m n → Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : ℕ` is coprime with `n`,\\nthen the minimal polynomial of a primitive `n`-th root of unity `μ`\\nhas `μ ^ m` as root. \"}]\n",
    "prompt_cons": "/-- The number of roots of a real polynomial `p` is at most the number of roots of its derivative\nthat are not roots of `p` plus one. -/\ntheorem ∀ (p : Polynomial ℝ),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\n    Finset.card\n        (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p)) \\ Multiset.toFinset (Polynomial.roots p)) +\n      1 :=\n\n/-- A polynomial splits if and only if it has as many roots as its degree. -/\ntheorem ∀ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p ↔ ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p :=\n\n/-- The `p`-adic norm of a natural `m` is one iff `p` doesn't divide `m`. -/\ntheorem ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℕ), padicNorm p ↑m = 1 ↔ ¬p ∣ m :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ p` are the same. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p) :=\n\n/-- The number of roots of a real polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ∀ (p : Polynomial ℝ),\n  Finset.card (Multiset.toFinset (Polynomial.roots p)) ≤\n    Finset.card (Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) + 1 :=\n\n/-- The `p`-adic norm of an integer `m` is one iff `p` doesn't divide `m`. -/\ntheorem ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℤ), padicNorm p ↑m = 1 ↔ ¬↑p ∣ m :=\n\n/-- The number of real roots of a polynomial is at most the number of roots of its derivative plus\none. -/\ntheorem ∀ {F : Type u_1} [inst : CommRing F] [inst_1 : Algebra F ℝ] (p : Polynomial F),\n  Fintype.card ↑(Polynomial.rootSet p ℝ) ≤ Fintype.card ↑(Polynomial.rootSet (↑Polynomial.derivative p) ℝ) + 1 :=\n\n/-- The number of roots of a real polynomial (counted with multiplicities) is at most the number of\nroots of its derivative (counted with multiplicities) plus one. -/\ntheorem ∀ (p : Polynomial ℝ),\n  ↑Multiset.card (Polynomial.roots p) ≤ ↑Multiset.card (Polynomial.roots (↑Polynomial.derivative p)) + 1 :=\n\n/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [inst_3 : Fact (Nat.Prime p)],\n      ¬p ∣ n → Polynomial.Separable (Polynomial.map (Int.castRingHom (ZMod p)) (minpoly ℤ μ)) :=\n\n/-- If `m : ℕ` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `μ`\nhas `μ ^ m` as root. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : ℕ},\n      Nat.coprime m n → Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) :=\n\n/-- Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : Field F] (p : Polynomial F),\n  Polynomial.natDegree p = Fintype.card (↥(Polynomial.rootSet p F)) ↔\n    Polynomial.Disjoint (Polynomial.rootSet p F) (Polynomial.rootSet (Polynomial.derivative p) F) ",
      "∀ {F : Type u_1} [inst : Field F] [inst_1 : Algebra F ℂ] (p : Polynomial F),\n  Polynomial.degree p = ↑(Polynomial.natDegree p) →\n    (Polynomial.Separable p ↔ ∀ x, multiplicity (Polynomial.eval x p) (Polynomial.roots p) ≤ 1) ",
      "∀ {F : Type u_1} [inst : Field F] (p : Polynomial F),\n  Polynomial.natDegree p = Fintype.card ↑(Polynomial.rootSet p F) ↔\n    Fintype.card ↑(Polynomial.rootSet (p * Polynomial.derivative p) F) = 0 ",
      "∀ {K : Type v} [inst : Field K] {p : Polynomial K},\n  Polynomial.Splits (RingHom.id K) p ∧ (↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p) ↔\n    Polynomial.roots p ∩ Polynomial.roots (↑Polynomial.derivative p) = ∅ ",
      "∀ {F : Type u_1} [inst : Field F] (p : Polynomial F),\n  Polynomial.natDegree p = Fintype.card (↥(Polynomial.rootSet p F)) ↔\n    (∀ x : F, Polynomial.IsRoot p x → ¬Polynomial.IsRoot (Polynomial.derivative p) x) ",
      "∀ {F : Type u_1} [inst : Field F] [inst_1 : Algebra F ℂ] (p : Polynomial F),\n  Polynomial.natDegree p = Fintype.card ↑(Polynomial.rootSet p ℂ) ↔\n    Fintype.card ↑(Polynomial.rootSet p ℂ ∩ Polynomial.rootSet (↑Polynomial.derivative p) ℂ) = 0 ",
      "∀ {F : Type u_1} [inst : Field F] (p : Polynomial F),\n  Polynomial.natDegree p = Multiset.card (Polynomial.roots p) ↔\n    Multiset.disjoint (Polynomial.roots p) (Polynomial.roots (↑Polynomial.derivative p)) ",
      "∀ {F : Type u_1} [inst : Field F] (p : Polynomial F),\n  (Polynomial.degree p = coe (Polynomial.natDegree p)) →\n    (Polynomial.Separable p ↔\n      Finset.card\n          (Multiset.toFinset (Polynomial.roots p) ∩ Multiset.toFinset (Polynomial.roots (↑Polynomial.derivative p))) =\n        0) ",
      "∀ {F : Type u_1} [inst : Field F] {p : Polynomial F},\r\n  Polynomial.Separable p ↔\r\n    Polynomial.natDegree p = Fintype.card ↑(Polynomial.rootSet p F) ",
      "∀ {F : Type u_1} [inst : Field F] (p : Polynomial F),\n  Polynomial.degree p = ↑(Polynomial.natDegree p) →\n    ((∀ (x : F), Polynomial.eval x p = 0 ↔ Polynomial.eval x (Polynomial.derivative p) = 0) ↔\n      (Multiset.Nodup (Polynomial.roots p)) ∧ ↑Multiset.card (Polynomial.roots p) = Polynomial.natDegree p) "
    ]
  },
  {
    "docString": "Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} {X : Type u_2} [inst : IsROrC 𝕜] [inst_1 : TopologicalSpace X] {S : Set C(X, 𝕜)},\\n  (∀ (f : C(X, 𝕜)), f ∈ S → ↑(AlgHom.compLeftContinuous ℝ ↑IsROrC.conjAe (_ : Continuous ↑IsROrC.conjCle)) f ∈ S) →\\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars ℝ (Algebra.adjoin 𝕜 S))\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set `S` is conjugation-invariant, then its `𝕜`-span is conjugation-invariant. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {ι : Type u_2} (ι' : Finset ι) (s l : ι → S),\\n  (Finset.sum ι' fun i => l i * s i) = 1 →\\n    (∀ (i : ι), s i ∈ S') → (∀ (i : ι), l i ∈ S') → ∀ (x : S), (∀ (i : ι), ∃ n, s i ^ n • x ∈ S') → x ∈ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sᵢ ^ n • x ∈ S'` for some `n` for each `sᵢ`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsMulRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsAddLeftInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is left invariant under addition. \"},\n {\"theorem\": \"RingHom.LocalizationPreserves @RingHom.Finite\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\\n    ∀ (f : V'' →ₗ[R] V),\\n      Function.Injective ↑f →\\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\\n * the function `f' : V'' → V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x ∈ Submodule.span R' s → ∃ t, t • x ∈ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\\nthen `t • x ∈ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h + g) ⁻¹' A) = ↑↑μ A) ↔\\n    MeasureTheory.Measure.IsAddRightInvariant μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"An alternative way to prove that `μ` is right invariant under addition. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} (f : α → G),\\n  MeasureTheory.Integrable f →\\n    ∀ {F : ι → α → G} {l : Filter ι},\\n      (∀ᶠ (i : ι) in l, MeasureTheory.Integrable (F i)) →\\n        Filter.Tendsto (fun i => ∫⁻ (x : α), ↑‖F i x - f x‖₊ ∂μ) l (nhds 0) →\\n          Filter.Tendsto (fun i => ∫ (x : α), F i x ∂μ) l (nhds (∫ (x : α), f x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"If `F i → f` in `L1`, then `∫ x, F i x ∂μ → ∫ x, f x ∂μ`. \"}]\n",
    "prompt_cons": "/-- If a set `S` is conjugation-invariant, then its `𝕜`-span is conjugation-invariant. -/\ntheorem ∀ {𝕜 : Type u_1} {X : Type u_2} [inst : IsROrC 𝕜] [inst_1 : TopologicalSpace X] {S : Set C(X, 𝕜)},\n  (∀ (f : C(X, 𝕜)), f ∈ S → ↑(AlgHom.compLeftContinuous ℝ ↑IsROrC.conjAe (_ : Continuous ↑IsROrC.conjCle)) f ∈ S) →\n    ContinuousMap.ConjInvariantSubalgebra (Subalgebra.restrictScalars ℝ (Algebra.adjoin 𝕜 S)) :=\n\n/-- An alternative way to prove that `μ` is left invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g * h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulLeftInvariant μ :=\n\n/-- Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\n`sᵢ ^ n • x ∈ S'` for some `n` for each `sᵢ`. -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {ι : Type u_2} (ι' : Finset ι) (s l : ι → S),\n  (Finset.sum ι' fun i => l i * s i) = 1 →\n    (∀ (i : ι), s i ∈ S') → (∀ (i : ι), l i ∈ S') → ∀ (x : S), (∀ (i : ι), ∃ n, s i ^ n • x ∈ S') → x ∈ S' :=\n\n/-- An alternative way to prove that `μ` is right invariant under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Mul G] [inst_2 : MeasurableMul G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h * g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsMulRightInvariant μ :=\n\n/-- An alternative way to prove that `μ` is left invariant under addition. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => g + h) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsAddLeftInvariant μ :=\n\n/-- If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. -/\ntheorem RingHom.LocalizationPreserves @RingHom.Finite :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\n * the function `f' : V'' → V'` doesn't need to be injective -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\n    ∀ (f : V'' →ₗ[R] V),\n      Function.Injective ↑f →\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b) :=\n\n/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\nthen `t • x ∈ span R s` for some `t : M`. -/\ntheorem ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x ∈ Submodule.span R' s → ∃ t, t • x ∈ Submodule.span R s :=\n\n/-- An alternative way to prove that `μ` is right invariant under addition. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Add G] [inst_2 : MeasurableAdd G] (μ : MeasureTheory.Measure G),\n  (∀ (g : G) (A : Set G), MeasurableSet A → ↑↑μ ((fun h => h + g) ⁻¹' A) = ↑↑μ A) ↔\n    MeasureTheory.Measure.IsAddRightInvariant μ :=\n\n/-- If `F i → f` in `L1`, then `∫ x, F i x ∂μ → ∫ x, f x ∂μ`. -/\ntheorem ∀ {α : Type u_3} {G : Type u_2} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} (f : α → G),\n  MeasureTheory.Integrable f →\n    ∀ {F : ι → α → G} {l : Filter ι},\n      (∀ᶠ (i : ι) in l, MeasureTheory.Integrable (F i)) →\n        Filter.Tendsto (fun i => ∫⁻ (x : α), ↑‖F i x - f x‖₊ ∂μ) l (nhds 0) →\n          Filter.Tendsto (fun i => ∫ (x : α), F i x ∂μ) l (nhds (∫ (x : α), f x ∂μ)) :=\n\n/-- Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : LinearMap F V),\n  S.comp T = T.comp S →\n    ∀ (λ : F), LinearMap.SubmoduleInvariant F S (LinearMap.ker (LinearMap.sub T (LinearMap.smulRight LinearMap.id λ))) ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  (S T : LinearMap 𝕜 V), LinearMap.commute S T →\n    ∀ (λ : 𝕜), Submodule.map S (LinearMap.nullSpace (T - λ • LinearMap.id)) ≤\n      LinearMap.nullSpace (T - λ • LinearMap.id) ",
      "∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] (S T : LinearMap 𝕜 V),\n  LinearMap.comp S T = LinearMap.comp T S →\n    ∀ (λ : 𝕜), Submodule.Compatible (Submodule.comap T (Submodule.map (LinearMap.id - λ • LinearMap.id) ⊤)) S ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : LinearMap 𝕜 V V},\n  (S.comp T = T.comp S) →\n    ∀ (λ : 𝕜), LinearMap.IsInvariantSubspace S (LinearMap.nullSpace (LinearMap.sub T (coeFn (LinearMap.id 𝕜 V) λ))) ",
      "∀ {F : Type u_1} [inst : Field F] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : End F V),\n  S.comp T = T.comp S →\n    ∀ (λ : F), Submodule.IsInvariant (End F V) (LinearMap.ker (LinearMap.sub T (λ • LinearMap.id))) S ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] (S T : LinearMap 𝕜 V),\n  LinearMap.commute S T → ∀ (λ : 𝕜), LinearMap.IsInvariantSubmodule S (LinearMap.nullSpace (T - λ • LinearMap.id)) ",
      "∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {S T : End 𝕜 V},\n  S.comp T = T.comp S → ∀ (λ : 𝕜), Submodule.map S (End.nullSpace (T - algebraMap 𝕜 (End 𝕜 V) λ)) = End.nullSpace (T - algebraMap 𝕜 (End 𝕜 V) λ) ",
      "∀ {K : Type u_1} {V : Type u_2} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : LinearMap K V V),\n  LinearMap.commute S T → ∀ (λ : K), Submodule.map S (LinearMap.ker (T - LinearMap.smulRight LinearMap.id λ)) ≤\n                               LinearMap.ker (T - LinearMap.smulRight LinearMap.id λ) ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] (S T : LinearMap 𝕜 V),\n  LinearMap.comp S T = LinearMap.comp T S →\n    ∀ (λ : 𝕜), Submodule.map S (LinearMap.nullSpace (LinearMap.sub T (coeFn (LinearMap.id 𝕜 V) λ))) ≤\n      LinearMap.nullSpace (LinearMap.sub T (coeFn (LinearMap.id 𝕜 V) λ)) ",
      "∀ {F : Type u} [inst : Field F] {V : Type u_1} [inst_1 : AddCommGroup V] [inst_2 : Module F V] (S T : End F V),\n  S * T = T * S → ∀ (λ : F), Submodule.IsInvariant (End.nullSpace (T - λ • 1)) S "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\\n  [inst_2 : NormedSpace 𝕜 V],\\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\\n    fun p => p.fst • p.snd\",\n  \"isProp\": true,\n  \"docString\":\n  \"On any vector space, multiplication by a scalar is a smooth operation. \"},\n {\"theorem\":\n  \"∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two nonzero vectors go to the same point in projective space if and only if one is\\na scalar multiple of the other. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x : F) (r : ℝ),\\n  inner x (r • x) = r * (‖x‖ * ‖x‖)\",\n  \"isProp\": true,\n  \"docString\": \"The inner product of a vector with a multiple of itself. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  {Q : QuadraticForm R M} (a b : M),\\n  ↑(CliffordAlgebra.ι Q) a * ↑(CliffordAlgebra.ι Q) b + ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\\n    ↑(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (↑Q) a b)\",\n  \"isProp\": true,\n  \"docString\": \"The symmetric product of vectors is a scalar \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\\n  ⨆ (μ : K) (k : ℕ), ↑(Module.End.generalizedEigenspace f μ) k = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\\n  (∀ (r : R),\\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the even parts, it suffices to show it is true on the\\nscalars, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every linear operator on a vector space over an algebraically closed field has\\nan eigenvalue. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\\n  1 • x = x\",\n  \"isProp\": true,\n  \"docString\": \"Scalar multiplication by one is the identity. \"}]\n",
    "prompt_cons": "/-- On any vector space, multiplication by a scalar is a smooth operation. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V]\n  [inst_2 : NormedSpace 𝕜 V],\n  Smooth (ModelWithCorners.prod (modelWithCornersSelf 𝕜 𝕜) (modelWithCornersSelf 𝕜 V)) (modelWithCornersSelf 𝕜 V)\n    fun p => p.fst • p.snd :=\n\n/-- Two nonzero vectors go to the same point in projective space if and only if one is\na scalar multiple of the other. -/\ntheorem ∀ (K : Type u_2) {V : Type u_1} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (v w : V)\n  (hv : v ≠ 0) (hw : w ≠ 0), Projectivization.mk K v hv = Projectivization.mk K w hw ↔ ∃ a, a • w = v :=\n\n/-- The inner product of a vector with a multiple of itself. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x : F) (r : ℝ),\n  inner x (r • x) = r * (‖x‖ * ‖x‖) :=\n\n/-- The symmetric product of vectors is a scalar -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  {Q : QuadraticForm R M} (a b : M),\n  ↑(CliffordAlgebra.ι Q) a * ↑(CliffordAlgebra.ι Q) b + ↑(CliffordAlgebra.ι Q) b * ↑(CliffordAlgebra.ι Q) a =\n    ↑(algebraMap R (CliffordAlgebra Q)) (QuadraticForm.polar (↑Q) a b) :=\n\n/-- The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\n  ⨆ (μ : K) (k : ℕ), ↑(Module.End.generalizedEigenspace f μ) k = ⊤ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- To show a property is true on the even parts, it suffices to show it is true on the\nscalars, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 0 → Prop},\n  (∀ (r : R),\n      P (↑(algebraMap R (CliffordAlgebra Q)) r)\n        (_ : ↑(algebraMap R (CliffordAlgebra Q)) r ∈ CliffordAlgebra.evenOdd Q 0)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0} {hy : y ∈ CliffordAlgebra.evenOdd Q 0},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 0)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 0},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 0)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 0), P x hx :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- Every linear operator on a vector space over an algebraically closed field has\nan eigenvalue. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] [inst_5 : Nontrivial V] (f : Module.End K V), ∃ c, Module.End.HasEigenvalue f c :=\n\n/-- Scalar multiplication by one is the identity. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommGroup M] (self : Module.Core R M) (x : M),\n  1 • x = x :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator. -/\ntheorem",
    "choices": [
      "∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : FiniteDimensional K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ (c : K), Module.End.HasEigenvalue T c ∧ Module.End.eigenspace T c = ⊤) → ∃ (a : K), T = a • LinearMap.id ",
      "∀ {K : Type u_1} [inst : DivisionRing K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : V →ₗ[K] V),\n  (∀ (v : V), v ≠ 0 → ∃ (c : K), T v = c • v) → ∃ (c : K), T = c • LinearMap.id ",
      "∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : Module.End K V) (h_eigenvectors : ∀ (v : V), v ≠ 0 → ∃ μ, Module.End.HasEigenvector T μ v),\n  ∃ (c : K), T = c • LinearMap.id ",
      "∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  (∀ (v : V), ∃ (c : K), Module.End.HasEigenvector f c v) → (∃ (c : K), f = c • Module.End.id K V) ",
      "∀ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : Module.End K V) (h_eigvec : ∀ v : V, ∃ c : K, T v = c • v),\n  ∃ c : K, ∀ v : V, T v = c • v ",
      "∀ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (h_eigen : ∀ v : V, v ≠ 0 → ∃ c, T v = c • v),\n  ∃ c, ∀ v : V, T v = c • v ",
      "∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V)\n  (h_eigenvector : ∀ v : V, v ≠ 0 → ∃ μ : K, Module.End.HasEigenvector T (μ, v)),\n  ∃ c : K, T = c • LinearMap.id ",
      "∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (T : Module.End K V),\n  (∀ (v : V), v ≠ 0 → ∃ (c : K), Module.End.HasEigenvector T c v) → ∃ (c : K), T = c • linear_map.id ",
      "∀ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  (T : Module.End K V) (h : ∀ (v : V), ∃ a, Module.End.HasEigenvector T a v),\n  ∃ (c : K), T = c • LinearMap.id ",
      "∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  (∀ (x : V), x ≠ 0 → ∃ (c : K), x = c • f x) → ∃ (c : K), f = c • linear_map.id "
    ]
  },
  {
    "docString": "Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  (v : E) (μ : Module.End.Eigenvalues T),\\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two linearly equivalent vector spaces have the same dimension. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\\n  CompleteLattice.Independent (Module.End.eigenspace f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\\nany eigenspace has trivial intersection with the span of all the other eigenspaces. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\": \"RingHom.LocalizationPreserves @RingHom.Finite\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. \"},\n {\"theorem\":\n  \"∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x ∈ Submodule.span R' s → ∃ t, t • x ∈ Submodule.span R s\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\\nthen `t • x ∈ span R s` for some `t : M`.\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\\n  {ι : Type u_2} (ι' : Finset ι) (s l : ι → S),\\n  (Finset.sum ι' fun i => l i * s i) = 1 →\\n    (∀ (i : ι), s i ∈ S') → (∀ (i : ι), l i ∈ S') → ∀ (x : S), (∀ (i : ι), ∃ n, s i ^ n • x ∈ S') → x ∈ S'\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\\n`sᵢ ^ n • x ∈ S'` for some `n` for each `sᵢ`. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\\n  ⨆ (μ : K) (k : ℕ), ↑(Module.End.generalizedEigenspace f μ) k = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). \"}]\n",
    "prompt_cons": "/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  (v : E) (μ : Module.End.Eigenvalues T),\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ :=\n\n/-- Two linearly equivalent vector spaces have the same dimension. -/\ntheorem ∀ {R : Type u} [inst : Ring R] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {M₁ : Type v}\n  [inst_3 : AddCommGroup M₁] [inst_4 : Module R M₁], (M ≃ₗ[R] M₁) → Module.rank R M = Module.rank R M₁ :=\n\n/-- The eigenspaces of a linear operator form an independent family of subspaces of `V`.  That is,\nany eigenspace has trivial intersection with the span of all the other eigenspaces. -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (f : Module.End K V),\n  CompleteLattice.Independent (Module.End.eigenspace f) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ) :=\n\n/-- If `S` is a finite `R`-algebra, then `S' = M⁻¹S` is a finite `R' = M⁻¹R`-algebra. -/\ntheorem RingHom.LocalizationPreserves @RingHom.Finite :=\n\n/-- If `S` is an `R' = M⁻¹R` algebra, and `x ∈ span R' s`,\nthen `t • x ∈ span R s` for some `t : M`. -/\ntheorem ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (M : Submonoid R) (R' : Type u) [inst_2 : CommRing R']\n  [inst_3 : Algebra R R'] [inst_4 : Algebra R' S] [inst_5 : Algebra R S] [inst_6 : IsScalarTower R R' S]\n  [inst_7 : IsLocalization M R'] (s : Set S) (x : S), x ∈ Submodule.span R' s → ∃ t, t • x ∈ Submodule.span R s :=\n\n/-- Suppose we are given `∑ i, lᵢ * sᵢ = 1` in `S`, and `S'` a subalgebra of `S` that contains\n`lᵢ` and `sᵢ`. To check that an `x : S` falls in `S'`, we only need to show that\n`sᵢ ^ n • x ∈ S'` for some `n` for each `sᵢ`. -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {S : Type u_1} [inst_1 : CommRing S] [inst_2 : Algebra R S] (S' : Subalgebra R S)\n  {ι : Type u_2} (ι' : Finset ι) (s l : ι → S),\n  (Finset.sum ι' fun i => l i * s i) = 1 →\n    (∀ (i : ι), s i ∈ S') → (∀ (i : ι), l i ∈ S') → ∀ (x : S), (∀ (i : ι), ∃ n, s i ^ n • x ∈ S') → x ∈ S' :=\n\n/-- The generalized eigenvectors span the entire vector space (Lemma 8.21 of [axler2015]). -/\ntheorem ∀ {K : Type v} {V : Type w} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] [inst_3 : IsAlgClosed K]\n  [inst_4 : FiniteDimensional K V] (f : Module.End K V),\n  ⨆ (μ : K) (k : ℕ), ↑(Module.End.generalizedEigenspace f μ) k = ⊤ :=\n\n/-- Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} [inst : Field 𝕜] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E] [inst_3 : FiniteDimensional 𝕜 E]\n  {T S : Module.End 𝕜 E},\n  (FiniteDimensional.finrank 𝕜 E = Module.End.eigenvalues T.card) →\n  (∀ (v : E) (μ : 𝕜), v ∈ Module.End.eigenspace T μ → v ∈ Module.End.eigenspace S μ) →\n  T * S = S * T ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] [inst_3 : FiniteDimensional 𝕜 E]\n  {T S : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) (hS : LinearMap.IsSymmetric S)\n  (h_eigenvalues : FiniteDimensional.finrank 𝕜 E = Fintype.card (Module.End.Eigenvalues T))\n  (h_eigenvectors : ∀ (μ : 𝕜), Module.End.eigenspace T μ = Module.End.eigenspace S μ),\n  T.comp S = S.comp T ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E] {T : E →ₗ[𝕜] E} {S : E →ₗ[𝕜] E}\n  (hT : LinearMap.eigenvectors T = LinearMap.eigenvectors S), T.comp S = S.comp T ",
      "∀ {𝕜 : Type u_1} [inst : Field 𝕜] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E] [inst_3 : FiniteDimensional 𝕜 E]\n  {T S : E →ₗ[𝕜] E},\n  (∀ μ : 𝕜, Module.End.eigenspace T μ = Module.End.eigenspace S μ) →\n  (LinearMap.IsDiagonalizable T ↔ LinearMap.IsDiagonalizable S) →\n  T.comp S = S.comp T ",
      "∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : FiniteDimensional 𝕜 V]\n  {T S : V →ₗ[𝕜] V},\n  (LinearMap.eigenspaces T).card = FiniteDimensional.finrank 𝕜 V →\n    (∀ (v : V) (μ : 𝕜), v ∈ Module.End.eigenspace T μ → v ∈ Module.End.eigenspace S μ) → T * S = S * T ",
      "∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : FiniteDimensional 𝕜 V]\n  {T S : Module.End 𝕜 V},\n  (FiniteDimensional.finrank 𝕜 V = (Module.End.eigenvalues T).toFinset.card) →\n  (∀ (μ : 𝕜) (v : V), Module.End.hasEigenvector T μ v ↔ Module.End.hasEigenvector S μ v) → T.comp S = S.comp T ",
      "∀ {𝕜 : Type u_1} [inst : Field 𝕜] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : FiniteDimensional 𝕜 V]\n  (T S : Module.End 𝕜 V) (h_dim : FiniteDimensional.finrank 𝕜 V = Module.End.eigenvalues T.to_linear_map.card)\n  (h_eigvec : ∀ (μ : 𝕜) (x : V), x ∈ Module.End.eigenspace T μ → x ∈ Module.End.eigenspace S μ),\n  T * S = S * T ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T S : E →ₗ[𝕜] E} [inst_3 : FiniteDimensional 𝕜 E]\n  (hT : ∀ (μ : 𝕜), LinearMap.ker (T - algebraMap 𝕜 (Module.End 𝕜 E) μ) = ⊥ →\n               LinearMap.ker ((T - algebraMap 𝕜 (Module.End 𝕜 E) μ) ^ FiniteDimensional.finrank 𝕜 E) = ⊥)\n  (hST : ∀ (μ : 𝕜) (v : E), v ∈ LinearMap.ker (T - algebraMap 𝕜 (Module.End 𝕜 E) μ) → v ∈ LinearMap.ker (S - algebraMap 𝕜 (Module.End 𝕜 E) μ)),\n  T.comp S = S.comp T ",
      "∀ {𝕜 : Type u_1} [inst : Field 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : AddCommGroup E]\n  [inst_2 : Module 𝕜 E] {T S : E →ₗ[𝕜] E} [inst_3 : FiniteDimensional 𝕜 E] {n : ℕ}\n  (hn : FiniteDimensional.finrank 𝕜 E = n) (hT : LinearMap.nDistinctEigvals T hn) (hST : LinearMap.sameEigenvectors T S),\n  S.comp T = T.comp S ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T S : E →ₗ[𝕜] E} [inst_3 : FiniteDimensional 𝕜 E]\n  (hT : FiniteDimensional.finrank 𝕜 E = FiniteDimensional.finrank 𝕜 (Module.End.eigenspace T).range)\n  (hST : ∀ (μ : 𝕜) (v : E), v ∈ Module.End.eigenspace T μ → ∃ (c : 𝕜), v ∈ Module.End.eigenspace S c),\n  T * S = S * T "
    ]
  },
  {
    "docString": "Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\\n  MeasurableSet u →\\n    MeasurableSet v →\\n      MeasurableSet w →\\n        MeasureTheory.VectorMeasure.restrict s u ≤ MeasureTheory.VectorMeasure.restrict 0 u →\\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\\n  MeasurableSet u →\\n    MeasurableSet v →\\n      MeasurableSet w →\\n        MeasureTheory.VectorMeasure.restrict 0 u ≤ MeasureTheory.VectorMeasure.restrict s u →\\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 ↔ U ⟂ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (v : E), ↑(orthogonalProjection (Submodule.span 𝕜 {v})ᗮ) v = 0\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection onto `(𝕜 ∙ v)ᗮ` of `v` is zero. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : α → E} {a : α → ℝ} {t₀ : Filter α},\\n  (∀ (n : α), ‖f n‖ ≤ a n) → Filter.Tendsto a t₀ (nhds 0) → Filter.Tendsto f t₀ (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Special case of the sandwich theorem: if the norm of `f` is bounded by a real\\nfunction `a` which tends to `0`, then `f` tends to `0`.\"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\\n  InnerProductGeometry.angle x y = 0 → inner x y = ‖x‖ * ‖y‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the angle between two vectors is 0, the inner product equals the product of the norms. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {u v : E}, v ∈ (Submodule.span 𝕜 {u})ᗮ ↔ inner u v = 0\",\n  \"isProp\": true,\n  \"docString\": \"A vector is in `(𝕜 ∙ u)ᗮ` iff it is orthogonal to `u`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"}]\n",
    "prompt_cons": "/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a negative set `u`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\n  MeasurableSet u →\n    MeasurableSet v →\n      MeasurableSet w →\n        MeasureTheory.VectorMeasure.restrict s u ≤ MeasureTheory.VectorMeasure.restrict 0 u →\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0 :=\n\n/-- A subset `v` of a null-set `w` has zero measure if `w` is a subset of a positive set `u`. -/\ntheorem ∀ {α : Type u_1} [inst : MeasurableSpace α] {s : MeasureTheory.SignedMeasure α} {u v w : Set α},\n  MeasurableSet u →\n    MeasurableSet v →\n      MeasurableSet w →\n        MeasureTheory.VectorMeasure.restrict 0 u ≤ MeasureTheory.VectorMeasure.restrict s u →\n          ↑s w = 0 → w ⊆ u → v ⊆ w → ↑s v = 0 :=\n\n/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 ↔ U ⟂ V :=\n\n/-- The orthogonal projection onto `(𝕜 ∙ v)ᗮ` of `v` is zero. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (v : E), ↑(orthogonalProjection (Submodule.span 𝕜 {v})ᗮ) v = 0 :=\n\n/-- Special case of the sandwich theorem: if the norm of `f` is bounded by a real\nfunction `a` which tends to `0`, then `f` tends to `0`. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} [inst : SeminormedAddGroup E] {f : α → E} {a : α → ℝ} {t₀ : Filter α},\n  (∀ (n : α), ‖f n‖ ≤ a n) → Filter.Tendsto a t₀ (nhds 0) → Filter.Tendsto f t₀ (nhds 0) :=\n\n/-- If the angle between two vectors is 0, the inner product equals the product of the norms. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},\n  InnerProductGeometry.angle x y = 0 → inner x y = ‖x‖ * ‖y‖ :=\n\n/-- A vector is in `(𝕜 ∙ u)ᗮ` iff it is orthogonal to `u`. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {u v : E}, v ∈ (Submodule.span 𝕜 {u})ᗮ ↔ inner u v = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {V : Type u_2} [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace 𝕜 V] {u v : V},\n  inner u v = 0 ↔ ∀ (a : 𝕜), ∥u∥ ≤ ∥u + a • v∥ ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (u v : E), inner u v = 0 ↔ ∀ (a : 𝕜), ‖u‖ ≤ ‖u + a • v‖ ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace 𝕜 V]\n  {u v : V} {a : 𝕜}, inner u v = 0 ↔ ∀ a, ‖u‖ ≤ ‖u + a • v‖ ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : IsROrC 𝕜] [inst_1 : InnerProductSpace 𝕜 V] {u v : V} {a : 𝕜},\n  inner u v = 0 ↔ ∀ a, ‖u‖ ≤ ‖u + a • v‖ ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace 𝕜 V]\n  (u v : V), inner u v = 0 ↔ ∀ (a : 𝕜), ‖u‖ ≤ ‖u + a • v‖ ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace 𝕜 V]\n  {u v : V}, inner u v = 0 ↔ ∀ (a : 𝕜), ‖u‖ ≤ ‖u + a • v‖ ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {u v : E}, inner u v = 0 ↔ ∀ (a : 𝕜), ∥u∥ ≤ ∥u + a • v∥ ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup V] [inst_2 : InnerProductSpace 𝕜 V]\n  {u v : V}, inner u v = 0 ↔ ∀ (a : 𝕜), ‖u‖ ≤ ‖u + a • v‖ ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace 𝕜 V] {u v : V},\n  inner u v = 0 ↔ ∀ (a : 𝕜), ‖u‖ ≤ ‖u + a • v‖ ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : NormedAddCommGroup V] [inst_2 : NormedSpace 𝕜 V] {u v : V},\n  (inner u v = 0) ↔ (∀ (a : 𝕜), ‖u‖ ≤ ‖u + a • v‖) "
    ]
  },
  {
    "docString": "Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inner product on an inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im\",\n  \"isProp\": true,\n  \"docString\":\n  \"The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\\n  inner x y * inner x y ≤ inner x x * inner y y\",\n  \"isProp\": true,\n  \"docString\": \"Cauchy–Schwarz inequality for real inner products. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) (f : V ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x : V), ↑f (↑(Orientation.rotation o θ) x) = ↑(Real.Angle.expMapCircle θ) * ↑f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\\ncomplex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (f : V ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x y : V), Orientation.oangle o x y = ↑(Complex.arg (↑(starRingEnd ℂ) (↑f x) * ↑f y))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\\nterms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\\n  [inst_6 : FiniteDimensional ℝ V],\\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v)\\n    (Filter.cocompact V) (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 as `w → ∞`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x : E), ↑f (↑(Orientation.rightAngleRotation o) x) = Complex.I * ↑f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\\nevaluated in terms of a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\\n    ∀ (x y : E), ↑(↑(Orientation.kahler o) x) y = ↑(starRingEnd ℂ) (↑f x) * ↑f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Kahler form on an oriented real inner product space of dimension 2 can be evaluated in terms\\nof a complex-number representation of the space. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F), |inner x y / (‖x‖ * ‖y‖)| ≤ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The real inner product of two vectors, divided by the product of their\\nnorms, has absolute value at most 1. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A linear operator on a complex inner product space is symmetric precisely when\\n`⟪T v, v⟫_ℂ` is real for all v.\"}]\n",
    "prompt_cons": "/-- The inner product on an inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {G : Type u_1} [inst : NormedAddCommGroup G] [inst_1 : InnerProductSpace ℝ G] (f : G ≃ₗᵢ[ℝ] ℂ) (x y : G),\n  inner x y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).re :=\n\n/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x y : E), ↑(↑(Orientation.areaForm o) x) y = (↑(starRingEnd ℂ) (↑f x) * ↑f y).im :=\n\n/-- Cauchy–Schwarz inequality for real inner products. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),\n  inner x y * inner x y ≤ inner x x * inner y y :=\n\n/-- Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\ncomplex-number representation of the space. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (θ : Real.Angle) (f : V ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x : V), ↑f (↑(Orientation.rotation o θ) x) = ↑(Real.Angle.expMapCircle θ) * ↑f x :=\n\n/-- The oriented angle on an oriented real inner product space of dimension 2 can be evaluated in\nterms of a complex-number representation of the space. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ V = 2)] (o : Orientation ℝ V (Fin 2)) (f : V ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x y : V), Orientation.oangle o x y = ↑(Complex.arg (↑(starRingEnd ℂ) (↑f x) * ↑f y)) :=\n\n/-- Riemann-Lebesgue lemma for functions on a real inner-product space: the integral\n`∫ v, exp (-2 * π * ⟪w, v⟫ * I) • f v` tends to 0 as `w → ∞`. -/\ntheorem ∀ {E : Type u_2} {V : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)\n  [inst_2 : NormedAddCommGroup V] [inst_3 : MeasurableSpace V] [inst_4 : BorelSpace V] [inst_5 : InnerProductSpace ℝ V]\n  [inst_6 : FiniteDimensional ℝ V],\n  Filter.Tendsto (fun w => ∫ (v : V), ↑(↑Real.fourierChar (↑Multiplicative.ofAdd (-inner v w))) • f v)\n    (Filter.cocompact V) (nhds 0) :=\n\n/-- The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\nevaluated in terms of a complex-number representation of the space. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x : E), ↑f (↑(Orientation.rightAngleRotation o) x) = Complex.I * ↑f x :=\n\n/-- The Kahler form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : InnerProductSpace ℝ E]\n  [inst_2 : Fact (FiniteDimensional.finrank ℝ E = 2)] (o : Orientation ℝ E (Fin 2)) (f : E ≃ₗᵢ[ℝ] ℂ),\n  ↑(Orientation.map (Fin 2) f.toLinearEquiv) o = Complex.orientation →\n    ∀ (x y : E), ↑(↑(Orientation.kahler o) x) y = ↑(starRingEnd ℂ) (↑f x) * ↑f y :=\n\n/-- The real inner product of two vectors, divided by the product of their\nnorms, has absolute value at most 1. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F), |inner x y / (‖x‖ * ‖y‖)| ≤ 1 :=\n\n/-- A linear operator on a complex inner product space is symmetric precisely when\n`⟪T v, v⟫_ℂ` is real for all v. -/\ntheorem ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (T : V →ₗ[ℂ] V),\n  LinearMap.IsSymmetric T ↔ ∀ (v : V), ↑(starRingEnd ℂ) (inner (↑T v) v) = inner (↑T v) v :=\n\n/-- Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$. -/\ntheorem",
    "choices": [
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = (‖u + v‖^2 - ‖u - v‖^2 + (‖u + I * v‖^2 - ‖u - I * v‖^2) * I) / 4 ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = ((norm (u + v)) ^ 2 - (norm (u - v)) ^ 2 + ((norm (u + I * v)) ^ 2 - (norm (u - I * v)) ^ 2) * I) / 4 ",
      "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = (‖u + v‖ ^ 2 - ‖u - v‖ ^ 2 + (‖u + I • v‖ ^ 2 - ‖u - I • v‖ ^ 2) * I) / 4 ",
      "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = (‖u+v‖^2 - ‖u-v‖^2 + ‖u+Complex.i*v‖^2 * Complex.i - ‖u-Complex.i*v‖^2 * Complex.i) / 4 ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = ((∥u + v∥ ^ 2 - ∥u - v∥ ^ 2 + (∥u + I * v∥ ^ 2) * I - (∥u - I * v∥ ^ 2) * I) / 4) ",
      "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = ((‖u + v‖^2 - ‖u - v‖^2) + (‖u + I • v‖^2 - ‖u - I • v‖^2) * I) / 4 ",
      "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = (‖u + v‖^2 - ‖u - v‖^2 + (‖u + Complex.i • v‖^2 - ‖u - Complex.i • v‖^2) * Complex.i) / 4 ",
      "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = (‖u + v‖^2 - ‖u - v‖^2 + (‖u + Complex.i • v‖^2 - ‖u - Complex.i • v‖^2) * Complex.i) / 4 ",
      "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = (‖u + v‖^2 - ‖u - v‖^2 + (‖u + Complex.i • v‖^2 - ‖u - Complex.i • v‖^2) * Complex.i) / 4 ",
      "forall {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℂ V] (u v : V),\n  inner u v = (‖u + v‖ ^ 2 - ‖u - v‖ ^ 2 + ((‖u + Complex.i • v‖ ^ 2 - ‖u - Complex.i • v‖ ^ 2) * Complex.i)) / 4 "
    ]
  },
  {
    "docString": "Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 ↔ U ⟂ V\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\\n  U ⟂ V → ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The projection into `U` from an orthogonal submodule `V` is the zero map. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict vector subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace ℝ P} [inst_4 : Nonempty { x // x ∈ s }]\\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\\n  dist p ↑(↑(EuclideanGeometry.orthogonalProjection s) p) = 0 ↔ p ∈ s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The distance to a point's orthogonal projection is 0 iff it lies in the subspace. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\\n  U ≤ V → ∀ (x : E), ↑(orthogonalProjection U) ↑(↑(orthogonalProjection V) x) = ↑(orthogonalProjection U) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `U ≤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of two subspaces is equal to the span of their union. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, ↑(↑(orthogonalProjection K) v) = v ↔ v ∈ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"A point equals its orthogonal projection if and only if it lies in the subspace. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0\",\n  \"isProp\": true,\n  \"docString\": \"A strict affine subspace has measure zero. \"},\n {\"theorem\":\n  \"∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of a subspace and the span of a set of points is equal to the span of the union of\\nthe subspace and the set of points. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\\nsuch that `V + V ⊆ U`.\"}]\n",
    "prompt_cons": "/-- The projection into `U` from `V` is the zero map if and only if `U` and `V` are orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\n  ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 ↔ U ⟂ V :=\n\n/-- The projection into `U` from an orthogonal submodule `V` is the zero map. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U],\n  U ⟂ V → ContinuousLinearMap.comp (orthogonalProjection U) (Submodule.subtypeL V) = 0 :=\n\n/-- A strict vector subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : Submodule ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- The distance to a point's orthogonal projection is 0 iff it lies in the subspace. -/\ntheorem ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {s : AffineSubspace ℝ P} [inst_4 : Nonempty { x // x ∈ s }]\n  [inst_5 : HasOrthogonalProjection (AffineSubspace.direction s)] {p : P},\n  dist p ↑(↑(EuclideanGeometry.orthogonalProjection s) p) = 0 ↔ p ∈ s :=\n\n/-- If `U ≤ V`, then projecting on `V` and then on `U` is the same as projecting on `U`. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection U] [inst_4 : HasOrthogonalProjection V],\n  U ≤ V → ∀ (x : E), ↑(orthogonalProjection U) ↑(↑(orthogonalProjection V) x) = ↑(orthogonalProjection U) x :=\n\n/-- The supremum of two subspaces is equal to the span of their union. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] (S T : Set (ℙ K V)),\n  Projectivization.Subspace.span (S ∪ T) = Projectivization.Subspace.span S ⊔ Projectivization.Subspace.span T :=\n\n/-- A point equals its orthogonal projection if and only if it lies in the subspace. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {K : Submodule 𝕜 E} [inst_3 : HasOrthogonalProjection K] {v : E}, ↑(↑(orthogonalProjection K) v) = v ↔ v ∈ K :=\n\n/-- A strict affine subspace has measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] (s : AffineSubspace ℝ E), s ≠ ⊤ → ↑↑μ ↑s = 0 :=\n\n/-- The supremum of a subspace and the span of a set of points is equal to the span of the union of\nthe subspace and the set of points. -/\ntheorem ∀ {K : Type u_2} {V : Type u_1} [inst : Field K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {S : Set (ℙ K V)}\n  {W : Projectivization.Subspace K V}, W ⊔ Projectivization.Subspace.span S = Projectivization.Subspace.span (↑W ∪ S) :=\n\n/-- Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\nsuch that `V + V ⊆ U`. -/\ntheorem ∀ {M : Type u_1} [inst : TopologicalSpace M] [inst_1 : AddMonoid M] [inst_2 : ContinuousAdd M] {U : Set M},\n  U ∈ nhds 0 → ∃ V, IsOpen V ∧ 0 ∈ V ∧ V + V ⊆ U :=\n\n/-- Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$ -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (U.orthogonal = ⊥ ↔ U = V) ",
      "forall {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (U.orthogonal = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E},\n  U ≤ V → (U.orthogonal = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (U.orthogonal = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (U.orthogonal = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (U.orthogonal = ⊥ ↔ U = V) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {U V : Submodule 𝕜 E}, U ≤ V → (Uᗮ = ⊥ ↔ U = V) "
    ]
  },
  {
    "docString": "Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (W : Submodule R M),\\n  LinearMap.range (LinearMap.dualMap (Submodule.mkQ W)) = Submodule.dualAnnihilator W\",\n  \"isProp\": true,\n  \"docString\":\n  \"That $\\\\operatorname{im}(q^* : (V/W)^* \\\\to V^*) = \\\\operatorname{ann}(W)$. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\\nlinear maps is complete provided that the codomain is a complete space. \"},\n {\"theorem\": \"∀ {x : ℝ}, Liouville x → Transcendental ℤ x\",\n  \"isProp\": true,\n  \"docString\": \"**Liouville's Theorem** \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Auxiliary lemma to show that the infimum of seminorms is well-defined. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace β] [inst_1 : TopologicalSpace γ]\\n  [inst_2 : T2Space γ] {f : α → β}, DenseRange f → ∀ {g h : β → γ}, Continuous g → Continuous h → g ∘ f = h ∘ f → g = h\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two continuous functions to a t2-space that agree on the dense range of a function are equal. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}\\n  (P : (α → E) → Prop),\\n  (∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → ↑↑μ s < ⊤ → P (Set.indicator s fun x => c)) →\\n    (∀ ⦃f g : α → E⦄,\\n        Disjoint (Function.support f) (Function.support g) →\\n          MeasureTheory.Integrable f → MeasureTheory.Integrable g → P f → P g → P (f + g)) →\\n      IsClosed {f | P ↑↑f} →\\n        (∀ ⦃f g : α → E⦄, f =ᶠ[MeasureTheory.Measure.ae μ] g → MeasureTheory.Integrable f → P f → P g) →\\n          ∀ ⦃f : α → E⦄, MeasureTheory.Integrable f → P f\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something for an arbitrary integrable function in a normed group,\\nit suffices to show that\\n* the property holds for (multiples of) characteristic functions;\\n* is closed under addition;\\n* the set of functions in the `L¹` space for which the property holds is closed.\\n* the property is closed under the almost-everywhere equal relation.\\n\\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\\na simple function with a multiple of a characteristic function and that the intersection\\nof their images is a subset of `{0}`).\\n\"},\n {\"theorem\":\n  \"∀ (α : Type u) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : T3Space α],\\n  NormalSpace α\",\n  \"isProp\": true,\n  \"docString\":\n  \"A T₃ topological space with second countable topology is a normal space.\\nThis lemma is not an instance to avoid a loop. \"},\n {\"theorem\":\n  \"∀ {F : Type u_2} {A : Type u_3} {B : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A]\\n  [inst_2 : CompleteSpace A] [inst_3 : StarRing A] [inst_4 : CstarRing A] [inst_5 : NormedRing B]\\n  [inst_6 : NormedAlgebra ℂ B] [inst_7 : CompleteSpace B] [inst_8 : StarRing B] [inst_9 : CstarRing B]\\n  [hF : StarAlgHomClass F ℂ A B] (φ : F) (a : A), ‖↑φ a‖ ≤ ‖a‖\",\n  \"isProp\": true,\n  \"docString\":\n  \"A star algebra homomorphism of complex C⋆-algebras is norm contractive. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two disjoint sets in a normal space admit disjoint neighbourhoods. \"}]\n",
    "prompt_cons": "/-- That $\\operatorname{im}(q^* : (V/W)^* \\to V^*) = \\operatorname{ann}(W)$. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (W : Submodule R M),\n  LinearMap.range (LinearMap.dualMap (Submodule.mkQ W)) = Submodule.dualAnnihilator W :=\n\n/-- If a Cauchy sequence of continuous linear map converges to a continuous linear map pointwise,\nthen it converges to the same map in norm. This lemma is used to prove that the space of continuous\nlinear maps is complete provided that the codomain is a complete space. -/\ntheorem ∀ {𝕜 : Type u_1} {𝕜₂ : Type u_2} {F : Type u_4} [inst : NormedAddCommGroup F] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : NontriviallyNormedField 𝕜₂] [inst_3 : NormedSpace 𝕜₂ F] {σ₁₂ : 𝕜 →+* 𝕜₂} {E' : Type u_3}\n  [inst_4 : SeminormedAddCommGroup E'] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : RingHomIsometric σ₁₂]\n  {f : ℕ → E' →SL[σ₁₂] F} {g : E' →SL[σ₁₂] F},\n  Filter.Tendsto (fun n x => ↑(f n) x) Filter.atTop (nhds ↑g) → CauchySeq f → Filter.Tendsto f Filter.atTop (nhds g) :=\n\n/-- **Liouville's Theorem** -/\ntheorem ∀ {x : ℝ}, Liouville x → Transcendental ℤ x :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem ∀ {𝕜 : Type u_2} {E : Type u_1} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E]\n  {p q : Seminorm 𝕜 E} {x : E}, BddBelow (Set.range fun u => ↑p u + ↑q (x - u)) :=\n\n/-- Two continuous functions to a t2-space that agree on the dense range of a function are equal. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {γ : Type u_3} [inst : TopologicalSpace β] [inst_1 : TopologicalSpace γ]\n  [inst_2 : T2Space γ] {f : α → β}, DenseRange f → ∀ {g h : β → γ}, Continuous g → Continuous h → g ∘ f = h ∘ f → g = h :=\n\n/-- To prove something for an arbitrary integrable function in a normed group,\nit suffices to show that\n* the property holds for (multiples of) characteristic functions;\n* is closed under addition;\n* the set of functions in the `L¹` space for which the property holds is closed.\n* the property is closed under the almost-everywhere equal relation.\n\nIt is possible to make the hypotheses in the induction steps a bit stronger, and such conditions\ncan be added once we need them (for example in `h_add` it is only necessary to consider the sum of\na simple function with a multiple of a characteristic function and that the intersection\nof their images is a subset of `{0}`). -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}\n  (P : (α → E) → Prop),\n  (∀ (c : E) ⦃s : Set α⦄, MeasurableSet s → ↑↑μ s < ⊤ → P (Set.indicator s fun x => c)) →\n    (∀ ⦃f g : α → E⦄,\n        Disjoint (Function.support f) (Function.support g) →\n          MeasureTheory.Integrable f → MeasureTheory.Integrable g → P f → P g → P (f + g)) →\n      IsClosed {f | P ↑↑f} →\n        (∀ ⦃f g : α → E⦄, f =ᶠ[MeasureTheory.Measure.ae μ] g → MeasureTheory.Integrable f → P f → P g) →\n          ∀ ⦃f : α → E⦄, MeasureTheory.Integrable f → P f :=\n\n/-- A T₃ topological space with second countable topology is a normal space.\nThis lemma is not an instance to avoid a loop. -/\ntheorem ∀ (α : Type u) [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.SecondCountableTopology α] [inst_2 : T3Space α],\n  NormalSpace α :=\n\n/-- A star algebra homomorphism of complex C⋆-algebras is norm contractive. -/\ntheorem ∀ {F : Type u_2} {A : Type u_3} {B : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A]\n  [inst_2 : CompleteSpace A] [inst_3 : StarRing A] [inst_4 : CstarRing A] [inst_5 : NormedRing B]\n  [inst_6 : NormedAlgebra ℂ B] [inst_7 : CompleteSpace B] [inst_8 : StarRing B] [inst_9 : CstarRing B]\n  [hF : StarAlgHomClass F ℂ A B] (φ : F) (a : A), ‖↑φ a‖ ≤ ‖a‖ :=\n\n/-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : NormalSpace α] (s t : Set α),\n  IsClosed s → IsClosed t → Disjoint s t → SeparatedNhds s t :=\n\n/-- Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$ -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {T : V →ₗ[𝕜] V}\n  [self : LinearMap.IsNormal T], LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E},\n  Operator.normedSpace T → LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : InnerProductSpace 𝕜 V] {T : V →ₗ[𝕜] V},\n  T.is_normal → LinearMap.range T = LinearMap.range (T.adjoint) ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V]\n  {T : V →ₗ[𝕜] V}, IsNormal T → LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] [inst_3 : StarModule 𝕜 V]\n  {T : V →ₗ[𝕜] V}, LinearMap.IsNormal T → LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u_1} {M : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup M] [inst_2 : Module 𝕜 M] (T : M →ₗ[𝕜] M),\n  LinearMap.IsNormal T → LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u} {V : Type v} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {T : V →ₗ[𝕜] V},\n  LinearMap.IsNormal T → LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : AddCommGroup V] [inst_2 : Module 𝕜 V] {T : LinearMap 𝕜 V V}\n  [hT : LinearMap.IsNormal T], LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u_1} {V : Type u_2} [inst : Field 𝕜] [inst_1 : InnerProductSpace 𝕜 V] {T : V →ₗ[𝕜] V},\n  LinearMap.IsNormal T → LinearMap.range T = LinearMap.range (LinearMap.adjoint T) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E},\n  IsNormal T → LinearMap.range T = LinearMap.range (LinearMap.adjoint T) "
    ]
  },
  {
    "docString": "Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every self-adjoint operator on an inner product space is symmetric. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  (v : E) (μ : Module.End.Eigenvalues T),\\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] (U : Submodule 𝕜 E) [inst_4 : CompleteSpace { x // x ∈ U }],\\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U))\",\n  \"isProp\": true,\n  \"docString\": \"The orthogonal projection is self-adjoint. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ [inst_3 : FiniteDimensional 𝕜 E], (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\\nfinite-dimensional inner product space is trivial. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  (T : E →ₗ[𝕜] E), LinearMap.IsSymmetric T ↔ LinearMap.IsSelfAdjoint sesqFormOfInner T\",\n  \"isProp\": true,\n  \"docString\":\n  \"An operator `T` on an inner product space is symmetric if and only if it is\\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\\nproduct space is an invariant subspace of the operator. \"}]\n",
    "prompt_cons": "/-- Every self-adjoint operator on an inner product space is symmetric. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {A : E →L[𝕜] E}, IsSelfAdjoint A → LinearMap.IsSymmetric ↑A :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  (v : E) (μ : Module.End.Eigenvalues T),\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ :=\n\n/-- The orthogonal projection is self-adjoint. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] (U : Submodule 𝕜 E) [inst_4 : CompleteSpace { x // x ∈ U }],\n  IsSelfAdjoint (ContinuousLinearMap.comp (Submodule.subtypeL U) (orthogonalProjection U)) :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ [inst_3 : FiniteDimensional 𝕜 E], (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ = ⊥ :=\n\n/-- An operator `T` on an inner product space is symmetric if and only if it is\n`LinearMap.IsSelfAdjoint` with respect to the sesquilinear form given by the inner product. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (T : E →ₗ[𝕜] E), LinearMap.IsSymmetric T ↔ LinearMap.IsSelfAdjoint sesqFormOfInner T :=\n\n/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ :=\n\n/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    ∀ ⦃v : E⦄, v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (⨆ (μ : 𝕜), Module.End.eigenspace T μ)ᗮ :=\n\n/-- Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (T : E →ₗ[𝕜] E),\n  (LinearMap.mul T ^ 9 = LinearMap.mul T ^ 8) → LinearMap.IsNormal T → LinearMap.IsSymmetric T ∧ (LinearMap.mul T ^ 2 = T) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsNormal T → T ^ 9 = T ^ 8 → LinearMap.IsSymmetric T ∧ T ^ 2 = T ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (T : E →ₗ[𝕜] E),\n  LinearMap.IsNormal T ∧ (T ^ 9 = T ^ 8) →\n    (LinearMap.IsSymmetric T ∧ (T ^ 2 = T)) ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →ₗ[𝕜] E}, T ^ 9 = T ^ 8 → LinearMap.IsNormal T → LinearMap.IsSymmetric T ∧ T ^ 2 = T ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, T^9 = T^8 → LinearMap.IsNormal T → LinearMap.IsSymmetric T ∧ T^2 = T ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, T ^ 9 = T ^ 8 → LinearMap.IsNormal T → LinearMap.IsSymmetric T ∧ T ^ 2 = T ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsNormal T → T ^ 9 = T ^ 8 → IsSelfAdjoint T ∧ T ^ 2 = T ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  (T : E →ₗ[𝕜] E),\n  LinearMap.IsNormal T → T ^ 9 = T ^ 8 → LinearMap.IsSymmetric T ∧ T ^ 2 = T ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, T^9 = T^8 → LinearMap.IsNormal T → LinearMap.IsSelfAdjoint sesqFormOfInner T ∧ T^2 = T ",
      "∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, IsNormal T ∧ T ^ 9 = T ^ 8 → LinearMap.IsSymmetric T ∧ T ^ 2 = T "
    ]
  },
  {
    "docString": "Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ\",\n  \"isProp\": true,\n  \"docString\": \"The eigenvalues of a self-adjoint operator are real. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E] {A : E →ₗ[𝕜] E}, IsSelfAdjoint A ↔ ↑LinearMap.adjoint A = A\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous linear operator is self-adjoint iff it is equal to its adjoint. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The eigenspaces of a self-adjoint operator are mutually orthogonal. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A self-adjoint operator preserves orthogonal complements of its eigenspaces. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] {T : E →L[𝕜] E},\\n  IsSelfAdjoint T →\\n    ∀ {x₀ : E},\\n      x₀ ≠ 0 →\\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 ‖x₀‖) x₀ →\\n          Module.End.HasEigenvector (↑T) (↑(⨅ (x : { x // x ≠ 0 }), ContinuousLinearMap.rayleighQuotient T ↑x)) x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\\nquotient. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\\n  (v : E) (μ : Module.End.Eigenvalues T),\\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"*Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\\ndirect sum of the eigenspaces of `T`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : CompleteSpace E] {T : E →L[𝕜] E},\\n  IsSelfAdjoint T →\\n    ∀ {x₀ : E},\\n      x₀ ≠ 0 →\\n        IsLocalExtrOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 ‖x₀‖) x₀ →\\n          Module.End.HasEigenvector (↑T) (↑(ContinuousLinearMap.rayleighQuotient T x₀)) x₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\\ncentred at the origin is an eigenvector of `T`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] {a : A},\\n  IsSelfAdjoint a → spectrum ℂ a = Complex.ofReal' ∘ Complex.re '' spectrum ℂ a\",\n  \"isProp\": true,\n  \"docString\": \"The spectrum of a selfadjoint is real \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\\n  [inst_3 : FiniteDimensional 𝕜 E] [_i : Nontrivial E] {T : E →ₗ[𝕜] E},\\n  LinearMap.IsSymmetric T →\\n    Module.End.HasEigenvalue T ↑(⨆ (x : { x // x ≠ 0 }), ↑IsROrC.re (inner (↑T ↑x) ↑x) / ‖↑x‖ ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\\nfinite-dimensional vector space is an eigenvalue for that operator. \"}]\n",
    "prompt_cons": "/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T → ∀ {μ : 𝕜}, Module.End.HasEigenvalue T μ → ↑(starRingEnd 𝕜) μ = μ :=\n\n/-- A continuous linear operator is self-adjoint iff it is equal to its adjoint. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E] {A : E →ₗ[𝕜] E}, IsSelfAdjoint A ↔ ↑LinearMap.adjoint A = A :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  {n : ℕ} (hn : FiniteDimensional.finrank 𝕜 E = n) (v : E) (i : Fin n),\n  ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr (↑T v) i =\n    ↑(LinearMap.IsSymmetric.eigenvalues hT hn i) * ↑(LinearMap.IsSymmetric.eigenvectorBasis hT hn).repr v i :=\n\n/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    OrthogonalFamily 𝕜 (fun μ => { x // x ∈ Module.End.eigenspace T μ }) fun μ =>\n      Submodule.subtypeₗᵢ (Module.End.eigenspace T μ) :=\n\n/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ (μ : 𝕜) (v : E), v ∈ (Module.End.eigenspace T μ)ᗮ → ↑T v ∈ (Module.End.eigenspace T μ)ᗮ :=\n\n/-- For a self-adjoint operator `T`, a minimum of the Rayleigh quotient of `T` on a sphere centred\nat the origin is an eigenvector of `T`, with eigenvalue the global infimum of the Rayleigh\nquotient. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →L[𝕜] E},\n  IsSelfAdjoint T →\n    ∀ {x₀ : E},\n      x₀ ≠ 0 →\n        IsMinOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 ‖x₀‖) x₀ →\n          Module.End.HasEigenvector (↑T) (↑(⨅ (x : { x // x ≠ 0 }), ContinuousLinearMap.rayleighQuotient T ↑x)) x₀ :=\n\n/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] [dec_𝕜 : DecidableEq 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : InnerProductSpace 𝕜 E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) [inst_3 : FiniteDimensional 𝕜 E]\n  (v : E) (μ : Module.End.Eigenvalues T),\n  ↑(LinearMap.IsSymmetric.diagonalization hT) (↑T v) μ = ↑T μ • ↑(LinearMap.IsSymmetric.diagonalization hT) v μ :=\n\n/-- For a self-adjoint operator `T`, a local extremum of the Rayleigh quotient of `T` on a sphere\ncentred at the origin is an eigenvector of `T`. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : IsROrC 𝕜] {E : Type u_1} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →L[𝕜] E},\n  IsSelfAdjoint T →\n    ∀ {x₀ : E},\n      x₀ ≠ 0 →\n        IsLocalExtrOn (ContinuousLinearMap.reApplyInnerSelf T) (Metric.sphere 0 ‖x₀‖) x₀ →\n          Module.End.HasEigenvector (↑T) (↑(ContinuousLinearMap.rayleighQuotient T x₀)) x₀ :=\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem ∀ {A : Type u_1} [inst : NormedRing A] [inst_1 : NormedAlgebra ℂ A] [inst_2 : CompleteSpace A] [inst_3 : StarRing A]\n  [inst_4 : CstarRing A] [inst_5 : StarModule ℂ A] {a : A},\n  IsSelfAdjoint a → spectrum ℂ a = Complex.ofReal' ∘ Complex.re '' spectrum ℂ a :=\n\n/-- The supremum of the Rayleigh quotient of a symmetric operator `T` on a nontrivial\nfinite-dimensional vector space is an eigenvalue for that operator. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : FiniteDimensional 𝕜 E] [_i : Nontrivial E] {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    Module.End.HasEigenvalue T ↑(⨆ (x : { x // x ≠ 0 }), ↑IsROrC.re (inner (↑T ↑x) ↑x) / ‖↑x‖ ^ 2) :=\n\n/-- Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) {λ : 𝕜} {ε : ℝ} (hε : 0 < ε)\n  {v : E} (hv₁ : ∥v∥ = 1) (hv₂ : ∥T v - λ • v∥ < ε),\n  ∃ (λ' : 𝕜), Module.End.HasEigenvalue T λ' ∧ abs (λ - λ') < ε ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T →\n    ∀ (λ : 𝕜) (ε : ℝ), ε > 0 →\n      (∃ v : E, ∥v∥ = 1 ∧ ∥T v - λ • v∥ < ε) →\n        ∃ λ' : 𝕜, Module.End.HasEigenvalue T λ' ∧ abs (IsROrC.re (λ - λ')) < ε ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : Nontrivial E] {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T → ∀ (λ : 𝕜) (ε : ℝ) (v : E),\n    0 < ε →\n      ∥v∥ = 1 →\n        ∥↑T v - λ • v∥ < ε →\n          ∃ λ' : 𝕜, Module.End.HasEigenvalue T λ' ∧ abs (IsROrC.re (λ - λ')) < ε ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →L[𝕜] E} (hT : IsSelfAdjoint T) (λ : 𝕜) (ε : ℝ),\n  0 < ε →\n    (∃ (v : E), ∥v∥ = 1 ∧ ∥T v - λ • v∥ < ε) →\n      ∃ (λ' : 𝕜), Module.End.HasEigenvalue (↑T) λ' ∧ abs (↑IsROrC.re (λ - λ')) < ε ",
      "forall {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T →\n    ∀ (λ : 𝕜) (ε : ℝ), 0 < ε →\n      ∃ (v : E), ∥v∥ = 1 ∧ ∥T v - λ • v∥ < ε →\n        ∃ (λ' : 𝕜), Module.End.HasEigenvalue T λ' ∧ abs (↑IsROrC.re (λ - λ')) < ε ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →ₗ[𝕜] E} (hT : LinearMap.IsSymmetric T) {λ : 𝕜} {ε : ℝ} (hε : 0 < ε)\n  {v : E} (hv : ∥v∥ = 1) (hTλv : ∥T v - λ • v∥ < ε),\n  ∃ (λ' : 𝕜), Module.End.HasEigenvalue T λ' ∧ abs (λ - λ') < ε ",
      "forall {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  {T : E →ₗ[𝕜] E}, LinearMap.IsSymmetric T →\n  ∀ (λ : 𝕜) (ε : ℝ), ε > 0 →\n    (∃ (v : E), ∥v∥ = 1 ∧ ∥T v - λ • v∥ < ε) →\n      ∃ (λ' : 𝕜), Module.End.HasEigenvalue T λ' ∧ abs (IsROrC.im (λ - λ')) < ε ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →L[𝕜] E},\n  IsSelfAdjoint T →\n    ∀ (λ : 𝕜) (ε : ℝ),\n      0 < ε →\n        (∃ (v : E), ∥v∥ = 1 ∧ ∥↑T v - λ • v∥ < ε) →\n          ∃ (λ' : 𝕜), Module.End.HasEigenvalue (↑T) λ' ∧ abs (IsROrC.re (λ - λ')) < ε ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →ₗ[𝕜] E},\n  LinearMap.IsSymmetric T →\n    ∀ {λ : 𝕜} {ε : ℝ} (hε : 0 < ε) {v : E},\n      ∥v∥ = 1 → ∥↑T v - λ • v∥ < ε →\n        ∃ (λ' : 𝕜), Module.End.HasEigenvalue T λ' ∧ abs (↑IsROrC.re (λ - λ')) < ε ",
      "forall {𝕜 : Type u_1} [inst : IsROrC 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]\n  [inst_3 : CompleteSpace E] {T : E →L[𝕜] E} (hT : IsSelfAdjoint T) {λ : 𝕜} {ε : ℝ} (hε : ε > 0),\n  (∃ (v : E), ∥v∥ = 1 ∧ ∥T v - λ • v∥ < ε) →\n    ∃ (λ' : 𝕜), Module.End.HasEigenvalue (↑T) λ' ∧ abs (↑IsROrC.re (λ - λ')) < ε "
    ]
  },
  {
    "docString": "For all odd $n$ show that $8 \\mid n^{2}-1$.",
    "prompts": "[{\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 3`, then `(-1)^(n/2) = -1`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\": \"∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n)\",\n  \"isProp\": true,\n  \"docString\": \"If `a` is even, then `n` is odd iff `n % a` is odd. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"∀ {n a : ℕ}, Odd n → Even a → Odd (n % a)\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is odd and `a` is even, then `n % a` is odd. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"∀ (n : ℤ), ↑ZMod.χ₈ ↑n = ↑ZMod.χ₈ ↑(n % 8)\",\n  \"isProp\": true,\n  \"docString\": \"The value of `χ₈ n`, for `n : ℤ`, depends only on `n % 8`. \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"}]\n",
    "prompt_cons": "/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 3 → (-1) ^ (n / 2) = -1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- If `a` is even, then `n` is odd iff `n % a` is odd. -/\ntheorem ∀ {n a : ℕ}, Even a → (Odd (n % a) ↔ Odd n) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- If `n` is odd and `a` is even, then `n % a` is odd. -/\ntheorem ∀ {n a : ℕ}, Odd n → Even a → Odd (n % a) :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The value of `χ₈ n`, for `n : ℤ`, depends only on `n % 8`. -/\ntheorem ∀ (n : ℤ), ↑ZMod.χ₈ ↑n = ↑ZMod.χ₈ ↑(n % 8) :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- For all odd $n$ show that $8 \\mid n^{2}-1$. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
      "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
      "∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ",
      "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
      "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
      "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
      "∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) ",
      "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
      "∀ {n : ℕ}, Odd n → 8 ∣ n ^ 2 - 1 ",
      "∀ {n : ℕ}, Odd n → 8 ∣ (n ^ 2 - 1) "
    ]
  },
  {
    "docString": "Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$.",
    "prompts": "[{\"theorem\":\n  \"∀ (n : ℕ), (∑' (i : ℕ), if n ≤ i then 2⁻¹ ^ i else 0) = 2 * 2⁻¹ ^ n\",\n  \"isProp\": true,\n  \"docString\": \"The sum of `2⁻¹ ^ i` for `n ≤ i` equals `2 * 2⁻¹ ^ n`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"∀ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : ℕ},\\n  2 ≤ k →\\n    ∀ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A ≃+* B → NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : ℕ},\\n  IsPrimitiveRoot ζ (2 ^ k) →\\n    2 ≤ k →\\n      ∀ [H : IsCyclotomicExtension {2 ^ k} K L],\\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (ζ - 1) = 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\\nthen the norm of `ζ - 1` is `2`. \"},\n {\"theorem\": \"∀ {n : ℕ} (self : Fin n), ↑self < n\",\n  \"isProp\": true,\n  \"docString\": \"If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. \"}]\n",
    "prompt_cons": "/-- The sum of `2⁻¹ ^ i` for `n ≤ i` equals `2 * 2⁻¹ ^ n`. -/\ntheorem ∀ (n : ℕ), (∑' (i : ℕ), if n ≤ i then 2⁻¹ ^ i else 0) = 2 * 2⁻¹ ^ n :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem ∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I) :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\nthen the norm of `zeta (2 ^ k) K L - 1` is `2`. -/\ntheorem ∀ {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] {k : ℕ},\n  2 ≤ k →\n    ∀ [inst_3 : IsCyclotomicExtension {2 ^ k} K L],\n      Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (IsCyclotomicExtension.zeta (2 ^ k) K L - 1) = 2 :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem ∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A ≃+* B → NoZeroDivisors A :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- If `Irreducible (cyclotomic (2 ^ k) K)` (in particular for `K = ℚ`) and `k` is at least `2`,\nthen the norm of `ζ - 1` is `2`. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : ℕ},\n  IsPrimitiveRoot ζ (2 ^ k) →\n    2 ≤ k →\n      ∀ [H : IsCyclotomicExtension {2 ^ k} K L],\n        Irreducible (Polynomial.cyclotomic (2 ^ k) K) → ↑(Algebra.norm K) (ζ - 1) = 2 :=\n\n/-- If `i : Fin n`, then `i.2` is a proof that `i.1 < n`. -/\ntheorem ∀ {n : ℕ} (self : Fin n), ↑self < n :=\n\n/-- Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$. -/\ntheorem",
    "choices": [
      "2 ∣ (1 + Complex.I)^2 ",
      "divisible_by_one_plus_i_squared : ∃ (a b : ℤ), (1 + Complex.I) ^ 2 * (a + b * Complex.I) = 2 ",
      "divisible_2_one_plus_i_squared : ∃ a b : ℤ, (a + Complex.I * b) * (1 + Complex.I) ^ 2 = 2 ",
      "∀ (self : ℤ[i]), self = (1 + Complex.I) ^ 2 → 2 ∣ self ",
      "2 ∣ (1 + ℂ.I) ^ 2 ",
      "∃ (a b : ℤ), (1 + Complex.I) ^ 2 = 2 * (a + b * Complex.I) ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : Algebra ℤ[R]], ((1 + Complex.I) ^ 2).im * Complex.I = 2 ",
      "∀ (R : Type u) [inst : CommRing R] [inst_1 : Algebra R ℂ], (1 + Complex.I) ^ 2 ∣ 2 ",
      "(2 : ℤ[I]) = (1 + I) ^ 2 ",
      "(1 : ℤ[i]) + I ^ 2 = 2 "
    ]
  },
  {
    "docString": "Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {p n r b : ℕ},\\n  Nat.Prime p → Nat.log p n < b → (p ^ r ∣ Nat.factorial n ↔ r ≤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` \"},\n {\"theorem\":\n  \"∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2`  \"},\n {\"theorem\": \"∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"∀ {p n b : ℕ} [hp : Fact (Nat.Prime p)],\\n  Nat.log p n < b → padicValNat p (Nat.factorial n) = Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Legendre's Theorem**\\n\\nThe `p`-adic valuation of `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"∀ {n d : ℕ}, d ∣ n → Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `d ∣ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {n b : ℕ}, Nat.log p n < b → multiplicity p (Nat.factorial n) = ↑(Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Legendre's Theorem**\\n\\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\\n  p ≠ 2 →\\n    ↑a ≠ 0 →\\n      legendreSym p a =\\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (↑a * ↑x)) (Finset.Ico 1 (Nat.succ (p / 2))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\\nthan `p/2` such that `(a * x) % p > p / 2`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : UniqueFactorizationMonoid α]\\n  [inst_2 : NormalizationMonoid α] [inst_3 : DecidableEq α] {x : α} {n : ℕ}, factorization (x ^ n) = n • factorization x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `x^n` is `n` times the power in `x` \"}]\n",
    "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\nThis sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` -/\ntheorem ∀ {p n r b : ℕ},\n  Nat.Prime p → Nat.log p n < b → (p ^ r ∣ Nat.factorial n ↔ r ≤ Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i) :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2` -/\ntheorem ∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem ∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n :=\n\n/-- **Legendre's Theorem**\n\nThe `p`-adic valuation of `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. -/\ntheorem ∀ {p n b : ℕ} [hp : Fact (Nat.Prime p)],\n  Nat.log p n < b → padicValNat p (Nat.factorial n) = Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- For `d ∣ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` -/\ntheorem ∀ {n d : ℕ}, d ∣ n → Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n)) :=\n\n/-- **Legendre's Theorem**\n\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {n b : ℕ}, Nat.log p n < b → multiplicity p (Nat.factorial n) = ↑(Finset.sum (Finset.Ico 1 b) fun i => n / p ^ i) :=\n\n/-- Gauss' lemma. The Legendre symbol can be computed by considering the number of naturals less\nthan `p/2` such that `(a * x) % p > p / 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\n  p ≠ 2 →\n    ↑a ≠ 0 →\n      legendreSym p a =\n        (-1) ^ Finset.card (Finset.filter (fun x => p / 2 < ZMod.val (↑a * ↑x)) (Finset.Ico 1 (Nat.succ (p / 2)))) :=\n\n/-- For any `p`, the power of `p` in `x^n` is `n` times the power in `x` -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : UniqueFactorizationMonoid α]\n  [inst_2 : NormalizationMonoid α] [inst_3 : DecidableEq α] {x : α} {n : ℕ}, factorization (x ^ n) = n • factorization x :=\n\n/-- Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$. -/\ntheorem",
    "choices": [
      "∀ {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  (if h : n = p ^ (Nat.log p n) then Nat.log p n else 0) =\n    Finset.sum (Nat.divisors n) fun d => Moebius.μ (n / d) * (if h : d = p ^ (Nat.log p d) then Nat.log p d else 0) ",
      "∀ {p n : ℕ},\n  Nat.Prime p →\n    (n ≠ 0 →\n      Finset.sum (Finset.divisors n) (fun d => μ (n / d) * Nat.log d) =\n        if n = p ^ (Nat.log p n) then Nat.log p else 0) ",
      "∀ {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  (∀ (A : ℕ), (A ∣ n) → ((∃ k, A = p ^ k) ↔ A = p ^ padicValNat p n)) →\n    Finset.sum (Finset.filter (fun A => A ∣ n) (Finset.range (Nat.succ n)))\n      (fun A => (μ (n / A)).natAbs * padicValNat p A) = padicValNat p n ",
      "∀ {p n : ℕ}, Nat.Prime p →\n  (n = 0 → Nat.log p n = 0) →\n    (n ≠ 0 → n = p ^ (Nat.log p n)) →\n      (Finset.sum (Finset.divisors n) fun d => (Units.coe (Euler.phi.Moebius (n / d)) : ℤ) * (Nat.log d : ℤ)) = Nat.log p n ",
      "∀ {p n : ℕ},\n  Nat.Prime p → (n = p ^ (multiplicity p n).get (multiplicity.finite_nat_iff.mpr ⟨Nat.Prime.ne_one p, n.pos_of_prime_pow⟩)) →\n    Finset.sum (Nat.divisors n) (λ (d : ℕ), Nat.mulFactor μ (n / d) * Nat.log d) = Nat.log p ",
      "∀ {p n : ℕ},\n  Nat.Prime p →\n    (∀ d, d ∣ n → (d = p ^ Nat.log p d ↔ (∃ k, d = p ^ k)) ∧\n      (∑ A in Finset.filter (fun _x => _x ∣ n) (Finset.Ico 1 (Nat.succ n)), moebius (n / A) * Nat.log A) = Nat.log p d) ",
      "∀ {p n : ℕ}, \n  Nat.Prime p →\n    (∀ {d : ℕ}, d ∣ n → \n      (Finset.sum (Finset.filter (λ (A : ℕ), A ∣ n) (Finset.range (n + 1))) \n        (λ (A : ℕ), μ (n / A) * Nat.log A)) = \n          if n = 0 then 0 else if n = p ^ (Nat.log p n) then Nat.log p else 0 ",
      "∀ {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  (Finset.sum (Finset.filter (fun d => d ∣ n) (Finset.range (Nat.succ n))) fun d => μ (n / d) * Nat.log d) =\n    if h : p ^ Nat.log p n = n then Nat.log p else 0 ",
      "∀ {p n : ℕ} [Fact (Nat.Prime p)],\n  (Finset.sum (Finset.filter (fun d => d ∣ n) (Finset.range (Nat.succ n))) fun d => μ d * Nat.log p) =\n    (if n = 0 then 0 else if n % p = 0 then Nat.log p else 0) ",
      "∀ {p n : ℕ},\n  Nat.Prime p →\n    ∀ {α : Type u_1} [inst : CommRing α],\n      (Finset.sum (Nat.divisors n) fun d => μ (n / d) * Nat.log d) =\n        if n % p = 0 then Nat.log p else 0 "
    ]
  },
  {
    "docString": "Show that there are infinitely many primes congruent to $-1$ modulo 6 .",
    "prompts": "[{\"theorem\":\n  \"∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]}\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. \"},\n {\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : ℕ) {w x : M}, ↑c w x → ↑c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k]\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\\n`p ≡ 1 [MOD k]`. \"},\n {\"theorem\":\n  \"∀ {m n : ℕ+}, PNat.factorMultiset m ≤ PNat.factorMultiset n ↔ m ∣ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"We now have four different results that all encode the\\nidea that inequality of multisets corresponds to divisibility\\nof positive integers. \"}]\n",
    "prompt_cons": "/-- For any positive `k : ℕ` there are infinitely many primes `p` such that `p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ 1 [MOD k]} :=\n\n/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c :=\n\n/-- **Wilson's Lemma**: the product of `1`, ..., `p-1` is `-1` modulo `p`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], ↑(Nat.factorial (p - 1)) = -1 :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : ℕ) {w x : M}, ↑c w x → ↑c (w ^ n) (x ^ n) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- For any positive `k : ℕ` there exists an arbitrarily large prime `p` such that\n`p ≡ 1 [MOD k]`. -/\ntheorem ∀ {k : ℕ} (n : ℕ), k ≠ 0 → ∃ p, Nat.Prime p ∧ n < p ∧ p ≡ 1 [MOD k] :=\n\n/-- We now have four different results that all encode the\nidea that inequality of multisets corresponds to divisibility\nof positive integers. -/\ntheorem ∀ {m n : ℕ+}, PNat.factorMultiset m ≤ PNat.factorMultiset n ↔ m ∣ n :=\n\n/-- Show that there are infinitely many primes congruent to $-1$ modulo 6 . -/\ntheorem",
    "choices": [
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} :",
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} ",
      "∀ {k : ℕ}, k ≠ 0 → Set.Infinite {p | Nat.Prime p ∧ p ≡ -1 [MOD 6]} "
    ]
  },
  {
    "docString": "Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.",
    "prompts": "[{\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution has `x ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A quadratic has no root if its discriminant has no square root. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\": \"∀ {r : ℝ}, Transcendental ℚ r → Irrational r\",\n  \"isProp\": true,\n  \"docString\": \"A transcendental real number is irrational. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\": \"No zero divisors. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K }\",\n  \"isProp\": true,\n  \"docString\": \"The ring of integers of a number field is not a field. \"}]\n",
    "prompt_cons": "/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0 :=\n\n/-- A solution has `x ≠ 0`. -/\ntheorem ∀ {d : ℤ}, 0 ≤ d → ∀ (a : Pell.Solution₁ d), Pell.Solution₁.x a ≠ 0 :=\n\n/-- A quadratic has no root if its discriminant has no square root. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {a b c : R},\n  (∀ (s : R), discrim a b c ≠ s ^ 2) → ∀ (x : R), a * x * x + b * x + c ≠ 0 :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- A transcendental real number is irrational. -/\ntheorem ∀ {r : ℝ}, Transcendental ℚ r → Irrational r :=\n\n/-- No zero divisors. -/\ntheorem ∀ {α : Type u_1} [self : CanonicallyOrderedCommSemiring α] {a b : α}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- The ring of integers of a number field is not a field. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], ¬IsField { x // x ∈ NumberField.ringOfIntegers K } :=\n\n/-- Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers. -/\ntheorem",
    "choices": [
      "∀ {x y : ℤ}, 7 * x ^ 3 + 2 ≠ y ^ 3 ",
      "∀ (x y : ℤ), 7 * x^3 + 2 ≠ y^3 ",
      "∀ (x y : ℤ), 7 * x ^ 3 + 2 ≠ y ^ 3 ",
      "∀ (x y : ℤ), 7 * x ^ 3 + 2 ≠ y ^ 3 ",
      "∀ (x y : ℤ), 7 * x ^ 3 + 2 ≠ y ^ 3 ",
      "∀ (x y : ℤ), 7 * x^3 + 2 ≠ y^3 ",
      "∀ (x y : ℤ), 7 * x ^ 3 + 2 ≠ y ^ 3 ",
      "∀ {x y : ℤ}, 7 * x ^ 3 + 2 ≠ y ^ 3 ",
      "∀ (x y : ℤ), 7 * x ^ 3 + 2 ≠ y ^ 3 ",
      "∀ (x y : ℤ), 7 * x ^ 3 + 2 ≠ y ^ 3 "
    ]
  },
  {
    "docString": "Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem ∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1 :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$. -/\ntheorem",
    "choices": [
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (p - 1) ∣ (q - 1) → Nat.Coprime n (p * q) → n ^ (q - 1) ≡ 1 [MOD (p * q)] ",
      "∀ {p q n : ℕ}, Nat.Prime p → Nat.Prime q → p ≠ q → ((p - 1) ∣ (q - 1)) → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 ",
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (p - 1) ∣ (q - 1) → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 ",
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p ≠ q → p % 2 = 1 → q % 2 = 1 → (p - 1) ∣ (q - 1) → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 ",
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (p - 1) ∣ (q - 1) → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 ",
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (q - 1) % (p - 1) = 0 → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 ",
      "∀ {p q n : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (p - 1) ∣ (q - 1) → Nat.Coprime n (p * q) → n ^ (q - 1) ≡ 1 [MOD (p * q)] ",
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (q - 1) % (p - 1) = 0 → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 ",
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (p - 1) ∣ (q - 1) → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 ",
      "∀ {p q n : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → (p - 1) ∣ (q - 1) → Nat.Coprime n (p * q) → (n ^ (q - 1)) % (p * q) = 1 "
    ]
  },
  {
    "docString": "Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 ↔ ¬IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {n : ℕ}, jacobiSym a n = -1 → ∃ p x, p ∣ n ∧ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"}]\n",
    "prompt_cons": "/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = -1 ↔ ¬IsSquare ↑a :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem ∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If `a : ZMod p` is nonzero, then `a^(p/2)` is either `1` or `-1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1 :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem ∀ {a : ℤ} {n : ℕ}, jacobiSym a n = -1 → ∃ p x, p ∣ n ∧ jacobiSym a p = -1 :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$. -/\ntheorem",
    "choices": [
      "∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → is_primitive_root a p ↔ is_primitive_root (-a) ((p - 1) / 2) ",
      "∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → (IsPrimitiveRoot a p ↔ orderOf (-a) = (p - 1) / 2) ",
      "∀ {p t : ℕ} [inst : Fact (Nat.Prime p)], p = 4 * t + 3 → ∀ {a : ZMod p}, IsPrimitiveRoot a p ↔ orderOf (-a) = (p - 1) / 2 ",
      "forall {a p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → (is_primitive_root a p ↔ is_primitive_root (-a) ((p - 1) / 2)) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p},\n  p % 4 = 3 → (is_primitive_root a p ↔ order_of (-a) = (p - 1) / 2) ",
      "∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → (primitiveRoot a ↑p ↔ orderOf (-a) = (p - 1) / 2) ",
      "∀ {a : ZMod p} {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → (IsPrimitiveRoot a p ↔ orderOf (-a) = (p - 1) / 2) ",
      "forall {p : ℕ} [Fact (Nat.Prime p)], p % 4 = 3 → ∀ {a : ZMod p}, is_primitive_root a p ↔ order_of (-a) = (p - 1) / 2 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, p % 4 = 3 → is_primitive_root a p ↔ (p - 1) / 2 = order_of (-a) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 4 = 3 → ∀ {a : ℕ}, IsPrimitiveRoot a p ↔ a.negation_has_order (p - 1) / 2 "
    ]
  },
  {
    "docString": "Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$.",
    "prompts": "[{\"theorem\":\n  \"∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\\ngroup must itself have order `p-1`, which only happens when `p` is prime.\\n\"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. \"},\n {\"theorem\": \"∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\\n`gcd a p ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p → (p ∣ List.prod L ↔ ∃ a, a ∈ L ∧ p ∣ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` \"}]\n",
    "prompt_cons": "/-- If `a^(p-1) = 1 mod p`, but `a^((p-1)/q) ≠ 1 mod p` for all prime factors `q` of `p-1`, then `p`\nis prime. This is true because `a` has order `p-1` in the multiplicative group mod `p`, so this\ngroup must itself have order `p-1`, which only happens when `p` is prime. -/\ntheorem ∀ (p : ℕ) (a : ZMod p), a ^ (p - 1) = 1 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → Nat.Prime p :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p = 1`, then `a : ZMod p` is nonzero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p = 1 → ↑a ≠ 0 :=\n\n/-- If an integer `a` and a prime `p` satisfy `gcd a p ≠ 1`, then `a : ZMod p` is zero. -/\ntheorem ∀ {a : ℤ} {p : ℕ}, Nat.Prime p → Int.gcd a ↑p ≠ 1 → ↑a = 0 :=\n\n/-- If `p` is a prime and `a` is an integer, then `a : ZMod p` is zero if and only if\n`gcd a p ≠ 1`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [pp : Fact (Nat.Prime p)], ↑a = 0 ↔ Int.gcd a ↑p ≠ 1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem ∀ {a : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], jacobiSym a p = 1 → IsSquare ↑a :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p → (p ∣ List.prod L ↔ ∃ a, a ∈ L ∧ p ∣ a) :=\n\n/-- Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, p ≠ 2 → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → IsPrimitiveRoot a (p - 1) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → IsPrimitiveRoot a (p - 1) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) ↔ IsPrimitiveRoot a p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, Nat.Prime p → (∀ q : ℕ, q ≠ 2 → Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → IsPrimitiveRoot a (p - 1) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, Nat.Coprime (ZMod.val a) p → (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) → IsPrimitiveRoot a p ",
      "∀ {p : ℕ}, Nat.Prime p → ∀ {a : ZMod p}, IsPrimitiveRoot a p ↔ (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, IsPrimitiveRoot a p ↔ (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) ",
      "∀ {p : ℕ}, Nat.Prime p → p % 2 = 1 → ∀ {a : ℕ}, IsPrimitiveRoot a p ↔ (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → (a ^ ((p - 1) / q) : ZMod p) ≠ 1) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, (∃ (n : ℕ), primitiveRoot a (Nat.minFac (p - 1) ^ n)) ↔ (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) ",
      "∀ {p : ℕ} (a : ZMod p) [inst : Fact (Nat.Prime p)], (∀ (q : ℕ), Nat.Prime q → q ∣ p - 1 → a ^ ((p - 1) / q) ≠ 1) ↔ ∀ (k : ℕ), 0 < k → k < p - 1 → a ^ k ≠ 1 "
    ]
  },
  {
    "docString": "Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\": \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first modified cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1\",\n  \"isProp\": true,\n  \"docString\": \"The first cyclotomic polyomial is `X - 1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"}]\n",
    "prompt_cons": "/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- A prime natural number is prime in `ℤ[i]` if and only if it is `3` mod `4` -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)], Prime ↑p ↔ p % 4 = 3 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- The first modified cyclotomic polyomial is `X - 1`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' 1 R = Polynomial.X - 1 :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1 :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- The first cyclotomic polyomial is `X - 1`. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 1 R = Polynomial.X - 1 :=\n\n/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 . -/\ntheorem",
    "choices": [
      "∀ {x p : ℕ}, Nat.Prime p → p ∣ (x ^ 4 - x ^ 2 + 1) → p % 12 = 1 ",
      "∀ {x p : ℕ}, Nat.Prime p → p ∣ (x ^ 4 - x ^ 2 + 1) → p % 12 = 1 ",
      "∀ {x p : ℕ}, Nat.Prime p → p ∣ x ^ 4 - x ^ 2 + 1 → p % 12 = 1 ",
      "∀ {p x : ℕ}, Nat.Prime p → p ∣ (x ^ 4 - x ^ 2 + 1) → p % 12 = 1 ",
      "∀ {x p : ℕ}, Nat.Prime p → p ∣ x ^ 4 - x ^ 2 + 1 → p % 12 = 1 ",
      "∀ {p x : ℕ}, Nat.Prime p → p ∣ (x ^ 4 - x ^ 2 + 1) → p % 12 = 1 ",
      "∀ {x p : ℕ}, Nat.Prime p → p ∣ x ^ 4 - x ^ 2 + 1 → p % 12 = 1 ",
      "∀ {x p : ℕ}, Nat.Prime p → p ∣ x ^ 4 - x ^ 2 + 1 → p % 12 = 1 ",
      "∀ {x p : ℕ}, Nat.Prime p → p ∣ (x ^ 4 - x ^ 2 + 1) → p % 12 = 1 ",
      "∀ {p x : ℕ}, Nat.Prime p → p ∣ x ^ 4 - x ^ 2 + 1 → p % 12 = 1 "
    ]
  },
  {
    "docString": "Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\\nto `3` mod `4`, then `(q / p) = -(p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y ≠ 0 → x ^ 2 = -y ^ 2 → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\\n`p` is a square mod `q`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"}]\n",
    "prompt_cons": "/-- The Law of Quadratic Reciprocity: if `p` and `q` are primes that are both congruent\nto `3` mod `4`, then `(q / p) = -(p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → legendreSym q ↑p = -legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y ≠ 0 → x ^ 2 = -y ^ 2 → p % 4 ≠ 3 :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- If `p` and `q` are odd primes and `p % 4 = 1`, then `q` is a square mod `p` iff\n`p` is a square mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], p % 4 = 1 → q ≠ 2 → (IsSquare ↑q ↔ IsSquare ↑p) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$. -/\ntheorem",
    "choices": [
      "∀ {a p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 → p % 4 = q % 4 → ¬p ∣ a → legendreSym a ↑p = legendreSym a ↑q ",
      "∀ {p q a : ℤ} [inst : Fact (IsCoprime ↑p a)] [inst_1 : Fact (IsCoprime ↑q a)],\n  a < 0 → p % 4 = q % 4 → ¬p ∣ a → legendreSym a p = legendreSym a q ",
      "∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)] {a : ℤ},\n  a < 0 → p ≠ q → p % 4 = q % 4 → ¬p ∣ a → legendreSym a ↑p = legendreSym a ↑q ",
      "∀ {a p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 → p % 4 = q % 4 → ¬(p ∣ a) → legendreSym a p = legendreSym a q ",
      "∀ {p q : ℕ} {a : ℤ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], a < 0 → p % 4 = q % 4 → ¬p ∣ a → ¬q ∣ a → legendreSym a ↑p = legendreSym a ↑q ",
      "∀ {p q : ℕ} {a : ℤ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 → p ≡ q [MOD (4 * a)] → ¬(p ∣ a) → legendreSym a ↑p = legendreSym a ↑q ",
      "∀ {a p q : ℤ} [inst : Fact (p % 4 = q % 4)] [inst_1 : Fact (Nat.Coprime (Int.natAbs a) (Int.natAbs p))],\n  a < 0 → legendreSym a p = legendreSym a q ",
      "forall {p q a : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 → p % (4 * a) = q % (4 * a) → ¬ (p ∣ a) → legendreSym a ↑p = legendreSym a ↑q ",
      "forall {p q a : ℤ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  a < 0 → p % (4 * a) = q % (4 * a) → ¬p ∣ a → legendreSym a p = legendreSym a q ",
      "∀ {p q a : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)], a < 0 → p % (4 * a) = q % (4 * a) → ¬(p ∣ a) → legendreSym a ↑p = legendreSym a ↑q "
    ]
  },
  {
    "docString": "Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.",
    "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0\",\n  \"isProp\": true,\n  \"docString\":\n  \"if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α}, 2 ≤ a → (1 - 1 / a)⁻¹ ≤ 2\",\n  \"isProp\": true,\n  \"docString\": \"An inequality involving `2`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\\n    1 ≤ b\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that the integer parts of the continued fraction are at least one. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c\",\n  \"isProp\": true,\n  \"docString\":\n  \"We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. \"},\n {\"theorem\": \"∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b\",\n  \"isProp\": true,\n  \"docString\":\n  \"a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem ∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- if we have a solution to `a ^ 4 + b ^ 4 = c ^ 2` then there must be a minimal one. -/\ntheorem ∀ {a b c : ℤ}, Fermat42 a b c → ∃ a0 b0 c0, Fermat42.Minimal a0 b0 c0 :=\n\n/-- An inequality involving `2`. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α}, 2 ≤ a → (1 - 1 / a)⁻¹ ≤ 2 :=\n\n/-- Shows that the integer parts of the continued fraction are at least one. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K] {b : K},\n  Stream'.Seq.get? (GeneralizedContinuedFraction.partialDenominators (GeneralizedContinuedFraction.of v)) n = some b →\n    1 ≤ b :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- We can swap `a` and `b` in a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2`. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → Fermat42.Minimal b a c :=\n\n/-- a minimal solution to `a ^ 4 + b ^ 4 = c ^ 2` must have `a` and `b` coprime. -/\ntheorem ∀ {a b c : ℤ}, Fermat42.Minimal a b c → IsCoprime a b :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways. -/\ntheorem",
    "choices": [
      "smallest_positive_integer_expressible_as_sum_of_two_different_integral_cubes_in_two_ways : ∃ a b c d e f : ℤ, a^3 + b^3 = c^3 + d^3 ∧ a ≠ c ∧ b ≠ d ∧ a^3 + b^3 = e^3 + f^3 ∧ e ≠ a ∧ f ≠ b ∧ e ≠ c ∧ f ≠ d ∧ 0 < a^3 + b^3 ∧ a^3 + b^3 = 1729 ",
      "Nat.smallestCubesSumTwoWays1729 : ∃ a b c d : ℕ, a ≠ b ∧ c ≠ d ∧ a^3 + b^3 = c^3 + d^3 ∧ a^3 + b^3 = 1729 ",
      "smallest_1729 : ∃ a b c d : ℕ, a ≠ b ∧ c ≠ d ∧ a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 ∧ 1729 = c ^ 3 + d ^ 3 ",
      "smallest_positive_integer_sum_of_two_different_integral_cubes : ∃ x y z w : ℤ, x ≠ y ∧ z ≠ w ∧ 0 < x ^ 3 + y ^ 3 ∧ x ^ 3 + y ^ 3 = z ^ 3 + w ^ 3 ∧ x ^ 3 + y ^ 3 = 1729 ",
      "smallest_positive_integer_expressible_as_sum_of_two_different_integral_cubes_in_two_ways : ∃ a b c d, a ≠ b ∧ c ≠ d ∧ a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 ∧ a ^ 3 + b ^ 3 = 1729 ",
      "Ramanujan1729 : ∃ x1 y1 x2 y2 : ℤ, x1 ≠ x2 ∧ y1 ≠ y2 ∧ x1 ^ 3 + y1 ^ 3 = 1729 ∧ x2 ^ 3 + y2 ^ 3 = 1729 ",
      "Ramanujan1729 : ∃ a b c d : ℤ, a ≠ c ∧ a ≠ -c ∧ a ≠ b ∧ a ≠ -b ∧ a ^ 3 + b ^ 3 = c ^ 3 + d ^ 3 ∧ 1729 = a ^ 3 + b ^ 3 ",
      "∃ n : ℕ, n > 0 ∧ (∃ a₁ b₁ a₂ b₂ : ℤ, a₁ ≠ a₂ ∧ n = a₁ ^ 3 + b₁ ^ 3 ∧ n = a₂ ^ 3 + b₂ ^ 3) ∧ (∀ k < n, ¬(∃ a₁ b₁ a₂ b₂ : ℤ, a₁ ≠ a₂ ∧ k = a₁ ^ 3 + b₁ ^ 3 ∧ k = a₂ ^ 3 + b₂ ^ 3)) ",
      "smallest_cube_sum_twice : ∃ (a₁ b₁ a₂ b₂ : ℤ), a₁ ≠ a₂ ∧ a₁ ^ 3 + b₁ ^ 3 = a₂ ^ 3 + b₂ ^ 3 ∧ abs (a₁ ^ 3 + b₁ ^ 3) = 1729 ",
      "ℕ1729_is_smallest_positive_integer_expressible_as_sum_of_two_different_integral_cubes_in_two_ways : ∃ a b c d, a ≠ b ∧ c ≠ d ∧ a ^ 3 + b ^ 3 = 1729 ∧ c ^ 3 + d ^ 3 = 1729 ∧ ∀ (p q r s : ℕ), p ^ 3 + q ^ 3 = r ^ 3 + s ^ 3 → (p ^ 3 + q ^ 3) ≤ 1729 "
    ]
  },
  {
    "docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\\n  AnalyticOn ℂ g U →\\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `ℂ`). \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∃ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f ≡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"}]\n",
    "prompt_cons": "/-- If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `ℂ`). -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\n  AnalyticOn ℂ g U →\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s) :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f ≡ v`,\nfor some value `v`. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∃ v, f = Function.const M v :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c :=\n\n/-- If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem ∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant. -/\ntheorem",
    "choices": [
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {Ω : Set E} {f : E → F},\n  AnalyticOn ℂ f Ω →\n    (∀ (z : E), z ∈ Ω → Complex.re (f z) = const) → ∀ (z w : E), z ∈ Ω → w ∈ Ω → f z = f w ",
      "forall {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → ℂ} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ ℂ) f U →\n    IsOpen U → (∀ x ∈ U, (f x).re = (f x).re) → ∀ x y ∈ U, f x = f y ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    IsOpen U → (∀ (x : E), x ∈ U → (f x).re = (f (classical.arbitrary E)).re) → ∀ (x y : E), x ∈ U → y ∈ U → f x = f y ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners ℂ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M → ℂ} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ ℂ) f U → IsOpen U →\n    (∀ (x : M), x ∈ U → ∃ k : ℝ, (f x).re = k) → (∃ k : ℂ, ∀ (x : M), x ∈ U → f x = k) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → ℂ},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → (∀ z : M, (f z).re = (f z).im) → ∀ (a b : M), f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {Ω : Set M} {f : M → ℂ},\n  MDifferentiableOn I (modelWithCornersSelf ℂ ℂ) f Ω →\n    IsOpen Ω → (∀ (x : M), x ∈ Ω → (f x).re = (f ⟨0, 0⟩).re) → ∀ (x y : M), x ∈ Ω → y ∈ Ω → f x = f y ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f Ω →\n    IsOpen Ω → (∀ (z : E), z ∈ Ω → Complex.constRe (f z) = Complex.constRe (f (Classical.choice (Nonempty.some (is_open_nonempty Ω))))) → ∀ (a b : E), a ∈ Ω → b ∈ Ω → f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    IsOpen U → (∀ x ∈ U, Complex.re (f x) = Complex.re (f (Classical.arbitrary E))) → ∀ x ∈ U, f x = f (Classical.arbitrary E) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U →\n    IsOpen U → (∀ x ∈ U, Complex.re (f x) = Complex.re (f (Classical.arbitrary E))) → ∀ x y ∈ U, f x = f y ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → ℂ} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ ℂ) f U →\n  IsOpen U → (∀ x ∈ U, complex.re (f x) = C) → ∀ x y ∈ U, f x = f y "
    ]
  },
  {
    "docString": "Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\\n(pre)connected compact open set, then it is a constant on this set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\\n  AnalyticOn ℂ g U →\\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\\nsense that it maps any open set contained in `U` to an open set in `ℂ`). \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∃ v, f = Function.const M v\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is the constant function `f ≡ v`,\\nfor some value `v`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\\nthen it is a constant function. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\\n  {s : Set E} {x y : E},\\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has zero Fréchet derivative at every point of a convex set,\\nthen it is a constant on this set. \"}]\n",
    "prompt_cons": "/-- If a function `f : M → F` from a complex manifold to a complex normed space is holomorphic on a\n(pre)connected compact open set, then it is a constant on this set. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsCompact U → IsOpen U → a ∈ U → b ∈ U → f a = f b :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- The *open mapping theorem* for holomorphic functions, global version: if a function `g : E → ℂ`\nis analytic on a connected set `U`, then either it is constant on `U`, or it is open on `U` (in the\nsense that it maps any open set contained in `U` to an open set in `ℂ`). -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {g : E → ℂ},\n  AnalyticOn ℂ g U →\n    IsPreconnected U → (∃ w, ∀ (z : E), z ∈ U → g z = w) ∨ ∀ (s : Set E), s ⊆ U → IsOpen s → IsOpen (g '' s) :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function `f : E → F` is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∀ (z w : E), f z = f w :=\n\n/-- A holomorphic function on a compact connected complex manifold is the constant function `f ≡ v`,\nfor some value `v`. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∃ v, f = Function.const M v :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c :=\n\n/-- If `f : 𝕜 → G`, `𝕜 = R` or `𝕜 = ℂ`, is differentiable everywhere and its derivative equal zero,\nthen it is a constant function. -/\ntheorem ∀ {𝕜 : Type u_1} {G : Type u_2} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup G] [inst_2 : NormedSpace 𝕜 G]\n  {f : 𝕜 → G}, Differentiable 𝕜 f → (∀ (x : 𝕜), deriv f x = 0) → ∀ (x y : 𝕜), f x = f y :=\n\n/-- If a function has zero Fréchet derivative at every point of a convex set,\nthen it is a constant on this set. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_2} {G : Type u_3}\n  [inst_2 : IsROrC 𝕜] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup G] [inst_5 : NormedSpace 𝕜 G] {f : E → G}\n  {s : Set E} {x y : E},\n  Convex ℝ s → DifferentiableOn 𝕜 f s → (∀ (x : E), x ∈ s → fderivWithin 𝕜 f s x = 0) → x ∈ s → y ∈ s → f x = f y :=\n\n/-- Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant. -/\ntheorem",
    "choices": [
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsPreconnected U → IsOpen U → a ∈ U → b ∈ U →\n    (∀ x ∈ U, Complex.abs (f x) = Complex.abs (f a)) → f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsOpen U → (∀ (x : M), x ∈ U → Complex.abs (f x) = Complex.abs (f (Classical.arbitrary M))) → ∀ (a b : M), f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsOpen U → a ∈ U → b ∈ U → IsLocallyConstant (Complex.abs ∘ f) → f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U → IsOpen U →\n  (∀ (x : M), x ∈ U → Complex.abs (f x) = Complex.abs (f a)) → a ∈ U → b ∈ U → f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {U : Set E} {f : E → ℂ},\n  AnalyticOn ℂ f U → (∀ (x : E), x ∈ U → Complex.abs (f x) = C) → ∀ (x y : E), x ∈ U → y ∈ U → f x = f y ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M} {a b : M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsOpen U → (∀ (x : M), x ∈ U → Complex.abs (f x) = Complex.abs (f a)) → a ∈ U → b ∈ U → f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M]\n  [inst_7 : ChartedSpace H M] [inst_8 : SmoothManifoldWithCorners I M] {f : M → ℂ} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ ℂ) f U → IsOpen U → IsLocallyConstant (Complex.abs ∘ f) → ∀ (a b : M), f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U →\n    IsOpen U → (∀ (x : M), x ∈ U → Complex.abs (f x) = 1) → ∀ (a b : M), a ∈ U → b ∈ U → f a = f b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F} {U : Set M},\n  MDifferentiableOn I (modelWithCornersSelf ℂ F) f U → IsOpen U →\n    (∀ (x y : M), x ∈ U → y ∈ U → ∥f x∥ = ∥f y∥) → ∀ (x y : M), x ∈ U → y ∈ U → f x = f y ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F} {U : Set E},\n  AnalyticOn ℂ f U → IsOpen U → (∀ (x : E), x ∈ U → Complex.abs (f x) = c) → ∀ (x y : E), x ∈ U → y ∈ U → f x = f y "
    ]
  },
  {
    "docString": "Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ)\",\n  \"isProp\": true,\n  \"docString\": \"Lebesgue dominated convergence theorem for series. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Comparison test of convergence of series of non-negative real numbers. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i\",\n  \"isProp\": true,\n  \"docString\":\n  \"A series whose terms are bounded by the terms of a converging geometric series converges. \"},\n {\"theorem\":\n  \"∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p\",\n  \"isProp\": true,\n  \"docString\": \"Comparison test of convergence of `ℝ≥0`-valued series. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r →\\n    ↑r' < r →\\n      ∃ a,\\n        a ∈ Set.Ioo 0 1 ∧\\n          ∃ C,\\n            C > 0 ∧\\n              ∀ (y : E),\\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\":\n  \"∀ {t : ℝ}, 0 < t → Summable fun n => rexp (-Real.pi * t * (↑n + 1) ^ 2)\",\n  \"isProp\": true,\n  \"docString\": \"The sum defining `zetaKernel₁` is convergent. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\\n  Summable u →\\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Consider a series of functions `∑' n, f n x`. If the series converges at a\\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\\nthen the series converges everywhere. \"}]\n",
    "prompt_cons": "/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- Lebesgue dominated convergence theorem for series. -/\ntheorem ∀ {α : Type u_2} {G : Type u_3} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}\n  {μ : MeasureTheory.Measure α} {ι : Type u_1} [inst_2 : Countable ι] {F : ι → α → G} {f : α → G} (bound : ι → α → ℝ),\n  (∀ (n : ι), MeasureTheory.AEStronglyMeasurable (F n) μ) →\n    (∀ (n : ι), ∀ᵐ (a : α) ∂μ, ‖F n a‖ ≤ bound n a) →\n      (∀ᵐ (a : α) ∂μ, Summable fun n => bound n a) →\n        (MeasureTheory.Integrable fun a => ∑' (n : ι), bound n a) →\n          (∀ᵐ (a : α) ∂μ, HasSum (fun n => F n a) (f a)) → HasSum (fun n => ∫ (a : α), F n a ∂μ) (∫ (a : α), f a ∂μ) :=\n\n/-- Comparison test of convergence of series of non-negative real numbers. -/\ntheorem ∀ {β : Type u_1} {f g : β → ℝ}, (∀ (b : β), 0 ≤ g b) → (∀ (b : β), g b ≤ f b) → Summable f → Summable g :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- A series whose terms are bounded by the terms of a converging geometric series converges. -/\ntheorem ∀ {m : ℝ} {f : ℕ → ℕ}, 1 < m → (∀ (i : ℕ), i ≤ f i) → Summable fun i => 1 / m ^ f i :=\n\n/-- Comparison test of convergence of `ℝ≥0`-valued series. -/\ntheorem ∀ {β : Type u_1} {f g : β → NNReal} {r : NNReal}, (∀ (b : β), g b ≤ f b) → HasSum f r → ∃ p, p ≤ r ∧ HasSum g p :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r →\n    ↑r' < r →\n      ∃ a,\n        a ∈ Set.Ioo 0 1 ∧\n          ∃ C,\n            C > 0 ∧\n              ∀ (y : E),\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n :=\n\n/-- The sum defining `zetaKernel₁` is convergent. -/\ntheorem ∀ {t : ℝ}, 0 < t → Summable fun n => rexp (-Real.pi * t * (↑n + 1) ^ 2) :=\n\n/-- Consider a series of functions `∑' n, f n x`. If the series converges at a\npoint, and all functions in the series are differentiable with a summable bound on the derivatives,\nthen the series converges everywhere. -/\ntheorem ∀ {α : Type u_1} {𝕜 : Type u_2} {E : Type u_3} {F : Type u_4} [inst : IsROrC 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : CompleteSpace F] {u : α → ℝ}\n  [inst_5 : NormedSpace 𝕜 F] {f : α → E → F} {f' : α → E → E →L[𝕜] F} {x₀ : E},\n  Summable u →\n    (∀ (n : α) (x : E), HasFDerivAt (f n) (f' n x) x) →\n      (∀ (n : α) (x : E), ‖f' n x‖ ≤ u n) → (Summable fun n => f n x₀) → ∀ (x : E), Summable fun n => f n x :=\n\n/-- Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle. -/\ntheorem",
    "choices": [
      "∀ {𝕜 : Type u_1} [inst : NondiscreteNormedField 𝕜] {z : 𝕜}, HasComplexAbs z = 1 →\n  Summable (λ n => z ^ n / (↑n ^ 2 : 𝕜)) ",
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : IsROrC 𝕜] {z : 𝕜}, ∥z∥ = 1 →\n  Summable (λ (n : ℕ), z ^ n / ↑(n ^ 2)) ",
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] (z : 𝕜), abs z = 1 → Summable fun n => z ^ n / (n ^ 2 : ℝ) ",
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : IsROrC 𝕜], Summable (λ n => ↑(n ^ 2)⁻¹) →\n  ∀ (z : 𝕜), IsROrC.abs z = 1 → Summable (λ n => z ^ n / ↑(n ^ 2)) ",
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {z : 𝕜}, Complex.abs z = 1 → Summable (λ n => z ^ n / ↑(n ^ 2)) ",
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : IsROrC 𝕜] {z : 𝕜},\n  HasCoeTAux.coe (Complex.abs (coeFn (starRingEnd 𝕜) z)) = 1 → Summable fun n => z ^ n / ↑(n ^ 2) ",
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : IsROrC 𝕜] {z : 𝕜},\n  Complex.abs (coeFn (IsROrC.re 𝕜) z) = 1 →\n    Summable fun n => z ^ n / (coe n ^ 2 : 𝕜) ",
      "∀ {𝕜 : Type u_1} [inst : IsROrC 𝕜] {z : 𝕜}, IsROrC.abs z = 1 → Summable fun n => z^n / (↑n ^ 2) ",
      "∀ {𝕜 : Type u_1} [_inst_1 : NondiscreteNormedField 𝕜] {z : 𝕜}, ∥z∥ = 1 → Summable (λ n => z ^ n / (↑n ^ 2 : 𝕜)) ",
      "∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {z : 𝕜}, ∥z∥ = 1 → Summable fun n => z ^ n / (↑n ^ 2) "
    ]
  },
  {
    "docString": "Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.",
    "prompts": "[{\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are equal on a dense set, then they are equal. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two continuous functions are a.e. equal, then they are equal. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\\n  Continuous f → MeasureTheory.LocallyIntegrable f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function `f` is locally integrable with respect to any locally finite measure. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\\n  (f' : ℂ → ℂ →L[ℝ] E) (z w : ℂ) (s : Set ℂ),\\n  Set.Countable s →\\n    ContinuousOn f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\\n      (∀ (x : ℂ),\\n          x ∈ Set.Ioo (min z.re w.re) (max z.re w.re) ×ℂ Set.Ioo (min z.im w.im) (max z.im w.im) \\\\ s →\\n            HasFDerivAt f (f' x) x) →\\n        MeasureTheory.IntegrableOn (fun z => Complex.I • ↑(f' z) 1 - ↑(f' z) Complex.I)\\n            (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\\n          (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) -\\n                  ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\\n                Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\\n              Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\\n            ∫ (x : ℝ) in z.re..w.re,\\n              ∫ (y : ℝ) in z.im..w.im, Complex.I • ↑(f' (↑x + ↑y * Complex.I)) 1 - ↑(f' (↑x + ↑y * Complex.I)) Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\\n`z w : ℂ`, is *real* differentiable at all but countably many points of the corresponding open\\nrectangle, and $\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}$ is integrable on this rectangle. Then the\\nintegral of `f` over the boundary of the rectangle is equal to the integral of\\n$2i\\\\frac{\\\\partial f}{\\\\partial \\\\bar z}=i\\\\frac{\\\\partial f}{\\\\partial x}-\\\\frac{\\\\partial f}{\\\\partial y}$\\nover the rectangle. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\\n  {f g : X → Y},\\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two functions are a.e. equal on an open set and are continuous on this set, then they are\\nequal on this set. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ\",\n  \"isProp\": true,\n  \"docString\": \"A constant function is uniformly integrable. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\\n  (∀ (u : Set (β × β)),\\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\\n    ContinuousAt f x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A function which can be locally uniformly approximated by functions which are continuous at\\na point is continuous at this point. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  [inst_1 : TopologicalSpace α],\\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A locally uniform limit of continuous functions is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"}]\n",
    "prompt_cons": "/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- If two continuous functions are equal on a dense set, then they are equal. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] {s : Set β},\n  Dense s → ∀ {f g : β → α}, Continuous f → Continuous g → Set.EqOn f g s → f = g :=\n\n/-- If two continuous functions are a.e. equal, then they are equal. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae μ] g → Continuous f → Continuous g → f = g :=\n\n/-- A continuous function `f` is locally integrable with respect to any locally finite measure. -/\ntheorem ∀ {X : Type u_1} {E : Type u_2} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]\n  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]\n  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],\n  Continuous f → MeasureTheory.LocallyIntegrable f :=\n\n/-- Suppose that a function `f : ℂ → E` is continuous on a closed rectangle with opposite corners at\n`z w : ℂ`, is *real* differentiable at all but countably many points of the corresponding open\nrectangle, and $\\frac{\\partial f}{\\partial \\bar z}$ is integrable on this rectangle. Then the\nintegral of `f` over the boundary of the rectangle is equal to the integral of\n$2i\\frac{\\partial f}{\\partial \\bar z}=i\\frac{\\partial f}{\\partial x}-\\frac{\\partial f}{\\partial y}$\nover the rectangle. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] (f : ℂ → E)\n  (f' : ℂ → ℂ →L[ℝ] E) (z w : ℂ) (s : Set ℂ),\n  Set.Countable s →\n    ContinuousOn f (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n      (∀ (x : ℂ),\n          x ∈ Set.Ioo (min z.re w.re) (max z.re w.re) ×ℂ Set.Ioo (min z.im w.im) (max z.im w.im) \\ s →\n            HasFDerivAt f (f' x) x) →\n        MeasureTheory.IntegrableOn (fun z => Complex.I • ↑(f' z) 1 - ↑(f' z) Complex.I)\n            (Set.uIcc z.re w.re ×ℂ Set.uIcc z.im w.im) →\n          (((∫ (x : ℝ) in z.re..w.re, f (↑x + ↑z.im * Complex.I)) -\n                  ∫ (x : ℝ) in z.re..w.re, f (↑x + ↑w.im * Complex.I)) +\n                Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑w.re + ↑y * Complex.I)) -\n              Complex.I • ∫ (y : ℝ) in z.im..w.im, f (↑z.re + ↑y * Complex.I) =\n            ∫ (x : ℝ) in z.re..w.re,\n              ∫ (y : ℝ) in z.im..w.im, Complex.I • ↑(f' (↑x + ↑y * Complex.I)) 1 - ↑(f' (↑x + ↑y * Complex.I)) Complex.I :=\n\n/-- If two functions are a.e. equal on an open set and are continuous on this set, then they are\nequal on this set. -/\ntheorem ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] {m : MeasurableSpace X} [inst_1 : TopologicalSpace Y]\n  [inst_2 : T2Space Y] {μ : MeasureTheory.Measure X} [inst_3 : MeasureTheory.Measure.IsOpenPosMeasure μ] {U : Set X}\n  {f g : X → Y},\n  f =ᶠ[MeasureTheory.Measure.ae (MeasureTheory.Measure.restrict μ U)] g →\n    IsOpen U → ContinuousOn f U → ContinuousOn g U → Set.EqOn f g U :=\n\n/-- A constant function is uniformly integrable. -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {ι : Type u_3} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α)\n  [inst : NormedAddCommGroup β] {p : ENNReal} {g : α → β},\n  1 ≤ p → p ≠ ⊤ → MeasureTheory.Memℒp g p → MeasureTheory.UnifIntegrable (fun x => g) p μ :=\n\n/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : UniformSpace β] {f : α → β} {x : α} [inst_1 : TopologicalSpace α],\n  (∀ (u : Set (β × β)),\n      u ∈ uniformity β → ∃ t, t ∈ nhds x ∧ ∃ F, ContinuousAt F x ∧ ∀ (y : α), y ∈ t → (f y, F y) ∈ u) →\n    ContinuousAt f x :=\n\n/-- A locally uniform limit of continuous functions is continuous. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  [inst_1 : TopologicalSpace α],\n  TendstoLocallyUniformly F f p → (∀ᶠ (n : ι) in p, Continuous (F n)) → ∀ [inst_2 : Filter.NeBot p], Continuous f :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space α] [inst_3 : T2Space β]\n  [inst_4 : AddGroup β] (f : α → β) (F₁ F₂ : α → β),\n  Continuous f →\n  (∀ (x : α), HasDerivAt F₁ (f x) x) → (∀ (x : α), HasDerivAt F₂ (f x) x) → ∃ (C : β), ∀ (x : α), F₁ x = F₂ x + C ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {Ω : Set α} {f : α → β}\n  [inst_2 : AddCommGroup β] {F G : α → β},\n  ContinuousOn f Ω → (∀ x ∈ Ω, HasDerivAt F (f x) x) → (∀ x ∈ Ω, HasDerivAt G (f x) x) → ∃ C : β, ∀ x ∈ Ω, F x = G x + C ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {Ω : Set α}\n  {f F G : α → β},\n  ContinuousOn f Ω → (∀ x ∈ Ω, HasDerivWithinAt F (f x) Ω x) → (∀ x ∈ Ω, HasDerivWithinAt G (f x) Ω x) →\n  (∃ C : β, ∀ x ∈ Ω, F x = G x + C) ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {s : Set α}\n  {f g : α → β} (h₁ : ContinuousOn f s) (h₂ : ContinuousOn g s),\n  (∀ (x : α), x ∈ s → ∃ C : β, ∀ (y : α), y ∈ s → f y = g y + C) → ∀ (x y : α), x ∈ s → y ∈ s → g x = g y → f x = f y ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {Ω : Set α} {f F G : α → β},\n  ContinuousOn f Ω → (∀ x ∈ Ω, HasDerivWithinAt F (f x) Ω x) → (∀ x ∈ Ω, HasDerivWithinAt G (f x) Ω x) →\n  ∃ C : β, ∀ x ∈ Ω, F x = G x + C ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {s : Set α}\n  (fs gs : Set (α → β)), (∀ f ∈ fs, Continuous f) → (∀ g ∈ gs, Continuous g) → \n  (∀ f ∈ fs, ∀ g ∈ gs, ∀ x ∈ s, (∃ c : β, ∀ z ∈ s, f z = g z + c)) →\n  ∃ c : β, ∀ f ∈ fs, ∀ g ∈ gs, ∀ z ∈ s, f z = g z + c ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β]\n  [inst_2 : T2Space β] {Ω : Set α} {f F G : α → β}, ContinuousOn f Ω → IsPrimitiveOn F f Ω → IsPrimitiveOn G f Ω →\n  ∃ (C : β), ∀ (x : α), x ∈ Ω → F x = G x + C ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] (f : α → β) (F G : α → β),\n  (∀ (x : α), ∃ (U : Set α) (H : U ∈ 𝓝 x), (∀ (y : α), y ∈ U → F y = G y)) →\n  Continuous f → (∀ (x : α), ∃ (c : β), ∀ (y : α), (∃ (U : Set α) (H : U ∈ 𝓝 x), (∀ (y : α), y ∈ U → F y = G y)) → F y = G y + c) ",
      "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T2Space β] {Ω : Set α} {F G : α → β} {f : α → β},\n  ContinuousOn f Ω → (∀ x ∈ Ω, HasDerivAt F (f x) x) → (∀ x ∈ Ω, HasDerivAt G (f x) x) → (∃ C : β, ∀ x ∈ Ω, F x = G x + C) ",
      "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f F G : ℝ → E} {Ω : Set ℝ},\n  ContinuousOn f Ω →\n  (∀ (x : ℝ), x ∈ Ω → (∃ C : E, ∀ y ∈ Ω, HasDerivWithinAt G (f y) Ω y ∧ HasDerivWithinAt F (f y) Ω y ∧ G y - F y = C)) →\n  ∃ C : E, ∀ x ∈ Ω, G x - F x = C "
    ]
  },
  {
    "docString": "Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), 0 ≤ x → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), 0 ≤ x → ‖f (↑x * Complex.I)‖ ≤ C) → 0 ≤ z.re → 0 ≤ z.im → ‖f z‖ ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `c < 2`;\\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the first quadrant.\\n\\nThen `‖f z‖` is bounded from above by the same constant on the closed first quadrant. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : DivisionRing R] [inst_2 : ContinuousSub R]\\n  [inst_3 : AddCommGroup M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M] [inst_6 : Module R M]\\n  [inst_7 : ContinuousSMul R M] (f : M →L[R] R), f ≠ 0 → IsOpenMap ↑f\",\n  \"isProp\": true,\n  \"docString\": \"A nonzero continuous linear functional is open. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), 0 ≤ x → f ↑x = 0) →\\n        (∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | 0 ≤ z.re ∧ 0 ≤ z.im}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the first quadrant.\\n\\nThen `f` is equal to zero on the closed first quadrant. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Liouville's theorem**: a complex differentiable bounded function is a constant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {β : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : NormedAddCommGroup β]\\n  {p : ENNReal} {f : α → β},\\n  MeasureTheory.Memℒp f p →\\n    MeasureTheory.StronglyMeasurable f →\\n      ∀ {ε : ℝ}, 0 < ε → ∃ M, 0 < M ∧ MeasureTheory.snorm (Set.indicator {x | M ≤ ↑‖f x‖₊} f) p μ ≤ ENNReal.ofReal ε\",\n  \"isProp\": true,\n  \"docString\":\n  \"This lemma implies that a single function is uniformly integrable (in the probability sense). \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\\n  [inst_5 : NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G), ‖f‖ = 0 ↔ f = 0\",\n  \"isProp\": true,\n  \"docString\": \"A continuous linear map is zero iff its norm vanishes. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\\n  Metric.Bounded s →\\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Ioi 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Ioi 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), 0 ≤ x → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → 0 ≤ z.im → ‖f z‖ ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the second quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\\n  for some `c < 2`;\\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the second quadrant.\\n\\nThen `‖f z‖` is bounded from above by the same constant on the closed second quadrant. \"}]\n",
    "prompt_cons": "/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f :=\n\n/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- **Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the first quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed first quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), 0 ≤ x → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), 0 ≤ x → ‖f (↑x * Complex.I)‖ ≤ C) → 0 ≤ z.re → 0 ≤ z.im → ‖f z‖ ≤ C :=\n\n/-- A nonzero continuous linear functional is open. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : TopologicalSpace R] [inst_1 : DivisionRing R] [inst_2 : ContinuousSub R]\n  [inst_3 : AddCommGroup M] [inst_4 : TopologicalSpace M] [inst_5 : ContinuousAdd M] [inst_6 : Module R M]\n  [inst_7 : ContinuousSMul R M] (f : M →L[R] R), f ≠ 0 → IsOpenMap ↑f :=\n\n/-- **Phragmen-Lindelöf principle** in the first quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open first quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open first quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the first quadrant.\n\nThen `f` is equal to zero on the closed first quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Ioi 0 ×ℂ Set.Ioi 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Ioi 0 ×ℂ Set.Ioi 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), 0 ≤ x → f ↑x = 0) →\n        (∀ (x : ℝ), 0 ≤ x → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | 0 ≤ z.re ∧ 0 ≤ z.im} :=\n\n/-- **Liouville's theorem**: a complex differentiable bounded function is a constant. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type v} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {f : E → F}, Differentiable ℂ f → Metric.Bounded (Set.range f) → ∃ c, ∀ (z : E), f z = c :=\n\n/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem ∀ {α : Type u_2} {β : Type u_1} {m : MeasurableSpace α} (μ : MeasureTheory.Measure α) [inst : NormedAddCommGroup β]\n  {p : ENNReal} {f : α → β},\n  MeasureTheory.Memℒp f p →\n    MeasureTheory.StronglyMeasurable f →\n      ∀ {ε : ℝ}, 0 < ε → ∃ M, 0 < M ∧ MeasureTheory.snorm (Set.indicator {x | M ≤ ↑‖f x‖₊} f) p μ ≤ ENNReal.ofReal ε :=\n\n/-- A continuous linear map is zero iff its norm vanishes. -/\ntheorem ∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : Fintype ι] [inst_1 : NontriviallyNormedField 𝕜]\n  [inst_2 : (i : ι) → NormedAddCommGroup (E i)] [inst_3 : (i : ι) → NormedSpace 𝕜 (E i)] [inst_4 : NormedAddCommGroup G]\n  [inst_5 : NormedSpace 𝕜 G] (f : ContinuousMultilinearMap 𝕜 E G), ‖f‖ = 0 ↔ f = 0 :=\n\n/-- If a set is disjoint of its translates by infinitely many bounded vectors, then it has measure\nzero. This auxiliary lemma proves this assuming additionally that the set is bounded. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : MeasurableSpace E]\n  [inst_3 : BorelSpace E] [inst_4 : FiniteDimensional ℝ E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ] {s : Set E} (u : ℕ → E),\n  Metric.Bounded s →\n    Metric.Bounded (Set.range u) → Pairwise (Disjoint on fun n => {u n} + s) → MeasurableSet s → ↑↑μ s = 0 :=\n\n/-- **Phragmen-Lindelöf principle** in the second quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open second quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open second quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the second quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed second quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Ioi 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Ioi 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), 0 ≤ x → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → 0 ≤ z.im → ‖f z‖ ≤ C :=\n\n/-- Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear. -/\ntheorem",
    "choices": [
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set E} [inst_2 : T2Space E]\n  (hΩ : IsOpen Ω) (φ : E → E), DifferentiableOn ℂ φ Ω → IsBoundedLinearMap ℂ φ →\n    ∃ z₀, z₀ ∈ Ω ∧ φ z₀ = z₀ ∧ HasDerivAt φ 1 z₀ → ∀ z, z ∈ Ω → φ z = z + (φ z₀ - z₀) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set E} {φ : E → ℂ} {z₀ : E},\n  IsOpen Ω →\n    Metric.Bounded Ω →\n      DifferentiableOn ℂ φ Ω →\n        ContinuousOn φ Ω →\n          φ z₀ = z₀ → deriv φ z₀ = 1 →\n            ∃ (a b : ℂ), ∀ (z : E), z ∈ Ω → φ z = a * z + b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : BoundedSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {φ : M → M} {z₀ : M},\n  MDifferentiable I (modelWithCornersSelf ℂ M) φ →\n    φ z₀ = z₀ →\n      MDeriv I (modelWithCornersSelf ℂ M) φ z₀ = 1 →\n        ∀ (z : M), φ z = z₀ + (z - z₀) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f →\n    (∃ z₀, f z₀ = z₀ ∧ HasDerivAt f 1 z₀) →\n      (∀ z : M, IsLinearMap ℂ (λ x, f (z + x) - f z)) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {Ω : Set ℂ} [inst_4 : IsOpen Ω] {f : ℂ → ℂ},\n  MDifferentiableOn ℂ f Ω →\n    Metric.Bounded Ω →\n      (∃ z₀,\n          z₀ ∈ Ω ∧\n            f z₀ = z₀ ∧\n              deriv f z₀ = 1) →\n        ∀ (z : ℂ), z ∈ Ω → f z = z * deriv f z₀ ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : ChartedSpace H M]\n  [inst_8 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f →\n    (∃ z₀, HasMem.Mem z₀ M ∧ f z₀ = z₀ ∧ fderiv ℂ f z₀ = 1) →\n      LinearMap.mkContinuous (fderiv ℂ f) 1 (λ x, norm_le_one _) = 1 ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set ℂ} {f : ℂ → ℂ},\n  IsOpen Ω → Metric.Bounded Ω → DifferentiableOn ℂ f Ω → ContinuousOn f Ω →\n    ∃ z₀ ∈ Ω, f z₀ = z₀ ∧ HasDerivAt f 1 z₀ → ∀ z, z ∈ Ω → ∃ a b, f z = a * z + b ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {Ω : Set M} {φ : M → M},\n  IsOpen Ω → Metric.Bounded Ω →\n    MDifferentiableOn I (modelWithCornersSelf ℂ M) φ Ω →\n      (∀ (x : M), x ∈ Ω → φ x ∈ Ω) →\n        ∀ {z₀ : M}, z₀ ∈ Ω → φ z₀ = z₀ → (mfderiv I (modelWithCornersSelf ℂ M) φ z₀).hasDerivWithinAt 1 (I.source ∩ (Ω ∩ φ ⁻¹' Ω)) →\n          (∀ (z : M), z ∈ Ω → φ z = (fun z => z₀ + 1 * (z - z₀)) z) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {Ω : Set ℂ} {φ : ℂ → ℂ},\n  IsOpen Ω → Metric.Bounded Ω → DifferentiableOn ℂ φ Ω →\n    ContinuousOn φ Ω → (∃ z₀, z₀ ∈ Ω ∧ φ z₀ = z₀ ∧ deriv φ z₀ = 1) → LinearIsometryEquiv.toLinearIsometry (φ.to_linear_map) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {Ω : Set M} {f : M → M},\n  IsOpen Ω →\n    Metric.Bounded Ω →\n      MDifferentiableOn I I f Ω →\n        ContinuousOn f (Closure Ω) →\n          ∃ z₀, z₀ ∈ Ω ∧ f z₀ = z₀ ∧\n            (mfderiv I I f z₀).hasDeriv (1 : ℂ) →\n              ∃ (a b : ℂ), ∀ (z : M), z ∈ Ω → f z = a * z + b "
    ]
  },
  {
    "docString": "Show that $ \\int_{-\\infty}^{\\infty} \\frac{\\cos x}{x^2 + a^2} dx = \\pi \\frac{e^{-a}}{a}$ for $a > 0$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\\nPicard-Lindelöf/Cauchy-Lipschitz theorem. \"},\n {\"theorem\":\n  \"∀ (a : ℝ) {b : ℝ}, 0 < b → MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a)\",\n  \"isProp\": true,\n  \"docString\": \"`exp (-b * x)` is integrable on `(a, ∞)`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\": \"∀ (a : ℝ), Cardinal.mk ↑(Set.Iic a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-∞, a]. \"},\n {\"theorem\": \"∀ (a : ℝ), Cardinal.mk ↑(Set.Iio a) = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the interval (-∞, a). \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {a : ℝ}, a < -1 → ∀ {c : ℝ}, 0 < c → MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `0 < c`, then `(λ t : ℝ, t ^ a)` is integrable on `(c, ∞)` for all `a < -1`. \"},\n {\"theorem\":\n  \"∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral $\\\\oint_{|z-c|=R} \\\\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ},\\n  a ≤ 0 →\\n    ∀ {z : ℂ},\\n      |z.im| ≤ b →\\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\\n$$\\\\left|exp^{a\\\\left(e^{z}+e^{-z}\\\\right)}\\\\right| \\\\le e^{a\\\\cos b \\\\exp^{|re z|}}.$$\\n\"}]\n",
    "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Integral of `|x - a| ^ n` over `Ι a b`. This integral appears in the proof of the\nPicard-Lindelöf/Cauchy-Lipschitz theorem. -/\ntheorem ∀ {a b : ℝ} (n : ℕ), ∫ (x : ℝ) in Ι a b, |x - a| ^ n = |b - a| ^ (n + 1) / (↑n + 1) :=\n\n/-- `exp (-b * x)` is integrable on `(a, ∞)`. -/\ntheorem ∀ (a : ℝ) {b : ℝ}, 0 < b → MeasureTheory.IntegrableOn (fun x => rexp (-b * x)) (Set.Ioi a) :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- The cardinality of the interval (-∞, a]. -/\ntheorem ∀ (a : ℝ), Cardinal.mk ↑(Set.Iic a) = Cardinal.continuum :=\n\n/-- The cardinality of the interval (-∞, a). -/\ntheorem ∀ (a : ℝ), Cardinal.mk ↑(Set.Iio a) = Cardinal.continuum :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If `0 < c`, then `(λ t : ℝ, t ^ a)` is integrable on `(c, ∞)` for all `a < -1`. -/\ntheorem ∀ {a : ℝ}, a < -1 → ∀ {c : ℝ}, 0 < c → MeasureTheory.IntegrableOn (fun t => t ^ a) (Set.Ioi c) :=\n\n/-- Integral $\\oint_{|z-c|=R} \\frac{dz}{z-w} = 2πi$ whenever $|w-c| < R$. -/\ntheorem ∀ {c w : ℂ} {R : ℝ}, w ∈ Metric.ball c R → (∮ (z : ℂ) in C(c, R), (z - w)⁻¹) = 2 * ↑Real.pi * Complex.I :=\n\n/-- A supporting lemma for the **Phragmen-Lindelöf principle** in a horizontal strip. If `z : ℂ`\nbelongs to a horizontal strip `|Complex.im z| ≤ b`, `b ≤ π / 2`, and `a ≤ 0`, then\n$$\\left|exp^{a\\left(e^{z}+e^{-z}\\right)}\\right| \\le e^{a\\cos b \\exp^{|re z|}}.$$ -/\ntheorem ∀ {a b : ℝ},\n  a ≤ 0 →\n    ∀ {z : ℂ},\n      |z.im| ≤ b →\n        b ≤ Real.pi / 2 → ↑Complex.abs (cexp (↑a * (cexp z + cexp (-z)))) ≤ rexp (a * Real.cos b * rexp |z.re|) :=\n\n/-- Show that $ \\int_{-\\infty}^{\\infty} \\frac{\\cos x}{x^2 + a^2} dx = \\pi \\frac{e^{-a}}{a}$ for $a > 0$. -/\ntheorem",
    "choices": [
      "∀ {a : ℝ}, 0 < a → ∫ (x : ℝ) in ℝ, Real.cos x / (x^2 + a^2) = Real.pi * rexp (-a) / a ",
      "∀ {a : ℝ}, a > 0 → ∫ x in Set.Iic ⊤, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * (Real.exp (-a) / a) ",
      "∀ {a : ℝ}, 0 < a → ∫ (x : ℝ) in (-∞, ∞), (Real.cos x) / (x ^ 2 + a ^ 2) = ↑Real.pi * (rexp (-a) / a) ",
      "∀ {a : ℝ}, 0 < a → (∫ (x : ℝ) in -∞..∞, (Real.cos x) / (x^2 + a^2)) = Real.pi * (rexp (-a)) / a ",
      "∀ {a : ℝ}, 0 < a → ∫ (x : ℝ) in ℝ, (Real.cos x) / (x^2 + a^2) = Real.pi * (Real.exp (-a) / a) ",
      "∀ {a : ℝ}, 0 < a → ∫ (x : ℝ) in Set.univ, (Real.cos x) / (x^2 + a^2) = Real.pi * (Real.exp (-a) / a) ",
      "∀ {a : ℝ}, 0 < a → ∫ (x : ℝ) in Set.univ, (Real.cos x) / (x ^ 2 + a ^ 2) = Real.pi * (Real.exp (-a) / a) ",
      "∀ {a : ℝ}, a > 0 →\n  (∫ (x : ℝ) in Set.univ, Real.cos x / (x^2 + a^2)) = ↑Real.pi * rexp (-a) / a ",
      "∀ {a : ℝ}, a > 0 → ∫ (x : ℝ) in Set.Iic ⊤, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a ",
      "∀ {a : ℝ}, a > 0 → ∫ (x : ℝ) in ℝ, Real.cos x / (x ^ 2 + a ^ 2) = Real.pi * rexp (-a) / a "
    ]
  },
  {
    "docString": "Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"∀ {x : ℝ}, |x| < 1 → HasSum (fun k => 2 * (1 / (2 * ↑k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. \"},\n {\"theorem\":\n  \"∀ (x : ℝ), Real.cos x ≠ 0 → deriv (fun y => Real.tan y - y) x = ↑1 / Real.cos x ^ 2 - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ),\\n  ∫ (x : ℝ) in a..b, Real.sin x ^ (n + 2) =\\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (↑n + 2) +\\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `sin x ^ n` for any natural `n ≥ 2`. \"},\n {\"theorem\": \"∀ {x : ℝ}, 0 < x → Real.sin x < x\",\n  \"isProp\": true,\n  \"docString\": \"For 0 < x, we have sin x < x. \"},\n {\"theorem\": \"∀ (x : ℝ), 0 < x → x ≤ 1 → |Real.log x * x| < 1\",\n  \"isProp\": true,\n  \"docString\": \"Bound for `|log x * x|` in the interval `(0, 1]`. \"},\n {\"theorem\": \"∀ {x : ℝ}, 0 < x → x < Real.pi / 2 → x < Real.tan x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `0 < x < π/2` we have `x < tan x`.\\n\\nThis is proved by checking that the function `tan x - x` vanishes\\nat zero and has non-negative derivative. \"},\n {\"theorem\":\n  \"∀ {a b : ℝ} (n : ℕ),\\n  ∫ (x : ℝ) in a..b, Real.cos x ^ (n + 2) =\\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (↑n + 2) +\\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.cos x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"The reduction formula for the integral of `cos x ^ n` for any natural `n ≥ 2`. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `ζ(0) = -1 / 2`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\\nwhich is studied in `Data.Real.Pi.Wallis` and other places. \"}]\n",
    "prompt_cons": "/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. -/\ntheorem ∀ {x : ℝ}, |x| < 1 → HasSum (fun k => 2 * (1 / (2 * ↑k + 1)) * x ^ (2 * k + 1)) (Real.log (1 + x) - Real.log (1 - x)) :=\n\n/-- The derivative of `tan x - x` is `1/(cos x)^2 - 1` away from the zeroes of cos. -/\ntheorem ∀ (x : ℝ), Real.cos x ≠ 0 → deriv (fun y => Real.tan y - y) x = ↑1 / Real.cos x ^ 2 - 1 :=\n\n/-- The reduction formula for the integral of `sin x ^ n` for any natural `n ≥ 2`. -/\ntheorem ∀ {a b : ℝ} (n : ℕ),\n  ∫ (x : ℝ) in a..b, Real.sin x ^ (n + 2) =\n    (Real.sin a ^ (n + 1) * Real.cos a - Real.sin b ^ (n + 1) * Real.cos b) / (↑n + 2) +\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.sin x ^ n :=\n\n/-- For 0 < x, we have sin x < x. -/\ntheorem ∀ {x : ℝ}, 0 < x → Real.sin x < x :=\n\n/-- Bound for `|log x * x|` in the interval `(0, 1]`. -/\ntheorem ∀ (x : ℝ), 0 < x → x ≤ 1 → |Real.log x * x| < 1 :=\n\n/-- For all `0 < x < π/2` we have `x < tan x`.\n\nThis is proved by checking that the function `tan x - x` vanishes\nat zero and has non-negative derivative. -/\ntheorem ∀ {x : ℝ}, 0 < x → x < Real.pi / 2 → x < Real.tan x :=\n\n/-- The reduction formula for the integral of `cos x ^ n` for any natural `n ≥ 2`. -/\ntheorem ∀ {a b : ℝ} (n : ℕ),\n  ∫ (x : ℝ) in a..b, Real.cos x ^ (n + 2) =\n    (Real.cos b ^ (n + 1) * Real.sin b - Real.cos a ^ (n + 1) * Real.sin a) / (↑n + 2) +\n      (↑n + 1) / (↑n + 2) * ∫ (x : ℝ) in a..b, Real.cos x ^ n :=\n\n/-- We have `ζ(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem ∀ (n : ℕ), ∫ (x : ℝ) in 0 ..Real.pi / 2, Real.cos x ^ n = 1 / 2 * ∫ (x : ℝ) in 0 ..Real.pi, Real.sin x ^ n :=\n\n/-- Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$. -/\ntheorem",
    "choices": [
      "∀ {a b : ℝ},\n  ∫ (x : ℝ) in a..b, Real.log (Real.sin (Real.pi * x)) = - Real.log 2 ",
      "∀ {a b : ℝ},\n  ∫ (x : ℝ) in a..b, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "∀ ε > 0, ∃ δ > 0, ∀ (x : ℝ), 0 < x → x < δ → |∫ (t : ℝ) in 0..x, Real.log (Real.sin (Real.pi * t)) - (-Real.log 2)| < ε ",
      "∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 ",
      "∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 ",
      "theorem integral_log_sin_pi_over_pi_eq_neg_log_2 : ∫ (x : ℝ) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "∫ (x : ℝ) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 ",
      "∀ {a b : ℝ},\n  ∫ (x : ℝ) in a..b, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 ",
      "∀ (n : ℕ),\n  ∫ (x : ℝ) in 0..1, Real.log (Real.sin (Real.pi * x)) = -Real.log 2 "
    ]
  },
  {
    "docString": "Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact connected complex manifold is constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A holomorphic function on a compact complex manifold is locally constant. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\\n  0 ≤ R →\\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\\n      Set.Countable s →\\n        ContinuousOn f (Metric.closedBall c R) →\\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\\\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"},\n {\"theorem\":\n  \"∀ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {H : Type uH}\\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Set.EqOn (↑f) 0 s ∧ Set.EqOn (↑f) 1 t ∧ ∀ (x : M), ↑f x ∈ Set.Icc 0 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given two disjoint closed sets in a Hausdorff σ-compact finite dimensional manifold, there\\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\\nother. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"On an empty space, bounded continuous functions are at distance 0. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\\n  Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\": \"Proof of the continuity of the map. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\\n  UniformContinuous self.toFun\",\n  \"isProp\": true,\n  \"docString\": \"Uniform continuity of the function \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K)\",\n  \"isProp\": true,\n  \"docString\": \"A continuous function is bounded below on a compact set. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"A differentiable function maps sets of measure zero to sets of measure zero. \"}]\n",
    "prompt_cons": "/-- A holomorphic function on a compact connected complex manifold is constant. -/\ntheorem ∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ∀ (a b : M), f a = f b :=\n\n/-- A holomorphic function on a compact complex manifold is locally constant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_2} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → IsLocallyConstant f :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\n  0 ≤ R →\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\n      Set.Countable s →\n        ContinuousOn f (Metric.closedBall c R) →\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0 :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r) :=\n\n/-- Given two disjoint closed sets in a Hausdorff σ-compact finite dimensional manifold, there\nexists an infinitely smooth function that is equal to `0` on one of them and is equal to one on the\nother. -/\ntheorem ∀ {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {H : Type uH}\n  [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type uM} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : T2Space M]\n  [inst_8 : SigmaCompactSpace M] {s t : Set M},\n  IsClosed s → IsClosed t → Disjoint s t → ∃ f, Set.EqOn (↑f) 0 s ∧ Set.EqOn (↑f) 1 t ∧ ∀ (x : M), ↑f x ∈ Set.Icc 0 1 :=\n\n/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : PseudoMetricSpace β]\n  {f g : BoundedContinuousFunction α β} [inst_2 : IsEmpty α], dist f g = 0 :=\n\n/-- Proof of the continuity of the map. -/\ntheorem ∀ {F : Type u_1} {A : outParam (Type u_2)} {B : outParam (Type u_3)} [inst : Monoid A] [inst_1 : Monoid B]\n  [inst_2 : TopologicalSpace A] [inst_3 : TopologicalSpace B] [self : ContinuousMonoidHomClass F A B] (f : F),\n  Continuous ↑f :=\n\n/-- Uniform continuity of the function -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (self : α ≃ᵤ β),\n  UniformContinuous self.toFun :=\n\n/-- A continuous function is bounded below on a compact set. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : TopologicalSpace β] [inst_4 : Nonempty α] {f : β → α} {K : Set β},\n  IsCompact K → ContinuousOn f K → BddBelow (f '' K) :=\n\n/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {s : Set E}\n  {f : E → E} [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (μ : MeasureTheory.Measure E)\n  [inst_5 : MeasureTheory.Measure.IsAddHaarMeasure μ], DifferentiableOn ℝ f s → ↑↑μ s = 0 → ↑↑μ (f '' s) = 0 :=\n\n/-- Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$. -/\ntheorem",
    "choices": [
      "∀ {E : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_1} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] [inst_10 : PreconnectedSpace M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ContinuousOn f (Set.Ioo (-1) 1) → (∃ z : M, f z ≠ 1/z) ",
      "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {H : Type u_1} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners ℂ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_2} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {f : M → ℂ},\n  MDifferentiable I (modelWithCornersSelf ℂ ℂ) f →\n  ContinuousOn f (Subtype.mk (circleMap (0 : ℂ) 1) circle_map_mem_sphere) ∧\n  ∀ (z : M), z ∈ Subtype.mk (circleMap (0 : ℂ) 1) circle_map_mem_sphere → f z = 1 / z → False ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners ℂ E H} {M : Type u_3} [inst_3 : TopologicalSpace M] [inst_4 : ChartedSpace H M]\n  [inst_5 : SmoothManifoldWithCorners I M] {D : Set M} {f : M → ℂ},\n  D = Metric.ClosedBall (0 : ℂ) 1 →\n  ContinuousOn f D →\n  (∀ z : ℂ, z ∈ Metric.Sphere (0 : ℂ) 1 → f ⟨z, Subtype.prop z⟩ = z⁻¹) → False ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_2} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {H : Type u_3} [inst_4 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_5 : ModelWithCorners.Boundaryless I] {M : Type u_4} [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] {f : M → F},\n  MDifferentiable I (modelWithCornersSelf ℂ F) f → ContinuousOn f (HasCompl.compl (Metric.ball 0 1)) →\n  (∀ (z : M), ∥z∥ = 1 → f z = powZeroClass.inv z) → False ",
      "∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners ℂ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : CompactSpace M] [inst_6 : ChartedSpace H M] [inst_7 : SmoothManifoldWithCorners I M] {f : M → ℂ},\n  ContinuousOn f (PartialBoundary D) → (∀ (z : ℂ), z ∈ PartialBoundary D → f z = 1 / z) → False ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : FiniteDimensional ℂ E]\n  {H : Type u_2} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ℂ E H} {M : Type u_3}\n  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M]\n  [inst_7 : CompactSpace M] {f : M → ℂ},\n  ContinuousOn f (Metric.Sphere 0 1) →\n    (∀ (z : ℂ), z ∈ Metric.Sphere 0 1 → f z = z⁻¹) → False ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {H : Type u_2} [inst_2 : TopologicalSpace H]\n  {I : ModelWithCorners ℂ E H} [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : CompactSpace M] [inst_8 : PreconnectedSpace M]\n  {f : M → ℂ}, MDifferentiable I (modelWithCornersSelf ℂ ℂ) f →\n    ContinuousOn f (Frontier (Metric.closedBall (0 : M) 1)) →\n      (∀ (z : M), z ∈ Frontier (Metric.closedBall 0 1) → f z = Complex.inv z) → False ",
      "∀ { E : Type u_1 } [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] { F : Type u_4 } [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] { H : Type u_2 } [inst_4 : TopologicalSpace H] { I : ModelWithCorners ℂ E H }\n  [inst_5 : ModelWithCorners.Boundaryless I] { M : Type u_3 } [inst_6 : TopologicalSpace M] [inst_7 : CompactSpace M]\n  [inst_8 : ChartedSpace H M] [inst_9 : SmoothManifoldWithCorners I M] { f : M → F },\n  ContinuousOn f (Metric.Sphere 0 1) →\n  (∀ (z : ℂ), z ∈ Metric.Sphere 0 1 → f z = 1/z) →\n  ¬(∃ (g : M → F), MDifferentiable I (modelWithCornersSelf ℂ F) g ∧ ContinuousOn g (Metric.ClosedBall 0 1) ∧\n    ∀ (z : ℂ), z ∈ Metric.Sphere 0 1 → g z = f z) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {F : Type u_4} [inst_2 : NormedAddCommGroup F]\n  [inst_3 : NormedSpace ℂ F] {D : Set ℂ} (hD : IsOpen D) {f : ℂ → F} (hf : DifferentiableOn ℂ f D),\n  ContinuousOn f (Closure D) → (∀ (z : ℂ), z ∈ Frontier D → f z = z⁻¹) → False ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {H : Type u_2} [inst_2 : TopologicalSpace H] {I : ModelWithCorners ℂ E H}\n  [inst_3 : ModelWithCorners.Boundaryless I] {M : Type u_3} [inst_4 : TopologicalSpace M] [inst_5 : CompactSpace M]\n  [inst_6 : ChartedSpace H M] [inst_7 : SmoothManifoldWithCorners I M] {f : M → ℂ},\n  ContinuousOn f (Metric.sphere 0 1) →\n    (∀ (z : ℂ), z ∈ Metric.sphere 0 1 → f z = 1 / z) → False "
    ]
  },
  {
    "docString": "For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$",
    "prompts": "[{\"theorem\": \"∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` plus its conjugate `conj z` is `2` times its real part. \"},\n {\"theorem\": \"∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y ≠ 0 → x ^ 2 = -y ^ 2 → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : IsROrC K] (z : K),\\n  List.TFAE [↑(starRingEnd K) z = z, ∃ r, ↑r = z, ↑(↑IsROrC.re z) = z, ↑IsROrC.im z = 0]\",\n  \"isProp\": true,\n  \"docString\":\n  \"There are several equivalent ways to say that a number `z` is in fact a real number. \"},\n {\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. \"},\n {\"theorem\": \"∀ (n : ℕ), riemannZeta (-2 * (↑n + 1)) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The trivial zeroes of the zeta function. \"},\n {\"theorem\": \"Cardinal.mk ↑Set.univ = Cardinal.continuum\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the complex numbers, as a set. \"},\n {\"theorem\":\n  \"∀ {a b : ℕ}, a % 4 = 3 → b % 4 = 3 → jacobiSym (↑a) b = -jacobiSym (↑b) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `ζ(0) = -1 / 2`. \"}]\n",
    "prompt_cons": "/-- A complex number `z` plus its conjugate `conj z` is `2` times its real part. -/\ntheorem ∀ (z : ℂ), ↑z.re = (z + ↑(starRingEnd ℂ) z) / 2 :=\n\n/-- A complex number `z` minus its conjugate `conj z` is `2i` times its imaginary part. -/\ntheorem ∀ (z : ℂ), ↑z.im = (z - ↑(starRingEnd ℂ) z) / (2 * Complex.I) :=\n\n/-- If two nonzero squares are negatives of each other in `ZMod p`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {x y : ZMod p}, y ≠ 0 → x ^ 2 = -y ^ 2 → p % 4 ≠ 3 :=\n\n/-- There are several equivalent ways to say that a number `z` is in fact a real number. -/\ntheorem ∀ {K : Type u_1} [inst : IsROrC K] (z : K),\n  List.TFAE [↑(starRingEnd K) z = z, ∃ r, ↑r = z, ↑(↑IsROrC.re z) = z, ↑IsROrC.im z = 0] :=\n\n/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- `-1` is a square in `ZMod p` iff `p` is not congruent to `3` mod `4`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], IsSquare (-1) ↔ p % 4 ≠ 3 :=\n\n/-- The trivial zeroes of the zeta function. -/\ntheorem ∀ (n : ℕ), riemannZeta (-2 * (↑n + 1)) = 0 :=\n\n/-- The cardinality of the complex numbers, as a set. -/\ntheorem Cardinal.mk ↑Set.univ = Cardinal.continuum :=\n\n/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. -/\ntheorem ∀ {a b : ℕ}, a % 4 = 3 → b % 4 = 3 → jacobiSym (↑a) b = -jacobiSym (↑b) a :=\n\n/-- We have `ζ(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$ -/\ntheorem",
    "choices": [
      "∀ (z1 z2 z3 z4 : ℂ), Complex.abs z1 = 1 → Complex.abs z2 = 1 → Complex.abs z3 = 1 → Complex.abs z4 = 1 → z1 ≠ 1 → z2 ≠ 1 → z3 ≠ 1 → z4 ≠ 1 → (3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4) ≠ 0 ",
      "∀ (z₁ z₂ z₃ z₄ : ℂ), Complex.abs z₁ = 1 → Complex.abs z₂ = 1 → Complex.abs z₃ = 1 → Complex.abs z₄ = 1 →\nz₁ ≠ 1 → z₂ ≠ 1 → z₃ ≠ 1 → z₄ ≠ 1 → 3 - z₁ - z₂ - z₃ - z₄ + z₁ * z₂ * z₃ * z₄ ≠ 0 ",
      "∀ (z1 z2 z3 z4 : ℂ), abs z1 = 1 → z1 ≠ 1 → abs z2 = 1 → z2 ≠ 1 → abs z3 = 1 → z3 ≠ 1 → abs z4 = 1 → z4 ≠ 1 → 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 ≠ 0 ",
      "∀ (z1 z2 z3 z4 : ℂ), Complex.abs z1 = 1 → z1 ≠ 1 → Complex.abs z2 = 1 → z2 ≠ 1 → Complex.abs z3 = 1 → z3 ≠ 1 → Complex.abs z4 = 1 → z4 ≠ 1 → 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 ≠ 0 ",
      "∀ {z1 z2 z3 z4 : ℂ}, Complex.abs z1 = 1 → z1 ≠ 1 → Complex.abs z2 = 1 → z2 ≠ 1 → Complex.abs z3 = 1 → z3 ≠ 1 → Complex.abs z4 = 1 → z4 ≠ 1 → 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 ≠ 0 ",
      "∀ (z1 z2 z3 z4 : ℂ), Complex.abs z1 = 1 → Complex.abs z2 = 1 → Complex.abs z3 = 1 → Complex.abs z4 = 1 → z1 ≠ 1 → z2 ≠ 1 → z3 ≠ 1 → z4 ≠ 1 → 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 ≠ 0 ",
      "∀ (z1 z2 z3 z4 : ℂ), \n  Complex.abs z1 = 1 ∧ z1 ≠ 1 → \n  Complex.abs z2 = 1 ∧ z2 ≠ 1 → \n  Complex.abs z3 = 1 ∧ z3 ≠ 1 → \n  Complex.abs z4 = 1 ∧ z4 ≠ 1 → \n  3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 ≠ 0 ",
      "∀ {z₁ z₂ z₃ z₄ : ℂ}, Complex.abs z₁ = 1 → z₁ ≠ 1 → Complex.abs z₂ = 1 → z₂ ≠ 1 →\n  Complex.abs z₃ = 1 → z₃ ≠ 1 → Complex.abs z₄ = 1 → z₄ ≠ 1 → \n  3 - z₁ - z₂ - z₃ - z₄ + z₁ * z₂ * z₃ * z₄ ≠ 0 ",
      "∀ (z1 z2 z3 z4 : ℂ), ↑Complex.abs z1 = 1 → z1 ≠ 1 → ↑Complex.abs z2 = 1 → z2 ≠ 1 → ↑Complex.abs z3 = 1 → z3 ≠ 1 → ↑Complex.abs z4 = 1 → z4 ≠ 1 → 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 ≠ 0 ",
      "∀ (z1 z2 z3 z4 : ℂ), Complex.abs z1 = 1 → Complex.abs z2 = 1 → Complex.abs z3 = 1 → Complex.abs z4 = 1 → z1 ≠ 1 → z2 ≠ 1 → z3 ≠ 1 → z4 ≠ 1 → 3 - z1 - z2 - z3 - z4 + z1 * z2 * z3 * z4 ≠ 0 "
    ]
  },
  {
    "docString": "Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z)\",\n  \"isProp\": true,\n  \"docString\": \"If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. \"},\n {\"theorem\":\n  \"∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\\nzero. \"},\n {\"theorem\":\n  \"∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\\npoint `z` of this disk we have `abs (f z) ≤ abs z`. \"},\n {\"theorem\":\n  \"∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\\n  0 ≤ R →\\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\\n      Set.Countable s →\\n        ContinuousOn f (Metric.closedBall c R) →\\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\\\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\\nthen the integral $\\\\oint_{|z-c|=R}f(z)\\\\,dz$ equals zero. \"},\n {\"theorem\":\n  \"∀ {S : Set ℕ+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [self : IsCyclotomicExtension S A B] {n : ℕ+}, n ∈ S → ∃ r, IsPrimitiveRoot r ↑n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. \"},\n {\"theorem\":\n  \"∀ {n : ℤ} {c w : ℂ} {R : ℝ}, n < 0 → w ∈ Metric.sphere c |R| → (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\\ncenter `c` and radius `|R|`, so the integral `∮ z in C(c, R), (z - w) ^ n` is equal to zero. \"},\n {\"theorem\":\n  \"∀ (n : ℕ+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n\",\n  \"isProp\": true,\n  \"docString\": \"`zeta n A B` is a primitive `n`-th root of unity. \"},\n {\"theorem\": \"∀ (n : ℕ), riemannZeta (-2 * (↑n + 1)) = 0\",\n  \"isProp\": true,\n  \"docString\": \"The trivial zeroes of the zeta function. \"},\n {\"theorem\":\n  \"∀ (n : ℕ+) (x : ℂˣ), x ∈ rootsOfUnity n ℂ ↔ ∃ i, i < ↑n ∧ cexp (2 * ↑Real.pi * Complex.I * (↑i / ↑↑n)) = ↑x\",\n  \"isProp\": true,\n  \"docString\":\n  \"The complex `n`-th roots of unity are exactly the\\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\\n  IsPrimitiveRoot ζ n →\\n    ∃ P,\\n      Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' n K ∧\\n        Polynomial.degree P = Polynomial.degree (Polynomial.cyclotomic' n K) ∧ Polynomial.Monic P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\\nmonic polynomial with integer coefficients. \"}]\n",
    "prompt_cons": "/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem ∀ {z : UpperHalfPlane}, z ∈ ModularGroup.fdo → ∀ (n : ℤ), 1 < ↑Complex.normSq ↑(ModularGroup.T ^ n • z) :=\n\n/-- If `n ≠ -1` is an integer number, then the integral of `(z - w) ^ n` over the circle equals\nzero. -/\ntheorem ∀ {n : ℤ}, n ≠ -1 → ∀ (c w : ℂ) (R : ℝ), (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- The **Schwarz Lemma**: if `f : ℂ → ℂ` sends an open disk with center `0` to itself, the for any\npoint `z` of this disk we have `abs (f z) ≤ abs z`. -/\ntheorem ∀ {f : ℂ → ℂ} {z : ℂ} {R : ℝ},\n  DifferentiableOn ℂ f (Metric.ball 0 R) →\n    Set.MapsTo f (Metric.ball 0 R) (Metric.ball 0 R) →\n      f 0 = 0 → ↑Complex.abs z < R → ↑Complex.abs (f z) ≤ ↑Complex.abs z :=\n\n/-- **Cauchy-Goursat theorem** for a disk: if `f : ℂ → E` is continuous on a closed disk\n`{z | ‖z - c‖ ≤ R}` and is complex differentiable at all but countably many points of its interior,\nthen the integral $\\oint_{|z-c|=R}f(z)\\,dz$ equals zero. -/\ntheorem ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {R : ℝ},\n  0 ≤ R →\n    ∀ {f : ℂ → E} {c : ℂ} {s : Set ℂ},\n      Set.Countable s →\n        ContinuousOn f (Metric.closedBall c R) →\n          (∀ (z : ℂ), z ∈ Metric.ball c R \\ s → DifferentiableAt ℂ f z) → (∮ (z : ℂ) in C(c, R), f z) = 0 :=\n\n/-- For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. -/\ntheorem ∀ {S : Set ℕ+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : ℕ+}, n ∈ S → ∃ r, IsPrimitiveRoot r ↑n :=\n\n/-- If `n < 0` and `|w - c| = |R|`, then `(z - w) ^ n` is not circle integrable on the circle with\ncenter `c` and radius `|R|`, so the integral `∮ z in C(c, R), (z - w) ^ n` is equal to zero. -/\ntheorem ∀ {n : ℤ} {c w : ℂ} {R : ℝ}, n < 0 → w ∈ Metric.sphere c |R| → (∮ (z : ℂ) in C(c, R), (z - w) ^ n) = 0 :=\n\n/-- `zeta n A B` is a primitive `n`-th root of unity. -/\ntheorem ∀ (n : ℕ+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n :=\n\n/-- The trivial zeroes of the zeta function. -/\ntheorem ∀ (n : ℕ), riemannZeta (-2 * (↑n + 1)) = 0 :=\n\n/-- The complex `n`-th roots of unity are exactly the\ncomplex numbers of the form `exp (2 * Real.pi * Complex.I * (i / n))` for some `i < n`. -/\ntheorem ∀ (n : ℕ+) (x : ℂˣ), x ∈ rootsOfUnity n ℂ ↔ ∃ i, i < ↑n ∧ cexp (2 * ↑Real.pi * Complex.I * (↑i / ↑↑n)) = ↑x :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then `cyclotomic' n K` comes from a\nmonic polynomial with integer coefficients. -/\ntheorem ∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\n  IsPrimitiveRoot ζ n →\n    ∃ P,\n      Polynomial.map (Int.castRingHom K) P = Polynomial.cyclotomic' n K ∧\n        Polynomial.degree P = Polynomial.degree (Polynomial.cyclotomic' n K) ∧ Polynomial.Monic P :=\n\n/-- Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ}, n > 0 → ∀ (z : ℂ), ↑Complex.abs z ≤ 1 → ¬Polynomial.IsRoot (Polynomial.sum (Finset.range n) (λ (i : ℕ), Polynomial.C (↑(n - i)) * Polynomial.X ^ i)) z ",
      "∀ {n : ℕ}, n > 0 → ∀ (z : ℂ), ↑Complex.abs z ≤ 1 → ¬Polynomial.isRoot (Polynomial.sum (Finset.range n) (λ (i : ℕ), Polynomial.C ((n - i) : ℂ) * Polynomial.x ^ i)) z ",
      "∀ (n : ℕ) {z : ℂ}, ↑Complex.abs z ≤ 1 → (Polynomial.eval z (Finset.sum (Finset.range n) (λ x, Polynomial.monomial (n - 1 - x) (↑x + 1)))) ≠ 0 ",
      "∀ n : ℕ, 0 < n → ∀ (z : ℂ), ↑Complex.abs z ≤ 1 → ¬(∑ (i : ℕ) in range n, (n - i) * z ^ i) = 0 ",
      "∀ {n : ℕ},\n  0 < n →\n    ∀ z : ℂ,\n      ↑Complex.abs z ≤ 1 →\n        ¬ Polynomial.IsRoot (Polynomial.of_finsupp (Finsupp.single n 1 + Finsupp.onFinset (Finset.range n) (λ (i : ℕ), n - i) (_ : ∀ (i : ℕ), i ∈ Finset.range n → True))) z ",
      "∀ {n : ℕ}, n > 0 → ∀ (z : ℂ), ↑Complex.abs z ≤ 1 → ¬IsRoot (Polynomial.monomial (n - 1) 1 + Polynomial.of_finsupp (Finₓ.coe_range n.sub_one)) z ",
      "∀ {n : ℕ} (z : ℂ), n > 0 → ↑Complex.abs z ≤ 1 → ¬(Polynomial.eval z (Polynomial.sumRange (λ i, Polynomial.X ^ i) n) = 0) ",
      "forall {n : ℕ} {z : ℂ}, n > 0 → ↑Complex.abs z ≤ 1 → (finset.range n).sum (λ i, ↑(n - i) * z ^ i) ≠ 0 ",
      "∀ {n : ℕ} (hn : 0 < n), ∀ z : ℂ, ↑Complex.abs z ≤ 1 → ¬Polynomial.isRoot (Polynomial.comp (Polynomial.monomial n 1) (Polynomial.x - Polynomial.C z)) z ",
      "∀ {n : ℕ}, n > 0 → ∀ {z : ℂ}, ↑Complex.abs z ≤ 1 → Polynomial.eval z (Polynomial.sumFinsetRange (n - 1) (λ i => Polynomial.C ((n - 1 - i) + 1) * Polynomial.X ^ i)) ≠ 0 "
    ]
  },
  {
    "docString": "Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ},\\n  CircleIntegrable f c R →\\n    ↑Complex.abs w < R →\\n      HasSum (fun n => ↑(cauchyPowerSeries f c R n) fun x => w)\\n        ((2 * ↑Real.pi * Complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\\nconverges to the Cauchy integral `(2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z` on the open\\ndisc `Metric.ball c R`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ},\\n  CircleIntegrable f c R →\\n    ↑Complex.abs w < R →\\n      HasSum (fun n => ∮ (z : ℂ) in C(c, R), (w / (z - c)) ^ n • (z - c)⁻¹ • f z)\\n        (∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z)\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\\nby `2πI` converges to the integral `∮ z in C(c, R), (z - w)⁻¹ • f z` on the open disc\\n`Metric.ball c R`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → ∀ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function `f` has a power series `p` around `x`, then the function `z ↦ f (z - y)` has the\\nsame power series around `x + y`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] (φ : PowerSeries R), IsUnit φ → IsUnit (↑(PowerSeries.constantCoeff R) φ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a formal power series is invertible, then so is its constant coefficient.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\\n  HasFPowerSeriesOnBall f p x r →\\n    ↑r' < r →\\n      ∃ a,\\n        a ∈ Set.Ioo 0 1 ∧\\n          ∃ C,\\n            C > 0 ∧\\n              ∀ (y : E),\\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion, then it is exponentially close to the partial\\nsums of this power series on strict subdisks of the disk of convergence. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} {r : ENNReal} {f : E → F} {x : E} [inst_5 : CompleteSpace F],\\n  HasFPowerSeriesOnBall f p x r →\\n    HasFPowerSeriesOnBall (fderiv 𝕜 f)\\n      (ContinuousLinearMap.compFormalMultilinearSeries\\n        (↑(ContinuousLinearEquiv.mk (continuousMultilinearCurryFin1 𝕜 E F).toLinearEquiv))\\n        (FormalMultilinearSeries.changeOriginSeries p 1))\\n      x r\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function has a power series on a ball, then so does its derivative. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {φ : PowerSeries R} (h : (PowerSeries.order φ).Dom),\\n  ↑(PowerSeries.coeff R (Part.get (PowerSeries.order φ) h)) φ ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the order of a formal power series is finite,\\nthen the coefficient indexed by the order is nonzero.\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Semiring R] {φ ψ : PowerSeries R},\\n  φ = ψ ↔ ∀ (n : ℕ), ↑(PowerSeries.coeff R n) φ = ↑(PowerSeries.coeff R n) ψ\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two formal power series are equal if all their coefficients are equal.\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum of a converging power series is continuous in its disk of convergence. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function admits a power series expansion on a disk, then it is continuous there. \"}]\n",
    "prompt_cons": "/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R`, `R > 0`,\nconverges to the Cauchy integral `(2 * π * I : ℂ)⁻¹ • ∮ z in C(c, R), (z - w)⁻¹ • f z` on the open\ndisc `Metric.ball c R`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ},\n  CircleIntegrable f c R →\n    ↑Complex.abs w < R →\n      HasSum (fun n => ↑(cauchyPowerSeries f c R n) fun x => w)\n        ((2 * ↑Real.pi * Complex.I)⁻¹ • ∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z) :=\n\n/-- For any circle integrable function `f`, the power series `cauchyPowerSeries f c R` multiplied\nby `2πI` converges to the integral `∮ z in C(c, R), (z - w)⁻¹ • f z` on the open disc\n`Metric.ball c R`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E} {c : ℂ} {R : ℝ} {w : ℂ},\n  CircleIntegrable f c R →\n    ↑Complex.abs w < R →\n      HasSum (fun n => ∮ (z : ℂ) in C(c, R), (w / (z - c)) ^ n • (z - c)⁻¹ • f z)\n        (∮ (z : ℂ) in C(c, R), (z - (c + w))⁻¹ • f z) :=\n\n/-- If a function `f` has a power series `p` around `x`, then the function `z ↦ f (z - y)` has the\nsame power series around `x + y`. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → ∀ (y : E), HasFPowerSeriesOnBall (fun z => f (z - y)) p (x + y) r :=\n\n/-- If a formal power series is invertible, then so is its constant coefficient. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] (φ : PowerSeries R), IsUnit φ → IsUnit (↑(PowerSeries.constantCoeff R) φ) :=\n\n/-- If a function admits a power series expansion, then it is exponentially close to the partial\nsums of this power series on strict subdisks of the disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal} {r' : NNReal},\n  HasFPowerSeriesOnBall f p x r →\n    ↑r' < r →\n      ∃ a,\n        a ∈ Set.Ioo 0 1 ∧\n          ∃ C,\n            C > 0 ∧\n              ∀ (y : E),\n                y ∈ Metric.ball 0 ↑r' → ∀ (n : ℕ), ‖f (x + y) - FormalMultilinearSeries.partialSum p n y‖ ≤ C * a ^ n :=\n\n/-- If a function has a power series on a ball, then so does its derivative. -/\ntheorem ∀ {𝕜 : Type u_2} [inst : NontriviallyNormedField 𝕜] {E : Type u_3} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_1} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} {r : ENNReal} {f : E → F} {x : E} [inst_5 : CompleteSpace F],\n  HasFPowerSeriesOnBall f p x r →\n    HasFPowerSeriesOnBall (fderiv 𝕜 f)\n      (ContinuousLinearMap.compFormalMultilinearSeries\n        (↑(ContinuousLinearEquiv.mk (continuousMultilinearCurryFin1 𝕜 E F).toLinearEquiv))\n        (FormalMultilinearSeries.changeOriginSeries p 1))\n      x r :=\n\n/-- If the order of a formal power series is finite,\nthen the coefficient indexed by the order is nonzero. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {φ : PowerSeries R} (h : (PowerSeries.order φ).Dom),\n  ↑(PowerSeries.coeff R (Part.get (PowerSeries.order φ) h)) φ ≠ 0 :=\n\n/-- Two formal power series are equal if all their coefficients are equal. -/\ntheorem ∀ {R : Type u_1} [inst : Semiring R] {φ ψ : PowerSeries R},\n  φ = ψ ↔ ∀ (n : ℕ), ↑(PowerSeries.coeff R n) φ = ↑(PowerSeries.coeff R n) ψ :=\n\n/-- The sum of a converging power series is continuous in its disk of convergence. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {F : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]\n  {p : FormalMultilinearSeries 𝕜 E F} [inst_5 : CompleteSpace F],\n  ContinuousOn (FormalMultilinearSeries.sum p) (EMetric.ball 0 (FormalMultilinearSeries.radius p)) :=\n\n/-- If a function admits a power series expansion on a disk, then it is continuous there. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField 𝕜] [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {p : FormalMultilinearSeries 𝕜 E F} {x : E} {r : ENNReal},\n  HasFPowerSeriesOnBall f p x r → ContinuousOn f (EMetric.ball x r) :=\n\n/-- Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : Semiring R] (f : PowerSeries R),\n  (∀ (i : ℕ), coeff R i f = 0 ∨ coeff R i f = 1) →\n    f (2 / 3) = 3 / 2 →\n      Irrational (f (1 / 2)) ",
      "Sorry, I can only translate to Lean code for the given examples. Please provide another example related to theorems and I'll be happy to help.",
      "∀ {R : Type u_1} [inst : Field R] {f : PowerSeries R} (H : ∀ (i : ℕ), ↑(PowerSeries.coeff R i) f = 0 ∨ ↑(PowerSeries.coeff R i) f = 1),\n  f (2 / 3) = 3 / 2 → Irrational (f (1 / 2)) ",
      "∀ {R : Type u_1} [inst : Field R] {f : PowerSeries R},\n  (∀ (n : ℕ), ↑(PowerSeries.coeff R n) f = 0 ∨ ↑(PowerSeries.coeff R n) f = 1) →\n    f (2 / 3) = 3 / 2 → Irrational (f (1 / 2)) ",
      "Let R : Type u_1 ",
      "f_01_power_series {R : Type u_1} [inst : Field R] [inst_1 : CharZero R] (φ : PowerSeries R)\n  (h : ∀ (n : ℕ), ↑(PowerSeries.coeff R n) φ = 0 ∨ ↑(PowerSeries.coeff R n) φ = 1) : Prop ",
      "forall (f : ℕ → ℚ),\n  (forall n, f n = 0 ∨ f n = 1) ->\n  (sum (λ n, f n * (2 / 3) ^ n) = 3 / 2) ->\n  not ∃ (a b : ℤ), b ≠ 0 ∧ (sum (λ n, f n * (1 / 2) ^ n) = a / b) ",
      "forall (f : ℝ → ℝ) (c : ℕ → ℝ),\n  (∀ n : ℕ, c n = 0 ∨ c n = 1) →\n  (forall x, has_sum (fun n => c n * x^n) (f x)) →\n  (f (2 / 3) = 3 / 2) →\n  ¬(∃ q : ℚ, f (1 / 2) = q) ",
      "∀ (f : ℕ → ℚ),\n  (∀ n : ℕ, f n = 0 ∨ f n = 1) →\n  (∑' (n : ℕ), f n * (2/3)^n) = 3/2 →\n  ∃ (x : ℝ), x ≠ ↑(∑' (n : ℕ), f n * (1/2)^n) ∧ Irrational x ",
      "forall {R : Type u_1} [inst : Semiring R] {f : PowerSeries R},\n  (∀ (n : ℕ), (PowerSeries.coeff R n f = 0) ∨ (PowerSeries.coeff R n f = 1)) →\n  f (2 / 3) = 3 / 2 →\n  (∃ r : ℚ, f (1 / 2) ≠ r) "
    ]
  },
  {
    "docString": "Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.",
    "prompts": "[{\"theorem\": \"Set.InjOn Nat.factorization {x | x ≠ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonzero natural number has a unique prime factorization \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\": \"∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. \"},\n {\"theorem\": \"∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b+2 expansion of n are all less than b+2 \"},\n {\"theorem\": \"∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b\",\n  \"isProp\": true,\n  \"docString\":\n  \"The digits in the base b expansion of n are all less than b, if b ≥ 2 \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {b : ℕ} {l : List ℕ}, (∀ (x : ℕ), x ∈ l → x < b + 2) → Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l\",\n  \"isProp\": true,\n  \"docString\": \"an n-digit number in base b + 2 is less than (b + 2)^n \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    Odd p →\\n      ∀ {x y : ℤ},\\n        ↑p ∣ x - y →\\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for odd primes. \"}]\n",
    "prompt_cons": "/-- Every nonzero natural number has a unique prime factorization -/\ntheorem Set.InjOn Nat.factorization {x | x ≠ 0} :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem ∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0 :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem ∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p :=\n\n/-- The digits in the base b+2 expansion of n are all less than b+2 -/\ntheorem ∀ {b m d : ℕ}, d ∈ Nat.digits (b + 2) m → d < b + 2 :=\n\n/-- The digits in the base b expansion of n are all less than b, if b ≥ 2 -/\ntheorem ∀ {b m d : ℕ}, 1 < b → d ∈ Nat.digits b m → d < b :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- an n-digit number in base b + 2 is less than (b + 2)^n -/\ntheorem ∀ {b : ℕ} {l : List ℕ}, (∀ (x : ℕ), x ∈ l → x < b + 2) → Nat.ofDigits (b + 2) l < (b + 2) ^ List.length l :=\n\n/-- **Lifting the exponent lemma** for odd primes. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    Odd p →\n      ∀ {x y : ℤ},\n        ↑p ∣ x - y →\n          ¬↑p ∣ x → ∀ (n : ℕ), multiplicity (↑p) (x ^ n - y ^ n) = multiplicity (↑p) (x - y) + multiplicity p n :=\n\n/-- Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime. -/\ntheorem",
    "choices": [
      "∀ (n : ℕ), n > 0 → ¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      " ∀ (n : ℕ), n > 0 → ¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "∀ (n : ℕ), n > 0 → ¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "∀ (n : ℕ), n > 0 → ¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "∀ (n : ℕ), n ≠ 0 → ¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "∀ (n : ℕ), n ≠ 0 → ¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "∀ (n : ℕ), n > 0 → ¬Nat.Prime (10^(10^(10^n)) + 10^(10^n) + 10^n - 1) ",
      "∀ (n : ℕ), n ≠ 0 → ¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "∀ (n : ℕ), n ≠ 0 → ¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) ",
      "∀ (n : ℕ), n > 0 → ¬Nat.Prime (10 ^ (10 ^ (10 ^ n)) + 10 ^ (10 ^ n) + 10 ^ n - 1) "
    ]
  },
  {
    "docString": "Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.",
    "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\": \"∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euclid's theorem on the **infinitude of primes**.\\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, Nat.Prime q → q % 4 = 3 → Even (padicValNat q n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A (positive) natural number `n` is a sum of two squares if and only if the exponent of\\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) \"},\n {\"theorem\": \"∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n\",\n  \"isProp\": true,\n  \"docString\": \"There are no perfect squares strictly between m² and (m+1)² \"},\n {\"theorem\":\n  \"∀ (a b c d x y z w : ℕ),\\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Euler's four-square identity**, a version for natural numbers. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"A sum of numbers is infinite iff one of them is infinite \"},\n {\"theorem\": \"∀ (n : ℕ), 512 ≤ n → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1) :=\n\n/-- Euclid's theorem on the **infinitude of primes**.\nHere given in the form: for every `n`, there exists a prime number `p ≥ n`. -/\ntheorem ∀ (n : ℕ), ∃ p, n ≤ p ∧ Nat.Prime p :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- A (positive) natural number `n` is a sum of two squares if and only if the exponent of\nevery prime `q` such that `q % 4 = 3` in the prime factorization of `n` is even.\n(The assumption `0 < n` is not present, since for `n = 0`, both sides are satisfied;\nthe right hand side holds, since `padicValNat q 0 = 0` by definition.) -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∀ {q : ℕ}, Nat.Prime q → q % 4 = 3 → Even (padicValNat q n) :=\n\n/-- There are no perfect squares strictly between m² and (m+1)² -/\ntheorem ∀ {n m : ℕ}, m * m < n → n < (m + 1) * (m + 1) → ¬∃ t, t * t = n :=\n\n/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem ∀ (a b c d x y z w : ℕ),\n  Int.natAbs (↑a * ↑x - ↑b * ↑y - ↑c * ↑z - ↑d * ↑w) ^ 2 + Int.natAbs (↑a * ↑y + ↑b * ↑x + ↑c * ↑w - ↑d * ↑z) ^ 2 +\n        Int.natAbs (↑a * ↑z - ↑b * ↑w + ↑c * ↑x + ↑d * ↑y) ^ 2 +\n      Int.natAbs (↑a * ↑w + ↑b * ↑z - ↑c * ↑y + ↑d * ↑x) ^ 2 =\n    (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) :=\n\n/-- A sum of numbers is infinite iff one of them is infinite -/\ntheorem ∀ {ι : Type u_2} {M : Type u_1} [inst : AddCommMonoid M] {s : Finset ι} {f : ι → WithTop M},\n  (Finset.sum s fun i => f i) = ⊤ ↔ ∃ i, i ∈ s ∧ f i = ⊤ :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem ∀ (n : ℕ), 512 ≤ n → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n :=\n\n/-- Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers. -/\ntheorem",
    "choices": [
      "∀ (N : ℕ), ∃ n, N ≤ n ∧ (∃ a b, n = a ^ 2 + b ^ 2) ∧ (∃ c d, n + 1 = c ^ 2 + d ^ 2) ∧ (∃ e f, n + 2 = e ^ 2 + f ^ 2) ",
      "∀ N, ∃ n, N ≤ n ∧ (∃ x1 y1, n = x1 ^ 2 + y1 ^ 2) ∧ (∃ x2 y2, n+1 = x2 ^ 2 + y2 ^ 2) ∧ (∃ x3 y3, n+2 = x3 ^ 2 + y3 ^ 2) ",
      "∀ N, ∃ n ≥ N, (∃ x y, n = x ^ 2 + y ^ 2) ∧ (∃ u v, n + 1 = u ^ 2 + v ^ 2) ∧ (∃ r s, n + 2 = r ^ 2 + s ^ 2) ",
      "∀ (M : ℕ), ∃ N, ∀ (n : ℕ), N ≤ n → (∃ x₁ y₁ x₂ y₂ x₃ y₃ : ℕ,\n  n = x₁ ^ 2 + y₁ ^ 2 ∧ n + 1 = x₂ ^ 2 + y₂ ^ 2 ∧ n + 2 = x₃ ^ 2 + y₃ ^ 2) ",
      "∀ (N : ℕ), ∃ n, N ≤ n ∧ (∃ x₁ y₁, n = x₁ ^ 2 + y₁ ^ 2) ∧ (∃ x₂ y₂, n + 1 = x₂ ^ 2 + y₂ ^ 2) ∧ (∃ x₃ y₃, n + 2 = x₃ ^ 2 + y₃ ^ 2) ",
      "∀ N : ℕ, ∃ n : ℕ, N ≤ n ∧ (∃ x y, n = x ^ 2 + y ^ 2) ∧ (∃ u v, n + 1 = u ^ 2 + v ^ 2) ∧ (∃ r s, n + 2 = r ^ 2 + s ^ 2) ",
      "∀ (N : ℕ), ∃ n : ℕ, n ≥ N ∧ (∃ x y, n = x ^ 2 + y ^ 2) ∧ (∃ u v, n + 1 = u ^ 2 + v ^ 2) ∧ (∃ r s, n + 2 = r ^ 2 + s ^ 2) ",
      "∀ (k : ℕ), ∃ n, (∃ x y, n = x ^ 2 + y ^ 2) ∧ (∃ u v, n + 1 = u ^ 2 + v ^ 2) ∧ (∃ r s, n + 2 = r ^ 2 + s ^ 2) ",
      "∀ N, ∃ n ≥ N, (∃ x y, n = x ^ 2 + y ^ 2) ∧ (∃ x y, n + 1 = x ^ 2 + y ^ 2) ∧ (∃ x y, n + 2 = x ^ 2 + y ^ 2) ",
      "∀ N : ℕ, ∃ n, N ≤ n ∧ (∃ x y, n = x ^ 2 + y ^ 2) ∧ (∃ u v, n + 1 = u ^ 2 + v ^ 2) ∧ (∃ r s, n + 2 = r ^ 2 + s ^ 2) "
    ]
  },
  {
    "docString": "Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that",
    "prompts": "[{\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\\n  for some `A`, `B`, and `c < 2`;\\n* `f` is equal to zero on the boundary of the third quadrant.\\n\\nThen `f` is equal to zero on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is also the derivative of `f` at this point. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set ℝ} {e : E} {a : ℝ} {f : ℝ → E},\\n  DifferentiableOn ℝ f s →\\n    ContinuousWithinAt f s a →\\n      s ∈ nhdsWithin a (Set.Ioi a) →\\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) → HasDerivWithinAt f e (Set.Ici a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and\\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set ℝ} {e : E} {a : ℝ} {f : ℝ → E},\\n  DifferentiableOn ℝ f s →\\n    ContinuousWithinAt f s a →\\n      s ∈ nhdsWithin a (Set.Iio a) →\\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Iio a)) (nhds e) → HasDerivWithinAt f e (Set.Iic a) a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and\\nits derivative also converges at `a`, then `f` is differentiable on the left at `a`. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), x ≤ 0 → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → z.im ≤ 0 → ‖f z‖ ≤ C\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\\n\\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\\n  for some `c < 2`;\\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\\n\\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c\",\n  \"isProp\": true,\n  \"docString\":\n  \"A continuous function on a closed interval with `f a = f b` has a local extremum at some\\npoint of the corresponding open interval. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → ∀ (y : ℝ), HasDerivAt f (g y) y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\\ncontinuous at this point, then `g` is the derivative of `f` everywhere. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f g : ℂ → E},\\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\\n    (∃ c,\\n        c < 2 ∧\\n          ∃ B,\\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n              rexp (B * ↑Complex.abs z ^ c)) →\\n      DiffContOnCl ℂ g (Set.Iio 0 ×ℂ Set.Iio 0) →\\n        (∃ c,\\n            c < 2 ∧\\n              ∃ B,\\n                g =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\\n                  rexp (B * ↑Complex.abs z ^ c)) →\\n          (∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) →\\n            (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = g (↑x * Complex.I)) → Set.EqOn f g {z | z.re ≤ 0 ∧ z.im ≤ 0}\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Phragmen-Lindelöf principle** in the third quadrant. Let `f g : ℂ → E` be functions such that\\n\\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\\n  quadrant for some `A`, `B`, and `c < 2`;\\n* `f` is equal to `g` on the boundary of the third quadrant.\\n\\nThen `f` is equal to `g` on the closed third quadrant. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] {f : α → β} {s : Set α} {a : α},\\n  MonotoneOn f s →\\n    s ∈ nhds a →\\n      (∀ (b : β), b < f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo b (f a)) →\\n        (∀ (b : β), b > f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo (f a) b) → ContinuousAt f a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\\nis continuous at `a`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\\n  {f' : E →L[𝕜] F} {a : E},\\n  HasStrictFDerivAt f f' a → ∀ {c : NNReal}, Subsingleton E ∨ 0 < c → ∃ s, s ∈ nhds a ∧ ApproximatesLinearOn f f' s c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\\nwith constant `c` on some neighborhood of `a`. \"}]\n",
    "prompt_cons": "/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp(B * (abs z) ^ c)` on the open third quadrant\n  for some `A`, `B`, and `c < 2`;\n* `f` is equal to zero on the boundary of the third quadrant.\n\nThen `f` is equal to zero on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → f ↑x = 0) →\n        (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = 0) → Set.EqOn f 0 {z | z.re ≤ 0 ∧ z.im ≤ 0} :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is also the derivative of `f` at this point. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → HasDerivAt f (g x) x :=\n\n/-- If a function is differentiable on the right of a point `a : ℝ`, continuous at `a`, and\nits derivative also converges at `a`, then `f` is differentiable on the right at `a`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set ℝ} {e : E} {a : ℝ} {f : ℝ → E},\n  DifferentiableOn ℝ f s →\n    ContinuousWithinAt f s a →\n      s ∈ nhdsWithin a (Set.Ioi a) →\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Ioi a)) (nhds e) → HasDerivWithinAt f e (Set.Ici a) a :=\n\n/-- If a function is differentiable on the left of a point `a : ℝ`, continuous at `a`, and\nits derivative also converges at `a`, then `f` is differentiable on the left at `a`. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {s : Set ℝ} {e : E} {a : ℝ} {f : ℝ → E},\n  DifferentiableOn ℝ f s →\n    ContinuousWithinAt f s a →\n      s ∈ nhdsWithin a (Set.Iio a) →\n        Filter.Tendsto (fun x => deriv f x) (nhdsWithin a (Set.Iio a)) (nhds e) → HasDerivWithinAt f e (Set.Iic a) a :=\n\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f : ℂ → E` be a function such that\n\n* `f` is differentiable in the open third quadrant and is continuous on its closure;\n* `‖f z‖` is bounded from above by `A * exp (B * (abs z) ^ c)` on the open third quadrant\n  for some `c < 2`;\n* `‖f z‖` is bounded from above by a constant `C` on the boundary of the third quadrant.\n\nThen `‖f z‖` is bounded from above by the same constant on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {C : ℝ} {f : ℂ → E} {z : ℂ},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      (∀ (x : ℝ), x ≤ 0 → ‖f ↑x‖ ≤ C) → (∀ (x : ℝ), x ≤ 0 → ‖f (↑x * Complex.I)‖ ≤ C) → z.re ≤ 0 → z.im ≤ 0 → ‖f z‖ ≤ C :=\n\n/-- A continuous function on a closed interval with `f a = f b` has a local extremum at some\npoint of the corresponding open interval. -/\ntheorem ∀ (f : ℝ → ℝ) {a b : ℝ}, a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c, c ∈ Set.Ioo a b ∧ IsLocalExtr f c :=\n\n/-- If a real function `f` has a derivative `g` everywhere but at a point, and `f` and `g` are\ncontinuous at this point, then `g` is the derivative of `f` everywhere. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f g : ℝ → E} {x : ℝ},\n  (∀ (y : ℝ), y ≠ x → HasDerivAt f (g y) y) → ContinuousAt f x → ContinuousAt g x → ∀ (y : ℝ), HasDerivAt f (g y) y :=\n\n/-- **Phragmen-Lindelöf principle** in the third quadrant. Let `f g : ℂ → E` be functions such that\n\n* `f` and `g` are differentiable in the open third quadrant and are continuous on its closure;\n* `‖f z‖` and `‖g z‖` are bounded from above by `A * exp(B * (abs z) ^ c)` on the open third\n  quadrant for some `A`, `B`, and `c < 2`;\n* `f` is equal to `g` on the boundary of the third quadrant.\n\nThen `f` is equal to `g` on the closed third quadrant. -/\ntheorem ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f g : ℂ → E},\n  DiffContOnCl ℂ f (Set.Iio 0 ×ℂ Set.Iio 0) →\n    (∃ c,\n        c < 2 ∧\n          ∃ B,\n            f =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n              rexp (B * ↑Complex.abs z ^ c)) →\n      DiffContOnCl ℂ g (Set.Iio 0 ×ℂ Set.Iio 0) →\n        (∃ c,\n            c < 2 ∧\n              ∃ B,\n                g =O[Filter.comap (↑Complex.abs) Filter.atTop ⊓ Filter.principal (Set.Iio 0 ×ℂ Set.Iio 0)] fun z =>\n                  rexp (B * ↑Complex.abs z ^ c)) →\n          (∀ (x : ℝ), x ≤ 0 → f ↑x = g ↑x) →\n            (∀ (x : ℝ), x ≤ 0 → f (↑x * Complex.I) = g (↑x * Complex.I)) → Set.EqOn f g {z | z.re ≤ 0 ∧ z.im ≤ 0} :=\n\n/-- If `f` is a monotone function on a neighborhood of `a` and the image of this neighborhood under\n`f` meets every interval `(b, f a)`, `b < f a`, and every interval `(f a, b)`, `b > f a`, then `f`\nis continuous at `a`. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : LinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderTopology β] {f : α → β} {s : Set α} {a : α},\n  MonotoneOn f s →\n    s ∈ nhds a →\n      (∀ (b : β), b < f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo b (f a)) →\n        (∀ (b : β), b > f a → ∃ c, c ∈ s ∧ f c ∈ Set.Ioo (f a) b) → ContinuousAt f a :=\n\n/-- If `f` has derivative `f'` at `a` in the strict sense and `c > 0`, then `f` approximates `f'`\nwith constant `c` on some neighborhood of `a`. -/\ntheorem ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}\n  {f' : E →L[𝕜] F} {a : E},\n  HasStrictFDerivAt f f' a → ∀ {c : NNReal}, Subsingleton E ∨ 0 < c → ∃ s, s ∈ nhds a ∧ ApproximatesLinearOn f f' s c :=\n\n/-- Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such that -/\ntheorem",
    "choices": [
      "∀ {f : ℝ → ℝ} {a : ℝ}, HasContDeriv 3 f a → ∃ b, HasDerivAt f (f a) b ",
      "∀ {f : ℝ → ℝ} {a : ℝ},\n  Continuous (deriv^[3]) f →\n    ∃ a, deriv^[3] f a = 0 ∧\n      (∃ x, deriv^[2] f x ≠ 0 ∧ (∃ x', f x' ≠ 0 ∧ (∃ x'', deriv f x'' ≠ 0))) ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n  Continuous (fun x => deriv^[3] f x) → ∃ a, deriv^[2] f a = 0 ∧ HasDerivAt (deriv^[2] f) 0 a ",
      "∀ {f : ℝ → ℝ},\n  ContinuousOn (deriv^[3] f) ℝ → ∃ a, deriv^[2] f a * deriv^[3] f a = 1 + (deriv^[1] f a) ^ 2 ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n  Differentiable ℝ [3] f → ∃ a, deriv^[2] f a = deriv^[3] f a ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n  (∃ (f''': ℝ → E), (∀ x, HasDerivAt f''' (f''' x) x) ∧ Continuous f''') →\n  (∃ a, HasDerivAt f (f''' a) a) ",
      "∀ {f : ℝ → ℝ} {a b : ℝ},\n  a < b →\n    ContinuousOn (deriv^[3]) f (Set.Icc a b) →\n      ∃ x₀, x₀ ∈ Set.Icc a b ∧ deriv^[3] f x₀ = 0 ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E} {a : ℝ},\n  Continuous (deriv^[3] f) → ∃ a, HasDerivAt f (deriv^[2] f a) a ∧ HasDerivAt (deriv f) (deriv^[3] f a) a ",
      "∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {f : ℝ → E},\n  Continuous (deriv^[3]) f →\n  ∃ a, deriv^[2] f a = 0 ∧ deriv f a = deriv f 0 ∧ deriv^[3] f (a / 2) = deriv^[3] f a ",
      "∀ {f : ℝ → ℝ} {a : ℝ}, (ContinuousOn (deriv^[3]) f ⊤) → ∃ a, (deriv^[2]) f a = 0 "
    ]
  },
  {
    "docString": "Let $(p_n)$ be a sequence and $f:\\mathbb{N}\\to\\mathbb{N}$. The sequence $(q_k)_{k\\in\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement.",
    "prompts": "[{\"theorem\":\n  \"∀ {f : ℕ → ℕ}, Function.Injective f → Filter.Tendsto f Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\":\n  \"An injective sequence `f : ℕ → ℕ` tends to infinity at infinity. \"},\n {\"theorem\":\n  \"∀ (f : CircleDeg1Lift) (x : ℝ),\\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `x : ℝ` the sequence $\\\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\\nIn particular, this limit does not depend on `x`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\\n  Function.Injective ↑(Con.kerLift f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {α : Type u_1} [inst : LinearOrder α] {f : Fin n → α}, Tuple.sort f = Equiv.refl (Fin n) ↔ Monotone f\",\n  \"isProp\": true,\n  \"docString\":\n  \"The permutation that sorts `f` is the identity if and only if `f` is monotone. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] {ι : Type u_3}\\n  {l : Filter ι} [inst_1 : Filter.NeBot l] [_i : Fact (1 ≤ p)] {F : ι → { x // x ∈ lp E p }},\\n  Metric.Bounded (Set.range F) → ∀ {f : (a : α) → E a}, Filter.Tendsto (id fun i => ↑(F i)) l (nhds f) → Memℓp f p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b\",\n  \"isProp\": true,\n  \"docString\": \"Every Cauchy sequence has a limit. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} {c : CategoryTheory.Limits.Fork f f},\\n  CategoryTheory.Limits.IsLimit c → CategoryTheory.IsIso (CategoryTheory.Limits.Fork.ι c)\",\n  \"isProp\": true,\n  \"docString\": \"Every equalizer of `(f, f)` is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] {n : ℕ}, 0 < n → Function.Injective ↑(Polynomial.expand R n)\",\n  \"isProp\": true,\n  \"docString\": \"Expansion is injective. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} {c : CategoryTheory.Limits.Cofork f f},\\n  CategoryTheory.Limits.IsColimit c → CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.π c)\",\n  \"isProp\": true,\n  \"docString\": \"Every coequalizer of `(f, f)` is an isomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u_3} [inst : MeasurableSpace α] {E : Type u_2} [inst_1 : MeasurableSpace E] [inst_2 : NormedAddCommGroup E]\\n  [inst_3 : BorelSpace E] [inst_4 : TopologicalSpace.SecondCountableTopology E] {μ : MeasureTheory.Measure α}\\n  [inst_5 : MeasureTheory.IsFiniteMeasure μ] {ι : Type u_1} {f : ι → α → E} {j : ι} {p : ENNReal},\\n  1 ≤ p →\\n    p ≠ ⊤ →\\n      MeasureTheory.Memℒp (f j) p →\\n        (∀ (i : ι), ProbabilityTheory.IdentDistrib (f i) (f j)) → MeasureTheory.UniformIntegrable f p μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequence of identically distributed Lᵖ functions is p-uniformly integrable. \"}]\n",
    "prompt_cons": "/-- An injective sequence `f : ℕ → ℕ` tends to infinity at infinity. -/\ntheorem ∀ {f : ℕ → ℕ}, Function.Injective f → Filter.Tendsto f Filter.atTop Filter.atTop :=\n\n/-- For any `x : ℝ` the sequence $\\frac{f^n(x)-x}{n}$ tends to the translation number of `f`.\nIn particular, this limit does not depend on `x`. -/\ntheorem ∀ (f : CircleDeg1Lift) (x : ℝ),\n  Filter.Tendsto (fun n => (↑(f ^ n) x - x) / ↑n) Filter.atTop (nhds (CircleDeg1Lift.translationNumber f)) :=\n\n/-- A monoid homomorphism `f` induces an injective homomorphism on the quotient by `f`'s kernel. -/\ntheorem ∀ {M : Type u_1} {P : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass P] (f : M →* P),\n  Function.Injective ↑(Con.kerLift f) :=\n\n/-- The permutation that sorts `f` is the identity if and only if `f` is monotone. -/\ntheorem ∀ {n : ℕ} {α : Type u_1} [inst : LinearOrder α] {f : Fin n → α}, Tuple.sort f = Equiv.refl (Fin n) ↔ Monotone f :=\n\n/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem ∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] {ι : Type u_3}\n  {l : Filter ι} [inst_1 : Filter.NeBot l] [_i : Fact (1 ≤ p)] {F : ι → { x // x ∈ lp E p }},\n  Metric.Bounded (Set.range F) → ∀ {f : (a : α) → E a}, Filter.Tendsto (id fun i => ↑(F i)) l (nhds f) → Memℓp f p :=\n\n/-- Every Cauchy sequence has a limit. -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedField α] {β : Type u_2} [inst_1 : Ring β] {abv : β → α}\n  [inst_2 : IsAbsoluteValue abv] [self : CauSeq.IsComplete β abv] (s : CauSeq β abv), ∃ b, s ≈ CauSeq.const abv b :=\n\n/-- Every equalizer of `(f, f)` is an isomorphism. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} {c : CategoryTheory.Limits.Fork f f},\n  CategoryTheory.Limits.IsLimit c → CategoryTheory.IsIso (CategoryTheory.Limits.Fork.ι c) :=\n\n/-- Expansion is injective. -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] {n : ℕ}, 0 < n → Function.Injective ↑(Polynomial.expand R n) :=\n\n/-- Every coequalizer of `(f, f)` is an isomorphism. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] {X Y : C} {f : X ⟶ Y} {c : CategoryTheory.Limits.Cofork f f},\n  CategoryTheory.Limits.IsColimit c → CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.π c) :=\n\n/-- A sequence of identically distributed Lᵖ functions is p-uniformly integrable. -/\ntheorem ∀ {α : Type u_3} [inst : MeasurableSpace α] {E : Type u_2} [inst_1 : MeasurableSpace E] [inst_2 : NormedAddCommGroup E]\n  [inst_3 : BorelSpace E] [inst_4 : TopologicalSpace.SecondCountableTopology E] {μ : MeasureTheory.Measure α}\n  [inst_5 : MeasureTheory.IsFiniteMeasure μ] {ι : Type u_1} {f : ι → α → E} {j : ι} {p : ENNReal},\n  1 ≤ p →\n    p ≠ ⊤ →\n      MeasureTheory.Memℒp (f j) p →\n        (∀ (i : ι), ProbabilityTheory.IdentDistrib (f i) (f j)) → MeasureTheory.UniformIntegrable f p μ :=\n\n/-- Let $(p_n)$ be a sequence and $f:\\mathbb{N}\\to\\mathbb{N}$. The sequence $(q_k)_{k\\in\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement. -/\ntheorem",
    "choices": [
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {f : ℕ → ℕ}\n  (hf : Function.Injective f) {a : ℕ → α}, Filter.Tendsto a Filter.atTop Filter.atTop ↔ Filter.Tendsto (a ∘ f) Filter.atTop Filter.atTop ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] {f : ℕ → ℕ} {hf : Function.Injective f} {p q : ℕ → α},\n  q = λ k, p (f k) → (Filter.Tendsto p Filter.atTop (nhds l) ↔ Filter.Tendsto q Filter.atTop (nhds l)) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {f : ℕ → ℕ}\n  (hf : Function.Injective f) {a : ℕ → α} {l : Filter α}, Filter.Tendsto a Filter.atTop l ↔ Filter.Tendsto (a ∘ f) Filter.atTop l ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] {f : ℕ → α} {g : ℕ → ℕ} (hf : Filter.Tendsto f Filter.atTop (nhds 0))\n  (hg : Function.Injective g), Filter.Tendsto (fun n => f (g n)) Filter.atTop (nhds 0) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {p : ℕ → α} {f : ℕ → ℕ},\n  Function.Injective f → (Filter.Tendsto p Filter.atTop l ↔ Filter.Tendsto (p ∘ f) Filter.atTop l) ",
      "∀ {α : Type} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {p : ℕ → α} {f : ℕ → ℕ},\n  Function.Injective f → Filter.Tendsto p Filter.atTop (nhds (Sup (Set.Range p))) →\n    Filter.Tendsto (p ∘ f) Filter.atTop (nhds (Sup (Set.Range (p ∘ f)))) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {p : ℕ → α} {f : ℕ → ℕ},\n  Function.Injective f → (Filter.Tendsto p Filter.atTop Filter.atTop ↔ Filter.Tendsto (fun k => p (f k)) Filter.atTop Filter.atTop) ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α] {s : ℕ → α} {l : Filter α}\n  (f : ℕ → ℕ), Function.Injective f → Filter.Tendsto s Filter.atTop l ↔ Filter.Tendsto (s ∘ f) Filter.atTop l ",
      "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]\n  {f : ℕ → ℕ} (hf : Function.Injective f) {p : ℕ → α}, Filter.Tendsto p Filter.atTop Filter.atTop → Filter.Tendsto (p ∘ f) Filter.atTop Filter.atTop ",
      "∀ {p : ℕ → ℕ} {f : ℕ → ℕ}, Function.Injective f →\n  ∀ {l : ℕ}, Filter.Tendsto p Filter.atTop (nhds l) → Filter.Tendsto (p ∘ f) Filter.atTop (nhds l) "
    ]
  },
  {
    "docString": "Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\\nby closed sets. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\\n`Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\\n  IsCompact s →\\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. \"},\n {\"theorem\":\n  \"∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : MetricSpace M]\\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\\n  (∀ (i : ι), IsClosed (K i)) →\\n    (∀ (i : ι), IsOpen (U i)) →\\n      (∀ (i : ι), K i ⊆ U i) →\\n        LocallyFinite K → ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `M` be a smooth σ-compact manifold with a metric. Let `K : ι → Set M` be a locally finite\\nfamily of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for all\\n`i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and `x ∈ K i`,\\nwe have `Metric.closedBall x (δ x) ⊆ U i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T0Space α] {f : α → β},\\n  Inducing f → Function.Injective f\",\n  \"isProp\": true,\n  \"docString\": \"A topology `Inducing` map from a T₀ space is injective. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s}\",\n  \"isProp\": true,\n  \"docString\": \"Subsets of a given closed subset form a closed set \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K U : Set α},\\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, IsOpen V ∧ K ⊆ V ∧ closure V ⊆ U ∧ IsCompact (closure V)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a locally compact T₂ space, given a compact set `K` inside an open set `U`, we can find a\\nopen set `V` between these sets with compact closure: `K ⊆ V` and the closure of `V` is inside `U`.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s\",\n  \"isProp\": true,\n  \"docString\": \"In a `T2Space`, every compact set is closed. \"},\n {\"theorem\":\n  \"∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any continuous bijection of compact Hausdorff spaces is an isomorphism. \"}]\n",
    "prompt_cons": "/-- In a metric space (or even a pseudo emetric space), an open set can be approximated from inside\nby closed sets. -/\ntheorem ∀ {X : Type u_1} [inst : PseudoEMetricSpace X] [inst_1 : MeasurableSpace X] (μ : MeasureTheory.Measure X),\n  MeasureTheory.Measure.InnerRegular μ IsClosed IsOpen :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- Let `X` be a metric space. Let `K : ι → Set X` be a locally finite family of closed sets, let\n`U : ι → Set X` be a family of open sets such that `K i ⊆ U i` for all `i`. Then there exists a\npositive continuous function `δ : C(X, ℝ≥0)` such that for any `i` and `x ∈ K i`, we have\n`Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type u_2} {X : Type u_1} [inst : MetricSpace X] {K U : ι → Set X},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : X), 0 < ↑δ x) ∧ ∀ (i : ι) (x : X), x ∈ K i → Metric.closedBall x ↑(↑δ x) ⊆ U i :=\n\n/-- For every finite open cover `Uᵢ` of a compact set, there exists a compact cover `Kᵢ ⊆ Uᵢ`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α},\n  IsCompact s →\n    ∀ {ι : Type u_1} (t : Finset ι) (U : ι → Set α),\n      (∀ (i : ι), i ∈ t → IsOpen (U i)) →\n        s ⊆ ⋃ (i : ι) (_ : i ∈ t), U i →\n          ∃ K, (∀ (i : ι), IsCompact (K i)) ∧ (∀ (i : ι), K i ⊆ U i) ∧ s = ⋃ (i : ι) (_ : i ∈ t), K i :=\n\n/-- Let `M` be a smooth σ-compact manifold with a metric. Let `K : ι → Set M` be a locally finite\nfamily of closed sets, let `U : ι → Set M` be a family of open sets such that `K i ⊆ U i` for all\n`i`. Then there exists a positive smooth function `δ : M → ℝ≥0` such that for any `i` and `x ∈ K i`,\nwe have `Metric.closedBall x (δ x) ⊆ U i`. -/\ntheorem ∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]\n  {H : Type uH} [inst_3 : TopologicalSpace H] (I : ModelWithCorners ℝ E H) {M : Type u_1} [inst_4 : MetricSpace M]\n  [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] [inst_7 : SigmaCompactSpace M] {K U : ι → Set M},\n  (∀ (i : ι), IsClosed (K i)) →\n    (∀ (i : ι), IsOpen (U i)) →\n      (∀ (i : ι), K i ⊆ U i) →\n        LocallyFinite K → ∃ δ, (∀ (x : M), 0 < ↑δ x) ∧ ∀ (i : ι) (x : M), x ∈ K i → Metric.closedBall x (↑δ x) ⊆ U i :=\n\n/-- A topology `Inducing` map from a T₀ space is injective. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : T0Space α] {f : α → β},\n  Inducing f → Function.Injective f :=\n\n/-- Subsets of a given closed subset form a closed set -/\ntheorem ∀ {α : Type u} [inst : EMetricSpace α] {s : Set α}, IsClosed s → IsClosed {t | ↑t ⊆ s} :=\n\n/-- In a locally compact T₂ space, given a compact set `K` inside an open set `U`, we can find a\nopen set `V` between these sets with compact closure: `K ⊆ V` and the closure of `V` is inside `U`. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : T2Space α] {K U : Set α},\n  IsCompact K → IsOpen U → K ⊆ U → ∃ V, IsOpen V ∧ K ⊆ V ∧ closure V ⊆ U ∧ IsCompact (closure V) :=\n\n/-- In a `T2Space`, every compact set is closed. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : T2Space α] {s : Set α}, IsCompact s → IsClosed s :=\n\n/-- Any continuous bijection of compact Hausdorff spaces is an isomorphism. -/\ntheorem ∀ {X Y : CompHaus} (f : X ⟶ Y), Function.Bijective ↑f → CategoryTheory.IsIso f :=\n\n/-- Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$. -/\ntheorem",
    "choices": [
      "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace X], ∃ f : (Set X) → (Set X), Function.Bijective f ∧ (∀ T, IsOpen T → IsClosed (f T)) ∧ (∀ K, IsClosed K → IsOpen (f K)) ",
      "∀ {X : Type u_1} [inst : MetricSpace X], ∃ (φ : (Set X) → (Set X)), (∀ (U : Set X), IsOpen U ↔ IsClosed (φ U)) ∧ (∀ (U : Set X), φ (φ U) = U) ∧ Function.Bijective φ ",
      "∀ {X : Type u_1} [inst : MetricSpace X],\n  ∃ (f : (Set X → Prop) → (Set X → Prop)),\n    Function.Bijective f ∧\n      (∀ (A : Set X → Prop), A ∈ f (λ (s : Set X), IsOpen s) → IsClosed A) ∧\n      (∀ (B : Set X → Prop), B ∈ f (λ (s : Set X), IsClosed s) → IsOpen B) ",
      "∀ {X : Type u_1} [inst : MetricSpace X],\n  ∃ (f : (Set X → Set X) × (Set X → Set X)), (∀ (A : Set X), IsOpen A → IsClosed (f.fst A)) ∧\n    (∀ (B : Set X), IsClosed B → IsOpen (f.snd B)) ∧\n      (∀ (A : Set X), IsOpen A → f.snd (f.fst A) = A) ∧\n        (∀ (B : Set X), IsClosed B → f.fst (f.snd B) = B) ",
      "∀ {M : Type u_1} [inst : MetricSpace M],\n  ∃ (f : Set M → Set M), (∀ (U : Set M), IsOpen U → IsClosed (f U)) ∧ (∀ (K : Set M), IsClosed K → IsOpen (f K)) ∧ Function.Bijective f ",
      "∀ {X : Type u_1} [inst : MetricSpace X],\n  ∃ (ψ : (Set X) → (Set X)), (∀ (U : Set X), IsOpen U ↔ IsClosed (ψ U)) ∧ (∀ (U : Set X), ψ (ψ U) = U) ",
      "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : TopologicalSpace X],\n  ∃ (f : {T : Set X // IsOpen T} ≃ {K : Set X // IsClosed K}),\n    ∀ (T : {T : Set X // IsOpen T}), IsClosed (f T).val ∧ (f T).val = X \\ T.val ",
      "∀ {M : Type u_1} [inst : MetricSpace M] [inst_1 : TopologicalSpace M],\n  ∃ (f : Set M → Set M),\n    (∀ (T : Set M), IsOpen T → IsClosed (f T)) ∧\n      (∀ (K : Set M), IsClosed K → IsOpen (f K)) ∧\n        (∀ (T : Set M), IsOpen T → f (f T) = T) ∧\n          (∀ (K : Set M), IsClosed K → f (f K) = K) ",
      "∀ {X : Type u_1} [inst : MetricSpace X],\n  ∃ (f : {t : Set X // IsOpen t} ≃ {k : Set X // IsClosed k}),\n    ∀ (U : {t : Set X // IsOpen t}), f.to_fun U = {k : Set X // IsClosed k ",
      "∀ {X : Type u_1} [inst : MetricSpace X],\n  ∃ (ϕ : (Set X → Prop) → (Set X → Prop)),\n    (∀ T, IsOpen T → IsClosed (ϕ T)) ∧\n      (∀ K, IsClosed K → IsOpen (ϕ K)) ∧\n        (∀ T K, IsOpen T ∧ IsClosed K → ϕ T = ϕ K → T = K) ∧\n          (∀ T K, IsOpen K ∧ IsClosed T → ϕ K = ϕ T → K = T) "
    ]
  },
  {
    "docString": "Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact.",
    "prompts": "[{\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] (B : ℝ),\\n  Set.Finite {x | IsIntegral ℤ x ∧ ∀ (φ : K →+* A), ‖↑φ x‖ ≤ B}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\\nsmaller in norm than `B` is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddBelow s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded below \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\\n  Metric.Bounded s → IsCompact (closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, IsCompact s → Metric.Bounded s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s\",\n  \"isProp\": true,\n  \"docString\":\n  \"A sequentially compact set in a uniform space is totally bounded. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\\n  IsClosed s → Metric.Bounded s → IsCompact s\",\n  \"isProp\": true,\n  \"docString\":\n  \"The **Heine–Borel theorem**: In a proper space, a closed bounded set is compact. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m0 : MeasurableSpace α} [inst : TopologicalSpace α] {μ : MeasureTheory.Measure α}\\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts μ] ⦃K : Set α⦄, IsCompact K → ↑↑μ K < ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A compact subset has finite measure for a measure which is finite on compacts. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddAbove s\",\n  \"isProp\": true,\n  \"docString\": \"A compact set is bounded above \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Set.Finite s → IsCompact (↑(convexHull ℝ) s)\",\n  \"isProp\": true,\n  \"docString\": \"Convex hull of a finite set is compact. \"}]\n",
    "prompt_cons": "/-- Let `B` be a real number. The set of algebraic integers in `K` whose conjugates are all\nsmaller in norm than `B` is finite. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] (B : ℝ),\n  Set.Finite {x | IsIntegral ℤ x ∧ ∀ (φ : K →+* A), ‖↑φ x‖ ≤ B} :=\n\n/-- A compact set is bounded below -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddBelow s :=\n\n/-- The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\n  Metric.Bounded s → IsCompact (closure s) :=\n\n/-- A compact set is bounded -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α}, IsCompact s → Metric.Bounded s :=\n\n/-- A sequentially compact set in a uniform space is totally bounded. -/\ntheorem ∀ {X : Type u_1} [inst : UniformSpace X] {s : Set X}, IsSeqCompact s → TotallyBounded s :=\n\n/-- The **Heine–Borel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α} [inst_1 : ProperSpace α],\n  IsClosed s → Metric.Bounded s → IsCompact s :=\n\n/-- A compact subset has finite measure for a measure which is finite on compacts. -/\ntheorem ∀ {α : Type u_1} {m0 : MeasurableSpace α} [inst : TopologicalSpace α] {μ : MeasureTheory.Measure α}\n  [inst_1 : MeasureTheory.IsFiniteMeasureOnCompacts μ] ⦃K : Set α⦄, IsCompact K → ↑↑μ K < ⊤ :=\n\n/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- A compact set is bounded above -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderClosedTopology α]\n  [inst_3 : Nonempty α] {s : Set α}, IsCompact s → BddAbove s :=\n\n/-- Convex hull of a finite set is compact. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Set.Finite s → IsCompact (↑(convexHull ℝ) s) :=\n\n/-- Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact. -/\ntheorem",
    "choices": [
      "IsCompact {x : ℝ^m | ∥x∥ ≤ 1} ",
      "∀ {m : ℕ} [inst : NormedGroup (Finₓ m → ℝ)], IsCompact {x : Finₓ m → ℝ | ∥x∥ ≤ 1} ",
      "∀ {m : ℕ} [inst : NormedGroup (Finₓ m → ℝ)] [inst_1 : TopologicalSpace (Finₓ m → ℝ)] [inst_2 : NormedSpace ℝ (Finₓ m → ℝ)],\n  IsCompact {x : Finₓ m → ℝ | ∥x∥ ≤ 1} ",
      "∀ {m : ℕ} [inst : PseudoMetricSpace (fin m → ℝ)], IsCompact {x : fin m → ℝ | ∥x∥ ≤ 1} ",
      "∀ {m : ℕ}, IsCompact {x : ℝ^m | ∥x∥ ≤ 1} ",
      "IsCompact {x : ℝ^m | ∥x∥ ≤ 1} ",
      "∀ {m : ℕ} [inst : EmetricSpace (Fin m → ℝ)], IsCompact {x | ∀ (i : Fin m), |x i| ≤ 1} ",
      "∀ {m : ℕ} [inst : NormedGroup (Finₓ m → ℝ)],\n  IsCompact {x : Finₓ m → ℝ | ∥x∥ ≤ 1} ",
      "∀ {m : ℕ} [inst : NormedGroup ℝ[m]], IsCompact {x : ℝ[m] | ∥x∥ ≤ 1} ",
      "∀ {m : ℕ} [inst : TopologicalSpace (Finₓ m → ℝ)] [inst_1 : MetricSpace (Finₓ m → ℝ)] [inst_2 : ProperSpace (Finₓ m → ℝ)],\n  IsCompact {x : Finₓ m → ℝ | ∀ (i : Finₓ m), |x i| ≤ 1} "
    ]
  },
  {
    "docString": "Show that if $S$ is connected, it is not true in general that its interior is connected.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α\",\n  \"isProp\": true,\n  \"docString\": \"A connected space is nonempty. \"},\n {\"theorem\":\n  \"∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\\n  Convex ℝ s → Set.Nonempty s → IsConnected s\",\n  \"isProp\": true,\n  \"docString\": \"A nonempty convex set is connected. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The directed sUnion of a set S of preconnected subsets is preconnected. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\\n  IsClosed s → ∀ [inst_2 : DiscreteTopology ↑s], Cardinal.continuum ≤ Cardinal.mk ↑s → ¬NormalSpace X\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\\nhas cardinality at least continuum, then the ambient space is not a normal space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\\n  Nonempty (TopologicalSpace.PositiveCompacts α)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a nonempty locally compact space, there exists a compact set with nonempty interior. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ConnectedSpace α] [inst_2 : Nontrivial α] [inst_3 : T1Space α]\\n  (x : α), Filter.NeBot (nhdsWithin x {x}ᶜ)\",\n  \"isProp\": true,\n  \"docString\": \"A non-trivial connected T1 space has no isolated points. \"},\n {\"theorem\":\n  \"∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X\",\n  \"isProp\": true,\n  \"docString\": \"A path-connected space must be nonempty. \"},\n {\"theorem\":\n  \"∀ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\\n  IsClosed s → ¬a ∈ s → Disjoint (nhdsSet s) (nhds a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\\nneighborhoods.  \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\\n  IsConnected s ↔\\n    ∀ (U : Finset (Set α)),\\n      (∀ (u v : Set α), u ∈ U → v ∈ U → Set.Nonempty (s ∩ (u ∩ v)) → u = v) →\\n        (∀ (u : Set α), u ∈ U → IsOpen u) → s ⊆ ⋃₀ ↑U → ∃ u, u ∈ U ∧ s ⊆ u\",\n  \"isProp\": true,\n  \"docString\":\n  \"A set `s` is connected if and only if\\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\\nit is contained in one of the members of the collection. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α],\\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A space is totally disconnected iff its connected components are subsingletons. \"}]\n",
    "prompt_cons": "/-- A connected space is nonempty. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], Nonempty α :=\n\n/-- A nonempty convex set is connected. -/\ntheorem ∀ {E : Type u_1} [inst : AddCommGroup E] [inst_1 : Module ℝ E] [inst_2 : TopologicalSpace E]\n  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] {s : Set E},\n  Convex ℝ s → Set.Nonempty s → IsConnected s :=\n\n/-- The directed sUnion of a set S of preconnected subsets is preconnected. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S : Set (Set α)},\n  DirectedOn (fun x x_1 => x ⊆ x_1) S → (∀ (s : Set α), s ∈ S → IsPreconnected s) → IsPreconnected (⋃₀ S) :=\n\n/-- Let `s` be a closed set in a separable space. If the induced topology on `s` is discrete and `s`\nhas cardinality at least continuum, then the ambient space is not a normal space. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace.SeparableSpace X] {s : Set X},\n  IsClosed s → ∀ [inst_2 : DiscreteTopology ↑s], Cardinal.continuum ≤ Cardinal.mk ↑s → ¬NormalSpace X :=\n\n/-- In a nonempty locally compact space, there exists a compact set with nonempty interior. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LocallyCompactSpace α] [inst_2 : Nonempty α],\n  Nonempty (TopologicalSpace.PositiveCompacts α) :=\n\n/-- A non-trivial connected T1 space has no isolated points. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ConnectedSpace α] [inst_2 : Nontrivial α] [inst_3 : T1Space α]\n  (x : α), Filter.NeBot (nhdsWithin x {x}ᶜ) :=\n\n/-- A path-connected space must be nonempty. -/\ntheorem ∀ {X : Type u_1} [inst : TopologicalSpace X] [self : PathConnectedSpace X], Nonempty X :=\n\n/-- If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\nneighborhoods. -/\ntheorem ∀ {X : Type u} [inst : TopologicalSpace X] [self : RegularSpace X] {s : Set X} {a : X},\n  IsClosed s → ¬a ∈ s → Disjoint (nhdsSet s) (nhds a) :=\n\n/-- A set `s` is connected if and only if\nfor every cover by a finite collection of open sets that are pairwise disjoint on `s`,\nit is contained in one of the members of the collection. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  IsConnected s ↔\n    ∀ (U : Finset (Set α)),\n      (∀ (u v : Set α), u ∈ U → v ∈ U → Set.Nonempty (s ∩ (u ∩ v)) → u = v) →\n        (∀ (u : Set α), u ∈ U → IsOpen u) → s ⊆ ⋃₀ ↑U → ∃ u, u ∈ U ∧ s ⊆ u :=\n\n/-- A space is totally disconnected iff its connected components are subsingletons. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α],\n  TotallyDisconnectedSpace α ↔ ∀ (x : α), Set.Subsingleton (connectedComponent x) :=\n\n/-- Show that if $S$ is connected, it is not true in general that its interior is connected. -/\ntheorem",
    "choices": [
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α], IsConnected (Interior s) → s = Interior s ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (S : Set α) [self : IsConnected S],\n  ¬IsConnected (Interior S) → ∃ S, IsConnected S ∧ ¬IsConnected (Interior S) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] {s : Set α},\n  IsConnected s → ¬(IsConnected (Interior s)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ConnectedSpace α],\n  ¬(IsConnected (Interior α)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α],\n  ¬ (∀ {s : Set α}, IsConnected s → IsConnected (Interior s)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ConnectedSpace α],\n  ¬(IsConnected (Interior (ConnectedSpace.carrier α)) ↔ IsConnected (ConnectedSpace.carrier α)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α] (s : Set α),\n  IsConnected s → ¬IsConnected (Interior s) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : ConnectedSpace α],\n  ¬(IsConnected (Interior α)) ",
      "∀ {α : Type u} [inst : TopologicalSpace α] [self : ConnectedSpace α],\n  ¬(IsConnected (Interior self)) → IsConnected self ",
      "∀ {α : Type u} [inst : TopologicalSpace α] (s : Set α),\n  IsConnected s → ¬(IsConnected (Interior s) ↔ ∀, False) "
    ]
  },
  {
    "docString": "Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] (x : α) {s : Set α},\\n  s ∈ nhds x → Set.Finite s → IsOpen {x}\",\n  \"isProp\": true,\n  \"docString\": \"A point with a finite neighborhood has to be isolated. \"},\n {\"theorem\":\n  \"∀ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\\n  ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"**Primitive element theorem** assuming E is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x))\",\n  \"isProp\": true,\n  \"docString\": \"Uniform converence implies pointwise convergence. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MetricSpace E]\\n  {f : ℕ → α → E} {g : α → E} [inst_1 : MeasureTheory.IsFiniteMeasure μ],\\n  (∀ (n : ℕ), MeasureTheory.AEStronglyMeasurable (f n) μ) →\\n    (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\\n      MeasureTheory.TendstoInMeasure μ f Filter.atTop g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Convergence a.e. implies convergence in measure in a finite measure space. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)]\\n  {F : ℕ → { x // x ∈ lp E p }},\\n  CauchySeq F →\\n    ∀ {f : { x // x ∈ lp E p }},\\n      Filter.Tendsto (id fun i => ↑(F i)) Filter.atTop (nhds ↑f) → Filter.Tendsto F Filter.atTop (nhds f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\\n`lp E p`, then it converges to `f` in the `lp E p` topology. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)],\\n  UniformContinuous Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion from `lp E p` to `∀ i, E i` is uniformly continuous. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\\n  (s : Set β),\\n  IsCompact s →\\n    ∀ (A : Set (BoundedContinuousFunction α β)),\\n      IsClosed A →\\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A\",\n  \"isProp\": true,\n  \"docString\":\n  \"Second version, with pointwise equicontinuity and range in a compact subset. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_3} {E : Type u_2} {ι : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\\n  [inst_2 : Module 𝕜 E] {p : SeminormFamily 𝕜 E ι} [inst_3 : Nonempty ι] [t : TopologicalSpace E],\\n  WithSeminorms p → ∀ (q : Seminorm 𝕜 E), Continuous ↑q → ∃ s C, C ≠ 0 ∧ q ≤ C • Finset.sup s p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `E` be a topological vector space (over a `NontriviallyNormedField`) whose topology is\\ngenerated by some family of seminorms `p`, and let `q` be a seminorm on `E`. If `q` is continuous,\\nthen it is uniformly controlled by *finitely many* seminorms of `p`, that is there\\nis some finset `s` of the index set and some `C > 0` such that `q ≤ C • s.sup p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [inst : MetricSpace β]\\n  {μ : MeasureTheory.Measure α} [inst_1 : SemilatticeSup ι] [inst_2 : Nonempty ι] [inst_3 : Countable ι] {f : ι → α → β}\\n  {g : α → β} [inst_4 : MeasureTheory.IsFiniteMeasure μ],\\n  (∀ (n : ι), MeasureTheory.StronglyMeasurable (f n)) →\\n    MeasureTheory.StronglyMeasurable g →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\\n        ∀ {ε : ℝ}, 0 < ε → ∃ t, MeasurableSet t ∧ ↑↑μ t ≤ ENNReal.ofReal ε ∧ TendstoUniformlyOn f g Filter.atTop tᶜ\",\n  \"isProp\": true,\n  \"docString\": \"Egorov's theorem for finite measure spaces. \"}]\n",
    "prompt_cons": "/-- If `E` is first countable, then every locally bounded linear map `E →ₛₗ[σ] F` is continuous. -/\ntheorem ∀ {𝕜 : Type u_2} {𝕜' : Type u_3} {E : Type u_4} {F : Type u_1} [inst : AddCommGroup E] [inst_1 : UniformSpace E]\n  [inst_2 : UniformAddGroup E] [inst_3 : AddCommGroup F] [inst_4 : UniformSpace F]\n  [inst_5 : TopologicalSpace.FirstCountableTopology E] [inst_6 : IsROrC 𝕜] [inst_7 : Module 𝕜 E]\n  [inst_8 : ContinuousSMul 𝕜 E] [inst_9 : IsROrC 𝕜'] [inst_10 : Module 𝕜' F] [inst_11 : ContinuousSMul 𝕜' F]\n  {σ : 𝕜 →+* 𝕜'} [inst_12 : UniformAddGroup F] (f : E →ₛₗ[σ] F),\n  (∀ (s : Set E), Bornology.IsVonNBounded 𝕜 s → Bornology.IsVonNBounded 𝕜' (↑f '' s)) → Continuous ↑f :=\n\n/-- A point with a finite neighborhood has to be isolated. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T1Space α] (x : α) {s : Set α},\n  s ∈ nhds x → Set.Finite s → IsOpen {x} :=\n\n/-- **Primitive element theorem** assuming E is finite. -/\ntheorem ∀ (F : Type u_2) [inst : Field F] (E : Type u_1) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite E],\n  ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- Uniform converence implies pointwise convergence. -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {s : Set α} {p : Filter ι},\n  TendstoUniformlyOn F f p s → ∀ {x : α}, x ∈ s → Filter.Tendsto (fun n => F n x) p (nhds (f x)) :=\n\n/-- Convergence a.e. implies convergence in measure in a finite measure space. -/\ntheorem ∀ {α : Type u_1} {E : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MetricSpace E]\n  {f : ℕ → α → E} {g : α → E} [inst_1 : MeasureTheory.IsFiniteMeasure μ],\n  (∀ (n : ℕ), MeasureTheory.AEStronglyMeasurable (f n) μ) →\n    (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\n      MeasureTheory.TendstoInMeasure μ f Filter.atTop g :=\n\n/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem ∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)]\n  {F : ℕ → { x // x ∈ lp E p }},\n  CauchySeq F →\n    ∀ {f : { x // x ∈ lp E p }},\n      Filter.Tendsto (id fun i => ↑(F i)) Filter.atTop (nhds ↑f) → Filter.Tendsto F Filter.atTop (nhds f) :=\n\n/-- The coercion from `lp E p` to `∀ i, E i` is uniformly continuous. -/\ntheorem ∀ {α : Type u_1} {E : α → Type u_2} {p : ENNReal} [inst : (i : α) → NormedAddCommGroup (E i)] [_i : Fact (1 ≤ p)],\n  UniformContinuous Subtype.val :=\n\n/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]\n  (s : Set β),\n  IsCompact s →\n    ∀ (A : Set (BoundedContinuousFunction α β)),\n      IsClosed A →\n        (∀ (f : BoundedContinuousFunction α β) (x : α), f ∈ A → ↑f x ∈ s) → (Equicontinuous fun x => ↑↑x) → IsCompact A :=\n\n/-- Let `E` be a topological vector space (over a `NontriviallyNormedField`) whose topology is\ngenerated by some family of seminorms `p`, and let `q` be a seminorm on `E`. If `q` is continuous,\nthen it is uniformly controlled by *finitely many* seminorms of `p`, that is there\nis some finset `s` of the index set and some `C > 0` such that `q ≤ C • s.sup p`. -/\ntheorem ∀ {𝕜 : Type u_3} {E : Type u_2} {ι : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : AddCommGroup E]\n  [inst_2 : Module 𝕜 E] {p : SeminormFamily 𝕜 E ι} [inst_3 : Nonempty ι] [t : TopologicalSpace E],\n  WithSeminorms p → ∀ (q : Seminorm 𝕜 E), Continuous ↑q → ∃ s C, C ≠ 0 ∧ q ≤ C • Finset.sup s p :=\n\n/-- Egorov's theorem for finite measure spaces. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {ι : Type u_3} {m : MeasurableSpace α} [inst : MetricSpace β]\n  {μ : MeasureTheory.Measure α} [inst_1 : SemilatticeSup ι] [inst_2 : Nonempty ι] [inst_3 : Countable ι] {f : ι → α → β}\n  {g : α → β} [inst_4 : MeasureTheory.IsFiniteMeasure μ],\n  (∀ (n : ι), MeasureTheory.StronglyMeasurable (f n)) →\n    MeasureTheory.StronglyMeasurable g →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) →\n        ∀ {ε : ℝ}, 0 < ε → ∃ t, MeasurableSet t ∧ ↑↑μ t ≤ ENNReal.ofReal ε ∧ TendstoUniformlyOn f g Filter.atTop tᶜ :=\n\n/-- Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses. -/\ntheorem",
    "choices": [
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] [_i : TopologicalSpace.CountableBasis ℕ],\n  Set.Countable E → ∃ p, ∀ (N : ℝ), p ∈ E → Set.Countable (E ∩ Metric.Ball p N)) ",
      "∀ (E : Set ℝ) [inst : Set.Countable Eᶜ], ∃ p : ℝ, condensation_point p E ",
      "∀ (E : Set ℝ), Set.Countable Eᶜ → ∃ p : ℝ, ∀ (e : ℝ), e > 0 → Set.Cardinal (E ∩ Set.Ioc (p - e) (p + e)) = Set.Countable ",
      "∀ {E : Set ℝ}, Set.Countable Eᶜ → ∃ p, IsCondensationPoint p E ",
      "∀ {E : Set ℝ}, (∀ (s : Set ℝ), s ∈ nhds 0 → Set.Countable (E ∩ s) → False) →\n∃ p, ∀ (s : Set ℝ), s ∈ nhds p → Set.Countable (E ∩ s) → False ",
      "∀ {E : Set ℝ} [inst : IsUncountable E], ∃ p : ℝ, ECondensesAt E p ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ] [inst_1 : LinearOrder ℝ] [inst_2 : OrderTopology ℝ] [inst_3 : DenselyOrdered ℝ],\n  Set.Countable E → ∃ p : ℝ, ∀ ε, 0 < ε → Set.Countable (E ∩ Metric.Ball p ε) ",
      "∀ {E : Set ℝ}, Set.Countable Eᶜ → ∃ p : ℝ, ∀ r, ∃ x y ∈ E, x < p ∧ p < y ∧ (y - x) ≤ r ",
      "∀ {E : Set ℝ} [inst : Set.Countable E], Set.Nonempty E → ∃ p, Set.DenselyOrdered.condenses E p ",
      "∀ {E : Set ℝ} [inst : TopologicalSpace ℝ], Set.Uncountable E → ∃ p, IsCondensationPoint E p "
    ]
  },
  {
    "docString": "Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$.",
    "prompts": "[{\"theorem\":\n  \"∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\\n  [inst_1 :\\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\\n  CategoryTheory.Limits.HasLimit F\",\n  \"isProp\": true,\n  \"docString\": \"Use the above equivalence to prove we have a limit. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ (n : ℕ), Filter.Tendsto (fun x => x ^ n * rexp (-x)) Filter.atTop (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The function `x^n * exp(-x)` tends to `0` at `+∞`, for any natural number `n`. \"},\n {\"theorem\": \"∀ (n : ℕ), 512 ≤ n → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Proves that Bertrand's postulate holds for all sufficiently large `n`.\\n\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to+\\\\infty}|x|=+\\\\infty$ \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a)\",\n  \"isProp\": true,\n  \"docString\": \"proof that a monotone function tends to `𝓝 a` as `x → ∞` \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] {r : ℝ}, 1 < r → Nat.cast =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\": \"For a real `r > 1` we have `n = o(r ^ n)` as `n → ∞`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\\n  (∀ (n : ℕ), AEMeasurable (f n)) →\\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ))\",\n  \"isProp\": true,\n  \"docString\": \"Monotone convergence theorem expressed with limits \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\\n  UniformCauchySeqOnFilter F p p' →\\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p'\",\n  \"isProp\": true,\n  \"docString\": \"A uniformly Cauchy sequence converges uniformly to its limit \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop\",\n  \"isProp\": true,\n  \"docString\": \"$\\\\lim_{x\\\\to-\\\\infty}|x|=+\\\\infty$ \"}]\n",
    "prompt_cons": "/-- Use the above equivalence to prove we have a limit. -/\ntheorem ∀ {J : Type w} {C : Type u} [inst : CategoryTheory.Category C] {B : C}\n  (F : CategoryTheory.Functor (CategoryTheory.Discrete J) (CategoryTheory.Over B))\n  [inst_1 :\n    CategoryTheory.Limits.HasLimit (CategoryTheory.Over.ConstructProducts.widePullbackDiagramOfDiagramOver B F)],\n  CategoryTheory.Limits.HasLimit F :=\n\n/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- The function `x^n * exp(-x)` tends to `0` at `+∞`, for any natural number `n`. -/\ntheorem ∀ (n : ℕ), Filter.Tendsto (fun x => x ^ n * rexp (-x)) Filter.atTop (nhds 0) :=\n\n/-- Proves that Bertrand's postulate holds for all sufficiently large `n`. -/\ntheorem ∀ (n : ℕ), 512 ≤ n → ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n :=\n\n/-- $\\lim_{x\\to+\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atTop Filter.atTop :=\n\n/-- proof that a monotone function tends to `𝓝 a` as `x → ∞` -/\ntheorem ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [self : SupConvergenceClass α] (a : α) (s : Set α),\n  IsLUB s a → Filter.Tendsto CoeTC.coe Filter.atTop (nhds a) :=\n\n/-- For a real `r > 1` we have `n = o(r ^ n)` as `n → ∞`. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] {r : ℝ}, 1 < r → Nat.cast =o[Filter.atTop] fun n => r ^ n :=\n\n/-- Monotone convergence theorem expressed with limits -/\ntheorem ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : ℕ → α → ENNReal} {F : α → ENNReal},\n  (∀ (n : ℕ), AEMeasurable (f n)) →\n    (∀ᵐ (x : α) ∂μ, Monotone fun n => f n x) →\n      (∀ᵐ (x : α) ∂μ, Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) →\n        Filter.Tendsto (fun n => ∫⁻ (x : α), f n x ∂μ) Filter.atTop (nhds (∫⁻ (x : α), F x ∂μ)) :=\n\n/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem ∀ {α : Type u} {β : Type v} {ι : Type x} [inst : UniformSpace β] {F : ι → α → β} {f : α → β} {p : Filter ι}\n  {p' : Filter α} [inst_1 : Filter.NeBot p],\n  UniformCauchySeqOnFilter F p p' →\n    (∀ᶠ (x : α) in p', Filter.Tendsto (fun n => F n x) p (nhds (f x))) → TendstoUniformlyOnFilter F f p p' :=\n\n/-- $\\lim_{x\\to-\\infty}|x|=+\\infty$ -/\ntheorem ∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α], Filter.Tendsto abs Filter.atBot Filter.atTop :=\n\n/-- Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : LinearOrderedField R] [inst_1 : FloorRing R],\n  Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 :FloorRing α], Filter.Tendsto (λ n, (Real.sqrt (n + 1) - Real.sqrt n)) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "∀ {α : Type u_1} [inst : LinearOrderedField α] [self : Archimedean α], Filter.Tendsto (fun n => (n + 1) ** (1 / 2) - n ** (1 / 2)) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "Filter.Tendsto (fun n => Real.sqrt (n + 1) - Real.sqrt n) Filter.atTop (nhds 0) ",
      "∀ {R : Type u_1} [inst : LinearOrderedField R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R],\n  Filter.Tendsto (fun n => sqrt (n + 1) - sqrt n) Filter.atTop (nhds 0) "
    ]
  },
  {
    "docString": "Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that\\n$\\\\sum_{k = 0}^{n - 1} (e^{X})^k = \\\\sum_{p = 0}^{\\\\infty} \\\\sum_{k = 0}^{n - 1} \\\\frac{k^p}{p!}X^p$. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0\",\n  \"isProp\": true,\n  \"docString\": \"If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. \"},\n {\"theorem\": \"∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\\nif and only if `1 < p`. \"},\n {\"theorem\":\n  \"∀ {x : ℝ}, |x| < 1 → HasSum (fun n => x ^ (n + 1) / (↑n + 1)) (-Real.log (1 - x))\",\n  \"isProp\": true,\n  \"docString\": \"Power series expansion of the logarithm around `1`. \"},\n {\"theorem\":\n  \"∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1)\",\n  \"isProp\": true,\n  \"docString\": \"Specific case of Jensen's inequality for sums of powers \"},\n {\"theorem\": \"∀ {p : ℝ}, (Summable fun n => (↑n ^ p)⁻¹) ↔ 1 < p\",\n  \"isProp\": true,\n  \"docString\":\n  \"Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\\nif and only if `1 < p`. \"},\n {\"theorem\": \"∀ {p x : ℝ}, LiouvilleWith p x → 1 < p → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. \"},\n {\"theorem\":\n  \"∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2`  \"},\n {\"theorem\":\n  \"∀ {x y : ℤ} {n : ℕ},\\n  2 ∣ x - y →\\n    ¬2 ∣ x →\\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"∀ (p : ℕ → Prop) [inst : DecidablePred p] (n : ℕ), Nat.count p n = Fintype.card { k // k < n ∧ p k }\",\n  \"isProp\": true,\n  \"docString\":\n  \"`count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. \"}]\n",
    "prompt_cons": "/-- Shows that\n$\\sum_{k = 0}^{n - 1} (e^{X})^k = \\sum_{p = 0}^{\\infty} \\sum_{k = 0}^{n - 1} \\frac{k^p}{p!}X^p$. -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (n : ℕ),\n  (Finset.sum (Finset.range n) fun k => PowerSeries.exp A ^ k) =\n    PowerSeries.mk fun p => Finset.sum (Finset.range n) fun k => ↑(k ^ p) * ↑(algebraMap ℚ A) (↑(Nat.factorial p))⁻¹ :=\n\n/-- If `1 < k` then `(∑ i in range k, ζ ^ i) = 0`. -/\ntheorem ∀ {R : Type u_1} {k : ℕ} [inst : CommRing R] [inst_1 : IsDomain R] {ζ : R},\n  IsPrimitiveRoot ζ k → 1 < k → (Finset.sum (Finset.range k) fun i => ζ ^ i) = 0 :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, 1 / n ^ p` converges\nif and only if `1 < p`. -/\ntheorem ∀ {p : ℕ}, (Summable fun n => 1 / ↑n ^ p) ↔ 1 < p :=\n\n/-- Power series expansion of the logarithm around `1`. -/\ntheorem ∀ {x : ℝ}, |x| < 1 → HasSum (fun n => x ^ (n + 1) / (↑n + 1)) (-Real.log (1 - x)) :=\n\n/-- Specific case of Jensen's inequality for sums of powers -/\ntheorem ∀ {ι : Type u} (s : Finset ι) {f : ι → ℝ} (n : ℕ),\n  (∀ (a : ι), a ∈ s → 0 ≤ f a) →\n    (Finset.sum s fun x => f x) ^ (n + 1) / ↑(Finset.card s) ^ n ≤ Finset.sum s fun x => f x ^ (n + 1) :=\n\n/-- Test for convergence of the `p`-series: the real-valued series `∑' n : ℕ, (n ^ p)⁻¹` converges\nif and only if `1 < p`. -/\ntheorem ∀ {p : ℝ}, (Summable fun n => (↑n ^ p)⁻¹) ↔ 1 < p :=\n\n/-- A number satisfying the Liouville condition with exponent `p > 1` is an irrational number. -/\ntheorem ∀ {p x : ℝ}, LiouvilleWith p x → 1 < p → Irrational x :=\n\n/-- For any `n`, we have `log_stirlingSeq 1 - log_stirlingSeq n ≤ 1/4 * ∑' 1/k^2` -/\ntheorem ∃ c, ∀ (n : ℕ), Real.log (Stirling.stirlingSeq 1) - Real.log (Stirling.stirlingSeq (Nat.succ n)) ≤ c :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem ∀ {x y : ℤ} {n : ℕ},\n  2 ∣ x - y →\n    ¬2 ∣ x →\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n :=\n\n/-- `count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. -/\ntheorem ∀ (p : ℕ → Prop) [inst : DecidablePred p] (n : ℕ), Nat.count p n = Fintype.card { k // k < n ∧ p k } :=\n\n/-- Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$. -/\ntheorem",
    "choices": [
      "∀ {p : ℝ}, (1 < p) → ¬Summable (fun k => 1 / (↑k * Real.log ↑k) ^ p) ",
      "∀ {p : ℝ}, (Summable fun k => 1 / ↑k * (Real.log ↑k) ^ p) ↔ p > 1 ",
      "∀ {p : ℝ}, (p ≤ 1) → ¬Summable (λ k => 1 / ↑k * (Real.log ↑k) ^ p) ",
      "∀ {p : ℝ}, (Summable fun k => (↑k * Real.log ↑k ^ p)⁻¹) ↔ p > 1 ",
      "∀ {p : ℝ}, (p ≤ 1 → ¬Summable fun k => 1 / (↑k * (Real.log ↑k) ^ p)) ",
      "∀ {p : ℝ}, 1 ≤ p → ¬(Summable fun k => (↑k * Real.log ↑k ^ p)⁻¹) ",
      "∀ {p : ℝ}, (Summable fun k => 1 / ↑k * (Real.log ↑k) ^ p) → 1 < p ",
      "∀ {p : ℝ}, (Summable fun k => (1 / ↑k) * (Real.log ↑k) ^ p) → 1 < p ",
      "∀ {p : ℝ}, (Summable fun k => 1 / ↑k * (Real.log ↑k) ^ p) → 1 < p ",
      "∀ {p : ℝ}, (Summable fun k => 1 / ↑k * (Real.log ↑k) ^ p) → 1 < p "
    ]
  },
  {
    "docString": "Show that a group of order 5 must be abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\\n  CategoryTheory.Limits.HasFiniteBiproducts C\",\n  \"isProp\": true,\n  \"docString\": \"An abelian category has finite biproducts. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := finRotate 5, property := (_ : finRotate (bit1 2) ∈ alternatingGroup (Fin (bit1 2))) }} =\\n  ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any 5-cycle within $A_5$ is the whole group. \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 ∈ alternatingGroup (Fin 5)) }} =\\n  ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\\n\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- An abelian category has finite biproducts. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Abelian C],\n  CategoryTheory.Limits.HasFiniteBiproducts C :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- The normal closure of the 5-cycle `finRotate 5` within $A_5$ is the whole group. This will be\nused to show that the normal closure of any 5-cycle within $A_5$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := finRotate 5, property := (_ : finRotate (bit1 2) ∈ alternatingGroup (Fin (bit1 2))) }} =\n  ⊤ :=\n\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 ∈ alternatingGroup (Fin 5)) }} =\n  ⊤ :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- Show that a group of order 5 must be abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 5 → ∀ (x y : G), x * y = y * x ",
      "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  Fintype.card α = 5 →\n    ∀ {G : Type u_1} [inst_2 : Group G] [h : Fintype.card G = 5], IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 5 → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : Fintype.card G = 5), IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 5 → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 5 → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 5 → IsAbelian G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 5 → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 5 → IsCommutative G ",
      "∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  Fintype.card α = 5 →\n    ∀ (G : Set α) [inst_2 : Group G], IsCommGroup G "
    ]
  },
  {
    "docString": "If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$.",
    "prompts": "[{\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, m > 0 ∧ ∀ a : G, a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, 0 < m ∧ ∀ a : G, a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, m > 0 ∧ ∀ a : G, a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, m > 0 ∧ ∀ a : G, a ^ m = 1 ",
      "∀ (G : Type u_1) [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, m > 0 ∧ ∀ a : G, a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, m > 0 ∧ ∀ a : G, a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, m > 0 ∧ ∀ a : G, a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m : ℕ, m > 0 ∧ ∀ a : G, a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m, 0 < m ∧ ∀ (a : G), a ^ m = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], ∃ m, 0 < m ∧ ∀ a : G, a ^ m = 1 "
    ]
  },
  {
    "docString": "Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.continuants g n = ppred →\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.numerators g n = ppredA →\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.denominators g n = ppredB →\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.continuants g n = ppred →\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.numerators g n = ppredA →\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.denominators g n = ppredB →\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G], (∀ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) → (∀ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) → IsCommutative G (*) ",
      "∀ {G : Type u_1} [inst : Group G] (h3 : ∀ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) (h5 : ∀ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5), IsCommutative G Mul.mul ",
      "∀ {G : Type u_1} [inst : Group G] (h3 : ∀ (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3) (h5 : ∀ (a b : G), (a * b) ^ 5 = a ^ 5 * b ^ 5),\n  IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) → (∀ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) → IsCommutative G Mul ",
      "∀ {G : Type u_1} [inst : Group G], (∀ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) → (∀ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G],\n  (∀ (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3) →\n  (∀ (a b : G), (a * b) ^ 5 = a ^ 5 * b ^ 5) →\n  IsCommutative G Mul ",
      "∀ {G : Type u_1} [inst : Group G] (h3 : ∀ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) (h5 : ∀ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5), IsCommutative G (*) ",
      "∀ {G : Type u_1} [inst : Group G] (h3 : ∀ a b : G, (a * b) ^ 3 = a ^ 3 * b ^ 3) (h5 : ∀ a b : G, (a * b) ^ 5 = a ^ 5 * b ^ 5), IsCommutative G (*) ",
      "∀ {G : Type u_1} [inst : Group G], \n  (∀ a b : G, a * b * a * b * a * b = a * a * a * b * b * b) → \n  (∀ a b : G, a * b * a * b * a * b * a * b * a * b = a * a * a * a * a * b * b * b * b * b) → CommGroup G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ a b : G, (a * b)^3 = a^3 * b^3) → (∀ a b : G, (a * b)^5 = a^5 * b^5) → IsCommutative G Mul "
    ]
  },
  {
    "docString": "If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$",
    "prompts": "[{\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (x : M), SemiconjBy (↑u) x (↑u * x * ↑u⁻¹)\",\n  \"isProp\": true,\n  \"docString\": \"`a` semiconjugates `x` to `a * x * a⁻¹`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {a : Mˣ} {x y : M}, SemiconjBy (↑a) x y → SemiconjBy (↑a⁻¹) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier\",\n  \"isProp\": true,\n  \"docString\": \"`G` is closed under inverses \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A)\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A multiplicative equivalence of groups preserves inversion. \"},\n {\"theorem\":\n  \"∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inversion is a group homomorphism if the group is commutative. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = x⁻¹`. \"}]\n",
    "prompt_cons": "/-- `a` semiconjugates `x` to `a * x * a⁻¹`. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ) (x : M), SemiconjBy (↑u) x (↑u * x * ↑u⁻¹) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {a : Mˣ} {x y : M}, SemiconjBy (↑a) x y → SemiconjBy (↑a⁻¹) y x :=\n\n/-- `G` is closed under inverses -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (self : Subgroup G) {x : G}, x ∈ self.carrier → x⁻¹ ∈ self.carrier :=\n\n/-- Shows that $e^{aX} * e^{bX} = e^{(a + b)X}$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A] (a b : A),\n  ↑(PowerSeries.rescale a) (PowerSeries.exp A) * ↑(PowerSeries.rescale b) (PowerSeries.exp A) =\n    ↑(PowerSeries.rescale (a + b)) (PowerSeries.exp A) :=\n\n/-- A multiplicative equivalence of groups preserves inversion. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : DivisionMonoid H] (h : G ≃* H) (x : G), ↑h x⁻¹ = (↑h x)⁻¹ :=\n\n/-- A monoid homomorphism between groups with zeros sending `0` to `0` sends `a⁻¹` to `(f a)⁻¹`. -/\ntheorem ∀ {G₀ : Type u_2} {G₀' : Type u_1} {F : Type u_3} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\n  [inst_2 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (a : G₀), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem ∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv :=\n\n/-- By definition, if `x` is invertible then `inverse x = x⁻¹`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹ :=\n\n/-- If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$ -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (a x : G), Conjugate x⁻¹ a x = x⁻¹ * Conjugate a * x ",
      "forall {G : Type u_1} [inst : Group G] (a x : G), Conjugate x⁻¹ (Conjugate x a) = Conjugate (x⁻¹ * a * x) a ",
      "∀ {G : Type u_1} [inst : Group G] (x a : G), Conjugate x⁻¹ a x = x⁻¹ * Conjugate x a x ",
      "∀ {G : Type u_1} [inst : Group G] (a x : G), Conjugate x⁻¹ (Conjugate x a) = Conjugate x (Conjugate x⁻¹ a) ",
      "forall {G : Type u_1} [inst : Group G] (a x : G),\n  Conjugate x⁻¹ (Conjugate x a) = Conjugate a (x⁻¹ * a * x) ",
      "∀ {G : Type u_1} [inst : Group G] (a x : G), Conjugate (x⁻¹ * a * x) = x⁻¹ * Conjugate a * x ",
      "forall {G : Type u_1} [inst : Group G] (a x : G), Conjugate x⁻¹ (Conjugate x a) = Conjugate (x⁻¹ * a * x) x ",
      "∀ {G : Type u_1} [inst : Group G] (C : G → G) (x a : G), C (x⁻¹ * a * x) = x⁻¹ * C a * x ",
      "∀ {G : Type u_1} [inst : Group G] (x a : G), Conjugate (x⁻¹ * a * x) = x⁻¹ * Conjugate a * x ",
      "∀ {G : Type u_1} [inst : Group G] (C : G → G) (x a : G), C (x⁻¹ * a * x) = x⁻¹ * C a * x "
    ]
  },
  {
    "docString": "If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function.",
    "prompts": "[{\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → Nat.totient n = Finsupp.prod (Nat.factorization n) fun p k => p ^ (k - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\": \"Euler's product formula for the totient function. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {n : ℕ}, jacobiSym a n = -1 → ∃ p x, p ∣ n ∧ jacobiSym a p = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a\",\n  \"isProp\": true,\n  \"docString\": \"`a ^ (n + 1) = a * a ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (ψ : AddChar R R') (n : ℕ),\\n  ψ ^ n = AddChar.mulShift ψ ↑n\",\n  \"isProp\": true,\n  \"docString\": \"If `n` is a natural number, then `ψ ^ n = mulShift ψ n`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\\n  0 < n →\\n    IsPrimitiveRoot ζ n → (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is a primitive `n`-th root of unity in `K`, then\\n`∏ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `n % 4 = 1`, then `(-1)^(n/2) = 1`. \"}]\n",
    "prompt_cons": "/-- Euler's product formula for the totient function. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → Nat.totient n = Finsupp.prod (Nat.factorization n) fun p k => p ^ (k - 1) * (p - 1) :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem ∀ {a : ℤ} {n : ℕ}, jacobiSym a n = -1 → ∃ p x, p ∣ n ∧ jacobiSym a p = -1 :=\n\n/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- `a ^ (n + 1) = a * a ^ n` -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedSemifield α] (n : ℕ) (a : α),\n  LinearOrderedSemifield.zpow (Int.ofNat (Nat.succ n)) a = a * LinearOrderedSemifield.zpow (Int.ofNat n) a :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If `n` is a natural number, then `ψ ^ n = mulShift ψ n`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] (ψ : AddChar R R') (n : ℕ),\n  ψ ^ n = AddChar.mulShift ψ ↑n :=\n\n/-- If there is a primitive `n`-th root of unity in `K`, then\n`∏ i in Nat.divisors n, cyclotomic' i K = X ^ n - 1`. -/\ntheorem ∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\n  0 < n →\n    IsPrimitiveRoot ζ n → (Finset.prod (Nat.divisors n) fun i => Polynomial.cyclotomic' i K) = Polynomial.X ^ n - 1 :=\n\n/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem ∀ {n : ℕ}, n % 4 = 1 → (-1) ^ (n / 2) = 1 :=\n\n/-- If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function. -/\ntheorem",
    "choices": [
      "∀ {a n : ℕ}, a > 1 → Nat.totient a^n - 1 ∣ n ",
      "∀ {a n : ℕ}, a > 1 → n ∣ Nat.totient (a ^ n - 1) ",
      "∀ {a n : ℕ}, a > 1 → Nat.Prime n → Nat.totient (a ^ n - 1) ∣ n ",
      "∀ {a n : ℕ}, a > 1 → n ∣ Nat.totient (a ^ n - 1) ",
      "∀ {a n : ℕ}, a > 1 → Nat.totient (a ^ n - 1) ∣ n ",
      "∀ {a : ℕ}, a > 1 → ∀ {n : ℕ}, n ∣ Nat.totient (a ^ n - 1) ",
      "∀ {a n : ℕ}, a > 1 → Nat.totient (a ^ n - 1) ∣ n ",
      "∀ {a n : ℕ}, a > 1 → Nat.totient (a ^ n - 1) ∣ n ",
      "∀ {a n : ℕ}, a > 1 → Nat.totient (a ^ n - 1) ∣ n ",
      "∀ {a n : ℕ}, a > 1 → n ∣ Nat.totient (a ^ n - 1) "
    ]
  },
  {
    "docString": "Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\\n  p ≠ 0 → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\\nthe characteristic. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\n  p ≠ 0 → Nat.Prime p :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A prime `p` is a unit in a commutative ring `R` of nonzero characteristic iff it does not divide\nthe characteristic. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (p : ℕ) [inst_1 : Fact (Nat.Prime p)],\n  ringChar R ≠ 0 → (IsUnit ↑p ↔ ¬p ∣ ringChar R) :=\n\n/-- Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p m : ℕ) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m → ¬p ∣ m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p → H.normal → Subgroup.IsCharSubgroup H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m → ¬ p ∣ m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p → Subgroup.Normal H → Subgroup.IsChar H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p * m → ¬p ∣ m → H.normal → Fintype.card { x // x ∈ H } = p → Subgroup.IsChar H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m → ¬ p ∣ m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p → Subgroup.normal H → Subgroup.IsCharacteristic G H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m → ¬p ∣ m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p → Subgroup.normal H → Subgroup.characteristic H ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)], \n  Fintype.card G = p * m → ¬p ∣ m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p → H.normal → Subgroup.IsChar H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p * m → ¬p ∣ m → H.normal → ∀ (g : G), (∀ (h : G), h ∈ H → g * h * g⁻¹ ∈ H) ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p * m → ¬p ∣ m →\n    H.normal → (∀ (ϕ : G ≃* G), ∀ (x : { x // x ∈ H }), ϕ (Subtype.val x) ∈ H) ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p * m → ¬ p ∣ m →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p → H.normal → Subgroup.IsCharacteristic H ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p m : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p * m →\n    ¬p ∣ m →\n      H.normal →\n        Fintype.card { x // x ∈ H } = p → Subgroup.IsCharacteristic H "
    ]
  },
  {
    "docString": "If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥\",\n  \"isProp\": true,\n  \"docString\": \"**The Three Subgroups Lemma** (via the Hall-Witt identity) \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topology on a linearly ordered group with zero element adjoined is T₃. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSolvable G], ∃ n, derivedSeries G n = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A group `G` is solvable if its derived series is eventually trivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- **The Three Subgroups Lemma** (via the Hall-Witt identity) -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H₁ H₂ H₃ : Subgroup G}, ⁅⁅H₂, H₃⁆, H₁⁆ = ⊥ → ⁅⁅H₃, H₁⁆, H₂⁆ = ⊥ → ⁅⁅H₁, H₂⁆, H₃⁆ = ⊥ :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- The topology on a linearly ordered group with zero element adjoined is T₃. -/\ntheorem ∀ {Γ₀ : Type u_1} [inst : LinearOrderedCommGroupWithZero Γ₀], T3Space Γ₀ :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A group `G` is solvable if its derived series is eventually trivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [self : IsSolvable G], ∃ n, derivedSeries G n = ⊥ :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 → ¬IsLieAbelian G → Nonempty (G ≃* S₃) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 6) (hN : Nontrivial G) (hA : ¬IsAbelian G), G ≃* S3 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ x y : G, x ≠ y ∧ ∀ z : G, z = x ∨ z = y → ∀ w : G, w = x ∨ w = y) → Fintype.card G = 6 → Nonempty (GroupEquiv G (SymmetricGroup (Fin 3))) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 6 ∧ ¬IsCommutative G → Nonempty (G ≃* SymmetricGroup (Fin 3)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 → Nonabelian G → Group.Isomorphic G (SymmetricGroup (Fin 3)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 → Nonabelian G → Group.Isomorphic G (SymmetricGroup (Fin 3)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 → Nonabelian G → Isomorphic G (symmetricGroup (Fin 3)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 → Nonabelian G → Group.Isomorphic G (SymmetricGroup (Fin 3)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 → ¬IsAbelian G → ∃ (ϕ : G ≃* S3), Function.Bijective ϕ.to_fun ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 6 ∧ ¬IsCommGroup G → Nonempty (G ≃* SymmetricGroup (Fin 3)) "
    ]
  },
  {
    "docString": "Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"}]\n",
    "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Subgroup.Normal H ∧ Fintype.card { x // x ∈ H } = p ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = p ∧ Subgroup.Normal H ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Subgroup.Normal H ∧ Fintype.card { x // x ∈ H } = p ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = p ∧ Subgroup.Normal H ",
      "forall {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Subgroup.Normal H ∧ Fintype.card { x // x ∈ H } = p ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = p ∧ Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = p ∧ Subgroup.Normal H ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Subgroup.Normal H ∧ Fintype.card { x // x ∈ H } = p ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = p ∧ Subgroup.Normal H ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = p ∧ Subgroup.Normal H "
    ]
  },
  {
    "docString": "If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.",
    "prompts": "[{\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : ℕ},\\n      Nat.coprime m n → Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `m : ℕ` is coprime with `n`,\\nthen the minimal polynomial of a primitive `n`-th root of unity `μ`\\nhas `μ ^ m` as root. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {n m : ℕ}, n ≠ m → IsCoprime (Polynomial.cyclotomic n ℚ) (Polynomial.cyclotomic m ℚ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ m`, then `(cyclotomic n ℚ)` and `(cyclotomic m ℚ)` are coprime. \"}]\n",
    "prompt_cons": "/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1 :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- If `m : ℕ` is coprime with `n`,\nthen the minimal polynomial of a primitive `n`-th root of unity `μ`\nhas `μ ^ m` as root. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {m : ℕ},\n      Nat.coprime m n → Polynomial.IsRoot (Polynomial.map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- If `n ≠ m`, then `(cyclotomic n ℚ)` and `(cyclotomic m ℚ)` are coprime. -/\ntheorem ∀ {n m : ℕ}, n ≠ m → IsCoprime (Polynomial.cyclotomic n ℚ) (Polynomial.cyclotomic m ℚ) :=\n\n/-- If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {m n : ℕ},\n  Nat.coprime m n → (∃ x, addOrderOf x = m) → (∃ y, addOrderOf y = n) → ∃ z, addOrderOf z = m * n ",
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {m n : ℕ},\n  Nat.coprime m n →\n    (∃ x, addOrderOf x = m) → (∃ y, addOrderOf y = n) → ∃ z, addOrderOf z = m * n ",
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G],\n  (∃ x, addOrderOf x = m) → (∃ y, addOrderOf y = n) → Nat.coprime m n → ∃ z, addOrderOf z = m * n ",
      "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : ℕ},\n  Nat.coprime m n → (∃ a, addOrderOf a = m) → (∃ b, addOrderOf b = n) → ∃ c, addOrderOf c = m * n ",
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {m n : ℕ}, \n  Nat.coprime m n →\n    (∃ x, addOrderOf x = m) → (∃ y, addOrderOf y = n) → ∃ z, addOrderOf z = m * n ",
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {m n : ℕ},\n  Nat.coprime m n →\n    (∃ x, addOrderOf x = m) →\n    (∃ y, addOrderOf y = n) →\n    ∃ z, addOrderOf z = m * n ",
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {m n : ℕ},\n  Nat.coprime m n →\n    (∃ x, addOrderOf x = m) → (∃ y, addOrderOf y = n) → ∃ z, addOrderOf z = m * n ",
      "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G],\n  (∃ a : G, addOrderOf a = m) →\n  (∃ b : G, addOrderOf b = n) →\n  Nat.coprime m n →\n  ∃ c : G, addOrderOf c = m * n ",
      "∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] {m n : ℕ},\n  Nat.coprime m n → (∃ x, addOrderOf x = m) → (∃ y, addOrderOf y = n) → ∃ z, addOrderOf z = m * n ",
      "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : Fintype G] {m n : ℕ},\n  Nat.coprime m n → (∃ x, addOrderOf x = m) → (∃ y, addOrderOf y = n) → ∃ z, addOrderOf z = m * n "
    ]
  },
  {
    "docString": "Prove that any two nonabelian groups of order 21 are isomorphic.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\\n  NonarchimedeanAddGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean.\"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R × S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean rings is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ (α : Type u_1) (β : Type u_2) [inst : LinearOrder α] [inst_1 : LinearOrder β] [inst_2 : Encodable α]\\n  [inst_3 : DenselyOrdered α] [inst_4 : NoMinOrder α] [inst_5 : NoMaxOrder α] [inst_6 : Nonempty α]\\n  [inst_7 : Encodable β] [inst_8 : DenselyOrdered β] [inst_9 : NoMinOrder β] [inst_10 : NoMaxOrder β]\\n  [inst_11 : Nonempty β], Nonempty (α ≃o β)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any two countable dense, nonempty linear orders without endpoints are order isomorphic. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Finite groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A ≃+* B → NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"}]\n",
    "prompt_cons": "/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K) :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G × K) :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f) :=\n\n/-- The cartesian product of two nonarchimedean rings is nonarchimedean. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R × S) :=\n\n/-- Any two countable dense, nonempty linear orders without endpoints are order isomorphic. -/\ntheorem ∀ (α : Type u_1) (β : Type u_2) [inst : LinearOrder α] [inst_1 : LinearOrder β] [inst_2 : Encodable α]\n  [inst_3 : DenselyOrdered α] [inst_4 : NoMinOrder α] [inst_5 : NoMaxOrder α] [inst_6 : Nonempty α]\n  [inst_7 : Encodable β] [inst_8 : DenselyOrdered β] [inst_9 : NoMinOrder β] [inst_10 : NoMaxOrder β]\n  [inst_11 : Nonempty β], Nonempty (α ≃o β) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- Finite groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G], Monoid.IsTorsion G :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem ∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A ≃+* B → NoZeroDivisors A :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- Prove that any two nonabelian groups of order 21 are isomorphic. -/\ntheorem",
    "choices": [
      "forall {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] [fG : Fintype G] [fH : Fintype H],\n  Fintype.card G = 21 →\n  Fintype.card H = 21 →\n  ¬ IsAbelian G →\n  ¬ IsAbelian H →\n  Nonempty (G ≃* H) ",
      "forall (G : Type u_1) (H : Type u_2) [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Nontrivial G → Nontrivial H → Fintype.card G = 21 → Fintype.card H = 21 → Nonabelian G → Nonabelian H → Nonempty (G ≃* H) ",
      "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Fintype.card G = 21 → Fintype.card H = 21 → ∃ (ϕ : G ≃* H), Function.Bijective ϕ.to_fun ∧ ∀ (x y : G), ϕ (x * y) = ϕ x * ϕ y ",
      "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Fintype.card G = 21 → Fintype.card H = 21 → ¬IsAbelian G → ¬IsAbelian H → Nonempty (G ≃* H) ",
      "∀ {G : Type u_1} {H : Type u_2} [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Fintype.card G = 21 → Fintype.card H = 21 → (Nonabelian G ↔ Nonabelian H) → Nonempty (G ≃* H) ",
      "∀ (G : Type u_1) (H : Type u_2) [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n  Fintype.card G = 21 →\n    Fintype.card H = 21 →\n      ¬IsAbelian G →\n        ¬IsAbelian H → Nonempty (G ≃* H) ",
      "∀ (G₁ G₂ : Type u_1) [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Fintype G₁] [inst_3 : Fintype G₂],\n  (¬ IsCommGroup G₁) →\n  (¬ IsCommGroup G₂) →\n  Fintype.card G₁ = 21 →\n  Fintype.card G₂ = 21 →\n  Nonempty (G₁ ≃* G₂) ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {H : Type u_2} [inst_2 : Group H] [inst_3 : Fintype H],\n  (Fintype.card G = 21) → (Group.IsNotSimple G) →\n  (Fintype.card H = 21) → (Group.IsNotSimple H) →\n  Nonempty (G ≃* H) ",
      "nonabelian_groups_order_21_isomorphic :\n  ∀ (G H : Type u_1) [inst : Group G] [inst_1 : Group H] [inst_2 : Fintype G] [inst_3 : Fintype H],\n    Fintype.card G = 21 → Fintype.card H = 21 → ¬IsAbelian G → ¬IsAbelian H → Nonempty (G ≃* H) ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (H : Type u_2) [inst_2 : Group H] [inst_3 : Fintype H],\n  Fintype.card G = 21 →\n  Fintype.card H = 21 →\n  ¬IsAbelianGroup G →\n  ¬IsAbelianGroup H →\n  Nonempty (G ≃* H) "
    ]
  },
  {
    "docString": "If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.",
    "prompts": "[{\"theorem\":\n  \"∀ {n m : ℕ}, n ≠ m → IsCoprime (Polynomial.cyclotomic n ℚ) (Polynomial.cyclotomic m ℚ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n ≠ m`, then `(cyclotomic n ℚ)` and `(cyclotomic m ℚ)` are coprime. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n)\",\n  \"isProp\": true,\n  \"docString\": \"If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` \"}]\n",
    "prompt_cons": "/-- If `n ≠ m`, then `(cyclotomic n ℚ)` and `(cyclotomic m ℚ)` are coprime. -/\ntheorem ∀ {n m : ℕ}, n ≠ m → IsCoprime (Polynomial.cyclotomic n ℚ) (Polynomial.cyclotomic m ℚ) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- If `x ^ n = 1`, then `x ^ m` is the same as `x ^ (m % n)` -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {x : M} (m : ℕ) {n : ℕ}, x ^ n = 1 → x ^ m = x ^ (m % n) :=\n\n/-- If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime. -/\ntheorem",
    "choices": [
      "∀ {G₁ G₂ : Type u_1} [inst₁ : Group G₁] [inst₂ : Group G₂] [inst₃ : IsCyclic G₁] [inst₄ : IsCyclic G₂] {m n : ℕ} [inst₅ : Fintype G₁] [inst₆ : Fintype G₂],\n  Fintype.card G₁ = m → Fintype.card G₂ = n → IsCyclic (G₁ × G₂) ↔ Nat.Coprime m n ",
      "∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : IsCyclic G₁] [inst_3 : IsCyclic G₂] [inst_4 : Fintype G₁] [inst_5 : Fintype G₂] {m n : ℕ}, Fintype.card G₁ = m → Fintype.card G₂ = n → IsCyclic (G₁ × G₂) ↔ Nat.Coprime m n ",
      "∀ {G1 G2 : Type u_1} [inst_1 : Group G1] [inst_2 : Group G2] [inst_3 : Fintype G1] [inst_4 : Fintype G2] [inst_5 : IsCyclic G1] [inst_6 : IsCyclic G2] {m n : ℕ}, Fintype.card G1 = m → Fintype.card G2 = n → (IsCyclic (G1 × G2) ↔ Nat.Coprime m n) ",
      "∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Fintype G₁] [inst_3 : Fintype G₂] [inst_4 : IsCyclic G₁] [inst_5 : IsCyclic G₂],\n  IsCyclic (G₁ × G₂) ↔ Nat.Coprime (Fintype.card G₁) (Fintype.card G₂) ",
      "∀ {G1 G2 : Type u_1} [inst_1 : Fintype G1] [inst_2 : Fintype G2] [inst_1_1 : IsCyclic G1] [inst_2_1 : IsCyclic G2],\n  IsCyclic (G1 × G2) ↔ IsCoprime (Fintype.card G1) (Fintype.card G2) ",
      "∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] [inst_2 : IsCyclic α] [inst_3 : IsCyclic β] {m n : ℕ},\n  Fintype.card α = m → Fintype.card β = n → (IsCyclic (α × β) ↔ Nat.Coprime m n) ",
      "∀ {G₁ G₂ : Type u_1} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : IsCyclic G₁] [inst_3 : IsCyclic G₂] {m n : ℕ} [Fintype.card G₁ = m] [Fintype.card G₂ = n], IsCoprime m n ↔ IsCyclic (G₁ × G₂) ",
      "∀ {G1 G2 : Type u_1} [inst : Group G1] [inst_1 : Group G2] [inst_2 : Fintype G1] [inst_3 : Fintype G2],\n  IsCyclic G1 → IsCyclic G2 → Fintype.card G1 = m → Fintype.card G2 = n →\n  (IsCyclic (G1 × G2) ↔ Nat.Coprime m n) ",
      "∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst₁ : Group G₁] [inst₂ : Group G₂] [inst₃ : IsCyclic G₁] [inst₄ : IsCyclic G₂]\n  [inst₅ : Fintype G₁] [inst₆ : Fintype G₂] {m n : ℕ},\n  Fintype.card G₁ = m → Fintype.card G₂ = n → IsCyclic (G₁ × G₂) ↔ Nat.Coprime m n ",
      "∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst_1 : AddGroup G₁] [inst_2 : AddGroup G₂] [inst_3 : Fintype G₁] [inst_4 : Fintype G₂] [IsAddCyclic G₁] [IsAddCyclic G₂],\n  (∀ {m n : ℕ}, Fintype.card G₁ = m → Fintype.card G₂ = n → IsAddCyclic (G₁ × G₂) ↔ Int.gcd m n = 1) "
    ]
  },
  {
    "docString": "If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by a subgroup gives a singleton then the subgroup is the whole group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\ntheorem ∀ {G : Type u} [inst : Group G] (H : Subgroup G), Subsingleton (G ⧸ H) → H = ⊤ :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$. -/\ntheorem",
    "choices": [
      "forall {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Fintype G] (P : Sylow p G),\n    P.normal → ({ Q : Sylow p G | ∃! Q, Q = P } : Set (Sylow p G)) = {P} ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] {P : Sylow p G},\n  Subgroup.Normal (P : Subgroup G) → ∀ Q : Sylow p G, Q = P ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Sylow p G}, Subgroup.Normal (↑P) → ∀ Q : Sylow p G, Q = P ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  P.normal → ∀ Q : Sylow p G, Q = P ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {P : Sylow p G},\n  P ≤ IsNormalSubgroup.mk (IsNormalSubgroup.mk (Subgroup.normal P)).normal →\n  ∀ Q : Sylow p G, ↑Q = ↑P ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)] (P : Sylow p G),\n  Subgroup.Normal ↑P → ∀ (Q : Sylow p G), Q = P ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] (P : Sylow p G) [inst_1 : Subgroup.Normal (↑P)],\n  ∀ Q : Sylow p G, Q = P ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) [inst_1 : Fact (Nat.Prime p)], Subgroup.Normal (↑P) → ∀ Q : Sylow p G, Q = P ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) [inst_1 : Fact (Nat.Prime p)], Subgroup.Normal (P : Subgroup G) → ∀ Q : Sylow p G, Q = P ",
      "∀ {G : Type u_1} [inst : Group G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Subgroup G) [h : IsPGroup p { x // x ∈ P }],\n  P.normal → (∀ Q : Sylow p G, ↑Q = P) "
    ]
  },
  {
    "docString": "Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card G = p ^ n → Fintype.card { x // x ∈ H } = p ^ (n - 1) → Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ (n - 1) → Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ (n - 1) → Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ (n - 1) → Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ (n - 1) → Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ (n - 1) → Fintype.card G = p ^ n → Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ (n - 1) → Subgroup.Normal H ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n ->\n    forall {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ (n - 1) -> Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ n →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ (n - 1) → Subgroup.Normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ (n - 1) →\n    Fintype.card G = p ^ n → Subgroup.Normal H "
    ]
  },
  {
    "docString": "Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.",
    "prompts": "[{\"theorem\":\n  \"∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk ↑Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the quaternions, as a set. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} (c₁ c₂ : R), Cardinal.mk ↑Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of a quaternion algebra, as a set. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of the quaternions, as a type. \"},\n {\"theorem\":\n  \"∀ (q : Quaternion ℝ), q.re = 0 → exp ℝ q = ↑(Real.cos ‖q‖) + (Real.sin ‖q‖ / ‖q‖) • q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The closed form for the quaternion exponential on imaginary quaternions. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"∀ (z : ℂ),\\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Complex.sin (↑Real.pi * z)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's infinite product formula for the complex sine function. \"},\n {\"theorem\":\n  \"∀ (x : ℝ),\\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\\n    (nhds (Real.sin (Real.pi * x)))\",\n  \"isProp\": true,\n  \"docString\": \"Euler's infinite product formula for the real sine function. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : AddCommGroup M] [inst_1 : Module ℂ M] [inst_2 : FiniteDimensional ℂ M]\\n  (Q₁ Q₂ : QuadraticForm ℂ M),\\n  BilinForm.Nondegenerate (↑QuadraticForm.associated Q₁) →\\n    BilinForm.Nondegenerate (↑QuadraticForm.associated Q₂) → QuadraticForm.Equivalent Q₁ Q₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"All nondegenerate quadratic forms on the complex numbers are equivalent. \"},\n {\"theorem\":\n  \"∀ (q : Quaternion ℝ),\\n  exp ℝ q =\\n    exp ℝ q.re • (↑(Real.cos ‖Quaternion.im q‖) + (Real.sin ‖Quaternion.im q‖ / ‖Quaternion.im q‖) • Quaternion.im q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The closed form for the quaternion exponential on arbitrary quaternions. \"},\n {\"theorem\": \"riemannZeta 0 = -1 / 2\",\n  \"isProp\": true,\n  \"docString\": \"We have `ζ(0) = -1 / 2`. \"}]\n",
    "prompt_cons": "/-- The cardinality of the quaternions, as a set. -/\ntheorem ∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk ↑Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The cardinality of a quaternion algebra, as a set. -/\ntheorem ∀ {R : Type u_1} (c₁ c₂ : R), Cardinal.mk ↑Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The cardinality of the quaternions, as a type. -/\ntheorem ∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R], Cardinal.mk (Quaternion R) = Cardinal.mk R ^ 4 :=\n\n/-- The closed form for the quaternion exponential on imaginary quaternions. -/\ntheorem ∀ (q : Quaternion ℝ), q.re = 0 → exp ℝ q = ↑(Real.cos ‖q‖) + (Real.sin ‖q‖ / ‖q‖) • q :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1 :=\n\n/-- Euler's infinite product formula for the complex sine function. -/\ntheorem ∀ (z : ℂ),\n  Filter.Tendsto (fun n => ↑Real.pi * z * Finset.prod (Finset.range n) fun j => 1 - z ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Complex.sin (↑Real.pi * z))) :=\n\n/-- Euler's infinite product formula for the real sine function. -/\ntheorem ∀ (x : ℝ),\n  Filter.Tendsto (fun n => Real.pi * x * Finset.prod (Finset.range n) fun j => 1 - x ^ 2 / (↑j + 1) ^ 2) Filter.atTop\n    (nhds (Real.sin (Real.pi * x))) :=\n\n/-- All nondegenerate quadratic forms on the complex numbers are equivalent. -/\ntheorem ∀ {M : Type u_1} [inst : AddCommGroup M] [inst_1 : Module ℂ M] [inst_2 : FiniteDimensional ℂ M]\n  (Q₁ Q₂ : QuadraticForm ℂ M),\n  BilinForm.Nondegenerate (↑QuadraticForm.associated Q₁) →\n    BilinForm.Nondegenerate (↑QuadraticForm.associated Q₂) → QuadraticForm.Equivalent Q₁ Q₂ :=\n\n/-- The closed form for the quaternion exponential on arbitrary quaternions. -/\ntheorem ∀ (q : Quaternion ℝ),\n  exp ℝ q =\n    exp ℝ q.re • (↑(Real.cos ‖Quaternion.im q‖) + (Real.sin ‖Quaternion.im q‖ / ‖Quaternion.im q‖) • Quaternion.im q) :=\n\n/-- We have `ζ(0) = -1 / 2`. -/\ntheorem riemannZeta 0 = -1 / 2 :=\n\n/-- Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions. -/\ntheorem",
    "choices": [
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : AddCommGroup R] [inst_3 : HasScalar R (Quaternion R)],\n  (∃ x : Quaternion R, x ^ 2 = -1) ∧ (Cardinal.mk {x : Quaternion R | x ^ 2 = -1} = Cardinal.mk R) ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : AddCommGroup R] [inst_3 : Module R (Quaternion R)], \n  Cardinal.mk (SetOf (λ x : Quaternion R, x ^ 2 = -1)) = Cardinal.mk R ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : Nontrivial R],\n  ∃ s : Set (Quaternion R), (∀ x, x ∈ s → x ^ 2 = -1) ∧ Cardinal.mk s = Cardinal.mk R ",
      "∀ (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R],\n  (∃ n : ℕ, (1 : Quaternion R) = -1) → Infinite {x : Quaternion R | x * x = -1} ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R], (∃ x : Quaternion R, x ^ 2 = -1) ∧ Cardinal.mk {x : Quaternion R | x ^ 2 = -1} = Cardinal.mk R ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : HasScalar R (Quaternion R)],\n  Cardinal.mk (SetOf (λ x : Quaternion R, x ^ 2 = -1)) = Cardinal.mk R ^ 2 ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R], ∃ s : Set (Quaternion R), Cardinal.mk s = Cardinal.mk R ∧ ∀ x ∈ s, x ^ 2 = -1 ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2: HasMul R],\n  (∃ x : R, x * x = -1) → Cardinal.mk {x : R | x * x = -1} = Cardinal.mk R ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R] [inst_2 : HasMul R],\n  (∃ x : R, x * x = -1) → Cardinal.mk (Set {x : R | x * x = -1}) = Cardinal.mk (Set.univ : Set R) ",
      "∀ (R : Type u_1) [inst : One R] [inst_1 : Neg R], \n  ∃s : Set (Quaternion R), (∀x : Quaternion R, x ∈ s → x * x = -1) ∧ Cardinal.mk s = Cardinal.mk R "
    ]
  },
  {
    "docString": "Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X\",\n  \"isProp\": true,\n  \"docString\":\n  \"`X` commutes with everything, even when the coefficients are noncommutative. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\\n  LocalRing (Localization (Ideal.primeCompl I))\",\n  \"isProp\": true,\n  \"docString\":\n  \"The localization of `R` at the complement of a prime ideal is a local ring. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\": \"∀ {R : Type u} [inst : Ring R], ¬IsField (Polynomial R)\",\n  \"isProp\": true,\n  \"docString\": \"`R[X]` is never a field for any ring `R`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\\n  Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S\",\n  \"isProp\": true,\n  \"docString\":\n  \"The definition of `cyclotomic n R` commutes with any ring homomorphism. \"},\n {\"theorem\": \"∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a\",\n  \"isProp\": true,\n  \"docString\": \"Any element commutes with itself. \"},\n {\"theorem\": \"∀ {R : Type u_1} [inst : Monoid R] (a : Rˣ), IsRegular ↑a\",\n  \"isProp\": true,\n  \"docString\": \"If `R` is a monoid, an element in `Rˣ` is regular. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` that is `I`-adically complete is Henselian at `I`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {χ : MulChar R R'}, MulChar.IsQuadratic χ → ∀ (f : R' →+* R''), MulChar.IsQuadratic (MulChar.ringHomComp χ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition with a ring homomorphism preserves the property of being a quadratic character. \"}]\n",
    "prompt_cons": "/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem ∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- `X` commutes with everything, even when the coefficients are noncommutative. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.X * p = p * Polynomial.X :=\n\n/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] (I : Ideal R) [hp : Ideal.IsPrime I],\n  LocalRing (Localization (Ideal.primeCompl I)) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- `R[X]` is never a field for any ring `R`. -/\ntheorem ∀ {R : Type u} [inst : Ring R], ¬IsField (Polynomial R) :=\n\n/-- The definition of `cyclotomic n R` commutes with any ring homomorphism. -/\ntheorem ∀ (n : ℕ) {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : Ring S] (f : R →+* S),\n  Polynomial.map f (Polynomial.cyclotomic n R) = Polynomial.cyclotomic n S :=\n\n/-- Any element commutes with itself. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] (a : S), Commute a a :=\n\n/-- If `R` is a monoid, an element in `Rˣ` is regular. -/\ntheorem ∀ {R : Type u_1} [inst : Monoid R] (a : Rˣ), IsRegular ↑a :=\n\n/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I :=\n\n/-- Composition with a ring homomorphism preserves the property of being a quadratic character. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {χ : MulChar R R'}, MulChar.IsQuadratic χ → ∀ (f : R' →+* R''), MulChar.IsQuadratic (MulChar.ringHomComp χ f) :=\n\n/-- Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : Ring R] (h : ∀ x : R, x^3 = x), ∀ x y : R, x * y = y * x ",
      "∀ {R : Type u} [inst : Ring R], (∀ (x : R), x^3 = x) → IsCommutative R ",
      "∀ {R : Type u_1} [inst : Ring R] (h : ∀ x : R, x^3 = x), IsCommutative R (*) ",
      "∀ {R : Type u} [inst : Ring R] (hr : ∀ (x : R), x ^ 3 = x), IsCommutative R ",
      "∀ {R : Type u} [inst : Ring R] (h : ∀ x : R, x ^ 3 = x), IsCommutative R (*) ",
      "∀ {R : Type u} [inst : Ring R] (H : ∀ (x : R), x^3 = x), CommRing R ",
      "∀ {R : Type u} [inst : Ring R], (∀ x : R, x^3 = x) → IsCommutative R Mul ",
      "∀ {R : Type u_1} [inst : Ring R] (hx : ∀ x : R, x^3 = x), IsCommutative R (*) ",
      "∀ {R : Type u_1} [inst : Ring R] (H : ∀ (x : R), x ^ 3 = x), IsCommutative R Mul ",
      "∀ {R : Type u_1} [inst : Ring R] (h : ∀ x : R, x^3 = x), IsCommutative R (*) "
    ]
  },
  {
    "docString": "Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\\nthen `(q / p) = (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p a b : ℕ}, Nat.coprime a b → p ∈ Nat.factors a → ↑(Nat.factorization (a * b)) p = ↑(Nat.factorization a) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\\nfor any `b` coprime to `a`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p → (p ∣ List.prod L ↔ ∃ a, a ∈ L ∧ p ∣ a)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` \"}]\n",
    "prompt_cons": "/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- If `p` is a prime factor of `b` then `p` is also a prime factor of `a * b` for any `a > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors b → a ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- If `p` is a prime factor of `a` then `p` is also a prime factor of `a * b` for any `b > 0` -/\ntheorem ∀ {p a b : ℕ}, p ∈ Nat.factors a → b ≠ 0 → p ∈ Nat.factors (a * b) :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- **Fermat's Little Theorem**: for all nonzero `a : ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p - 1) = 1 :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes and `p % 4 = 1`,\nthen `(q / p) = (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 1 → q ≠ 2 → legendreSym q ↑p = legendreSym p ↑q :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- If `p` is a prime factor of `a` then the power of `p` in `a` is the same that in `a * b`,\nfor any `b` coprime to `a`. -/\ntheorem ∀ {p a b : ℕ}, Nat.coprime a b → p ∈ Nat.factors a → ↑(Nat.factorization (a * b)) p = ↑(Nat.factorization a) p :=\n\n/-- Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoidWithZero M] {p : M} {L : List M}, Prime p → (p ∣ List.prod L ↔ ∃ a, a ∈ L ∧ p ∣ a) :=\n\n/-- Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → (∃ a b : ℕ, a ≠ 0 ∧ b ≠ 0 ∧ (Finset.sum (Finset.range p) (λ x, (x : ℤ)⁻¹) = (a * b⁻¹ : ℤ))) → ∃ a b : ℕ, a ≠ 0 ∧ b ≠ 0 ∧ (a * b⁻¹ : ℤ) % ↑p = 0 ",
      "forall {p : ℕ} [Fact (Nat.Prime p)], p % 2 = 1 → p ∣ Nat.gcd (Finset.sum (Finset.range (p - 1)) (λ x, (x + 1)⁻¹).num) p ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → p ∣ (Finset.sum (Finset.range (p - 1)) (λ x, ↑(Nat.choose (p - 1) x))) ",
      "forall {p : ℕ} [inst : Fact (Nat.Prime p)], \n  p % 2 = 1 → \n  ∀ {a b : ℕ}, (1 + Finset.sum (Finset.range (p - 1)) (λ x, 1 / (x + 1))) = a / b → p ∣ a ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a b : ℤ}, p % 2 = 1 → p ≠ 2 →\n  ∑ k in Finset.range (p - 1), (↑(k + 1))⁻¹ = a / b → p ∣ a ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p ∣ (\n  List.sum (List.map (λ x, Nat.gcdA x p) (List.range 1 (p - 1))) ) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p ∣ ∑ k in Finset.range (p - 1), (Nat.gcdA k p) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a b : ℕ}, p % 2 = 1 → (1 : ℚ) + Finset.sum (Finset.range (p - 1)) (λ i, 1 / (i + 1)) = a / b → p ∣ a ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → p ∣ Nat.gcd ((Finset.range (p - 1)).sum (λ x, x.denom)) ((Finset.range (p - 1)).sum (λ x, x.numer)) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 → ∀ {a b : ℕ}, a * p = b * (p - 1) → p ∣ a "
    ]
  },
  {
    "docString": "Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  ↑Polynomial.C x ∈\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\\n  (f : R ≃+* S), ↑f 0 = 0\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism sends zero to zero. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` that is `I`-adically complete is Henselian at `I`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : Semiring A] [inst_1 : Algebra ℝ A] ⦃f g : ℂ →ₐ[ℝ] A⦄, ↑f Complex.I = ↑g Complex.I → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two `ℝ`-algebra homomorphisms from `ℂ` are equal if they agree on `Complex.I`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : Ring S]\\n  [inst_3 : IsDomain S] [inst_4 : Algebra R S] {n : Type u_3} {m : Type u_4} [inst_5 : Fintype n] [inst_6 : Fintype m],\\n  Basis n R S → ∀ {I : Ideal S}, I ≠ ⊥ → Basis m R { x // x ∈ I } → Fintype.card m = Fintype.card n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `S` a module-finite free `R`-algebra, then the `R`-rank of a nonzero `R`-free\\nideal `I` of `S` is the same as the rank of `S`. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` has characteristic `0`, then so does `FractionRing R`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"}]\n",
    "prompt_cons": "/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥ :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  ↑Polynomial.C x ∈\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\n    x = 0 :=\n\n/-- A ring isomorphism sends zero to zero. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S]\n  (f : R ≃+* S), ↑f 0 = 0 :=\n\n/-- A ring is a `ℚ`-algebra iff it has equal characteristic zero. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I) :=\n\n/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I :=\n\n/-- Two `ℝ`-algebra homomorphisms from `ℂ` are equal if they agree on `Complex.I`. -/\ntheorem ∀ {A : Type u_1} [inst : Semiring A] [inst_1 : Algebra ℝ A] ⦃f g : ℂ →ₐ[ℝ] A⦄, ↑f Complex.I = ↑g Complex.I → f = g :=\n\n/-- If `S` a module-finite free `R`-algebra, then the `R`-rank of a nonzero `R`-free\nideal `I` of `S` is the same as the rank of `S`. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : StrongRankCondition R] [inst_2 : Ring S]\n  [inst_3 : IsDomain S] [inst_4 : Algebra R S] {n : Type u_3} {m : Type u_4} [inst_5 : Fintype n] [inst_6 : Fintype m],\n  Basis n R S → ∀ {I : Ideal S}, I ≠ ⊥ → Basis m R { x // x ∈ I } → Fintype.card m = Fintype.card n :=\n\n/-- If `R` has characteristic `0`, then so does `FractionRing R`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CharZero R], CharZero (FractionRing R) :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : CharZero R], ∀ (I : Ideal (Matrix (Fin 2) (Fin 2) R)),\n  I = ⊥ ∨ I = ⊤ ",
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (I : Ideal (Matrix (Finₓ 2) (Finₓ 2) R)),\n  Ideal.IsPrime I → Ideal.IsMaximal I ",
      "∀ (I : Ideal (Matrix (Finₓ 2) (Finₓ 2) ℝ)), I = ⊥ ∨ I = ⊤ ",
      "∀ (I : Ideal (Matrix (Finₓ 2) (Finₓ 2) ℝ)), I = ⊥ ∨ I = ⊤ ",
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  (∀ (I : Ideal (Matrix (Finₓ 2) (Finₓ 2) R)), I = ⊥ ∨ I = ⊤) →\n  ∀ (I : Ideal R), I = ⊥ ∨ I = ⊤ ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] (I : Ideal (Matrix (Finₓ 2) (Finₓ 2) R)),\n  I = ⊥ ∨ I = ⊤ ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Algebra ℝ R],\n(∀ (I : Ideal R), I = ⊥ ∨ I = ⊤) ↔ R ≃+* Matrix (Finₓ 2) (Finₓ 2) ℝ ",
      "∀ {R : Type u} [inst : Ring R] [inst_1 : IsDomain R] [inst_2 : Algebra ℝ R₂] (I : Ideal R), I = ⊥ ∨ I = ⊤ ",
      "∀ {R : Type u} [inst : CommRing R] {I : Ideal (Matrix (Fin 2) (Fin 2) R)}, I = ⊥ ∨ I = ⊤ ",
      "∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Matrix (Finₓ 2) (Finₓ 2) R)),\n  I = ⊥ ∨ I = ⊤ "
    ]
  },
  {
    "docString": "Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α)\",\n  \"isProp\": true,\n  \"docString\": \"A finite field has prime power cardinality. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ {f : Polynomial ℚ} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of `ℚ[X]` by the ideal generated by an irreducible polynomial of `ℚ[X]`\\nis a number field. \"},\n {\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {ι : Type u_1} {g : ι → Polynomial R} {s : Finset ι},\\n  (∀ (i : ι), i ∈ s → Polynomial.Monic (g i)) →\\n    (Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) →\\n      ∃ q r,\\n        (∀ (i : ι), i ∈ s → Polynomial.degree (r i) < Polynomial.degree (g i)) ∧\\n          (↑f / Finset.prod s fun i => ↑(g i)) = ↑q + Finset.sum s fun i => ↑(r i) / ↑(g i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\\n\"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. \"},\n {\"theorem\":\n  \"∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1\",\n  \"isProp\": true,\n  \"docString\": \"This lemma is for polynomials over a field. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- A finite field has prime power cardinality. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Field α], IsPrimePow (Fintype.card α) :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem ∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- The quotient of `ℚ[X]` by the ideal generated by an irreducible polynomial of `ℚ[X]`\nis a number field. -/\ntheorem ∀ {f : Polynomial ℚ} [hf : Fact (Irreducible f)], NumberField (AdjoinRoot f) :=\n\n/-- Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime. -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {ι : Type u_1} {g : ι → Polynomial R} {s : Finset ι},\n  (∀ (i : ι), i ∈ s → Polynomial.Monic (g i)) →\n    (Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) →\n      ∃ q r,\n        (∀ (i : ι), i ∈ s → Polynomial.degree (r i) < Polynomial.degree (g i)) ∧\n          (↑f / Finset.prod s fun i => ↑(g i)) = ↑q + Finset.sum s fun i => ↑(r i) / ↑(g i) :=\n\n/-- **Fermat's Little Theorem**: for all `a : ℤ` coprime to `p`, we have\n`a ^ (p - 1) ≡ 1 [ZMOD p]`. -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℤ}, IsCoprime n ↑p → n ^ (p - 1) ≡ 1 [ZMOD ↑p] :=\n\n/-- This lemma is for polynomials over a field. -/\ntheorem ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) (f : Polynomial K),\n  Polynomial.Splits i f ↔ f = 0 ∨ ∀ {g : Polynomial L}, Irreducible g → g ∣ Polynomial.map i f → Polynomial.degree g = 1 :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements. -/\ntheorem",
    "choices": [
      "∀ {F : Type u_1} [inst : Field F] (q : Polynomial F) [inst_1 : Fact (Polynomial.Irreducible q)] {p : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card (Zmod p) = p →\n    (∀ n : ℕ, Polynomial.degree q = n → Fintype.card (QuotientRing.Quotient (Ideal.span (singleton q))) = p ^ n) ",
      "∀ {p : ℕ} [hp : Fact (Nat.Prime p)] {n : ℕ} {q : Polynomial (Zmod p)},\n  Irreducible q → Polynomial.degree q = n → Fintype.card (AdjoinRoot q) = p ^ n ",
      "∀ {p : ℕ} {n : ℕ} [inst : Fact (Nat.Prime p)] {F : Type u_1} [inst_1 : Field F] [inst_2 : Fintype F] {q : Polynomial F},\n  (Polynomial.degree q = n) → Irreducible q → Fintype.card (AdjoinRoot q) = p ^ n ",
      "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  ∀ {q : Polynomial F}, Polynomial.degree q = n → Irreducible q → Fintype.card (Polynomial.QuotientRing q) = p ^ n ",
      "∀ {F : Type u_1} [inst : Field F] {p n : ℕ} [hp : Fact (Nat.Prime p)] [hn : Fact (0 < n)] {q : Polynomial F},\n  Polynomial.degree q = n → Irreducible q → Fintype.card (Polynomial.QuotientRing (Polynomial.divideByMonic q)) = p ^ n ",
      "∀ {F : Type u} [inst : Field F] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] {R : Type u_1} [inst_2 : CommRing R] [inst_3 : IsDomain R] {q : Polynomial F},\n  Polynomial.degree q = p ^ (Polynomial.natDegree q) → Irreducible q → Fintype.card (R ⧸ Ideal.span (singleton q)) = p ^ (Polynomial.natDegree q) ",
      "∀ {F : Type u} [inst : Field F] {p : ℕ} [char_p : CharP F p] [hp : Fact (Nat.Prime p)] {n : ℕ} (q : Polynomial F),\n  Irreducible q → Polynomial.degree q = n → Fintype.card (Polynomial.Quotient (Polynomial.maximal_ideal q)) = p ^ n ",
      "∀ {F : Type u_1} [inst : Field F] {p : ℕ} [hp : Fact (Nat.Prime p)] (n : ℕ) (q : Polynomial F),\n  Irreducible q → Polynomial.degree q = n → Fintype.card (AdjoinRoot q) = p ^ n ",
      "∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] {p : ℕ} [Fact (Nat.Prime p)] [CharP F p] {q : Polynomial F} {n : ℕ},\n  Irreducible q → Polynomial.degree q = n → Fintype.card (QuotientRing.Quotient (Polynomial.spanSingleton q)) = p ^ n ",
      "∀ {F : Type u} [inst : Field F] (p : ℕ) [inst_1 : Fact (Nat.Prime p)] [hp : CharP F p] {n : ℕ} {q : Polynomial F},\n  Irreducible q → Polynomial.degree q = n →\n    Fintype.card (Polynomial.QuotientRing (Polynomial.quotientRing.mk' q)) = p ^ n "
    ]
  },
  {
    "docString": "If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\": \"∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\\n  p + q ≠ 0 →\\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) ≤ Polynomial.rootMultiplicity a (p + q)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The multiplicity of `p + q` is at least the minimum of the multiplicities. \"}]\n",
    "prompt_cons": "/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- The `p`-adic norm of `q` is `1` if `q` is prime and not equal to `p`. -/\ntheorem ∀ {p q : ℕ} [p_prime : Fact (Nat.Prime p)] [q_prime : Fact (Nat.Prime q)], p ≠ q → padicNorm p ↑q = 1 :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- If `p` is prime, then `cyclotomic p R = ∑ i in range p, X ^ i`. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Polynomial.cyclotomic p R = Finset.sum (Finset.range p) fun i => Polynomial.X ^ i :=\n\n/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/\ntheorem ∀ (p' : ℕ), 2 < LucasLehmer.q (p' + 2) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- The multiplicity of `p + q` is at least the minimum of the multiplicities. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {p q : Polynomial R} (a : R),\n  p + q ≠ 0 →\n    min (Polynomial.rootMultiplicity a p) (Polynomial.rootMultiplicity a q) ≤ Polynomial.rootMultiplicity a (p + q) :=\n\n/-- If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : Field R] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i + 1) ",
      "forall {p : ℕ} (hp : Nat.Prime p),\n  Irreducible (Finset.sum (Finset.range p) (fun i => Polynomial.X ^ i) : Polynomial ℚ) ",
      "∀ {p : ℕ}, Nat.Prime p → Irreducible (Polynomial.evalRing (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i)) ",
      "∀ (p : ℕ), Nat.Prime p → Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.x_pow i) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)],\n  Irreducible (Polynomial.sum (Finset.range p) (λ i, Polynomial.X ^ i) : Polynomial ℚ) ",
      "∀ (p : ℕ) [hp : Fact (Nat.Prime p)], Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i + 1) ",
      "∀ (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Irreducible (Polynomial.sum (Finset.range p) (λ i, Polynomial.X ^ i) : Polynomial ℚ) ",
      "∀ (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.C (1 : ℚ) * Polynomial.X ^ i) ",
      "∀ (p : ℕ) [hp : Fact (Nat.Prime p)],\n  Irreducible (Finset.sum (Finset.range p) fun i => Polynomial.X ^ i + 1 : Polynomial ℚ) ",
      "∀ {p : ℕ}, Nat.Prime p → Irreducible (Polynomial.sum (Finset.range p) (λ i => Polynomial.X ^ i) : Polynomial ℚ) "
    ]
  },
  {
    "docString": "Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"∀ (S : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite ↑S] [inst_6 : IsCyclotomicExtension S A B],\\n  Algebra.IsIntegral A B\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite cyclotomic extension of an integral noetherian domain is integral \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ (R : Type w₁) [inst : CommRing R] (ι : Type u_2) [inst_1 : Finite ι], Algebra.FinitePresentation R (MvPolynomial ι R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The ring of polynomials in finitely many variables is finitely presented. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I :=\n\n/-- A finite cyclotomic extension of an integral noetherian domain is integral -/\ntheorem ∀ (S : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsDomain B] [inst_4 : IsNoetherianRing A] [inst_5 : Finite ↑S] [inst_6 : IsCyclotomicExtension S A B],\n  Algebra.IsIntegral A B :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- The ring of polynomials in finitely many variables is finitely presented. -/\ntheorem ∀ (R : Type w₁) [inst : CommRing R] (ι : Type u_2) [inst_1 : Finite ι], Algebra.FinitePresentation R (MvPolynomial ι R) :=\n\n/-- Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$. -/\ntheorem",
    "choices": [
      "∃ (a₀ : ℤ), ∀ (a : ℤ), a₀ ≤ a → Irreducible (Polynomial.x ^ 7 + Polynomial.C 15 * Polynomial.x ^ 2 - Polynomial.C 30 * Polynomial.x + Polynomial.C a) ",
      "∀ (f : ℕ → Polynomial ℚ),\n  (∀ (n : ℕ), f n = Polynomial.x ^ 7 + Polynomial.C (15 : ℚ) * (Polynomial.x ^ 2) - Polynomial.C (30 : ℚ) * Polynomial.x + Polynomial.C (↑n : ℚ)) →\n  ∃ (S : Set ℕ), Set.Infinite S ∧ ∀ (n : ℕ), n ∈ S → Irreducible (f n) ",
      "∃ (s : ℕ → ℤ), Function.Injective s ∧ ∀ (n : ℕ), Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C (s n))) ",
      "∃ (a : ℤ) (ha : ∀ (b : ℤ), a ≤ b → Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C b)) ",
      "∃ (a : ℤ), ∀ (f : Polynomial ℚ), f = Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C a) → Irreducible f ",
      "∃ (f : ℕ → Polynomial ℤ), (∀ (n : ℕ), f n = Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + n) ∧\n  ∀ (n : ℕ), Irreducible (Polynomial.map (Int.castRingHom ℚ) (f n)) ",
      "∃ {s : ℕ → ℤ}, Function.Injective s ∧ ∀ (n : ℕ), Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C (s n)) ",
      "∃ (s : ℕ → ℤ), Function.Injective s ∧ ∀ (n : ℕ), Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + Polynomial.C (s n)) ",
      "∃ (s : ℕ → ℤ), StrictMono s ∧ ∀ (n : ℕ), Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + (s n)) ",
      "∃ N : ℕ, ∀ n : ℕ, N ≤ n → Irreducible (Polynomial.x ^ 7 + 15 * Polynomial.x ^ 2 - 30 * Polynomial.x + n) "
    ]
  },
  {
    "docString": "Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.",
    "prompts": "[{\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is closed. \"},\n {\"theorem\":\n  \"∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\\n  FiniteDimensional k\\n    ↑(CategoryTheory.Limits.limit\\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k))))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Finite limits of finite dimensional vectors spaces are finite dimensional,\\nbecause we can realise them as subobjects of a finite product. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\\n    ∀ (f : V'' →ₗ[R] V),\\n      Function.Injective ↑f →\\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\\n\\nThe statement we prove is actually slightly more general:\\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\\n * the function `f' : V'' → V'` doesn't need to be injective\\n\"},\n {\"theorem\":\n  \"∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] (E : Type v) [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : ProperSpace 𝕜] [inst : FiniteDimensional 𝕜 E], ProperSpace E\",\n  \"isProp\": true,\n  \"docString\":\n  \"Any finite-dimensional vector space over a proper field is proper.\\nWe do not register this as an instance to avoid an instance loop when trying to prove the\\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\\nexplicitly when needed. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s\",\n  \"isProp\": true,\n  \"docString\": \"A finite-dimensional subspace is complete. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\\n  IsClosed s →\\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a Noetherian space, every closed set is a finite union of irreducible closed sets. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nonempty open subset of a preirreducible subspace is dense in the subspace. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subspace of a finite-dimensional space is also finite-dimensional. \"}]\n",
    "prompt_cons": "/-- A finite-dimensional subspace is closed. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsClosed ↑s :=\n\n/-- Finite limits of finite dimensional vectors spaces are finite dimensional,\nbecause we can realise them as subobjects of a finite product. -/\ntheorem ∀ {J : Type} [inst : CategoryTheory.SmallCategory J] [inst_1 : CategoryTheory.FinCategory J] {k : Type v}\n  [inst_2 : Field k] (F : CategoryTheory.Functor J (FGModuleCat k)),\n  FiniteDimensional k\n    ↑(CategoryTheory.Limits.limit\n        (CategoryTheory.Functor.comp F (CategoryTheory.forget₂ (FGModuleCat k) (ModuleCat k)))) :=\n\n/-- Let `V` be a vector space over `K = Frac(R)`, `S / R` a ring extension\nand `V'` a module over `S`. If `b`, in the intersection `V''` of `V` and `V'`,\nis linear independent over `S` in `V'`, then it is linear independent over `R` in `V`.\n\nThe statement we prove is actually slightly more general:\n * it suffices that the inclusion `algebraMap R S : R → S` is nontrivial\n * the function `f' : V'' → V'` doesn't need to be injective -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {S : Type v} [inst_1 : CommRing S] [inst_2 : Algebra R S] (K : Type u_5)\n  [inst_3 : Field K] [inst_4 : Algebra R K] [hRK : IsFractionRing R K] {V : Type u_2} {V' : Type u_3} {V'' : Type u_1}\n  [inst_5 : AddCommGroup V] [inst_6 : Module R V] [inst_7 : Module K V] [inst_8 : IsScalarTower R K V]\n  [inst_9 : AddCommGroup V'] [inst_10 : Module R V'] [inst_11 : Module S V'] [inst_12 : IsScalarTower R S V']\n  [inst_13 : AddCommGroup V''] [inst_14 : Module R V''] [inst_15 : IsDomain R] [inst_16 : IsDedekindDomain R],\n  RingHom.ker (algebraMap R S) ≠ ⊤ →\n    ∀ (f : V'' →ₗ[R] V),\n      Function.Injective ↑f →\n        ∀ (f' : V'' →ₗ[R] V') {ι : Type u_4} {b : ι → V''}, LinearIndependent S (↑f' ∘ b) → LinearIndependent K (↑f ∘ b) :=\n\n/-- Any finite-dimensional vector space over a proper field is proper.\nWe do not register this as an instance to avoid an instance loop when trying to prove the\nproperness of `𝕜`, and the search for `𝕜` as an unknown metavariable. Declare the instance\nexplicitly when needed. -/\ntheorem ∀ (𝕜 : Type u) [inst : NontriviallyNormedField 𝕜] (E : Type v) [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : ProperSpace 𝕜] [inst : FiniteDimensional 𝕜 E], ProperSpace E :=\n\n/-- A finite-dimensional subspace is complete. -/\ntheorem ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type v} [inst_1 : NormedAddCommGroup E]\n  [inst_2 : NormedSpace 𝕜 E] [inst_3 : CompleteSpace 𝕜] (s : Submodule 𝕜 E)\n  [inst_4 : FiniteDimensional 𝕜 { x // x ∈ s }], IsComplete ↑s :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] {s : Set α},\n  IsClosed s →\n    ∃ S, Set.Finite S ∧ (∀ (t : Set α), t ∈ S → IsClosed t) ∧ (∀ (t : Set α), t ∈ S → IsIrreducible t) ∧ s = ⋃₀ S :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\n  AffineIndependent k f → Set.Finite s :=\n\n/-- A nonempty open subset of a preirreducible subspace is dense in the subspace. -/\ntheorem ∀ {α : Type u} [inst : TopologicalSpace α] {S U : Set α},\n  IsPreirreducible S → IsOpen U → Set.Nonempty (S ∩ U) → S ⊆ closure (S ∩ U) :=\n\n/-- A subspace of a finite-dimensional space is also finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V]\n  [inst_3 : FiniteDimensional K V] (S : Submodule K V), FiniteDimensional K { x // x ∈ S } :=\n\n/-- Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$. -/\ntheorem",
    "choices": [
      "∀ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  [inst_3 : Infinite F] (hF : Infinite F), ¬(∃ (n : ℕ) (S : Finₓ n → Submodule F V), V = ⋃ (i : Finₓ n), ↑(S i)) ",
      "∀ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  [inst_3 : Infinite F] [inst_4 : IsNoetherian F V], ¬∃ S : Set (Submodule F V),\n    Set.Finite S ∧ ∀ (x : V), (∃ (s : Submodule F V) (H : s ∈ S), x ∈ s) ∧ (∀ s : Submodule F V, s ∈ S → s < ⊤) ",
      "∀ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F]\n  {ι : Type u_1} [inst_4 : Finite ι] {S : ι → Submodule F V}, (⋃ (i : ι), ↑(S i)) = Set.Univ → ∃ i, S i = ⊤ ",
      "∀ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  ∀ {ι : Type u_1} [inst_4 : Fintype ι] (S : ι → Submodule F V), (∀ i, S i < ⊤) → ∃ x : V, x ∉ ⋃ (i : ι), ↑(S i) ",
      "forall {F : Type u} {V : Type v} [inst : DivisionRing F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] {ι : Type w}\n  [inst_3 : Fintype ι] (S : ι → Submodule F V), (∀ i, S i < ⊤) → ¬(V = ⋃ i, ↑(S i)) ",
      "∀ (F : Type u) [inst : Field F] [inst_1 : Infinite F] (V : Type v) [inst_2 : AddCommGroup V] [inst_3 : Module F V],\n  ¬(∃ (I : Type u_1) (s : I → Submodule F V), Set.Finite (Set.Range s) ∧ V = ⋃ (i : I), ↑(s i) ∧ ∀ (i : I), s i < ⊤) ",
      "∀ (F : Type u) (V : Type v) [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  ∀ (s : Set (Submodule F V)), Set.Finite s → (∀ (S : Submodule F V), S ∈ s → S < ⊤) → ∃ x : V, x ∉ ⋃₀ s ",
      "∀ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V]\n  [inst_3 : Infinite F] (n : ℕ) (S : Finₓ (n + 1) → Submodule F V),\n  (∀ (i : Finₓ (n + 1)), S i < ⊤) → ⊤ ≠ ⨆ (i : Finₓ (n + 1)), S i ",
      "∀ {F : Type u} {V : Type v} [inst : Field F] [inst_1 : AddCommGroup V] [inst_2 : Module F V] [inst_3 : Infinite F],\n  ∀ {ι : Type u_1} [inst_4 : Fintype ι] (S : ι → Submodule F V), ¬(V = ⋃ (i : ι), ↑(S i)) ",
      "∀ (F : Type u) {V : Type v} [inst : Field F] [inst_1 : Infinite F] [inst_2 : AddCommGroup V] [inst_3 : Module F V]\n  (S : Set (Submodule F V)), Set.Finite S → ∃ (x : V), ∀ (s : Submodule F V), s ∈ S → x ∉ s "
    ]
  },
  {
    "docString": "Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"∀ (A : Matrix.SpecialLinearGroup (Fin 2) ℤ), SlashAction.map ℂ 0 A 1 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The constant function 1 is invariant under any element of `SL(2, ℤ)`. \"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)},\\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.δ X i)\\n      (CategoryTheory.CosimplicialObject.δ X (Fin.castSucc i)) =\\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.δ X i)\\n      (CategoryTheory.CosimplicialObject.δ X (Fin.succ i))\",\n  \"isProp\": true,\n  \"docString\": \"The special case of the first cosimplicial identity \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a ≠ 0 → ↑(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} (c₁ c₂ : R), Cardinal.mk ↑Set.univ = Cardinal.mk R ^ 4\",\n  \"isProp\": true,\n  \"docString\": \"The cardinality of a quaternion algebra, as a set. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x ∈ ↑(LieAlgebra.radical R L) }\",\n  \"isProp\": true,\n  \"docString\": \"The radical of a Noetherian Lie algebra is solvable. \"},\n {\"theorem\":\n  \"LieGroup (modelWithCornersSelf ℝ (EuclideanSpace ℝ (Fin 1))) { x // x ∈ circle }\",\n  \"isProp\": true,\n  \"docString\": \"The unit circle in `ℂ` is a Lie group. \"},\n {\"theorem\":\n  \"∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"An algebraic integer whose conjugates are all of norm one is a root of unity. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"}]\n",
    "prompt_cons": "/-- The constant function 1 is invariant under any element of `SL(2, ℤ)`. -/\ntheorem ∀ (A : Matrix.SpecialLinearGroup (Fin 2) ℤ), SlashAction.map ℂ 0 A 1 = 1 :=\n\n/-- The special case of the first cosimplicial identity -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] (X : CategoryTheory.CosimplicialObject C) {n : ℕ} {i : Fin (n + 2)},\n  CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.δ X i)\n      (CategoryTheory.CosimplicialObject.δ X (Fin.castSucc i)) =\n    CategoryTheory.CategoryStruct.comp (CategoryTheory.CosimplicialObject.δ X i)\n      (CategoryTheory.CosimplicialObject.δ X (Fin.succ i)) :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a ≠ 0 → ↑(quadraticChar F) a ^ 2 = 1 :=\n\n/-- The cardinality of a quaternion algebra, as a set. -/\ntheorem ∀ {R : Type u_1} (c₁ c₂ : R), Cardinal.mk ↑Set.univ = Cardinal.mk R ^ 4 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p :=\n\n/-- The radical of a Noetherian Lie algebra is solvable. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst_3 : IsNoetherian R L], LieAlgebra.IsSolvable R { x // x ∈ ↑(LieAlgebra.radical R L) } :=\n\n/-- The unit circle in `ℂ` is a Lie group. -/\ntheorem LieGroup (modelWithCornersSelf ℝ (EuclideanSpace ℝ (Fin 1))) { x // x ∈ circle } :=\n\n/-- An algebraic integer whose conjugates are all of norm one is a root of unity. -/\ntheorem ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K] (A : Type u_2) [inst_2 : NormedField A]\n  [inst_3 : IsAlgClosed A] [inst_4 : NormedAlgebra ℚ A] {x : K},\n  IsIntegral ℤ x → (∀ (φ : K →+* A), ‖↑φ x‖ = 1) → ∃ n x_1, x ^ n = 1 :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "alg_cos_deg1 : IsAlgebraic ℚ (Real.cos (Real.pi / 180)) ",
      "IsAlgebraic ℚ (Real.cos (Real.pi / 180)) ",
      "ℂ.cos (1 * (↑(Real.pi) / 180)) = algebraic ℚ ",
      "IsAlgebraic ℚ (Real.cos (Real.pi / 180)) ",
      "∀ (K : Type u_1) [inst : Field K] [inst_1 : Algebra ℝ K] [inst_2 : IsAlgClosed (AlgebraicClosure K)],\n  IsAlgebraic ℚ (Real.cos (Real.pi / 180)) ",
      "CosOneAlgebraic : IsAlgebraic ℚ (Real.cos (Real.deg (1 : ℝ))) ",
      "IsAlgebraic ℚ (Real.cos (Real.pi / 180)) ",
      "Alg.cos_deg_one : IsAlgebraic ℚ (Real.cos (Real.pi / 180)) ",
      "∀ (x : ℚ) [inst : Algebra ℚ ℝ],\n  Real.cos (x * (π / 180)) ≠ 0 → IsAlgebraic ℚ (Real.cos (x * (π / 180))) ",
      "∀ {F : Type u_1} [inst : Field F] [inst_1 : Algebra ℝ F] [inst_2 : Field F] [inst_3 : Algebra ℝ F],\n  IsAlgebraic ℚ (Real.cos (Real.deg 1)) "
    ]
  },
  {
    "docString": "Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n → ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K], minpoly ℤ μ ∣ Polynomial.X ^ n - 1 :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "irreducible_x_pow_3_sub_3_x_sub_1 : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "x_pow_three_minus_3x_minus_one_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "x_pow_three_minus_three_x_minus_one_irreducible :\n  Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "irreducible_x_pow_three_minus_three_x_minus_one : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "theorem x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "x_pow_3_minus_3x_minus_1_irreducible : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) ",
      "irreducible_x_pow_three_minus_three_x_minus_one : Irreducible (Polynomial.x ^ 3 - 3 * Polynomial.x - 1 : Polynomial ℚ) "
    ]
  },
  {
    "docString": "Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b * a ∈ H) (b ∈ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\\nof `b * a` and `b` belong to `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\\n  AddSubgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An additive subgroup has index two if and only if there exists `a` such that\\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.\"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a\",\n  \"isProp\": true,\n  \"docString\": \"If `a` commutes with `b`, then `b` commutes with `a`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"}]\n",
    "prompt_cons": "/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, Subgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b * a ∈ H) (b ∈ H) :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G},\n  AddSubgroup.index H = 2 ↔ ∃ a, ∀ (b : G), Xor' (b + a ∈ H) (b ∈ H) :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Mul S] {a b : S}, Commute a b → Commute b a :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K :=\n\n/-- If `a` commutes with `b`, then `b` commutes with `a`. -/\ntheorem ∀ {S : Type u_1} [inst : Add S] {a b : S}, AddCommute a b → AddCommute b a :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {a b : G}, Commute a b → IsAddSubgroup {g : G | ∃ (l : List G), List.prod l = g ∧ (∀ (x : G), x ∈ l → x = a ∨ x = b)} ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G}, Commute a b → ∀ (c d : G), (c ∈ Subgroup.closure {a, b}) → (d ∈ Subgroup.closure {a, b}) → Commute c d ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G} (H : Subgroup G), H = Subgroup.closure {a, b} → Commute a b → ∀ (x y : G), x ∈ H → y ∈ H → Commute x y ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G}, Commute a b → ∀ (x y : G), x ∈ Subgroup.closure {a, b} → y ∈ Subgroup.closure {a, b} → Commute x y ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G}, Commute a b → ∀ (z : G), z ∈ Subgroup.closure ({a, b}) → ∀ (y : G), y ∈ Subgroup.closure ({a, b}) → Commute z y ",
      "forall {G : Type u_1} [inst : Group G] {a b : G}, Commute a b → IsAddCommGroup (Subgroup.closure ({a, b} : Set G)) ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G) (H : Subgroup G),\n  H = Subgroup.closure {a, b} → IsConj a b → ∀ (x y : G), x ∈ H → y ∈ H → Commute x y ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G} (H : Subgroup G),\n  H = Subgroup.closure {a, b} → Commute a b → IsCommutative H Mul.comm ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G}, Commute a b → (∀ (x y : G), x ∈ Subgroup.closure {a, b} → y ∈ Subgroup.closure {a, b} → Commute x y) ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G} (H : Subgroup G),\n  H = Subgroup.closure {a, b} → Commute a b → ∀ (x y : G), x ∈ H → y ∈ H → Commute x y "
    ]
  },
  {
    "docString": "Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group with zero, the center of the units is the preimage of the center. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsAddCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- In a group with zero, the center of the units is the preimage of the center. -/\ntheorem ∀ {M : Type u_1} [inst : GroupWithZero M], Set.center Mˣ = Units.val ⁻¹' Set.center M :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsAddCyclic α :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ a ∈ G, orderOf a = 2 ∧ ∀ b ∈ G, orderOf b = 2 → b = a) → (∃ z, z ∈ Subgroup.center G ∧ orderOf z = 2) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (∃! x : G, orderOf x = 2) → ∃ y : G, y ∈ Subgroup.center G ∧ orderOf y = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (∃! a : G, orderOf a = 2) → ∃ b : G, b ∈ Subgroup.center G ∧ orderOf b = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃ a : G, orderOf a = 2 ∧ ∀ b : G, orderOf b = 2 → b = a) → ∀ c : G, orderOf c = 2 → c ∈ Subgroup.center G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃! (x : G), orderOf x = 2) → ∃ (z : G), z ∈ Subgroup.center G ∧ orderOf z = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], (∃! x : G, orderOf x = 2) → Exists (λ x : G, orderOf x = 2 ∧ x ∈ Subgroup.center G) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (∃! a, orderOf a = 2) → (∃ a, a ∈ Subgroup.center G ∧ orderOf a = 2) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : ∃! (g : G), orderOf g = 2),\n  (∃ (x : G), orderOf x = 2) → ∃ (x : G), x ∈ Subgroup.center G ∧ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, (∀ y : G, y ^ 2 = 1 ↔ y = x) → x ∈ Subgroup.center G ",
      "∀ {G : Type u_1} [inst : Group G] (x : G), (∀ y : G, orderOf y = 2 → y = x) → x ^ 2 = 1 → x ∈ Subgroup.center G "
    ]
  },
  {
    "docString": "Prove that a group of even order contains an element of order $2 .$",
    "prompts": "[{\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ (p' : ℕ), lucasLehmerResidue (p' + 2) = 0 → orderOf (LucasLehmer.ωUnit (p' + 2)) = 2 ^ (p' + 2)\",\n  \"isProp\": true,\n  \"docString\": \"The order of `ω` in the unit group is exactly `2^p`. \"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x\",\n  \"isProp\": true,\n  \"docString\": \"The convolution of two even functions is also even. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\\n          P x hx →\\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property is true on the odd parts, it suffices to show it is true on the\\nvectors, closed under addition, and under left-multiplication by a pair of vectors. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"}]\n",
    "prompt_cons": "/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- The order of `ω` in the unit group is exactly `2^p`. -/\ntheorem ∀ (p' : ℕ), lucasLehmerResidue (p' + 2) = 0 → orderOf (LucasLehmer.ωUnit (p' + 2)) = 2 ^ (p' + 2) :=\n\n/-- The convolution of two even functions is also even. -/\ntheorem ∀ {𝕜 : Type u𝕜} {G : Type uG} {E : Type uE} {E' : Type uE'} {F : Type uF} [inst : NormedAddCommGroup E]\n  [inst_1 : NormedAddCommGroup E'] [inst_2 : NormedAddCommGroup F] {f : G → E} {g : G → E'} {x : G}\n  [inst_3 : NontriviallyNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E] [inst_5 : NormedSpace 𝕜 E'] [inst_6 : NormedSpace 𝕜 F]\n  (L : E →L[𝕜] E' →L[𝕜] F) [inst_7 : MeasurableSpace G] {μ : MeasureTheory.Measure G} [inst_8 : NormedSpace ℝ F]\n  [inst_9 : AddCommGroup G] [inst_10 : MeasureTheory.Measure.IsAddLeftInvariant μ]\n  [inst_11 : MeasureTheory.Measure.IsNegInvariant μ] [inst_12 : MeasurableNeg G] [inst_13 : MeasurableAdd G],\n  (∀ᵐ (x : G) ∂μ, f (-x) = f x) → (∀ᵐ (x : G) ∂μ, g (-x) = g x) → convolution f g L (-x) = convolution f g L x :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- To show a property is true on the odd parts, it suffices to show it is true on the\nvectors, closed under addition, and under left-multiplication by a pair of vectors. -/\ntheorem ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (Q : QuadraticForm R M) {P : (x : CliffordAlgebra Q) → x ∈ CliffordAlgebra.evenOdd Q 1 → Prop},\n  (∀ (v : M), P (↑(CliffordAlgebra.ι Q) v) (_ : ↑(CliffordAlgebra.ι Q) v ∈ CliffordAlgebra.evenOdd Q 1)) →\n    (∀ {x y : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1} {hy : y ∈ CliffordAlgebra.evenOdd Q 1},\n        P x hx → P y hy → P (x + y) (_ : x + y ∈ CliffordAlgebra.evenOdd Q 1)) →\n      (∀ (m₁ m₂ : M) {x : CliffordAlgebra Q} {hx : x ∈ CliffordAlgebra.evenOdd Q 1},\n          P x hx →\n            P (↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x)\n              (_ : ↑(CliffordAlgebra.ι Q) m₁ * ↑(CliffordAlgebra.ι Q) m₂ * x ∈ CliffordAlgebra.evenOdd Q 1)) →\n        ∀ (x : CliffordAlgebra Q) (hx : x ∈ CliffordAlgebra.evenOdd Q 1), P x hx :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- Prove that a group of even order contains an element of order $2 .$ -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ (x : G), orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ (x : G), orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ (x : G), x ≠ 1 ∧ x ^ 2 = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  (Fintype.card G % 2 = 0) → ∃ (x : G), orderOf x = 2 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ x : G, orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ (x : G), orderOf x = 2 ",
      "∀ {G : Type u} [inst : Fintype G] [inst_1 : Group G], 2 ∣ Fintype.card G → ∃ (x : G), orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ (x : G), orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], \n  Fintype.card G % 2 = 0 → ∃ (x : G), orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G % 2 = 0 → ∃ (x : G), orderOf x = 2 "
    ]
  },
  {
    "docString": "Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.",
    "prompts": "[{\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\\n  [inst_3 : Fintype ι] {b : ι → V}, LinearIndependent K b ↔ Fintype.card ι = Set.finrank K (Set.range b)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite family of vectors is linearly independent if and only if\\nits cardinality equals the dimension of its span. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of a linearly independent set is linearly independent. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a finite basis, then it is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k { x // x ∈ vectorSpan k s }\",\n  \"isProp\": true,\n  \"docString\": \"The `vectorSpan` of a finite set is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\\n  AffineIndependent k f → Set.Finite s\",\n  \"isProp\": true,\n  \"docString\":\n  \"An affine-independent subset of a finite-dimensional affine space is finite. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a vector space has a basis indexed by elements of a finite set, then it is\\nfinite-dimensional. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every finite subset of an algebraically independent set is algebraically independent. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : ℕ},\\n  (∀ (s : Finset M), (LinearIndependent R fun i => ↑i) → Finset.card s ≤ n) →\\n    ∀ (s : Set M), LinearIndependent R Subtype.val → Cardinal.mk ↑s ≤ ↑n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite set of linearly independent vectors has cardinality at most `n`,\\nthen the same is true for arbitrary sets of linearly independent vectors.\\n\"},\n {\"theorem\":\n  \"∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. \"},\n {\"theorem\":\n  \"∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\\n  [inst_3 : AddTorsor V P] {s : Set P},\\n  Set.Finite s → FiniteDimensional k { x // x ∈ AffineSubspace.direction (affineSpan k s) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"The direction of the affine span of a finite set is\\nfinite-dimensional. \"}]\n",
    "prompt_cons": "/-- A finite family of vectors is linearly independent if and only if\nits cardinality equals the dimension of its span. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  [inst_3 : Fintype ι] {b : ι → V}, LinearIndependent K b ↔ Fintype.card ι = Set.finrank K (Set.range b) :=\n\n/-- Every finite subset of a linearly independent set is linearly independent. -/\ntheorem ∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (s : Set M),\n  LinearIndependent R Subtype.val → ∀ (t : Finset ↑s), LinearIndependent R Subtype.val :=\n\n/-- If a vector space has a finite basis, then it is finite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  [inst_3 : Finite ι], Basis ι K V → FiniteDimensional K V :=\n\n/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem ∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P}, Set.Finite s → FiniteDimensional k { x // x ∈ vectorSpan k s } :=\n\n/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem ∀ (k : Type u_1) {V : Type u_2} {P : Type u_4} {ι : Type u_3} [inst : DivisionRing k] [inst_1 : AddCommGroup V]\n  [inst_2 : Module k V] [inst_3 : AddTorsor V P] [inst_4 : FiniteDimensional k V] {s : Set ι} {f : ↑s → P},\n  AffineIndependent k f → Set.Finite s :=\n\n/-- If a vector space has a basis indexed by elements of a finite set, then it is\nfinite-dimensional. -/\ntheorem ∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Set.Finite s → FiniteDimensional K V :=\n\n/-- Every finite subset of an algebraically independent set is algebraically independent. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (s : Set A),\n  AlgebraicIndependent R Subtype.val → ∀ (t : Finset ↑s), AlgebraicIndependent R Subtype.val :=\n\n/-- If every finite set of linearly independent vectors has cardinality at most `n`,\nthen the same is true for arbitrary sets of linearly independent vectors. -/\ntheorem ∀ {R : Type u_2} {M : Type u_1} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] {n : ℕ},\n  (∀ (s : Finset M), (LinearIndependent R fun i => ↑i) → Finset.card s ≤ n) →\n    ∀ (s : Set M), LinearIndependent R Subtype.val → Cardinal.mk ↑s ≤ ↑n :=\n\n/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ntheorem ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : Field 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : AddCommGroup E]\n  [inst_3 : Module 𝕜 E] [inst_4 : TopologicalSpace E] [inst_5 : AddCommGroup F] [inst_6 : Module 𝕜 F]\n  [inst_7 : TopologicalSpace F] [inst_8 : TopologicalAddGroup F] [inst_9 : ContinuousSMul 𝕜 F]\n  [inst_10 : FiniteDimensional 𝕜 E] [inst_11 : FiniteDimensional 𝕜 F], FiniteDimensional 𝕜 (E →L[𝕜] F) :=\n\n/-- The direction of the affine span of a finite set is\nfinite-dimensional. -/\ntheorem ∀ (k : Type u_2) {V : Type u_3} {P : Type u_1} [inst : DivisionRing k] [inst_1 : AddCommGroup V] [inst_2 : Module k V]\n  [inst_3 : AddTorsor V P] {s : Set P},\n  Set.Finite s → FiniteDimensional k { x // x ∈ AffineSubspace.direction (affineSpan k s) } :=\n\n/-- Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite. -/\ntheorem",
    "choices": [
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {s : Set V}, Set.Countable (Set.BasisOfSpan s) →\n  ∀ (t : Set V), LinearIndependent K Subtype.val → Set.Countable t ∨ Set.Finite t ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  [inst_3 : Countable ι] {b : ι → V}, Set.SurjOn b Set.Univ (Set.range b) →\n  ∀ (s : Set V), LinearIndependent K Subtype.val → Cardinal.mk ↑s ≤ Cardinal.mk (Option ι) ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w}\n  {s : Set ι}, Basis (↑s) K V → Cardinal.mk ↑s ≤ω → ∀ (t : Set ι), LinearIndependent K (fun x => t x) → Cardinal.mk ↑t ≤ω ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  {s : Set ι} {b : ι → V}, (LinearIndependent K b) → Set.Countable (Set.range b) → Set.Finite s ∨ Set.Countable s ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  [inst_3 : Infinite ι], (∃ (b : ι → V), Submodule.span K (Set.range b) = ⊤) →\n    ∀ (s : Set V), LinearIndependent K Subtype.val → Set.countable s ∨ Set.Finite s ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1},\n  (Exists (f : ℕ → ι) → (Cardinal.mk ι < Cardinal.omega)) →\n    ∀ (s : Set V), LinearIndependent K Subtype.val → Cardinal.mk ↑s < Cardinal.omega ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  {b : ι → V}, Set.Countable (Set.Range b) → Submodule.span K (Set.Range b) = ⊤ →\n  ∀ (s : Set V), LinearIndependent K Subtype.val → Set.Countable s ∨ Set.Finite s ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  [inst_3 : Infinite ι] {b : ι → V}, LinearIndependent K b → ∀ (s : Set V), LinearIndependent K Subtype.val → Set.Countable s ",
      "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type w} {s : Set ι}\n  {b : ι → V}, (Exists (Function.Surjective b) ∧ Submodule.span K (Set.Range b) = ⊤) →\n  LinearIndependent K s → Cardinal.mk ↑s ≤ ω ",
      "forall {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : Module K V] {ι : Type u_1}\n  [inst_3 : Fintype ι] {b : ι → V}, (Set.range b).Span = ⊤ →\n    ∀ (s : Set V), LinearIndependent K Subtype.val → Set.Countable s ∨ Set.Finite s "
    ]
  },
  {
    "docString": "Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G ⧸ Subgroup.center G) → Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"If the quotient by `center G` is nilpotent, then so is G. \"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is cyclic. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G ⧸ Subgroup.center G) → Group.IsNilpotent G :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G) :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is cyclic. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)], Fintype.card α = p → IsCyclic α :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsCyclic (G ⧸ Subgroup.center G) → G ≃+ Subgroup.center G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (h : IsCyclic (G ⧸ Subgroup.center G)), G = Subgroup.center G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  IsCyclic (G ⧸ Subgroup.center G) → MulAction.fixedPoints (ConjAct G) G = ↑(Set.univ : Set G) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsCyclic (G ⧸ Subgroup.center G) → AddCommGroup G ",
      "∀ {G : Type u_1} [inst : Group G], IsCyclic (G ⧸ Subgroup.center G) → ∀ x y : G, x * y = y * x ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsCyclic (G ⧸ Subgroup.center G) → IsAddCommGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsCyclic (G ⧸ Subgroup.center G) → G = Subgroup.center G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsCyclic (G ⧸ Subgroup.center G) → IsAddCommGroup (Additive G) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], IsCyclic (G ⧸ Subgroup.center G) → Subgroup.center G = G ",
      "∀ {G : Type u_1} [inst : Group G] [hG : IsCyclic (G ⧸ Subgroup.center G)], IsAbelian G "
    ]
  },
  {
    "docString": "Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\":\n  \"The `p`- and `q`-primary components are disjoint for `p ≠ q`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient by the center of a group of cardinality `p ^ 2` is cyclic. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\\na square mod `p` iff `p` is a nonsquare mod `q`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddCommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\\n  p ≠ p' → Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p')\",\n  \"isProp\": true,\n  \"docString\": \"The `p`- and `q`-primary components are disjoint for `p ≠ q`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\n  p ≠ p' → Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n\n/-- The quotient by the center of a group of cardinality `p ^ 2` is cyclic. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [inst_2 : Fact (Nat.Prime p)],\n  Fintype.card G = p ^ 2 → IsCyclic (G ⧸ Subgroup.center G) :=\n\n/-- If `p` and `q` are distinct primes that are both congruent to `3` mod `4`, then `q` is\na square mod `p` iff `p` is a nonsquare mod `q`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p % 4 = 3 → q % 4 = 3 → p ≠ q → (IsSquare ↑q ↔ ¬IsSquare ↑p) :=\n\n/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\ntheorem ∀ {G : Type u_1} [inst : AddCommMonoid G] {p : ℕ} [hp : Fact (Nat.Prime p)] {p' : ℕ} [hp' : Fact (Nat.Prime p')],\n  p ≠ p' → Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p') :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_2} [inst : Group G] [inst_1 : Fintype G] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)],\n  Fintype.card G = p ^ 2 * q → ¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.denominators g n = ppredB →\\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.continuants g n = ppred →\\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\\n        GeneralizedContinuedFraction.continuants g (n + 2) =\\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\\n  Stream'.Seq.get? g.s (n + 1) = some gp →\\n    GeneralizedContinuedFraction.numerators g n = ppredA →\\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` commutes with both `b` and `c`, then it commutes with their product. \"}]\n",
    "prompt_cons": "/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- For every pair of elements `a` and `b` there is a `c` such that `r a c` and `r b c` -/\ntheorem ∀ {α : Type u_1} {r : α → α → Prop} [self : IsDirected α r] (a b : α), ∃ c, r a c ∧ r b c :=\n\n/-- Shows that `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredB predB : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.denominators g n = ppredB →\n      GeneralizedContinuedFraction.denominators g (n + 1) = predB →\n        GeneralizedContinuedFraction.denominators g (n + 2) = gp.b * predB + gp.a * ppredB :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂` and `Bₙ = bₙ * Bₙ₋₁ + aₙ * Bₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp ppred pred : GeneralizedContinuedFraction.Pair K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.continuants g n = ppred →\n      GeneralizedContinuedFraction.continuants g (n + 1) = pred →\n        GeneralizedContinuedFraction.continuants g (n + 2) =\n          { a := gp.b * pred.a + gp.a * ppred.a, b := gp.b * pred.b + gp.a * ppred.b } :=\n\n/-- Shows that `Aₙ = bₙ * Aₙ₋₁ + aₙ * Aₙ₋₂`. -/\ntheorem ∀ {K : Type u_1} {g : GeneralizedContinuedFraction K} {n : ℕ} [inst : DivisionRing K]\n  {gp : GeneralizedContinuedFraction.Pair K} {ppredA predA : K},\n  Stream'.Seq.get? g.s (n + 1) = some gp →\n    GeneralizedContinuedFraction.numerators g n = ppredA →\n      GeneralizedContinuedFraction.numerators g (n + 1) = predA →\n        GeneralizedContinuedFraction.numerators g (n + 2) = gp.b * predA + gp.a * ppredA :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- If `a` commutes with both `b` and `c`, then it commutes with their product. -/\ntheorem ∀ {S : Type u_1} [inst : Semigroup S] {a b c : S}, Commute a b → Commute a c → Commute a (b * c) :=\n\n/-- Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.normalClosure {{ val ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b⁻², b * a * b⁻³} ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.normalClosure {{ val ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.normalClosure ({a, b}) = Subgroup.normalClosure ({b * a * (b^2), b * a * (b^3)}) ",
      "∀ {G : Type u_1} [inst : Group G] {a b : G},\n  Subgroup.normalClosure {{ val ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.closure {{a, b}} = Subgroup.closure {{b * a * b^2, b * a * b^3}} ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.closure ({a, b} : Set G) = Subgroup.closure ({b * a * b ^ 2, b * a * b ^ 3} : Set G) ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.normalClosure {{ val ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.closure {a, b} = Subgroup.closure {b * a * b^2, b * a * b^3} ",
      "∀ {G : Type u_1} [inst : Group G] (a b : G),\n  Subgroup.normalClosure {{ val "
    ]
  },
  {
    "docString": "Prove that in the ring $\\mathbb{Z}[x],(2) \\cap(x)=(2 x)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A ≃+* B → NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α → β},\\n  IsRingHom f → ∀ {γ : Type u_1} [inst_2 : Ring γ] {g : β → γ}, IsRingHom g → IsRingHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two ring homomorphisms is a ring homomorphism. \"},\n {\"theorem\":\n  \"∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {r : Setoid α} {x : α} {b : Set α},\\n  b ∈ Setoid.classes r → x ∈ b → ∀ {b' : Set α}, b' ∈ Setoid.classes r → x ∈ b' → b = b'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If x ∈ α is in 2 equivalence classes, the equivalence classes are equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two ring homomorphisms are equal on a set, then they are equal on its subring closure. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\\n  Ideal.comap (algebraMap R S) (conductor R x) ⊔ I = ⊤ →\\n    Function.Injective ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) →\\n      Ideal.comap (algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\\n        Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {χ : MulChar R ℤ},\\n  MulChar.IsQuadratic χ →\\n    ∀ {χ' : MulChar R' ℤ},\\n      MulChar.IsQuadratic χ' →\\n        ∀ [inst_3 : Nontrivial R''], ringChar R'' ≠ 2 → ∀ {a : R} {a' : R'}, ↑(↑χ a) = ↑(↑χ' a') → ↑χ a = ↑χ' a'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two values of quadratic characters with target `ℤ` agree after coercion into a ring\\nof characteristic not `2`, then they agree in `ℤ`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"}]\n",
    "prompt_cons": "/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem ∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A ≃+* B → NoZeroDivisors A :=\n\n/-- The composition of two ring homomorphisms is a ring homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α → β},\n  IsRingHom f → ∀ {γ : Type u_1} [inst_2 : Ring γ] {g : β → γ}, IsRingHom g → IsRingHom (g ∘ f) :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subfield closure. -/\ntheorem ∀ {K : Type u} {L : Type v} [inst : Field K] [inst_1 : Field L] {f g : K →+* L} {s : Set K},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subfield.closure s) :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y :=\n\n/-- If x ∈ α is in 2 equivalence classes, the equivalence classes are equal. -/\ntheorem ∀ {α : Type u_1} {r : Setoid α} {x : α} {b : Set α},\n  b ∈ Setoid.classes r → x ∈ b → ∀ {b' : Set α}, b' ∈ Setoid.classes r → x ∈ b' → b = b' :=\n\n/-- If two ring homomorphisms are equal on a set, then they are equal on its subring closure. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : Ring R] [inst_1 : Ring S] {f g : R →+* S} {s : Set R},\n  Set.EqOn (↑f) (↑g) s → Set.EqOn ↑f ↑g ↑(Subring.closure s) :=\n\n/-- A technical result telling us that `(I * S) ∩ R<x> = I * R<x>` for any ideal `I` of `R`. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] {x : S} {I : Ideal R},\n  Ideal.comap (algebraMap R S) (conductor R x) ⊔ I = ⊤ →\n    Function.Injective ↑(algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) →\n      Ideal.comap (algebraMap { x_1 // x_1 ∈ Algebra.adjoin R {x} } S) (Ideal.map (algebraMap R S) I) =\n        Ideal.map (algebraMap R { x_1 // x_1 ∈ Algebra.adjoin R {x} }) I :=\n\n/-- If two values of quadratic characters with target `ℤ` agree after coercion into a ring\nof characteristic not `2`, then they agree in `ℤ`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {χ : MulChar R ℤ},\n  MulChar.IsQuadratic χ →\n    ∀ {χ' : MulChar R' ℤ},\n      MulChar.IsQuadratic χ' →\n        ∀ [inst_3 : Nontrivial R''], ringChar R'' ≠ 2 → ∀ {a : R} {a' : R'}, ↑(↑χ a) = ↑(↑χ' a') → ↑χ a = ↑χ' a' :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- Prove that in the ring $\\mathbb{Z}[x],(2) \\cap(x)=(2 x)$. -/\ntheorem",
    "choices": [
      "Ideal.span ({2}: Set ℤ[X]) ∩ Ideal.span ({X}: Set ℤ[X]) = Ideal.span ({2 * X}: Set ℤ[X]) ",
      "Ideal.mk (Ideal.span {2}) ∩ Ideal.mk (Ideal.span {x}) = Ideal.mk (Ideal.span {2 * x}) ",
      "ideal.inter_two_x : ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R],\n  ideal.span {2} ⊓ ideal.span {ringChar.poly R} = ideal.span {2 * ringChar.poly R} ",
      "Ideal.inter (Ideal.span {2}) (Ideal.span {int_X}) = Ideal.span {2 * int_X} ",
      "Ideal.inter (Ideal.span {2}) (Ideal.span {x}) = Ideal.span {2 * x} ",
      "Ideal.inter (Ideal.span {2}) (Ideal.span {Polynomial.x}) = Ideal.span {2 * Polynomial.x} ",
      "Ideal.prod (Ideal.span {2}) (Ideal.span {Polynomial.x}) =\n  Ideal.span {2 * Polynomial.x} ",
      "Ideal.intersection (Ideal.span {2}) (Ideal.span {x}) = Ideal.span {2 * x} ",
      "∀ [_inst_4 : CommRing (ℤ[x])] (x : ℤ), Ideal.comap (polynomial.aeval x) (Ideal.span {2}) ⊓ Ideal.comap (polynomial.aeval x) (Ideal.span {polynomial.X}) =\n  Ideal.comap (polynomial.aeval x) (Ideal.span {2 * polynomial.X}) ",
      "Ideal.inter.{0} (Ideal.span ({(2:ℤ)} : Set ℤ[X])) (Ideal.span ({X} : Set ℤ[X])) =\n  Ideal.span ({(2:ℤ) * X} : Set ℤ[X]) "
    ]
  },
  {
    "docString": "Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\\n  IsNilpotent I →\\n    ∀ {P : ⦃S : Type u_1⦄ → [inst : CommRing S] → Ideal S → Prop},\\n      (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I : Ideal S), I ^ 2 = ⊥ → P I) →\\n        (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I J : Ideal S),\\n            I ≤ J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J) →\\n          P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\\n`P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"An ideal `I` of `R` is equal to its Jacobson radical if and only if\\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (∀ (P : Ideal R) (x : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\\n    I = J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\\nthe localization of `J` at `P`, then `I = J`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  ↑Polynomial.C x ∈\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I : Ideal R},\\n  Ideal.radical I = Ideal.jacobson I ↔ Ideal.radical ⊥ = Ideal.jacobson ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\\n  (∀ (P : Ideal R) (hP : Ideal.IsMaximal P),\\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I ≤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\\n    I ≤ J\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\\nthe localization of `J` at `P`, then `I ≤ J`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G ⧸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\\n  Function.Injective\\n    ↑(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n        (_ :\\n          P ≤\\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)))\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be an ideal in `R[x]`.  The map\\n`R[x]/P → (R / (P ∩ R))[x] / (P / (P ∩ R))`\\nis injective.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\\nthen `R → R[X]/P` is an integral map. \"}]\n",
    "prompt_cons": "/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I →\n    ∀ {P : ⦃S : Type u_1⦄ → [inst : CommRing S] → Ideal S → Prop},\n      (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I : Ideal S), I ^ 2 = ⊥ → P I) →\n        (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I J : Ideal S),\n            I ≤ J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J) →\n          P I :=\n\n/-- An ideal `I` of `R` is equal to its Jacobson radical if and only if\nthe Jacobson radical of the quotient ring `R/I` is the zero ideal -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I : Ideal R}, Ideal.jacobson I = I ↔ Ideal.jacobson ⊥ = ⊥ :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (∀ (P : Ideal R) (x : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I = Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\n    I = J :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  ↑Polynomial.C x ∈\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\n    x = 0 :=\n\n/-- The standard radical and Jacobson radical of an ideal `I` of `R` are equal if and only if\nthe nilradical and Jacobson radical of the quotient ring `R/I` coincide -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I : Ideal R},\n  Ideal.radical I = Ideal.jacobson I ↔ Ideal.radical ⊥ = Ideal.jacobson ⊥ :=\n\n/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I ≤ J`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},\n  (∀ (P : Ideal R) (hP : Ideal.IsMaximal P),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I ≤ Ideal.map (algebraMap R (Localization.AtPrime P)) J) →\n    I ≤ J :=\n\n/-- A quotient of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G ⧸ H) :=\n\n/-- Let `P` be an ideal in `R[x]`.  The map\n`R[x]/P → (R / (P ∩ R))[x] / (P / (P ∩ R))`\nis injective. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (P : Ideal (Polynomial R)),\n  Function.Injective\n    ↑(Ideal.quotientMap (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P)\n        (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n        (_ :\n          P ≤\n            Ideal.comap (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P)))\n              (Ideal.map (Polynomial.mapRingHom (Ideal.Quotient.mk (Ideal.comap Polynomial.C P))) P))) :=\n\n/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P) :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\nthen `R → R[X]/P` is an integral map. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C) :=\n\n/-- Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x ∈ I ∩ J → IsNilpotent (coeFn (Ideal.Quotient.mk (I * J)) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x ∈ I ∧ x ∈ J →\n    IsNilpotent (Submodule.Quotient.mk (x * 1)) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x ∈ I ∩ J →\n    IsNilpotent (coeFn (Ideal.Quotient.mk (I * J)) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x ∈ I ∧ x ∈ J →\n    IsNilpotent (Ideal.Quotient.mk (I * J) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R) (h : x ∈ I ⊓ J),\n  IsNilpotent (coeFn (Ideal.Quotient.mk (I * J)) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R) (hx : x ∈ I ⊓ J),\n  IsNilpotent (Ideal.Quotient.mk (I * J) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x ∈ I ∩ J → IsNilpotent (Ideal.Quotient.mk (I * J) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x ∈ HasInter.inter (coe I) (coe J) → IsNilpotent (coeFn (Ideal.Quotient.mk (I * J)) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R) (hx : x ∈ I ⊓ J),\n  IsNilpotent (Ideal.Quotient.mk (I * J) x) ",
      "∀ {R : Type u} [inst : CommRing R] {I J : Ideal R} (x : R),\n  x ∈ I ∩ J →\n    ∀ (n : ℕ),\n      (Ideal.Quotient.mk (I * J) x) ^ n = 0 →\n        (Ideal.Quotient.mk (I * J) x) ^ (n + 1) = 0 "
    ]
  },
  {
    "docString": "Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.",
    "prompts": "[{\"theorem\":\n  \"∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M\",\n  \"isProp\": true,\n  \"docString\": \"Krull's theorem: a nontrivial ring has a maximal ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Only finitely many maximal ideals of `R` divide a given nonzero ideal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R],\\n  Ideal.IsJacobson R ↔\\n    ∀ {I : Ideal R}, Ideal.IsPrime I → ∃ M, (∀ (J : Ideal R), J ∈ M → Ideal.IsMaximal J ∨ J = ⊤) ∧ I = sInf M\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` is Jacobson if and only if for every prime ideal `I`,\\n`I` can be written as the infimum of some collection of maximal ideals.\\nAllowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsMaximal I], IsCoatom I\",\n  \"isProp\": true,\n  \"docString\":\n  \"The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\\nand there are no other proper ideals strictly containing it. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\\nthen `R → R[X]/P` is an integral map. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\\n  ↑Polynomial.C x ∈\\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\\n    x = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\\nThis theorem shows `I'` will not contain any non-zero constant polynomials. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I\",\n  \"isProp\": true,\n  \"docString\": \"Maximal ideals in complete normed rings are closed. \"}]\n",
    "prompt_cons": "/-- Krull's theorem: a nontrivial ring has a maximal ideal. -/\ntheorem ∀ (α : Type u) [inst : Semiring α] [inst_1 : Nontrivial α], ∃ M, Ideal.IsMaximal M :=\n\n/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- Only finitely many maximal ideals of `R` divide a given nonzero ideal. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R] {I : Ideal R},\n  I ≠ 0 → Set.Finite {v | v.asIdeal ∣ I} :=\n\n/-- A ring `R` is Jacobson if and only if for every prime ideal `I`,\n`I` can be written as the infimum of some collection of maximal ideals.\nAllowing ⊤ in the set `M` of maximal ideals is equivalent, but makes some proofs cleaner. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R],\n  Ideal.IsJacobson R ↔\n    ∀ {I : Ideal R}, Ideal.IsPrime I → ∃ M, (∀ (J : Ideal R), J ∈ M → Ideal.IsMaximal J ∨ J = ⊤) ∧ I = sInf M :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ :=\n\n/-- The maximal ideal is a coatom in the ordering on ideals; that is, it is not the entire ring,\nand there are no other proper ideals strictly containing it. -/\ntheorem ∀ {α : Type u} [inst : Semiring α] {I : Ideal α} [self : Ideal.IsMaximal I], IsCoatom I :=\n\n/-- If `R` is a Jacobson ring, and `P` is a maximal ideal of `R[X]`,\nthen `R → R[X]/P` is an integral map. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : Ideal.IsJacobson R] (P : Ideal (Polynomial R)) [hP : Ideal.IsMaximal P],\n  RingHom.IsIntegral (RingHom.comp (Ideal.Quotient.mk P) Polynomial.C) :=\n\n/-- Given any ring `R` and an ideal `I` of `R[X]`, we get a map `R → R[x] → R[x]/I`.\nIf we let `R` be the image of `R` in `R[x]/I` then we also have a map `R[x] → R'[x]`.\nIn particular we can map `I` across this map, to get `I'` and a new map `R' → R'[x] → R'[x]/I`.\nThis theorem shows `I'` will not contain any non-zero constant polynomials. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] (I : Ideal (Polynomial R))\n  (x : { x // x ∈ RingHom.range (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C) }),\n  ↑Polynomial.C x ∈\n      Ideal.map (Polynomial.mapRingHom (RingHom.rangeRestrict (RingHom.comp (Ideal.Quotient.mk I) Polynomial.C))) I →\n    x = 0 :=\n\n/-- Maximal ideals in complete normed rings are closed. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] [inst_1 : CompleteSpace R] {I : Ideal R} [hI : Ideal.IsMaximal I], IsClosed ↑I :=\n\n/-- Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : Nontrivial R] {M : Ideal R},\n  (∀ x : R, x ∉ M → IsUnit x) → (∀ J : Ideal R, M < J → J = ⊤) ∧ ∀ I : Ideal R, Ideal.IsMaximal I → I = M ",
      "∀ {R : Type u} [inst : CommRing R] (M : Ideal R), (∀ x : R, x ∉ M → IsUnit x) → Ideal.IsMaximal M ∧ ∀ (M' : Ideal R), Ideal.IsMaximal M' → M' = M ",
      "∀ {R : Type u} [inst : CommRing R] (M : Ideal R), (∀ x, x ∉ M → IsUnit x) → Ideal.IsMaximal M ∧ ∀ M', Ideal.IsMaximal M' → M' = M ",
      "∀ {R : Type u} [inst : CommRing R] {M : Ideal R},\n  (∀ x, x ∉ M → IsUnit x) → Ideal.IsMaximal M ∧ ∀ M', Ideal.IsMaximal M' → M' = M ",
      "∀ {R : Type u} [inst : CommRing R] (M : Ideal R), (∀ (x : R), x ∉ M → IsUnit x) → Ideal.IsMaximal M ∧ ∀ (x : Ideal R), Ideal.IsMaximal x → x = M ",
      "∀ (R : Type u) [inst : CommRing R] (M : Ideal R),\n  (∀ x, x ∉ M → IsUnit x) → (∀ J : Ideal R, M < J → J = ⊤) ∧ ∀ N : Ideal R, Ideal.IsMaximal N → N = M ",
      "∀ {R : Type u} [inst : CommRing R] (M : Ideal R), (∀ (x : R), x ∉ M → IsUnit x) → Ideal.IsMaximal M ∧ ∀ (N : Ideal R), Ideal.IsMaximal N → N = M ",
      "∀ {R : Type u} [inst : CommRing R] (M : Ideal R), (∀ x : R, x ∈ M ∨ IsUnit x) → Ideal.IsMaximal M ∧ ∀ (M' : Ideal R), Ideal.IsMaximal M' → M' = M ",
      "∀ {R : Type u_1} [inst : CommRing R] (M : Ideal R) (H : ∀ (x : R), x ∉ M → IsUnit x),\n  Ideal.IsMaximal M ∧ ∀ (m : Ideal R), Ideal.IsMaximal m → m = M ",
      "∀ {R : Type u} [inst : CommRing R] (M : Ideal R), (∀ x ∈ R, x ∉ M → IsUnit x) → Ideal.IsMaximal M ∧ ∀ (I : Ideal R), Ideal.IsMaximal I → I = M "
    ]
  },
  {
    "docString": "Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C\",\n  \"isProp\": true,\n  \"docString\": \"Transitivity of cyclotomic extensions. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Transitivity of cyclotomic extensions. -/\ntheorem ∀ (S T : Set ℕ+) (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] (C : Type w)\n  [inst_3 : CommRing C] [inst_4 : Algebra A C] [inst_5 : Algebra B C] [inst_6 : IsScalarTower A B C]\n  [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C],\n  Function.Injective ↑(algebraMap B C) → IsCyclotomicExtension (S ∪ T) A C :=\n\n/-- Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$. -/\ntheorem",
    "choices": [
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "irreducible_x_pow_3_plus_6x_plus_12 : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "irreducible_in_Q_x_pow_three_plus_6x_plus_12 : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6_x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) ",
      "x_pow_3_plus_6x_plus_12_irreducible : Irreducible (Polynomial.map (Int.castRingHom ℚ) (Polynomial.x ^ 3 + 6 * Polynomial.x + 12)) "
    ]
  },
  {
    "docString": "Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\\nirreducible in the fraction field. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\\niff it is irreducible in the fraction field. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\nirreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : NormalizedGCDMonoid R] {p : Polynomial R},\n  Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\niff it is irreducible in the fraction field. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] [inst_4 : IsDomain R] [inst_5 : IsIntegrallyClosed R] {p : Polynomial R},\n  Polynomial.Monic p → (Irreducible p ↔ Irreducible (Polynomial.map (algebraMap R K) p)) :=\n\n/-- Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$ -/\ntheorem",
    "choices": [
      "irreducible_x_pow_two_add_one_f7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "irreducible_X_pow_add_one {p : ℕ} [fact (nat.prime p)] [char_p (zmod p) p] [ge p 3] : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (zmod p)) ",
      "Polynomial.x_pow_2_add_one_irreducible_in_F7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "irreducible_in_f7_x2_plus_1 : Irreducible (Polynomial.map (Int.castRingHom (Zmod 7)) (Polynomial.x ^ 2 + 1)) ",
      "irreducible_X_pow_add_one_pow_two (p : ℕ) [Fact p.prime] (hp : p ≠ 2) : Irreducible (X ^ 2 + 1 : Polynomial (Zmod p)) ",
      "irreducible_x_sq_add_one_in_F7 : Irreducible (@Polynomial.map (Zmod 7) (Zmod 7) _ _ (@Int.castRingHom (Zmod 7)) (x ^ 2 + 1 : Polynomial ℤ)) ",
      "ℤ_irreducible_x_squared_plus_one : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial ℤ) ",
      "Irreducible_x_pow_2_add_1_F7 : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (GfP 7)) ",
      "x_pow_two_add_one_irreducible : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) ",
      "irreducible_x_squared_plus_one : Irreducible (Polynomial.x ^ 2 + 1 : Polynomial (Zmod 7)) "
    ]
  },
  {
    "docString": "Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ},\\n  Nat.Prime p →\\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : UniqueFactorizationMonoid α]\\n  [inst_2 : NormalizationMonoid α] [inst_3 : DecidableEq α] {x : α} {n : ℕ}, factorization (x ^ n) = n • factorization x\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `x^n` is `n` times the power in `x` \"},\n {\"theorem\":\n  \"∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\\nis irrational. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\": \"∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1\",\n  \"isProp\": true,\n  \"docString\": \"The multiplicity of prime `p` in `p` is `1` \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\\n  IsPrimitiveRoot μ n →\\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is a prime that does not divide `n`,\\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\\nand of `μ ^ p` are the same. \"}]\n",
    "prompt_cons": "/-- If the `p ^ n`th cyclotomic polynomial is irreducible, so is the `p ^ m`th, for `m ≤ n`. -/\ntheorem ∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n m : ℕ},\n      m ≤ n → Irreducible (Polynomial.cyclotomic (p ^ n) R) → Irreducible (Polynomial.cyclotomic (p ^ m) R) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- If `p` and `q` are irreducible, then `p ∣ q` implies `q ∣ p`. -/\ntheorem ∀ {α : Type u_1} [inst : Monoid α] {p q : α}, Irreducible p → Irreducible q → p ∣ q → q ∣ p :=\n\n/-- For any `p`, the power of `p` in `x^n` is `n` times the power in `x` -/\ntheorem ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : UniqueFactorizationMonoid α]\n  [inst_2 : NormalizationMonoid α] [inst_3 : DecidableEq α] {x : α} {n : ℕ}, factorization (x ^ n) = n • factorization x :=\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem ∀ {x : ℝ} (n : ℕ) {m : ℤ} (hm : m ≠ 0) (p : ℕ) [hp : Fact (Nat.Prime p)],\n  x ^ n = ↑m → Part.get (multiplicity (↑p) m) (_ : multiplicity.Finite (↑p) m) % n ≠ 0 → Irrational x :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- The multiplicity of prime `p` in `p` is `1` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ↑(Nat.factorization p) p = 1 :=\n\n/-- If `p` is a prime that does not divide `n`,\nthen the minimal polynomials of a primitive `n`-th root of unity `μ`\nand of `μ ^ p` are the same. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : CommRing K] {μ : K},\n  IsPrimitiveRoot μ n →\n    ∀ [inst_1 : IsDomain K] [inst_2 : CharZero K] {p : ℕ} [hprime : Fact (Nat.Prime p)],\n      ¬p ∣ n → minpoly ℤ μ = minpoly ℤ (μ ^ p) :=\n\n/-- Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, Irreducible (Polynomial.x ^ n - Polynomial.C (↑p) : Polynomial ℚ) ",
      "∀ {p : ℕ} [hp : Fact (Nat.Prime p)] {n : ℕ} (hn : 0 < n),\n  Irreducible (Polynomial.x ^ n - coeFn Polynomial.c (Int.of_nat p) : Polynomial ℚ) ",
      "∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Irreducible (Polynomial.x ^ n - Polynomial.C (↑p : ℚ)) ",
      "∀ {p : ℕ},\n  Nat.Prime p →\n    ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\n      Irreducible (Polynomial.x ^ n - (Polynomial.C (coe p))) ",
      "∀ {p n : ℕ},\n  Nat.Prime p →\n    Irreducible (Polynomial.map (algebraMap ℤ ℚ) (Polynomial.x ^ n - coeFn Polynomial.c (↑p : ℤ))) ",
      "∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.x ^ n - coeFn Polynomial.c (↑p : ℚ)) ",
      "∀ {p : ℕ}, Nat.Prime p → ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\n  Irreducible (Polynomial.x ^ n - coeFn Polynomial.c (↑p : R)) ",
      "∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.x ^ n - Polynomial.C (coe p) : Polynomial ℚ) ",
      "∀ {p : ℕ} [Fact (Nat.Prime p)] {n : ℕ} [hn : 0 < n], Irreducible (Polynomial.x ^ n - coeFn Polynomial.c (↑p) : Polynomial ℚ) ",
      "∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.x ^ n - Polynomial.C (↑p)) "
    ]
  },
  {
    "docString": "Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p k : ℕ}, Nat.Prime p → Nat.factorization (p ^ k) = Finsupp.single p k\",\n  \"isProp\": true,\n  \"docString\":\n  \"For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` \"},\n {\"theorem\":\n  \"∀ {p k : ℕ}, k ≠ 0 → Nat.Prime p → List.toFinset (Nat.factors (p ^ k)) = {p}\",\n  \"isProp\": true,\n  \"docString\":\n  \"The only prime divisor of positive prime power `p^k` is `p` itself \"},\n {\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {x y : ℤ} {n : ℕ},\\n  2 ∣ x - y →\\n    ¬2 ∣ x →\\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` \"},\n {\"theorem\": \"∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any `p`, the power of `p` in `n^k` is `k` times the power in `n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. \"},\n {\"theorem\":\n  \"∀ {a p k : ℕ}, Nat.Prime p → ¬a ∣ p ^ k → a ∣ p ^ (k + 1) → a = p ^ (k + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime,\\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\\nthen `a = p^(k+1)`.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {p n : ℕ},\\n  Nat.Prime p → Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p ^ k` is a prime power, then\\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. \"}]\n",
    "prompt_cons": "/-- For prime `p` the only prime factor of `p^k` is `p` with multiplicity `k` -/\ntheorem ∀ {p k : ℕ}, Nat.Prime p → Nat.factorization (p ^ k) = Finsupp.single p k :=\n\n/-- The only prime divisor of positive prime power `p^k` is `p` itself -/\ntheorem ∀ {p k : ℕ}, k ≠ 0 → Nat.Prime p → List.toFinset (Nat.factors (p ^ k)) = {p} :=\n\n/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem ∀ {x y : ℤ} {n : ℕ},\n  2 ∣ x - y →\n    ¬2 ∣ x →\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n :=\n\n/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ (n : ℕ), Nat.totient (p ^ (n + 1)) = p ^ n * (p - 1) :=\n\n/-- For any `p`, the power of `p` in `n^k` is `k` times the power in `n` -/\ntheorem ∀ (n k : ℕ), Nat.factorization (n ^ k) = k • Nat.factorization n :=\n\n/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem ∀ {p : ℕ}, Nat.Prime p → ∀ {n : ℕ}, 0 < n → Nat.totient (p ^ n) = p ^ (n - 1) * (p - 1) :=\n\n/-- For any natural `k` and a real `r > 1` we have `n ^ k = o(r ^ n)` as `n → ∞`. -/\ntheorem ∀ {R : Type u_1} [inst : NormedRing R] (k : ℕ) {r : ℝ}, 1 < r → (fun n => ↑n ^ k) =o[Filter.atTop] fun n => r ^ n :=\n\n/-- If `p` is prime,\nand `a` doesn't divide `p^k`, but `a` does divide `p^(k+1)`\nthen `a = p^(k+1)`. -/\ntheorem ∀ {a p k : ℕ}, Nat.Prime p → ¬a ∣ p ^ k → a ∣ p ^ (k + 1) → a = p ^ (k + 1) :=\n\n/-- If `p ^ k` is a prime power, then\n`cyclotomic (p ^ (n + 1)) R = ∑ i in range p, (X ^ (p ^ n)) ^ i`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {p n : ℕ},\n  Nat.Prime p → Polynomial.cyclotomic (p ^ (n + 1)) R = Finset.sum (Finset.range p) fun i => (Polynomial.X ^ p ^ n) ^ i :=\n\n/-- Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2^2^k + 1 ↔ ∃ k : ℕ, p = 2^(2^k) + 1 ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p = 2 ^ (2 ^ (Nat.log 2 p - 1)) + 1 ↔ p = 2 ^ (Nat.log 2 p) + 1 ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2 ^ r + 1 → ∃ (k : ℕ), r = 2 ^ k ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2^r + 1 → ∃ k : ℕ, r = 2^k ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2 ^ r + 1 → ∃ k : ℕ, r = 2 ^ k ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2 ^ r + 1 → ∃ k : ℕ, r = 2 ^ k ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2 ^ r + 1 → ∃ k : ℕ, r = 2 ^ k ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2 ^ r + 1 → ∃ (k : ℕ), r = 2 ^ k ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2 ^ r + 1 → ∃ k : ℕ, r = 2 ^ k ",
      "∀ {p r : ℕ}, Nat.Prime p → p = 2 ^ r + 1 → ∃ k : ℕ, r = 2 ^ k "
    ]
  },
  {
    "docString": "Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative.",
    "prompts": "[{\"theorem\":\n  \"∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w + y) (x + z)\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations preserve addition.\"},\n {\"theorem\":\n  \"∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f)\",\n  \"isProp\": true,\n  \"docString\": \"Composition of additive monoid homomorphisms is associative.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Add M] {c : AddCon M} (x y : M), ↑(x + y) = ↑x + ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of an additive congruence relation\\ncommutes with addition (by definition).\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\\n  ↑f (a + b) = ↑f a + ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve addition. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Add M] (self : AddCon M) {w x y z : M}, Setoid.r w x → Setoid.r y z → Setoid.r (w + y) (x + z)\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations are closed under addition \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves addition. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x : α), ↑f (-x) = -↑f x\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve additive inverse. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coercion to the quotient of a congruence relation commutes with multiplication (by\\ndefinition). \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y z : M}, ↑c x y → ↑c y z → ↑c x z\",\n  \"isProp\": true,\n  \"docString\": \"Additive congruence relations are transitive.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Add M] {c : AddCon M} {C : AddCon.Quotient c → Prop} (q : AddCon.Quotient c),\\n  (∀ (x : M), C ↑x) → C q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inductive principle used to prove propositions about\\nthe elements of a quotient by an additive congruence relation.\"}]\n",
    "prompt_cons": "/-- Additive congruence relations preserve addition. -/\ntheorem ∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {w x y z : M}, ↑c w x → ↑c y z → ↑c (w + y) (x + z) :=\n\n/-- Composition of additive monoid homomorphisms is associative. -/\ntheorem ∀ {M : Type u_2} {N : Type u_3} {P : Type u_4} {Q : Type u_1} [inst : Zero M] [inst_1 : Zero N] [inst_2 : Zero P]\n  [inst_3 : Zero Q] (f : ZeroHom M N) (g : ZeroHom N P) (h : ZeroHom P Q),\n  ZeroHom.comp (ZeroHom.comp h g) f = ZeroHom.comp h (ZeroHom.comp g f) :=\n\n/-- The coercion to the quotient of an additive congruence relation\ncommutes with addition (by definition). -/\ntheorem ∀ {M : Type u_1} [inst : Add M] {c : AddCon M} (x y : M), ↑(x + y) = ↑x + ↑y :=\n\n/-- Ring homomorphisms preserve addition. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\n  ↑f (a + b) = ↑f a + ↑f b :=\n\n/-- Additive congruence relations are closed under addition -/\ntheorem ∀ {M : Type u_1} [inst : Add M] (self : AddCon M) {w x y z : M}, Setoid.r w x → Setoid.r y z → Setoid.r (w + y) (x + z) :=\n\n/-- A ring isomorphism preserves addition. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x + y) = ↑e x + ↑e y :=\n\n/-- Ring homomorphisms preserve additive inverse. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : NonAssocRing α] [inst_1 : NonAssocRing β] (f : α →+* β) (x : α), ↑f (-x) = -↑f x :=\n\n/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\ndefinition). -/\ntheorem ∀ {M : Type u_1} [inst : Mul M] {c : Con M} (x y : M), ↑(x * y) = ↑x * ↑y :=\n\n/-- Additive congruence relations are transitive. -/\ntheorem ∀ {M : Type u_1} [inst : Add M] (c : AddCon M) {x y z : M}, ↑c x y → ↑c y z → ↑c x z :=\n\n/-- The inductive principle used to prove propositions about\nthe elements of a quotient by an additive congruence relation. -/\ntheorem ∀ {M : Type u_1} [inst : Add M] {c : AddCon M} {C : AddCon.Quotient c → Prop} (q : AddCon.Quotient c),\n  (∀ (x : M), C ↑x) → C q :=\n\n/-- Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "∀ {n : ℕ} [inst : Add (Zmod n)] (a b c : Zmod n), a + (b + c) = (a + b) + c ",
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "forall {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) ",
      "∀ {n : ℕ} (a b c : Zmod n), (a + b) + c = a + (b + c) "
    ]
  },
  {
    "docString": "Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The proposition that `n` is not zero. \"},\n {\"theorem\":\n  \"∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ\",\n  \"isProp\": true,\n  \"docString\":\n  \"The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. \"},\n {\"theorem\": \"∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\": \"∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\\n  Group.nilpotencyClass G = Group.nilpotencyClass (G ⧸ Subgroup.center G) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The nilpotency class of a non-trivial group is one more than its quotient by the center \"},\n {\"theorem\": \"∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. \"}]\n",
    "prompt_cons": "/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- The proposition that `n` is not zero. -/\ntheorem ∀ {R : Type u_1} [inst : Zero R] {n : R} [self : NeZero n], n ≠ 0 :=\n\n/-- The minimal polynomial of a primitive `n`-th root of unity `μ` divides `cyclotomic n ℤ`. -/\ntheorem ∀ {n : ℕ} {K : Type u_1} [inst : Field K] {μ : K},\n  IsPrimitiveRoot μ n → 0 < n → ∀ [inst_1 : CharZero K], minpoly ℤ μ ∣ Polynomial.cyclotomic n ℤ :=\n\n/-- **Wilson's Theorem**: For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` iff n is prime. -/\ntheorem ∀ {n : ℕ}, n ≠ 1 → (Nat.Prime n ↔ ↑(Nat.factorial (n - 1)) = -1) :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- If a prime `p` divides `n` such that `-1` is a square modulo `n`, then `p % 4 ≠ 3`. -/\ntheorem ∀ {p n : ℕ}, Nat.Prime p → p ∣ n → IsSquare (-1) → p % 4 ≠ 3 :=\n\n/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\n  Group.nilpotencyClass G = Group.nilpotencyClass (G ⧸ Subgroup.center G) + 1 :=\n\n/-- For `n ≠ 1`, `(n-1)!` is congruent to `-1` modulo `n` only if n is prime. -/\ntheorem ∀ {n : ℕ}, ↑(Nat.factorial (n - 1)) = -1 → n ≠ 1 → Nat.Prime n :=\n\n/-- Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes. -/\ntheorem",
    "choices": [
      "∀ {n : ℕ}, n > 1 → ¬MulGroup (Zmod n) ",
      "∀ {n : ℕ}, n ≠ 1 → ¬Group (Zmod n) ",
      "∀ {n : ℕ}, n > 1 → ¬MulGroup (Zmod n) ",
      "∀ {n : ℕ}, n > 1 → ¬ IsGroup (Zmod n) ",
      "∀ {n : ℕ} [fact (1 < n)], ¬IsGroup (Zmod n) ",
      "∀ {n : ℕ}, n > 1 → ¬(IsGroup (Zmod n) fun x y : Zmod n => x * y) ",
      "∀ {n : ℕ}, n > 1 → ¬IsGroup (Zmod n) ",
      "∀ {n : ℕ}, n > 1 → ¬ IsGroup (Zmod n) ",
      "∀ {n : ℕ}, n > 1 → ¬ IsGroup (Zmod n) [Zmod.HasMul n] ",
      "∀ {n : ℕ}, n > 1 → ¬IsGroup (ℤ/nℤ) "
    ]
  },
  {
    "docString": "Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit `a` of a finite field `F` of odd characteristic is a square\\nif and only if `a ^ (#F / 2) = 1`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The number of solutions to `x^2 = a` is determined by the quadratic character. \"},\n {\"theorem\":\n  \"∀ {d : ℤ}, d ≠ 0 → ∀ {a : Pell.Solution₁ d}, Pell.Solution₁.x a = 1 → a = 1\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x = 1` is trivial. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\": \"The square of the symbol is 1 if `p ∤ a`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\\n  a ≠ 0 → ↑(quadraticChar F) a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The square of the quadratic character on nonzero arguments is `1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {P : Type u_2} [inst : VAdd G P] [self : FaithfulVAdd G P] {g₁ g₂ : G},\\n  (∀ (p : P), g₁ +ᵥ p = g₂ +ᵥ p) → g₁ = g₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two elements `g₁` and `g₂` are equal whenever they act in the same way on all points. \"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- Euler's Criterion: A unit `x` of `ZMod p` is a square if and only if `x ^ (p / 2) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (x : (ZMod p)ˣ), (∃ y, y ^ 2 = x) ↔ x ^ (p / 2) = 1 :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- A unit `a` of a finite field `F` of odd characteristic is a square\nif and only if `a ^ (#F / 2) = 1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F],\n  ringChar F ≠ 2 → ∀ (a : Fˣ), IsSquare a ↔ a ^ (Fintype.card F / 2) = 1 :=\n\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F],\n  ringChar F ≠ 2 → ∀ (a : F), ↑(Finset.card (Set.toFinset {x | x ^ 2 = a})) = ↑(quadraticChar F) a + 1 :=\n\n/-- A solution with `x = 1` is trivial. -/\ntheorem ∀ {d : ℤ}, d ≠ 0 → ∀ {a : Pell.Solution₁ d}, Pell.Solution₁.x a = 1 → a = 1 :=\n\n/-- The square of the symbol is 1 if `p ∤ a`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ℤ}, ↑a ≠ 0 → legendreSym p a ^ 2 = 1 :=\n\n/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F] [inst_2 : DecidableEq F] {a : F},\n  a ≠ 0 → ↑(quadraticChar F) a ^ 2 = 1 :=\n\n/-- Two elements `g₁` and `g₂` are equal whenever they act in the same way on all points. -/\ntheorem ∀ {G : Type u_1} {P : Type u_2} [inst : VAdd G P] [self : FaithfulVAdd G P] {g₁ g₂ : G},\n  (∀ (p : P), g₁ +ᵥ p = g₂ +ᵥ p) → g₁ = g₂ :=\n\n/-- Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ (orderOf x = 1 ∨ orderOf x = 2) ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Monoid G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "forall {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ orderOf x = 1 ∨ orderOf x = 2 ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, x ^ 2 = 1 ↔ (orderOf x = 1 ∨ orderOf x = 2) "
    ]
  },
  {
    "docString": "Let $x$ and $y$ be elements of $G$. Prove that $xy=yx$ if and only if $y^{-1}xy=x$ if and only if $x^{-1}y^{-1}xy=1$.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u} {L₁ L₂ : List (α × Bool)} {x1 : α} {b1 : Bool} {x2 : α} {b2 : Bool},\\n  (x1, b1) ≠ (x2, b2) → FreeGroup.Red ((x1, b1) :: L₁) ((x2, b2) :: L₂) → FreeGroup.Red L₁ ((x1, !b1) :: (x2, b2) :: L₂)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` and `y` are distinct letters and `w₁ w₂` are words such that `xw₁` reduces to `yw₂`, then\\n`w₁` reduces to `x⁻¹yw₂`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] {a : Mˣ} {x y : M}, SemiconjBy (↑a) x y → SemiconjBy (↑a⁻¹) y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Type u_2} [inst : SMul M α] [self : MulAction.IsPretransitive M α] (x y : α), ∃ g, g • x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g • x = y`. \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"By definition, if `x` is invertible then `inverse x = x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of left inverse \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Type u_2} [inst : VAdd M α] [self : AddAction.IsPretransitive M α] (x y : α), ∃ g, g +ᵥ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g +ᵥ x = y`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x)\",\n  \"isProp\": true,\n  \"docString\": \"Proof of right inverse \"},\n {\"theorem\":\n  \"∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x\",\n  \"isProp\": true,\n  \"docString\":\n  \"An equivalence relation is symmetric: `x ~ y` implies `y ~ x` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant μ]\\n  [inst_7 : MeasureTheory.Measure.IsMulRightInvariant ν],\\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.fst⁻¹)\",\n  \"isProp\": true,\n  \"docString\": \"The map `(x, y) ↦ (xy, x⁻¹)` is measure-preserving. \"}]\n",
    "prompt_cons": "/-- If `x` and `y` are distinct letters and `w₁ w₂` are words such that `xw₁` reduces to `yw₂`, then\n`w₁` reduces to `x⁻¹yw₂`. -/\ntheorem ∀ {α : Type u} {L₁ L₂ : List (α × Bool)} {x1 : α} {b1 : Bool} {x2 : α} {b2 : Bool},\n  (x1, b1) ≠ (x2, b2) → FreeGroup.Red ((x1, b1) :: L₁) ((x2, b2) :: L₂) → FreeGroup.Red L₁ ((x1, !b1) :: (x2, b2) :: L₂) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- If a unit `a` semiconjugates `x` to `y`, then `a⁻¹` semiconjugates `y` to `x`. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] {a : Mˣ} {x y : M}, SemiconjBy (↑a) x y → SemiconjBy (↑a⁻¹) y x :=\n\n/-- There is `g` such that `g • x = y`. -/\ntheorem ∀ {M : Type u_1} {α : Type u_2} [inst : SMul M α] [self : MulAction.IsPretransitive M α] (x y : α), ∃ g, g • x = y :=\n\n/-- By definition, if `x` is invertible then `inverse x = x⁻¹`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : MonoidWithZero M₀] (u : M₀ˣ), Ring.inverse ↑u = ↑u⁻¹ :=\n\n/-- Proof of left inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.LeftInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- There is `g` such that `g +ᵥ x = y`. -/\ntheorem ∀ {M : Type u_1} {α : Type u_2} [inst : VAdd M α] [self : AddAction.IsPretransitive M α] (x y : α), ∃ g, g +ᵥ x = y :=\n\n/-- Proof of right inverse -/\ntheorem ∀ {α : Type u} [self : Rack α] (x : α), Function.RightInverse (Rack.invAct x) (Shelf.act x) :=\n\n/-- An equivalence relation is symmetric: `x ~ y` implies `y ~ x` -/\ntheorem ∀ {α : Sort u} {r : α → α → Prop}, Equivalence r → ∀ {x y : α}, r x y → r y x :=\n\n/-- The map `(x, y) ↦ (xy, x⁻¹)` is measure-preserving. -/\ntheorem ∀ {G : Type u_1} [inst : MeasurableSpace G] [inst_1 : Group G] [inst_2 : MeasurableMul₂ G]\n  (μ ν : MeasureTheory.Measure G) [inst_3 : MeasureTheory.SigmaFinite ν] [inst_4 : MeasureTheory.SigmaFinite μ]\n  [inst_5 : MeasurableInv G] [inst_6 : MeasureTheory.Measure.IsMulRightInvariant μ]\n  [inst_7 : MeasureTheory.Measure.IsMulRightInvariant ν],\n  MeasureTheory.MeasurePreserving fun z => (z.fst * z.snd, z.fst⁻¹) :=\n\n/-- Let $x$ and $y$ be elements of $G$. Prove that $xy=yx$ if and only if $y^{-1}xy=x$ if and only if $x^{-1}y^{-1}xy=1$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] (x y : G), x * y = y * x ↔ y⁻¹ * x * y = x ↔ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] (x y : G),\n  (x * y = y * x) ↔ (y⁻¹ * x * y = x) ∧ (x⁻¹ * y⁻¹ * x * y = 1) ",
      "∀ {G : Type u} [inst : Group G] {x y : G}, x * y = y * x ↔ y⁻¹ * x * y = x ↔ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] (x y : G), x * y = y * x ↔ y⁻¹ * x * y = x ∧ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] (x y : G), x * y = y * x ↔ y⁻¹ * x * y = x ∧ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] {x y : G}, x * y = y * x ↔ y⁻¹ * x * y = x ↔ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] (x y : G), x * y = y * x ↔ y⁻¹ * x * y = x ↔ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] (x y : G), x * y = y * x ↔ y⁻¹ * x * y = x ↔ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] (x y : G), x * y = y * x ↔ y⁻¹ * x * y = x ∧ x⁻¹ * y⁻¹ * x * y = 1 ",
      "∀ {G : Type u} [inst : Group G] (x y : G), x * y = y * x ↔ y⁻¹ * x * y = x ↔ x⁻¹ * y⁻¹ * x * y = 1 "
    ]
  },
  {
    "docString": "If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type w} [inst : Group G] {g : G} {P : G → Prop},\\n  P 1 → (∀ (a : G), P a → P (g * a)) → (∀ (a : G), P a → P (g⁻¹ * a)) → ∀ (n : ℤ), P (g ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all powers of `g` it suffices to show it is closed under multiplication\\nby `g` and `g⁻¹` on the left. For subgroups generated by more than one element, see\\n`Subgroup.closure_induction_left`. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : Group G] {g : G} {P : G → Prop},\\n  P 1 → (∀ (a : G), P a → P (a * g)) → (∀ (a : G), P a → P (a * g⁻¹)) → ∀ (n : ℤ), P (g ^ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all powers of `g` it suffices to show it is closed under multiplication\\nby `g` and `g⁻¹` on the right. For subgroups generated by more than one element, see\\n`Subgroup.closure_induction_right`. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.LeftInverse g f → Function.IsFixedPt g x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\\npoint of `g`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Type u_2} [inst : VAdd M α] [self : AddAction.IsPretransitive M α] (x y : α), ∃ g, g +ᵥ x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g +ᵥ x = y`. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : AddGroup G] {g : G} {P : G → Prop},\\n  P 0 → (∀ (a : G), P a → P (g + a)) → (∀ (a : G), P a → P (-g + a)) → ∀ (n : ℤ), P (n • g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all multiples of `g` it suffices to show it is closed under\\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\\n`AddSubgroup.closure_induction_left`.\"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Type u_2} [inst : SMul M α] [self : MulAction.IsPretransitive M α] (x y : α), ∃ g, g • x = y\",\n  \"isProp\": true,\n  \"docString\": \"There is `g` such that `g • x = y`. \"},\n {\"theorem\":\n  \"∀ {G : Type w} [inst : AddGroup G] {g : G} {P : G → Prop},\\n  P 0 → (∀ (a : G), P a → P (a + g)) → (∀ (a : G), P a → P (a + -g)) → ∀ (n : ℤ), P (n • g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show a property of all multiples of `g` it suffices to show it is closed under\\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\\nsee `AddSubgroup.closure_induction_right`.\"},\n {\"theorem\":\n  \"∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z)\\n  [inst_3 : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)], CategoryTheory.IsIso g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If\\n```\\n(f 0)\\n(0 g)\\n```\\nis invertible, then `g` is invertible.\\n\"},\n {\"theorem\":\n  \"∀ {n : ℕ} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) → G) (j : Fin (n + 1)) (k : Fin n),\\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))⁻¹ *\\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\\n    Fin.contractNth j (fun x x_1 => x * x_1) g k\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\\nThen if `k < j`, this says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ = gₖ`.\\nIf `k = j`, it says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ₊₁ = gₖgₖ₊₁`.\\nIf `k > j`, it says `(g₀g₁...gₖ)⁻¹ * g₀g₁...gₖ₊₁ = gₖ₊₁.`\\nUseful for defining group cohomology. \"}]\n",
    "prompt_cons": "/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g⁻¹` on the left. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_left`. -/\ntheorem ∀ {G : Type w} [inst : Group G] {g : G} {P : G → Prop},\n  P 1 → (∀ (a : G), P a → P (g * a)) → (∀ (a : G), P a → P (g⁻¹ * a)) → ∀ (n : ℤ), P (g ^ n) :=\n\n/-- To show a property of all powers of `g` it suffices to show it is closed under multiplication\nby `g` and `g⁻¹` on the right. For subgroups generated by more than one element, see\n`Subgroup.closure_induction_right`. -/\ntheorem ∀ {G : Type w} [inst : Group G] {g : G} {P : G → Prop},\n  P 1 → (∀ (a : G), P a → P (a * g)) → (∀ (a : G), P a → P (a * g⁻¹)) → ∀ (n : ℤ), P (g ^ n) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- If `x` is a fixed point of `f` and `g` is a left inverse of `f`, then `x` is a fixed\npoint of `g`. -/\ntheorem ∀ {α : Type u} {f g : α → α} {x : α}, Function.IsFixedPt f x → Function.LeftInverse g f → Function.IsFixedPt g x :=\n\n/-- There is `g` such that `g +ᵥ x = y`. -/\ntheorem ∀ {M : Type u_1} {α : Type u_2} [inst : VAdd M α] [self : AddAction.IsPretransitive M α] (x y : α), ∃ g, g +ᵥ x = y :=\n\n/-- To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\n`AddSubgroup.closure_induction_left`. -/\ntheorem ∀ {G : Type w} [inst : AddGroup G] {g : G} {P : G → Prop},\n  P 0 → (∀ (a : G), P a → P (g + a)) → (∀ (a : G), P a → P (-g + a)) → ∀ (n : ℤ), P (n • g) :=\n\n/-- There is `g` such that `g • x = y`. -/\ntheorem ∀ {M : Type u_1} {α : Type u_2} [inst : SMul M α] [self : MulAction.IsPretransitive M α] (x y : α), ∃ g, g • x = y :=\n\n/-- To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\nsee `AddSubgroup.closure_induction_right`. -/\ntheorem ∀ {G : Type w} [inst : AddGroup G] {g : G} {P : G → Prop},\n  P 0 → (∀ (a : G), P a → P (a + g)) → (∀ (a : G), P a → P (a + -g)) → ∀ (n : ℤ), P (n • g) :=\n\n/-- If\n```\n(f 0)\n(0 g)\n```\nis invertible, then `g` is invertible. -/\ntheorem ∀ {C : Type u} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]\n  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {W X Y Z : C} (f : W ⟶ Y) (g : X ⟶ Z)\n  [inst_3 : CategoryTheory.IsIso (CategoryTheory.Limits.biprod.map f g)], CategoryTheory.IsIso g :=\n\n/-- Let `(g₀, g₁, ..., gₙ)` be a tuple of elements in `Gⁿ⁺¹`.\nThen if `k < j`, this says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ = gₖ`.\nIf `k = j`, it says `(g₀g₁...gₖ₋₁)⁻¹ * g₀g₁...gₖ₊₁ = gₖgₖ₊₁`.\nIf `k > j`, it says `(g₀g₁...gₖ)⁻¹ * g₀g₁...gₖ₊₁ = gₖ₊₁.`\nUseful for defining group cohomology. -/\ntheorem ∀ {n : ℕ} {G : Type u_1} [inst : Group G] (g : Fin (n + 1) → G) (j : Fin (n + 1)) (k : Fin n),\n  (Fin.partialProd g (Fin.succAbove (Fin.succ j) (Fin.castSucc k)))⁻¹ *\n      Fin.partialProd g (Fin.succ (Fin.succAbove j k)) =\n    Fin.contractNth j (fun x x_1 => x * x_1) g k :=\n\n/-- If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$. -/\ntheorem",
    "choices": [
      "∀ {G : Type w} [inst : Group G] {g x : G}, orderOf x = orderOf (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] {x g : G}, orderOf x = orderOf (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] {x g : G}, orderOf x = orderOf (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] {x g : G}, orderOf x = orderOf (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] {x g : G}, orderOf x = orderOf (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] (x g : G), orderOf x = orderOf (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] (g x : G), order_of x = order_of (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] {g x : G}, orderOf x = orderOf (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] {x g : G}, order_of x = order_of (g⁻¹ * x * g) ",
      "∀ {G : Type w} [inst : Group G] (g x : G), order_of x = order_of (g⁻¹ * x * g) "
    ]
  },
  {
    "docString": "Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups have nilpotency class at most one \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G ⧸ Subgroup.center G) → Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"If the quotient by `center G` is nilpotent, then so is G. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1\",\n  \"isProp\": true,\n  \"docString\": \"Shows that $e^{x} * e^{-x} = 1$ \"},\n {\"theorem\":\n  \"∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L\",\n  \"isProp\": true,\n  \"docString\": \"A semisimple Abelian Lie algebra is trivial. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove something about polynomials,\\nit suffices to show the condition is closed under taking sums,\\nand it holds for monomials.\\n\"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- Abelian groups have nilpotency class at most one -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.nilpotencyClass G ≤ 1 :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- For all `a` and `b` of `G₀`, `a * b = 0` implies `a = 0` or `b = 0`. -/\ntheorem ∀ {M₀ : Type u_1} [inst : Mul M₀] [inst_1 : Zero M₀] [self : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 → a = 0 ∨ b = 0 :=\n\n/-- If the quotient by `center G` is nilpotent, then so is G. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Group.IsNilpotent (G ⧸ Subgroup.center G) → Group.IsNilpotent G :=\n\n/-- Shows that $e^{x} * e^{-x} = 1$ -/\ntheorem ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : Algebra ℚ A],\n  PowerSeries.exp A * ↑PowerSeries.evalNegHom (PowerSeries.exp A) = 1 :=\n\n/-- A semisimple Abelian Lie algebra is trivial. -/\ntheorem ∀ (R : Type u) (L : Type v) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]\n  [inst : LieAlgebra.IsSemisimple R L] [h : IsLieAbelian L], Subsingleton L :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- To prove something about polynomials,\nit suffices to show the condition is closed under taking sums,\nand it holds for monomials. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] {M : Polynomial R → Prop} (p : Polynomial R),\n  (∀ (p q : Polynomial R), M p → M q → M (p + q)) → (∀ (n : ℕ) (a : R), M (↑(Polynomial.monomial n) a)) → M p :=\n\n/-- Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommGroup G ",
      "∀ {G : Type u_1} [inst : Group G], (∀ (x : G), x ^ 2 = 1) → IsCommutative G "
    ]
  },
  {
    "docString": "If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\in \\mathbb{Z}$ are all distinct.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n * x = 0`, but `n/p * x ≠ 0` for\\nall prime factors `p` of `n`, then `x` has order `n` in `G`.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"Inverses of elements of finite order have finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {n : ℕ},\\n  (∀ (s : Finset A), (AlgebraicIndependent R fun i => ↑i) → Finset.card s ≤ n) →\\n    ∀ (s : Set A), AlgebraicIndependent R Subtype.val → Cardinal.mk ↑s ≤ ↑n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite set of algebraically independent element has cardinality at most `n`,\\nthen the same is true for arbitrary sets of algebraically independent elements. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\\n  IsOfFinOrder x → IsOfFinOrder (↑f x)\",\n  \"isProp\": true,\n  \"docString\": \"The image of an element of finite order has finite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y)\",\n  \"isProp\": true,\n  \"docString\": \"Elements of finite order are closed under multiplication. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A monoid is not a torsion monoid if it has an element of infinite order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x\",\n  \"isProp\": true,\n  \"docString\": \"A group element has finite order iff its order is positive. \"}]\n",
    "prompt_cons": "/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- If `n * x = 0`, but `n/p * x ≠ 0` for\nall prime factors `p` of `n`, then `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : AddMonoid G] {x : G} {n : ℕ},\n  0 < n → n • x = 0 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → (n / p) • x ≠ 0) → addOrderOf x = n :=\n\n/-- Inverses of elements of finite order have finite order. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {x : G}, IsOfFinOrder x⁻¹ ↔ IsOfFinOrder x :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If every finite set of algebraically independent element has cardinality at most `n`,\nthen the same is true for arbitrary sets of algebraically independent elements. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {n : ℕ},\n  (∀ (s : Finset A), (AlgebraicIndependent R fun i => ↑i) → Finset.card s ≤ n) →\n    ∀ (s : Set A), AlgebraicIndependent R Subtype.val → Cardinal.mk ↑s ≤ ↑n :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- The image of an element of finite order has finite order. -/\ntheorem ∀ {G : Type u_2} {H : Type u_1} [inst : Monoid G] [inst_1 : Monoid H] (f : G →* H) {x : G},\n  IsOfFinOrder x → IsOfFinOrder (↑f x) :=\n\n/-- Elements of finite order are closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G] {x y : G}, IsOfFinOrder x → IsOfFinOrder y → IsOfFinOrder (x * y) :=\n\n/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsion G ↔ ∃ g, ¬IsOfFinOrder g :=\n\n/-- A group element has finite order iff its order is positive. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G}, 0 < orderOf x ↔ IsOfFinOrder x :=\n\n/-- If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\in \\mathbb{Z}$ are all distinct. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ (n m : ℤ), x ^ n = x ^ m → n = m ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ (m n : ℤ), m ≠ n → x ^ m ≠ x ^ n ",
      "∀ {G : Type u_1} [inst : Group G] {x : G},\n  ¬IsOfFinOrder x → ∀ n m : ℤ, x ^ n = x ^ m → n = m ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ (m n : ℤ), m ≠ n → x ^ m ≠ x ^ n ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ (m n : ℤ), x ^ m = x ^ n ↔ m = n ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ m n : ℤ, m ≠ n → x ^ m ≠ x ^ n ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ (m n : ℤ), m ≠ n → x ^ m ≠ x ^ n ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ (m n : ℤ), x ^ m = x ^ n → m = n ",
      "∀ {G : Type u_1} [inst : Group G] {x : G},\n  ¬IsOfFinOrder x → ∀ (n m : ℤ), n ≠ m → x ^ n ≠ x ^ m ",
      "∀ {G : Type u_1} [inst : Group G] {x : G}, ¬IsOfFinOrder x → ∀ m n : ℤ, x ^ m = x ^ n → m = n "
    ]
  },
  {
    "docString": "Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic.",
    "prompts": "[{\"theorem\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n R` is different from `0`. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic' n R` is different from `0`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\":\n  \"∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\\n  A ≃+* B → NoZeroDivisors A\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two rings are isomorphic, and the second doesn't have zero divisors,\\nthen so does the first. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\\n  NonarchimedeanAddGroup (G × K)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean groups is nonarchimedean.\"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R × S)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cartesian product of two nonarchimedean rings is nonarchimedean. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication is monotone in an ordered commutative group. \"}]\n",
    "prompt_cons": "/-- `cyclotomic n R` is different from `0`. -/\ntheorem ∀ (n : ℕ) (R : Type u_1) [inst : Ring R] [inst_1 : Nontrivial R], Polynomial.cyclotomic n R ≠ 0 :=\n\n/-- `cyclotomic' n R` is different from `0`. -/\ntheorem ∀ (n : ℕ) (R : Type u_1) [inst : CommRing R] [inst_1 : IsDomain R], Polynomial.cyclotomic' n R ≠ 0 :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanGroup G] {K : Type u_2}\n  [inst_3 : Group K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanGroup K], NonarchimedeanGroup (G × K) :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G :=\n\n/-- If two rings are isomorphic, and the second doesn't have zero divisors,\nthen so does the first. -/\ntheorem ∀ {A : Type u_1} (B : Type u_2) [inst : Ring A] [inst_1 : Ring B] [inst_2 : NoZeroDivisors B],\n  A ≃+* B → NoZeroDivisors A :=\n\n/-- The cartesian product of two nonarchimedean groups is nonarchimedean. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : NonarchimedeanAddGroup G] {K : Type u_2}\n  [inst_3 : AddGroup K] [inst_4 : TopologicalSpace K] [inst_5 : NonarchimedeanAddGroup K],\n  NonarchimedeanAddGroup (G × K) :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem ∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- The cartesian product of two nonarchimedean rings is nonarchimedean. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R]\n  [inst_3 : Ring S] [inst_4 : TopologicalSpace S] [inst_5 : NonarchimedeanRing S], NonarchimedeanRing (R × S) :=\n\n/-- Multiplication is monotone in an ordered commutative group. -/\ntheorem ∀ {α : Type u} [self : OrderedCommGroup α] (a b : α), a ≤ b → ∀ (c : α), c * a ≤ c * b :=\n\n/-- Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic. -/\ntheorem",
    "choices": [
      "_not_isomorphic_real_complex : ¬(Units ℝ ≃* Units ℂ) ",
      "∀ {R : Type u_1} {C : Type u_2} [inst : CommGroup R] [inst_1 : TopologicalSpace R] [inst_2 : Real R]\n  [inst_3 : Zero R] [inst_4 : CommGroup C] [inst_5 : TopologicalSpace C] [inst_6 : Complex C]\n  [inst_7 : Zero C], ¬(R ≠ 0 → C ≠ 0 → R ≃* C) ",
      "¬(units ℝ ≃* units ℂ) ",
      "∀ {R : Type u_1} {C : Type u_2} [inst : DivisionRing R] [inst_1 : DivisionRing C] [inst_2 : RealDomain R]\n  [inst_3 : RealDomain C], ¬(Rˣ ≃* Cˣ) ",
      "¬(units ℝ ≃* units ℂ) ",
      "NotIsomorphic.Real.toComplex : ¬(units ℝ ≃* units ℂ) ",
      "Real.mulGroup.≃.complex.mulGroup → False ",
      "¬(units ℝ ≃* units ℂ) ",
      "¬(units ℝ ≃* units ℂ) ",
      "NotIsomorphicRealComplexMultiplicativeGroup : ¬(units ℝ ≃* units ℂ) "
    ]
  },
  {
    "docString": "Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a\",\n  \"isProp\": true,\n  \"docString\":\n  \"The product of group homomorphisms is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : α → β},\\n  IsGroupHom f → IsGroupHom fun a => (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"The inverse of a group homomorphism is a group homomorphism if the target is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is a monoid homomorphism. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1)\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism is injective iff its kernel is trivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve inverse. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends inverses to inverses. \"},\n {\"theorem\": \"∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv\",\n  \"isProp\": true,\n  \"docString\":\n  \"Inversion is a group homomorphism if the group is commutative. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1\",\n  \"isProp\": true,\n  \"docString\": \"A group homomorphism sends 1 to 1. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The composition of two group homomorphisms is a group homomorphism. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. \"}]\n",
    "prompt_cons": "/-- The product of group homomorphisms is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f g : α → β},\n  IsGroupHom f → IsGroupHom g → IsGroupHom fun a => f a * g a :=\n\n/-- The inverse of a group homomorphism is a group homomorphism if the target is commutative. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} [inst : Group α] [inst_1 : CommGroup β] {f : α → β},\n  IsGroupHom f → IsGroupHom fun a => (f a)⁻¹ :=\n\n/-- A group homomorphism is a monoid homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → IsMonoidHom f :=\n\n/-- A group homomorphism is injective iff its kernel is trivial. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → (Function.Injective f ↔ ∀ (a : α), f a = 1 → a = 1) :=\n\n/-- Group homomorphisms preserve inverse. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a : G), ↑f a⁻¹ = (↑f a)⁻¹ :=\n\n/-- A group homomorphism sends inverses to inverses. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → ∀ (a : α), f a⁻¹ = (f a)⁻¹ :=\n\n/-- Inversion is a group homomorphism if the group is commutative. -/\ntheorem ∀ {α : Type u} [inst : CommGroup α], IsGroupHom Inv.inv :=\n\n/-- A group homomorphism sends 1 to 1. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β}, IsGroupHom f → f 1 = 1 :=\n\n/-- The composition of two group homomorphisms is a group homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},\n  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f) :=\n\n/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\ntheorem ∀ {F : Type u_1} {G : Type u_2} {M : Type u_3} [inst : Group G] [inst_1 : Monoid M] [inst_2 : MonoidHomClass F G M]\n  (f g : F) {x : G}, ↑f x = ↑g x → ↑f x⁻¹ = ↑g x⁻¹ :=\n\n/-- Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G], IsGroupHom Inv.inv ↔ IsCommGroup G ",
      "∀ {G : Type u_1} [inst : Group G], IsGroupHom Inv.inv ↔ IsCommutative G ",
      "∀ {α : Type u} [inst : Group α], IsGroupHom Inv.inv ↔ IsCommutative α ",
      "∀ {G : Type u_1} [inst : Group G], IsGroupHom Inv.inv ↔ IsCommutative G ",
      "∀ {G : Type u_1} [inst : Group G], IsGroupHom Inv.inv ↔ ∀ (a b : G), a * b = b * a ",
      "∀ {G : Type u} [inst : Group G], IsGroupHom Inv.inv ↔ IsCommutativeGroup G ",
      "∀ (G : Type u) [inst : Group G], IsGroupHom Inv.inv ↔ ∀ (a b : G), a * b = b * a ",
      "∀ {G : Type u} [inst : Group G], IsGroupHom Inv.inv ↔ IsCommutative Mul.mul ",
      "∀ {α : Type u} [inst : Group α], IsGroupHom Inv.inv ↔ IsCommGroup α ",
      "∀ (G : Type u) [inst : Group G], IsGroupHom (fun g => g⁻¹) ↔ IsCommGroup G "
    ]
  },
  {
    "docString": "Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\\n  Nat.card { x // x ∈ commutator G } ∣\\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card ↑(commutatorSet G) + 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` has `n` commutators `[g₁, g₂]`, then `|G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\\nwhere `G'` denotes the commutator of `G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `G` has `n` commutators `[g₁, g₂]`, then `|G'| ∣ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,\nwhere `G'` denotes the commutator of `G`. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)],\n  Nat.card { x // x ∈ commutator G } ∣\n    Subgroup.index (Subgroup.center G) ^ (Subgroup.index (Subgroup.center G) * Nat.card ↑(commutatorSet G) + 1) :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  2 < n → n = Fintype.card G → ¬ (∃ H : Subgroup G, Fintype.card { x // x ∈ H } = n - 1) ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  Fintype.card G = n → n > 2 → ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } ≠ n - 1 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  Fintype.card G = n → 2 < n → ¬∃ H : Subgroup G, Fintype.card { x // x ∈ H } = n - 1 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G}, Fintype.card { x // x ∈ H } = Fintype.card G - 1 → Fintype.card G ≤ 2 ",
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  2 < Fintype.card G → Fintype.card G = n → ¬ ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = n - 1 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  Fintype.card G = n → n > 2 → ¬∃ H : Subgroup G, Fintype.card { x // x ∈ H } = n - 1 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  Fintype.card G = n → n > 2 → ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } ≠ n - 1 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  Fintype.card G = n → n > 2 → ∀ H : Subgroup G, Fintype.card { x // x ∈ H } ≠ n - 1 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  2 < n → Fintype.card G = n → ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } ≠ n - 1 ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  Fintype.card G = n → 2 < n →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } ≠ n - 1 "
    ]
  },
  {
    "docString": "Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k)\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup generated by a set includes the set. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"}]\n",
    "prompt_cons": "/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- The subgroup generated by a set includes the set. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {k : Set G}, k ⊆ ↑(Subgroup.closure k) :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H \\ {1}) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H \\ {1}) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H - {1}) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H \\ {1}) ",
      "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G}, H = Subgroup.closure (H - {1}) ",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H \\ {1}) ",
      "forall {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H \\ {1}) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H \\ {1}) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = Subgroup.closure (H - {1}) ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  H = Subgroup.closure (H - {1}) "
    ]
  },
  {
    "docString": "Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\": \"∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\": \"Every subgroup of `ℤ` is cyclic. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"Torsion groups are closed under extensions. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G }\",\n  \"isProp\": true,\n  \"docString\": \"Torsion submonoids are torsion. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion groups are additive torsion groups.\"}]\n",
    "prompt_cons": "/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Every subgroup of `ℤ` is cyclic. -/\ntheorem ∀ (H : AddSubgroup ℤ), ∃ a, H = AddSubgroup.closure {a} :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Torsion groups are closed under extensions. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} [inst : Group G] {N : Subgroup G} [inst_1 : Group H] {f : G →* H},\n  N = MonoidHom.ker f → Monoid.IsTorsion H → Monoid.IsTorsion { x // x ∈ N } → Monoid.IsTorsion G :=\n\n/-- Torsion submonoids are torsion. -/\ntheorem ∀ {G : Type u_1} [inst : CommMonoid G], Monoid.IsTorsion { x // x ∈ CommMonoid.torsion G } :=\n\n/-- Subgroups of additive torsion groups are additive torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G], AddMonoid.IsTorsion G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsion { x // x ∈ H } :=\n\n/-- Show that the subgroup of all rotations in a dihedral group is a maximal subgroup. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G], IsDihedral G → ∀ (H : Subgroup G), IsRotationSubgroup H → IsCoatom H ",
      "∀ {G : Type u_1} [inst : DihedralGroup G],\n  Subgroup.IsMaximal (Subgroup.rotations G) ",
      "∀ {n : ℕ} [fact (0 < n)] (H : Subgroup (DihedralGroup n)), H = Subgroup.zRotation n → IsCoatom H ",
      "∀ {n : ℕ} (hn : n > 2), IsCoatom (Dihedral.rotationSubgroup n) ",
      "∀ {n : ℕ} (hn : 0 < n) (g : Zmod n), IsCoatom (Dihedral.rotationSubgroup n) → Subgroup.Normal (Dihedral.rotationSubgroup n) ",
      "∀ {G : Type u_1} [inst : Group G], DihedralGroup G → ∀ (H : Subgroup G), RotationSubgroup G H → IsCoatom H → Subgroup.Normal H ",
      "∀ {n : ℕ} (hn : n > 2), IsCoatom (Dihedral.rotationSubgroup n hn) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Dihedral G → ∀ (H : Subgroup G), IsRotationSubgroup H → IsCoatom H ",
      "∀ {n : ℕ} (hn : 0 < n), IsCoatom (Subgroup.zpowers (SemidirectProduct.left (zmod n))) ",
      "∀ {n : ℕ} (hn : 0 < n) (H : Subgroup (DihedralGroup n)), IsRotationSubgroup H → IsCoatom H "
    ]
  },
  {
    "docString": "Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Group homomorphisms preserve division. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\\n      1 /\\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1))\",\n  \"isProp\": true,\n  \"docString\": \"Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"}]\n",
    "prompt_cons": "/-- A subgroup is closed under division. -/\ntheorem ∀ {M : Type u_1} {S : Type u_2} [inst : DivInvMonoid M] [inst_1 : SetLike S M] [hSM : SubgroupClass S M] {H : S}\n  {x y : M}, x ∈ H → y ∈ H → x / y ∈ H :=\n\n/-- Group homomorphisms preserve division. -/\ntheorem ∀ {G : Type u_1} {H : Type u_2} {F : Type u_3} [inst : Group G] [inst_1 : DivisionMonoid H]\n  [inst_2 : MonoidHomClass F G H] (f : F) (a b : G), ↑f (a / b) = ↑f a / ↑f b :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], CommMonoid.torsion G = (CommGroup.torsion G).toSubmonoid :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- Shows that `|v - Aₙ / Bₙ| ≤ 1 / (Bₙ * Bₙ₊₁)`. -/\ntheorem ∀ {K : Type u_1} {v : K} {n : ℕ} [inst : LinearOrderedField K] [inst_1 : FloorRing K],\n  ¬GeneralizedContinuedFraction.TerminatedAt (GeneralizedContinuedFraction.of v) n →\n    |v - GeneralizedContinuedFraction.convergents (GeneralizedContinuedFraction.of v) n| ≤\n      1 /\n        (GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) n *\n          GeneralizedContinuedFraction.denominators (GeneralizedContinuedFraction.of v) (n + 1)) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), CommGroup (A ⧸ B) ",
      "∀ {G : Type u_1} [inst : CommGroup G] (H : Subgroup G),\n  CommGroup (G ⧸ H) ",
      "∀ {G : Type u_1} [inst : CommGroup G] (H : Subgroup G), IsAddCommGroup (G ⧸ H) ",
      "∀ {A : Type u_1} {B : Type u_2} [inst : CommGroup A] [inst_1 : SetLike B A] [hAB : SubgroupClass B A] {G : B},\n  AddCommGroup (A ⧸ G) ",
      "∀ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), CommGroup (A ⧸ B) ",
      "∀ {A : Type u_1} {B : Type u_2} [inst : CommGroup A] [inst_1 : SetLike B A] [hAB : SubgroupClass B A] (H : B), CommGroup (A ⧸ H) ",
      "∀ {A : Type u_1} [inst : CommGroup A] {B : Subgroup A}, CommGroup (A ⧸ B) ",
      "∀ {G : Type u_1} [inst : CommGroup G] (B : Subgroup G), AddCommGroup G ⧸ AddSubgroup B ",
      "∀ {G : Type u_1} [inst : CommGroup G] (B : Subgroup G), IsCommutative (G ⧸ B) ",
      "∀ {A : Type u_1} [inst : CommGroup A] (B : Subgroup A), IsCommGroup (A ⧸ B) "
    ]
  },
  {
    "docString": "Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {P Q : Subgroup M},\\n  MulAction.fixedPoints { x // x ∈ P ⊔ Q } α =\\n    MulAction.fixedPoints { x // x ∈ P } α ∩ MulAction.fixedPoints { x // x ∈ Q } α\",\n  \"isProp\": true,\n  \"docString\": \"Fixed points of sup of subgroups is intersection \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"}]\n",
    "prompt_cons": "/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1 :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- Fixed points of sup of subgroups is intersection -/\ntheorem ∀ (M : Type u_1) (α : Type u_2) [inst : Group M] [inst_1 : MulAction M α] {P Q : Subgroup M},\n  MulAction.fixedPoints { x // x ∈ P ⊔ Q } α =\n    MulAction.fixedPoints { x // x ∈ P } α ∩ MulAction.fixedPoints { x // x ∈ Q } α :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable). -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)}, (∀ H ∈ S, Subgroup.Normal H) → Set.Nonempty S → Subgroup.Normal (⋂₀ S) ",
      "∀ {G : Type u_1} [inst : Group G] {ι : Type u_2} (S : ι → Subgroup G) (hS : Nonempty ι),\n  (∀ i, Subgroup.Normal (S i)) → Subgroup.Normal (⨅ i, S i) ",
      "∀ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), (∀ H : Subgroup G, H ∈ S → Subgroup.Normal H) → (∃ H : Subgroup G, H ∈ S) → Subgroup.Normal (Subgroup.inf S) ",
      "∀ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), (∀ H ∈ S, Subgroup.Normal H) → (∃ H₀, H₀ ∈ S) → Subgroup.Normal (⋂₀ S) ",
      "∀ {G : Type u_1} [inst : Group G] (s : Set (Subgroup G)),\n  (∀ H ∈ s, Subgroup.Normal H) → (∃ x, x ∈ s) → Subgroup.Normal (⋂₀ s) ",
      "forall {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)),\n  (∀ H ∈ S, Subgroup.Normal H) → ∃ (H : Subgroup G), S.nonempty → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] {S : Set (Subgroup G)} (hS: S.nonempty),\n  (∀ H ∈ S, Subgroup.Normal H) → Subgroup.Normal (⋂₀ S) ",
      "∀ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)),\n  (∀ (H : Subgroup G), H ∈ S → Subgroup.Normal H) →\n  (∃ (H : Subgroup G), H ∈ S) → Subgroup.Normal (⨅ H ∈ S, H) ",
      "∀ {G : Type u_1} [inst : Group G] (S : Set (Subgroup G)), (∀ H ∈ S, Subgroup.Normal H) → ∃ H : Subgroup G, Subgroup.Normal H ∧ (∀ h ∈ S, H ≤ h) ",
      "∀ {G : Type u_1} [inst : Group G] {I : Type u_2} (S : I → Subgroup G) (hS : ∀ i : I, Subgroup.Normal (S i)),\n  Subgroup.Normal (Subgroup.Inter S) "
    ]
  },
  {
    "docString": "Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite).",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`.\"},\n {\"theorem\":\n  \"∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\\na homomorphism from the whole of `G` to `F`. \"},\n {\"theorem\":\n  \"∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\\n  IntermediateField.fixingSubgroup ⊥ = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"This lemma says that `Gal(L/K) = L ≃ₐ[K] L` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K\",\n  \"isProp\": true,\n  \"docString\": \"Closure of a subgroup `K` equals `K`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\\n  ↑f (a * b) = ↑f a * ↑f b\",\n  \"isProp\": true,\n  \"docString\": \"Ring homomorphisms preserve multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {N : Type u_2} [inst_1 : Group N] (f : G →* N) {H K : Subgroup G},\n  MonoidHom.ker f ≤ H → MonoidHom.ker f ≤ K → Subgroup.map f H = Subgroup.map f K → H = K :=\n\n/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_2} [inst_1 : AddGroup N] (f : G →+ N) {H K : AddSubgroup G},\n  AddMonoidHom.ker f ≤ H → AddMonoidHom.ker f ≤ K → AddSubgroup.map f H = AddSubgroup.map f K → H = K :=\n\n/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem ∀ {V : Type u} {W : Type v} {G : SimpleGraph V} {F : SimpleGraph W} [inst : Finite W],\n  ((G' : SimpleGraph.Subgraph G) → Set.Finite G'.verts → SimpleGraph.Subgraph.coe G' →g F) → Nonempty (G →g F) :=\n\n/-- This lemma says that `Gal(L/K) = L ≃ₐ[K] L` -/\ntheorem ∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L],\n  IntermediateField.fixingSubgroup ⊥ = ⊤ :=\n\n/-- Closure of a subgroup `K` equals `K`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G), Subgroup.closure ↑K = K :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- Ring homomorphisms preserve multiplication. -/\ntheorem ∀ {α : Type u_1} {β : Type u_2} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β} (f : α →+* β) (a b : α),\n  ↑f (a * b) = ↑f a * ↑f b :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite). -/\ntheorem",
    "choices": [
      "forall {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.index H = Subgroup.index K * Subgroup.index (Subgroup.comap K.restrict H) ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.index H = Subgroup.index K * Subgroup.index (Subgroup.comap (Subgroup.subtype K) H) ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Cardinal.mk (G ⧸ H) = Cardinal.mk (G ⧸ K) * Cardinal.mk (K ⧸ H) ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  cardinal.mk (G ⧸ H) = cardinal.mk (G ⧸ K) * cardinal.mk (K ⧸ H) ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  QuotientGroup.card (G ⧸ H) = QuotientGroup.card (G ⧸ K) * QuotientGroup.card (K ⧸ H) ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.index H = Subgroup.index K * Subgroup.index (Subgroup.comap (Subgroup.subtype K) H) ",
      "∀ {G : Type u} [inst : Group G] (H K : Subgroup G),\n  Subgroup.index H = Subgroup.index K * Subgroup.relindex K H ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.relindex H K * Subgroup.relindex K G = Subgroup.relindex H G ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  QuotientGroup.quotientGroupLift H K (QuotientGroup.mk) = QuotientGroup.quotientGroupLift K H (QuotientGroup.mk) * QuotientGroup.quotientGroupLift H K (QuotientGroup.mk) ",
      "∀ {G : Type u_1} [inst : Group G] (H K : Subgroup G),\n  Subgroup.index H * Subgroup.index K = Subgroup.index (Subgroup.comap K.toMonoidHom H) "
    ]
  },
  {
    "docString": "Prove that $\\mathbb{Q}$ has no proper subgroups of finite index.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subring of a ring with no zero divisors has no zero divisors. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\\n  Group.FG { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Schreier's Lemma**: A finite index subgroup of a finitely generated\\ngroup is finitely generated. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Quotienting a group by its torsion subgroup yields a torsion free group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"The additive subgroup has finite index \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"Primitive element theorem for finite dimensional extension of a finite field. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n",
    "prompt_cons": "/-- The subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G} [self : Subgroup.FiniteIndex H], Subgroup.index H ≠ 0 :=\n\n/-- A subring of a ring with no zero divisors has no zero divisors. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : NoZeroDivisors R] (s : Subring R), NoZeroDivisors { x // x ∈ s } :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated\ngroup is finitely generated. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.FG G] [inst_1 : Subgroup.FiniteIndex H],\n  Group.FG { x // x ∈ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\ntheorem ∀ (G : Type u_1) [inst : CommGroup G], Monoid.IsTorsionFree (G ⧸ CommGroup.torsion G) :=\n\n/-- The additive subgroup has finite index -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] {H : AddSubgroup G} [self : AddSubgroup.FiniteIndex H], AddSubgroup.index H ≠ 0 :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Primitive element theorem for finite dimensional extension of a finite field. -/\ntheorem ∀ (F : Type u_1) [inst : Field F] (E : Type u_2) [inst_1 : Field E] [inst_2 : Algebra F E] [inst_3 : Finite F]\n  [inst_4 : FiniteDimensional F E], ∃ α, F⟮α⟯ = ⊤ :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Prove that $\\mathbb{Q}$ has no proper subgroups of finite index. -/\ntheorem",
    "choices": [
      "forall {G : Type u_1} [inst : Group G] [h : G ≃+ ℚ], ∀ P : Subgroup G, Subgroup.FiniteIndex P → P = ⊤ ",
      "∀ {R : Type u_1} [inst : Ring R] [inst_1 : RingCharZero R] [inst_2 : Subfield.FiniteIndex R],\n  (Subfield.FiniteIndex R).index = 1 ",
      "∀ {Q : Type u_1} [inst : DivisionRing Q] [self : Field Q] {H : Subgroup Q} [h : Subgroup.FiniteIndex H], Subgroup.index H = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsQ G], ∀ {H : Subgroup G} [self : Subgroup.FiniteIndex H], H = ⊤ ",
      "∀ {G : Type u_1} [inst : Field G] (H : Subfield G) [self : Subfield.FiniteIndex H], G = H.toSubring ",
      "∀ {G : Type u_1} [inst : Field G] [h : IsFractionRing ℤ G] (H : Subgroup G) [inst_1 : Subgroup.FiniteIndex H], H = ⊤ ",
      "∀ {G : Type u_1} [inst : Group G] [h : Field.toGroup G], Field.toGroup.FiniteIndex G → Subgroup.index (⊥ : Subgroup G) = 1 ",
      "∀ {G : Type u_1} [inst : Group G] [h : IsSubgroup G], Subgroup.index G ≠ 0 ",
      "∀ {G : Type u_1} [inst : Group G] [hG : Isomorphic G ℚ], \n  ∀ (H : Subgroup G), Subgroup.FiniteIndex H → H = ⊤ ",
      "forall (H : Subgroup ℚ), Subgroup.index H ≠ 0 → H = ⊤ "
    ]
  },
  {
    "docString": "Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).",
    "prompts": "[{\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\\nprime powers `p i ^ e i`. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite additive group `G` there exists an element of\\norder `p` in `G`. This is the additive version of Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleAddGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple.\"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"}]\n",
    "prompt_cons": "/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [inst_1 : Finite G], ∃ ι x p x e, Nonempty (G ≃+ ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem ∀ (G : Type u) [inst : AddCommGroup G] [hG : AddGroup.FG G],\n  ∃ n ι x p x e, Nonempty (G ≃+ (Fin n →₀ ℤ) × ⨁ (i : ι), ZMod (p i ^ e i)) :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, addOrderOf x = p :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : AddGroup α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleAddGroup α :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group). -/\ntheorem",
    "choices": [
      "∀ (G : Type u) [inst : AddCommGroup G] [IsSimpleAddGroup G],\n  ∃ p, Fact (Nat.Prime p) ∧ Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u} [inst : AddCommGroup G], IsSimpleAddGroup G → ∃ p [hp : Fact (Nat.Prime p)], Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : IsSimpleAddGroup G], ∃ p [hp : Fact (Nat.Prime p)], Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u_1} [inst : AddCommGroup G],\n  IsSimpleAddGroup G → ∃ p, Fact (Nat.Prime p) ∧ Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u} [inst : AddCommGroup G] [hG : IsSimpleAddGroup G], ∃ p [hp : Fact (Nat.Prime p)], Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u_1} [inst : AddCommGroup G] [hG : IsSimpleAddGroup G], ∃ p [hp : Fact (Nat.Prime p)], Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u_1} [inst : AddCommGroup G] [hG : IsSimpleAddGroup G],\n  ∃ p [hp : Fact (Nat.Prime p)], Nonempty (G ≃+ ZMod p) ",
      "∀ (G : Type u) [inst : AddCommGroup G] [hG : IsSimpleAddGroup G],\n  ∃ p, Fact (Nat.Prime p) ∧ Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u} [inst : AddCommGroup G], IsSimpleAddGroup G → ∃ p [hp : Fact (Nat.Prime p)], Nonempty (G ≃+ ZMod p) ",
      "∀ {G : Type u_1} [inst : AddCommGroup G] [hs : IsSimpleAddGroup G], ∃ p, Fact (Nat.Prime p) ∧ Nonempty (G ≃+ ZMod p) "
    ]
  },
  {
    "docString": "Prove that subgroups of a solvable group are solvable.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion-free groups are torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G],\\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Subgroups of additive torsion-free groups are additively torsion-free.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is finitely generated if and only if it is finitely generated as a submonoid. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"Subgroups of torsion groups are torsion groups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"Product of a list of elements in a subgroup is in the subgroup. \"}]\n",
    "prompt_cons": "/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Subgroups of torsion-free groups are torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsionFree G → ∀ (H : Subgroup G), Monoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- Subgroups of additive torsion-free groups are additively torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G],\n  AddMonoid.IsTorsionFree G → ∀ (H : AddSubgroup G), AddMonoid.IsTorsionFree { x // x ∈ H } :=\n\n/-- A subgroup is finitely generated if and only if it is finitely generated as a submonoid. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (P : Subgroup G), Subgroup.FG P ↔ Submonoid.FG P.toSubmonoid :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- Subgroups of torsion groups are torsion groups. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], Monoid.IsTorsion G → ∀ (H : Subgroup G), Monoid.IsTorsion { x // x ∈ H } :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Product of a list of elements in a subgroup is in the subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (K : Subgroup G) {l : List G}, (∀ (x : G), x ∈ l → x ∈ K) → List.prod l ∈ K :=\n\n/-- Prove that subgroups of a solvable group are solvable. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [h : Group.IsSolvable G], ∀ (H : Subgroup G), Group.IsSolvable { x // x ∈ H } ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsSolvable G] (H : Subgroup G), IsSolvable { x // x ∈ H } ",
      "∀ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable (↥H) ",
      "∀ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), IsSolvable G → IsSolvable { x // x ∈ H } ",
      "∀ {G : Type u_1} [inst : Group G], IsSolvable G → ∀ (H : Subgroup G), IsSolvable { x // x ∈ H } ",
      "forall {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable { x // x ∈ H } ",
      "∀ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (P : Subgroup G), IsSolvable P.toSubgroup ",
      "forall {G : Type u_1} [inst : Group G] [hG : IsSolvable G] (H : Subgroup G), IsSolvable (quotient_group.quotient H) ",
      "∀ {G : Type u_1} [inst : Group G], IsSolvable G → ∀ (H : Subgroup G), IsSolvable { x // x ∈ H } "
    ]
  },
  {
    "docString": "Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"A subgroup is either the trivial subgroup or contains a non-identity element. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"}]\n",
    "prompt_cons": "/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ ∃ x, x ∈ H ∧ x ≠ 1 :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [IsSolvable G] (H : Subgroup G),\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H → ∃ A : Subgroup G, A ≤ H ∧ Nontrivial { x // x ∈ A } ∧ Subgroup.Normal A ∧ IsAbelian G ",
      "∀ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G),\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H →\n    ∃ (A : Subgroup G), Nontrivial { x // x ∈ A } ∧ A ≤ H ∧ Subgroup.Normal A ∧ IsAbelian G A ",
      "∀ {G : Type u_1} [inst : Group G] [hG : IsSolvable G] {H : Subgroup G},\n  Subgroup.Normal H → Nontrivial { x // x ∈ H } →\n    ∃ A : Subgroup G, A ≤ H ∧ Subgroup.Normal A ∧ IsAbelian A ∧ Nontrivial { x // x ∈ A } ",
      "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H → IsSolvable G →\n    ∃ A : Subgroup G, Nontrivial { x // x ∈ A } ∧ Subgroup.Normal A ∧ IsAbelian { x // x ∈ A } ",
      "∀ {G : Type u_1} [inst : Group G] (hG : IsSolvable G) {H : Subgroup G},\n  Subgroup.Normal H → Nontrivial { x // x ∈ H } →\n    ∃ A : Subgroup G, A ≤ H ∧ Subgroup.Normal A ∧ IsAbelian A ∧ Nontrivial { x // x ∈ A } ",
      "∀ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G),\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H → ∃ (A : Subgroup G), A ≤ H ∧ Nontrivial { x // x ∈ A } ∧ Subgroup.Normal A ∧ IsAbelian G ",
      "∀ {G : Type u_1} [inst : Group G] [h : IsSolvable G] (H : Subgroup G),\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H → ∃ (A : Subgroup G), A ≤ H ∧ Subgroup.Normal A ∧ IsAbelian A ",
      "∀ {G : Type u_1} [inst : Group G] [h : Group.IsSolvable G] {H : Subgroup G},\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H →\n    ∃ (A : Subgroup G), Nontrivial { x // x ∈ A } ∧ A ≤ H ∧ Subgroup.Normal A ∧ IsAbelian G A ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : IsSolvable G] (H : Subgroup G),\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H → ∃ A : Subgroup G, A ≤ H ∧ Nontrivial { x // x ∈ A } ∧ Subgroup.Normal A ∧ IsAbelian A ",
      "∀ {G : Type u_1} [inst : Group G] (h_sol : IsSolvable G) (H : Subgroup G),\n  Nontrivial { x // x ∈ H } → Subgroup.Normal H →\n  ∃ A : Subgroup G, Nontrivial { x // x ∈ A } ∧ Subgroup.Normal A ∧ IsAbelian G "
    ]
  },
  {
    "docString": "Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$.",
    "prompts": "[{\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1\",\n  \"isProp\": true,\n  \"docString\": \"Every nonzero element of a group with zero is invertible. \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)},\\n  g ∈ alternatingGroup (Fin 5) →\\n    g ≠ 1 → (∀ (n : ℕ), n ∈ Equiv.Perm.cycleType g → n = 2) → IsConj (Equiv.swap 0 4 * Equiv.swap 1 3) g\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps\\nis conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation\\nin $A_5$ is $A_5$. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ\",\n  \"isProp\": true,\n  \"docString\":\n  \"To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\\non some compact set with non-empty interior. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\\n  [inst_3 : Finite Γ], ProperlyDiscontinuousSMul Γ T\",\n  \"isProp\": true,\n  \"docString\": \"A finite group action is always properly discontinuous. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\\n  UniformGroup (UniformFun α G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. \"}]\n",
    "prompt_cons": "/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- Every nonzero element of a group with zero is invertible. -/\ntheorem ∀ {α : Type u_1} [self : LinearOrderedCommGroupWithZero α] (a : α), a ≠ 0 → a * a⁻¹ = 1 :=\n\n/-- Shows that any non-identity element of $A_5$ whose cycle decomposition consists only of swaps\nis conjugate to $(04)(13)$. This is used to show that the normal closure of such a permutation\nin $A_5$ is $A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)},\n  g ∈ alternatingGroup (Fin 5) →\n    g ≠ 1 → (∀ (n : ℕ), n ∈ Equiv.Perm.cycleType g → n = 2) → IsConj (Equiv.swap 0 4 * Equiv.swap 1 3) g :=\n\n/-- To show that an invariant σ-finite measure is regular it is sufficient to show that it is finite\non some compact set with non-empty interior. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : T2Space G] [inst_3 : TopologicalGroup G]\n  [inst_4 : MeasurableSpace G] [inst_5 : BorelSpace G] [inst_6 : TopologicalSpace.SecondCountableTopology G]\n  {μ : MeasureTheory.Measure G} [inst_7 : MeasureTheory.SigmaFinite μ]\n  [inst : MeasureTheory.Measure.IsMulLeftInvariant μ] {K : Set G},\n  IsCompact K → Set.Nonempty (interior K) → ↑↑μ K ≠ ⊤ → MeasureTheory.Measure.Regular μ :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- A finite group action is always properly discontinuous. -/\ntheorem ∀ {Γ : Type u_1} [inst : Group Γ] {T : Type u_2} [inst_1 : TopologicalSpace T] [inst_2 : MulAction Γ T]\n  [inst_3 : Finite Γ], ProperlyDiscontinuousSMul Γ T :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- If `G` is a uniform group, then `α →ᵤ G` is a uniform group as well. -/\ntheorem ∀ {α : Type u_1} {G : Type u_2} [inst : Group G] [inst_1 : UniformSpace G] [inst_2 : UniformGroup G],\n  UniformGroup (UniformFun α G) :=\n\n/-- Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$. -/\ntheorem",
    "choices": [
      "∀ {A : Type u_1} [inst : Fintype A] [inst_1 : Nonempty A] (G : Type u_2) [inst_2 : Group G] [inst_3 : MulAction G A],\n  Fintype.card A > 1 → Transitive G A → ∃ σ, σ ≠ 1 ∧ ∀ a, MulAction.toFun σ a ≠ a ",
      "∀ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [Nontrivial A]\n  [inst_2 : MulAction G A] [Transitive G A],\n  ∃ (σ : G), ∀ (a : A), MulAction.toFun σ a ≠ a ",
      "∀ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [inst_2 : Fintype G] [inst_3 : Nonempty A],\n  MulAction.IsTransitive G A → 2 ≤ Fintype.card A → ∃ σ : G, ∀ a : A, σ • a ≠ a ",
      "∀ {G : Type u_1} {A : Type u_2} [inst : Group G] [inst_1 : MulAction G A] [inst_2 : Fintype A] [inst_3 : Nonempty A]\n  [inst_4 : Fintype G] [hN : Nontrivial A] (hT : MulAction.IsTransitive G A),\n  ∃ σ : G, ∀ a : A, MulAction.toFun σ a ≠ a ",
      "∀ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [inst_2 : Nonempty A] [inst_3 : Fintype G]\n  [hA : 1 < Fintype.card A] [hG : MulAction G A] [hT : MulAction.IsTransitive G A],\n  ∃ σ : G, ∀ a : A, MulAction.toFun σ a ≠ a ",
      "∀ {A : Type u_1} [inst : Fintype A] [inst_1 : Nonempty A] {G : Type u_2} [inst_2 : Group G] [inst_3 : MulAction G A]\n  [hT : Transitive G A], Fintype.card A > 1 → ∃ σ : G, ∀ a : A, σ • a ≠ a ",
      "∀ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [nontriv : Nonempty A] [inst_2 : MulAction G A]\n  [hTrans : Action.Transitive G A], (∃ σ : G, ∀ a : A, σ • a ≠ a) ",
      "∀ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [hN : Nonempty A] [inst_2 : Fintype G],\n  Fintype.card A > 1 → MulAction.IsTransitive G A → ∃ σ : G, ∀ a : A, σ • a ≠ a ",
      "∀ {A : Type u_1} [inst : Fintype A] {G : Type u_2} [inst_1 : Group G] [inst_2 : MulAction G A]\n  [inst_3 : Nonempty A] (hG : Transitive G A) (hA : Fintype.card A > 1), \n  ∃ σ : G, ∀ a : A, mulAction.toFun σ a ≠ a ",
      "∀ {G : Type u_1} [inst : Group G] {A : Type u_2} [inst_1 : Fintype A] [inst_2 : Fintype G]\n  [inst_3 : MulAction G A], Fintype.card A > 1 → Transitive G A →\n  ∃ σ : G, ∀ a : A, σ • a ≠ a "
    ]
  },
  {
    "docString": "Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\\n  Fintype.card α = p → IsSimpleGroup α\",\n  \"isProp\": true,\n  \"docString\": \"A finite group of prime order is simple. \"},\n {\"theorem\":\n  \"∀ (n : ℕ) {a : ℕ}, 0 < a → ((∃ k, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S ≠ ⊥ → (¬∃ a, IsLeast {g | g ∈ S ∧ 0 < g} a) → Dense ↑S\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\\nelement, then `S` is dense `G`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\\nthen `x` has order `n` in `G`. \"},\n {\"theorem\": \"∀ {m n k : ℕ}, n * k < m → m < n * (k + 1) → ¬n ∣ m\",\n  \"isProp\": true,\n  \"docString\":\n  \"`m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A finite group of prime order is simple. -/\ntheorem ∀ {α : Type u} [inst : Group α] [inst_1 : Fintype α] {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Fintype.card α = p → IsSimpleGroup α :=\n\n/-- `n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. -/\ntheorem ∀ (n : ℕ) {a : ℕ}, 0 < a → ((∃ k, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n) :=\n\n/-- Let `S` be a nontrivial additive subgroup in an archimedean linear ordered additive commutative\ngroup `G` with order topology. If the set of positive elements of `S` does not have a minimal\nelement, then `S` is dense `G`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : TopologicalSpace G] [inst_2 : OrderTopology G]\n  [inst_3 : Archimedean G] (S : AddSubgroup G), S ≠ ⊥ → (¬∃ a, IsLeast {g | g ∈ S ∧ 0 < g} a) → Dense ↑S :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If `x^n = 1`, but `x^(n/p) ≠ 1` for all prime factors `p` of `n`,\nthen `x` has order `n` in `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Monoid G] {x : G} {n : ℕ},\n  0 < n → x ^ n = 1 → (∀ (p : ℕ), Nat.Prime p → p ∣ n → x ^ (n / p) ≠ 1) → orderOf x = n :=\n\n/-- `m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem ∀ {m n k : ℕ}, n * k < m → m < n * (k + 1) → ¬n ∣ m :=\n\n/-- Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : ℕ),\n  0 < n → Nat.Prime n → (∀ k, k ∣ n → ∃ (H : Subgroup G), Fintype.card {x // x ∈ H} = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  0 < n → Fintype.card G = n → (∀ (k : ℕ), 0 < k → k ∣ n → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : ℕ) (hn : 1 < n), (∀ k, k ∣ n → ∃ K, Fintype.card { x // x ∈ K } = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  0 < n → Nat.Prime n → (∀ (k : ℕ), k ∣ Fintype.card G → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ}, 0 < n →\n  (∀ (k : ℕ), 0 < k → k ∣ n → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = k) →\n  ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  0 < n → Fintype.card G = n → (∀ k, 0 < k → k ∣ n → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : ℕ),\n  0 < n → Nat.not_prime n → (∀ k, 0 < k → k ∣ n → ∃ H : Subgroup G, Fintype.card {x // x ∈ H} = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : ℕ),\n  1 < n → (∀ k, 1 ≤ k → k ∣ n → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (n : ℕ),\n  1 < n → (∀ k, k ∣ n → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = k) → ¬IsSimpleGroup G ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ},\n  0 < n → Fintype.card G = n → (∀ k, 0 < k → k ∣ n → ∃ H : Subgroup G, Fintype.card { x // x ∈ H } = k) →\n    ¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that characteristic subgroups are normal.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\": \"The topological closure of a normal subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The topological closure of a normal additive subgroup is normal.\"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤\",\n  \"isProp\": true,\n  \"docString\": \"Any normal subgroup is either `⊥` or `⊤` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is either the trivial subgroup or nontrivial. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of a set is a subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup is closed under multiplication. \"}]\n",
    "prompt_cons": "/-- The topological closure of a normal subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  [inst_3 : Subgroup.Normal N], Subgroup.Normal (Subgroup.topologicalClosure N) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- The topological closure of a normal additive subgroup is normal. -/\ntheorem ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  [inst_3 : AddSubgroup.Normal N], AddSubgroup.Normal (AddSubgroup.topologicalClosure N) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Any normal subgroup is either `⊥` or `⊤` -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [self : IsSimpleGroup G] (H : Subgroup G), Subgroup.Normal H → H = ⊥ ∨ H = ⊤ :=\n\n/-- A subgroup is either the trivial subgroup or nontrivial. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), H = ⊥ ∨ Nontrivial { x // x ∈ H } :=\n\n/-- The normal closure of a set is a subgroup. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (s : Set G), IsSubgroup (Group.normalClosure s) :=\n\n/-- A subgroup is closed under multiplication. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) {x y : G}, x ∈ H → y ∈ H → x * y ∈ H :=\n\n/-- Prove that characteristic subgroups are normal. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), CharSubgroupCondition G →  Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.IsCharacteristic H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.IsCharSubgroup H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Characteristic H → Subgroup.Normal H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), Subgroup.Characteristic H → Subgroup.Normal H "
    ]
  },
  {
    "docString": "If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\\n  p ≠ 0 → Nat.Prime p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A helper lemma: the characteristic is prime if it is non-zero. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a}\",\n  \"isProp\": true,\n  \"docString\":\n  \"Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G }\",\n  \"isProp\": true,\n  \"docString\":\n  \"A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- A helper lemma: the characteristic is prime if it is non-zero. -/\ntheorem ∀ (R : Type u) [inst : Semiring R] [inst_1 : Nontrivial R] [inst_2 : NoZeroDivisors R] {p : ℕ} [hp : CharP R p],\n  p ≠ 0 → Nat.Prime p :=\n\n/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there\nexists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/\ntheorem ∀ {G : Type u_1} [inst : LinearOrderedAddCommGroup G] [inst_1 : Archimedean G] {H : AddSubgroup G} {a : G},\n  IsLeast {g | g ∈ H ∧ 0 < g} a → H = AddSubgroup.closure {a} :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/\ntheorem ∀ (G : Type u_1) [inst : Group G] [inst_1 : Finite ↑(commutatorSet G)], Finite { x // x ∈ commutator G } :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$. -/\ntheorem",
    "choices": [
      "forall {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G} (n : ℕ),\n  Fintype.card { x // x ∈ H } = n →\n  (∀ K : Subgroup G, Fintype.card { x // x ∈ K } = n → H = K) →\n  Subgroup.IsCharacteristic H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  (∀ (K : Subgroup G), Fintype.card { x // x ∈ K } = Fintype.card { x // x ∈ H } → K = H) →\n    Subgroup.characteristic H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ} {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = n →\n    (∀ K : Subgroup G, Fintype.card { x // x ∈ K } = n → K = H) → H.charact ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G} [inst_2 : Fintype { x // x ∈ H }],\n  (∀ (K : Subgroup G), Fintype.card { x // x ∈ K } = Fintype.card { x // x ∈ H } → K = H) →\n    ∀ (ϕ : G ≃* G), Subgroup.comap (MulEquiv.toMonoidHom ϕ) H = H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {n : ℕ} (H : Subgroup G),\n  Fintype.card { x // x ∈ H } = n →\n    (∀ (K : Subgroup G), Fintype.card { x // x ∈ K } = n → K = H) →\n      Subgroup.IsChar H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G} {n : ℕ},\n  Fintype.card { x // x ∈ H } = n → (∀ K : Subgroup G, Fintype.card { x // x ∈ K } = n → K = H) → Subgroup.IsChar H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G},\n  (∀ (K : Subgroup G), Fintype.card { x // x ∈ K } = Fintype.card { x // x ∈ H } → K = H) →\n    ∀ (f : G →* G), ∀ (a : { x // x ∈ H }), coeFn f (coe a) ∈ H ",
      "∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] {H : Subgroup α} [inst_2 : Fintype { x // x ∈ H }],\n  (∀ K : Subgroup α, Fintype.card { x // x ∈ K } = Fintype.card { x // x ∈ H } → K = H) → H.charact ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {H : Subgroup G} (n : ℕ),\n  (∀ K : Subgroup G, Fintype.card { x // x ∈ K } = n → K = H) → Subgroup.characteristic H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    (∀ K : Subgroup G, Fintype.card { x // x ∈ K } = p ^ n → K = H) → Subgroup.IsCharSubgroup H "
    ]
  },
  {
    "docString": "Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$.",
    "prompts": "[{\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  P.1 ≤ H → Sylow p { x // x ∈ H } ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G) [_inst : Fact (Nat.Prime p)],\n  ↑P ≤ H → ∃ Q : Sylow p { x // x ∈ H }, ↑P ≤ ↑Q ",
      "forall {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G), P ≤ H → P ∈ Sylow p { x // x ∈ H } ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G) (hP : P ≤ H),\n  P ∈ Sylow p { x // x ∈ H } ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Sylow p G} (H : Subgroup G) (h : P.carrier ≤ H),\n  ∃ (Q : Sylow p { x // x ∈ H }), P.carrier = ↑Q ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Sylow p G} {H : Subgroup G},\n  P.1 ≤ H → ∃ Q : Sylow p { x // x ∈ H }, P.1 = Q.1 ",
      "forall {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G) (hPH : P.to_subgroup ≤ H),\n  P.to_subgroup ∈ Sylow p { x // x ∈ H } ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (P : Sylow p G) (H : Subgroup G) (hPH : ↑P ≤ H),\n  Sylow p { x // x ∈ H } ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) (P : Sylow p G),\n  P.1 ≤ H → ∃ Q : Sylow p { x // x ∈ H }, P.1 ≤ ↑Q ",
      "∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Fintype (Sylow p G)] (P : Sylow p G),\n  P.carrier ≤ H.carrier → ∃ Q : Sylow p { x // x ∈ H }, P.carrier = Q.carrier "
    ]
  },
  {
    "docString": "Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\\n  [hp₂ : Fact (Nat.Prime p₂)],\\n  p₁ ≠ p₂ →\\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\\n      IsPGroup p₁ { x // x ∈ H₁ } →\\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ })\",\n  \"isProp\": true,\n  \"docString\": \"finite p-groups with different p have coprime orders \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n →\\n        p ∣\\n          Fintype.card\\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\\nindex of `H` inside its normalizer. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- finite p-groups with different p have coprime orders -/\ntheorem ∀ {G : Type u_2} [inst : Group G] {G₂ : Type u_1} [inst_1 : Group G₂] (p₁ p₂ : ℕ) [hp₁ : Fact (Nat.Prime p₁)]\n  [hp₂ : Fact (Nat.Prime p₂)],\n  p₁ ≠ p₂ →\n    ∀ (H₁ : Subgroup G) (H₂ : Subgroup G₂) [inst_2 : Fintype { x // x ∈ H₁ }] [inst_3 : Fintype { x // x ∈ H₂ }],\n      IsPGroup p₁ { x // x ∈ H₁ } →\n        IsPGroup p₂ { x // x ∈ H₂ } → Nat.coprime (Fintype.card { x // x ∈ H₁ }) (Fintype.card { x // x ∈ H₂ }) :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup, then `p` divides the\nindex of `H` inside its normalizer. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n →\n        p ∣\n          Fintype.card\n            ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) :=\n\n/-- Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 → ∃ p [hp : Fact (Nat.Prime p)], ∃ P : Sylow p G, Subgroup.normal P ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 → ∃ p n, Fact (Nat.Prime p) ∧ p ^ n ∣ 312 ∧ ∃ H : Subgroup G, Subgroup.normal H ∧ Fintype.card { x // x ∈ H } = p ^ n ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 → ∃ (p : ℕ) (H : Subgroup G),\n  Fact (Nat.Prime p) ∧ p ∣ Fintype.card G ∧ Subgroup.Normal H ∧ IsPGroup p { x // x ∈ H } ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 →\n  ∃ p (_hp : Fact (Nat.Prime p)) (P : Sylow p G), Subgroup.normal P ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 → ∃ p (H : Subgroup G), Nat.Prime p ∧ Fintype.card { x // x ∈ H } = p ∧ Subgroup.normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 312 →\n  ∃ (p : ℕ) (hp : Fact (Nat.Prime p)) (H : Subgroup G),\n    Fintype.card { x // x ∈ H } = p ^ ↑(Nat.factorization (Fintype.card G)) p ∧ Subgroup.normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 →\n  ∃ (p : ℕ) (H : Subgroup G), Nat.Prime p ∧ p ∣ Fintype.card G ∧ Subgroup.normal H ∧ IsPGroup p { x // x ∈ H } ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 →\n  ∃ p (hp : Nat.Prime p) (P : Sylow p G), Subgroup.normal P ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 → ∃ (p : ℕ) [hp : Fact (Nat.Prime p)], ∃ (H : Sylow p G), Subgroup.normal H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 312 →\n  ∃ p (H : Subgroup G), Fact (Nat.Prime p) ∧ p ∣ Fintype.card G ∧ (Subgroup.IsPGroup p).IsNormal H "
    ]
  },
  {
    "docString": "Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalisation of **Sylow's first theorem**. If `p ^ n` divides\\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\\n  Fintype.card (Sylow p G) ≡ 1 [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's third theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\\n  MulAction.IsPretransitive G (Sylow p G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's second theorem**.\\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G},\\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H }\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\\n  p ∣ Fintype.card G → ∃ x, orderOf x = p\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every prime `p` dividing the order of a finite group `G` there exists an element of order\\n`p` in `G`. This is known as Cauchy's theorem. \"}]\n",
    "prompt_cons": "/-- A generalisation of **Sylow's first theorem**. If `p ^ n` divides\nthe cardinality of `G`, then there is a subgroup of cardinality `p ^ n` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n : ℕ} [inst_2 : Fact (Nat.Prime p)],\n  p ^ n ∣ Fintype.card G → ∃ K, Fintype.card { x // x ∈ K } = p ^ n :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- A generalization of **Sylow's third theorem**.\nIf the number of Sylow `p`-subgroups is finite, then it is congruent to `1` modulo `p`. -/\ntheorem ∀ (p : ℕ) (G : Type u_1) [inst : Group G] [inst_1 : Fact (Nat.Prime p)] [inst_2 : Fintype (Sylow p G)],\n  Fintype.card (Sylow p G) ≡ 1 [MOD p] :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- A generalization of **Sylow's second theorem**.\nIf the number of Sylow `p`-subgroups is finite, then all Sylow `p`-subgroups are conjugate. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] [hp : Fact (Nat.Prime p)] [inst_1 : Finite (Sylow p G)],\n  MulAction.IsPretransitive G (Sylow p G) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a `p`-subgroup but not a Sylow `p`-subgroup of cardinality `p ^ n`,\nthen `p ^ (n + 1)` divides the cardinality of the normalizer of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G},\n      Fintype.card { x // x ∈ H } = p ^ n → p ^ (n + 1) ∣ Fintype.card { x // x ∈ Subgroup.normalizer H } :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) [hp : Fact (Nat.Prime p)],\n  p ∣ Fintype.card G → ∃ x, orderOf x = p :=\n\n/-- Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q r : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r → (p < q) ∧ (q < r) → ∃ K, Subgroup.normal K ∧ (∃ n, Fintype.card { x // x ∈ K } = p ^ n) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r → p < q → q < r →\n    (∃ (P : Sylow p G), Subgroup.normal (P : Subgroup G)) ∨\n    (∃ (Q : Sylow q G), Subgroup.normal (Q : Subgroup G)) ∨\n    (∃ (R : Sylow r G), Subgroup.normal (R : Subgroup G)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q r : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  p < q → q < r → Fintype.card G = p * q * r → ∃ (R : Sylow p G ⊕ Sylow q G ⊕ Sylow r G), Sylow.IsNormal R ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q r : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r → (p < q) → (q < r) →\n  (∃ P : Sylow p G, is_normal P) ∨ (∃ Q : Sylow q G, is_normal Q) ∨ (∃ R : Sylow r G, is_normal R) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q r : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  p < q → q < r → Fintype.card G = p * q * r →\n    ∃ S, S ∈ Sylow p G ∧ IsNormalSubgroup S ∨ S ∈ Sylow q G ∧ IsNormalSubgroup S ∨ S ∈ Sylow r G ∧ IsNormalSubgroup S ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q r : ℕ) [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  p < q → q < r → Fintype.card G = p * q * r →\n  (∃ P : Sylow p G, Subgroup.normal (coe P)) ∨\n  (∃ Q : Sylow q G, Subgroup.normal (coe Q)) ∨\n  (∃ R : Sylow r G, Subgroup.normal (coe R)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] (p q r : ℕ) [_hp : Fact (Nat.Prime p)] [_hq : Fact (Nat.Prime q)] [_hr : Fact (Nat.Prime r)],\n  (p < q) ∧ (q < r) ∧ (Fintype.card G = p * q * r) →\n    (∃ P : Sylow p G, Subgroup.Normal (↑P)) ∨\n    (∃ Q : Sylow q G, Subgroup.Normal (↑Q)) ∨\n    (∃ R : Sylow r G, Subgroup.Normal (↑R)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r → p < q → q < r →\n    (∃ P : Sylow p G, Subgroup.IsNormal (coe P)) ∨ (∃ Q : Sylow q G, Subgroup.IsNormal (coe Q)) ∨ (∃ R : Sylow r G, Subgroup.IsNormal (coe R)) ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] {p q r : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r → p < q → q < r →\n  (∃ P : Sylow p G, ∀ Q : Sylow p G, P = Q) ∨\n  (∃ Q : Sylow q G, ∀ R : Sylow q G, Q = R) ∨\n  (∃ R : Sylow r G, ∀ S : Sylow r G, R = S) ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p q r : ℕ} [hp : Fact (Nat.Prime p)] [hq : Fact (Nat.Prime q)] [hr : Fact (Nat.Prime r)],\n  Fintype.card G = p * q * r ∧ p < q ∧ q < r →\n  (∃ P : Sylow p G, Subgroup.normal P) ∨ (∃ Q : Sylow q G, Subgroup.normal Q) ∨ (∃ R : Sylow r G, Subgroup.normal R) "
    ]
  },
  {
    "docString": "Prove that a group of order 200 has a normal Sylow 5-subgroup.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p\",\n  \"isProp\": true,\n  \"docString\":\n  \"The cardinality of a Sylow subgroup is `p ^ n`\\nwhere `n` is the multiplicity of `p` in the group order. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\\n      Nonempty\\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of s is the smallest normal subgroup containing s. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q\",\n  \"isProp\": true,\n  \"docString\":\n  \"A generalization of **Sylow's first theorem**.\\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"}]\n",
    "prompt_cons": "/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- The cardinality of a Sylow subgroup is `p ^ n`\nwhere `n` is the multiplicity of `p` in the group order. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Fintype.card { x // x ∈ ↑P } = p ^ ↑(Nat.factorization (Fintype.card G)) p :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\n      Nonempty\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)] :=\n\n/-- The normal closure of s is the smallest normal subgroup containing s. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] {s t : Set G}, IsNormalSubgroup t → s ⊆ t → Group.normalClosure s ⊆ t :=\n\n/-- A generalization of **Sylow's first theorem**.\nEvery `p`-subgroup is contained in a Sylow `p`-subgroup. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] {P : Subgroup G}, IsPGroup p { x // x ∈ P } → ∃ Q, P ≤ ↑Q :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- Prove that a group of order 200 has a normal Sylow 5-subgroup. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G], Fintype.card G = 200 →\n  ∃ (H : Sylow 5 G), Subgroup.Normal ↑H ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 200),\n  ∃ (Q : Sylow 5 G), Subgroup.Normal ↑Q ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 200 → ∃ (P : Sylow 5 G), Subgroup.Normal ↑P ",
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 200 → (∃ (P : Sylow 5 G), Subgroup.Normal ↑P) ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (hG : Fintype.card G = 200),\n  ∃ (P : Sylow 5 G), Subgroup.Normal ↑P ",
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 200 →\n    ∃ (P : Sylow 5 G), Subgroup.Normal ↑P ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 200 →\n    ∃ (H : Subgroup G), Subgroup.Normal H ∧ IsPGroup 5 { x // x ∈ H } ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 200 →\n    ∃ (P : Sylow 5 G), Subgroup.Normal ↑P ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 200 → ∃ (N : Sylow 5 G), Subgroup.Normal ↑N ",
      "∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] [hG : Fintype.card G = 200],\n  ∃ (P : Sylow 5 G), Subgroup.Normal ↑P "
    ]
  },
  {
    "docString": "Prove that if $|G|=1365$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → -1 ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Characteristic `≠ 2` and nontrivial implies that `-1 ≠ 1`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → -1 ≠ 1 :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- Prove that if $|G|=1365$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 1365 → ¬ IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hN : Nontrivial G], Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hN : Nontrivial G],\n  Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hN : Nontrivial G],\n  Fintype.card G = 1365 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 1365 → ¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Prove that if $|G|=132$ then $G$ is not simple.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion group is not torsion-free. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free group is not torsion. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial additive torsion group is not torsion-free.\"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G\",\n  \"isProp\": true,\n  \"docString\": \"A nontrivial torsion-free additive group is not torsion.\"},\n {\"theorem\": \"IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) }\",\n  \"isProp\": true,\n  \"docString\":\n  \"Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\\non its cycle type that its normal closure is all of $A_5$. \"},\n {\"theorem\":\n  \"∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g\",\n  \"isProp\": true,\n  \"docString\":\n  \"A nontrivial monoid is not torsion-free if any nontrivial element has finite order. \"}]\n",
    "prompt_cons": "/-- A nontrivial torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsion G → ¬Monoid.IsTorsionFree G :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A nontrivial torsion-free group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Monoid.IsTorsionFree G → ¬Monoid.IsTorsion G :=\n\n/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- A nontrivial additive torsion group is not torsion-free. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsion G → ¬AddMonoid.IsTorsionFree G :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- A nontrivial torsion-free additive group is not torsion. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] [hN : Nontrivial G], AddMonoid.IsTorsionFree G → ¬AddMonoid.IsTorsion G :=\n\n/-- Shows that $A_5$ is simple by taking an arbitrary non-identity element and showing by casework\non its cycle type that its normal closure is all of $A_5$. -/\ntheorem IsSimpleGroup { x // x ∈ alternatingGroup (Fin 5) } :=\n\n/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\ntheorem ∀ (G : Type u_1) [inst : Monoid G], ¬Monoid.IsTorsionFree G ↔ ∃ g, g ≠ 1 ∧ IsOfFinOrder g :=\n\n/-- Prove that if $|G|=132$ then $G$ is not simple. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G], Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [hN : Fintype G], Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G], Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hN : Nontrivial G],\n  Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G] [hN : Nontrivial G], Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 132 → ¬IsSimpleGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [hN : Nontrivial G], Fintype.card G = 132 → ¬IsSimpleGroup G "
    ]
  },
  {
    "docString": "Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.",
    "prompts": "[{\"theorem\":\n  \"∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\\n  5 ≤ Fintype.card α →\\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\\nat least 5 elements is the entire alternating group if it contains a 3-cycle. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  List.TFAE\\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\\n      Nonempty\\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\\ngroups. \"},\n {\"theorem\":\n  \"∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\\n$A_5$. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"Subgroup.normalClosure\\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 ∈ alternatingGroup (Fin 5)) }} =\\n  ⊤\",\n  \"isProp\": true,\n  \"docString\":\n  \"The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group.\\n\"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P)\",\n  \"isProp\": true,\n  \"docString\": \"Sylow subgroups are Hall subgroups. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s)\",\n  \"isProp\": true,\n  \"docString\": \"The normal closure of s is a normal subgroup. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"}]\n",
    "prompt_cons": "/-- A key lemma to prove $A_5$ is simple. Shows that any normal subgroup of an alternating group on\nat least 5 elements is the entire alternating group if it contains a 3-cycle. -/\ntheorem ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α],\n  5 ≤ Fintype.card α →\n    ∀ {f : Equiv.Perm α} (hf : Equiv.Perm.IsThreeCycle f),\n      Subgroup.normalClosure {{ val := f, property := (_ : f ∈ alternatingGroup α) }} = ⊤ :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- A finite group is nilpotent iff the normalizer condition holds, and iff all maximal groups are\nnormal and iff all sylow groups are normal and iff the group is the direct product of its sylow\ngroups. -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  List.TFAE\n    [Group.IsNilpotent G, NormalizerCondition G, ∀ (H : Subgroup G), IsCoatom H → Subgroup.Normal H,\n      ∀ (p : ℕ), Fact (Nat.Prime p) → ∀ (P : Sylow p G), Subgroup.Normal ↑P,\n      Nonempty\n        (((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G)] :=\n\n/-- Part of proving $A_5$ is simple. Shows that the square of any element of $A_5$ with a 3-cycle in\nits cycle decomposition is a 3-cycle, so the normal closure of the original element must be\n$A_5$. -/\ntheorem ∀ {g : Equiv.Perm (Fin 5)}, 3 ∈ Equiv.Perm.cycleType g → Equiv.Perm.IsThreeCycle (g * g) :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- The normal closure of $(04)(13)$ within $A_5$ is the whole group. This will be\nused to show that the normal closure of any permutation of cycle type $(2,2)$ is the whole group. -/\ntheorem Subgroup.normalClosure\n    {{ val := Equiv.swap 0 4 * Equiv.swap 1 3,\n        property := (_ : Equiv.swap 0 4 * Equiv.swap 1 3 ∈ alternatingGroup (Fin 5)) }} =\n  ⊤ :=\n\n/-- Sylow subgroups are Hall subgroups. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p : ℕ} [hp : Fact (Nat.Prime p)] (P : Sylow p G),\n  Nat.coprime (Fintype.card { x // x ∈ ↑P }) (Subgroup.index ↑P) :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- The normal closure of s is a normal subgroup. -/\ntheorem ∀ {G : Type u_1} {s : Set G} [inst : Group G], IsNormalSubgroup (Group.normalClosure s) :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 →\n    (∀ (P : Sylow 3 G), Subgroup.Normal ↑P) →\n      CommGroup G ",
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G], Fintype.card G = 105 →\n  (∃ H : Sylow 3 G, Subgroup.Normal ↑H) → CommGroup G ",
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P : Sylow 3 G), Subgroup.Normal ↑P) → CommGroup G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∃ (P : Sylow 3 G), Subgroup.Normal ↑P) → CommGroup G ",
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 →\n  (∃ (P : Sylow 3 G), Subgroup.Normal ↑P) →\n  CommGroup G ",
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 →\n    (∀ (P : Sylow 3 G), Subgroup.Normal ↑P) → Group.IsAbelian G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    ∀ (P : Sylow 3 G), Subgroup.Normal ↑P → IsAbelian G ",
      "∀ {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 →\n    (∀ (P : Sylow 3 G), Subgroup.Normal ↑P) →\n      IsCommutativeGroup G ",
      "forall {G : Type u_1} [inst : Group G] [inst_1 : Fintype G],\n  Fintype.card G = 105 → (∀ (N : Sylow 3 G), Subgroup.Normal ↑N) → IsCommutative G ",
      "∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  Fintype.card G = 105 →\n    (∀ (P : Sylow 3 G), Subgroup.Normal ↑P) → IsCommutativeGroup G "
    ]
  },
  {
    "docString": "Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`.  \"},\n {\"theorem\":\n  \"∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\\n  Finite (Sylow p { x // x ∈ H })\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\\n  p ^ m ∣ Fintype.card G →\\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ m`\\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\\n  p ^ (n + 1) ∣ Fintype.card G →\\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a subgroup of `G` of cardinality `p ^ n`,\\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\\nif `p ^ (n + 1)` divides the cardinality of `G` \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a group that satisfies the normalizer condition, every maximal subgroup is normal \"},\n {\"theorem\":\n  \"∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\\n  Fintype.card { x // x ∈ H } = p ^ n →\\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\\n      Fintype.card (G ⧸ H) [MOD p]\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\\nmod `p` to the index of `H`.  \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G],\\n  Group.nilpotencyClass { x // x ∈ H } ≤ Group.nilpotencyClass G\",\n  \"isProp\": true,\n  \"docString\":\n  \"A the nilpotency class of a subgroup is less or equal to the nilpotency class of the group \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y\",\n  \"isProp\": true,\n  \"docString\": \"Elements of disjoint, normal subgroups commute.\"},\n {\"theorem\":\n  \"∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. \"}]\n",
    "prompt_cons": "/-- If `H` is a subgroup of `G` of cardinality `p ^ n`, then the cardinality of the\nnormalizer of `H` is congruent mod `p ^ (n + 1)` to the cardinality of `G`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card { x // x ∈ Subgroup.normalizer H } ≡ Fintype.card G [MOD p ^ (n + 1)] :=\n\n/-- If `H` is a subgroup of `G`, then `Finite (Sylow p G)` implies `Finite (Sylow p H)`. -/\ntheorem ∀ {p : ℕ} {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Finite (Sylow p G)],\n  Finite (Sylow p { x // x ∈ H }) :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ m`\nif `n ≤ m` and `p ^ m` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] (p : ℕ) {n m : ℕ} [_hp : Fact (Nat.Prime p)],\n  p ^ m ∣ Fintype.card G →\n    ∀ (H : Subgroup G), Fintype.card { x // x ∈ H } = p ^ n → n ≤ m → ∃ K, Fintype.card { x // x ∈ K } = p ^ m ∧ H ≤ K :=\n\n/-- If `H` is a subgroup of `G` of cardinality `p ^ n`,\nthen `H` is contained in a subgroup of cardinality `p ^ (n + 1)`\nif `p ^ (n + 1)` divides the cardinality of `G` -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)],\n  p ^ (n + 1) ∣ Fintype.card G →\n    ∀ {H : Subgroup G}, Fintype.card { x // x ∈ H } = p ^ n → ∃ K, Fintype.card { x // x ∈ K } = p ^ (n + 1) ∧ H ≤ K :=\n\n/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G), NormalizerCondition G → IsCoatom H → Subgroup.Normal H :=\n\n/-- If `H` is a `p`-subgroup of `G`, then the index of `H` inside its normalizer is congruent\nmod `p` to the index of `H`. -/\ntheorem ∀ {G : Type u} [inst : Group G] [inst_1 : Fintype G] {p n : ℕ} [hp : Fact (Nat.Prime p)] {H : Subgroup G},\n  Fintype.card { x // x ∈ H } = p ^ n →\n    Fintype.card ({ x // x ∈ Subgroup.normalizer H } ⧸ Subgroup.comap (Subgroup.subtype (Subgroup.normalizer H)) H) ≡\n      Fintype.card (G ⧸ H) [MOD p] :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H₁ H₂ : Subgroup G),\n  Subgroup.Normal H₁ → Subgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → Commute x y :=\n\n/-- A the nilpotency class of a subgroup is less or equal to the nilpotency class of the group -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G],\n  Group.nilpotencyClass { x // x ∈ H } ≤ Group.nilpotencyClass G :=\n\n/-- Elements of disjoint, normal subgroups commute. -/\ntheorem ∀ {G : Type u_1} [inst : AddGroup G] (H₁ H₂ : AddSubgroup G),\n  AddSubgroup.Normal H₁ → AddSubgroup.Normal H₂ → Disjoint H₁ H₂ → ∀ (x y : G), x ∈ H₁ → y ∈ H₂ → AddCommute x y :=\n\n/-- **Lagrange's Theorem**: The order of a subgroup divides the order of its ambient group. -/\ntheorem ∀ {α : Type u_1} [inst : Group α] [inst_1 : Fintype α] (s : Subgroup α) [inst_2 : Fintype { x // x ∈ s }],\n  Fintype.card { x // x ∈ s } ∣ Fintype.card α :=\n\n/-- Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$. -/\ntheorem",
    "choices": [
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.commute_set H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.comap (MulEquiv.toMonoidHom (commutator G)) H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.commute G H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.comap (MulAut.conj : G →* MulAut G) H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.commute.central H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Subgroup.Normal H ↔ Subgroup.commuteSubset G H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.commute G H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.comap (Subgroup.subtype H) (Subgroup.closure {g : G | ∃ (x : G) (h : x ∈ H), g = x⁻¹ * x}) ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] {H : Subgroup G},\n  Subgroup.Normal H ↔ Subgroup.commute_set H ≤ H ",
      "∀ {G : Type u_1} [inst : Group G] (H : Subgroup G),\n  Subgroup.Normal H ↔ Subgroup.comap (Subgroup.subtype H) (Subgroup.derivedSeries G 1) ≤ H "
    ]
  },
  {
    "docString": "Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"A product of ideals in an integral domain is zero if and only if one of the terms is zero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\\n  Algebra.IsIntegral R A → ∀ (x : B), IsIntegral A x → IsIntegral R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"If A is an R-algebra all of whose elements are integral over R,\\nand x is an element of an A-algebra that is integral over A, then x is integral over R.\"},\n {\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\\n  Polynomial.Monic g₁ →\\n    Polynomial.Monic g₂ →\\n      IsCoprime g₁ g₂ →\\n        ∃ q r₁ r₂,\\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\\ndeg(r₂) < deg(g₂).\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type u_2) [inst_2 : Field K] [inst_3 : Algebra R K]\\n  [inst_4 : IsFractionRing R K], IsIntegrallyClosed R ↔ IsIntegralClosure R R K\",\n  \"isProp\": true,\n  \"docString\":\n  \"`R` is integrally closed iff it is the integral closure of itself in its field of fractions. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → Set.InjOn Int.cast {0, 1, -1}\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\\nthat is nontrivial and of characteristic not `2`, then they are equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. \"},\n {\"theorem\":\n  \"∀ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : Rˣ), u⁻¹ = u ↔ u = 1 ∨ u = -1\",\n  \"isProp\": true,\n  \"docString\":\n  \"In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\\none's additive inverse. \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {M : Type u_1}\\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M]\\n  [inst_7 : NoZeroSMulDivisors A M] (N : Submodule R M),\\n  N ≠ ⊥ → Submodule.FG N → ∀ (x : A), (∀ (n : M), n ∈ N → x • n ∈ N) → IsIntegral R x\",\n  \"isProp\": true,\n  \"docString\":\n  \"Suppose `A` is an `R`-algebra, `M` is an `A`-module such that `a • m ≠ 0` for all non-zero `a`\\nand `m`. If `x : A` fixes a nontrivial f.g. `R`-submodule `N` of `M`, then `x` is `R`-integral. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\\n  (φ : R →+* S) (f : Polynomial R), Polynomial.Monic f → Irreducible (Polynomial.map φ f) → Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"A polynomial over an integral domain `R` is irreducible if it is monic and\\nirreducible after mapping into an integral domain `S`.\\n\\nA special case of this lemma is that a polynomial over `ℤ` is irreducible if\\nit is monic and irreducible over `ℤ/pℤ` for some prime `p`.\\n\"}]\n",
    "prompt_cons": "/-- If `P` is a prime ideal of `R`, then `R[x]/(P)` is an integral domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] {P : Ideal R}, Ideal.IsPrime P → IsDomain (Polynomial R ⧸ Ideal.map Polynomial.C P) :=\n\n/-- A product of ideals in an integral domain is zero if and only if one of the terms is zero. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {s : Multiset (Ideal R)},\n  Multiset.prod s = ⊥ ↔ ∃ I, I ∈ s ∧ I = ⊥ :=\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand x is an element of an A-algebra that is integral over A, then x is integral over R. -/\ntheorem ∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : CommRing B]\n  [inst_3 : Algebra A B] [inst_4 : Algebra R B] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R A B],\n  Algebra.IsIntegral R A → ∀ (x : B), IsIntegral A x → IsIntegral R x :=\n\n/-- Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\ndeg(r₂) < deg(g₂). -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\n  Polynomial.Monic g₁ →\n    Polynomial.Monic g₂ →\n      IsCoprime g₁ g₂ →\n        ∃ q r₁ r₂,\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂ :=\n\n/-- `R` is integrally closed iff it is the integral closure of itself in its field of fractions. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type u_2) [inst_2 : Field K] [inst_3 : Algebra R K]\n  [inst_4 : IsFractionRing R K], IsIntegrallyClosed R ↔ IsIntegralClosure R R K :=\n\n/-- If two integers from `{0, 1, -1}` result in equal elements in a ring `R`\nthat is nontrivial and of characteristic not `2`, then they are equal. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocRing R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → Set.InjOn Int.cast {0, 1, -1} :=\n\n/-- If `P` is a prime ideal of `R`, then `P.R[x]` is a prime ideal of `R[x]`. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (P : Ideal R), Ideal.IsPrime (Ideal.map Polynomial.C P) ↔ Ideal.IsPrime P :=\n\n/-- In the unit group of an integral domain, a unit is its own inverse iff the unit is one or\none's additive inverse. -/\ntheorem ∀ {R : Type x} [inst : Ring R] [inst_1 : NoZeroDivisors R] (u : Rˣ), u⁻¹ = u ↔ u = 1 ∨ u = -1 :=\n\n/-- Suppose `A` is an `R`-algebra, `M` is an `A`-module such that `a • m ≠ 0` for all non-zero `a`\nand `m`. If `x : A` fixes a nontrivial f.g. `R`-submodule `N` of `M`, then `x` is `R`-integral. -/\ntheorem ∀ {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {M : Type u_1}\n  [inst_3 : AddCommGroup M] [inst_4 : Module R M] [inst_5 : Module A M] [inst_6 : IsScalarTower R A M]\n  [inst_7 : NoZeroSMulDivisors A M] (N : Submodule R M),\n  N ≠ ⊥ → Submodule.FG N → ∀ (x : A), (∀ (n : M), n ∈ N → x • n ∈ N) → IsIntegral R x :=\n\n/-- A polynomial over an integral domain `R` is irreducible if it is monic and\nirreducible after mapping into an integral domain `S`.\n\nA special case of this lemma is that a polynomial over `ℤ` is irreducible if\nit is monic and irreducible over `ℤ/pℤ` for some prime `p`. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : CommRing S] [inst_3 : IsDomain S]\n  (φ : R →+* S) (f : Polynomial R), Polynomial.Monic f → Irreducible (Polynomial.map φ f) → Irreducible f :=\n\n/-- Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x^2 = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x * x = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x * x = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x^2 = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x * x = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x * x = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x ^ 2 = 1 → x = 1 ∨ x = -1 ",
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] (x : R), x * x = 1 → x = 1 ∨ x = -1 "
    ]
  },
  {
    "docString": "A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\\nthen every `a : R` is a square. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring is a `ℚ`-algebra iff it has equal characteristic zero. \"},\n {\"theorem\": \"∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a\",\n  \"isProp\": true,\n  \"docString\": \"Multiplication in a boolean ring is idempotent. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y\",\n  \"isProp\": true,\n  \"docString\": \"A ring isomorphism preserves multiplication. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I\",\n  \"isProp\": true,\n  \"docString\":\n  \"A ring `R` that is `I`-adically complete is Henselian at `I`. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b\",\n  \"isProp\": true,\n  \"docString\":\n  \"in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. \"},\n {\"theorem\":\n  \"∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α → β}, IsRingHom f → IsSemiringHom f\",\n  \"isProp\": true,\n  \"docString\": \"A ring homomorphism is also a semiring homomorphism. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R],\\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"If all prime ideals in a commutative ring are principal, so are all other ideals. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\\n  {χ : MulChar R R'}, MulChar.IsQuadratic χ → ∀ (f : R' →+* R''), MulChar.IsQuadratic (MulChar.ringHomComp χ f)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Composition with a ring homomorphism preserves the property of being a quadratic character. \"}]\n",
    "prompt_cons": "/-- If `ringChar R = 2`, where `R` is a finite reduced commutative ring,\nthen every `a : R` is a square. -/\ntheorem ∀ {R : Type u_1} [inst : Finite R] [inst : CommRing R] [inst_1 : IsReduced R] [inst_2 : CharP R 2] (a : R), IsSquare a :=\n\n/-- A ring is a `ℚ`-algebra iff it has equal characteristic zero. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R], Nonempty (Algebra ℚ R) ↔ ∀ (I : Ideal R), I ≠ ⊤ → CharZero (R ⧸ I) :=\n\n/-- Multiplication in a boolean ring is idempotent. -/\ntheorem ∀ {α : Type u_1} [self : BooleanRing α] (a : α), a * a = a :=\n\n/-- A ring isomorphism preserves multiplication. -/\ntheorem ∀ {R : Type u_1} {S : Type u_2} [inst : Mul R] [inst_1 : Mul S] [inst_2 : Add R] [inst_3 : Add S] (e : R ≃+* S)\n  (x y : R), ↑e (x * y) = ↑e x * ↑e y :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- A ring `R` that is `I`-adically complete is Henselian at `I`. -/\ntheorem ∀ (R : Type u_1) [inst : CommRing R] (I : Ideal R) [inst_1 : IsAdicComplete I R], HenselianRing R I :=\n\n/-- in a local ring `R`, if `a + b = 1`, then either `a` is a unit or `b` is a unit. In another\nword, for every `a : R`, either `a` is a unit or `1 - a` is a unit. -/\ntheorem ∀ {R : Type u} [inst : Semiring R] [self : LocalRing R] {a b : R}, a + b = 1 → IsUnit a ∨ IsUnit b :=\n\n/-- A ring homomorphism is also a semiring homomorphism. -/\ntheorem ∀ {α : Type u} {β : Type v} [inst : Ring α] [inst_1 : Ring β] {f : α → β}, IsRingHom f → IsSemiringHom f :=\n\n/-- If all prime ideals in a commutative ring are principal, so are all other ideals. -/\ntheorem ∀ {R : Type u} [inst : CommRing R],\n  (∀ (P : Ideal R), Ideal.IsPrime P → Submodule.IsPrincipal P) → IsPrincipalIdealRing R :=\n\n/-- Composition with a ring homomorphism preserves the property of being a quadratic character. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] {R'' : Type w} [inst_2 : CommRing R'']\n  {χ : MulChar R R'}, MulChar.IsQuadratic χ → ∀ (f : R' →+* R''), MulChar.IsQuadratic (MulChar.ringHomComp χ f) :=\n\n/-- A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative. -/\ntheorem",
    "choices": [
      " ∀ {R : Type u_1} [inst : Ring R], (∀ (a : R), a * a = a) → IsCommutative R Mul ",
      "∀ {α : Type u_1} [self : BooleanRing α], IsCommutative α ",
      "∀ {R : Type u_1} [inst : Ring R] [self : ∀ (a : R), a * a = a], IsCommutative R (*) ",
      "∀ {R : Type u} [inst : Ring R] [inst_1 : BooleanRing R], IsCommutative R Mul ",
      "∀ {R : Type u_1} [self : BooleanRing R], IsCommutative R add ",
      "∀ {R : Type u_1} [inst : BooleanRing R], CommRing R ",
      "∀ {R : Type u_1} [inst : BooleanRing R], IsCommutative R (*) ",
      "∀ {R : Type u_1} [inst : Semiring R] (h : ∀ (a : R), a*a = a), ∀ (a b : R), a * b = b * a ",
      "∀ {R : Type u_1} [self : BooleanRing R], IsCommutative R (*) ",
      "∀ {R : Type u_1} [self : BooleanRing R], IsCommutative R "
    ]
  },
  {
    "docString": "Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G\",\n  \"isProp\": true,\n  \"docString\": \"The center of a group acts commutatively on that group. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of fixed points of the conjugation action of `G` on itself is the center of `G`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\\n  AddSubgroup.Normal H → ∀ (n : A), n ∈ H → ∀ (g : A), g + n + -g ∈ H\",\n  \"isProp\": true,\n  \"docString\": \"`N` is closed under additive conjugation \"},\n {\"theorem\":\n  \"∀ (α : Type u) (β : Type v) [inst : AddGroup α] [inst_1 : AddAction α β] [inst_2 : Fintype α]\\n  [inst_3 : (a : α) → Fintype ↑(AddAction.fixedBy α β a)] [inst_4 : Fintype (Quotient (AddAction.orbitRel α β))],\\n  (Finset.sum Finset.univ fun a => Fintype.card ↑(AddAction.fixedBy α β a)) =\\n    Fintype.card (Quotient (AddAction.orbitRel α β)) * Fintype.card α\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\\nthe average number of elements fixed by each `g ∈ G` is the number of orbits. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\\n  Group.nilpotencyClass G = Group.nilpotencyClass (G ⧸ Subgroup.center G) + 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The nilpotency class of a non-trivial group is one more than its quotient by the center \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\\n  (Finset.sum Finset.univ fun a => ↑1 a) = ↑(Fintype.card Rˣ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The sum over all values of the trivial multiplicative character on a finite ring is\\nthe cardinality of its unit group. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R\",\n  \"isProp\": true,\n  \"docString\":\n  \"Every nonarchimedean ring is naturally a nonarchimedean additive group. \"},\n {\"theorem\":\n  \"∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological additive group `G` with normal additive subgroup\\n`N`, `0 : G ⧸ N` has a countable neighborhood basis.\"},\n {\"theorem\":\n  \"∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a first countable topological group `G` with normal subgroup `N`, `1 : G ⧸ N` has a\\ncountable neighborhood basis. \"},\n {\"theorem\":\n  \"∀ {T : ℝ} [hT : Fact (0 < T)] (I : Set (AddCircle T)) (u x : AddCircle T),\\n  IsOfFinAddOrder u →\\n    I =ᶠ[MeasureTheory.Measure.ae MeasureTheory.volume] Metric.ball x (T / (2 * ↑(addOrderOf u))) →\\n      MeasureTheory.IsAddFundamentalDomain { x // x ∈ AddSubgroup.zmultiples u } I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `G` be the subgroup of `AddCircle T` generated by a point `u` of finite order `n : ℕ`. Then\\nany set `I` that is almost equal to a ball of radius `T / 2n` is a fundamental domain for the action\\nof `G` on `AddCircle T` by left addition. \"}]\n",
    "prompt_cons": "/-- The center of a group acts commutatively on that group. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], SMulCommClass G { x // x ∈ Subgroup.center G } G :=\n\n/-- The set of fixed points of the conjugation action of `G` on itself is the center of `G`. -/\ntheorem ∀ {G : Type u_1} [inst : Group G], MulAction.fixedPoints (ConjAct G) G = ↑(Subgroup.center G) :=\n\n/-- `N` is closed under additive conjugation -/\ntheorem ∀ {A : Type u_1} [inst : AddGroup A] {H : AddSubgroup A},\n  AddSubgroup.Normal H → ∀ (n : A), n ∈ H → ∀ (g : A), g + n + -g ∈ H :=\n\n/-- **Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\nthe average number of elements fixed by each `g ∈ G` is the number of orbits. -/\ntheorem ∀ (α : Type u) (β : Type v) [inst : AddGroup α] [inst_1 : AddAction α β] [inst_2 : Fintype α]\n  [inst_3 : (a : α) → Fintype ↑(AddAction.fixedBy α β a)] [inst_4 : Fintype (Quotient (AddAction.orbitRel α β))],\n  (Finset.sum Finset.univ fun a => Fintype.card ↑(AddAction.fixedBy α β a)) =\n    Fintype.card (Quotient (AddAction.orbitRel α β)) * Fintype.card α :=\n\n/-- The nilpotency class of a non-trivial group is one more than its quotient by the center -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [hH : Group.IsNilpotent G] [inst_1 : Nontrivial G],\n  Group.nilpotencyClass G = Group.nilpotencyClass (G ⧸ Subgroup.center G) + 1 :=\n\n/-- The sum over all values of the trivial multiplicative character on a finite ring is\nthe cardinality of its unit group. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] {R' : Type v} [inst_1 : CommRing R'] [inst_2 : Fintype R] [inst_3 : DecidableEq R],\n  (Finset.sum Finset.univ fun a => ↑1 a) = ↑(Fintype.card Rˣ) :=\n\n/-- Every nonarchimedean ring is naturally a nonarchimedean additive group. -/\ntheorem ∀ (R : Type u_1) [inst : Ring R] [inst_1 : TopologicalSpace R] [t : NonarchimedeanRing R], NonarchimedeanAddGroup R :=\n\n/-- In a first countable topological additive group `G` with normal additive subgroup\n`N`, `0 : G ⧸ N` has a countable neighborhood basis. -/\ntheorem ∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] (N : AddSubgroup G)\n  (n : AddSubgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 0) :=\n\n/-- In a first countable topological group `G` with normal subgroup `N`, `1 : G ⧸ N` has a\ncountable neighborhood basis. -/\ntheorem ∀ (G : Type w) [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (N : Subgroup G)\n  (n : Subgroup.Normal N) [inst_3 : TopologicalSpace.FirstCountableTopology G], Filter.IsCountablyGenerated (nhds 1) :=\n\n/-- Let `G` be the subgroup of `AddCircle T` generated by a point `u` of finite order `n : ℕ`. Then\nany set `I` that is almost equal to a ball of radius `T / 2n` is a fundamental domain for the action\nof `G` on `AddCircle T` by left addition. -/\ntheorem ∀ {T : ℝ} [hT : Fact (0 < T)] (I : Set (AddCircle T)) (u x : AddCircle T),\n  IsOfFinAddOrder u →\n    I =ᶠ[MeasureTheory.Measure.ae MeasureTheory.volume] Metric.ball x (T / (2 * ↑(addOrderOf u))) →\n      MeasureTheory.IsAddFundamentalDomain { x // x ∈ AddSubgroup.zmultiples u } I :=\n\n/-- Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$. -/\ntheorem",
    "choices": [
      "∀ {R : Type u_1} [inst : Semiring R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "∀ {R : Type u_1} [inst : CommRing R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G],\n  (Finset.sum Finset.univ id) ∈ Subgroup.center (R ⧸ G) ",
      "∀ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "∀ {R : Type u} {G : Type v} [inst : CommRing R] [inst_1 : Group G] [inst_2 : Fintype G],\n  let N : R[G] ",
      "∀ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G], \n  let N ",
      "∀ {R : Type u_1} {G : Type u_2} [inst : CommRing R] [inst_1 : Group G] [inst_2 : Fintype G],\n  let N ",
      "∀ {R : Type u_1} [inst : CommRing R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G] [inst_3 : DecidableEq G],\n  (∑ a in Finset.univ, (a : R[G])) ∈ Subgroup.center R[G] ",
      "∀ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G] [inst_3 : MulSemiringAction G R],\n  let N ",
      "∀ {R : Type u_1} [inst : CommRing R] {G : Type u_2} [inst_1 : Group G] [inst_2 : Fintype G] [inst_3 : DecidableEq G],\n  ∀ (g : G), (Finset.sum Finset.univ fun a => g * a) = (Finset.sum Finset.univ id) * g ",
      "∀ {R : Type u} [inst : CommRing R] {G : Type v} [inst_1 : Group G] [inst_2 : Fintype G] [inst_3 : DecidableEq G],\n  let N "
    ]
  },
  {
    "docString": "An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\\n  Group.IsNilpotent (G ⧸ H)\",\n  \"isProp\": true,\n  \"docString\": \"A quotient of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"A p-group is nilpotent \"},\n {\"theorem\":\n  \"∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)] [inst_1 : Finite η]\\n  [inst_2 : ∀ (i : η), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : η) → Gs i)\",\n  \"isProp\": true,\n  \"docString\": \"n-ary products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G\",\n  \"isProp\": true,\n  \"docString\": \"A nilpotent subgroup is solvable \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\\n  IsNilpotent I →\\n    ∀ {P : ⦃S : Type u_1⦄ → [inst : CommRing S] → Ideal S → Prop},\\n      (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I : Ideal S), I ^ 2 = ⊥ → P I) →\\n        (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I J : Ideal S),\\n            I ≤ J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J) →\\n          P I\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\\n`P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. \"},\n {\"theorem\": \"∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\": \"Abelian groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x ∈ H }\",\n  \"isProp\": true,\n  \"docString\": \"A subgroup of a nilpotent group is nilpotent \"},\n {\"theorem\":\n  \"∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂)\",\n  \"isProp\": true,\n  \"docString\": \"Products of nilpotent groups are nilpotent \"},\n {\"theorem\":\n  \"∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] {I : LieIdeal R L},\\n  I ≤ LieAlgebra.center R L → LieAlgebra.IsNilpotent R (L ⧸ I) → LieAlgebra.IsNilpotent R L\",\n  \"isProp\": true,\n  \"docString\": \"A central extension of nilpotent Lie algebras is nilpotent. \"},\n {\"theorem\":\n  \"∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\\n    Group.IsNilpotent G\",\n  \"isProp\": true,\n  \"docString\":\n  \"If a finite group is the direct product of its Sylow groups, it is nilpotent \"}]\n",
    "prompt_cons": "/-- A quotient of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [inst_1 : Subgroup.Normal H] [_h : Group.IsNilpotent G],\n  Group.IsNilpotent (G ⧸ H) :=\n\n/-- A p-group is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Finite G] {p : ℕ} [hp : Fact (Nat.Prime p)], IsPGroup p G → Group.IsNilpotent G :=\n\n/-- n-ary products of nilpotent groups are nilpotent -/\ntheorem ∀ {η : Type u_1} {Gs : η → Type u_2} [inst : (i : η) → Group (Gs i)] [inst_1 : Finite η]\n  [inst_2 : ∀ (i : η), Group.IsNilpotent (Gs i)], Group.IsNilpotent ((i : η) → Gs i) :=\n\n/-- A nilpotent subgroup is solvable -/\ntheorem ∀ {G : Type u_1} [inst : Group G] [h : Group.IsNilpotent G], IsSolvable G :=\n\n/-- Let `P` be a property on ideals. If `P` holds for square-zero ideals, and if\n`P I → P (J ⧸ I) → P J`, then `P` holds for all nilpotent ideals. -/\ntheorem ∀ {R : Type u_2} {S : Type u_1} [inst : CommSemiring R] [inst_1 : CommRing S] [inst : Algebra R S] (I : Ideal S),\n  IsNilpotent I →\n    ∀ {P : ⦃S : Type u_1⦄ → [inst : CommRing S] → Ideal S → Prop},\n      (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I : Ideal S), I ^ 2 = ⊥ → P I) →\n        (∀ ⦃S : Type u_1⦄ [inst : CommRing S] (I J : Ideal S),\n            I ≤ J → P I → P (Ideal.map (Ideal.Quotient.mk I) J) → P J) →\n          P I :=\n\n/-- Abelian groups are nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : CommGroup G], Group.IsNilpotent G :=\n\n/-- A subgroup of a nilpotent group is nilpotent -/\ntheorem ∀ {G : Type u_1} [inst : Group G] (H : Subgroup G) [hG : Group.IsNilpotent G], Group.IsNilpotent { x // x ∈ H } :=\n\n/-- Products of nilpotent groups are nilpotent -/\ntheorem ∀ {G₁ : Type u_1} {G₂ : Type u_2} [inst : Group G₁] [inst_1 : Group G₂] [inst_2 : Group.IsNilpotent G₁]\n  [inst_3 : Group.IsNilpotent G₂], Group.IsNilpotent (G₁ × G₂) :=\n\n/-- A central extension of nilpotent Lie algebras is nilpotent. -/\ntheorem ∀ {R : Type u} {L : Type v} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] {I : LieIdeal R L},\n  I ≤ LieAlgebra.center R L → LieAlgebra.IsNilpotent R (L ⧸ I) → LieAlgebra.IsNilpotent R L :=\n\n/-- If a finite group is the direct product of its Sylow groups, it is nilpotent -/\ntheorem ∀ {G : Type u_1} [hG : Group G] [inst : Fintype G],\n  ((p : { x // x ∈ (Nat.factorization (Fintype.card G)).support }) → (P : Sylow (↑p) G) → { x // x ∈ ↑P }) ≃* G →\n    Group.IsNilpotent G :=\n\n/-- An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$. -/\ntheorem",
    "choices": [
      "∀ {m : ℕ} {p : ℕ} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {p} : Ideal (Zmod (p ^ m))) ",
      "∀ {m : ℕ} {p : ℕ} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {p} : Ideal (Zmod (p ^ m))) ",
      " ∀ {m : ℕ} {p : ℕ} [hp : Fact (Nat.Prime p)], IsNilpotent (Ideal.span (singleton (p : ℤ / p^m))) ",
      "∀ {p m : ℕ} [hp : Fact (Nat.Prime p)] [hpm : Fact (0 < m)],\n  IsNilpotent (Ideal.span {p} : Ideal (Zmod (p ^ m))) ",
      "∀ {m p : ℕ} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {p} : Ideal (ℤ / p^m)) ",
      "∀ {m : ℕ} {p : ℕ} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span {p} : Ideal (Zmod (p ^ m))) ",
      "∀ {n m : ℕ} {p : ℕ} [hp : Fact (Nat.Prime p)],\n  Ideal.IsNilpotent (Ideal.span ({(p : ℕ)} : Set (Zmod (p ^ m)))) ",
      "∀ {p m : ℕ} [hp : Fact (Nat.Prime p)] [_inst : Fact (0 < m)],\n  IsNilpotent (Ideal.span {p} : Ideal (Zmod (p ^ m))) ",
      "∀ {m : ℕ} {p : ℕ} [hp : Fact (Nat.Prime p)], Ideal.IsNilpotent (Ideal.span (singleton (p : ℕ)) : Ideal (Zmod (p ^ m))) ",
      "∀ {p m : ℕ} [hp : Fact (Nat.Prime p)] (hpm : p ^ m ≠ 0), Ideal.IsNilpotent (Ideal.span {coe p} : Ideal (Zmod (p ^ m))) "
    ]
  },
  {
    "docString": "Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$.",
    "prompts": "[{\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n]\",\n  \"isProp\": true,\n  \"docString\": \"Infinitely many natural numbers are equal to `d` mod `n`. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : ℕ) {w x : M}, ↑c w x → ↑c (w ^ n) (x ^ n)\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicative congruence relations preserve natural powers. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a n = 1`. \"},\n {\"theorem\": \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) = 1`, then `gcd a m = 1`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b\",\n  \"isProp\": true,\n  \"docString\":\n  \"If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\\nthen there is a `b`-th primitive root of unity in `R`. \"},\n {\"theorem\":\n  \"∀ {n d : ℕ}, d ∣ n → Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n))\",\n  \"isProp\": true,\n  \"docString\":\n  \"For `d ∣ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n'\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. \"},\n {\"theorem\":\n  \"∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. \"},\n {\"theorem\":\n  \"∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. \"}]\n",
    "prompt_cons": "/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (d : ℕ), ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c :=\n\n/-- Multiplicative congruence relations preserve natural powers. -/\ntheorem ∀ {M : Type u_1} [inst : Monoid M] (c : Con M) (n : ℕ) {w x : M}, ↑c w x → ↑c (w ^ n) (x ^ n) :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑n = 1 :=\n\n/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) = 1 → Int.gcd a ↑m = 1 :=\n\n/-- If there is an `n`-th primitive root of unity in `R` and `b` divides `n`,\nthen there is a `b`-th primitive root of unity in `R`. -/\ntheorem ∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M} {n a b : ℕ},\n  0 < n → IsPrimitiveRoot ζ n → n = a * b → IsPrimitiveRoot (ζ ^ a) b :=\n\n/-- For `d ∣ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` -/\ntheorem ∀ {n d : ℕ}, d ∣ n → Nat.totient (n / d) = Finset.card (Finset.filter (fun k => Nat.gcd n k = d) (Finset.range n)) :=\n\n/-- If `n` is a nonzero natural number and `p ≠ 1`, then there are natural numbers `e`\nand `n'` such that `n'` is not divisible by `p` and `n = p^e * n'`. -/\ntheorem ∀ {n : ℕ}, n ≠ 0 → ∀ (p : ℕ), p ≠ 1 → ∃ e n', ¬p ∣ n' ∧ n = p ^ e * n' :=\n\n/-- If `gcd a (m * n) ≠ 1`, then `gcd a m ≠ 1` or `gcd a n ≠ 1`. -/\ntheorem ∀ {a : ℤ} {m n : ℕ}, Int.gcd a (↑m * ↑n) ≠ 1 ↔ Int.gcd a ↑m ≠ 1 ∨ Int.gcd a ↑n ≠ 1 :=\n\n/-- **Fermat's Little Theorem**: for every unit `a` of `ZMod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (a : (ZMod p)ˣ), a ^ (p - 1) = 1 :=\n\n/-- Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$. -/\ntheorem",
    "choices": [
      "∀ (N M d : ℕ), 0 < N → Int.gcd M (↑N) = 1 → Int.gcd d (↑(Nat.totient N)) = 1 →\n  ∀ M₁, M₁ ≡ M ^ d [MOD N] → (∃ d', d * d' ≡ 1 [MOD Nat.totient N] ∧ M ≡ M₁ ^ d' [MOD N]) ",
      "∀ {N : ℕ}, N > 0 → ∀ {M : ℤ}, Int.gcd M ↑N = 1 → ∀ {d : ℕ}, Int.gcd d (Nat.totient N) = 1 →\n  ∀ {M₁ : ℤ}, M₁ ≡ (M ^ d) [ZMOD ↑N] → ∃ d' : ℕ, d * d' ≡ 1 [ZMOD Nat.totient N] ∧ M ≡ (M₁ ^ d') [ZMOD ↑N] ",
      "∀ {N : ℕ}, N > 0 → ∀ {M d : ℤ}, Int.gcd M ↑N = 1 → Int.gcd d (Nat.totient N) = 1 →\n  ∀ {M₁ : ℤ}, M₁ ≡ (M ^ d) [ZMOD N] →\n  ∃ d' : ℤ, d * d' ≡ 1 [ZMOD (Nat.totient N)] ∧ M ≡ (M₁ ^ d') [ZMOD N] ",
      "/-- Infinitely many natural numbers are equal to `d` mod `n`. -/\ntheorem nat_inf_mod (n : ℕ) (hn : n ≠ 0) (d : ℕ) : ∃ᶠ (m : ℕ) in Filter.atTop, m ≡ d [MOD n] ",
      "forall {N : ℕ}, N > 0 →\n  ∀ {M : ℤ}, Int.gcd M ↑N = 1 →\n  ∀ {d : ℕ}, Int.gcd d (Nat.totient N) = 1 →\n    ∀ {M1 : ℤ}, M1 ≡ (M ^ d) [ZMOD ↑N] →\n      ∀ {d' : ℕ}, d * d' ≡ 1 [ZMOD Nat.totient N] →\n        M ≡ (M1 ^ d') [ZMOD ↑N] ",
      "∀ {N : ℕ}, N > 0 → ∀ {M : ℤ}, Int.gcd M ↑N = 1 → ∀ {d : ℕ}, Int.gcd d (Nat.totient N) = 1 →\n  ∀ {M1 : ℤ}, M1 ≡ (M ^ d) [MOD N] → ∃ d' : ℕ, d * d' ≡ 1 [MOD Nat.totient N] ∧ M ≡ (M1 ^ d') [MOD N] ",
      "∀ {N : ℕ}, 0 < N → ∀ {M d : ℤ}, Int.gcd M ↑N = 1 → Int.gcd d (Int.ofNat (Nat.totient N)) = 1 → ∀ {M₁ : ℤ}, M₁ ≡ M ^ d [ZMOD ↑N] → ∃ d' : ℤ, d * d' ≡ 1 [ZMOD (Int.ofNat (Nat.totient N))] ∧ M ≡ M₁ ^ d' [ZMOD ↑N] ",
      "∀ {N : ℕ}, N > 0 → ∀ {M : ℤ}, Int.gcd M ↑N = 1 → ∀ {d : ℕ}, Int.gcd d (Euler.phi N) = 1 →\n  ∀ {M₁ : ℤ}, M₁ ≡ M^d [ZMOD N] → ∃ d' : ℕ, (d * d') % Euler.phi N = 1 ∧ M ≡ M₁^d' [ZMOD N] ",
      "∀ {N : ℕ}, 0 < N → ∀ {M : ℤ}, Int.gcd M ↑N = 1 → ∀ {d : ℕ}, Int.gcd d (Nat.totient N) = 1 →\n  ∀ (M1 : ℕ), M1 ≡ (M ^ d) [MOD N] → ∃ d' : ℕ, d * d' ≡ 1 [MOD Nat.totient N] ∧ M ≡ (↑M1 ^ d') [MOD N] ",
      "∀ {N : ℕ}, N > 0 → ∀ {M : ℤ}, Int.gcd M ↑N = 1 → ∀ {d : ℕ}, Int.gcd d (Nat.totient N) = 1 →\n  ∀ {M1 : ℤ}, M1 ≡ M ^ d [MOD N] → ∃ d', d * d' ≡ 1 [MOD Nat.totient N] ∧ M ≡ M1 ^ d' [MOD N] "
    ]
  },
  {
    "docString": "Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.",
    "prompts": "[{\"theorem\":\n  \"∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"The set of natural numbers that are sums of two squares is closed under multiplication. \"},\n {\"theorem\": \"∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. \"},\n {\"theorem\":\n  \"∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\": \"The sum of two squares is zero iff both elements are zero. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same multiples. \"},\n {\"theorem\": \"∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n\",\n  \"isProp\": true,\n  \"docString\":\n  \"Two natural numbers are equal if and only if they have the same divisors. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"Pythagorean theorem, if-and-if vector inner product form using square roots. \"},\n {\"theorem\":\n  \"∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c\",\n  \"isProp\": true,\n  \"docString\":\n  \"If two integers are congruent to a sufficiently large modulus,\\nthey are equal. \"},\n {\"theorem\":\n  \"∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\\n      (Ideal.quotientMap (Ideal.comap g' I) f\\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\\n      (Ideal.quotientMap (Ideal.comap f' I) g leq)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Commutativity of a square is preserved when taking quotients by an ideal. \"},\n {\"theorem\":\n  \"∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\\nnumbers `a` and `b` such that `-1` is a square modulo `b`. \"},\n {\"theorem\":\n  \"∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1)\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the natural number `n` is a sum of two squares of coprime natural numbers, then\\n`-1` is a square modulo `n`. \"}]\n",
    "prompt_cons": "/-- The set of natural numbers that are sums of two squares is closed under multiplication. -/\ntheorem ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 :=\n\n/-- If `-1` is a square modulo the natural number `n`, then `n` is a sum of two squares. -/\ntheorem ∀ {n : ℕ}, IsSquare (-1) → ∃ x y, n = x ^ 2 + y ^ 2 :=\n\n/-- The sum of two squares is zero iff both elements are zero. -/\ntheorem ∀ {α : Type u} [inst : LinearOrderedRing α] {x y : α}, x * x + y * y = 0 ↔ x = 0 ∧ y = 0 :=\n\n/-- Two natural numbers are equal if and only if they have the same multiples. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), m ∣ a ↔ n ∣ a) ↔ m = n :=\n\n/-- Two natural numbers are equal if and only if they have the same divisors. -/\ntheorem ∀ {m n : ℕ}, (∀ (a : ℕ), a ∣ m ↔ a ∣ n) ↔ m = n :=\n\n/-- Pythagorean theorem, if-and-if vector inner product form using square roots. -/\ntheorem ∀ {F : Type u_1} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {x y : F},\n  ‖x + y‖ = Real.sqrt (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖) ↔ inner x y = 0 :=\n\n/-- If two integers are congruent to a sufficiently large modulus,\nthey are equal. -/\ntheorem ∀ {a b c : ℤ}, a % b = c → Int.natAbs (a - c) < Int.natAbs b → a = c :=\n\n/-- Commutativity of a square is preserved when taking quotients by an ideal. -/\ntheorem ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] {R' : Type u_1} {S' : Type u_2}\n  [inst_2 : CommRing R'] [inst_3 : CommRing S'] {f : R →+* S} {f' : R' →+* S'} {g : R →+* R'} {g' : S →+* S'}\n  (hfg : RingHom.comp f' g = RingHom.comp g' f) (I : Ideal S'),\n  let leq := (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap g (Ideal.comap f' I));\n  RingHom.comp (Ideal.quotientMap I g' (_ : Ideal.comap g' I ≤ Ideal.comap g' I))\n      (Ideal.quotientMap (Ideal.comap g' I) f\n        (_ : Ideal.comap f (Ideal.comap g' I) ≤ Ideal.comap f (Ideal.comap g' I))) =\n    RingHom.comp (Ideal.quotientMap I f' (_ : Ideal.comap f' I ≤ Ideal.comap f' I))\n      (Ideal.quotientMap (Ideal.comap f' I) g leq) :=\n\n/-- A natural number `n` is a sum of two squares if and only if `n = a^2 * b` with natural\nnumbers `a` and `b` such that `-1` is a square modulo `b`. -/\ntheorem ∀ {n : ℕ}, (∃ x y, n = x ^ 2 + y ^ 2) ↔ ∃ a b, n = a ^ 2 * b ∧ IsSquare (-1) :=\n\n/-- If the natural number `n` is a sum of two squares of coprime natural numbers, then\n`-1` is a square modulo `n`. -/\ntheorem ∀ {n x y : ℕ}, n = x ^ 2 + y ^ 2 → Nat.coprime x y → IsSquare (-1) :=\n\n/-- Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares. -/\ntheorem",
    "choices": [
      "∀ {n : ℤ}, (∃ x y : ℚ, n = x ^ 2 + y ^ 2) → ∃ a b : ℤ, n = a ^ 2 + b ^ 2 ",
      "∀ {a : ℤ}, (∃ x y : ℚ, a = x ^ 2 + y ^ 2) → ∃ m n : ℤ, a = m ^ 2 + n ^ 2 ",
      "∀ {n : ℤ}, (∃ x y : ℚ, n = x ^ 2 + y ^ 2) → ∃ x y : ℤ, n = x ^ 2 + y ^ 2 ",
      "∀ {z : ℤ}, (∃ x y : ℚ, z = x ^ 2 + y ^ 2) → ∃ m n : ℤ, z = m ^ 2 + n ^ 2 ",
      "∀ {a b c : ℤ}, a = b ^ 2 + c ^ 2 → ∃ x y : ℤ, a = x ^ 2 + y ^ 2 ",
      "∀ {a b c : ℤ}, a = (b : ℤ) ^ 2 + c ^ 2 → ∃ x y : ℤ, a = x ^ 2 + y ^ 2 ",
      "∀ {a : ℤ}, (∃ x y : ℚ, a = x ^ 2 + y ^ 2) → ∃ m n : ℤ, a = m ^ 2 + n ^ 2 ",
      "∀ {a b x y u v : ℤ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2 ",
      "∀ {n : ℤ}, (∃ x y : ℚ, n = x ^ 2 + y ^ 2) → ∃ x y : ℤ, n = x ^ 2 + y ^ 2 ",
      "∀ {n : ℤ}, (∃ x y : ℚ, n = x ^ 2 + y ^ 2) → ∃ x y : ℤ, n = x ^ 2 + y ^ 2 "
    ]
  },
  {
    "docString": "Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2.",
    "prompts": "[{\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a ring by an ideal is a field iff the ideal is maximal. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a\",\n  \"isProp\": true,\n  \"docString\":\n  \"In a finite field of characteristic `2`, all elements are squares. \"},\n {\"theorem\":\n  \"∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The finite field `F` has even cardinality iff it has characteristic `2`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R\",\n  \"isProp\": true,\n  \"docString\":\n  \"The class number is `1` iff the ring of integers is a principal ideal domain. \"},\n {\"theorem\":\n  \"∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J\",\n  \"isProp\": true,\n  \"docString\": \"Multiplicativity of the ideal norm in number rings. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\\n  ∃ V, ↑V * ↑V ⊆ ↑U\",\n  \"isProp\": true,\n  \"docString\":\n  \"An open subgroup of a nonarchimedean ring contains the square of another one. \"},\n {\"theorem\": \"∀ {α : Type u} [self : StrictOrderedRing α], 0 ≤ 1\",\n  \"isProp\": true,\n  \"docString\": \"In a strict ordered ring, `0 ≤ 1`. \"},\n {\"theorem\":\n  \"∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I)\",\n  \"isProp\": true,\n  \"docString\":\n  \"The quotient of a finitely presented algebra by a finitely generated ideal is finitely\\npresented. \"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If the quotient by an ideal is a field, then the ideal is maximal. \"},\n {\"theorem\": \"∀ (z : UpperHalfPlane), ∃ g, g • z ∈ ModularGroup.fd\",\n  \"isProp\": true,\n  \"docString\": \"Any `z : ℍ` can be moved to `𝒟` by an element of `SL(2,ℤ)`  \"}]\n",
    "prompt_cons": "/-- The quotient of a ring by an ideal is a field iff the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.IsMaximal I ↔ IsField (R ⧸ I) :=\n\n/-- In a finite field of characteristic `2`, all elements are squares. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Finite F], ringChar F = 2 → ∀ (a : F), IsSquare a :=\n\n/-- The finite field `F` has even cardinality iff it has characteristic `2`. -/\ntheorem ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], ringChar F = 2 ↔ Fintype.card F % 2 = 0 :=\n\n/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  [inst_3 : Fintype (ClassGroup R)], Fintype.card (ClassGroup R) = 1 ↔ IsPrincipalIdealRing R :=\n\n/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem ∀ {S : Type u_1} [inst : CommRing S] [inst_1 : IsDomain S] [inst_2 : IsDedekindDomain S] [inst_3 : Module.Free ℤ S]\n  [inst_4 : Module.Finite ℤ S] (I J : Ideal S), Submodule.cardQuot (I * J) = Submodule.cardQuot I * Submodule.cardQuot J :=\n\n/-- An open subgroup of a nonarchimedean ring contains the square of another one. -/\ntheorem ∀ {R : Type u_1} [inst : Ring R] [inst_1 : TopologicalSpace R] [inst_2 : NonarchimedeanRing R] (U : OpenAddSubgroup R),\n  ∃ V, ↑V * ↑V ⊆ ↑U :=\n\n/-- In a strict ordered ring, `0 ≤ 1`. -/\ntheorem ∀ {α : Type u} [self : StrictOrderedRing α], 0 ≤ 1 :=\n\n/-- The quotient of a finitely presented algebra by a finitely generated ideal is finitely\npresented. -/\ntheorem ∀ {R : Type w₁} {A : Type w₂} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] {I : Ideal A},\n  Ideal.FG I → Algebra.FinitePresentation R A → Algebra.FinitePresentation R (A ⧸ I) :=\n\n/-- If the quotient by an ideal is a field, then the ideal is maximal. -/\ntheorem ∀ {R : Type u} [inst : CommRing R] (I : Ideal R), IsField (R ⧸ I) → Ideal.IsMaximal I :=\n\n/-- Any `z : ℍ` can be moved to `𝒟` by an element of `SL(2,ℤ)` -/\ntheorem ∀ (z : UpperHalfPlane), ∃ g, g • z ∈ ModularGroup.fd :=\n\n/-- Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2. -/\ntheorem",
    "choices": [
      "∀ {R : Type u} [inst : CommRing R], IsField (R ⧸ (1 + Ii)) → Fintype.card (R ⧸ (1 + Ii)) = 2 ",
      "IsField (ℤ[i] ⧸ Ideal.span [(1 + I)]) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span [(1 + I)]) = 2 ",
      "∀ {R : Type u} [inst : CommRing R] (I : Ideal R), I = Ideal.span {(1 : R) + I} → IsField (R ⧸ I) ∧ Fintype.card (R ⧸ I) = 2 ",
      "IsField (ℤ[i] ⧸ ideal.span {(1 + I)}) ∧ Fintype.card (ℤ[i] ⧸ ideal.span {(1 + I)}) = 2 ",
      "quotientZiOnePlusIIsField : IsField (ℤ[i] ⧸ Ideal.span {(1 + I)}) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span {(1 + I)}) = 2 ",
      "IsField (ℤ[i] ⧸ Ideal.span {(1 : ℤ[i]) + I}) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span {(1 : ℤ[i]) + I}) = 2 ",
      "∀ {I : Ideal ℤ[i]}, I = Ideal.span {(1 + I)}, IsField (ℤ[i] ⧸ I) ∧ Fintype.card (ℤ[i] ⧸ I) = 2 ",
      "IsField (ℤ[i] ⧸ Ideal.span [{1 + I}]) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span [{1 + I}]) = 2 ",
      "IsField (ℤ[i] ⧸ Ideal.span {(1 + I)}) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span {(1 + I)}) = 2 ",
      "IsField (ℤ[i] ⧸ Ideal.span {(1 + I)}) ∧ Fintype.card (ℤ[i] ⧸ Ideal.span {(1 + I)}) = 2 "
    ]
  },
  {
    "docString": "Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$.",
    "prompts": "[{\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not a unit. \"},\n {\"theorem\":\n  \"∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\\n  [inst : Nontrivial S], False\",\n  \"isProp\": true,\n  \"docString\": \"The product of two nontrivial rings is not a domain \"},\n {\"theorem\":\n  \"∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A solution with `x > 1` must have `y ≠ 0`. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. \"},\n {\"theorem\":\n  \"∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is not `1`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥\",\n  \"isProp\": true,\n  \"docString\":\n  \"When a ring is not a field, the maximal ideals are nontrivial. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. \"},\n {\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\\n  I ≠ 0 →\\n    ¬v.asIdeal ^ (Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) + 1) ∣\\n        ∏ᶠ (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I\",\n  \"isProp\": true,\n  \"docString\":\n  \"For every nonzero ideal `I` of `v`, `v^(val_v(I) + 1)` does not divide `∏_v v^(val_v(I))`. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is not a unit. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], ¬IsUnit (minpoly A x) :=\n\n/-- The product of two nontrivial rings is not a domain -/\ntheorem ∀ (R : Type u_1) (S : Type u_2) [inst : Ring R] [inst_1 : Ring S] [inst : IsDomain (R × S)] [inst : Nontrivial R]\n  [inst : Nontrivial S], False :=\n\n/-- A solution with `x > 1` must have `y ≠ 0`. -/\ntheorem ∀ {d : ℤ} {a : Pell.Solution₁ d}, 1 < Pell.Solution₁.x a → Pell.Solution₁.y a ≠ 0 :=\n\n/-- We have `2 ≠ 0` in a nontrivial ring whose characteristic is not `2`. -/\ntheorem ∀ {R : Type u_1} [inst : NonAssocSemiring R] [inst_1 : Nontrivial R], ringChar R ≠ 2 → 2 ≠ 0 :=\n\n/-- A minimal polynomial is not `1`. -/\ntheorem ∀ (A : Type u_2) {B : Type u_1} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] (x : B)\n  [inst_3 : Nontrivial B], minpoly A x ≠ 1 :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ∀ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, Ideal.IsMaximal M → ¬IsField R → M ≠ ⊥ :=\n\n/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B} {a : Polynomial A},\n  IsIntegral A x → Polynomial.Monic a → DvdNotUnit a (minpoly A x) → ↑(Polynomial.aeval x) a ≠ 0 :=\n\n/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- For every nonzero ideal `I` of `v`, `v^(val_v(I) + 1)` does not divide `∏_v v^(val_v(I))`. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : IsDedekindDomain R]\n  (v : IsDedekindDomain.HeightOneSpectrum R) (I : Ideal R),\n  I ≠ 0 →\n    ¬v.asIdeal ^ (Associates.count (Associates.mk v.asIdeal) (Associates.factors (Associates.mk I)) + 1) ∣\n        ∏ᶠ (v : IsDedekindDomain.HeightOneSpectrum R), IsDedekindDomain.HeightOneSpectrum.maxPowDividing v I :=\n\n/-- Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$. -/\ntheorem",
    "choices": [
      "∀ (x y : ℚ) [inst : CommRing ℚ], ¬IsPrincipalIdealRing (ℚ[X] × ℚ[Y]) ",
      "∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : IsDomain R] [inst_3 : IsDomain S],\n  Ideal.principal (Ideal.span {(1 : R × S).fst, (0, 1).snd}) → False ",
      "∀ (x y : ℚ[X]) [inst : CommRing ℚ[X]], ¬IsPrincipalIdealRing (ℚ[X]) → Ideal.span {(x, y)} ≠ ⊥ ",
      "∀ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDedekindDomain A] [inst_2 : IsFractionRing A ℚ],\n  ¬(Ideal.span {Polynomial.x, Polynomial.y} : Ideal (Polynomial A)).IsPrincipal ",
      "∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : IsDomain (R × S)] [inst_3 : Nontrivial R]\n  [inst_4 : Nontrivial S], Ideal (R × S) (Ideal.principal (1, 0), Ideal.principal (0, 1)) ≠ ⊤ ",
      "∀ {R : Type u_1} [inst : Field R] [inst_1 : IsAlgClosed R] {x y : R} [inst_2 : IsDomain (R[X, Y])],\n  Polynomial.eval₂ (RingHom.comp (Polynomial.mapRingHom (RingHom.id R)) (algebraMap R (R[X, Y]))) x (X : R[X, Y]) ≠\n    Polynomial.eval₂ (RingHom.comp (Polynomial.mapRingHom (RingHom.id R)) (algebraMap R (R[X, Y]))) y (Y : R[X, Y]) →\n      Ideal.span {(X : R[X, Y]), Y} ≠ ⊤ ",
      "∀ (x y : Polynomial ℚ) [inst : EuclideanDomain (Polynomial ℚ)], Ideal.span {x, y} ≠ ⊥ → ¬Ideal.IsPrincipal (Ideal.span {x, y}) ",
      "∀ (R : Type u_1) (S : Type u_2) [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : IsDomain R] [inst_3 : IsDomain S],\n  ¬Ideal.IsPrincipal (Ideal.span {(1 : Polynomial R), Polynomial.x * Polynomial.y}) ",
      "∀ {A : Type u_1} [inst : Field A] [inst_1 : IsDedekindDomain A],\n  ∀ (x y : A[X]), ¬Ideal.IsPrincipal (Ideal.span {x, y}) ",
      "∀ (x y : Polynomial ℚ), ¬IsPrincipalIdealRing (x, y) "
    ]
  },
  {
    "docString": "Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.",
    "prompts": "[{\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\\n  Polynomial.Monic g₁ →\\n    Polynomial.Monic g₂ →\\n      IsCoprime g₁ g₂ →\\n        ∃ q r₁ r₂,\\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\\ndeg(r₂) < deg(g₂).\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I\",\n  \"isProp\": true,\n  \"docString\":\n  \"If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself \"},\n {\"theorem\":\n  \"∀ {F : Type u_2} {M₀ : Type u_1} [inst : MonoidWithZero M₀] [inst_1 : MonoidWithZeroHomClass F ℚ M₀] {f g : F},\\n  (∀ (m : ℤ), ↑f ↑m = ↑g ↑m) → f = g\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` agree on the integers then they are equal `φ`. \"},\n {\"theorem\":\n  \"∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on the factors. \"},\n {\"theorem\":\n  \"∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"To prove a property of a finite product, it suffices to prove that the property is\\nmultiplicative and holds on factors. \"},\n {\"theorem\":\n  \"∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {ι : Type u_1} {g : ι → Polynomial R} {s : Finset ι},\\n  (∀ (i : ι), i ∈ s → Polynomial.Monic (g i)) →\\n    (Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) →\\n      ∃ q r,\\n        (∀ (i : ι), i ∈ s → Polynomial.degree (r i) < Polynomial.degree (g i)) ∧\\n          (↑f / Finset.prod s fun i => ↑(g i)) = ↑q + Finset.sum s fun i => ↑(r i) / ↑(g i)\",\n  \"isProp\": true,\n  \"docString\":\n  \"Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\\n\"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\\n  Ideal.IsPrime P →\\n    ¬Polynomial.leadingCoeff f ∈ P →\\n      (∀ (n : ℕ), ↑n < Polynomial.degree f → Polynomial.coeff f n ∈ P) →\\n        0 < Polynomial.degree f → ¬Polynomial.coeff f 0 ∈ P ^ 2 → Polynomial.IsPrimitive f → Irreducible f\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\\nirreducible. \"},\n {\"theorem\":\n  \"∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R] {f g : Polynomial R},\\n  Polynomial.degree f = 2 →\\n    Polynomial.degree g = 2 → Fintype.card R % 2 = 1 → ∃ a b, Polynomial.eval a f + Polynomial.eval b g = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A},\\n  Polynomial.Monic p → ∀ {r : K}, ↑(Polynomial.aeval r) p = 0 → IsLocalization.IsInteger A r\",\n  \"isProp\": true,\n  \"docString\":\n  \"Integral root theorem:\\nif `r : f.codomain` is a root of a monic polynomial over the ufd `A`,\\nthen `r` is an integer \"},\n {\"theorem\":\n  \"∀ {R : Type u_2} {A : Type u_1} [inst : Semiring R] [inst_1 : Add A] {f g : AddMonoidAlgebra R A} {a0 b0 : A},\\n  (∀ {a b : A}, a ∈ f.support → b ∈ g.support → a ≠ a0 ∨ b ≠ b0 → a + b ≠ a0 + b0) → ↑(f * g) (a0 + b0) = ↑f a0 * ↑g b0\",\n  \"isProp\": true,\n  \"docString\":\n  \"The coefficient of a monomial in a product `f * g` that can be reached in at most one way\\nas a product of monomials in the supports of `f` and `g` is a product. \"}]\n",
    "prompt_cons": "/-- Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\ndeg(r₂) < deg(g₂). -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {g₁ g₂ : Polynomial R},\n  Polynomial.Monic g₁ →\n    Polynomial.Monic g₂ →\n      IsCoprime g₁ g₂ →\n        ∃ q r₁ r₂,\n          Polynomial.degree r₁ < Polynomial.degree g₁ ∧\n            Polynomial.degree r₂ < Polynomial.degree g₂ ∧ ↑f / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂ :=\n\n/-- If every coefficient of a polynomial is in an ideal `I`, then so is the polynomial itself -/\ntheorem ∀ {R : Type u} [inst : CommSemiring R] (I : Ideal (Polynomial R)) (p : Polynomial R),\n  (∀ (n : ℕ), Polynomial.coeff p n ∈ Ideal.comap Polynomial.C I) → p ∈ I :=\n\n/-- If `f` and `g` agree on the integers then they are equal `φ`. -/\ntheorem ∀ {F : Type u_2} {M₀ : Type u_1} [inst : MonoidWithZero M₀] [inst_1 : MonoidWithZeroHomClass F ℚ M₀] {f g : F},\n  (∀ (m : ℤ), ↑f ↑m = ↑g ↑m) → f = g :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on the factors. -/\ntheorem ∀ {M : Type u_1} {α : Sort u_2} [inst : CommMonoid M] {f : α → M} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (i : α), p (f i)) → p (∏ᶠ (i : α), f i) :=\n\n/-- To prove a property of a finite product, it suffices to prove that the property is\nmultiplicative and holds on factors. -/\ntheorem ∀ {α : Type u_2} {M : Type u_1} [inst : CommMonoid M] {f : α → M} {s : Set α} (p : M → Prop),\n  p 1 → (∀ (x y : M), p x → p y → p (x * y)) → (∀ (x : α), x ∈ s → p (f x)) → p (∏ᶠ (i : α) (_ : i ∈ s), f i) :=\n\n/-- Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime. -/\ntheorem ∀ (R : Type) [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f : Polynomial R) {ι : Type u_1} {g : ι → Polynomial R} {s : Finset ι},\n  (∀ (i : ι), i ∈ s → Polynomial.Monic (g i)) →\n    (Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) →\n      ∃ q r,\n        (∀ (i : ι), i ∈ s → Polynomial.degree (r i) < Polynomial.degree (g i)) ∧\n          (↑f / Finset.prod s fun i => ↑(g i)) = ↑q + Finset.sum s fun i => ↑(r i) / ↑(g i) :=\n\n/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f : Polynomial R} {P : Ideal R},\n  Ideal.IsPrime P →\n    ¬Polynomial.leadingCoeff f ∈ P →\n      (∀ (n : ℕ), ↑n < Polynomial.degree f → Polynomial.coeff f n ∈ P) →\n        0 < Polynomial.degree f → ¬Polynomial.coeff f 0 ∈ P ^ 2 → Polynomial.IsPrimitive f → Irreducible f :=\n\n/-- If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. -/\ntheorem ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : Fintype R] {f g : Polynomial R},\n  Polynomial.degree f = 2 →\n    Polynomial.degree g = 2 → Fintype.card R % 2 = 1 → ∃ a b, Polynomial.eval a f + Polynomial.eval b g = 0 :=\n\n/-- Integral root theorem:\nif `r : f.codomain` is a root of a monic polynomial over the ufd `A`,\nthen `r` is an integer -/\ntheorem ∀ {A : Type u_1} {K : Type u_2} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A]\n  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] {p : Polynomial A},\n  Polynomial.Monic p → ∀ {r : K}, ↑(Polynomial.aeval r) p = 0 → IsLocalization.IsInteger A r :=\n\n/-- The coefficient of a monomial in a product `f * g` that can be reached in at most one way\nas a product of monomials in the supports of `f` and `g` is a product. -/\ntheorem ∀ {R : Type u_2} {A : Type u_1} [inst : Semiring R] [inst_1 : Add A] {f g : AddMonoidAlgebra R A} {a0 b0 : A},\n  (∀ {a b : A}, a ∈ f.support → b ∈ g.support → a ≠ a0 ∨ b ≠ b0 → a + b ≠ a0 + b0) → ↑(f * g) (a0 + b0) = ↑f a0 * ↑g b0 :=\n\n/-- Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer. -/\ntheorem",
    "choices": [
      "∀ {R : Type} [inst : CommRing R] [inst_1 : IsDomain R] (K : Type) [inst_2 : Field K] [inst_3 : Algebra (Polynomial R) K]\n  [inst_4 : IsFractionRing (Polynomial R) K] (f g : Polynomial ℚ),\n  (∀ (n : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff (f * g) n)) →\n    (∀ (i j : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff f i * Polynomial.coeff g j)) ",
      "∀ {f g : Polynomial ℚ},\n  (∀ (n : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff (f * g) n)) →\n    ∀ (i j : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {R : Type} [inst : CommRing R] [inst_1 : IsDomain R] {f g : Polynomial R},\n  (∀ (n : ℕ), IsLocalization.IsInteger R (Polynomial.coeff f n)) →\n    (∀ (m : ℕ), IsLocalization.IsInteger R (Polynomial.coeff g m)) →\n      ∀ (i j : ℕ), IsLocalization.IsInteger R (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f g : Polynomial R}, (∀ (n : ℕ), IsInteger (Polynomial.coeff (f * g) n)) →\n  ∀ (i j : ℕ), IsInteger (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {f g : Polynomial ℚ},\n  (∀ (n : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff (f * g) n)) →\n    ∀ (i j : ℕ),\n      IsLocalization.IsInteger ℤ (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {f g : Polynomial ℚ},\n  (∀ (n : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff (f * g) n)) →\n    ∀ (i j : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDomain R] {f g : Polynomial ℚ} (H : ∀ (n : ℕ), IsLocalization.IsInteger R (Polynomial.coeff (f * g) n)),\n  ∀ (i j : ℕ), IsLocalization.IsInteger R (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {f g : Polynomial ℚ},\n  (∀ (n : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff (f * g) n)) →\n    ∀ (i j : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {f g : Polynomial ℚ} {i j : ℕ},\n  (∀ (n : ℕ), IsLocalization.IsInteger ℤ (Polynomial.coeff (f * g) n)) →\n    IsLocalization.IsInteger ℤ (Polynomial.coeff f i * Polynomial.coeff g j) ",
      "∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDomain R] [inst_2 : UniqueFactorizationMonoid R]\n  [inst_3 : Field K] [inst_4 : Algebra R K] [inst_5 : IsFractionRing R K] {f g : Polynomial R},\n  (∀ (n : ℕ), IsLocalization.IsInteger R (Polynomial.coeff (f * g) n)) →\n    ∀ (i j : ℕ), IsLocalization.IsInteger R (Polynomial.coeff f i * Polynomial.coeff g j) "
    ]
  },
  {
    "docString": "Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\\nirreducible over `ℚ`. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\\n  IsIntegral A x → Prime (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is prime. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is nonzero. \"}]\n",
    "prompt_cons": "/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- An irreducible polynomial of prime degree with 1-3 non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℝ) + 1 ≤ Fintype.card ↑(Polynomial.rootSet p ℂ) →\n        Fintype.card ↑(Polynomial.rootSet p ℂ) ≤ Fintype.card ↑(Polynomial.rootSet p ℝ) + 3 →\n          Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\nirreducible over `ℚ`. -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsPrimitive p → (Irreducible p ↔ Irreducible (Polynomial.map (Int.castRingHom ℚ) p)) :=\n\n/-- A minimal polynomial is prime. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},\n  IsIntegral A x → Prime (minpoly A x) :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- A minimal polynomial is nonzero. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : Nontrivial A], IsIntegral A x → minpoly A x ≠ 0 :=\n\n/-- Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "x_pow_6_30x_pow_5_neg_15x_pow_3_6x_neg_120_irreducible : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducibility_of_x_pow_6_plus_30_x_pow_5_minus_15_x_pow_3_plus_6_x_minus_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120_irreducible : Irreducible (Polynomial.x ^ 6 + 30 • Polynomial.x ^ 5 - 15 • Polynomial.x ^ 3 + 6 • Polynomial.x - 120 : Polynomial ℤ) ",
      "irreducible_x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120 : Polynomial ℤ) ",
      "irreducible_x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_6_add_30_x_pow_5_sub_15_x_pow_3_add_6_x_sub_120 : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) ",
      "irreducible_x_pow_six_add_thirty_x_pow_five_sub_fifteen_x_pow_three_add_six_x_sub_one_twenty : Irreducible (Polynomial.x ^ 6 + 30 * Polynomial.x ^ 5 - 15 * Polynomial.x ^ 3 + 6 * Polynomial.x - 120) "
    ]
  },
  {
    "docString": "Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$.",
    "prompts": "[{\"theorem\": \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2\",\n  \"isProp\": true,\n  \"docString\": \"A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3)\",\n  \"isProp\": true,\n  \"docString\":\n  \"`-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q\",\n  \"isProp\": true,\n  \"docString\":\n  \"The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ+} {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L]\\n  [hpri : Fact (Nat.Prime ↑p)] [hcyc : IsCyclotomicExtension {p} K L],\\n  IsPrimitiveRoot ζ ↑p → Irreducible (Polynomial.cyclotomic (↑p) K) → p ≠ 2 → ↑(Algebra.norm K) (ζ - 1) = ↑↑p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic p K)` (in particular for `K = ℚ`) and `p` is an odd prime,\\nthen the norm of `ζ - 1` is `p`. \"},\n {\"theorem\":\n  \"∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2))\",\n  \"isProp\": true,\n  \"docString\":\n  \"**The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. \"},\n {\"theorem\":\n  \"∀ {x y : ℤ} {n : ℕ},\\n  2 ∣ x - y →\\n    ¬2 ∣ x →\\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n\",\n  \"isProp\": true,\n  \"docString\": \"**Lifting the exponent lemma** for `p = 2` \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : ℕ+} {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : ℕ},\\n  IsPrimitiveRoot ζ ↑(p ^ (k + 1)) →\\n    ∀ [hpri : Fact (Nat.Prime ↑p)] [inst_3 : IsCyclotomicExtension {p ^ (k + 1)} K L],\\n      Irreducible (Polynomial.cyclotomic (↑(p ^ (k + 1))) K) → p ≠ 2 → ↑(Algebra.norm K) (ζ - 1) = ↑↑p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = ℚ`) and `p` is an odd\\nprime, then the norm of `ζ - 1` is `p`. \"},\n {\"theorem\":\n  \"∀ {p : ℕ+} {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\\n  [inst_3 : Fact (Nat.Prime ↑p)] [inst_4 : IsCyclotomicExtension {p} K L],\\n  Irreducible (Polynomial.cyclotomic (↑p) K) → p ≠ 2 → ↑(Algebra.norm K) (IsCyclotomicExtension.zeta p K L - 1) = ↑↑p\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `Irreducible (cyclotomic p K)` (in particular for `K = ℚ`) and `p` is an odd prime,\\nthen the norm of `zeta p K L - 1` is `p`. \"}]\n",
    "prompt_cons": "/-- A prime `p` satisfies `p % 2 = 1` if and only if `p ≠ 2`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p % 2 = 1 ↔ p ≠ 2 :=\n\n/-- `2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `7` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare 2 ↔ p % 8 = 1 ∨ p % 8 = 7) :=\n\n/-- `-2` is a square modulo an odd prime `p` iff `p` is congruent to `1` or `3` mod `8`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → (IsSquare (-2) ↔ p % 8 = 1 ∨ p % 8 = 3) :=\n\n/-- The Law of Quadratic Reciprocity: if `p` and `q` are odd primes, then\n`(q / p) = (-1)^((p-1)(q-1)/4) * (p / q)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → legendreSym q ↑p = (-1) ^ (p / 2 * (q / 2)) * legendreSym p ↑q :=\n\n/-- If `Irreducible (cyclotomic p K)` (in particular for `K = ℚ`) and `p` is an odd prime,\nthen the norm of `ζ - 1` is `p`. -/\ntheorem ∀ {p : ℕ+} {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L]\n  [hpri : Fact (Nat.Prime ↑p)] [hcyc : IsCyclotomicExtension {p} K L],\n  IsPrimitiveRoot ζ ↑p → Irreducible (Polynomial.cyclotomic (↑p) K) → p ≠ 2 → ↑(Algebra.norm K) (ζ - 1) = ↑↑p :=\n\n/-- **The Law of Quadratic Reciprocity**: if `p` and `q` are distinct odd primes, then\n`(q / p) * (p / q) = (-1)^((p-1)(q-1)/4)`. -/\ntheorem ∀ {p q : ℕ} [inst : Fact (Nat.Prime p)] [inst_1 : Fact (Nat.Prime q)],\n  p ≠ 2 → q ≠ 2 → p ≠ q → legendreSym q ↑p * legendreSym p ↑q = (-1) ^ (p / 2 * (q / 2)) :=\n\n/-- **Lifting the exponent lemma** for `p = 2` -/\ntheorem ∀ {x y : ℤ} {n : ℕ},\n  2 ∣ x - y →\n    ¬2 ∣ x →\n      Even n → multiplicity 2 (x ^ n - y ^ n) + 1 = multiplicity 2 (x + y) + multiplicity 2 (x - y) + multiplicity 2 ↑n :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- If `Irreducible (cyclotomic (p ^ (k + 1)) K)` (in particular for `K = ℚ`) and `p` is an odd\nprime, then the norm of `ζ - 1` is `p`. -/\ntheorem ∀ {p : ℕ+} {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L] {k : ℕ},\n  IsPrimitiveRoot ζ ↑(p ^ (k + 1)) →\n    ∀ [hpri : Fact (Nat.Prime ↑p)] [inst_3 : IsCyclotomicExtension {p ^ (k + 1)} K L],\n      Irreducible (Polynomial.cyclotomic (↑(p ^ (k + 1))) K) → p ≠ 2 → ↑(Algebra.norm K) (ζ - 1) = ↑↑p :=\n\n/-- If `Irreducible (cyclotomic p K)` (in particular for `K = ℚ`) and `p` is an odd prime,\nthen the norm of `zeta p K L - 1` is `p`. -/\ntheorem ∀ {p : ℕ+} {K : Type u} (L : Type v) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]\n  [inst_3 : Fact (Nat.Prime ↑p)] [inst_4 : IsCyclotomicExtension {p} K L],\n  Irreducible (Polynomial.cyclotomic (↑p) K) → p ≠ 2 → ↑(Algebra.norm K) (IsCyclotomicExtension.zeta p K L - 1) = ↑↑p :=\n\n/-- Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$. -/\ntheorem",
    "choices": [
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.x_plus_2_pow_p_minus_2_pow_p_div_x p) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.x_pow_sub (2^p) (Polynomial.x + 2) p) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.map ℤ (Polynomial.x ^ p - 2) + Polynomial.x * (2 ^ p - 1)) ",
      "forall {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.x_pow_add_two_pow_sub_two_pow_div_x p) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.x ^ p - 2 ^ p + (2 * Polynomial.x * ((Polynomial.x + 2) ^ (p - 1)) - 2 ^ (p - 1))) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.map ℤ (Polynomial.x + 2) ^ p - 2 ^ p) / x ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible ((X + 2) ^ p - C ↑(2 ^ p) : Polynomial ℤ) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.x ^ p + 2 * Polynomial.x ^ (p - 1) - Polynomial.C (2 ^ p)) ",
      "∀ {p : ℕ} [inst_1 : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.div_X (((Polynomial.x + 2) ^ p) - (Polynomial.C (↑p)))) ",
      "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], p ≠ 2 → Irreducible (Polynomial.x_pow_add_of_odd_prime p - 2 ^ p) "
    ]
  },
  {
    "docString": "Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$.",
    "prompts": "[{\"theorem\":\n  \"∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1\",\n  \"isProp\": true,\n  \"docString\":\n  \"The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℤ` is irreducible. \"},\n {\"theorem\": \"∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ)\",\n  \"isProp\": true,\n  \"docString\": \"`cyclotomic n ℚ` is irreducible. \"},\n {\"theorem\":\n  \"∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x)\",\n  \"isProp\": true,\n  \"docString\": \"A minimal polynomial is irreducible. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it is coprime with its mirror \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℤ},\\n  Polynomial.IsUnitTrinomial p →\\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p\",\n  \"isProp\": true,\n  \"docString\":\n  \"A unit trinomial is irreducible if it has no complex roots in common with its mirror \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\\n  legendreSym p a = -1 → ∀ {x y : ZMod p}, x ^ 2 - ↑a * y ^ 2 = 0 → x = 0 ∧ y = 0\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `legendreSym p a = -1`, then the only solution of `x^2 - a*y^2 = 0` in `ℤ/pℤ`\\nis the trivial one. \"},\n {\"theorem\":\n  \"∀ {p : Polynomial ℚ},\\n  Irreducible p →\\n    Nat.Prime (Polynomial.natDegree p) →\\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ)\",\n  \"isProp\": true,\n  \"docString\":\n  \"An irreducible polynomial of prime degree with two non-real roots has full Galois group. \"},\n {\"theorem\": \"∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `x + y` is irrational, then at least one of `x` and `y` is irrational. \"},\n {\"theorem\":\n  \"∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\\n  jacobiSym a p = -1 → ∀ {x y : ℤ}, ↑p ∣ x ^ 2 - a * y ^ 2 → ↑p ∣ x ∧ ↑p ∣ y\",\n  \"isProp\": true,\n  \"docString\":\n  \"If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\\n`x` and `y`. \"}]\n",
    "prompt_cons": "/-- The proof that `a` is a solution to the Pell equation `x^2 - d*y^2 = 1` -/\ntheorem ∀ {d : ℤ} (a : Pell.Solution₁ d), Pell.Solution₁.x a ^ 2 - d * Pell.Solution₁.y a ^ 2 = 1 :=\n\n/-- `cyclotomic n ℤ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℤ) :=\n\n/-- `cyclotomic n ℚ` is irreducible. -/\ntheorem ∀ {n : ℕ}, 0 < n → Irreducible (Polynomial.cyclotomic n ℚ) :=\n\n/-- A minimal polynomial is irreducible. -/\ntheorem ∀ {A : Type u_1} {B : Type u_2} [inst : CommRing A] [inst_1 : Ring B] [inst_2 : Algebra A B] {x : B}\n  [inst_3 : IsDomain A] [inst_4 : IsDomain B], IsIntegral A x → Irreducible (minpoly A x) :=\n\n/-- A unit trinomial is irreducible if it is coprime with its mirror -/\ntheorem ∀ {p : Polynomial ℤ}, Polynomial.IsUnitTrinomial p → IsCoprime p (Polynomial.mirror p) → Irreducible p :=\n\n/-- A unit trinomial is irreducible if it has no complex roots in common with its mirror -/\ntheorem ∀ {p : Polynomial ℤ},\n  Polynomial.IsUnitTrinomial p →\n    (∀ (z : ℂ), ¬(↑(Polynomial.aeval z) p = 0 ∧ ↑(Polynomial.aeval z) (Polynomial.mirror p) = 0)) → Irreducible p :=\n\n/-- If `legendreSym p a = -1`, then the only solution of `x^2 - a*y^2 = 0` in `ℤ/pℤ`\nis the trivial one. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\n  legendreSym p a = -1 → ∀ {x y : ZMod p}, x ^ 2 - ↑a * y ^ 2 = 0 → x = 0 ∧ y = 0 :=\n\n/-- An irreducible polynomial of prime degree with two non-real roots has full Galois group. -/\ntheorem ∀ {p : Polynomial ℚ},\n  Irreducible p →\n    Nat.Prime (Polynomial.natDegree p) →\n      Fintype.card ↑(Polynomial.rootSet p ℂ) = Fintype.card ↑(Polynomial.rootSet p ℝ) + 2 →\n        Function.Bijective ↑(Polynomial.Gal.galActionHom p ℂ) :=\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem ∀ {x y : ℝ}, Irrational (x + y) → Irrational x ∨ Irrational y :=\n\n/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {a : ℤ},\n  jacobiSym a p = -1 → ∀ {x y : ℤ}, ↑p ∣ x ^ 2 - a * y ^ 2 → ↑p ∣ x ∧ ↑p ∣ y :=\n\n/-- Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$. -/\ntheorem",
    "choices": [
      "Irreducible (Polynomial.map (Polynomial.integralNormalization (Polynomial.map Polynomial.C (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1))) ℚ) ",
      "Irreducible (Polynomial.eval₂_ring_hom (RingHom.id ℚ) (Polynomial.x + Polynomial.C (1 - Polynomial.Chebyshev.t ℚ 1)) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial ℚ[ℚ]) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial ℚ[ℚ]) ",
      "Irreducible (Polynomial.map (Polynomial.embedPolyNumberField ℚ) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial ℚ[Polynomial.y]) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial ℚ[Bool]) ",
      "Irreducible (Polynomial.map (Polynomial.mapRingHom (algebraMap ℚ ℚ[X])) (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1)) ",
      "Irreducible (Polynomial.x ^ 2 + Polynomial.y ^ 2 - 1 : Polynomial ℚ[ℚ]) ",
      "Irreducible (Polynomial.map (RingHom.id ℚ) (Polynomial.x ^ 2) + Polynomial.map (RingHom.id ℚ) (Polynomial.y ^ 2) - Polynomial.map (RingHom.id ℚ) (1 : Polynomial ℚ)) "
    ]
  }
]