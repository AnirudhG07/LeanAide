{"total-prompts": 40,
 "temperature": 0.8,
 "query-number": 20,
 "number-similar-sentences": 12,
 "number-keyword-sentences": 8,
 "include-fixed": false,
 "failures":
 ["No integer is irrational.",
  "Every subgroup of a group is a group.",
  "Every infinite set contains a finite set."],
 "elaborated-prompts":
 [{"theorem": "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], p = 2 ∨ p % 2 = 1",
   "some-correct": null,
   "prompt": "Every prime number is `2` or odd.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨   p %  2 =  1",
    " (  p :  ℕ ) ->  [ hp :  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨  Odd  p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨  ∃    (   q :  ℕ ) ,  p =    2 * q +  1",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨  Odd  p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  p ≠  2",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->   p =  2 ∨   p %  2 =  1"]},
  {"theorem": "∀ (n : ℕ), ∃ m, m % 2 = 1 ∧ m ≥ n",
   "some-correct": null,
   "prompt": "There are infinitely many odd natural numbers.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∀  n   :  ℕ ,  ∃    (   m :  ℕ ) ,    m %  2 =  1 ∧  m ≥ n",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,   Odd  m ∧  m > n",
    " ∀   (  a  :  ℕ  )  ,  ∃    (   b :  ℕ ) ,   b =  a +  2 ∧  Even  b",
    " ∀  n   :  ℕ ,  ∃    (   m :  ℕ ) ,   m > n ∧   m %  2 =  1",
    " ∀  n   :  ℕ ,  ∃     a  ,   n < a ∧  Odd  a",
    " ∀  m   :  ℕ ,  ∃    (   n :  ℕ ) ,   n > m ∧  Odd  n",
    " ∀   (  a  :  ℕ  )  ,  ∃    (   b :  ℕ ) ,    b %  2 =  1 ∧  b > a",
    " ∃    (   n :  ℕ ) ,  Odd  n",
    " ∀  m   :  ℕ ,  ∃     n  :  ℕ ,    n %  2 =  1 ∧  m < n",
    " ∀   (  m  :  ℕ  )  ,  ∃    (   n :  ℕ ) ,   m < n ∧   n %  2 =  1",
    " ¬  ∃    (   n :  ℕ ) ,  ∀   (  m  :  ℕ  )  ,   n ≤ m →  ¬  Odd  m",
    " Nonempty   ℕ",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,   Odd  m ∧  m > n",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,   Odd  m ∧  m ≥ n",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,     2 * n +  1 = m"]},
  {"theorem": "∀ (n : ℕ) [inst : Fact (Nat.Prime n)], n = 3 → n = 3 ∨ n = 5",
   "some-correct": null,
   "prompt": "The smallest odd prime is `3`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   ["  ↑  (  nat.prime.min_odd  ) =  3",
    " Fact   (   Nat.Prime   3  )",
    " Nat.Prime   3",
    " ∀   (  n  :  ℕ  )  [   Fact   (   Nat.Prime  n  ) ]  ,   n =  3 →   n =  3 ∨  n =  5",
    " (  n :  ℕ ) ->  [  Fact   (   Nat.Prime  n  ) ] ->  (  hp :  n ≠  0 ) ->  (  h :  n ≠  2 ) ->  n =  3"]},
  {"theorem": "∀ (n : ℕ), ∃ p, n < p ∧ Nat.Prime p ∧ p % 2 = 1",
   "some-correct": null,
   "prompt": "There are infinitely many odd prime numbers.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ¬  BddAbove   {   p   :  ℕ |   Nat.Prime  p ∧   p %  2 =  1 }",
    " ∃    (   n  m :  ℕ ) ,   Nat.Prime   (     2 * n +  1  ) ∧  m <    2 * n +  1",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   n < p ∧   Nat.Prime  p ∧   p %  2 =  1",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   n < p ∧  Nat.Prime  p",
    " ∃    (   p :  ℕ ) ,    p %  2 =  1 ∧  Nat.Prime  p",
    " ∀  n   :  ℕ ,  ∃     p  :  ℕ ,   n < p ∧   Nat.Prime  p ∧   p %  2 =  1",
    " ∀  n   :  ℕ ,  ∃     p  :  ℕ ,   p > n ∧   Nat.Prime  p ∧   p %  2 =  1",
    " ∀   (  k  :  ℕ  )  ,  ∃    (   p :  ℕ ) ,   k < p ∧   Nat.Prime  p ∧   p %  2 =  1",
    " ∀  n   :  ℕ ,  ∃  p  > n ,   Fact   (   Nat.Prime  p  ) ∧   p %  2 =  1",
    " ∃    (   p :  ℕ ) ,   Nat.Prime  p ∧  ∀   {  q  :  ℕ }  ,    Nat.Prime  q ∧  q < p →  ¬  Odd  q"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],\n  Module.rank K V = 2 → FiniteDimensional K V",
   "some-correct": null,
   "prompt":
   "If a vector space has dimension `2` then it is finite dimensional.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h₀ :   2 ≤  Module.rank  K V ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  Field  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V ≤  2 →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  H :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V ≤  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u_1 } ->  {  V :  Type  u_2 } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 ↔  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   2 ≤  Module.rank  K V ) ->  FiniteDimensional  K V"]},
  {"theorem": "(K : Type u) → [inst : Field K] → DivisionRing K",
   "some-correct": null,
   "prompt": "Every field is a division ring.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  Field  K ] ->  DivisionRing  K",
    " (  K :  Type  u ) ->  [  Field  K ] ->  DivisionRing  K",
    " {  K :  Type  u } ->  [  Field  K ] ->  DivisionRing  K",
    " {  k :  Type  u } ->  [  Field  k ] ->  DivisionRing  k",
    " {  α :  Type  u_1 } ->  [  Field  α ] ->  DivisionRing  α",
    " {  α :  Type  u } ->  [  Field  α ] ->  DivisionRing  α",
    " {  α :  Type* } ->  [  Field  α ] ->  DivisionRing  α"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V] (ι : Type u_1)\n  [inst_3 : Unique ι], Nonempty (Basis ι K V) → FiniteDimensional K V",
   "some-correct": null,
   "prompt": "If a space has dimension `2` then it is finite dimensional.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V =  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  ι :  Type  u_1 ) ->  [  Unique  ι ] ->   Nonempty   (   Basis  ι K V  ) →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V ≤  2 →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  [  Fintype  K ] ->    Module.rank  K V =  2 →  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   Module.rank  K V ≤  2 ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  H :   2 ≤  Module.rank  K V ) ->  FiniteDimensional  K V",
    " {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :   2 ≤  Module.rank  K V ) ->  FiniteDimensional  K V",
    " {  K :  Type  u_1 } ->  {  V :  Type  u_2 } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->    Module.rank  K V =  2 →  FiniteDimensional  K V"]},
  {"theorem": "∀ (n : ℕ), ∃ n', n' = Nat.succ n",
   "some-correct": null,
   "prompt": "Every natural number has a successor.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  n :  ℕ ) ->  ∃    (   n' :  ℕ ) ,  n' = n.succ",
    " (  n :  ℕ ) ->  ∃    (   m :  ℕ ) ,  n < m",
    " (  n :  ℕ ) ->  ∃    (   m :  ℕ ) ,   m = n.succ ∨  m =  0",
    " (  n :  ℕ ) ->  ∃    (   m :  ℕ ) ,   n +  1 = m",
    " {  n :  ℕ } ->  ∃    (   n' :  ℕ ) ,  n < n'",
    " (  n :  ℕ ) ->  ∃    (   x :  ℕ ) ,  x = n.succ",
    " {  n :  ℕ } ->  ∃    (   i :  ℕ ) ,  n.succ = i",
    " ∀   (  n  :  ℕ  )  ,  n.succ =  n +  1",
    " {  α :  Type  u } ->  [  Zero  α ] ->  [  One  α ] ->  [  Add  α ] ->  [  AddCommMonoid  α ] ->  [  Mul  α ] ->  [  LT  α ] ->  [  LinearOrder  α ] ->  (  x : α ) ->  x <   1 + x",
    " {  α :  Type  u } ->  [  Zero  α ] ->  [  One  α ] ->  [  Add  α ] ->  [  AddCommMonoid  α ] ->  [  Mul  α ] ->  [  LT  α ] ->  [  LinearOrderₓ  α ] ->  (  x : α ) ->  x <   1 + x",
    " {  α :  Type  u } ->  [  Zero  α ] ->  [  One  α ] ->  [  Add  α ] ->  [  AddCommMonoidₓ  α ] ->  [  Mul  α ] ->  [  LT  α ] ->  [  LinearOrder  α ] ->  (  x : α ) ->  x <   1 + x",
    " {  α :  Type  u } ->  [  Zero  α ] ->  [  One  α ] ->  [  Add  α ] ->  [  AddCommMonoidₓ  α ] ->  [  Mul  α ] ->  [  LT  α ] ->  [  LinearOrderₓ  α ] ->  (  x : α ) ->  x <   1 + x",
    " {  n :  ℕ } ->  ∃    (   m :  ℕ ) ,  m =  n +  1",
    " (  n :  ℕ ) ->  ∃    (   k :  ℕ ) ,  n ≤ k",
    " ∀   (  n  :  ℕ  )  ,  ∃    (   m :  ℕ ) ,  m > n",
    " (  n :  ℕ ) ->  ∃    (   m :  ℕ ) ,  n = m.succ",
    " {  n :  ℕ } ->  ∃    (   m :  ℕ ) ,  m = n.succ",
    " ∀   (  x  :  ℕ  )  ,  ∃    (   y :  ℕ ) ,  ∀   (  z  :  ℕ  )  ,   y < z →  x < z"]},
  {"theorem": "∀ (n : ℕ), n < Nat.succ n",
   "some-correct": null,
   "prompt": "Every natural number is less than its successor.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  n :  ℕ ) ->  n < n.succ",
    " {  n :  ℕ } ->  n < n.succ",
    " {  m :  ℕ } ->  m < m.succ",
    " (  m :  ℕ ) ->  m < m.succ",
    " (  k :  ℕ ) ->  k < k.succ",
    " (  n :  ℕ ) ->  n <  (   n +  1  )"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MeasurableSpace α] {s : Set α}, MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set is Lebesgue measurable.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Set  α } ->  (   MeasurableSet  s  )",
    " {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  {  s :  Set  α } ->  MeasurableSet  s",
    " {  α :  Type  u_1 } ->  MeasurableSpace  α",
    " {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  ∀   (  x  :  Set  α  )  ,  MeasurableSet  x",
    " {  α :  Type  u_1 } ->  [  MeasurableSpace  α ] ->  ∀   (  s  :  Set  α  )  ,  MeasurableSet  s"]},
  {"theorem":
   "∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : T2Space α] [inst_2 : MeasurableSpace α] [inst_3 : BorelSpace α]\n  {s : Set α}, coeFn MeasureTheory.volume.toOuterMeasure s = 0 → MeasurableSet s",
   "some-correct": null,
   "prompt": "Every set of Borel measure zero is Lebesgue measurable.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  [  TopologicalSpace  α ] ->  [  T2Space  α ] ->  [  MeasurableSpace  α ] ->  [  BorelSpace  α ] ->  {  s :  Set  α } ->  (  hs :   MeasureTheory.MeasureSpace.volume  s =  0 ) ->  MeasurableSet  s"]},
  {"theorem": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)], ¬∃ a, a ^ 2 = p",
   "some-correct": null,
   "prompt": "No prime number is a perfect square.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   a :  ℕ ) ,   a ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   n :  ℕ ) ,   n * n = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :  p ≠  2 ) ->  ¬  ∃    (   n :  ℕ ) ,   n * n = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   t :  ℕ ) ,   t * t = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃     m  ,  p =  m * m",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  ∀   (  n  :  ℕ  )  ,   p =  n ^  2 ↔   p =  0 ∧  n =  0",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ∀   (  m  :  ℕ  )  ,   m ^  2 ≠ p",
    " {  n :  ℕ } ->  [  Fact   (   Nat.Prime  n  ) ] ->  ¬  ∃    (   m :  ℕ ) ,   m ^  2 = n",
    " {  n :  ℕ } ->  [  Fact   (   Nat.Prime  n  ) ] ->  ¬  ∃    (   m :  ℕ ) ,   m * m = n",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ∀   (  n  :  ℕ  )  ,   n ≠  0 →  ¬   n * n = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   m :  ℕ ) ,   m ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   m :  ℕ ) ,  p =  m ^  2",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :  p ≠  2 ) ->  ¬  ∃    (   a :  ℕ ) ,   a * a = p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  ∀   (  a  :  ℕ  )  ,   a ^  2 ≠ p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   m :  ℕ ) ,   m ^  2 = p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   n :  ℕ ) ,  p =  n * n",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  ¬  ∃    (   m :  ℕ ) ,   m * m = p"]},
  {"theorem": "∀ {p : ℕ}, Nat.Prime p → Odd p → 2 < p",
   "some-correct": null,
   "prompt": "Every odd prime number is greater than `2`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  p :  ℕ } ->  (  hpri :  Nat.Prime  p ) ->  (  hop :  Odd  p ) ->   2 < p",
    " {  p :  ℕ } ->  [ hpri :  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->   2 < p",
    " {  p :  ℕ } ->  (  h :   p %  2 =  1 ) ->  (  hp :  Fact   (   Nat.Prime  p  ) ) ->   2 < p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :  Odd  p ) ->   2 < p",
    " (  p :  ℕ ) ->  (  h_odd :   p %  2 =  1 ) ->  [  Fact   (   Nat.Prime  p  ) ] ->   2 < p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h :   p %  2 =  1 ) ->   2 < p",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  h_odd :   p %  2 =  1 ) ->   2 < p",
    " {  p :  ℕ } ->   Nat.Prime  p →    p %  2 =  1 →  p >  2",
    " {  n :  ℕ } ->  (  h_prime :  Nat.Prime  n ) ->  (  n_odd :   n %  2 =  1 ) ->   2 < n",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  p ≥  3",
    " {  p :  ℕ } ->   Nat.Prime  p →   Odd  p →   2 < p",
    " {  p :  ℕ } ->  [  Fact   (   Nat.Prime  p  ) ] ->  (  hp :  p ≠  2 ) ->   2 < p",
    " (  p :  ℕ ) ->  [ hpri :  Fact   (   Nat.Prime  p  ) ] ->   3 ≤ p",
    " {  p :  ℕ } ->  (  h_odd :   p %  2 =  1 ) ->  (  h_prime :  Fact   (   Nat.Prime  p  ) ) ->  p >  2",
    " (  p :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  p >  2",
    " {  p :  ℕ } ->  (  hp :  Nat.Prime  p ) ->  (  hpo :   p %  2 =  1 ) ->  p >  2",
    " (  p :  ℕ ) ->  [ hp :  Fact   (   Nat.Prime  p  ) ] ->  {  h :   p %  2 =  1 } ->   3 ≤ p"]},
  {"theorem":
   "∀ {a b c d e f g h : ℤ},\n  a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = e ^ 2 + f ^ 2 + g ^ 2 + h ^ 2 →\n    (a + b) * (a + b) + (c + d) * (c + d) = (e + f) * (e + f) + (g + h) * (g + h)",
   "some-correct": null,
   "prompt":
   "The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  a b c d e f g h :  ℤ } ->  (  ha :      a ^  2 +  b ^  2 +  c ^  2 +  d ^  2 =     e ^  2 +  f ^  2 +  g ^  2 +  h ^  2 ) ->     (   a + b  ) *  (   a + b  ) +   (   c + d  ) *  (   c + d  ) =    (   e + f  ) *  (   e + f  ) +   (   g + h  ) *  (   g + h  )",
    " {  a b :  ℕ } ->  (  h₁ :  ∃    (   m  n  p  q :  ℕ ) ,      m * m +  n * n +  p * p +  q * q = a ) ->  (  h₂ :  ∃    (   m'  n'  p'  q' :  ℕ ) ,      m' * m' +  n' * n' +  p' * p' +  q' * q' = b ) ->  ∃    (   m  n  p  q :  ℕ ) ,      m * m +  n * n +  p * p +  q * q =  a * b",
    " {  a b :  ℤ } ->  (  H1 :  ∃    (   x  y  z  w :  ℤ ) ,  a =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  (  H2 :  ∃    (   x  y  z  w :  ℤ ) ,  b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2 ) ->  ∃    (   x  y  z  w :  ℤ ) ,   a * b =     x ^  2 +  y ^  2 +  z ^  2 +  w ^  2",
    " {  m n :  ℕ } ->  (  hm :  ∃    (   a  b  c  d :  ℕ ) ,      a * a +  b * b +  c * c +  d * d = m ) ->  (  hn :  ∃    (   a  b  c  d :  ℕ ) ,      a * a +  b * b +  c * c +  d * d = n ) ->  ∃    (   x  y  z  w :  ℕ ) ,      x * x +  y * y +  z * z +  w * w =  m * n",
    " {  a b :  ℤ } ->  (  ha :  ∃    (   x  y  z  w :  ℤ ) ,  a =     x * x +  y * y +  z * z +  w * w ) ->  (  hb :  ∃    (   x  y  z  w :  ℤ ) ,  b =     x * x +  y * y +  z * z +  w * w ) ->  ∃    (   x  y  z  w :  ℤ ) ,   a * b =     x * x +  y * y +  z * z +  w * w",
    " {  x y :  ℤ } ->  (  hx :   (   ∃    (   a  b  c  d :  ℤ ) ,  x =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2  ) ∧  (   ∃    (   a  b  c  d :  ℤ ) ,  y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2  ) ) ->  ∃    (   a  b  c  d :  ℤ ) ,   x * y =     a ^  2 +  b ^  2 +  c ^  2 +  d ^  2"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : CompactSpace α], LocallyCompactSpace α",
   "some-correct": null,
   "prompt": "Every compact topological space is locally compact.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  [  CompactSpace  α ] ->  LocallyCompactSpace  α",
    " {  X :  Type  u_1 } ->  [  TopologicalSpace  X ] ->  [  CompactSpace  X ] ->  LocallyCompactSpace  X",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  [  CompactSpace  X ] ->  LocallyCompactSpace  X"]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α → β),\n  Continuous f → UniformContinuous f",
   "some-correct": null,
   "prompt": "Every continuous function is uniformly continuous.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  (  f :  α → β ) ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  h :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  SeparatedSpace  α ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f",
    " {  α :  Type  u_1 } ->  {  β :  Type  u_2 } ->  [  UniformSpace  α ] ->  [  UniformSpace  β ] ->  [  CompleteSpace  α ] ->  {  f :  α → β } ->  (  hf :  Continuous  f ) ->  UniformContinuous  f"]},
  {"theorem":
   "∀ (p : ℕ) [inst : Fact (Nat.Prime p)] (q : ℕ) [inst : Fact (Nat.Prime q)], p < 6 ∧ q < 6 ∧ p ≠ q → p + q ≠ 6",
   "some-correct": null,
   "prompt": "`6` is not the sum of two distinct prime numbers.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ¬  ∃    (   p  q :  ℕ ) ,   p ≠ q ∧   Nat.Prime  p ∧   Nat.Prime  q ∧   p + q =  6",
    " ∀   (  p  :  ℕ  )  [   Fact   (   Nat.Prime  p  ) ]  (  q  :  ℕ  )  [   Fact   (   Nat.Prime  q  ) ]  ,    p <  6 ∧   q <  6 ∧  p ≠ q →   p + q ≠  6",
    " ∀  p q   :  ℕ ,   p ≠ q →   p ≠  2 →   q ≠  2 →   p + q ≠  6",
    " (  p q :  ℕ ) ->  [  Fact   (   Nat.Prime  p  ) ] ->  [  Fact   (   Nat.Prime  q  ) ] ->  (  hpq :  p ≠ q ) ->   p + q ≠  6",
    " ∀   (  p q  :  ℕ  )  ,    p + q =  6 →   p ≠ q →   p ≤  3 ∧  q ≤  3",
    " ∀   {  x y  :  ℕ }  ,   x ≠ y →   6 ≠  x + y",
    " ¬  (   ∃    (   x  y :  ℕ ) ,   x ≠ y ∧   Nat.Prime  x ∧   Nat.Prime  y ∧   x + y =  6  )",
    " ∀   (  p q  :  ℕ  )  ,   Nat.Prime  p →   Nat.Prime  q →   p ≠ q →   p + q ≠  6",
    " ∀   (  p q  :  ℕ  )  ,   Prime  p →   Prime  q →   p ≠ q →   p + q ≠  6",
    " ∀   (  a b  :  ℕ  )  ,   Nat.Prime  a →   Nat.Prime  b →   a ≠ b →   a + b ≠  6"]},
  {"theorem": "∀ {X : Type u_1} [inst : Ringₓ X], IsUnit 1",
   "some-correct": null,
   "prompt": "The identity element in a ring is a unit.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  MulOneClass  α ] ->  IsUnit   1",
    " {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  IsUnit   1",
    " {  R :  Type  u } ->  [  Monoid  R ] ->  [  Ring  R ] ->  IsUnit   1",
    " {  R :  Type  u } ->  [  Monoid  R ] ->  [  Ringₓ  R ] ->  IsUnit   1",
    " {  R :  Type  u } ->  [  Monoidₓ  R ] ->  [  Ring  R ] ->  IsUnit   1",
    " {  R :  Type  u } ->  [  Monoidₓ  R ] ->  [  Ringₓ  R ] ->  IsUnit   1",
    " {  X :  Type  u_1 } ->  [  Ringₓ  X ] ->  IsUnit   (   1   : X )",
    " {  α :  Type  u } ->  [  MulOneClass  α ] ->  [  HasDistribNeg  α ] ->  IsUnit   1",
    " {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  [  HasDistribNeg  α ] ->  IsUnit   1",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  IsUnit   (   1   : α )",
    " {  α :  Type  u } ->  [  Ring  α ] ->  IsUnit   1",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  IsUnit   1",
    " {  α :  Type  u } ->  [  MulOneClass  α ] ->  (  a : α ) ->    1 * a = a",
    " {  α :  Type  u } ->  [  MulOneClassₓ  α ] ->  (  a : α ) ->    1 * a = a",
    " {  α :  Type  u } ->  [  Ring  α ] ->  (  a : α ) ->    (   1   : α ) * a = a",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  (  a : α ) ->    (   1   : α ) * a = a",
    " {  α :  Type  u } ->  [  Ringₓ  α ] ->  IsUnit   (   1   : α )",
    " {  R :  Type  u_1 } ->  [  Ring  R ] ->  IsUnit   1",
    " {  R :  Type  u_1 } ->  [  Ringₓ  R ] ->  IsUnit   1"]},
  {"theorem": "∀ {m n : ℕ}, m ≥ 0 → n ≥ 0 → m + n ≥ 0",
   "some-correct": null,
   "prompt": "The sum of two natural numbers is a natural number.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  m n :  ℕ } ->  (  hm :  m ≥  0 ) ->  (  hn :  n ≥  0 ) ->   m + n ≥  0",
    " {  a b :  ℕ } ->   (   a + b   :  ℕ ) =  a + b",
    " {  m n :  ℕ } ->   (   m + n   :  ℕ ) =  m + n"]},
  {"theorem": "∀ {G : Type u} [inst : Groupₓ G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "The identity element of a group has finite order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  G :  Type  u } ->  [  Group  G ] ->  IsOfFinOrder   1",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  IsOfFinOrder   1",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  IsOfFinOrder   (   1   : G )",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  g : G ) ->   IsOfFinOrder   1 ↔  IsOfFinOrder  g",
    " (  G :  Type  u_1 ) ->  [  Groupₓ  G ] ->  IsOfFinOrder   (   1   : G )"]},
  {"theorem": "∀ (p : ℕ), Nat.Prime p ↔ p = 2 ∨ p = 3 ∨ p = 5 ∨ p = 7",
   "some-correct": null,
   "prompt": "`7` is a prime number.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" Nat.Prime   7",
    " (  p :  ℕ ) ->   Nat.Prime  p ↔   p =  2 ∨   p =  3 ∨   p =  5 ∨  p =  7",
    " Fact   (   Nat.Prime   7  )"]},
  {"theorem": "∃ p q r, Prime p ∧ Prime q ∧ Prime r ∧ p < 8 ∧ q < 8 ∧ r < 8",
   "some-correct": null,
   "prompt": "There are `3` prime numbers below `8`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" ∃    (   p  q  r :  ℕ ) ,   Prime  p ∧   Prime  q ∧   Prime  r ∧   p <  8 ∧   q <  8 ∧  r <  8"]},
  {"theorem": "∀ {α : Type u} [inst : DecidableEq α] (s : Finset α), ∅ ⊂ s",
   "some-correct": null,
   "prompt": "The empty set is contained in every finite set.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  DecidableEq  α ] ->  (  s :  Finset  α ) ->   ∅ ⊆ s",
    " {  α :  Type  u } ->  (  s :  Finset  α ) ->   ∅ ⊆ s",
    " {  α :  Type  u_1 } ->  {  s :  Finset  α } ->   ∅ ⊆ s",
    " {  α :  Type  u_1 } ->  (  f :  Finset  α ) ->   ∅ ⊆ f",
    " {  α :  Type  u } ->  {  s :  Finset  α } ->   ∅ ⊆ s"]},
  {"theorem": "{α : Type u} → [inst : CommRing α] → CommMonoid α",
   "some-correct": null,
   "prompt": "Every commutative ring is a monoid.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  CommRing  α ] ->  CommMonoid  α",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  CommMonoidₓ  α",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  CommMonoid  α",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  CommMonoidₓ  α",
    " {  α :  Type  u_1 } ->  [  NonUnitalRing  α ] ->  Monoid  α",
    " {  α :  Type  u_1 } ->  [  NonUnitalRing  α ] ->  Monoidₓ  α",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  Monoid  α",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  Monoidₓ  α",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  Monoid  α",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  Monoidₓ  α",
    " {  R :  Type  u_1 } ->  [  CommRing  R ] ->  Monoid  R",
    " {  R :  Type  u_1 } ->  [  CommRing  R ] ->  Monoidₓ  R",
    " {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  Monoid  R",
    " {  R :  Type  u_1 } ->  [  CommRingₓ  R ] ->  Monoidₓ  R",
    " {  α :  Type  u_1 } ->  [  CommRing  α ] ->  Monoid  α",
    " {  α :  Type  u_1 } ->  [  CommRing  α ] ->  Monoidₓ  α",
    " {  α :  Type  u_1 } ->  [  CommRingₓ  α ] ->  Monoid  α",
    " {  α :  Type  u_1 } ->  [  CommRingₓ  α ] ->  Monoidₓ  α",
    " {  β :  Type  u_1 } ->  [  CommRing  β ] ->  Monoid  β",
    " {  β :  Type  u_1 } ->  [  CommRing  β ] ->  Monoidₓ  β",
    " {  β :  Type  u_1 } ->  [  CommRingₓ  β ] ->  Monoid  β",
    " {  β :  Type  u_1 } ->  [  CommRingₓ  β ] ->  Monoidₓ  β",
    " {  R :  Type  u } ->  [  CommRing  R ] ->  Monoid  R",
    " {  R :  Type  u } ->  [  CommRing  R ] ->  Monoidₓ  R",
    " {  R :  Type  u } ->  [  CommRingₓ  R ] ->  Monoid  R",
    " {  R :  Type  u } ->  [  CommRingₓ  R ] ->  Monoidₓ  R"]},
  {"theorem": "∀ (n : ℕ), n ≠ 2 → n ≠ 5 → Fintype.card (Finₓ n) ≠ 10",
   "some-correct": null,
   "prompt": "There is no field of order `10`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  n :  ℕ ) ->  (  h :  n ≠  2 ) ->  (  h' :  n ≠  5 ) ->   Fintype.card   (   Finₓ  n  ) ≠  10",
    " [  Nonempty   ℤ ] ->  {  F :  Type  u_1 } ->  [  Fintype  F ] ->  [  Field  F ] ->   Fintype.card  F ≠  10",
    " ¬  Nonempty   (   Field   (   Fin   10  )  )",
    " ¬  Nonempty   (   Field   (   Finₓ   10  )  )",
    " ¬  IsPrimePow   10",
    " (  n :  ℕ ) ->   ¬  IsPrimePow   10 →      (  n   :  ℤ ) ^  2 + n ≠  0 →  Nonempty   (   Field   (   Fin  n  )  )",
    " (  n :  ℕ ) ->   ¬  IsPrimePow   10 →      (  n   :  ℤ ) ^  2 + n ≠  0 →  Nonempty   (   Field   (   Finₓ  n  )  )"]},
  {"theorem": "∀ {n : ℕ}, Odd n → ∃ m k, k ≠ m ∧ k + m = n",
   "some-correct": null,
   "prompt":
   "Every odd natural number is the sum of two distinct natural numbers.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  n :  ℕ } ->  (  hn :  Odd  n ) ->  ∃    (   m  k :  ℕ ) ,   k ≠ m ∧   k + m = n",
    " {  n :  ℕ } ->  (  h_odd :  Odd  n ) ->  (   ∃    (   m  k :  ℕ ) ,   n =  m + k ∧  m ≠ k  )",
    " {  n :  ℕ } ->  (  h_odd :  Odd  n ) ->  ∃    (   x  y :  ℕ ) ,   x ≠ y ∧  n =  x + y",
    " {  n :  ℕ } ->  (  h_odd :  Odd  n ) ->  ∃    (   a  b :  ℕ ) ,   a ≠ b ∧   a + b = n",
    " {  n :  ℕ } ->  (  h :  Odd  n ) ->  ∃    (   x  y :  ℕ ) ,   x ≠ y ∧  n =  x + y",
    " {  n :  ℕ } ->  (  hn :  Odd  n ) ->  ∃    (   a  b :  ℕ ) ,   a ≠ b ∧   a + b = n",
    " {  n :  ℕ } ->    n %  2 =  1 →  ∃    (   x  y :  ℕ ) ,   x ≠ y ∧  n =  x + y",
    " {  n :  ℕ } ->  (  h_odd :  Odd  n ) ->  ∃    (   m1  m2 :  ℕ ) ,    m1 + m2 = n ∧  m1 ≠ m2",
    " {  n :  ℕ } ->  (  h_odd :   n %  2 =  1 ) ->  ∃    (   m  k :  ℕ ) ,      2 * m +   2 * k = n ∧  m ≠ k",
    " {  n :  ℕ } ->  (  h :  Odd  n ) ->  ∃    (   i  j :  ℕ ) ,   i ≠ j ∧   i + j = n",
    " {  n :  ℕ } ->  (  h_odd :  Odd  n ) ->  ∃     i  j  :  ℕ ,   i ≠ j ∧   i + j = n",
    " {  n :  ℕ } ->  (  h_odd :  Odd  n ) ->  ∃    (   m  k :  ℕ ) ,   m ≠ k ∧  n =  m + k",
    " {  n :  ℕ } ->  (  h_odd :  ¬  Even  n ) ->  ∃     i  j  ,   i ≠ j ∧   i + j = n",
    " {  n :  ℕ } ->  (  hn :   n %  2 =  1 ) ->  ∃    (   s  t :  ℕ ) ,   s ≠ t ∧  n =  s + t",
    " {  n :  ℕ } ->  (  hn :  Odd  n ) ->  ∃    (   k  m :  ℕ ) ,    1 ≤ k ∧   k < m ∧   m < n ∧   ↑  (   k + m  ) = n",
    " {  n :  ℕ } ->  (  h_odd :   n %  2 =  1 ) ->  ∃    (   m  k :  ℕ ) ,   m ≠ k ∧   m + k = n",
    " {  n :  ℕ } ->   Odd  n →  ∃    (   i  j :  ℕ ) ,   i ≠ j ∧   i + j = n"]},
  {"theorem": "∀ (G : Type u_1) [inst : Groupₓ G], IsOfFinOrder 1",
   "some-correct": null,
   "prompt": "Every element in the trivial group has finite order.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  G :  Type  u_1 ) ->  [  Groupₓ  G ] ->  IsOfFinOrder   (   1   : G )",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (  h :  G =  1 ) ->  ∀   (  x  : G  )  ,  IsOfFinOrder  x",
    " (  G :  Type* ) ->  [  Groupₓ  G ] ->  (  g : G ) ->   g =  1 ↔  IsOfFinOrder  g"]},
  {"theorem": "∀ {n : ℕ}, Even n → Even (n * n)",
   "some-correct": null,
   "prompt": "The square of an even number is even.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  m :  ℕ } ->  (  h :  Even  m ) ->  Even   (   m ^  2  )",
    " {  n :  ℕ } ->  (  h :  Even  n ) ->  Even   (   n * n  )",
    " (  n :  ℤ ) ->   Even  n →  Even   (   n ^  2  )",
    " {  n :  ℕ } ->   Even  n →  Even   (   n ^  2  )",
    " {  m :  ℕ } ->  ∀   (  h  :  Even  m  )  ,  Even   (   m * m  )",
    " {  n :  ℕ } ->  (  hn :  Even  n ) ->  Even   (   n * n  )",
    " {  m :  ℕ } ->   Even   (   m * m  ) ↔  Even  m",
    " {  n :  ℕ } ->  (  h :  Even  n ) ->  Even   (   n ^  2  )",
    " {  m :  ℕ } ->   Even  m →  Even   (   m ^  2  )",
    " {  m :  ℕ } ->  (  h :  Even  m ) ->  Even   (   m * m  )",
    " {  n :  ℕ } ->   Even  n →  Even   (   n ^  2  )",
    " {  n :  ℕ } ->   Even  n →  Even   (   n * n  )",
    " (  n :  ℕ ) ->   Odd  n →  Even   (   n ^  2  )",
    " {  n :  ℕ } ->   Even   (    2 * n  ) →  Even   (   n ^  2  )",
    " {  x :  ℕ } ->  [  Fact   (   Even  x  ) ] ->  Even   (   x * x  )"]},
  {"theorem":
   "∀ (K : Type u) [inst : CommGroup K] [inst : Semiring K] [inst : Monoid K] [inst : DivisionRing K], IsField K",
   "some-correct": null,
   "prompt": "Every commutative division ring is a field.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" (  K :  Type  u ) ->  [  CommGroup  K ] ->  [  Semiring  K ] ->  [  Monoid  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommGroup  K ] ->  [  Semiring  K ] ->  [  Monoidₓ  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommGroup  K ] ->  [  Semiringₓ  K ] ->  [  Monoid  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommGroup  K ] ->  [  Semiringₓ  K ] ->  [  Monoidₓ  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommGroupₓ  K ] ->  [  Semiring  K ] ->  [  Monoid  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommGroupₓ  K ] ->  [  Semiring  K ] ->  [  Monoidₓ  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommGroupₓ  K ] ->  [  Semiringₓ  K ] ->  [  Monoid  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommGroupₓ  K ] ->  [  Semiringₓ  K ] ->  [  Monoidₓ  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " {  K :  Type  u } ->  [  DivisionRing  K ] ->  [  CommRing  K ] ->  IsField  K",
    " {  K :  Type  u } ->  [  DivisionRing  K ] ->  [  CommRingₓ  K ] ->  IsField  K",
    " {  R :  Type  u } ->  [  CommRing  R ] ->  [  DivisionRing  R ] ->  IsField  R",
    " {  R :  Type  u } ->  [  CommRingₓ  R ] ->  [  DivisionRing  R ] ->  IsField  R",
    " {  α :  Type  u } ->  [  CommRing  α ] ->  [  DivisionRing  α ] ->  IsField  α",
    " {  α :  Type  u } ->  [  CommRingₓ  α ] ->  [  DivisionRing  α ] ->  IsField  α",
    " {  K :  Type  u } ->  [  CommRing  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " {  K :  Type  u } ->  [  CommRingₓ  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommRing  K ] ->  [  DivisionRing  K ] ->  IsField  K",
    " (  K :  Type  u ) ->  [  CommRingₓ  K ] ->  [  DivisionRing  K ] ->  IsField  K"]},
  {"theorem": "∀ {α : Type u} [inst : Group α] (a : α), id a = a",
   "some-correct": null,
   "prompt":
   "The image of the identity element under the identity map is the identity element.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  Group  α ] ->  (  a : α ) ->   id  a = a",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  (  a : α ) ->   id  a = a",
    " {  α :  Type  u } ->  [  Monoid  α ] ->  (  x : α ) ->    (  id   :  α → α )  x = x",
    " {  α :  Type  u } ->  [  Monoidₓ  α ] ->  (  x : α ) ->    (  id   :  α → α )  x = x",
    " {  α :  Type  u_1 } ->  (  x : α ) ->   id  x = x",
    " {  α :  Type  u } ->  (  x : α ) ->   id  x = x",
    " {  α :  Type  u } ->  [  Group  α ] ->  (  a : α ) ->   (   id  a   : α ) = a",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  (  a : α ) ->   (   id  a   : α ) = a",
    " {  α :  Type  u } ->  {  f :  α → α } ->  [  Monoidₓ  α ] ->  (  h :  IsMonoidHom  f ) ->   f   1 =  1",
    " (  k :  Type  u_1 ) ->  (  α :  Type  u_2 ) ->  [ _inst_1 :  Group  α ] ->   (    (    @ id   (   k → α  )   :   (   k → α  ) →  (   k → α  ) )   1  ) =  1",
    " (  k :  Type  u_1 ) ->  (  α :  Type  u_2 ) ->  [ _inst_1 :  Groupₓ  α ] ->   (    (    @ id   (   k → α  )   :   (   k → α  ) →  (   k → α  ) )   1  ) =  1",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  Monoidₓ  α ] ->  [  Monoidₓ  β ] ->  (  f :  α → β ) ->  (  h :  IsMonoidHom  f ) ->   f   1 =  1",
    " {  α :  Type  u } ->  [  Group  α ] ->   id   1 =  1",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->   id   1 =  1",
    " {  α :  Type  u } ->  {  β :  Type  v } ->  [  Groupₓ  α ] ->  [  Groupₓ  β ] ->  {  f :  α → β } ->  (  hf :  IsGroupHom  f ) ->   f   (   1   : α ) =  1",
    " {  α :  Type  u } ->  (  x : α ) ->  [  Group  α ] ->   id  x = x",
    " {  α :  Type  u } ->  (  x : α ) ->  [  Groupₓ  α ] ->   id  x = x",
    " {  α :  Type  u } ->  [  Semigroup  α ] ->  (  x : α ) ->   id  x = x",
    " {  α :  Type  u } ->  [  Semigroupₓ  α ] ->  (  x : α ) ->   id  x = x"]},
  {"theorem": "∀ {α : Type u} (a : α), Function.IsFixedPt id a",
   "some-correct": null,
   "prompt":
   "Every point is a fixed point of the identity function on a space.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  (  a : α ) ->  Function.IsFixedPt  id a",
    " {  α :  Type  u } ->  {  x : α } ->  Function.IsFixedPt  id x",
    " {  α :  Type  u } ->  (  x : α ) ->  Function.IsFixedPt  id x",
    " {  α :  Type  u } ->  (  x : α ) ->  Function.IsFixedPt   (    @ id  α  ) x",
    " {  α :  Type  u_1 } ->  (  x : α ) ->  Function.IsFixedPt  id x",
    " {  α :  Type  u_1 } ->  (  a : α ) ->  Function.IsFixedPt  id a",
    " {  α :  Type* } ->  (  a : α ) ->  Function.IsFixedPt  id a"]},
  {"theorem":
   "∀ {α : Type u} [inst : PseudoMetricSpace α] (a : α), Metric.diam (?m.2691279 a) = 0",
   "some-correct": null,
   "prompt": "The diameter of a singleton space is `0`.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  PseudoMetricSpace  α ] ->  (  a : α ) ->   Metric.diam   (    {  aa }  {    aa    }   :  Set  α ) =  0",
    " {  α :  Type  u } ->  [  PseudoEmetricSpace  α ] ->  {  a : α } ->   Emetric.diam   (    {  aa }  {    aa    }   :  Set  α ) =  0"]},
  {"theorem": "∀ {α : Type u} [inst : Group α], Nonempty α",
   "some-correct": null,
   "prompt": "Every group is non-empty.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  Group  α ] ->  Nonempty  α",
    " {  α :  Type  u } ->  [  Groupₓ  α ] ->  Nonempty  α",
    " {  G :  Type  u } ->  [  Group  G ] ->  Nonempty  G",
    " {  G :  Type  u } ->  [  Groupₓ  G ] ->  Nonempty  G",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  Nonempty  G",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  Nonempty  G",
    " {  M :  Type  u_1 } ->  [  Group  M ] ->  Nonempty  M",
    " {  M :  Type  u_1 } ->  [  Groupₓ  M ] ->  Nonempty  M",
    " {  α :  Type  u_1 } ->  [  Group  α ] ->  Nonempty  α",
    " {  α :  Type  u_1 } ->  [  Groupₓ  α ] ->  Nonempty  α",
    " {  G :  Type  u_5 } ->  [  Group  G ] ->  Nonempty  G",
    " {  G :  Type  u_5 } ->  [  Groupₓ  G ] ->  Nonempty  G",
    " {  G :  Type  u_1 } ->  [  Group  G ] ->  (   Nonempty  G  )",
    " {  G :  Type  u_1 } ->  [  Groupₓ  G ] ->  (   Nonempty  G  )"]},
  {"theorem":
   "∀ {α : Type u} [inst : TopologicalSpace α] {x : α}, IsConnected (ConnectedComponent x)",
   "some-correct": null,
   "prompt": "All connected components of a topological space are connected.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  x : α } ->  IsConnected   (   ConnectedComponent  x  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  ∀  x   : α ,  IsConnected   (   ConnectedComponent  x  )",
    " {  X :  Type  u } ->  [  TopologicalSpace  X ] ->  ∀  U   :  Set  X ,   IsConnected  U →  ∀  x   : X ,   x ∈ U →  IsConnected   (   ConnectedComponent  x  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  ∀   (  x  : α  )  ,  IsConnected   (   ConnectedComponent  x  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  {  x : α } ->  IsConnected   (   ConnectedComponent  x  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  x : α ) ->  IsConnected   (   ConnectedComponent  x  )",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  x :  ConnectedComponents  α ) ->  IsConnected  x",
    " {  α :  Type  u } ->  [  TopologicalSpace  α ] ->  (  x : α ) ->  IsConnected   (   ConnectedComponent  x  )"]},
  {"theorem":
   "∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ringₓ B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B}\n  (hx : IsIntegral A x), ∃ p, ?m.2769709 hx p",
   "some-correct": null,
   "prompt": "The ring of integers has a maximal ideal.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  A :  Type  u_1 } ->  {  B :  Type  u_2 } ->  [  Field  A ] ->  [  Ringₓ  B ] ->  [  IsDomain  B ] ->  [  Algebra  A B ] ->  {  x : B } ->  (  hx :  IsIntegral  A x ) ->  ∃     p  , p.is_maximal"]},
  {"theorem": "PythagoreanTriple 3 4 5",
   "some-correct": null,
   "prompt": "The numbers `3`, `4` and `5` form a Pythagorean triple.",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" PythagoreanTriple   3  4  5", " PythagoreanTriple   3  4  5"]},
  {"theorem":
   "∀ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroupₓ V] [inst_2 : Module K V],\n  Basis Empty K V → Nontrivial V",
   "some-correct": null,
   "prompt": "A vector space with the empty set as basis is trivial. ",
   "correct": null,
   "comments": "",
   "all-elabs":
   [" {  K :  Type  u } ->  {  V :  Type  v } ->  [  DivisionRing  K ] ->  [  AddCommGroupₓ  V ] ->  [  Module  K V ] ->  (  h :  Basis  Empty K V ) ->  Nontrivial  V"]}],
 "elaborated": 37}