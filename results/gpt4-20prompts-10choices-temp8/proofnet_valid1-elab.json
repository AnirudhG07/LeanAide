{"total-prompts": 25,
 "temperature": 0.8,
 "query-number": 5,
 "number-similar-sentences": 10,
 "include-fixed": false,
 "failures":
 ["If `k ≥ 2` and `𝑥 ∈ ℝ^k`, prove that there exists `𝑦 ∈ ℝ^k` such that `𝑦 ≠ 0` but `𝑥 ⋅ 𝑦 = 0`.",
  "Let `X` be a metric space in which every infinite subset has a limit point. Prove that `X` is separable.",
  "Suppose `E⊆ℝ^k` is uncountable, and let `P` be the set of condensation points of `E`. Prove that `P` is perfect.",
  "If `Σ a_n` converges, and if `{b_n}` is monotonic and bounded, prove that `Σ a_n b_n` converges.",
  "If `f` is defined on `E`, the graph of `f` is the set of points `(x, f(x))`, for `x ∈ E`. In particular, if `E` is a set of real numbers, and `f` is real-valued, the graph of `f` is a subset of the plane. Suppose `E` is compact, and prove that `f` is continuous on `E` if and only if its graph is compact."],
 "elaborated-prompts":
 [{"theorem": "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
   "some-correct": null,
   "prompt":
   "If `r` is rational (`r ≠ 0`) and `x` is irrational, prove that `r+x` is irrational.",
   "groups":
   [["∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {x : ℝ} (r : ℚ), r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x)",
     "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {x : ℝ} {r : ℚ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {x : ℝ} (r : ℚ), r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) ",
    "∀ {r : ℚ} {x : ℝ}, r ≠ 0 → Irrational x → Irrational (↑r + x) "]},
  {"theorem": "¬∃ q, q ^ 2 = 12",
   "some-correct": true,
   "prompt": "Prove that there is no rational number whose square is `12`.",
   "groups":
   [["¬∃ q, q ^ 2 = 12", "¬∃ q, q ^ 2 = 12", "¬∃ q, q ^ 2 = 12"],
    ["¬∃ q, q * q = 12", "¬∃ q, q * q = 12", "¬∃ q, q * q = 12"],
    ["Irrational (Real.sqrt 12)", "Irrational (Real.sqrt 12)"],
    ["¬∃ a b, b ≠ 0 ∧ a * a = 12 * (b * b)"]],
   "correct": false,
   "comments": "It takes `q` to be a natural number.",
   "all-elabs":
   ["¬∃ (q : ℚ), q * q = 12 ",
    "¬∃ (q : ℚ), q ^ 2 = 12 ",
    "¬∃ q : ℚ, q ^ 2 = 12 ",
    "Irrational (Real.sqrt 12) ",
    "¬∃ (a b : ℤ), b ≠ 0 ∧ (a * a = 12 * (b * b)) ",
    "¬∃ q : ℚ, q * q = 12 ",
    "¬∃ (q : ℚ), q ^ 2 = 12 ",
    "Irrational (Real.sqrt 12) ",
    "¬∃ q : ℚ, q * q = 12 "]},
  {"theorem":
   "∀ (A : Set ℝ), Set.Nonempty A → BddBelow A → sInf A = -sSup (-A)",
   "some-correct": null,
   "prompt":
   "Let `A` be a nonempty set of real numbers which is bounded below. Let `-A` be the set of all numbers `-x`, where `x ∈ A`. Prove that `inf A = -sup (-A)`.",
   "groups":
   [["∀ (A : Set ℝ), Set.Nonempty A → BddBelow A → sInf A = -sSup (-A)",
     "∀ (A : Set ℝ), Set.Nonempty A → BddBelow A → sInf A = -sSup (Neg.neg '' A)",
     "∀ {A : Set ℝ}, Set.Nonempty A → BddBelow A → sInf A = -sSup (-A)",
     "∀ (A : Set ℝ), Set.Nonempty A → BddBelow A → sInf A = -sSup (Neg.neg '' A)",
     "∀ {A : Set ℝ}, Set.Nonempty A → BddBelow A → sInf A = -sSup (Neg.neg '' A)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ (A : Set ℝ), Set.Nonempty A → BddBelow A → sInf A = -sSup (-A) ",
    "∀ (A : Set ℝ), Set.Nonempty A → BddBelow A → sInf A = -sSup (Neg.neg '' A) ",
    "∀ {A : Set ℝ}, Set.Nonempty A → BddBelow A → sInf A = -sSup (-A) ",
    "∀ (A : Set ℝ), Set.Nonempty A → BddBelow A → sInf A = -sSup (Neg.neg '' A) ",
    "∀ {A : Set ℝ}, Set.Nonempty A → BddBelow A → sInf A = -sSup (Neg.neg '' A) "]},
  {"theorem": "∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ ?m.1464420 z r w = 1 ∧ z = r * w",
   "some-correct": false,
   "prompt":
   "If `z` is a complex number, prove that there exists an `r ≥ 0` and a complex number `w` with `| w | = 1` such that `z = rw`.",
   "groups":
   [["∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ ?m.1464420 z r w = 1 ∧ z = r * w",
     "∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ ?m.1464420 z r w = 1 ∧ z = r * w"],
    ["∀ (z : ℂ), ∃ r w, r ≥ 0 ∧ ?m.1466215 z r w = 1 ∧ z = r • w",
     "∀ (z : ℂ), ∃ r w, r ≥ 0 ∧ ?m.1466215 z r w = 1 ∧ z = r • w"],
    ["∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ ?m.1464026 z r w = 1 ∧ z = ↑r * w"],
    ["∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ ↑Complex.abs w = 1 ∧ z = r * w"],
    ["∀ (z : ℂ), ∃ r w, r ≥ 0 ∧ ?m.1465903 z r w = 1 ∧ z = r * w"]],
   "correct": false,
   "comments": "Absolute value not picked up. For others, coercion is not recognized, or r is taken to be complex.",
   "all-elabs":
   ["∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), 0 ≤ r ∧ ↑Complex.abs w = 1 ∧ z = ↑r * w ",
    "∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ ↑Complex.abs w = 1 ∧ z = r * w ",
    "∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ Complex.abs w = 1 ∧ z = r * w ",
    "∀ (z : ℂ), ∃ r w, r ≥ 0 ∧ ↑Complex.abs w = 1 ∧ z = r * w ",
    "∀ (z : ℂ), ∃ r w, 0 ≤ r ∧ ↑Complex.abs w = 1 ∧ z = r * w ",
    "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ ↑Complex.abs w = 1 ∧ z = r • w ",
    "∀ (z : ℂ), ∃ (r : ℝ) (w : ℂ), r ≥ 0 ∧ ↑Complex.abs w = 1 ∧ z = r • w "]},
  {"theorem":
   "∀ {x y : ℂ}, ↑Complex.abs (↑(↑Complex.abs x) - ↑(↑Complex.abs y)) ≤ ↑Complex.abs (x - y)",
   "some-correct": true,
   "prompt": "If `x, y` are complex, prove that `||x|-|y|| ≤ |x-y|`.",
   "groups":
   [["∀ {x y : ℂ}, ↑Complex.abs (↑(↑Complex.abs x) - ↑(↑Complex.abs y)) ≤ ↑Complex.abs (x - y)"]],
   "correct": false,
   "comments": "Coercion not recognized if put explicitly",
   "all-elabs":
   ["∀ {x y : ℂ}, Complex.abs (Complex.abs x - Complex.abs y) ≤ Complex.abs (x - y) "]},
  {"theorem":
   "∀ {k : ℕ} [inst : LinearOrderedField ℝ] [inst_1 : NormedAddCommGroup (Fin k → ℝ)] [inst_2 : NormedSpace ℝ (Fin k → ℝ)]\n  {x y : Fin k → ℝ} {r d : ℝ},\n  k ≥ 3 →\n    dist x y = d →\n      d > 0 → r > 0 → 2 * r > d → ∃ f, Function.Injective f ∧ ∀ (n : ℤ), dist (f n) x = r ∧ dist (f n) y = r",
   "some-correct": null,
   "prompt":
   "Suppose `k ≥ 3`, `x, y ∈ ℝ^k`, `|x - y| = d > 0`, and `r > 0`. Prove that if `2r > d`, there are infinitely many `z ∈ ℝ^k` such that `|z-x|=|z-y|=r`.",
   "groups":
   [["∀ {k : ℕ} [inst : LinearOrderedField ℝ] [inst_1 : NormedAddCommGroup (Fin k → ℝ)] [inst_2 : NormedSpace ℝ (Fin k → ℝ)]\n  {x y : Fin k → ℝ} {r d : ℝ},\n  k ≥ 3 →\n    dist x y = d →\n      d > 0 → r > 0 → 2 * r > d → ∃ f, Function.Injective f ∧ ∀ (n : ℤ), dist (f n) x = r ∧ dist (f n) y = r"],
    ["∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {x y : E} {r d : ℝ},\n  3 ≤ FiniteDimensional.finrank ℝ E →\n    dist x y = d → 0 < d → 0 < r → 2 * r > d → ∃ A, Set.Infinite A ∧ ∀ (z : E), z ∈ A → dist z x = r ∧ dist z y = r"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {x y : E} {r d : ℝ},\n  3 ≤ FiniteDimensional.finrank ℝ E →\n  dist x y = d → 0 < d → 0 < r → 2 * r > d → ∃ A : Set E, Set.Infinite A ∧ ∀ z, z ∈ A → dist z x = r ∧ dist z y = r ",
    "∀ {k : ℕ} [inst : LinearOrderedField ℝ] [inst_1 : NormedAddCommGroup (Fin k → ℝ)] [inst_2 : NormedSpace ℝ (Fin k → ℝ)]\n  {x y : Fin k → ℝ} {r d : ℝ},\n  k ≥ 3 → dist x y = d → d > 0 → r > 0 → 2 * r > d → ∃ f : ℤ → Fin k → ℝ, Function.Injective f ∧ ∀ n : ℤ, dist (f n) x = r ∧ dist (f n) y = r "]},
  {"theorem":
   "∀ {k : ℝ} {a b c r : ℝ}, (∀ (x : ℝ), |x - a| = 2 * |x - b| ↔ |x - c| = r) → 3 * c = 4 * b - a ∧ 3 * r = 2 * |b - a|",
   "some-correct": false,
   "prompt":
   "Suppose `a, b ∈ ℝ^k`. Find `c ∈ ℝ^k` and `r > 0` such that `|x-a|=2|x-b|` if and only if `| x - c | = r`. Prove that `3c = 4b - a` and `3r = 2 |b - a|`.",
   "groups":
   [["∀ {k : ℝ} {a b c r : ℝ}, (∀ (x : ℝ), |x - a| = 2 * |x - b| ↔ |x - c| = r) → 3 * c = 4 * b - a ∧ 3 * r = 2 * |b - a|"],
    ["∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace V]\n  [inst_3 : NormedAddTorsor V V] {a b c : V} {r : ℝ},\n  (∀ (x : V), dist x a = 2 * dist x b ↔ dist x c = r) → 3 • c = 4 • b - a ∧ 3 * r = 2 * dist b a"]],
   "correct": false,
   "comments": "a b c are taken to be in ℝ. In others, scalar multiplication not defined for `nat`, otherwise could be correct and a generalization too.",
   "all-elabs":
   ["∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} {r : ℝ},\n  (∀ x : P, dist x a = 2 * dist x b ↔ dist x c = r) → 3 • c = 4 • b - a ∧ 3 * r = 2 * dist b a ",
    "∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace V] [inst_3 : NormedAddTorsor V V],\n  ∀ {a b c : V} {r : ℝ},\n    (∀ x, dist x a = 2 * dist x b ↔ dist x c = r) →\n      3 • c = 4 • b - a ∧ 3 * r = 2 * dist b a ",
    "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} (r : ℝ),\n  (∀ x : P, dist x a = 2 * dist x b ↔ dist x c = r) →\n    3 • c = 4 • b - a ∧ 3 * r = 2 * dist b a ",
    "∀ {k a b c : ℝ} {r : ℝ},\n  (∀ (x : ℝ), |x - a| = 2 * |x - b| ↔ |x - c| = r) →\n    3 * c = 4 * b - a ∧ 3 * r = 2 * |b - a| ",
    "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P] [inst_3 : NormedAddTorsor V P],\n  ∀ {a b c : P} {r : ℝ},\n    (∀ x : P, dist x a = 2 * dist x b ↔ dist x c = r) →\n      3 • c = 4 • b - a ∧ 3 * r = 2 * dist b a ",
    "∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]\n  [inst_3 : NormedAddTorsor V P] {a b c : P} {r : ℝ},\n  (∀ x, dist x a = 2 * dist x b ↔ dist x c = r) → 3 • c = 4 • b - a ∧ 3 * r = 2 * dist b a "]},
  {"theorem":
   "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, t₁ ⊆ s ∧ t₂ ⊆ s ∧ Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂",
   "some-correct": null,
   "prompt":
   "Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.",
   "groups":
   [["∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, t₁ ⊆ s ∧ t₂ ⊆ s ∧ Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂"],
    ["∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ P C, Perfect P ∧ Set.Countable C ∧ s = P ∪ C"],
    ["∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t, Set.Countable t ∧ s = s \\ t ∪ s ∩ t ∧ Perfect (s \\ t)"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s →\n    ∃ (P : Set α), ∃ (C : Set α),\n      Perfect P ∧ Set.Countable C ∧ s = P ∪ C ",
    "∀ {α : Type u} [inst : MetricSpace α] [inst_2 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ P A, Perfect P ∧ Set.Countable A ∧ s = P ∪ A ",
    "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ P A, Perfect P ∧ Set.Countable A ∧ s = P ∪ A ",
    "forall {α : Type u} [inst : MetricSpace α] [TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t, Set.Countable t ∧ s = (s \\ t) ∪ (s ∩ t) ∧ Perfect (s \\ t) ",
    "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, t₁ ⊆ s ∧ t₂ ⊆ s ∧ Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂ ",
    "∀ {α : Type u} [inst : MetricSpace α] [inst_2 : TopologicalSpace.SeparableSpace α] {C : Set α},\n  IsClosed C → ∃ P V, Perfect P ∧ Set.Countable V ∧ C = P ∪ V ",
    "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂ ",
    "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂ ",
    "forall {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, Perfect t₁ ∧ Set.Countable t₂ ∧ s = t₁ ∪ t₂ ",
    "∀ {α : Type u} [inst : MetricSpace α] [inst_1 : TopologicalSpace.SeparableSpace α] {s : Set α},\n  IsClosed s → ∃ t₁ t₂, Set.Countable t₁ ∧ Perfect t₂ ∧ s = t₁ ∪ t₂ "]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrderedRing α] [inst_2 : OrderTopology α]\n  [inst_3 : TopologicalSpace β] {s : β → α} {a : α} {f : Filter β},\n  Filter.Tendsto s f (nhds a) → Filter.Tendsto (fun x => |s x|) f (nhds |a|)",
   "some-correct": false,
   "prompt":
   "Prove that convergence of `{s_n}` implies convergence of `{|s_n|}`.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrderedRing α] [inst_2 : OrderTopology α]\n  [inst_3 : TopologicalSpace β] {s : β → α} {a : α} {f : Filter β},\n  Filter.Tendsto s f (nhds a) → Filter.Tendsto (fun x => |s x|) f (nhds |a|)"]],
   "correct": false,
   "comments": "The statement is a bit ambiguous, by convergence does it mean lim n -> infty? In that case, we want the at_top filter, this is for any filter.",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrderedRing α] [inst_2 : OrderTopology α]\n  [inst_3 : TopologicalSpace β] {s : β → α} {a : α} {f : Filter β},\n  Filter.Tendsto s f (nhds a) → Filter.Tendsto (fun x => abs (s x)) f (nhds (abs a)) "]},
  {"theorem":
   "∀ (s : ℕ → ℝ),\n  s 0 = Real.sqrt 2 →\n    (∀ (n : ℕ), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) →\n      (∃ l, Filter.Tendsto s Filter.atTop (nhds l)) ∧ ∀ (n : ℕ), s n < 2",
   "some-correct": null,
   "prompt":
   "If `s_1=√2`, and `s_{n+1}=√(2+√s_n)` for `(n=1,2,3, ...)`, prove that `{s_n}` converges, and that `s_n < 2` for `n=1,2,3, ...`.",
   "groups":
   [["∀ (s : ℕ → ℝ),\n  s 0 = Real.sqrt 2 →\n    (∀ (n : ℕ), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) →\n      (∃ l, Filter.Tendsto s Filter.atTop (nhds l)) ∧ ∀ (n : ℕ), s n < 2"],
    ["∀ (n : ℕ), 0 < Real.sqrtTwoAddSeries (0 / 1) n ∧ Real.sqrtTwoAddSeries (0 / 1) n < 2"],
    ["∀ (n : ℕ), 0 < n → Real.sqrtTwoAddSeries 0 n < 2"],
    ["∀ (n : ℕ), Real.sqrt (2 + Real.sqrtTwoAddSeries (0 / 1) n) < 2"],
    ["∀ (n : ℕ),\n  Real.sqrt (2 + Real.sqrtTwoAddSeries (0 / 1) n) < 2 ∧ Filter.Tendsto Real.sqrtTwoAddSeries Filter.atTop (nhds 0)"],
    ["∀ (s : ℕ → ℝ),\n  s 0 = Real.sqrt 2 →\n    (∀ (n : ℕ), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) →\n      Filter.Tendsto s Filter.atTop (nhds (Real.sqrt 2)) ∧ ∀ (n : ℕ), s n < 2"]],
   "correct": true,
   "comments": "Index shifted by 1.",
   "all-elabs":
   ["∀ (n : ℕ), 0 < Real.sqrtTwoAddSeries (↑0 / ↑1) n ∧ Real.sqrtTwoAddSeries (↑0 / ↑1) n < 2 ",
    "s_nat_converges_lt_2 : ∀ (n : ℕ), 0 < n → Real.sqrtTwoAddSeries 0 n < 2 ",
    "∀ (n : ℕ), Real.sqrt (2 + Real.sqrtTwoAddSeries (↑0 / ↑1) n) < 2 ",
    "∀ (n : ℕ), Real.sqrt (2 + Real.sqrtTwoAddSeries (↑0 / ↑1) n) < 2 ∧ Filter.Tendsto Real.sqrtTwoAddSeries Filter.atTop (nhds 0) ",
    "∀ (s : ℕ → ℝ),\n  s 0 = Real.sqrt 2 → (∀ (n : ℕ), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n)))\n  → Filter.Tendsto s Filter.atTop (nhds (Real.sqrt 2)) ∧ ∀ (n : ℕ), s n < 2 ",
    "∀ (s : ℕ → ℝ), (s 0 = Real.sqrt 2) → (∀ (n : ℕ), s (n + 1) = Real.sqrt (2 + Real.sqrt (s n))) → (∃ l, Filter.Tendsto s Filter.atTop (nhds l)) ∧ ∀ n, s n < 2 "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑i + 1) - Real.sqrt ↑i) Filter.atTop\n    Filter.atTop",
   "some-correct": null,
   "prompt":
   "Prove that `lim_{n→∞} Σ_{i<n} a_i = ∞`, where `a_i = √(i + 1) - √i`.",
   "groups":
   [["∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑i + 1) - Real.sqrt ↑i) Filter.atTop\n    Filter.atTop",
     "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑i + 1) - Real.sqrt ↑i) Filter.atTop\n    Filter.atTop",
     "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑i + 1) - Real.sqrt ↑i) Filter.atTop\n    Filter.atTop",
     "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑i + 1) - Real.sqrt ↑i) Filter.atTop\n    Filter.atTop"],
    ["∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt ↑(i + 1) - Real.sqrt ↑i) Filter.atTop\n    Filter.atTop"],
    ["∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]\n  [inst_3 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑i + 1) - Real.sqrt ↑i) Filter.atTop\n    Filter.atTop"]],
   "correct": true,
   "comments": "There are some extra assumptions which are not required.",
   "all-elabs":
   ["∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α] [inst_3 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
    "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
    "∀ {α : Type u_1} [inst : LinearOrderedAddCommGroup α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑(i + 1)) - Real.sqrt ↑i) Filter.atTop Filter.atTop ",
    "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (↑i + 1) - Real.sqrt ↑i) Filter.atTop Filter.atTop ",
    "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) fun i => Real.sqrt (i + 1) - Real.sqrt i) Filter.atTop Filter.atTop ",
    "∀ {α : Type u_1} [inst : LinearOrderedField α] [inst_1 : Archimedean α],\n  Filter.Tendsto (fun n => Finset.sum (Finset.range n) (λi => (Real.sqrt (i + 1) - Real.sqrt i))) Filter.atTop Filter.atTop "]},
  {"theorem":
   "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)",
   "some-correct": null,
   "prompt":
   "Suppose `{p_n}` is a Cauchy sequence in a metric space `X`, and some sequence `{p_{n l}}` converges to a point `p ∈ X`. Prove that the full sequence `{p_n}` converges to `p`.",
   "groups":
   [["∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)",
     "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)",
     "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)",
     "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)",
     "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)"],
    ["∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)",
     "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)"],
    ["∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α}\n  {ι : Type u_12} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n  CauchySeq u →\n    Filter.Tendsto f p Filter.atTop →\n      ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)"],
    ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {l : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto l p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ l) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)"],
    ["∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a)"]],
   "correct": true,
   "comments": "I think the nonempty β assumption is not required.",
   "all-elabs":
   ["∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {l : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto l p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ l) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α}\n  {ι : Type*} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n  CauchySeq u →\n    Filter.Tendsto f p Filter.atTop →\n      ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : Nonempty β] [inst_2 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_3 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) ",
    "∀ {α : Type u} {β : Type v} [inst : MetricSpace α] [inst_1 : SemilatticeSup β] {u : β → α},\n  CauchySeq u →\n    ∀ {ι : Type u_1} {f : ι → β} {p : Filter ι} [inst_2 : Filter.NeBot p],\n      Filter.Tendsto f p Filter.atTop →\n        ∀ {a : α}, Filter.Tendsto (u ∘ f) p (nhds a) → Filter.Tendsto u Filter.atTop (nhds a) "]},
  {"theorem":
   "∀ {α : Type u_1} [inst : MetricSpace α] [inst_1 : CompleteSpace α] {G : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n)",
   "some-correct": null,
   "prompt":
   "Suppose `X` is a nonempty complete metric space, and `{G_n}` is a sequence of dense open sets of `X`. Prove Baire's theorem, namely, that `∩_{n=1}^{∞} G_n` is not empty.",
   "groups":
   [["∀ {α : Type u_1} [inst : MetricSpace α] [inst_1 : CompleteSpace α] {G : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n)",
     "∀ {α : Type u_1} [inst : MetricSpace α] [inst_1 : CompleteSpace α] {f : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (f n) ∧ Dense (f n)) → Set.Nonempty (⋂ (n : ℕ), f n)",
     "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : ℕ → Set X},\n  (∀ (n : ℕ), IsOpen (G n) ∧ Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n)",
     "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : ℕ → Set X},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n)",
     "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : ℕ → Set X},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n)"],
    ["∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : ℕ → Set X},\n  (∀ (n : ℕ), IsOpen (G n) ∧ Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n)",
     "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : ℕ → Set X},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n)"],
    ["∀ {α : Type u_2} [inst : MetricSpace α] [inst_1 : CompleteSpace α] {β : Type u_1} [inst_2 : Encodable β]\n  {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s)"],
    ["∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {β : Type u_2} [inst_2 : Encodable β]\n  {G : β → Set X}, (∀ (n : β), IsOpen (G n)) → (∀ (n : β), Dense (G n)) → Set.Nonempty (⋂ (n : β), G n)"],
    ["∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (S n)) → (∀ (n : ℕ), Dense (S n)) → Set.Nonempty (⋂ (n : ℕ), S n)"]],
   "correct": true,
   "comments": "Index shifted by 1.",
   "all-elabs":
   ["∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {β : Type u_2} [inst_2 : Encodable β]\n  {G : β → Set X}, (∀ (n : β), IsOpen (G n)) → (∀ (n : β), Dense (G n)) → Set.Nonempty (⋂ (n : β), G n) ",
    "∀ {α : Type u_1} [inst : MetricSpace α] [inst_1 : CompleteSpace α] {G : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n) ",
    "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : ℕ → Set X},\n  (∀ n, IsOpen (G n) ∧ Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n) ",
    "forall {α : Type u_1} [inst : MetricSpace α] [inst_1 : CompleteSpace α] {f : ℕ → Set α},\n  (∀ (n : ℕ), IsOpen (f n) ∧ Dense (f n)) → Set.Nonempty (⋂ (n : ℕ), f n) ",
    "forall {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : BaireSpace α] {S : ℕ → Set α},\n  (∀ n, IsOpen (S n)) → (∀ n, Dense (S n)) → Set.Nonempty (⋂ n, S n) ",
    "∀ {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : ℕ → Set X},\n  (∀ n, IsOpen (G n) ∧ Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n) ",
    "∀ {α : Type u_2} [inst : MetricSpace α] [inst_1 : CompleteSpace α] {β : Type u_1} [inst_2 : Encodable β]\n  {f : β → Set α}, (∀ (s : β), IsOpen (f s)) → (∀ (s : β), Dense (f s)) → Set.Nonempty (⋂ (s : β), f s) ",
    "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : ℕ → Set X},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n) ",
    "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] {G : ℕ → Set X},\n  (∀ n, IsOpen (G n)) → (∀ n, Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n) ",
    "forall {X : Type u_1} [inst : MetricSpace X] [inst_1 : CompleteSpace X] [inst_2 : Nonempty X] {G : ℕ → Set X},\n  (∀ (n : ℕ), IsOpen (G n)) → (∀ (n : ℕ), Dense (G n)) → Set.Nonempty (⋂ (n : ℕ), G n) "]},
  {"theorem":
   "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X → Y},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))",
   "some-correct": null,
   "prompt":
   "If `f` is a continuous mapping of a metric space `X` into a metric space `Y`, prove that `f(∂E) ⊆ ∂f(E)` for every set `E ⊆ X`. (`∂E` denotes the closure of `E`).",
   "groups":
   [["∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X → Y},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X → Y) (E : Set X),\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))"],
    ["∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))",
     "∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))",
     "∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E))"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f : X → Y},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E)) ",
    "forall {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y]\n  {f : X → Y} {E : Set X},\n    Continuous f → Set.MapsTo f (closure E) (closure (f '' E)) ",
    "∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E)) ",
    "forall {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (f : X → Y) (E : Set X),\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E)) ",
    " ∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E)) ",
    "∀ {X : Type u} {Y : Type v} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E)) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : MetricSpace Y] {f : X → Y} {E : Set X},\n  Continuous f → Set.MapsTo f (closure E) (closure (f '' E)) "]},
  {"theorem":
   "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X]\n  [inst_3 : MetricSpace Y] {f g : X → Y} {E : Set X}, Dense E → Continuous f → Continuous g → Dense (f '' E)",
   "some-correct": false,
   "prompt":
   "Let `f` and `g` be continuous mappings of a metric space `X` into a metric space `Y`, and let `E` be a dense subset of `X`. Prove that `f(E)` is dense in `f(X)`.",
   "groups":
   [["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X]\n  [inst_3 : MetricSpace Y] {f g : X → Y} {E : Set X}, Dense E → Continuous f → Continuous g → Dense (f '' E)",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y]\n  [inst_3 : MetricSpace Y] {f : X → Y} {E : Set X} {g : X → Y}, Continuous f → Continuous g → Dense E → Dense (f '' E)",
     "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y]\n  [inst_3 : MetricSpace Y] {f g : X → Y} {E : Set X}, Dense E → Continuous f → Continuous g → Dense (f '' E)"],
    ["∀ {X : Type u_12} {Y : Type u_13} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X]\n  [inst_3 : MetricSpace Y] {f g : X → Y} (E : Set X), Dense E → Continuous f → Continuous g → Dense (f '' E)"],
    ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f g : X → Y},\n  Continuous f → Continuous g → Dense E → Dense (f '' E)"]],
   "correct": false,
   "comments": "We get the output that f(E) is dense in Y, not f(X). Same problem occurs for all other outputs.",
   "all-elabs":
   ["∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace Y] {E : Set X} {f g : X → Y},\n  Continuous f → Continuous g → Dense E → Dense (f '' E) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : MetricSpace X] [inst_3 : MetricSpace Y]\n  {f g : X → Y} {E : Set X},\n  Dense E → Continuous f → Continuous g → Dense (f '' E) ",
    "forall {X Y : Type*} [topological_space X] [topological_space Y] [metric_space X] [metric_space Y] {f g : X → Y} (E : set X),\n  dense E → continuous f → continuous g → dense (f '' E) ",
    "∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X] [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y]\n  {f : X → Y} {E : Set X} {g : X → Y}, Continuous f → Continuous g → Dense E → Dense (f '' E) ",
    "forall {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : MetricSpace X]\n  [inst_2 : TopologicalSpace Y] [inst_3 : MetricSpace Y] {f g : X -> Y} {E : Set X},\n  Dense E ->\n  Continuous f ->\n  Continuous g ->\n  Dense (f '' E) "]},
  {"theorem":
   "∀ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {E : Set Y} (f : C(↑E, ℝ)),\n  IsClosed E → ∃ g, ContinuousMap.restrict E g = f",
   "some-correct": false,
   "prompt":
   "If `f` is a real continuous function defined on a closed set `E ⊆ ℝ`, prove that there exist continuous real functions `g` on `ℝ` such that `g(x)=f(x)` for all `x ∈ E`.",
   "groups":
   [["∀ {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {E : Set Y} (f : C(↑E, ℝ)),\n  IsClosed E → ∃ g, ContinuousMap.restrict E g = f"]],
   "correct": false,
   "comments": "The statement is not incorrect, however it is a generalization of what is asked, and misses the condition that `E ⊆ ℝ`. Same thing for others.",
   "all-elabs":
   ["forall {Y : Type u_1} [inst : TopologicalSpace Y] [inst_1 : NormalSpace Y] {E : Set Y} (f : C(↑E, ℝ)),\n  IsClosed E → ∃ g, ContinuousMap.restrict E g = f "]},
  {"theorem":
   "∀ {E : Set ℝ}, Metric.Bounded E → ∃ f, UniformContinuous f ∧ ∀ (C : ℝ), ∃ x, x ∈ E ∧ C < |f x|",
   "some-correct": null,
   "prompt":
   "Let `E` be a bounded set in `ℝ^1`. Prove that there exists a real function `f` such that `f` is uniformly continuous and is not bounded on `E`.",
   "groups":
   [["∀ {E : Set ℝ}, Metric.Bounded E → ∃ f, UniformContinuous f ∧ ∀ (C : ℝ), ∃ x, x ∈ E ∧ C < |f x|"],
    ["∀ {E : Set ℝ}, Metric.Bounded E → ∃ f, UniformContinuous f ∧ ∀ (M : ℝ), ∃ x H, M < f x"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {E : Set ℝ} (hE : Metric.Bounded E),\n  ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ∀ (M : ℝ), ∃ (x : ℝ) (H : x ∈ E), M < f x ",
    "∀ {E : Set ℝ}, Metric.Bounded E → ∃ (f : ℝ → ℝ), UniformContinuous f ∧ ∀ (C : ℝ), ∃ x ∈ E, C < |f x| "]},
  {"theorem":
   "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {g : α → β} {f : β → γ},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (f ∘ g)",
   "some-correct": null,
   "prompt":
   "A uniformly continuous function of a uniformly continuous function is uniformly continuous.",
   "groups":
   [["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {g : α → β} {f : β → γ},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (f ∘ g)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (g : β → γ) (f : α → β),\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)",
     "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β]\n  [inst_2 : UniformSpace γ] {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f)"]],
   "correct": null,
   "comments": "",
   "all-elabs":
   ["∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {g : α → β} {f : β → γ},\n  UniformContinuous g → UniformContinuous f → UniformContinuous (f ∘ g) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (g : β → γ) (f : α → β),\n  UniformContinuous g → UniformContinuous f → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ), UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "forall {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  (f : α → β) (g : β → γ),\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ},\n  UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) ",
    "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : UniformSpace α] [inst_1 : UniformSpace β] [inst_2 : UniformSpace γ]\n  {f : α → β} {g : β → γ}, UniformContinuous f → UniformContinuous g → UniformContinuous (g ∘ f) "]},
  {"theorem":
   "∀ {f : ℝ → ℝ},\n  (∀ {a b c : ℝ}, a < b → f a < c → c < f b → ∃ x, x ∈ Set.Ioo a b ∧ f x = c) →\n    (∀ (q : ℚ), IsClosed {x | f x = ↑q}) → Continuous f",
   "some-correct": null,
   "prompt":
   "Suppose `f` is a real function with domain `ℝ^1` which has the intermediate value property: if `f(a) < c < f(b)`, then `f(x) = c` for some `x` between `a` and `b`. Suppose also, for every rational `r`, that the set of all `x` with `f(x) = r` is closed. Prove that `f` is continuous.",
   "groups":
   [["∀ {f : ℝ → ℝ},\n  (∀ {a b c : ℝ}, a < b → f a < c → c < f b → ∃ x, x ∈ Set.Ioo a b ∧ f x = c) →\n    (∀ (q : ℚ), IsClosed {x | f x = ↑q}) → Continuous f"],
    ["∀ {f : ℝ → ℝ},\n  (∀ (a b c : ℝ), f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n    (∀ (q : ℚ), IsClosed {x | f x = ↑q}) → Continuous f"]],
   "correct": true,
   "comments": "Translation seems refined",
   "all-elabs":
   ["forall {f : ℝ → ℝ},\n  (∀ a b c, f a < c → c < f b → ∃ x, a < x ∧ x < b ∧ f x = c) →\n  (∀ q : ℚ, is_closed {x | f x = q}) →\n  continuous f ",
    "forall {f : ℝ → ℝ},\n  (∀ {a b : ℝ} {c : ℝ}, a < b → f a < c → c < f b → ∃ x, x ∈ set.Ioo a b ∧ f x = c) →\n  (∀ (q : ℚ), is_closed {x : ℝ | f x = ↑q}) →\n  continuous f ",
    "forall {f : ℝ → ℝ} (hmono : ∀ a b : ℝ, a < b → a < f a → f a < f b → f b < b),\n  (forall (q : ℚ) (x : ℝ), f x = q → ∃ s hs, x ∈ s ∧ IsClosed s) →\n  Continuous f "]},
  {"theorem":
   "∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f",
   "some-correct": null,
   "prompt":
   "Assume that `f` is a continuous real function defined in `(a, b)` such that `f((x+y)/2) ≤ (f(x)+f(y))/2` for all `x, y ∈ (a, b)`. Prove that `f` is convex.",
   "groups":
   [["∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f",
     "∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f",
     "∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f",
     "∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f",
     "∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f"],
    ["∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) ≤ a • f x + b • f y) →\n      ConvexOn 𝕜 s f"],
    ["∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜] {s : Set 𝕜}\n  {f : 𝕜 → 𝕜},\n  ContinuousOn f s → (∀ ⦃x : 𝕜⦄, x ∈ s → ∀ ⦃y : 𝕜⦄, y ∈ s → x < y → f ((x + y) / 2) ≤ (f x + f y) / 2) → ConvexOn 𝕜 s f"],
    ["∀ {s : Set ℝ} {f : ℝ → ℝ},\n  Convex ℝ s →\n    (∀ ⦃x y : ℝ⦄, x ∈ s → y ∈ s → ∀ ⦃a b : ℝ⦄, 0 < a → 0 < b → a + b = 2 → f ((a • x + b • y) / 2) ≤ (f x + f y) / 2) →\n      ConvexOn ℝ s f"]],
   "correct": true,
   "comments": "",
   "all-elabs":
   ["∀ {𝕜 : Type u_1} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜] {s : Set 𝕜}\n  {f : 𝕜 → 𝕜},\n  ContinuousOn f s →\n    (∀ ⦃x : 𝕜⦄,\n        x ∈ s →\n          ∀ ⦃y : 𝕜⦄, y ∈ s → x < y → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n      ConvexOn 𝕜 s f ",
    "∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ x y : ℝ, x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f ",
    "forall {a b : ℝ} (hab : a < b),\n  ∀ {f : ℝ → ℝ},\n    ContinuousOn f (Set.Ioo a b) →\n    (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n    ConvexOn ℝ (Set.Ioo a b) f ",
    "∀ {a b : ℝ},\n  a < b →\n    ∀ {f : ℝ → ℝ},\n      ContinuousOn f (Set.Ioo a b) →\n        (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n          ConvexOn ℝ (Set.Ioo a b) f ",
    "∀ {s : Set ℝ} {f : ℝ → ℝ},\n  Convex ℝ s →\n    (∀ ⦃x y : ℝ⦄,\n        x ∈ s →\n          y ∈ s → ∀ ⦃a b : ℝ⦄, 0 < a → 0 < b → a + b = 2 → f ((a • x + b • y) / 2) ≤ (f x + f y) / 2) →\n      ConvexOn ℝ s f ",
    "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_3} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] [inst_5 : LinearOrder E] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → x < y → ∀ ⦃a b : 𝕜⦄, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) ≤ a • f x + b • f y) →\n      ConvexOn 𝕜 s f ",
    "∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]\n  [inst_2 : OrderedAddCommMonoid β] [inst_3 : Module 𝕜 E] [inst_4 : Module 𝕜 β] {s : Set E}\n  {f : E → β},\n  Convex 𝕜 s →\n    (∀ ⦃x : E⦄,\n        x ∈ s →\n          ∀ ⦃y : E⦄, y ∈ s → (∀ (z : E), z = (x + y) / 2 → f z ≤ (f x + f y) / 2)) →\n      ConvexOn 𝕜 s f ",
    "∀ {a b : ℝ} (hab : a < b) {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ioo a b) →\n    (∀ (x y : ℝ), x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n      ConvexOn ℝ (Set.Ioo a b) f ",
    "forall {a b : ℝ} (hab : a < b) {f : ℝ → ℝ},\n  ContinuousOn f (Set.Ioo a b) →\n    (∀ x y : ℝ, x ∈ Set.Ioo a b → y ∈ Set.Ioo a b → f ((x + y) / 2) ≤ (f x + f y) / 2) →\n      ConvexOn ℝ (Set.Ioo a b) f "]}],
 "elaborated": 20}